// Arena Breakout Infinite - Flat Offset List
// Format: Class.Property = 0xOFFSET

AnimBoneCompressionCodec_ACL.SafetyFallbackCodec = 0x38 // AnimBoneCompressionCodec* (Size: 0x8)
AnimBoneCompressionCodec_ACLDatabase.DatabaseAsset = 0x38 // AnimationCompressionLibraryDatabase* (Size: 0x8)
AnimationCompressionLibraryDatabase.CookedCompressedBytes = 0x28 // TArray<uint8_t> (Size: 0x10)
AnimationCompressionLibraryDatabase.CookedAnimSequenceMappings = 0x38 // TArray<uint64_t> (Size: 0x10)
AnimationCompressionLibraryDatabase.MaxStreamRequestSizeKB = 0x158 // uint32_t (Size: 0x4)
ActionPointData.UniqueIndex = 0x0 // int32_t (Size: 0x4)
ActionPointData.Location = 0x4 // FVector (Size: 0xc)
ActionPointEditorActor.ActionPointType = 0x310 // EEActionPointType (Size: 0x1)
ActionPointEditorActor.ProjectDistanceOfNavigationMesh = 0x314 // float (Size: 0x4)
ActionPointEditorActor.DRootComponent = 0x318 // SceneComponent* (Size: 0x8)
ActionPointEditorActor.SpotComponent = 0x320 // PrimitiveComponent* (Size: 0x8)
ActionPointEditorActor.WarnComponent = 0x328 // PrimitiveComponent* (Size: 0x8)
ActionPointEditorActor.ArrowComponent = 0x330 // ArrowComponent* (Size: 0x8)
ActionPointRadianSafe.Radian = 0x0 // float (Size: 0x4)
ActionPointRadianSafe.CoverDistance = 0x4 // float (Size: 0x4)
ActionPointSystemActor.PointToOtherNavPathLengths = 0x310 // TMap<...> (Size: 0x50)
ActionPointSystemActor.MAX_NAV_PATH_DISTANCE = 0x360 // float (Size: 0x4)
ActionPointSystemActor.PointToOtherNavPathLengthsCount = 0x364 // int32_t (Size: 0x4)
BPTacticPointEditorActor.BPTacticType = 0x318 // int32_t (Size: 0x4)
BPTacticPointEditorActor.PointData = 0x320 // FTacticPointData (Size: 0x70)
ChangeNotifyingRecastNavMesh.NavmeshTilesUpdatedImmediateDelegate = 0x6a0 // FMulticastInlineDelegate (Size: 0x10)
ChangeNotifyingRecastNavMesh.NavmeshTilesUpdatedBufferedDelegate = 0x6b0 // FMulticastInlineDelegate (Size: 0x10)
ChangeNotifyingRecastNavMesh.NavmeshTilesUpdatedUntilFinishedDelegate = 0x6c0 // FMulticastInlineDelegate (Size: 0x10)
CoverFinderVisData.DebugPoints = 0x28 // TArray<FDebugPoint> (Size: 0x10)
CoverFinderVisData.DebugArrows = 0x38 // TArray<FDebugArrow> (Size: 0x10)
CoverPointOctreeData.CoverID = 0x0 // int32_t (Size: 0x4)
CoverPointOctreeData.PointType = 0x4 // EEActionPointType (Size: 0x1)
CoverPointOctreeData.Location = 0x10 // FVector (Size: 0xc)
CoverPointOctreeData.Direction = 0x1c // FVector (Size: 0xc)
CoverPointOctreeData.RightDirection = 0x28 // FVector (Size: 0xc)
CoverPointOctreeData.PoseData = 0x38 // TArray<FCoverPoseData> (Size: 0x10)
CoverPointRuntimeInfo.TakenActor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
CoverPointRuntimeInfo.TakenBeginTime = 0x8 // float (Size: 0x4)
CoverPointRuntimeInfo.NextAvailableTime = 0xc // float (Size: 0x4)
CoverPointRuntimeInfo.LastSpottedTime = 0x10 // float (Size: 0x4)
CoverPointTestingActor.CapsuleComponent = 0x310 // CapsuleComponent* (Size: 0x8)
CoverPointTestingActor.GeneratorActor = 0x318 // CoverSystemActor* (Size: 0x8)
CoverPointTestingActor.NavAgentProps = 0x398 // FNavAgentProperties (Size: 0x30)
CoverPointTestingActor.QueryingExtent = 0x3c8 // FVector (Size: 0xc)
CoverPointTestingActor.GroundOffset = 0x3d4 // float (Size: 0x4)
CoverPointTestingActor.EndPointSize = 0x3d8 // float (Size: 0x4)
CoverPointTestingActor.EdgeThickness = 0x3dc // float (Size: 0x4)
CoverPointTestingActor.CoverPointSize = 0x3e0 // float (Size: 0x4)
CoverPointTestingActor.bDrawCoverPoint = 0x3e4 // uint8_t (Size: 0x1)
CoverPointTestingActor.bDrawDefenceMap = 0x3e4 // uint8_t (Size: 0x1)
CoverPointTestingActor.bDrawDefenceWall = 0x3e4 // uint8_t (Size: 0x1)
CoverPointTestingActor.bDrawDefenceAngle = 0x3e4 // uint8_t (Size: 0x1)
CoverPointTestingActor.bDrawFireTrace = 0x3e4 // uint8_t (Size: 0x1)
CoverPointTestingActor.bEdgeChanged = 0x3e5 // bool (Size: 0x1)
CoverPointTestingActor.TargetActor = 0x3e8 // Actor* (Size: 0x8)
CoverPointTestingActor.EdgeDataEditor = 0x460 // FNavMeshEdgeCoverDataEditor (Size: 0x1)
CoverPointTestingActor.PointDataEditor = 0x4c8 // FDTOCoverDataEditor (Size: 0x1)
CoverPointTestingActor.SincePoint = 0x4cc // FVector (Size: 0xc)
CoverPointTestingActor.UntilPoint = 0x4d8 // FVector (Size: 0xc)
CoverPointTestingActor.SegmentRatio = 0x4e4 // float (Size: 0x4)
CoverPointTestingActor.SegmentLength = 0x4e8 // float (Size: 0x4)
CoverPoseData.PoseType = 0x0 // EENPCPoseType (Size: 0x1)
CoverPoseData.bLShootable = 0x1 // uint8_t (Size: 0x1)
CoverPoseData.bRShootable = 0x1 // uint8_t (Size: 0x1)
CoverPoseData.bMShootable = 0x1 // uint8_t (Size: 0x1)
CoverPoseData.Location = 0x4 // FVector (Size: 0xc)
CoverPoseData.Direction = 0x10 // FVector (Size: 0xc)
CoverPoseData.DefenceRatio = 0x1c // float (Size: 0x4)
CoverPoseData.LDefenceAngle = 0x20 // float (Size: 0x4)
CoverPoseData.RDefenceAngle = 0x24 // float (Size: 0x4)
CoverSystem.CoverPointRuntimeInfoMap = 0x98 // TMap<...> (Size: 0x50)
CoverSystem.ActorTakeCoverPointMap = 0xe8 // TMap<...> (Size: 0x50)
CoverSystem.NavMesh = 0x188 // ChangeNotifyingRecastNavMesh* (Size: 0x8)
CoverSystem.bDebugDraw = 0x191 // bool (Size: 0x1)
CoverSystem.CoverPointGenerator = 0x198 // CoverSystemActor* (Size: 0x8)
CoverSystem.TacticPointGenerator = 0x1a0 // TacticSystemActor* (Size: 0x8)
CoverSystemActor.CoverSystem = 0x368 // CoverSystem* (Size: 0x8)
CoverSystemActor.RawCoverPoints = 0x370 // TArray<FDTOCoverData> (Size: 0x10)
CoverSystemActor.GeneratorVersion = 0x478 // int32_t (Size: 0x4)
CoverSystemActor.PoseSamplingConfigs = 0x480 // TArray<FNavMeshCoverPointPoseSamplingConfig> (Size: 0x10)
CoverSystemActor.bTestEndpointMovable = 0x490 // bool (Size: 0x1)
CoverSystemActor.bTraceComplex = 0x491 // bool (Size: 0x1)
CoverSystemActor.TraceChannel = 0x492 // uint8_t (Size: 0x1)
CoverSystemActor.RejectedActorNames = 0x498 // TArray<FString> (Size: 0x10)
CoverSystemActor.ExclusionVolumes = 0x4a8 // TArray<Volume*> (Size: 0x10)
CoverSystemActor.GeneratableEdgeMinLength = 0x4b8 // float (Size: 0x4)
CoverSystemActor.HoleTestOffset = 0x4bc // float (Size: 0x4)
CoverSystemActor.SamplingHeight = 0x4c0 // float (Size: 0x4)
CoverSystemActor.SamplingWidth = 0x4c4 // float (Size: 0x4)
CoverSystemActor.HalfAbsoluteWidth = 0x4c8 // float (Size: 0x4)
CoverSystemActor.HalfShoulderWidth = 0x4cc // float (Size: 0x4)
CoverSystemActor.ScanStep = 0x4d0 // float (Size: 0x4)
CoverSystemActor.ScanReach = 0x4d4 // float (Size: 0x4)
CoverSystemActor.CoverPointMinDistance = 0x4d8 // float (Size: 0x4)
CoverSystemActor.CoverPointGroundOffset = 0x4dc // float (Size: 0x4)
CoverSystemActor.FireTestOffset = 0x4e0 // float (Size: 0x4)
CoverSystemActor.FireLineRadius = 0x4e4 // float (Size: 0x4)
CoverSystemActor.FireLineLength = 0x4e8 // float (Size: 0x4)
CoverSystemActor.DefenceTraceLength = 0x4ec // float (Size: 0x4)
CoverSystemActor.DefenceAngleStep = 0x4f0 // float (Size: 0x4)
CoverSystemActor.RemoveDistance = 0x4f4 // float (Size: 0x4)
CoverSystemActor.RemoveAngle = 0x4f8 // float (Size: 0x4)
CoverSystemActor.CliffEdgeDistance = 0x4fc // float (Size: 0x4)
CoverSystemActor.StraightCliffErrorTolerance = 0x500 // float (Size: 0x4)
CoverSystemActor.bEnableNavmeshHeightCorrection = 0x504 // bool (Size: 0x1)
CoverSystemActor.bUseFastTestNoDefenceRegion = 0x505 // bool (Size: 0x1)
CoverSystemActor.bParallelNavMeshTile = 0x506 // bool (Size: 0x1)
CoverSystemActor.bParallelDefenceTest = 0x507 // bool (Size: 0x1)
CoverSystemActor.bParallelDefenceAngle = 0x508 // bool (Size: 0x1)
CoverSystemActor.bParallelCollectBoundaryEdge = 0x509 // bool (Size: 0x1)
CoverSystemActor.bParallelGenerateSamplePoint = 0x50a // bool (Size: 0x1)
CoverSystemActor.bParallelGenerateDefenceMapPoint = 0x50b // bool (Size: 0x1)
CoverSystemActor.bParallelCalculatePointDefenceRatio = 0x50c // bool (Size: 0x1)
CoverSystemActor.bParallelCalculatePointDefenceAngle = 0x50d // bool (Size: 0x1)
CoverSystemActor.CoverPointRuntimeInfoExpireTime = 0x510 // float (Size: 0x4)
CoverSystemActor.bInitOctree = 0x514 // bool (Size: 0x1)
CoverSystemActor.bKeepRemoved = 0x515 // bool (Size: 0x1)
CoverSystemActor.bDebugDraw = 0x516 // bool (Size: 0x1)
DTOCoverData.NavPolyRef = 0x10 // uint64_t (Size: 0x8)
DTOCoverData.EdgeIndex = 0x18 // int32_t (Size: 0x4)
DTOCoverData.bCustomized = 0x1c // uint8_t (Size: 0x1)
DTOCoverData.bMarked = 0x1c // uint8_t (Size: 0x1)
DTOCoverData.bAddable = 0x1c // uint8_t (Size: 0x1)
DTOCoverData.bLMovable = 0x1c // uint8_t (Size: 0x1)
DTOCoverData.bRMovable = 0x1c // uint8_t (Size: 0x1)
DTOCoverData.BaseWeight = 0x20 // float (Size: 0x4)
DTOCoverData.Rotation = 0x24 // FRotator (Size: 0xc)
DTOCoverData.RightDir = 0x30 // FVector (Size: 0xc)
DTOCoverData.PoseData = 0x40 // TArray<FCoverPoseData> (Size: 0x10)
DebugArrow.Start = 0x0 // FVector (Size: 0xc)
DebugArrow.End = 0xc // FVector (Size: 0xc)
DebugArrow.Color = 0x18 // FColor (Size: 0x4)
DebugArrow.bGenericOrUnitDebugData = 0x1c // bool (Size: 0x1)
DebugPoint.Location = 0x0 // FVector (Size: 0xc)
DebugPoint.Color = 0xc // FColor (Size: 0x4)
DebugPoint.bGenericOrUnitDebugData = 0x10 // bool (Size: 0x1)
DoorPointTmpBuildData.Location = 0x0 // FVector (Size: 0xc)
DoorPointTmpBuildData.IsSafety = 0xc // bool (Size: 0x1)
DoorPointTmpBuildData.RelevanceIndex = 0x10 // int32_t (Size: 0x4)
DoorPointTmpBuildData.DangerValue = 0x14 // int32_t (Size: 0x4)
KeyRouteAssistActor.ParentPointEdActor = 0x310 // Actor* (Size: 0x8)
KeyRoutePointData.PointID = 0x10 // int32_t (Size: 0x4)
KeyRoutePointData.Radius = 0x14 // float (Size: 0x4)
KeyRoutePointData.MaxNavPathForMultipleOfRadius = 0x18 // float (Size: 0x4)
KeyRoutePointData.LinkPoints = 0x20 // TArray<FKeyRoutePointLink> (Size: 0x10)
KeyRoutePointData.OrientSafetys = 0x30 // TArray<FActionPointRadianSafe> (Size: 0x10)
KeyRoutePointData.DangerValue = 0x40 // float (Size: 0x4)
KeyRoutePointData.CalculateDangerTime = 0x44 // float (Size: 0x4)
KeyRoutePointData.PolyRef = 0x48 // int64_t (Size: 0x8)
KeyRoutePointData.NeighborPolyRefs = 0x50 // TArray<int64_t> (Size: 0x10)
KeyRoutePointLink.Index = 0x0 // int32_t (Size: 0x4)
KeyRoutePointLink.NavPathLength = 0x4 // float (Size: 0x4)
KeyRouteSkeletonEditPoint.UniqueID = 0x8 // int32_t (Size: 0x4)
KeyRouteSkeletonEditPoint.Location = 0xc // FVector (Size: 0xc)
KeyRouteSkeletonEditPoint.DistanceToWall = 0x18 // float (Size: 0x4)
KeyRouteSkeletonEditPoint.bDistanceToWallSmall = 0x1c // bool (Size: 0x1)
KeyRouteSkeletonEditPoint.ConnectionCount = 0x20 // int32_t (Size: 0x4)
KeyRouteSkeletonEditPoint.Score = 0x24 // float (Size: 0x4)
KeyRouteSkeletonEditPoint.IsJunction = 0x28 // bool (Size: 0x1)
NavMeshCoverPointPoseSamplingConfig.PoseType = 0x0 // EENPCPoseType (Size: 0x1)
NavMeshCoverPointPoseSamplingConfig.DefenceHeight = 0x4 // float (Size: 0x4)
NavMeshCoverPointPoseSamplingConfig.DefenceRatio = 0x8 // float (Size: 0x4)
NavMeshCoverPointPoseSamplingConfig.FireHeight = 0xc // float (Size: 0x4)
NavMeshCoverPointPoseSamplingConfig.RequiredMinimumDefenceAngle = 0x10 // float (Size: 0x4)
NavMeshCoverPointPoseSamplingConfig.LimitedMaximumDefenceAngle = 0x14 // float (Size: 0x4)
NavMeshTacticPointBuilder.CoverSystemActor = 0x0 // CoverSystemActor* (Size: 0x8)
NavMeshTacticPointBuilder.World = 0x28 // World* (Size: 0x8)
NavMeshTacticPointBuilder.MainNavData = 0x30 // RecastNavMesh* (Size: 0x8)
SeekANode.Index = 0x0 // int32_t (Size: 0x4)
SeekANode.ParentIndex = 0x4 // int32_t (Size: 0x4)
SeekANode.NowCost = 0x8 // float (Size: 0x4)
SeekANode.CostFromBot = 0xc // float (Size: 0x4)
SeekANode.CostEstimate = 0x10 // float (Size: 0x4)
TacticPointData.TacticPointType = 0x10 // EETacticPointType (Size: 0x1)
TacticPointData.PointID = 0x14 // int32_t (Size: 0x4)
TacticPointData.Interval = 0x18 // float (Size: 0x4)
TacticPointData.AlwaysActivated = 0x1c // bool (Size: 0x1)
TacticPointData.ShouldCrouch = 0x1d // bool (Size: 0x1)
TacticPointData.GuardTargetAndDirections = 0x20 // TArray<FTacticPointGuardTargetAndDirection> (Size: 0x10)
TacticPointData.FieldTrace = 0x30 // bool (Size: 0x1)
TacticPointData.Radius = 0x34 // float (Size: 0x4)
TacticPointData.bCustomized = 0x38 // uint8_t (Size: 0x1)
TacticPointData.ActorID = 0x3c // uint32_t (Size: 0x4)
TacticPointData.IndRelatedToActor = 0x40 // int8_t (Size: 0x1)
TacticPointData.CustomValue = 0x44 // float (Size: 0x4)
TacticPointData.CustomVector = 0x48 // FVector (Size: 0xc)
TacticPointData.Rotation = 0x54 // FRotator (Size: 0xc)
TacticPointData.OrientSafetys = 0x60 // TArray<FActionPointRadianSafe> (Size: 0x10)
TacticPointGuardDotActor.ParentEditPoint = 0x310 // TacticPointEditorActor* (Size: 0x8)
TacticPointGuardDotActor.IndexOfGuard = 0x318 // int32_t (Size: 0x4)
TacticPointGuardDotActor.bArrowDir = 0x31c // bool (Size: 0x1)
TacticPointGuardTargetAndDirection.Location = 0x0 // FVector (Size: 0xc)
TacticPointGuardTargetAndDirection.Direction = 0xc // FRotator (Size: 0xc)
TacticPointTypeColor.None_Color = 0x0 // FLinearColor (Size: 0x10)
TacticPointTypeColor.FlashBag_Color = 0x10 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Smoke_Color = 0x20 // FLinearColor (Size: 0x10)
TacticPointTypeColor.HighValue_Color = 0x30 // FLinearColor (Size: 0x10)
TacticPointTypeColor.FatalGate_Color = 0x40 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Escape_Color = 0x50 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Trap_Color = 0x60 // FLinearColor (Size: 0x10)
TacticPointTypeColor.OverWatch_Color = 0x70 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Prone_Color = 0x80 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Window_Color = 0x90 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Door_Color = 0xa0 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Retreat_Color = 0xb0 // FLinearColor (Size: 0x10)
TacticPointTypeColor.Transfer_Color = 0xc0 // FLinearColor (Size: 0x10)
TacticSystemActor.CoverSystem = 0x368 // CoverSystem* (Size: 0x8)
TacticSystemActor.TacticPoints = 0x370 // TArray<FTacticPointData> (Size: 0x10)
TacticSystemActor.DoorTacticPoints = 0x380 // TArray<FTacticPointData> (Size: 0x10)
TacticSystemActor.WindowTacticPoints = 0x390 // TArray<FTacticPointData> (Size: 0x10)
TacticSystemActor.EscapeTacticPoints = 0x3a0 // TArray<FTacticPointData> (Size: 0x10)
TacticSystemActor.TacticPointTypeColor = 0x3b0 // FTacticPointTypeColor (Size: 0xd0)
TacticSystemActor.GenerateOrientSafetyTypes = 0x480 // TArray<EETacticPointType> (Size: 0x10)
TacticSystemActor.KeyRoutePoints = 0x490 // TArray<FKeyRoutePointData> (Size: 0x10)
TacticSystemActor.KeyRoutePointsChians = 0x4a0 // TMap<...> (Size: 0x50)
TacticSystemActor.NumOfOrientPointSafe = 0x4f0 // int32_t (Size: 0x4)
TacticSystemActor.LengthOfOrientPointSafe = 0x4f4 // int32_t (Size: 0x4)
TakeCoverPointIDListInfo.List = 0x0 // TArray<int32_t> (Size: 0x10)
AIAsyncTaskBlueprintProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
AIAsyncTaskBlueprintProxy.OnFail = 0x38 // FMulticastInlineDelegate (Size: 0x10)
AIController.bStartAILogicOnPossess = 0x3c0 // uint8_t (Size: 0x1)
AIController.bStopAILogicOnUnposses = 0x3c0 // uint8_t (Size: 0x1)
AIController.bLOSflag = 0x3c0 // uint8_t (Size: 0x1)
AIController.bSkipExtraLOSChecks = 0x3c0 // uint8_t (Size: 0x1)
AIController.bAllowStrafe = 0x3c0 // uint8_t (Size: 0x1)
AIController.bWantsPlayerState = 0x3c0 // uint8_t (Size: 0x1)
AIController.bSetControlRotationFromPawnOrientation = 0x3c0 // uint8_t (Size: 0x1)
AIController.PathFollowingComponent = 0x3c8 // PathFollowingComponent* (Size: 0x8)
AIController.BrainComponent = 0x3d0 // BrainComponent* (Size: 0x8)
AIController.PerceptionComponent = 0x3d8 // AIPerceptionComponent* (Size: 0x8)
AIController.ActionsComp = 0x3e0 // PawnActionsComponent* (Size: 0x8)
AIController.Blackboard = 0x3e8 // BlackboardComponent* (Size: 0x8)
AIController.CachedGameplayTasksComponent = 0x3f0 // GameplayTasksComponent* (Size: 0x8)
AIController.DefaultNavigationFilterClass = 0x3f8 // ClassProperty (Size: 0x8)
AIController.ReceiveMoveCompleted = 0x400 // FMulticastInlineDelegate (Size: 0x10)
AIDamageEvent.Amount = 0x0 // float (Size: 0x4)
AIDamageEvent.Location = 0x4 // FVector (Size: 0xc)
AIDamageEvent.HitLocation = 0x10 // FVector (Size: 0xc)
AIDamageEvent.DamagedActor = 0x20 // Actor* (Size: 0x8)
AIDamageEvent.Instigator = 0x28 // Actor* (Size: 0x8)
AIDamageEvent.Tag = 0x30 // FName (Size: 0x8)
AIDataProviderBoolValue.DefaultValue = 0x30 // bool (Size: 0x1)
AIDataProviderFloatValue.DefaultValue = 0x30 // float (Size: 0x4)
AIDataProviderIntValue.DefaultValue = 0x30 // int32_t (Size: 0x4)
AIDataProviderTypedValue.PropertyType = 0x20 // ClassProperty (Size: 0x8)
AIDataProviderValue.DataBinding = 0x10 // AIDataProvider* (Size: 0x8)
AIDataProviderValue.DataField = 0x18 // FName (Size: 0x8)
AIDataProvider_QueryParams.ParamName = 0x28 // FName (Size: 0x8)
AIDataProvider_QueryParams.FloatValue = 0x30 // float (Size: 0x4)
AIDataProvider_QueryParams.IntValue = 0x34 // int32_t (Size: 0x4)
AIDataProvider_QueryParams.BoolValue = 0x38 // bool (Size: 0x1)
AIDataProvider_Random.Min = 0x40 // float (Size: 0x4)
AIDataProvider_Random.Max = 0x44 // float (Size: 0x4)
AIDataProvider_Random.bInteger = 0x48 // uint8_t (Size: 0x1)
AIDynamicParam.ParamName = 0x0 // FName (Size: 0x8)
AIDynamicParam.ParamType = 0x8 // EEAIParamType (Size: 0x1)
AIDynamicParam.Value = 0xc // float (Size: 0x4)
AIDynamicParam.BBKey = 0x10 // FBlackboardKeySelector (Size: 0x28)
AIMoveRequest.GoalActor = 0x0 // Actor* (Size: 0x8)
AINoiseEvent.NoiseLocation = 0x4 // FVector (Size: 0xc)
AINoiseEvent.Loudness = 0x10 // float (Size: 0x4)
AINoiseEvent.MaxRange = 0x14 // float (Size: 0x4)
AINoiseEvent.Instigator = 0x18 // Actor* (Size: 0x8)
AINoiseEvent.NoiseRelator = 0x20 // Actor* (Size: 0x8)
AINoiseEvent.Tag = 0x28 // FName (Size: 0x8)
AIPerceptionComponent.SensesConfig = 0xf8 // TArray<AISenseConfig*> (Size: 0x10)
AIPerceptionComponent.DominantSense = 0x108 // ClassProperty (Size: 0x8)
AIPerceptionComponent.AIOwner = 0x120 // AIController* (Size: 0x8)
AIPerceptionComponent.OnPerceptionUpdated = 0x1a8 // FMulticastInlineDelegate (Size: 0x10)
AIPerceptionComponent.OnTargetPerceptionUpdated = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
AIPerceptionComponent.OnTargetPerceptionInfoUpdated = 0x1c8 // FMulticastInlineDelegate (Size: 0x10)
AIPerceptionStimuliSourceComponent.bAutoRegisterAsSource = 0xf8 // uint8_t (Size: 0x1)
AIPerceptionStimuliSourceComponent.RegisterAsSourceForSenses = 0x100 // TArray<ClassProperty> (Size: 0x10)
AIPerceptionSystem.Senses = 0x88 // TArray<AISense*> (Size: 0x10)
AIPerceptionSystem.PerceptionAgingRate = 0x98 // float (Size: 0x4)
AIPredictionEvent.Requestor = 0x0 // Actor* (Size: 0x8)
AIPredictionEvent.PredictedActor = 0x8 // Actor* (Size: 0x8)
AIRequestID.RequestID = 0x0 // uint32_t (Size: 0x4)
AISense.DefaultExpirationAge = 0x28 // float (Size: 0x4)
AISense.NotifyType = 0x2c // EEAISenseNotifyType (Size: 0x1)
AISense.bWantsNewPawnNotification = 0x30 // uint8_t (Size: 0x1)
AISense.bAutoRegisterAllPawnsAsSources = 0x30 // uint8_t (Size: 0x1)
AISense.PerceptionSystemInstance = 0x38 // AIPerceptionSystem* (Size: 0x8)
AISenseAffiliationFilter.bDetectEnemies = 0x0 // uint8_t (Size: 0x1)
AISenseAffiliationFilter.bDetectNeutrals = 0x0 // uint8_t (Size: 0x1)
AISenseAffiliationFilter.bDetectFriendlies = 0x0 // uint8_t (Size: 0x1)
AISenseConfig.DebugColor = 0x28 // FColor (Size: 0x4)
AISenseConfig.MaxAge = 0x2c // float (Size: 0x4)
AISenseConfig.bStartsEnabled = 0x30 // uint8_t (Size: 0x1)
AISenseConfig_Blueprint.Implementation = 0x48 // ClassProperty (Size: 0x8)
AISenseConfig_Damage.Implementation = 0x48 // ClassProperty (Size: 0x8)
AISenseConfig_Hearing.Implementation = 0x48 // ClassProperty (Size: 0x8)
AISenseConfig_Hearing.HearingRange = 0x50 // float (Size: 0x4)
AISenseConfig_Hearing.LoSHearingRange = 0x54 // float (Size: 0x4)
AISenseConfig_Hearing.bUseLoSHearing = 0x58 // uint8_t (Size: 0x1)
AISenseConfig_Hearing.DetectionByAffiliation = 0x5c // FAISenseAffiliationFilter (Size: 0x4)
AISenseConfig_Sight.Implementation = 0x48 // ClassProperty (Size: 0x8)
AISenseConfig_Sight.SightRadius = 0x50 // float (Size: 0x4)
AISenseConfig_Sight.LoseSightRadius = 0x54 // float (Size: 0x4)
AISenseConfig_Sight.PeripheralVisionAngleDegrees = 0x58 // float (Size: 0x4)
AISenseConfig_Sight.DetectionByAffiliation = 0x5c // FAISenseAffiliationFilter (Size: 0x4)
AISenseConfig_Sight.AutoSuccessRangeFromLastSeenLocation = 0x60 // float (Size: 0x4)
AISenseConfig_Sight.PointOfViewBackwardOffset = 0x64 // float (Size: 0x4)
AISenseConfig_Sight.NearClippingRadius = 0x68 // float (Size: 0x4)
AISenseEvent_Damage.Event = 0x28 // FAIDamageEvent (Size: 0x38)
AISenseEvent_Hearing.Event = 0x28 // FAINoiseEvent (Size: 0x38)
AISense_Blueprint.ListenerDataType = 0x80 // ClassProperty (Size: 0x8)
AISense_Blueprint.ListenerContainer = 0x88 // TArray<AIPerceptionComponent*> (Size: 0x10)
AISense_Blueprint.UnprocessedEvents = 0x98 // TArray<AISenseEvent*> (Size: 0x10)
AISense_Damage.RegisteredEvents = 0x80 // TArray<FAIDamageEvent> (Size: 0x10)
AISense_Hearing.NoiseEvents = 0x80 // TArray<FAINoiseEvent> (Size: 0x10)
AISense_Hearing.SpeedOfSoundSq = 0x90 // float (Size: 0x4)
AISense_Prediction.RegisteredEvents = 0x80 // TArray<FAIPredictionEvent> (Size: 0x10)
AISense_Sight.MaxTracesPerTick = 0x148 // int32_t (Size: 0x4)
AISense_Sight.MinQueriesPerTimeSliceCheck = 0x14c // int32_t (Size: 0x4)
AISense_Sight.MaxTimeSlicePerTick = 0x150 // double (Size: 0x8)
AISense_Sight.HighImportanceQueryDistanceThreshold = 0x158 // float (Size: 0x4)
AISense_Sight.MaxQueryImportance = 0x160 // float (Size: 0x4)
AISense_Sight.SightLimitQueryImportance = 0x164 // float (Size: 0x4)
AISense_Team.RegisteredEvents = 0x80 // TArray<FAITeamStimulusEvent> (Size: 0x10)
AISense_Touch.RegisteredEvents = 0x80 // TArray<FAITouchEvent> (Size: 0x10)
AISightEvent.SeenActor = 0x8 // Actor* (Size: 0x8)
AISightEvent.Observer = 0x10 // Actor* (Size: 0x8)
AIStimulus.Age = 0x0 // float (Size: 0x4)
AIStimulus.ExpirationAge = 0x4 // float (Size: 0x4)
AIStimulus.Strength = 0x8 // float (Size: 0x4)
AIStimulus.StimulusLocation = 0xc // FVector (Size: 0xc)
AIStimulus.ReceiverLocation = 0x18 // FVector (Size: 0xc)
AIStimulus.Tag = 0x24 // FName (Size: 0x8)
AIStimulus.bSuccessfullySensed = 0x38 // uint8_t (Size: 0x1)
AISubsystem.AISystem = 0x30 // AISystem* (Size: 0x8)
AISystem.PerceptionSystemClassName = 0x58 // FSoftClassPath (Size: 0x18)
AISystem.EnvQueryManagerClassName = 0x70 // FSoftClassPath (Size: 0x18)
AISystem.HotSpotManagerClassName = 0x88 // FSoftClassPath (Size: 0x18)
AISystem.AcceptanceRadius = 0xa0 // float (Size: 0x4)
AISystem.PathfollowingRegularPathPointAcceptanceRadius = 0xa4 // float (Size: 0x4)
AISystem.PathfollowingNavLinkAcceptanceRadius = 0xa8 // float (Size: 0x4)
AISystem.bFinishMoveOnGoalOverlap = 0xac // bool (Size: 0x1)
AISystem.bAcceptPartialPaths = 0xad // bool (Size: 0x1)
AISystem.bAllowStrafing = 0xae // bool (Size: 0x1)
AISystem.bEnableBTAITasks = 0xaf // bool (Size: 0x1)
AISystem.bAllowControllersAsEQSQuerier = 0xb0 // bool (Size: 0x1)
AISystem.bEnableDebuggerPlugin = 0xb1 // bool (Size: 0x1)
AISystem.bForgetStaleActors = 0xb2 // bool (Size: 0x1)
AISystem.bAddBlackboardSelfKey = 0xb3 // bool (Size: 0x1)
AISystem.DefaultSightCollisionChannel = 0xb4 // uint8_t (Size: 0x1)
AISystem.BehaviorTreeManager = 0xb8 // BehaviorTreeManager* (Size: 0x8)
AISystem.EnvironmentQueryManager = 0xc0 // EnvQueryManager* (Size: 0x8)
AISystem.PerceptionSystem = 0xc8 // AIPerceptionSystem* (Size: 0x8)
AISystem.AllProxyObjects = 0xd0 // TArray<AIAsyncTaskBlueprintProxy*> (Size: 0x10)
AISystem.HotSpotManager = 0xe0 // AIHotSpotManager* (Size: 0x8)
AISystem.NavLocalGrids = 0xe8 // NavLocalGridManager* (Size: 0x8)
AITask.OwnerController = 0x68 // AIController* (Size: 0x8)
AITask_MoveTo.OnRequestFailed = 0x70 // FMulticastInlineDelegate (Size: 0x10)
AITask_MoveTo.OnMoveFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AITask_MoveTo.MoveRequest = 0x90 // FAIMoveRequest (Size: 0x40)
AITeamStimulusEvent.Broadcaster = 0x28 // Actor* (Size: 0x8)
AITeamStimulusEvent.Enemy = 0x30 // Actor* (Size: 0x8)
AITouchEvent.TouchReceiver = 0x10 // Actor* (Size: 0x8)
AITouchEvent.OtherActor = 0x18 // Actor* (Size: 0x8)
ActorPerceptionBlueprintInfo.Target = 0x0 // Actor* (Size: 0x8)
ActorPerceptionBlueprintInfo.LastSensedStimuli = 0x8 // TArray<FAIStimulus> (Size: 0x10)
ActorPerceptionBlueprintInfo.bIsHostile = 0x18 // uint8_t (Size: 0x1)
ActorPerceptionUpdateInfo.TargetId = 0x0 // int32_t (Size: 0x4)
ActorPerceptionUpdateInfo.Target = 0x4 // TWeakObjectPtr<UObject> (Size: 0x8)
ActorPerceptionUpdateInfo.Stimulus = 0xc // FAIStimulus (Size: 0x3c)
BTCompositeChild.ChildComposite = 0x0 // BTCompositeNode* (Size: 0x8)
BTCompositeChild.ChildTask = 0x8 // BTTaskNode* (Size: 0x8)
BTCompositeChild.Decorators = 0x10 // TArray<BTDecorator*> (Size: 0x10)
BTCompositeChild.DecoratorOps = 0x20 // TArray<FBTDecoratorLogic> (Size: 0x10)
BTCompositeNode.Children = 0x58 // TArray<FBTCompositeChild> (Size: 0x10)
BTCompositeNode.Services = 0x68 // TArray<BTService*> (Size: 0x10)
BTCompositeNode.bApplyDecoratorScope = 0x88 // uint8_t (Size: 0x1)
BTComposite_SimpleParallel.FinishMode = 0x90 // uint8_t (Size: 0x1)
BTDecorator.bInverseCondition = 0x60 // uint8_t (Size: 0x1)
BTDecorator.FlowAbortMode = 0x64 // uint8_t (Size: 0x1)
BTDecoratorLogic.Operation = 0x0 // uint8_t (Size: 0x1)
BTDecoratorLogic.Number = 0x2 // uint16_t (Size: 0x2)
BTDecorator_Blackboard.IntValue = 0x90 // int32_t (Size: 0x4)
BTDecorator_Blackboard.FloatValue = 0x94 // float (Size: 0x4)
BTDecorator_Blackboard.StringValue = 0x98 // FString (Size: 0x10)
BTDecorator_Blackboard.CachedDescription = 0xa8 // FString (Size: 0x10)
BTDecorator_Blackboard.OperationType = 0xb8 // uint8_t (Size: 0x1)
BTDecorator_Blackboard.NotifyObserver = 0xb9 // uint8_t (Size: 0x1)
BTDecorator_BlackboardBase.BlackboardKey = 0x68 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_BlueprintBase.AIOwner = 0x68 // AIController* (Size: 0x8)
BTDecorator_BlueprintBase.ActorOwner = 0x70 // Actor* (Size: 0x8)
BTDecorator_BlueprintBase.ObservedKeyNames = 0x78 // TArray<FName> (Size: 0x10)
BTDecorator_BlueprintBase.bShowPropertyDetails = 0x98 // uint8_t (Size: 0x1)
BTDecorator_BlueprintBase.bCheckConditionOnlyBlackBoardChanges = 0x98 // uint8_t (Size: 0x1)
BTDecorator_BlueprintBase.bIsObservingBB = 0x98 // uint8_t (Size: 0x1)
BTDecorator_CheckGameplayTagsOnActor.ActorToCheck = 0x68 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_CheckGameplayTagsOnActor.TagsToMatch = 0x90 // EEGameplayContainerMatchType (Size: 0x1)
BTDecorator_CheckGameplayTagsOnActor.GameplayTags = 0x98 // FGameplayTagContainer (Size: 0x20)
BTDecorator_CheckGameplayTagsOnActor.CachedDescription = 0xb8 // FString (Size: 0x10)
BTDecorator_CompareBBEntries.Operator = 0x68 // uint8_t (Size: 0x1)
BTDecorator_CompareBBEntries.BlackboardKeyA = 0x70 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_CompareBBEntries.BlackboardKeyB = 0x98 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_ConeCheck.ConeHalfAngle = 0x68 // float (Size: 0x4)
BTDecorator_ConeCheck.ConeOrigin = 0x70 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_ConeCheck.ConeDirection = 0x98 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_ConeCheck.Observed = 0xc0 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_Cooldown.CoolDownTime = 0x68 // float (Size: 0x4)
BTDecorator_DoesPathExist.BlackboardKeyA = 0x68 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_DoesPathExist.BlackboardKeyB = 0x90 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_DoesPathExist.bUseSelf = 0xb8 // uint8_t (Size: 0x1)
BTDecorator_DoesPathExist.PathQueryType = 0xbc // uint8_t (Size: 0x1)
BTDecorator_DoesPathExist.FilterClass = 0xc0 // ClassProperty (Size: 0x8)
BTDecorator_IsAtLocation.AcceptableRadius = 0x90 // float (Size: 0x4)
BTDecorator_IsAtLocation.ParametrizedAcceptableRadius = 0x98 // FAIDataProviderFloatValue (Size: 0x38)
BTDecorator_IsAtLocation.GeometricDistanceType = 0xd0 // EFAIDistanceType (Size: 0x1)
BTDecorator_IsAtLocation.bUseParametrizedRadius = 0xd4 // uint8_t (Size: 0x1)
BTDecorator_IsAtLocation.bUseNavAgentGoalLocation = 0xd4 // uint8_t (Size: 0x1)
BTDecorator_IsAtLocation.bPathFindingBasedTest = 0xd4 // uint8_t (Size: 0x1)
BTDecorator_IsBBEntryOfClass.TestClass = 0x90 // ClassProperty (Size: 0x8)
BTDecorator_KeepInCone.ConeHalfAngle = 0x68 // float (Size: 0x4)
BTDecorator_KeepInCone.ConeOrigin = 0x70 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_KeepInCone.Observed = 0x98 // FBlackboardKeySelector (Size: 0x28)
BTDecorator_KeepInCone.bUseSelfAsOrigin = 0xc0 // uint8_t (Size: 0x1)
BTDecorator_KeepInCone.bUseSelfAsObserved = 0xc0 // uint8_t (Size: 0x1)
BTDecorator_Loop.NumLoops = 0x68 // int32_t (Size: 0x4)
BTDecorator_Loop.bInfiniteLoop = 0x6c // bool (Size: 0x1)
BTDecorator_Loop.InfiniteLoopTimeoutTime = 0x70 // float (Size: 0x4)
BTDecorator_SetTagCooldown.CooldownTag = 0x68 // FGameplayTag (Size: 0x8)
BTDecorator_SetTagCooldown.CooldownDuration = 0x70 // float (Size: 0x4)
BTDecorator_SetTagCooldown.bAddToExistingDuration = 0x74 // bool (Size: 0x1)
BTDecorator_TagCooldown.CooldownTag = 0x68 // FGameplayTag (Size: 0x8)
BTDecorator_TagCooldown.CooldownDuration = 0x70 // float (Size: 0x4)
BTDecorator_TagCooldown.bAddToExistingDuration = 0x74 // bool (Size: 0x1)
BTDecorator_TagCooldown.bActivatesCooldown = 0x75 // bool (Size: 0x1)
BTDecorator_TimeLimit.TimeLimit = 0x68 // float (Size: 0x4)
BTNode.NodeName = 0x30 // FString (Size: 0x10)
BTNode.TreeAsset = 0x40 // BehaviorTree* (Size: 0x8)
BTNode.ParentNode = 0x48 // BTCompositeNode* (Size: 0x8)
BTService.Interval = 0x60 // float (Size: 0x4)
BTService.RandomDeviation = 0x64 // float (Size: 0x4)
BTService.bCallTickOnSearchStart = 0x68 // uint8_t (Size: 0x1)
BTService.bRestartTimerOnEachActivation = 0x68 // uint8_t (Size: 0x1)
BTService_BlackboardBase.BlackboardKey = 0x70 // FBlackboardKeySelector (Size: 0x28)
BTService_BlueprintBase.AIOwner = 0x70 // AIController* (Size: 0x8)
BTService_BlueprintBase.ActorOwner = 0x78 // Actor* (Size: 0x8)
BTService_BlueprintBase.bShowPropertyDetails = 0x90 // uint8_t (Size: 0x1)
BTService_BlueprintBase.bShowEventDetails = 0x90 // uint8_t (Size: 0x1)
BTService_DefaultFocus.FocusPriority = 0x98 // uint8_t (Size: 0x1)
BTService_RunEQS.EQSRequest = 0x98 // FEQSParametrizedQueryExecutionRequest (Size: 0x48)
BTTaskNode.Services = 0x58 // TArray<BTService*> (Size: 0x10)
BTTaskNode.bIgnoreRestartSelf = 0x68 // uint8_t (Size: 0x1)
BTTask_BlackboardBase.BlackboardKey = 0x70 // FBlackboardKeySelector (Size: 0x28)
BTTask_BlueprintBase.AIOwner = 0x70 // AIController* (Size: 0x8)
BTTask_BlueprintBase.ActorOwner = 0x78 // Actor* (Size: 0x8)
BTTask_BlueprintBase.TickInterval = 0x80 // FIntervalCountdown (Size: 0x8)
BTTask_BlueprintBase.bShowPropertyDetails = 0xa0 // uint8_t (Size: 0x1)
BTTask_FinishWithResult.Result = 0x70 // uint8_t (Size: 0x1)
BTTask_GameplayTaskBase.bWaitForGameplayTask = 0x70 // uint8_t (Size: 0x1)
BTTask_MakeNoise.Loudnes = 0x70 // float (Size: 0x4)
BTTask_MoveDirectlyToward.bDisablePathUpdateOnGoalLocationChange = 0xb0 // uint8_t (Size: 0x1)
BTTask_MoveDirectlyToward.bProjectVectorGoalToNavigation = 0xb0 // uint8_t (Size: 0x1)
BTTask_MoveDirectlyToward.bUpdatedDeprecatedProperties = 0xb0 // uint8_t (Size: 0x1)
BTTask_MoveTo.AcceptableRadius = 0x98 // float (Size: 0x4)
BTTask_MoveTo.FilterClass = 0xa0 // ClassProperty (Size: 0x8)
BTTask_MoveTo.ObservedBlackboardValueTolerance = 0xa8 // float (Size: 0x4)
BTTask_MoveTo.bObserveBlackboardValue = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bAllowStrafe = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bAllowPartialPath = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bTrackMovingGoal = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bProjectGoalLocation = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bReachTestIncludesAgentRadius = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bReachTestIncludesGoalRadius = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bStopOnOverlap = 0xac // uint8_t (Size: 0x1)
BTTask_MoveTo.bStopOnOverlapNeedsUpdate = 0xad // uint8_t (Size: 0x1)
BTTask_PlayAnimation.AnimationToPlay = 0x70 // AnimationAsset* (Size: 0x8)
BTTask_PlayAnimation.bLooping = 0x78 // uint8_t (Size: 0x1)
BTTask_PlayAnimation.bNonBlocking = 0x78 // uint8_t (Size: 0x1)
BTTask_PlayAnimation.MyOwnerComp = 0x80 // BehaviorTreeComponent* (Size: 0x8)
BTTask_PlayAnimation.CachedSkelMesh = 0x88 // SkeletalMeshComponent* (Size: 0x8)
BTTask_PlaySound.SoundToPlay = 0x70 // SoundCue* (Size: 0x8)
BTTask_PushPawnAction.Action = 0x70 // PawnAction* (Size: 0x8)
BTTask_RotateToFaceBBEntry.Precision = 0x98 // float (Size: 0x4)
BTTask_RunBehavior.BehaviorAsset = 0x70 // BehaviorTree* (Size: 0x8)
BTTask_RunBehaviorDynamic.InjectionTag = 0x70 // FGameplayTag (Size: 0x8)
BTTask_RunBehaviorDynamic.DefaultBehaviorAsset = 0x78 // BehaviorTree* (Size: 0x8)
BTTask_RunBehaviorDynamic.BehaviorAsset = 0x80 // BehaviorTree* (Size: 0x8)
BTTask_RunEQSQuery.QueryTemplate = 0x98 // EnvQuery* (Size: 0x8)
BTTask_RunEQSQuery.QueryParams = 0xa0 // TArray<FEnvNamedValue> (Size: 0x10)
BTTask_RunEQSQuery.QueryConfig = 0xb0 // TArray<FAIDynamicParam> (Size: 0x10)
BTTask_RunEQSQuery.RunMode = 0xc0 // uint8_t (Size: 0x1)
BTTask_RunEQSQuery.EQSQueryBlackboardKey = 0xc8 // FBlackboardKeySelector (Size: 0x28)
BTTask_RunEQSQuery.bUseBBKey = 0xf0 // bool (Size: 0x1)
BTTask_RunEQSQuery.EQSRequest = 0xf8 // FEQSParametrizedQueryExecutionRequest (Size: 0x48)
BTTask_SetTagCooldown.CooldownTag = 0x70 // FGameplayTag (Size: 0x8)
BTTask_SetTagCooldown.bAddToExistingDuration = 0x78 // bool (Size: 0x1)
BTTask_SetTagCooldown.CooldownDuration = 0x7c // float (Size: 0x4)
BTTask_Wait.WaitTime = 0x70 // float (Size: 0x4)
BTTask_Wait.RandomDeviation = 0x74 // float (Size: 0x4)
BTTask_WaitBlackboardTime.BlackboardKey = 0x78 // FBlackboardKeySelector (Size: 0x28)
BehaviorTree.RootNode = 0x30 // BTCompositeNode* (Size: 0x8)
BehaviorTree.BlackboardAsset = 0x38 // BlackboardData* (Size: 0x8)
BehaviorTree.RootDecorators = 0x40 // TArray<BTDecorator*> (Size: 0x10)
BehaviorTree.RootDecoratorOps = 0x50 // TArray<FBTDecoratorLogic> (Size: 0x10)
BehaviorTreeComponent.NodeInstances = 0x170 // TArray<BTNode*> (Size: 0x10)
BehaviorTreeComponent.DefaultBehaviorTreeAsset = 0x2c0 // BehaviorTree* (Size: 0x8)
BehaviorTreeManager.MaxDebuggerSteps = 0x28 // int32_t (Size: 0x4)
BehaviorTreeManager.LoadedTemplates = 0x30 // TArray<FBehaviorTreeTemplateInfo> (Size: 0x10)
BehaviorTreeManager.ActiveComponents = 0x40 // TArray<BehaviorTreeComponent*> (Size: 0x10)
BehaviorTreeTemplateInfo.Asset = 0x0 // BehaviorTree* (Size: 0x8)
BehaviorTreeTemplateInfo.Template = 0x8 // BTCompositeNode* (Size: 0x8)
BlackboardComponent.BrainComp = 0xf8 // BrainComponent* (Size: 0x8)
BlackboardComponent.DefaultBlackboardAsset = 0x100 // BlackboardData* (Size: 0x8)
BlackboardComponent.BlackboardAsset = 0x108 // BlackboardData* (Size: 0x8)
BlackboardComponent.KeyInstances = 0x130 // TArray<BlackboardKeyType*> (Size: 0x10)
BlackboardData.Parent = 0x30 // BlackboardData* (Size: 0x8)
BlackboardData.Keys = 0x38 // TArray<FBlackboardEntry> (Size: 0x10)
BlackboardData.bHasSynchronizedKeys = 0x48 // uint8_t (Size: 0x1)
BlackboardEntry.EntryName = 0x0 // FName (Size: 0x8)
BlackboardEntry.KeyType = 0x8 // BlackboardKeyType* (Size: 0x8)
BlackboardEntry.bInstanceSynced = 0x10 // uint8_t (Size: 0x1)
BlackboardEntry.Category = 0x14 // FName (Size: 0x8)
BlackboardKeySelector.AllowedTypes = 0x0 // TArray<BlackboardKeyType*> (Size: 0x10)
BlackboardKeySelector.SelectedKeyName = 0x10 // FName (Size: 0x8)
BlackboardKeySelector.SelectedKeyType = 0x18 // ClassProperty (Size: 0x8)
BlackboardKeySelector.SelectedKeyID = 0x20 // uint8_t (Size: 0x1)
BlackboardKeySelector.bNoneIsAllowedValue = 0x24 // uint8_t (Size: 0x1)
BlackboardKeyType_Class.BaseClass = 0x30 // ClassProperty (Size: 0x8)
BlackboardKeyType_Enum.EnumType = 0x30 // Enum* (Size: 0x8)
BlackboardKeyType_Enum.EnumName = 0x38 // FString (Size: 0x10)
BlackboardKeyType_Enum.bIsEnumNameValid = 0x48 // uint8_t (Size: 0x1)
BlackboardKeyType_NativeEnum.EnumName = 0x30 // FString (Size: 0x10)
BlackboardKeyType_NativeEnum.EnumType = 0x40 // Enum* (Size: 0x8)
BlackboardKeyType_Object.BaseClass = 0x30 // ClassProperty (Size: 0x8)
BlackboardKeyType_String.StringValue = 0x30 // FString (Size: 0x10)
BrainComponent.BlackboardComp = 0x100 // BlackboardComponent* (Size: 0x8)
BrainComponent.AIOwner = 0x108 // AIController* (Size: 0x8)
CrowdAvoidanceConfig.VelocityBias = 0x0 // float (Size: 0x4)
CrowdAvoidanceConfig.DesiredVelocityWeight = 0x4 // float (Size: 0x4)
CrowdAvoidanceConfig.CurrentVelocityWeight = 0x8 // float (Size: 0x4)
CrowdAvoidanceConfig.SideBiasWeight = 0xc // float (Size: 0x4)
CrowdAvoidanceConfig.ImpactTimeWeight = 0x10 // float (Size: 0x4)
CrowdAvoidanceConfig.ImpactTimeRange = 0x14 // float (Size: 0x4)
CrowdAvoidanceConfig.CustomPatternIdx = 0x18 // uint8_t (Size: 0x1)
CrowdAvoidanceConfig.AdaptiveDivisions = 0x19 // uint8_t (Size: 0x1)
CrowdAvoidanceConfig.AdaptiveRings = 0x1a // uint8_t (Size: 0x1)
CrowdAvoidanceConfig.AdaptiveDepth = 0x1b // uint8_t (Size: 0x1)
CrowdAvoidanceSamplingPattern.Angles = 0x0 // TArray<float> (Size: 0x10)
CrowdAvoidanceSamplingPattern.Radii = 0x10 // TArray<float> (Size: 0x10)
CrowdFollowingComponent.CrowdAgentMoveDirection = 0x2b0 // FVector (Size: 0xc)
CrowdManager.MyNavData = 0x28 // NavigationData* (Size: 0x8)
CrowdManager.AvoidanceConfig = 0x30 // TArray<FCrowdAvoidanceConfig> (Size: 0x10)
CrowdManager.SamplingPatterns = 0x40 // TArray<FCrowdAvoidanceSamplingPattern> (Size: 0x10)
CrowdManager.MaxAgents = 0x50 // int32_t (Size: 0x4)
CrowdManager.MaxAgentRadius = 0x54 // float (Size: 0x4)
CrowdManager.MaxAvoidedAgents = 0x58 // int32_t (Size: 0x4)
CrowdManager.MaxAvoidedWalls = 0x5c // int32_t (Size: 0x4)
CrowdManager.NavmeshCheckInterval = 0x60 // float (Size: 0x4)
CrowdManager.PathOptimizationInterval = 0x64 // float (Size: 0x4)
CrowdManager.SeparationDirClamp = 0x68 // float (Size: 0x4)
CrowdManager.PathOffsetRadiusMultiplier = 0x6c // float (Size: 0x4)
CrowdManager.bResolveCollisions = 0x70 // uint8_t (Size: 0x1)
EQSParametrizedQueryExecutionRequest.QueryTemplate = 0x0 // EnvQuery* (Size: 0x8)
EQSParametrizedQueryExecutionRequest.QueryConfig = 0x8 // TArray<FAIDynamicParam> (Size: 0x10)
EQSParametrizedQueryExecutionRequest.EQSQueryBlackboardKey = 0x18 // FBlackboardKeySelector (Size: 0x28)
EQSParametrizedQueryExecutionRequest.RunMode = 0x40 // uint8_t (Size: 0x1)
EQSParametrizedQueryExecutionRequest.bUseBBKeyForQueryTemplate = 0x44 // uint8_t (Size: 0x1)
EQSTestingPawn.QueryTemplate = 0x5e0 // EnvQuery* (Size: 0x8)
EQSTestingPawn.QueryParams = 0x5e8 // TArray<FEnvNamedValue> (Size: 0x10)
EQSTestingPawn.QueryConfig = 0x5f8 // TArray<FAIDynamicParam> (Size: 0x10)
EQSTestingPawn.TimeLimitPerStep = 0x608 // float (Size: 0x4)
EQSTestingPawn.StepToDebugDraw = 0x60c // int32_t (Size: 0x4)
EQSTestingPawn.HighlightMode = 0x610 // EEEnvQueryHightlightMode (Size: 0x1)
EQSTestingPawn.bDrawLabels = 0x614 // uint8_t (Size: 0x1)
EQSTestingPawn.bDrawFailedItems = 0x614 // uint8_t (Size: 0x1)
EQSTestingPawn.bReRunQueryOnlyOnFinishedMove = 0x614 // uint8_t (Size: 0x1)
EQSTestingPawn.bShouldBeVisibleInGame = 0x614 // uint8_t (Size: 0x1)
EQSTestingPawn.bTickDuringGame = 0x614 // uint8_t (Size: 0x1)
EQSTestingPawn.QueryingMode = 0x618 // uint8_t (Size: 0x1)
EQSTestingPawn.NavAgentProperties = 0x620 // FNavAgentProperties (Size: 0x30)
EnvDirection.LineFrom = 0x0 // ClassProperty (Size: 0x8)
EnvDirection.LineTo = 0x8 // ClassProperty (Size: 0x8)
EnvDirection.Rotation = 0x10 // ClassProperty (Size: 0x8)
EnvDirection.DirMode = 0x18 // uint8_t (Size: 0x1)
EnvNamedValue.ParamName = 0x0 // FName (Size: 0x8)
EnvNamedValue.ParamType = 0x8 // EEAIParamType (Size: 0x1)
EnvNamedValue.Value = 0xc // float (Size: 0x4)
EnvOverlapData.ExtentX = 0x0 // float (Size: 0x4)
EnvOverlapData.ExtentY = 0x4 // float (Size: 0x4)
EnvOverlapData.ExtentZ = 0x8 // float (Size: 0x4)
EnvOverlapData.ShapeOffset = 0xc // FVector (Size: 0xc)
EnvOverlapData.OverlapChannel = 0x18 // uint8_t (Size: 0x1)
EnvOverlapData.OverlapShape = 0x19 // uint8_t (Size: 0x1)
EnvOverlapData.bOnlyBlockingHits = 0x1c // uint8_t (Size: 0x1)
EnvOverlapData.bOverlapComplex = 0x1c // uint8_t (Size: 0x1)
EnvOverlapData.bSkipOverlapQuerier = 0x1c // uint8_t (Size: 0x1)
EnvQuery.QueryName = 0x30 // FName (Size: 0x8)
EnvQuery.Options = 0x38 // TArray<EnvQueryOption*> (Size: 0x10)
EnvQueryGenerator.OptionName = 0x30 // FString (Size: 0x10)
EnvQueryGenerator.ItemType = 0x40 // ClassProperty (Size: 0x8)
EnvQueryGenerator.bAutoSortTests = 0x48 // uint8_t (Size: 0x1)
EnvQueryGenerator_ActorsOfClass.SearchedActorClass = 0x50 // ClassProperty (Size: 0x8)
EnvQueryGenerator_ActorsOfClass.GenerateOnlyActorsInRadius = 0x58 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryGenerator_ActorsOfClass.SearchRadius = 0x90 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_ActorsOfClass.SearchCenter = 0xc8 // ClassProperty (Size: 0x8)
EnvQueryGenerator_BlueprintBase.GeneratorsActionDescription = 0x50 // FText (Size: 0x18)
EnvQueryGenerator_BlueprintBase.Context = 0x68 // ClassProperty (Size: 0x8)
EnvQueryGenerator_BlueprintBase.GeneratedItemType = 0x70 // ClassProperty (Size: 0x8)
EnvQueryGenerator_Composite.Generators = 0x50 // TArray<EnvQueryGenerator*> (Size: 0x10)
EnvQueryGenerator_Composite.bAllowDifferentItemTypes = 0x60 // uint8_t (Size: 0x1)
EnvQueryGenerator_Composite.bHasMatchingItemType = 0x60 // uint8_t (Size: 0x1)
EnvQueryGenerator_Composite.ForcedItemType = 0x68 // ClassProperty (Size: 0x8)
EnvQueryGenerator_Cone.AlignedPointsDistance = 0x80 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Cone.ConeDegrees = 0xb8 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Cone.AngleStep = 0xf0 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Cone.Range = 0x128 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Cone.CenterActor = 0x160 // ClassProperty (Size: 0x8)
EnvQueryGenerator_Cone.bIncludeContextLocation = 0x168 // uint8_t (Size: 0x1)
EnvQueryGenerator_CurrentLocation.QueryContext = 0x50 // ClassProperty (Size: 0x8)
EnvQueryGenerator_Donut.InnerRadius = 0x80 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Donut.OuterRadius = 0xb8 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Donut.NumberOfRings = 0xf0 // FAIDataProviderIntValue (Size: 0x38)
EnvQueryGenerator_Donut.PointsPerRing = 0x128 // FAIDataProviderIntValue (Size: 0x38)
EnvQueryGenerator_Donut.ArcDirection = 0x160 // FEnvDirection (Size: 0x20)
EnvQueryGenerator_Donut.ArcAngle = 0x180 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_Donut.bUseSpiralPattern = 0x1b8 // bool (Size: 0x1)
EnvQueryGenerator_Donut.Center = 0x1c0 // ClassProperty (Size: 0x8)
EnvQueryGenerator_Donut.bDefineArc = 0x1c8 // uint8_t (Size: 0x1)
EnvQueryGenerator_OnCircle.CircleRadius = 0x80 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_OnCircle.SpaceBetween = 0xb8 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_OnCircle.NumberOfPoints = 0xf0 // FAIDataProviderIntValue (Size: 0x38)
EnvQueryGenerator_OnCircle.PointOnCircleSpacingMethod = 0x128 // EEPointOnCircleSpacingMethod (Size: 0x1)
EnvQueryGenerator_OnCircle.ArcDirection = 0x130 // FEnvDirection (Size: 0x20)
EnvQueryGenerator_OnCircle.ArcAngle = 0x150 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_OnCircle.AngleRadians = 0x188 // float (Size: 0x4)
EnvQueryGenerator_OnCircle.CircleCenter = 0x190 // ClassProperty (Size: 0x8)
EnvQueryGenerator_OnCircle.bIgnoreAnyContextActorsWhenGeneratingCircle = 0x198 // bool (Size: 0x1)
EnvQueryGenerator_OnCircle.CircleCenterZOffset = 0x1a0 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_OnCircle.TraceData = 0x1d8 // FEnvTraceData (Size: 0x30)
EnvQueryGenerator_OnCircle.bDefineArc = 0x208 // uint8_t (Size: 0x1)
EnvQueryGenerator_PathingGrid.PathToItem = 0xf8 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryGenerator_PathingGrid.NavigationFilter = 0x130 // ClassProperty (Size: 0x8)
EnvQueryGenerator_PathingGrid.ScanRangeMultiplier = 0x138 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_ProjectedPoints.ProjectionData = 0x50 // FEnvTraceData (Size: 0x30)
EnvQueryGenerator_SimpleGrid.GridSize = 0x80 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_SimpleGrid.SpaceBetween = 0xb8 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_SimpleGrid.GenerateAround = 0xf0 // ClassProperty (Size: 0x8)
EnvQueryInstanceBlueprintWrapper.QueryID = 0x30 // int32_t (Size: 0x4)
EnvQueryInstanceBlueprintWrapper.ItemType = 0x58 // ClassProperty (Size: 0x8)
EnvQueryInstanceBlueprintWrapper.OptionIndex = 0x60 // int32_t (Size: 0x4)
EnvQueryInstanceBlueprintWrapper.OnQueryFinishedEvent = 0x68 // FMulticastInlineDelegate (Size: 0x10)
EnvQueryInstanceCache.Template = 0x0 // EnvQuery* (Size: 0x8)
EnvQueryManager.InstanceCache = 0xa8 // TArray<FEnvQueryInstanceCache> (Size: 0x10)
EnvQueryManager.LocalContexts = 0xb8 // TArray<EnvQueryContext*> (Size: 0x10)
EnvQueryManager.GCShieldedWrappers = 0xc8 // TArray<EnvQueryInstanceBlueprintWrapper*> (Size: 0x10)
EnvQueryManager.MaxAllowedTestingTime = 0x12c // float (Size: 0x4)
EnvQueryManager.bTestQueriesUsingBreadth = 0x130 // bool (Size: 0x1)
EnvQueryManager.QueryCountWarningThreshold = 0x134 // int32_t (Size: 0x4)
EnvQueryManager.QueryCountWarningInterval = 0x138 // double (Size: 0x8)
EnvQueryNode.VerNum = 0x28 // int32_t (Size: 0x4)
EnvQueryOption.Generator = 0x28 // EnvQueryGenerator* (Size: 0x8)
EnvQueryOption.Tests = 0x30 // TArray<EnvQueryTest*> (Size: 0x10)
EnvQueryRequest.QueryTemplate = 0x0 // EnvQuery* (Size: 0x8)
EnvQueryRequest.Owner = 0x8 // Object* (Size: 0x8)
EnvQueryRequest.World = 0x10 // World* (Size: 0x8)
EnvQueryResult.ItemType = 0x10 // ClassProperty (Size: 0x8)
EnvQueryResult.OptionIndex = 0x2c // int32_t (Size: 0x4)
EnvQueryResult.QueryID = 0x30 // int32_t (Size: 0x4)
EnvQueryTest.TestOrder = 0x30 // int32_t (Size: 0x4)
EnvQueryTest.TestPurpose = 0x34 // uint8_t (Size: 0x1)
EnvQueryTest.TestComment = 0x38 // FString (Size: 0x10)
EnvQueryTest.MultipleContextFilterOp = 0x48 // uint8_t (Size: 0x1)
EnvQueryTest.MultipleContextScoreOp = 0x49 // uint8_t (Size: 0x1)
EnvQueryTest.FilterType = 0x4a // uint8_t (Size: 0x1)
EnvQueryTest.BoolValue = 0x50 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryTest.FloatValueMin = 0x88 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.FloatValueMax = 0xc0 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.ScoringEquation = 0xf9 // uint8_t (Size: 0x1)
EnvQueryTest.ClampMinType = 0xfa // uint8_t (Size: 0x1)
EnvQueryTest.ClampMaxType = 0xfb // uint8_t (Size: 0x1)
EnvQueryTest.NormalizationType = 0xfc // EEEQSNormalizationType (Size: 0x1)
EnvQueryTest.ScoreClampMin = 0x100 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.ScoreClampMax = 0x138 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.ScoringFactor = 0x170 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.ReferenceValue = 0x1a8 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest.bDefineReferenceValue = 0x1e0 // bool (Size: 0x1)
EnvQueryTest.bWorkOnFloatValues = 0x1f0 // uint8_t (Size: 0x1)
EnvQueryTest_Distance.TestMode = 0x1f8 // uint8_t (Size: 0x1)
EnvQueryTest_Distance.DistanceTo = 0x200 // ClassProperty (Size: 0x8)
EnvQueryTest_Dot.LineA = 0x1f8 // FEnvDirection (Size: 0x20)
EnvQueryTest_Dot.LineB = 0x218 // FEnvDirection (Size: 0x20)
EnvQueryTest_Dot.TestMode = 0x238 // EEEnvTestDot (Size: 0x1)
EnvQueryTest_Dot.bAbsoluteValue = 0x239 // bool (Size: 0x1)
EnvQueryTest_GameplayTags.TagQueryToMatch = 0x1f8 // FGameplayTagQuery (Size: 0x48)
EnvQueryTest_GameplayTags.bUpdatedToUseQuery = 0x240 // bool (Size: 0x1)
EnvQueryTest_GameplayTags.TagsToMatch = 0x241 // EEGameplayContainerMatchType (Size: 0x1)
EnvQueryTest_GameplayTags.GameplayTags = 0x248 // FGameplayTagContainer (Size: 0x20)
EnvQueryTest_Overlap.OverlapData = 0x1f8 // FEnvOverlapData (Size: 0x20)
EnvQueryTest_Pathfinding.TestMode = 0x1f8 // uint8_t (Size: 0x1)
EnvQueryTest_Pathfinding.Context = 0x200 // ClassProperty (Size: 0x8)
EnvQueryTest_Pathfinding.PathFromContext = 0x208 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryTest_Pathfinding.SkipUnreachable = 0x240 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryTest_Pathfinding.FilterClass = 0x278 // ClassProperty (Size: 0x8)
EnvQueryTest_PathfindingBatch.ScanRangeMultiplier = 0x280 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_Project.ProjectionData = 0x1f8 // FEnvTraceData (Size: 0x30)
EnvQueryTest_Trace.TraceData = 0x1f8 // FEnvTraceData (Size: 0x30)
EnvQueryTest_Trace.TraceFromContext = 0x228 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryTest_Trace.ItemHeightOffset = 0x260 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_Trace.ContextHeightOffset = 0x298 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_Trace.Context = 0x2d0 // ClassProperty (Size: 0x8)
EnvQueryTest_Volume.VolumeContext = 0x1f8 // ClassProperty (Size: 0x8)
EnvQueryTest_Volume.VolumeClass = 0x200 // ClassProperty (Size: 0x8)
EnvQueryTest_Volume.bDoComplexVolumeTest = 0x208 // uint8_t (Size: 0x1)
EnvTraceData.VersionNum = 0x0 // int32_t (Size: 0x4)
EnvTraceData.NavigationFilter = 0x8 // ClassProperty (Size: 0x8)
EnvTraceData.ProjectDown = 0x10 // float (Size: 0x4)
EnvTraceData.ProjectUp = 0x14 // float (Size: 0x4)
EnvTraceData.ExtentX = 0x18 // float (Size: 0x4)
EnvTraceData.ExtentY = 0x1c // float (Size: 0x4)
EnvTraceData.ExtentZ = 0x20 // float (Size: 0x4)
EnvTraceData.PostProjectionVerticalOffset = 0x24 // float (Size: 0x4)
EnvTraceData.TraceChannel = 0x28 // uint8_t (Size: 0x1)
EnvTraceData.SerializedChannel = 0x29 // uint8_t (Size: 0x1)
EnvTraceData.TraceShape = 0x2a // uint8_t (Size: 0x1)
EnvTraceData.TraceMode = 0x2b // uint8_t (Size: 0x1)
EnvTraceData.bTraceComplex = 0x2c // uint8_t (Size: 0x1)
EnvTraceData.bOnlyBlockingHits = 0x2c // uint8_t (Size: 0x1)
EnvTraceData.bCanTraceOnNavMesh = 0x2c // uint8_t (Size: 0x1)
EnvTraceData.bCanTraceOnGeometry = 0x2c // uint8_t (Size: 0x1)
EnvTraceData.bCanDisableTrace = 0x2c // uint8_t (Size: 0x1)
EnvTraceData.bCanProjectDown = 0x2c // uint8_t (Size: 0x1)
GenericTeamId.TeamID = 0x0 // uint8_t (Size: 0x1)
GridPathFollowingComponent.GridManager = 0x298 // NavLocalGridManager* (Size: 0x8)
IntervalCountdown.Interval = 0x0 // float (Size: 0x4)
NavLinkProxy.PointLinks = 0x320 // TArray<FNavigationLink> (Size: 0x10)
NavLinkProxy.SegmentLinks = 0x330 // TArray<FNavigationSegmentLink> (Size: 0x10)
NavLinkProxy.SmartLinkComp = 0x340 // NavLinkCustomComponent* (Size: 0x8)
NavLinkProxy.bSmartLinkIsRelevant = 0x348 // bool (Size: 0x1)
NavLinkProxy.OnSmartLinkReached = 0x350 // FMulticastInlineDelegate (Size: 0x10)
PathFollowingComponent.MovementComp = 0x130 // NavMovementComponent* (Size: 0x8)
PathFollowingComponent.MyNavData = 0x140 // NavigationData* (Size: 0x8)
PawnAction.ChildAction = 0x28 // PawnAction* (Size: 0x8)
PawnAction.ParentAction = 0x30 // PawnAction* (Size: 0x8)
PawnAction.OwnerComponent = 0x38 // PawnActionsComponent* (Size: 0x8)
PawnAction.Instigator = 0x40 // Object* (Size: 0x8)
PawnAction.BrainComp = 0x48 // BrainComponent* (Size: 0x8)
PawnAction.bAllowNewSameClassInstance = 0x80 // uint8_t (Size: 0x1)
PawnAction.bReplaceActiveSameClassInstance = 0x80 // uint8_t (Size: 0x1)
PawnAction.bShouldPauseMovement = 0x80 // uint8_t (Size: 0x1)
PawnAction.bAlwaysNotifyOnFinished = 0x80 // uint8_t (Size: 0x1)
PawnActionEvent.Action = 0x0 // PawnAction* (Size: 0x8)
PawnActionStack.TopAction = 0x0 // PawnAction* (Size: 0x8)
PawnAction_Move.GoalActor = 0x98 // Actor* (Size: 0x8)
PawnAction_Move.GoalLocation = 0xa0 // FVector (Size: 0xc)
PawnAction_Move.AcceptableRadius = 0xac // float (Size: 0x4)
PawnAction_Move.FilterClass = 0xb0 // ClassProperty (Size: 0x8)
PawnAction_Move.bAllowStrafe = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bFinishOnOverlap = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bUsePathfinding = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bAllowPartialPath = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bProjectGoalToNavigation = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bUpdatePathToGoal = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Move.bAbortChildActionOnPathChange = 0xb8 // uint8_t (Size: 0x1)
PawnAction_Repeat.ActionToRepeat = 0x98 // PawnAction* (Size: 0x8)
PawnAction_Repeat.RecentActionCopy = 0xa0 // PawnAction* (Size: 0x8)
PawnAction_Repeat.ChildFailureHandlingMode = 0xa8 // uint8_t (Size: 0x1)
PawnAction_Sequence.ActionSequence = 0x98 // TArray<PawnAction*> (Size: 0x10)
PawnAction_Sequence.ChildFailureHandlingMode = 0xa8 // uint8_t (Size: 0x1)
PawnAction_Sequence.RecentActionCopy = 0xb0 // PawnAction* (Size: 0x8)
PawnAction_Wait.TimeToWait = 0x98 // float (Size: 0x4)
PawnActionsComponent.ControlledPawn = 0xf8 // Pawn* (Size: 0x8)
PawnActionsComponent.ActionStacks = 0x100 // TArray<FPawnActionStack> (Size: 0x10)
PawnActionsComponent.ActionEvents = 0x110 // TArray<FPawnActionEvent> (Size: 0x10)
PawnActionsComponent.CurrentAction = 0x120 // PawnAction* (Size: 0x8)
PawnSensingComponent.HearingThreshold = 0xf8 // float (Size: 0x4)
PawnSensingComponent.LOSHearingThreshold = 0xfc // float (Size: 0x4)
PawnSensingComponent.SightRadius = 0x100 // float (Size: 0x4)
PawnSensingComponent.SensingInterval = 0x104 // float (Size: 0x4)
PawnSensingComponent.HearingMaxSoundAge = 0x108 // float (Size: 0x4)
PawnSensingComponent.bEnableSensingUpdates = 0x10c // uint8_t (Size: 0x1)
PawnSensingComponent.bOnlySensePlayers = 0x10c // uint8_t (Size: 0x1)
PawnSensingComponent.bSeePawns = 0x10c // uint8_t (Size: 0x1)
PawnSensingComponent.bHearNoises = 0x10c // uint8_t (Size: 0x1)
PawnSensingComponent.OnSeePawn = 0x118 // FMulticastInlineDelegate (Size: 0x10)
PawnSensingComponent.OnHearNoise = 0x128 // FMulticastInlineDelegate (Size: 0x10)
PawnSensingComponent.PeripheralVisionAngle = 0x138 // float (Size: 0x4)
PawnSensingComponent.PeripheralVisionCosine = 0x13c // float (Size: 0x4)
AIRLAgentComponent.bAuto = 0xf8 // bool (Size: 0x1)
AIRLAgentComponent.EpisodeID = 0xfc // int32_t (Size: 0x4)
AIRLAgentComponent.AIType = 0x100 // int32_t (Size: 0x4)
AIRLAgentComponent.Settings = 0x108 // AIRLSettings* (Size: 0x8)
AIRLAgentComponent.AgentID = 0x110 // int32_t (Size: 0x4)
AIRLAgentComponent.ActionDataLenDefault = 0x180 // int32_t (Size: 0x4)
AIRLEpisodeComponent.bAuto = 0xf8 // bool (Size: 0x1)
AIRLEpisodeComponent.EpisodeID = 0xfc // int32_t (Size: 0x4)
AIRLEpisodeComponent.EpisodeStartDataLen = 0x104 // int32_t (Size: 0x4)
AIRLEpisodeComponent.EpisodeEndDataLen = 0x10c // int32_t (Size: 0x4)
AIRLManager.InitDataLength = 0x318 // int32_t (Size: 0x4)
AIRLSettings.ClientVersion = 0x38 // FString (Size: 0x10)
AIRLSettings.RouterIP = 0x48 // FString (Size: 0x10)
AIRLSettings.RouterPort = 0x58 // int32_t (Size: 0x4)
AIRLSettings.BussName = 0x60 // FString (Size: 0x10)
AIRLSettings.UpdateIntervalSeconds = 0x70 // float (Size: 0x4)
AIRLSettings.SubLevelForTraining = 0x78 // FSoftObjectPath (Size: 0x18)
AIRLSettings.LevelAssetToRLMode = 0x90 // TMap<...> (Size: 0x50)
AIRLSubsystem.CachedAIRLManager = 0x48 // AIRLManager* (Size: 0x8)
BTDecorator_AIRLMode.IsAIRLEnabled = 0x68 // bool (Size: 0x1)
BTDecorator_AIRLMode.CachedBTComp = 0x70 // BehaviorTreeComponent* (Size: 0x8)
MapRule.MapPath = 0x0 // FSoftObjectPath (Size: 0x18)
MapRule.RuleIDs = 0x18 // TArray<int32_t> (Size: 0x10)
ActorLayer.Name = 0x0 // FName (Size: 0x8)
AkAcousticPortal.HighlightActor = 0x348 // StaticMeshActor* (Size: 0x8)
AkAcousticPortal.HighlightMaterial = 0x358 // Material* (Size: 0x8)
AkAcousticPortal.Room = 0x360 // AkSpatialAudioVolume* (Size: 0x8)
AkAcousticPortal.Portal = 0x368 // AkPortalComponent* (Size: 0x8)
AkAcousticPortal.IndoorEnvironalTransRadius = 0x370 // float (Size: 0x4)
AkAcousticPortal.OutdoorEnvironalTransRadius = 0x374 // float (Size: 0x4)
AkAcousticPortal.OutdoorAccurateLoadRadius = 0x378 // float (Size: 0x4)
AkAcousticPortal.Outside = 0x37c // bool (Size: 0x1)
AkAcousticPortal.InitialState = 0x37d // EAkAcousticPortalState (Size: 0x1)
AkAcousticPortal.AkAmbientSound = 0x380 // AkAmbientSound* (Size: 0x8)
AkAcousticPortal.MultiSourceSound = 0x388 // MultiSourceSoundComponent* (Size: 0x8)
AkAcousticPortal.bRequiresStateMigration = 0x390 // bool (Size: 0x1)
AkAcousticSurface.Texture = 0x0 // uint32_t (Size: 0x4)
AkAcousticSurface.Occlusion = 0x4 // float (Size: 0x4)
AkAcousticSurface.Name = 0x8 // FString (Size: 0x10)
AkAcousticTextureParams.AbsorptionValues = 0x0 // FVector4 (Size: 0x10)
AkAdvancedInitializationSettings.IO_MemorySize = 0x0 // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.IO_Granularity = 0x4 // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.TargetAutoStreamBufferLength = 0x8 // float (Size: 0x4)
AkAdvancedInitializationSettings.UseStreamCache = 0xc // bool (Size: 0x1)
AkAdvancedInitializationSettings.MaximumPinnedBytesInCache = 0x10 // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.EnableGameSyncPreparation = 0x14 // bool (Size: 0x1)
AkAdvancedInitializationSettings.ContinuousPlaybackLookAhead = 0x18 // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.MonitorQueuePoolSize = 0x1c // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.MaximumHardwareTimeoutMs = 0x20 // uint32_t (Size: 0x4)
AkAdvancedInitializationSettings.DebugOutOfRangeCheckEnabled = 0x24 // bool (Size: 0x1)
AkAdvancedInitializationSettings.DebugOutOfRangeLimit = 0x28 // float (Size: 0x4)
AkAdvancedInitializationSettingsWithMultiCoreRendering.EnableMultiCoreRendering = 0x2c // bool (Size: 0x1)
AkAmbientSound.AkAudioEvent = 0x310 // AkAudioEvent* (Size: 0x8)
AkAmbientSound.AkComponent = 0x318 // AkComponent* (Size: 0x8)
AkAmbientSound.StopWhenOwnerIsDestroyed = 0x320 // bool (Size: 0x1)
AkAmbientSound.AutoPost = 0x321 // bool (Size: 0x1)
AkAndroidAdvancedInitializationSettings.AudioAPI = 0x30 // uint32_t (Size: 0x4)
AkAndroidAdvancedInitializationSettings.RoundFrameSizeToHardwareSize = 0x34 // bool (Size: 0x1)
AkAndroidInitializationSettings.CommonSettings = 0x30 // FAkCommonInitializationSettingsWithSampleRate (Size: 0x68)
AkAndroidInitializationSettings.CommunicationSettings = 0x98 // FAkCommunicationSettingsWithSystemInitialization (Size: 0x28)
AkAndroidInitializationSettings.AdvancedSettings = 0xc0 // FAkAndroidAdvancedInitializationSettings (Size: 0x38)
AkAssetBase.PlatformAssetData = 0x40 // AkAssetPlatformData* (Size: 0x8)
AkAssetData.CachedHash = 0x28 // uint32_t (Size: 0x4)
AkAssetData.BankLanguage = 0x30 // FString (Size: 0x10)
AkAssetDataSwitchContainer.SwitchContainers = 0x88 // TArray<AkAssetDataSwitchContainerData*> (Size: 0x10)
AkAssetDataSwitchContainer.DefaultGroupValue = 0x98 // AkGroupValue* (Size: 0x8)
AkAssetDataSwitchContainerData.GroupValue = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
AkAssetDataSwitchContainerData.DefaultGroupValue = 0x50 // AkGroupValue* (Size: 0x8)
AkAssetDataSwitchContainerData.MediaList = 0x58 // TArray<AkMediaAsset*> (Size: 0x10)
AkAssetDataSwitchContainerData.Children = 0x68 // TArray<AkAssetDataSwitchContainerData*> (Size: 0x10)
AkAssetDataWithMedia.MediaList = 0x78 // TArray<AkMediaAsset*> (Size: 0x10)
AkAssetPlatformData.CurrentAssetData = 0x28 // AkAssetData* (Size: 0x8)
AkAudioBank.AutoLoad = 0x50 // bool (Size: 0x1)
AkAudioBank.LocalizedPlatformAssetDataMap = 0x58 // TMap<...> (Size: 0x50)
AkAudioBank.LinkedAkEvents = 0xa8 // TSet<...> (Size: 0x50)
AkAudioBank.CurrentLocalizedPlatformAssetData = 0xf8 // AkAssetPlatformData* (Size: 0x8)
AkAudioEvent.LocalizedPlatformAssetDataMap = 0x50 // TMap<...> (Size: 0x50)
AkAudioEvent.RequiredBank = 0xa0 // AkAudioBank* (Size: 0x8)
AkAudioEvent.LastRequiredBank = 0xa8 // AkAudioBank* (Size: 0x8)
AkAudioEvent.CurrentLocalizedPlatformData = 0xb0 // AkAssetPlatformData* (Size: 0x8)
AkAudioEvent.MaxAttenuationRadius = 0xb8 // float (Size: 0x4)
AkAudioEvent.IsInfinite = 0xbc // bool (Size: 0x1)
AkAudioEvent.MinimumDuration = 0xc0 // float (Size: 0x4)
AkAudioEvent.MaximumDuration = 0xc4 // float (Size: 0x4)
AkAudioEventData.MaxAttenuationRadius = 0xf0 // float (Size: 0x4)
AkAudioEventData.IsInfinite = 0xf4 // bool (Size: 0x1)
AkAudioEventData.MinimumDuration = 0xf8 // float (Size: 0x4)
AkAudioEventData.MaximumDuration = 0xfc // float (Size: 0x4)
AkAudioEventData.LocalizedMedia = 0x100 // TMap<...> (Size: 0x50)
AkAudioEventData.PostedEvents = 0x150 // TSet<...> (Size: 0x50)
AkAudioEventData.UserDefinedSends = 0x1a0 // TSet<...> (Size: 0x50)
AkAudioEventData.PostedTriggers = 0x1f0 // TSet<...> (Size: 0x50)
AkAudioEventData.GroupValues = 0x240 // TSet<...> (Size: 0x50)
AkAudioSession.AudioSessionCategory = 0x0 // EEAkAudioSessionCategory (Size: 0x4)
AkAudioSession.AudioSessionCategoryOptions = 0x4 // uint32_t (Size: 0x4)
AkAudioSession.AudioSessionMode = 0x8 // EEAkAudioSessionMode (Size: 0x4)
AkAudioType.ShortID = 0x28 // uint32_t (Size: 0x4)
AkAudioType.UserData = 0x30 // TArray<Object*> (Size: 0x10)
AkAuxBus.RequiredBank = 0x50 // AkAudioBank* (Size: 0x8)
AkBoolPropertyToControl.ItemProperty = 0x0 // FString (Size: 0x10)
AkCallbackInfo.AkComponent = 0x28 // AkComponent* (Size: 0x8)
AkChannelMask.ChannelMask = 0x0 // int32_t (Size: 0x4)
AkCheckBox.CheckedState = 0x520 // EECheckBoxState (Size: 0x1)
AkCheckBox.CheckedStateDelegate = 0x524 // FDelegate (Size: 0x10)
AkCheckBox.WidgetStyle = 0x538 // FCheckBoxStyle (Size: 0x5c8)
AkCheckBox.HorizontalAlignment = 0xb00 // uint8_t (Size: 0x1)
AkCheckBox.IsFocusable = 0xb01 // bool (Size: 0x1)
AkCheckBox.ThePropertyToControl = 0xb08 // FAkBoolPropertyToControl (Size: 0x10)
AkCheckBox.ItemToControl = 0xb18 // FAkWwiseItemToControl (Size: 0x40)
AkCheckBox.AkOnCheckStateChanged = 0xb58 // FMulticastInlineDelegate (Size: 0x10)
AkCheckBox.OnItemDropped = 0xb68 // FMulticastInlineDelegate (Size: 0x10)
AkCheckBox.OnPropertyDropped = 0xb78 // FMulticastInlineDelegate (Size: 0x10)
AkCommonInitializationSettings.MaximumNumberOfMemoryPools = 0x0 // uint32_t (Size: 0x4)
AkCommonInitializationSettings.MaximumNumberOfPositioningPaths = 0x4 // uint32_t (Size: 0x4)
AkCommonInitializationSettings.CommandQueueSize = 0x8 // uint32_t (Size: 0x4)
AkCommonInitializationSettings.SamplesPerFrame = 0xc // uint32_t (Size: 0x4)
AkCommonInitializationSettings.MainOutputSettings = 0x10 // FAkMainOutputSettings (Size: 0x28)
AkCommonInitializationSettings.StreamingLookAheadRatio = 0x38 // float (Size: 0x4)
AkCommonInitializationSettings.NumberOfRefillsInVoice = 0x3c // uint16_t (Size: 0x2)
AkCommonInitializationSettings.SpatialAudioSettings = 0x40 // FAkSpatialAudioSettings (Size: 0x20)
AkCommonInitializationSettingsWithSampleRate.SampleRate = 0x60 // uint32_t (Size: 0x4)
AkCommunicationSettings.PoolSize = 0x0 // uint32_t (Size: 0x4)
AkCommunicationSettings.DiscoveryBroadcastPort = 0x4 // uint16_t (Size: 0x2)
AkCommunicationSettings.CommandPort = 0x6 // uint16_t (Size: 0x2)
AkCommunicationSettings.NotificationPort = 0x8 // uint16_t (Size: 0x2)
AkCommunicationSettings.NetworkName = 0x10 // FString (Size: 0x10)
AkCommunicationSettingsWithCommSelection.CommunicationSystem = 0x20 // EEAkCommSystem (Size: 0x4)
AkCommunicationSettingsWithSystemInitialization.InitializeSystemComms = 0x20 // bool (Size: 0x1)
AkComponent.bUseSpatialAudio = 0x258 // bool (Size: 0x1)
AkComponent.OcclusionCollisionChannel = 0x260 // uint8_t (Size: 0x1)
AkComponent.EnableSpotReflectors = 0x261 // bool (Size: 0x1)
AkComponent.OuterRadius = 0x264 // float (Size: 0x4)
AkComponent.InnerRadius = 0x268 // float (Size: 0x4)
AkComponent.EarlyReflectionAuxBus = 0x270 // AkAuxBus* (Size: 0x8)
AkComponent.EarlyReflectionAuxBusName = 0x278 // FString (Size: 0x10)
AkComponent.EarlyReflectionOrder = 0x288 // int32_t (Size: 0x4)
AkComponent.EarlyReflectionBusSendGain = 0x28c // float (Size: 0x4)
AkComponent.EarlyReflectionMaxPathLength = 0x290 // float (Size: 0x4)
AkComponent.roomReverbAuxBusGain = 0x294 // float (Size: 0x4)
AkComponent.diffractionMaxEdges = 0x298 // int32_t (Size: 0x4)
AkComponent.diffractionMaxPaths = 0x29c // int32_t (Size: 0x4)
AkComponent.diffractionMaxPathLength = 0x2a0 // float (Size: 0x4)
AkComponent.StopWhenOwnerDestroyed = 0x2a4 // bool (Size: 0x1)
AkComponent.AttenuationScalingFactor = 0x2a8 // float (Size: 0x4)
AkComponent.OcclusionRefreshInterval = 0x2ac // float (Size: 0x4)
AkComponent.bUseReverbVolumes = 0x2b0 // bool (Size: 0x1)
AkComponent.bAutoCulling = 0x2b1 // bool (Size: 0x1)
AkComponent.Listeners = 0x380 // TSet<...> (Size: 0x50)
AkComponent.Emitters = 0x3d0 // TSet<...> (Size: 0x50)
AkComponent.CurrentRoom = 0x420 // AkRoomComponent* (Size: 0x8)
AkComponent.CurrVirtualRoom = 0x428 // CAVirtualRoomComponent* (Size: 0x8)
AkComponent.DynamicTickInterval = 0x44c // bool (Size: 0x1)
AkComponent.AutoPostEvent = 0x44d // bool (Size: 0x1)
AkComponent.UseFloorSystem = 0x44e // bool (Size: 0x1)
AkComponent.CurrentFloor = 0x450 // int32_t (Size: 0x4)
AkComponent.SpecialInsideOutValue = 0x454 // float (Size: 0x4)
AkComponent.TickIntervalInFrames = 0x460 // uint8_t (Size: 0x1)
AkComponent.DistanceToListener = 0x464 // float (Size: 0x4)
AkComponent.IsListeningToSelf = 0x468 // bool (Size: 0x1)
AkComponent.CurrentSpeakingDialog = 0x470 // FVoicePlayingData (Size: 0x28)
AkComponent.Category = 0x4d0 // FName (Size: 0x8)
AkDurationCallbackInfo.Duration = 0x38 // float (Size: 0x4)
AkDurationCallbackInfo.EstimatedDuration = 0x3c // float (Size: 0x4)
AkDurationCallbackInfo.AudioNodeID = 0x40 // int32_t (Size: 0x4)
AkDurationCallbackInfo.MediaID = 0x44 // int32_t (Size: 0x4)
AkDurationCallbackInfo.bStreaming = 0x48 // bool (Size: 0x1)
AkEventCallbackInfo.PlayingID = 0x30 // int32_t (Size: 0x4)
AkEventCallbackInfo.eventId = 0x34 // int32_t (Size: 0x4)
AkExternalSourceInfo.ExternalSrcName = 0x0 // FString (Size: 0x10)
AkExternalSourceInfo.CodecID = 0x10 // EAkCodecId (Size: 0x1)
AkExternalSourceInfo.Filename = 0x18 // FString (Size: 0x10)
AkExternalSourceInfo.ExternalSourceAsset = 0x28 // AkExternalMediaAsset* (Size: 0x8)
AkExternalSourceInfo.IsStreamed = 0x30 // bool (Size: 0x1)
AkFolder.UnrealFolderPath = 0x40 // FString (Size: 0x10)
AkFolder.WwiseFolderPath = 0x50 // FString (Size: 0x10)
AkGameObject.AkAudioEvent = 0x238 // AkAudioEvent* (Size: 0x8)
AkGameObject.EventName = 0x240 // FString (Size: 0x10)
AkGeometryComponent.MeshType = 0x250 // EAkMeshType (Size: 0x1)
AkGeometryComponent.LOD = 0x254 // int32_t (Size: 0x4)
AkGeometryComponent.WeldingThreshold = 0x258 // float (Size: 0x4)
AkGeometryComponent.StaticMeshSurfaceOverride = 0x260 // TMap<...> (Size: 0x50)
AkGeometryComponent.CollisionMeshSurfaceOverride = 0x2b0 // FAkGeometrySurfaceOverride (Size: 0x18)
AkGeometryComponent.bEnableDiffraction = 0x2c8 // bool (Size: 0x1)
AkGeometryComponent.bEnableDiffractionOnBoundaryEdges = 0x2c9 // bool (Size: 0x1)
AkGeometryComponent.AssociatedRoom = 0x2d0 // Actor* (Size: 0x8)
AkGeometryComponent.HighlightVolumeActor = 0x2e0 // StaticMeshActor* (Size: 0x8)
AkGeometryComponent.HighlightMaterial = 0x2e8 // Material* (Size: 0x8)
AkGeometryComponent.OwnerMaterials = 0x2f0 // TArray<MaterialInterface*> (Size: 0x10)
AkGeometryComponent.Parent = 0x308 // PrimitiveComponent* (Size: 0x8)
AkGeometryComponent.GeometryData = 0x310 // FAkGeometryData (Size: 0x50)
AkGeometryComponent.SurfaceAreas = 0x360 // TMap<...> (Size: 0x50)
AkGeometryComponent.PreviousStaticMeshSurfaceOverride = 0x3b0 // TMap<...> (Size: 0x50)
AkGeometryComponent.OriginVertices = 0x400 // TArray<FVector> (Size: 0x10)
AkGeometryData.Vertices = 0x0 // TArray<FVector> (Size: 0x10)
AkGeometryData.Surfaces = 0x10 // TArray<FAkAcousticSurface> (Size: 0x10)
AkGeometryData.Triangles = 0x20 // TArray<FAkTriangle> (Size: 0x10)
AkGeometryData.ToOverrideAcousticTexture = 0x30 // TArray<PhysicalMaterial*> (Size: 0x10)
AkGeometryData.ToOverrideOcclusion = 0x40 // TArray<PhysicalMaterial*> (Size: 0x10)
AkGeometrySurfaceOverride.AcousticTexture = 0x0 // AkAcousticTexture* (Size: 0x8)
AkGeometrySurfaceOverride.bEnableOcclusionOverride = 0x8 // bool (Size: 0x1)
AkGeometrySurfaceOverride.OcclusionValue = 0xc // float (Size: 0x4)
AkGeometrySurfaceOverride.SurfaceArea = 0x10 // float (Size: 0x4)
AkGeometrySurfacePropertiesToMap.AcousticTexture = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
AkGeometrySurfacePropertiesToMap.OcclusionValue = 0x28 // float (Size: 0x4)
AkGroupValue.MediaDependencies = 0x40 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
AkGroupValue.GroupShortID = 0x50 // uint32_t (Size: 0x4)
AkIOSInitializationSettings.CommonSettings = 0x30 // FAkCommonInitializationSettingsWithSampleRate (Size: 0x68)
AkIOSInitializationSettings.AudioSession = 0x98 // FAkAudioSession (Size: 0xc)
AkIOSInitializationSettings.CommunicationSettings = 0xa8 // FAkCommunicationSettingsWithSystemInitialization (Size: 0x28)
AkIOSInitializationSettings.AdvancedSettings = 0xd0 // FAkAdvancedInitializationSettings (Size: 0x2c)
AkInitBank.AvailableAudioCultures = 0x50 // TArray<FString> (Size: 0x10)
AkInitBank.DefaultLanguage = 0x60 // FString (Size: 0x10)
AkInitBankAssetData.PluginInfos = 0x88 // TArray<FAkPluginInfo> (Size: 0x10)
AkItemBoolProperties.OnSelectionChanged = 0x130 // FMulticastInlineDelegate (Size: 0x10)
AkItemBoolProperties.OnPropertyDragged = 0x140 // FMulticastInlineDelegate (Size: 0x10)
AkItemProperties.OnSelectionChanged = 0x130 // FMulticastInlineDelegate (Size: 0x10)
AkItemProperties.OnPropertyDragged = 0x140 // FMulticastInlineDelegate (Size: 0x10)
AkLateReverbComponent.bEnable = 0x238 // bool (Size: 0x1)
AkLateReverbComponent.SendLevel = 0x23c // float (Size: 0x4)
AkLateReverbComponent.FadeRate = 0x240 // float (Size: 0x4)
AkLateReverbComponent.Priority = 0x244 // float (Size: 0x4)
AkLateReverbComponent.AutoAssignAuxBus = 0x248 // bool (Size: 0x1)
AkLateReverbComponent.AuxBus = 0x250 // AkAuxBus* (Size: 0x8)
AkLateReverbComponent.AuxBusName = 0x258 // FString (Size: 0x10)
AkLateReverbComponent.ParentSplineRegion = 0x298 // SplineSound* (Size: 0x8)
AkLateReverbComponent.AuxBusManual = 0x2a0 // AkAuxBus* (Size: 0x8)
AkLinuxInitializationSettings.CommonSettings = 0x30 // FAkCommonInitializationSettingsWithSampleRate (Size: 0x68)
AkLinuxInitializationSettings.CommunicationSettings = 0x98 // FAkCommunicationSettingsWithSystemInitialization (Size: 0x28)
AkLinuxInitializationSettings.AdvancedSettings = 0xc0 // FAkAdvancedInitializationSettingsWithMultiCoreRendering (Size: 0x30)
AkMacInitializationSettings.CommonSettings = 0x30 // FAkCommonInitializationSettingsWithSampleRate (Size: 0x68)
AkMacInitializationSettings.CommunicationSettings = 0x98 // FAkCommunicationSettingsWithSystemInitialization (Size: 0x28)
AkMacInitializationSettings.AdvancedSettings = 0xc0 // FAkAdvancedInitializationSettingsWithMultiCoreRendering (Size: 0x30)
AkMainOutputSettings.AudioDeviceShareset = 0x0 // FString (Size: 0x10)
AkMainOutputSettings.DeviceID = 0x10 // uint32_t (Size: 0x4)
AkMainOutputSettings.PanningRule = 0x14 // EEAkPanningRule (Size: 0x4)
AkMainOutputSettings.ChannelConfigType = 0x18 // EEAkChannelConfigType (Size: 0x4)
AkMainOutputSettings.ChannelMask = 0x1c // uint32_t (Size: 0x4)
AkMainOutputSettings.NumberOfChannels = 0x20 // uint32_t (Size: 0x4)
AkMarkerCallbackInfo.Identifier = 0x38 // int32_t (Size: 0x4)
AkMarkerCallbackInfo.position = 0x3c // int32_t (Size: 0x4)
AkMarkerCallbackInfo.label = 0x40 // FString (Size: 0x10)
AkMediaAsset.ID = 0x28 // uint32_t (Size: 0x4)
AkMediaAsset.MediaName = 0x30 // FString (Size: 0x10)
AkMediaAsset.AutoLoad = 0x40 // bool (Size: 0x1)
AkMediaAsset.UserData = 0x48 // TArray<Object*> (Size: 0x10)
AkMediaAsset.Language = 0x58 // FString (Size: 0x10)
AkMediaAsset.CurrentMediaAssetData = 0x68 // AkMediaAssetData* (Size: 0x8)
AkMediaAssetData.IsStreamed = 0x28 // bool (Size: 0x1)
AkMediaAssetData.UseDeviceMemory = 0x29 // bool (Size: 0x1)
AkMediaAssetData.Language = 0x30 // FString (Size: 0x10)
AkMediaAssetData.AssetPlatform = 0x40 // FString (Size: 0x10)
AkMidiCc.Cc = 0x2 // EEAkMidiCcValues (Size: 0x1)
AkMidiCc.Value = 0x3 // uint8_t (Size: 0x1)
AkMidiChannelAftertouch.Value = 0x2 // uint8_t (Size: 0x1)
AkMidiEventBase.Type = 0x0 // EEAkMidiEventType (Size: 0x1)
AkMidiEventBase.Chan = 0x1 // uint8_t (Size: 0x1)
AkMidiGeneric.Param1 = 0x2 // uint8_t (Size: 0x1)
AkMidiGeneric.Param2 = 0x3 // uint8_t (Size: 0x1)
AkMidiNoteAftertouch.Note = 0x2 // uint8_t (Size: 0x1)
AkMidiNoteAftertouch.Value = 0x3 // uint8_t (Size: 0x1)
AkMidiNoteOnOff.Note = 0x2 // uint8_t (Size: 0x1)
AkMidiNoteOnOff.Velocity = 0x3 // uint8_t (Size: 0x1)
AkMidiPitchBend.ValueLsb = 0x2 // uint8_t (Size: 0x1)
AkMidiPitchBend.ValueMsb = 0x3 // uint8_t (Size: 0x1)
AkMidiPitchBend.FullValue = 0x4 // int32_t (Size: 0x4)
AkMidiProgramChange.ProgramNum = 0x2 // uint8_t (Size: 0x1)
AkMusicSyncCallbackInfo.PlayingID = 0x30 // int32_t (Size: 0x4)
AkMusicSyncCallbackInfo.SegmentInfo = 0x34 // FAkSegmentInfo (Size: 0x24)
AkMusicSyncCallbackInfo.MusicSyncType = 0x58 // EEAkCallbackType (Size: 0x1)
AkMusicSyncCallbackInfo.UserCueName = 0x60 // FString (Size: 0x10)
AkOutputSettings.AudioDeviceSharesetName = 0x0 // FString (Size: 0x10)
AkOutputSettings.IdDevice = 0x10 // int32_t (Size: 0x4)
AkOutputSettings.PanRule = 0x14 // EPanningRule (Size: 0x1)
AkOutputSettings.ChannelConfig = 0x15 // EAkChannelConfiguration (Size: 0x1)
AkPluginInfo.Name = 0x0 // FString (Size: 0x10)
AkPluginInfo.PluginID = 0x10 // uint32_t (Size: 0x4)
AkPluginInfo.dll = 0x18 // FString (Size: 0x10)
AkPortalComponent.bDynamic = 0x238 // bool (Size: 0x1)
AkPortalComponent.InitialState = 0x239 // EAkAcousticPortalState (Size: 0x1)
AkPortalComponent.ObstructionRefreshInterval = 0x23c // float (Size: 0x4)
AkPortalComponent.ObstructionCollisionChannel = 0x240 // uint8_t (Size: 0x1)
AkPortalComponent.AutoDisableDistance = 0x244 // float (Size: 0x4)
AkPortalComponent.fTickInterval = 0x248 // float (Size: 0x4)
AkPortalComponent.Parent = 0x258 // PrimitiveComponent* (Size: 0x8)
AkPropertyToControl.ItemProperty = 0x0 // FString (Size: 0x10)
AkReverbVolume.bEnabled = 0x348 // bool (Size: 0x1)
AkReverbVolume.AuxBus = 0x350 // AkAuxBus* (Size: 0x8)
AkReverbVolume.AuxBusName = 0x358 // FString (Size: 0x10)
AkReverbVolume.SendLevel = 0x368 // float (Size: 0x4)
AkReverbVolume.FadeRate = 0x36c // float (Size: 0x4)
AkReverbVolume.Priority = 0x370 // float (Size: 0x4)
AkReverbVolume.LateReverbComponent = 0x378 // AkLateReverbComponent* (Size: 0x8)
AkRoomComponent.bEnable = 0x258 // bool (Size: 0x1)
AkRoomComponent.bDynamic = 0x259 // bool (Size: 0x1)
AkRoomComponent.Priority = 0x25c // float (Size: 0x4)
AkRoomComponent.WallOcclusion = 0x260 // float (Size: 0x4)
AkRoomComponent.RoomOcclusionValue = 0x264 // float (Size: 0x4)
AkRoomComponent.SkipAutoSwitchInDoorState = 0x268 // bool (Size: 0x1)
AkRoomComponent.AuxSendLevel = 0x26c // float (Size: 0x4)
AkRoomComponent.AutoPost = 0x270 // bool (Size: 0x1)
AkRoomComponent.SameAVolumeLateReverbCom = 0x278 // AkLateReverbComponent* (Size: 0x8)
AkRoomComponent.GeometryComponent = 0x2a0 // AkAcousticTextureSetComponent* (Size: 0x8)
AkRoomInfo.RoomActorName = 0x0 // FString (Size: 0x10)
AkRoomInfo.RoomLocation = 0x10 // FVector (Size: 0xc)
AkSegmentInfo.CurrentPosition = 0x0 // int32_t (Size: 0x4)
AkSegmentInfo.PreEntryDuration = 0x4 // int32_t (Size: 0x4)
AkSegmentInfo.ActiveDuration = 0x8 // int32_t (Size: 0x4)
AkSegmentInfo.PostExitDuration = 0xc // int32_t (Size: 0x4)
AkSegmentInfo.RemainingLookAheadTime = 0x10 // int32_t (Size: 0x4)
AkSegmentInfo.BeatDuration = 0x14 // float (Size: 0x4)
AkSegmentInfo.BarDuration = 0x18 // float (Size: 0x4)
AkSegmentInfo.GridDuration = 0x1c // float (Size: 0x4)
AkSegmentInfo.GridOffset = 0x20 // float (Size: 0x4)
AkSettings.MaxSimultaneousReverbVolumes = 0x28 // uint8_t (Size: 0x1)
AkSettings.WwiseProjectPath = 0x30 // FFilePath (Size: 0x10)
AkSettings.WwiseSoundDataFolder = 0x40 // FDirectoryPath (Size: 0x10)
AkSettings.bAutoConnectToWAAPI = 0x50 // bool (Size: 0x1)
AkSettings.DefaultOcclusionCollisionChannel = 0x51 // uint8_t (Size: 0x1)
AkSettings.DefaultFitToGeometryCollisionChannel = 0x52 // uint8_t (Size: 0x1)
AkSettings.AkGeometryMap = 0x58 // TMap<...> (Size: 0x50)
AkSettings.GlobalDecayAbsorption = 0xa8 // float (Size: 0x4)
AkSettings.DefaultReverbAuxBus = 0xb0 // TSoftObjectPtr<UObject> (Size: 0x28)
AkSettings.EnvironmentDecayAuxBusMap = 0xd8 // TMap<...> (Size: 0x50)
AkSettings.HFDampingName = 0x128 // FString (Size: 0x10)
AkSettings.DecayEstimateName = 0x138 // FString (Size: 0x10)
AkSettings.TimeToFirstReflectionName = 0x148 // FString (Size: 0x10)
AkSettings.HFDampingRTPC = 0x158 // TSoftObjectPtr<UObject> (Size: 0x28)
AkSettings.DecayEstimateRTPC = 0x180 // TSoftObjectPtr<UObject> (Size: 0x28)
AkSettings.TimeToFirstReflectionRTPC = 0x1a8 // TSoftObjectPtr<UObject> (Size: 0x28)
AkSettings.AudioInputEvent = 0x1d0 // TSoftObjectPtr<UObject> (Size: 0x28)
AkSettings.AcousticTextureParamsMap = 0x1f8 // TMap<...> (Size: 0x50)
AkSettings.SplitSwitchContainerMedia = 0x248 // bool (Size: 0x1)
AkSettings.SplitMediaPerFolder = 0x249 // bool (Size: 0x1)
AkSettings.UseEventBasedPackaging = 0x24a // bool (Size: 0x1)
AkSettings.EnableAutomaticAssetSynchronization = 0x24b // bool (Size: 0x1)
AkSettings.CommandletCommitMessage = 0x250 // FString (Size: 0x10)
AkSettings.UnrealCultureToWwiseCulture = 0x260 // TMap<...> (Size: 0x50)
AkSettings.AskedToUseNewAssetManagement = 0x2b0 // bool (Size: 0x1)
AkSettings.bEnableMultiCoreRendering = 0x2b1 // bool (Size: 0x1)
AkSettings.MigratedEnableMultiCoreRendering = 0x2b2 // bool (Size: 0x1)
AkSettings.FixupRedirectorsDuringMigration = 0x2b3 // bool (Size: 0x1)
AkSettings.WwiseWindowsInstallationPath = 0x2b8 // FDirectoryPath (Size: 0x10)
AkSettings.WwiseMacInstallationPath = 0x2c8 // FFilePath (Size: 0x10)
AkSettingsPerUser.WwiseWindowsInstallationPath = 0x28 // FDirectoryPath (Size: 0x10)
AkSettingsPerUser.WwiseMacInstallationPath = 0x38 // FFilePath (Size: 0x10)
AkSettingsPerUser.EnableAutomaticAssetSynchronization = 0x48 // bool (Size: 0x1)
AkSettingsPerUser.WaapiIPAddress = 0x50 // FString (Size: 0x10)
AkSettingsPerUser.WaapiPort = 0x60 // uint32_t (Size: 0x4)
AkSettingsPerUser.bAutoConnectToWAAPI = 0x64 // bool (Size: 0x1)
AkSettingsPerUser.AutoSyncSelection = 0x65 // bool (Size: 0x1)
AkSettingsPerUser.SuppressWwiseProjectPathWarnings = 0x66 // bool (Size: 0x1)
AkSettingsPerUser.SoundDataGenerationSkipLanguage = 0x67 // bool (Size: 0x1)
AkSlider.Value = 0x130 // float (Size: 0x4)
AkSlider.ValueDelegate = 0x134 // FDelegate (Size: 0x10)
AkSlider.WidgetStyle = 0x148 // FSliderStyle (Size: 0x370)
AkSlider.Orientation = 0x4b8 // uint8_t (Size: 0x1)
AkSlider.SliderBarColor = 0x4bc // FLinearColor (Size: 0x10)
AkSlider.SliderHandleColor = 0x4cc // FLinearColor (Size: 0x10)
AkSlider.IndentHandle = 0x4dc // bool (Size: 0x1)
AkSlider.Locked = 0x4dd // bool (Size: 0x1)
AkSlider.StepSize = 0x4e0 // float (Size: 0x4)
AkSlider.IsFocusable = 0x4e4 // bool (Size: 0x1)
AkSlider.ThePropertyToControl = 0x4e8 // FAkPropertyToControl (Size: 0x10)
AkSlider.ItemToControl = 0x4f8 // FAkWwiseItemToControl (Size: 0x40)
AkSlider.OnValueChanged = 0x538 // FMulticastInlineDelegate (Size: 0x10)
AkSlider.OnItemDropped = 0x548 // FMulticastInlineDelegate (Size: 0x10)
AkSlider.OnPropertyDropped = 0x558 // FMulticastInlineDelegate (Size: 0x10)
AkSpatialAudioBakeData.PortalActorName = 0x8 // FString (Size: 0x10)
AkSpatialAudioBakeData.PortalLocation = 0x18 // FVector (Size: 0xc)
AkSpatialAudioBakeData.FrontRoom = 0x28 // FAkRoomInfo (Size: 0x20)
AkSpatialAudioBakeData.BackRoom = 0x48 // FAkRoomInfo (Size: 0x20)
AkSpatialAudioBakeData.bHasFrontRoom = 0x68 // bool (Size: 0x1)
AkSpatialAudioBakeData.bHasBackRoom = 0x69 // bool (Size: 0x1)
AkSpatialAudioSettings.MaxSoundPropagationDepth = 0x0 // uint32_t (Size: 0x4)
AkSpatialAudioSettings.MovementThreshold = 0x4 // float (Size: 0x4)
AkSpatialAudioSettings.NumberOfPrimaryRays = 0x8 // uint32_t (Size: 0x4)
AkSpatialAudioSettings.ReflectionOrder = 0xc // uint32_t (Size: 0x4)
AkSpatialAudioSettings.MaximumPathLength = 0x10 // float (Size: 0x4)
AkSpatialAudioSettings.CPULimitPercentage = 0x14 // float (Size: 0x4)
AkSpatialAudioSettings.EnableDiffractionOnReflections = 0x18 // bool (Size: 0x1)
AkSpatialAudioSettings.EnableGeometricDiffractionAndTransmission = 0x19 // bool (Size: 0x1)
AkSpatialAudioSettings.CalcEmitterVirtualPosition = 0x1a // bool (Size: 0x1)
AkSpatialAudioSettings.UseObstruction = 0x1b // bool (Size: 0x1)
AkSpatialAudioSettings.UseOcclusion = 0x1c // bool (Size: 0x1)
AkSpatialAudioVolume.HighlightVolumeActor = 0x348 // StaticMeshActor* (Size: 0x8)
AkSpatialAudioVolume.DrawDebugColor = 0x368 // FLinearColor (Size: 0x10)
AkSpatialAudioVolume.DrawVolumeComponent = 0x378 // DrawVolumeComponent* (Size: 0x8)
AkSpatialAudioVolume.IndoorEnvironalTransRadius = 0x380 // float (Size: 0x4)
AkSpatialAudioVolume.OutdoorEnvironalTransRadius = 0x384 // float (Size: 0x4)
AkSpatialAudioVolume.OutdoorAccurateLoadRadius = 0x388 // float (Size: 0x4)
AkSpatialAudioVolume.RoomIndex = 0x38c // int32_t (Size: 0x4)
AkSpatialAudioVolume.HighlightMaterial = 0x390 // Material* (Size: 0x8)
AkSpatialAudioVolume.SetStateComponent = 0x398 // SetStateComponent* (Size: 0x8)
AkSpatialAudioVolume.SetSwitchComponent = 0x3a0 // SetSwitchComponent* (Size: 0x8)
AkSpatialAudioVolume.Floor = 0x3a8 // int32_t (Size: 0x4)
AkSpatialAudioVolume.SurfaceReflectorSet = 0x3b0 // AkSurfaceReflectorSetComponent* (Size: 0x8)
AkSpatialAudioVolume.LateReverb = 0x3b8 // AkLateReverbComponent* (Size: 0x8)
AkSpatialAudioVolume.Room = 0x3c0 // AkRoomComponent* (Size: 0x8)
AkSpotReflector.EarlyReflectionAuxBus = 0x310 // AkAuxBus* (Size: 0x8)
AkSpotReflector.EarlyReflectionAuxBusName = 0x318 // FString (Size: 0x10)
AkSpotReflector.AcousticTexture = 0x328 // AkAcousticTexture* (Size: 0x8)
AkSpotReflector.DistanceScalingFactor = 0x330 // float (Size: 0x4)
AkSpotReflector.Level = 0x334 // float (Size: 0x4)
AkSubmixInputComponent.SubmixToRecord = 0x520 // SoundSubmix* (Size: 0x8)
AkSurfacePoly.Texture = 0x0 // AkAcousticTexture* (Size: 0x8)
AkSurfacePoly.Occlusion = 0x8 // float (Size: 0x4)
AkSurfacePoly.EnableSurface = 0xc // bool (Size: 0x1)
AkSurfacePoly.SurfaceArea = 0x10 // float (Size: 0x4)
AkSurfaceReflectorSetComponent.bEnableSurfaceReflectors = 0x250 // bool (Size: 0x1)
AkSurfaceReflectorSetComponent.AcousticPolys = 0x258 // TArray<FAkSurfacePoly> (Size: 0x10)
AkSurfaceReflectorSetComponent.bEnableDiffraction = 0x268 // bool (Size: 0x1)
AkSurfaceReflectorSetComponent.bEnableDiffractionOnBoundaryEdges = 0x269 // bool (Size: 0x1)
AkSurfaceReflectorSetComponent.AssociatedRoom = 0x270 // Actor* (Size: 0x8)
AkSurfaceReflectorSetComponent.ParentBrush = 0x278 // Model* (Size: 0x8)
AkTriangle.Point0 = 0x0 // uint16_t (Size: 0x2)
AkTriangle.Point1 = 0x2 // uint16_t (Size: 0x2)
AkTriangle.Point2 = 0x4 // uint16_t (Size: 0x2)
AkTriangle.Surface = 0x6 // uint16_t (Size: 0x2)
AkWaapiFieldNames.FieldName = 0x0 // FString (Size: 0x10)
AkWaapiUri.Uri = 0x0 // FString (Size: 0x10)
AkWindowsAdvancedInitializationSettings.UseHeadMountedDisplayAudioDevice = 0x30 // bool (Size: 0x1)
AkWindowsAdvancedInitializationSettings.MaxSystemAudioObjects = 0x34 // uint32_t (Size: 0x4)
AkWindowsInitializationSettings.CommonSettings = 0x30 // FAkCommonInitializationSettingsWithSampleRate (Size: 0x68)
AkWindowsInitializationSettings.CommunicationSettings = 0x98 // FAkCommunicationSettingsWithSystemInitialization (Size: 0x28)
AkWindowsInitializationSettings.AdvancedSettings = 0xc0 // FAkWindowsAdvancedInitializationSettings (Size: 0x38)
AkWwiseItemToControl.ItemPicked = 0x0 // FAkWwiseObjectDetails (Size: 0x30)
AkWwiseItemToControl.ItemPath = 0x30 // FString (Size: 0x10)
AkWwiseObjectDetails.ItemName = 0x0 // FString (Size: 0x10)
AkWwiseObjectDetails.ItemPath = 0x10 // FString (Size: 0x10)
AkWwiseObjectDetails.ItemId = 0x20 // FString (Size: 0x10)
AkWwiseTree.OnSelectionChanged = 0x130 // FMulticastInlineDelegate (Size: 0x10)
AkWwiseTree.OnItemDragged = 0x140 // FMulticastInlineDelegate (Size: 0x10)
AkWwiseTreeSelector.OnSelectionChanged = 0x130 // FMulticastInlineDelegate (Size: 0x10)
AkWwiseTreeSelector.OnItemDragged = 0x140 // FMulticastInlineDelegate (Size: 0x10)
AnimNotify_AudioBank.Bank = 0x38 // AkAudioBank* (Size: 0x8)
AnimNotify_AudioBank.Operation = 0x40 // uint8_t (Size: 0x1)
AnimNotify_AudioBank.DelaySecond = 0x44 // int32_t (Size: 0x4)
AnimNotify_PlayAudio.AudioEvent = 0x38 // AkAudioEvent* (Size: 0x8)
AnimNotify_PlayAudio.Stoppable = 0x40 // bool (Size: 0x1)
AnimNotify_PlayAudio.FollowMesh = 0x41 // bool (Size: 0x1)
AnimNotify_PlayAudio.ComponentName = 0x48 // FString (Size: 0x10)
AnimNotify_PlayAudio.UseEmitLocation = 0x58 // bool (Size: 0x1)
AnimNotify_PlayAudio.EmitLocation = 0x5c // FVector (Size: 0xc)
AnimNotify_PlayAudio.TriggerOnSwitch = 0x68 // bool (Size: 0x1)
AnimNotify_PlayAudio.IgnoreOnSwitch = 0x69 // bool (Size: 0x1)
AnimNotify_PlayAudio.SwitchGroupName = 0x70 // FString (Size: 0x10)
AnimNotify_PlayAudio.SwitchName = 0x80 // FString (Size: 0x10)
AnimNotify_PlayAudio.NotifyToAudioConsole = 0x90 // bool (Size: 0x1)
AnimNotify_PlayAudio.AnimInstance = 0x94 // TWeakObjectPtr<UObject> (Size: 0x8)
AudioConsoleMessage.TimeSeconds = 0x0 // float (Size: 0x4)
AudioConsoleMessage.Verbosity = 0x4 // uint8_t (Size: 0x1)
AudioConsoleMessage.Action = 0x5 // uint8_t (Size: 0x1)
AudioConsoleMessage.ObjectType = 0x6 // uint8_t (Size: 0x1)
AudioConsoleMessage.ObjectName = 0x8 // FString (Size: 0x10)
AudioConsoleMessage.GameObject = 0x18 // FString (Size: 0x10)
AudioConsoleMessage.Value = 0x28 // float (Size: 0x4)
AudioConsoleMessage.Source = 0x30 // FString (Size: 0x10)
AudioEmitter3D.AudioEvent = 0x310 // AkAudioEvent* (Size: 0x8)
AudioEmitter3D.AutoActivate = 0x318 // bool (Size: 0x1)
AudioEmitter3D.AutoStartStop = 0x319 // bool (Size: 0x1)
AudioEmitter3D.DistanceToStopSound = 0x31c // float (Size: 0x4)
AudioEmitter3D.AudioStudioComponents = 0x320 // TArray<AudioStudioComponent*> (Size: 0x10)
AudioEmitter3D.AkComponent = 0x330 // AkComponent* (Size: 0x8)
AudioEmitter3D.bIsSoundPlaying = 0x338 // bool (Size: 0x1)
AudioEmitter3D.bIsSoundPaused = 0x339 // bool (Size: 0x1)
AudioEventExtendData_HD.Category = 0x8 // FName (Size: 0x8)
AudioStudioEditorSettings.ShowEmitterIcons = 0x28 // bool (Size: 0x1)
AudioStudioProfileData.ak_totalCPU = 0x0 // double (Size: 0x8)
AudioStudioProfileData.ak_pluginCPU = 0x8 // double (Size: 0x8)
AudioStudioProfileData.ak_calCpuByRendertime = 0x10 // double (Size: 0x8)
AudioStudioProfileData.ak_physicalVoices = 0x18 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_virtualVoices = 0x1c // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_totalVoices = 0x20 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_nbActiveEvents = 0x24 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_memory = 0x28 // float (Size: 0x4)
AudioStudioProfileData.gameCPU = 0x2c // float (Size: 0x4)
AudioStudioProfileData.FrameTime = 0x30 // float (Size: 0x4)
AudioStudioProfileData.gameThreadTime = 0x34 // float (Size: 0x4)
AudioStudioProfileData.gameMemory = 0x38 // float (Size: 0x4)
AudioStudioProfileData.ak_memory_Used = 0x3c // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_memory_DeviceUsed = 0x40 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_memory_Reserved = 0x44 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_memory_Max = 0x48 // uint32_t (Size: 0x4)
AudioStudioProfileData.ak_volume_bus_weapon = 0x4c // float (Size: 0x4)
AudioStudioProfileData.ak_volume_bus_action = 0x50 // float (Size: 0x4)
AudioStudioProfileData.ak_volume_bus_ambience = 0x54 // float (Size: 0x4)
AudioStudioProfileData.ak_volume_bus_voice = 0x58 // float (Size: 0x4)
AudioStudioSettings.PersistentBanks = 0x28 // TArray<FString> (Size: 0x10)
AudioStudioSettings.InitialStates = 0x38 // TArray<FString> (Size: 0x10)
AudioStudioSettings.InitialEvents = 0x48 // TArray<FString> (Size: 0x10)
AudioStudioSettings.LevelAudioConfigs = 0x58 // TMap<...> (Size: 0x50)
AudioStudioSettings.DiffractionEnabledQuality = 0xa8 // uint8_t (Size: 0x1)
AudioStudioSettings.EarlyReflectionEnabledQuality = 0xa9 // uint8_t (Size: 0x1)
AudioStudioSettings.OcclusionObstructionEnabledQuality = 0xaa // uint8_t (Size: 0x1)
AudioStudioSettings.LateReverbEnabledQuality = 0xab // uint8_t (Size: 0x1)
AudioStudioSettings.SoundObjectPoolSize = 0xac // uint8_t (Size: 0x1)
AudioStudioSettings.RoomAuxBusRTPCConfigs = 0xb0 // TMap<...> (Size: 0x50)
AudioStudioSettings.EventExtendDataTable = 0x100 // FSoftObjectPath (Size: 0x18)
CAVirtualRoomComponent.Priority = 0x258 // int32_t (Size: 0x4)
CAVirtualRoomComponent.bEnable = 0x25c // uint8_t (Size: 0x1)
CAVirtualRoomComponent.FloorID = 0x260 // int32_t (Size: 0x4)
CAVirtualRoomComponent.EnableOverrideRoomSwitch = 0x264 // int32_t (Size: 0x4)
CAVirtualRoomVolume.VirtualRoom = 0x348 // CAVirtualRoomComponent* (Size: 0x8)
DrawVolumeComponent.DrawColor = 0x5c8 // FColor (Size: 0x4)
DrawVolumeComponent.DebugMaterial = 0x5d0 // Material* (Size: 0x8)
EmitterListenerManager.WwiseInfoTarget = 0x30 // Actor* (Size: 0x8)
EmitterListenerManager.OnVoiceDialogEnd = 0x58 // FMulticastInlineDelegate (Size: 0x10)
EmitterListenerManager.DefaultEmitters = 0xd0 // TArray<AkComponent*> (Size: 0x10)
EmitterListenerManager.AmbienceEmitters = 0xe0 // TArray<AudioEmitter3D*> (Size: 0x10)
EmitterListenerManager.DefaultListeners = 0xf0 // TArray<AkComponent*> (Size: 0x10)
EmitterListenerManager.SpatialAudioListener = 0x100 // AkComponent* (Size: 0x8)
EmitterListenerManager.AnimationSoundMap = 0x110 // TMap<...> (Size: 0x50)
EmitterListenerManager.MultiSourceEvents = 0x160 // TMap<...> (Size: 0x50)
EmitterListenerManager.FoliageSoundPlaybackDatas = 0x1b8 // TArray<FoliageSoundPlaybackData*> (Size: 0x10)
EmitterListenerManager.EventExtendDataTable = 0x1d0 // DataTable* (Size: 0x8)
FoliageSoundComponent.SoundConfigs = 0xf8 // TArray<FoliageSoundConfig*> (Size: 0x10)
FoliageSoundComponent.SearchRadius = 0x108 // float (Size: 0x4)
FoliageSoundConfig.AudioEvent = 0x30 // AkAudioEvent* (Size: 0x8)
FoliageSoundConfig.TriggerIntervalMin = 0x38 // float (Size: 0x4)
FoliageSoundConfig.TriggerIntervalMax = 0x3c // float (Size: 0x4)
FoliageSoundConfig.MinHeight = 0x40 // float (Size: 0x4)
FoliageSoundConfig.MaxHeight = 0x44 // float (Size: 0x4)
FoliageSoundPlaybackData.SoundConfig = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
FoliageSoundPlaybackData.FoliageSoundInstances = 0x40 // TArray<FoliageSoundComponent*> (Size: 0x10)
GlobalAmbienceEmitter.OverridingSplineSound = 0x340 // SplineSound* (Size: 0x8)
LevelAudioData.InheritedConfigName = 0x0 // FString (Size: 0x10)
LevelAudioData.Levels = 0x10 // TArray<FString> (Size: 0x10)
LevelAudioData.Banks = 0x20 // TArray<FString> (Size: 0x10)
LevelAudioData.States = 0x30 // TArray<FString> (Size: 0x10)
LevelAudioData.Events = 0x40 // TArray<FString> (Size: 0x10)
LevelAudioData.UnloadBanksOnLevelUnload = 0x50 // bool (Size: 0x1)
LevelAudioData.StopEventsOnLevelUnload = 0x51 // bool (Size: 0x1)
LevelAudioData.StopAll2DSoundsOnLevelUnload = 0x52 // bool (Size: 0x1)
LevelAudioData.LevelNameExactMatch = 0x53 // bool (Size: 0x1)
LevelAudioData.AudioDataForMode = 0x58 // TArray<FPlayModeAudioData> (Size: 0x10)
LoadBankComponent.SoundBank = 0xf8 // AkAudioBank* (Size: 0x8)
LoadBankComponent.UseCounter = 0x100 // bool (Size: 0x1)
MovieSceneAkAudioEventSection.Event = 0x128 // AkAudioEvent* (Size: 0x8)
MovieSceneAkAudioEventSection.RetriggerEvent = 0x130 // bool (Size: 0x1)
MovieSceneAkAudioEventSection.ScrubTailLengthMs = 0x134 // int32_t (Size: 0x4)
MovieSceneAkAudioEventSection.StopAtSectionEnd = 0x138 // bool (Size: 0x1)
MovieSceneAkAudioEventSection.EventName = 0x140 // FString (Size: 0x10)
MovieSceneAkAudioEventSection.MaxSourceDuration = 0x170 // float (Size: 0x4)
MovieSceneAkAudioEventSection.MaxDurationSourceID = 0x178 // FString (Size: 0x10)
MovieSceneAkAudioEventTemplate.Section = 0x20 // MovieSceneAkAudioEventSection* (Size: 0x8)
MovieSceneAkAudioRTPCSection.RTPC = 0xe8 // AkRtpc* (Size: 0x8)
MovieSceneAkAudioRTPCSection.Name = 0xf0 // FString (Size: 0x10)
MovieSceneAkAudioRTPCSection.FloatCurve = 0x100 // FRichCurve (Size: 0x80)
MovieSceneAkAudioRTPCSection.FloatChannelSerializationHelper = 0x180 // FMovieSceneFloatChannelSerializationHelper (Size: 0x30)
MovieSceneAkAudioRTPCSection.RTPCChannel = 0x1b0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneAkAudioRTPCTemplate.Section = 0x20 // MovieSceneAkAudioRTPCSection* (Size: 0x8)
MovieSceneAkTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneAkTrack.bIsAMasterTrack = 0x88 // bool (Size: 0x1)
MovieSceneFloatChannelSerializationHelper.PreInfinityExtrap = 0x0 // uint8_t (Size: 0x1)
MovieSceneFloatChannelSerializationHelper.PostInfinityExtrap = 0x1 // uint8_t (Size: 0x1)
MovieSceneFloatChannelSerializationHelper.Times = 0x8 // TArray<int32_t> (Size: 0x10)
MovieSceneFloatChannelSerializationHelper.Values = 0x18 // TArray<FMovieSceneFloatValueSerializationHelper> (Size: 0x10)
MovieSceneFloatChannelSerializationHelper.DefaultValue = 0x28 // float (Size: 0x4)
MovieSceneFloatChannelSerializationHelper.bHasDefaultValue = 0x2c // bool (Size: 0x1)
MovieSceneFloatValueSerializationHelper.Value = 0x0 // float (Size: 0x4)
MovieSceneFloatValueSerializationHelper.InterpMode = 0x4 // uint8_t (Size: 0x1)
MovieSceneFloatValueSerializationHelper.TangentMode = 0x5 // uint8_t (Size: 0x1)
MovieSceneFloatValueSerializationHelper.Tangent = 0x8 // FMovieSceneTangentDataSerializationHelper (Size: 0x14)
MovieSceneTangentDataSerializationHelper.ArriveTangent = 0x0 // float (Size: 0x4)
MovieSceneTangentDataSerializationHelper.LeaveTangent = 0x4 // float (Size: 0x4)
MovieSceneTangentDataSerializationHelper.TangentWeightMode = 0x8 // uint8_t (Size: 0x1)
MovieSceneTangentDataSerializationHelper.ArriveTangentWeight = 0xc // float (Size: 0x4)
MovieSceneTangentDataSerializationHelper.LeaveTangentWeight = 0x10 // float (Size: 0x4)
MultiPositionSound.EmitterPoints = 0x340 // TArray<SceneComponent*> (Size: 0x10)
MultiSourceSoundComponent.AudioEvent = 0x238 // AkAudioEvent* (Size: 0x8)
MultiSourceSoundComponent.MultiSoundRadius = 0x240 // float (Size: 0x4)
ParticleSoundComponent.SoundData = 0xf8 // TArray<FParticleSoundData> (Size: 0x10)
ParticleSoundComponent.PlaySoundAtLocation = 0x108 // bool (Size: 0x1)
ParticleSoundData.ParticleEventType = 0x0 // uint8_t (Size: 0x1)
ParticleSoundData.ParticleEventName = 0x4 // FName (Size: 0x8)
ParticleSoundData.AudioEvent = 0x10 // AkAudioEvent* (Size: 0x8)
PlayModeAudioData.SubModeID = 0x0 // uint64_t (Size: 0x8)
PlayModeAudioData.RuleID = 0x8 // uint64_t (Size: 0x8)
PlayModeAudioData.bOverrideBase = 0x10 // bool (Size: 0x1)
PlayModeAudioData.Banks = 0x18 // TArray<FString> (Size: 0x10)
PlayModeAudioData.States = 0x28 // TArray<FString> (Size: 0x10)
PlayModeAudioData.Events = 0x38 // TArray<FString> (Size: 0x10)
PostEventAsync.Completed = 0x30 // FMulticastInlineDelegate (Size: 0x10)
PostEventAtLocationAsync.Completed = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SetAttenuationComponent.ActivateValue = 0xf8 // float (Size: 0x4)
SetAttenuationComponent.ResetValue = 0xfc // float (Size: 0x4)
SetAttenuationComponent.IsGlobal = 0x100 // bool (Size: 0x1)
SetAttenuationComponent.IsAbsoluteValue = 0x101 // bool (Size: 0x1)
SetRTPCComponent.RTPCName = 0xf8 // FString (Size: 0x10)
SetRTPCComponent.InitialValue = 0x108 // float (Size: 0x4)
SetRTPCComponent.ResetValue = 0x10c // float (Size: 0x4)
SetRTPCComponent.IsGlobal = 0x110 // bool (Size: 0x1)
SetRTPCComponent.BindToGeographicRTPCType = 0x111 // bool (Size: 0x1)
SetRTPCComponent.GeographicRTPCType = 0x112 // EEGeographicRTPCType (Size: 0x1)
SetRTPCComponent.TickWithAkComponent = 0x113 // bool (Size: 0x1)
SetRTPCComponent.SlewWithDeltaTime = 0x114 // bool (Size: 0x1)
SetRTPCComponent.CoolDownTime = 0x118 // float (Size: 0x4)
SetRTPCComponent.IgnoreTickWhenListeningToSelf = 0x11c // bool (Size: 0x1)
SetRTPCComponent.CurrentValue = 0x130 // float (Size: 0x4)
SetRTPCComponent.ConnectedActor = 0x14c // TWeakObjectPtr<UObject> (Size: 0x8)
SetRTPCComponent.AkComponent = 0x158 // AkComponent* (Size: 0x8)
SetStateComponent.StateGroupName = 0xf8 // FString (Size: 0x10)
SetStateComponent.ActivateStateName = 0x108 // FString (Size: 0x10)
SetStateComponent.DeactivateStateName = 0x118 // FString (Size: 0x10)
SetStateComponent.AdditionalStateGroupName = 0x128 // FString (Size: 0x10)
SetStateComponent.AdditionalActivateName = 0x138 // FString (Size: 0x10)
SetStateComponent.AdditionalDeactivateName = 0x148 // FString (Size: 0x10)
SetSwitchComponent.SwitchGroupName = 0xf8 // FString (Size: 0x10)
SetSwitchComponent.ActivateSwitchName = 0x108 // FString (Size: 0x10)
SetSwitchComponent.DeactivateSwitchName = 0x118 // FString (Size: 0x10)
SplineSound.SplineRadius = 0x340 // float (Size: 0x4)
SplineSound.RegionHeight = 0x344 // float (Size: 0x4)
SplineSound.OverrideGlobalAmbienceSound = 0x348 // bool (Size: 0x1)
SplineSound.SplineComponent = 0x350 // SplineComponent* (Size: 0x8)
SplineSound.OutlineColor = 0x36c // FColor (Size: 0x4)
TArrUMultiSourceSoundComponent.TArrUMultiSourceSoundComponent = 0x0 // TArray<MultiSourceSoundComponent*> (Size: 0x10)
WwiseRTPCTableRow.BusName = 0x8 // FString (Size: 0x10)
WwiseRTPCTableRow.YAxis = 0x18 // FString (Size: 0x10)
WwiseRTPCTableRow.XAxis = 0x28 // FString (Size: 0x10)
WwiseRTPCTableRow.Notes = 0x38 // FString (Size: 0x10)
WwiseRTPCTableRow.RTPCPos = 0x48 // FString (Size: 0x10)
AndroidPermissionCallbackProxy.OnPermissionsGrantedDynamicDelegate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
AndroidPermissionCallbackProxy.OnExternalStagePermissionsGrantedDynamicDelegate = 0x38 // FMulticastInlineDelegate (Size: 0x10)
AndroidPermissionCallbackProxy.OnLocationPermissionsGrantedDynamicDelegate = 0x48 // FMulticastInlineDelegate (Size: 0x10)
AngularRangeLimit.LimitMin = 0x0 // FVector (Size: 0xc)
AngularRangeLimit.LimitMax = 0xc // FVector (Size: 0xc)
AngularRangeLimit.Bone = 0x18 // FBoneReference (Size: 0x10)
AnimLegIKDefinition.IKFootBone = 0x0 // FBoneReference (Size: 0x10)
AnimLegIKDefinition.FKFootBone = 0x10 // FBoneReference (Size: 0x10)
AnimLegIKDefinition.NumBonesInLimb = 0x20 // int32_t (Size: 0x4)
AnimLegIKDefinition.MinRotationAngle = 0x24 // float (Size: 0x4)
AnimLegIKDefinition.FootBoneForwardAxis = 0x28 // uint8_t (Size: 0x1)
AnimLegIKDefinition.HingeRotationAxis = 0x29 // uint8_t (Size: 0x1)
AnimLegIKDefinition.bEnableRotationLimit = 0x2a // bool (Size: 0x1)
AnimLegIKDefinition.bEnableKneeTwistCorrection = 0x2b // bool (Size: 0x1)
AnimNode_AimOffsetLookAt.BasePose = 0x270 // FPoseLink (Size: 0x10)
AnimNode_AimOffsetLookAt.LODThreshold = 0x280 // int32_t (Size: 0x4)
AnimNode_AimOffsetLookAt.SourceSocketName = 0x284 // FName (Size: 0x8)
AnimNode_AimOffsetLookAt.PivotSocketName = 0x28c // FName (Size: 0x8)
AnimNode_AimOffsetLookAt.LookAtLocation = 0x294 // FVector (Size: 0xc)
AnimNode_AimOffsetLookAt.SocketAxis = 0x2a0 // FVector (Size: 0xc)
AnimNode_AimOffsetLookAt.Alpha = 0x2ac // float (Size: 0x4)
AnimNode_AnimDynamics.LinearDampingOverride = 0xd0 // float (Size: 0x4)
AnimNode_AnimDynamics.AngularDampingOverride = 0xd4 // float (Size: 0x4)
AnimNode_AnimDynamics.RelativeSpaceBone = 0x140 // FBoneReference (Size: 0x10)
AnimNode_AnimDynamics.BoundBone = 0x150 // FBoneReference (Size: 0x10)
AnimNode_AnimDynamics.ChainEnd = 0x160 // FBoneReference (Size: 0x10)
AnimNode_AnimDynamics.BoxExtents = 0x170 // FVector (Size: 0xc)
AnimNode_AnimDynamics.LocalJointOffset = 0x17c // FVector (Size: 0xc)
AnimNode_AnimDynamics.GravityScale = 0x188 // float (Size: 0x4)
AnimNode_AnimDynamics.GravityOverride = 0x18c // FVector (Size: 0xc)
AnimNode_AnimDynamics.LinearSpringConstant = 0x198 // float (Size: 0x4)
AnimNode_AnimDynamics.AngularSpringConstant = 0x19c // float (Size: 0x4)
AnimNode_AnimDynamics.WindScale = 0x1a0 // float (Size: 0x4)
AnimNode_AnimDynamics.ComponentLinearAccScale = 0x1a4 // FVector (Size: 0xc)
AnimNode_AnimDynamics.ComponentLinearVelScale = 0x1b0 // FVector (Size: 0xc)
AnimNode_AnimDynamics.ComponentAppliedLinearAccClamp = 0x1bc // FVector (Size: 0xc)
AnimNode_AnimDynamics.AngularBiasOverride = 0x1c8 // float (Size: 0x4)
AnimNode_AnimDynamics.NumSolverIterationsPreUpdate = 0x1cc // int32_t (Size: 0x4)
AnimNode_AnimDynamics.NumSolverIterationsPostUpdate = 0x1d0 // int32_t (Size: 0x4)
AnimNode_AnimDynamics.ConstraintSetup = 0x1d4 // FAnimPhysConstraintSetup (Size: 0x48)
AnimNode_AnimDynamics.SphericalLimits = 0x220 // TArray<FAnimPhysSphericalLimit> (Size: 0x10)
AnimNode_AnimDynamics.SphereCollisionRadius = 0x230 // float (Size: 0x4)
AnimNode_AnimDynamics.ExternalForce = 0x234 // FVector (Size: 0xc)
AnimNode_AnimDynamics.PlanarLimits = 0x240 // TArray<FAnimPhysPlanarLimit> (Size: 0x10)
AnimNode_AnimDynamics.CollisionType = 0x250 // EAnimPhysCollisionType (Size: 0x1)
AnimNode_AnimDynamics.SimulationSpace = 0x251 // EAnimPhysSimSpaceType (Size: 0x1)
AnimNode_AnimDynamics.bUseSphericalLimits = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bUsePlanarLimit = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bDoUpdate = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bDoEval = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bOverrideLinearDamping = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bOverrideAngularBias = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bOverrideAngularDamping = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bEnableWind = 0x254 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bUseGravityOverride = 0x255 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bLinearSpring = 0x255 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bAngularSpring = 0x255 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.bClamp = 0x255 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.ClampReferenceBone = 0x258 // FBoneReference (Size: 0x10)
AnimNode_AnimDynamics.ClampTranslationMin = 0x268 // FVector (Size: 0xc)
AnimNode_AnimDynamics.ClampTranslationMax = 0x274 // FVector (Size: 0xc)
AnimNode_AnimDynamics.ClampRotationMin = 0x280 // FRotator (Size: 0xc)
AnimNode_AnimDynamics.ClampRotationMax = 0x28c // FRotator (Size: 0xc)
AnimNode_AnimDynamics.bChain = 0x298 // uint8_t (Size: 0x1)
AnimNode_AnimDynamics.RetargetingSettings = 0x2a0 // FRotationRetargetingInfo (Size: 0x130)
AnimNode_ApplyAdditive.Base = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ApplyAdditive.Additive = 0x20 // FPoseLink (Size: 0x10)
AnimNode_ApplyAdditive.Alpha = 0x30 // float (Size: 0x4)
AnimNode_ApplyAdditive.AlphaScaleBias = 0x34 // FInputScaleBias (Size: 0x8)
AnimNode_ApplyAdditive.LODThreshold = 0x3c // int32_t (Size: 0x4)
AnimNode_ApplyAdditive.AlphaBoolBlend = 0x40 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_ApplyAdditive.AlphaCurveName = 0x88 // FName (Size: 0x8)
AnimNode_ApplyAdditive.AlphaScaleBiasClamp = 0x90 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_ApplyAdditive.AlphaInputType = 0xc4 // EEAnimAlphaInputType (Size: 0x1)
AnimNode_ApplyAdditive.bAlphaBoolEnabled = 0xc5 // bool (Size: 0x1)
AnimNode_ApplyLimits.AngularRangeLimits = 0xd0 // TArray<FAngularRangeLimit> (Size: 0x10)
AnimNode_ApplyLimits.AngularOffsets = 0xe0 // TArray<FVector> (Size: 0x10)
AnimNode_ApplyLimits.LocationRangeLimits = 0xf0 // TArray<FAngularRangeLimit> (Size: 0x10)
AnimNode_ApplyLimits.LocationOffsets = 0x100 // TArray<FVector> (Size: 0x10)
AnimNode_BlendBoneByChannel.A = 0x10 // FPoseLink (Size: 0x10)
AnimNode_BlendBoneByChannel.B = 0x20 // FPoseLink (Size: 0x10)
AnimNode_BlendBoneByChannel.BoneDefinitions = 0x30 // TArray<FBlendBoneByChannelEntry> (Size: 0x10)
AnimNode_BlendBoneByChannel.Alpha = 0x50 // float (Size: 0x4)
AnimNode_BlendBoneByChannel.AlphaScaleBias = 0x58 // FInputScaleBias (Size: 0x8)
AnimNode_BlendBoneByChannel.TransformsSpace = 0x60 // uint8_t (Size: 0x1)
AnimNode_BlendListBase.BlendPose = 0x10 // TArray<FPoseLink> (Size: 0x10)
AnimNode_BlendListBase.BlendTime = 0x20 // TArray<float> (Size: 0x10)
AnimNode_BlendListBase.TransitionType = 0x30 // EEBlendListTransitionType (Size: 0x1)
AnimNode_BlendListBase.BlendType = 0x31 // EEAlphaBlendOption (Size: 0x1)
AnimNode_BlendListBase.bResetChildOnActivation = 0x32 // bool (Size: 0x1)
AnimNode_BlendListBase.bResetBlendingChildOnActivation = 0x33 // bool (Size: 0x1)
AnimNode_BlendListBase.CustomBlendCurve = 0x38 // CurveFloat* (Size: 0x8)
AnimNode_BlendListBase.BlendProfile = 0x40 // BlendProfile* (Size: 0x8)
AnimNode_BlendListByBool.bActiveValue = 0x98 // bool (Size: 0x1)
AnimNode_BlendListByEnum.EnumToPoseIndex = 0x98 // TArray<int32_t> (Size: 0x10)
AnimNode_BlendListByEnum.ActiveEnumValue = 0xa8 // uint8_t (Size: 0x1)
AnimNode_BlendListByInt.ActiveChildIndex = 0x98 // int32_t (Size: 0x4)
AnimNode_BlendSpaceEvaluator.NormalizedTime = 0x208 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.X = 0x120 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.Y = 0x124 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.Z = 0x128 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.PlayRate = 0x12c // float (Size: 0x4)
AnimNode_BlendSpacePlayer.bLoop = 0x130 // bool (Size: 0x1)
AnimNode_BlendSpacePlayer.bResetPlayTimeWhenBlendSpaceChanges = 0x131 // bool (Size: 0x1)
AnimNode_BlendSpacePlayer.StartPosition = 0x134 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.BlendSpace = 0x138 // BlendSpaceBase* (Size: 0x8)
AnimNode_BlendSpacePlayer.bResetPlayTimeWhenStartPositionChanges = 0x140 // bool (Size: 0x1)
AnimNode_BlendSpacePlayer.bResetAccumulateTimeWhenActive = 0x141 // bool (Size: 0x1)
AnimNode_BlendSpacePlayer.bUseOverrideInterpolationParam = 0x148 // bool (Size: 0x1)
AnimNode_BlendSpacePlayer.OverrideInterpolationParam_X = 0x14c // FInterpolationParameter (Size: 0x8)
AnimNode_BlendSpacePlayer.OverrideInterpolationParam_Y = 0x154 // FInterpolationParameter (Size: 0x8)
AnimNode_BlendSpacePlayer.PreviousBlendSpace = 0x1e8 // BlendSpaceBase* (Size: 0x8)
AnimNode_BlendSpacePlayer.PreviousStartPosition = 0x1f0 // float (Size: 0x4)
AnimNode_BlendSpacePlayer.LastCachedAnimSequence = 0x200 // AnimSequence* (Size: 0x8)
AnimNode_BoneDrivenController.SourceBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_BoneDrivenController.DrivingCurve = 0xe0 // CurveFloat* (Size: 0x8)
AnimNode_BoneDrivenController.Multiplier = 0xe8 // float (Size: 0x4)
AnimNode_BoneDrivenController.RangeMin = 0xec // float (Size: 0x4)
AnimNode_BoneDrivenController.RangeMax = 0xf0 // float (Size: 0x4)
AnimNode_BoneDrivenController.RemappedMin = 0xf4 // float (Size: 0x4)
AnimNode_BoneDrivenController.RemappedMax = 0xf8 // float (Size: 0x4)
AnimNode_BoneDrivenController.ParameterName = 0xfc // FName (Size: 0x8)
AnimNode_BoneDrivenController.TargetBone = 0x104 // FBoneReference (Size: 0x10)
AnimNode_BoneDrivenController.DestinationMode = 0x114 // EEDrivenDestinationMode (Size: 0x1)
AnimNode_BoneDrivenController.ModificationMode = 0x115 // EEDrivenBoneModificationMode (Size: 0x1)
AnimNode_BoneDrivenController.SourceComponent = 0x116 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bUseRange = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetTranslationX = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetTranslationY = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetTranslationZ = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetRotationX = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetRotationY = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetRotationZ = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetScaleX = 0x117 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetScaleY = 0x118 // uint8_t (Size: 0x1)
AnimNode_BoneDrivenController.bAffectTargetScaleZ = 0x118 // uint8_t (Size: 0x1)
AnimNode_CCDIK.EffectorLocation = 0xd0 // FVector (Size: 0xc)
AnimNode_CCDIK.EffectorLocationSpace = 0xdc // uint8_t (Size: 0x1)
AnimNode_CCDIK.EffectorTarget = 0xe0 // FBoneSocketTarget (Size: 0x60)
AnimNode_CCDIK.TipBone = 0x140 // FBoneReference (Size: 0x10)
AnimNode_CCDIK.RootBone = 0x150 // FBoneReference (Size: 0x10)
AnimNode_CCDIK.Precision = 0x160 // float (Size: 0x4)
AnimNode_CCDIK.MaxIterations = 0x164 // int32_t (Size: 0x4)
AnimNode_CCDIK.bStartFromTail = 0x168 // bool (Size: 0x1)
AnimNode_CCDIK.bEnableRotationLimit = 0x169 // bool (Size: 0x1)
AnimNode_CCDIK.RotationLimitPerJoints = 0x170 // TArray<float> (Size: 0x10)
AnimNode_Constraint.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_Constraint.ConstraintSetup = 0xe0 // TArray<FConstraint> (Size: 0x10)
AnimNode_Constraint.ConstraintWeights = 0xf0 // TArray<float> (Size: 0x10)
AnimNode_CopyBone.SourceBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_CopyBone.TargetBone = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_CopyBone.bCopyTranslation = 0xf0 // bool (Size: 0x1)
AnimNode_CopyBone.bCopyRotation = 0xf1 // bool (Size: 0x1)
AnimNode_CopyBone.bCopyScale = 0xf2 // bool (Size: 0x1)
AnimNode_CopyBone.ControlSpace = 0xf3 // uint8_t (Size: 0x1)
AnimNode_CopyBoneDelta.SourceBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_CopyBoneDelta.TargetBone = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_CopyBoneDelta.bCopyTranslation = 0xf0 // bool (Size: 0x1)
AnimNode_CopyBoneDelta.bCopyRotation = 0xf1 // bool (Size: 0x1)
AnimNode_CopyBoneDelta.bCopyScale = 0xf2 // bool (Size: 0x1)
AnimNode_CopyBoneDelta.CopyMode = 0xf3 // ECopyBoneDeltaMode (Size: 0x1)
AnimNode_CopyBoneDelta.TranslationMultiplier = 0xf4 // float (Size: 0x4)
AnimNode_CopyBoneDelta.RotationMultiplier = 0xf8 // float (Size: 0x4)
AnimNode_CopyBoneDelta.ScaleMultiplier = 0xfc // float (Size: 0x4)
AnimNode_CopyPoseFromMesh.SourceMeshComponent = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
AnimNode_CopyPoseFromMesh.bUseAttachedParent = 0x18 // uint8_t (Size: 0x1)
AnimNode_CopyPoseFromMesh.bCopyCurves = 0x18 // uint8_t (Size: 0x1)
AnimNode_CopyPoseFromMesh.bCopyCustomAttributes = 0x19 // bool (Size: 0x1)
AnimNode_CopyPoseFromMesh.bUseMeshPose = 0x1a // uint8_t (Size: 0x1)
AnimNode_CopyPoseFromMesh.RootBoneToCopy = 0x1c // FName (Size: 0x8)
AnimNode_CurveSource.SourcePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_CurveSource.SourceBinding = 0x20 // FName (Size: 0x8)
AnimNode_CurveSource.Alpha = 0x28 // float (Size: 0x4)
AnimNode_CurveSource.CurveSource = 0x30 // TScriptInterface<IInterface> (Size: 0x10)
AnimNode_Fabrik.EffectorTransform = 0xd0 // FTransform (Size: 0x30)
AnimNode_Fabrik.EffectorTarget = 0x100 // FBoneSocketTarget (Size: 0x60)
AnimNode_Fabrik.TipBone = 0x160 // FBoneReference (Size: 0x10)
AnimNode_Fabrik.RootBone = 0x170 // FBoneReference (Size: 0x10)
AnimNode_Fabrik.Precision = 0x180 // float (Size: 0x4)
AnimNode_Fabrik.MaxIterations = 0x184 // int32_t (Size: 0x4)
AnimNode_Fabrik.EffectorTransformSpace = 0x188 // uint8_t (Size: 0x1)
AnimNode_Fabrik.EffectorRotationSource = 0x189 // uint8_t (Size: 0x1)
AnimNode_HandIKRetargeting.RightHandFK = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_HandIKRetargeting.LeftHandFK = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_HandIKRetargeting.RightHandIK = 0xf0 // FBoneReference (Size: 0x10)
AnimNode_HandIKRetargeting.LeftHandIK = 0x100 // FBoneReference (Size: 0x10)
AnimNode_HandIKRetargeting.IKBonesToMove = 0x110 // TArray<FBoneReference> (Size: 0x10)
AnimNode_HandIKRetargeting.HandFKWeight = 0x120 // float (Size: 0x4)
AnimNode_LayeredBoneBlend.BasePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_LayeredBoneBlend.BlendPoses = 0x20 // TArray<FPoseLink> (Size: 0x10)
AnimNode_LayeredBoneBlend.LayerSetup = 0x30 // TArray<FInputBlendPose> (Size: 0x10)
AnimNode_LayeredBoneBlend.BlendWeights = 0x40 // TArray<float> (Size: 0x10)
AnimNode_LayeredBoneBlend.bMeshSpaceRotationBlend = 0x50 // bool (Size: 0x1)
AnimNode_LayeredBoneBlend.bMeshSpaceScaleBlend = 0x51 // bool (Size: 0x1)
AnimNode_LayeredBoneBlend.CurveBlendOption = 0x52 // uint8_t (Size: 0x1)
AnimNode_LayeredBoneBlend.DesiredCurveBlendIndex = 0x54 // int32_t (Size: 0x4)
AnimNode_LayeredBoneBlend.bBlendRootMotionBasedOnRootBone = 0x58 // bool (Size: 0x1)
AnimNode_LayeredBoneBlend.LODThreshold = 0x5c // int32_t (Size: 0x4)
AnimNode_LayeredBoneBlend.PerBoneBlendWeights = 0x60 // TArray<FPerBoneBlendWeight> (Size: 0x10)
AnimNode_LayeredBoneBlend.SkeletonGuid = 0x70 // FGuid (Size: 0x10)
AnimNode_LayeredBoneBlend.VirtualBoneGuid = 0x80 // FGuid (Size: 0x10)
AnimNode_LegIK.ReachPrecision = 0xd0 // float (Size: 0x4)
AnimNode_LegIK.MaxIterations = 0xd4 // int32_t (Size: 0x4)
AnimNode_LegIK.LegsDefinition = 0xd8 // TArray<FAnimLegIKDefinition> (Size: 0x10)
AnimNode_LookAt.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_LookAt.LookAtTarget = 0xe0 // FBoneSocketTarget (Size: 0x60)
AnimNode_LookAt.LookAtLocation = 0x140 // FVector (Size: 0xc)
AnimNode_LookAt.LookAt_Axis = 0x14c // FAxis (Size: 0x10)
AnimNode_LookAt.bUseLookUpAxis = 0x15c // bool (Size: 0x1)
AnimNode_LookAt.InterpolationType = 0x15d // uint8_t (Size: 0x1)
AnimNode_LookAt.LookUp_Axis = 0x160 // FAxis (Size: 0x10)
AnimNode_LookAt.LookAtClamp = 0x170 // float (Size: 0x4)
AnimNode_LookAt.InterpolationTime = 0x174 // float (Size: 0x4)
AnimNode_LookAt.InterpolationTriggerThreashold = 0x178 // float (Size: 0x4)
AnimNode_MakeDynamicAdditive.Base = 0x10 // FPoseLink (Size: 0x10)
AnimNode_MakeDynamicAdditive.Additive = 0x20 // FPoseLink (Size: 0x10)
AnimNode_MakeDynamicAdditive.bMeshSpaceAdditive = 0x30 // bool (Size: 0x1)
AnimNode_ModifyBone.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_ModifyBone.Translation = 0xe0 // FVector (Size: 0xc)
AnimNode_ModifyBone.Rotation = 0xec // FRotator (Size: 0xc)
AnimNode_ModifyBone.Scale = 0xf8 // FVector (Size: 0xc)
AnimNode_ModifyBone.TranslationMode = 0x104 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.RotationMode = 0x105 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.ScaleMode = 0x106 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.TranslationSpace = 0x107 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.RotationSpace = 0x108 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.ScaleSpace = 0x109 // uint8_t (Size: 0x1)
AnimNode_ModifyBone.bSkipEvaluateWhenBoneTransformUnchanged = 0x10a // bool (Size: 0x1)
AnimNode_ModifyBone.ActualTranslation = 0x10c // FVector (Size: 0xc)
AnimNode_ModifyBone.ActualRotation = 0x118 // FRotator (Size: 0xc)
AnimNode_ModifyBone.TranslationInterp = 0x124 // FInputVInterp (Size: 0x18)
AnimNode_ModifyBone.RotationInterp = 0x13c // FInputRInterp (Size: 0x18)
AnimNode_ModifyCurve.SourcePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ModifyCurve.CurveValues = 0x20 // TArray<float> (Size: 0x10)
AnimNode_ModifyCurve.CurveNames = 0x30 // TArray<FName> (Size: 0x10)
AnimNode_ModifyCurve.Alpha = 0x50 // float (Size: 0x4)
AnimNode_ModifyCurve.ApplyMode = 0x54 // EEModifyCurveApplyMode (Size: 0x1)
AnimNode_ModifyCurve.ActualAlpha = 0x58 // float (Size: 0x4)
AnimNode_ModifyCurve.AlphaScaleBiasClamp = 0x5c // FInputScaleBiasClamp (Size: 0x30)
AnimNode_MultiWayBlend.Poses = 0x10 // TArray<FPoseLink> (Size: 0x10)
AnimNode_MultiWayBlend.DesiredAlphas = 0x20 // TArray<float> (Size: 0x10)
AnimNode_MultiWayBlend.AlphaScaleBias = 0x40 // FInputScaleBias (Size: 0x8)
AnimNode_MultiWayBlend.bAdditiveNode = 0x48 // bool (Size: 0x1)
AnimNode_MultiWayBlend.bNormalizeAlpha = 0x49 // bool (Size: 0x1)
AnimNode_ObserveBone.BoneToObserve = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_ObserveBone.DisplaySpace = 0xe0 // uint8_t (Size: 0x1)
AnimNode_ObserveBone.bRelativeToRefPose = 0xe1 // bool (Size: 0x1)
AnimNode_ObserveBone.Translation = 0xe4 // FVector (Size: 0xc)
AnimNode_ObserveBone.Rotation = 0xf0 // FRotator (Size: 0xc)
AnimNode_ObserveBone.Scale = 0xfc // FVector (Size: 0xc)
AnimNode_PoseBlendNode.SourcePose = 0x168 // FPoseLink (Size: 0x10)
AnimNode_PoseBlendNode.BlendOption = 0x178 // EEAlphaBlendOption (Size: 0x1)
AnimNode_PoseBlendNode.CustomCurve = 0x180 // CurveFloat* (Size: 0x8)
AnimNode_PoseByName.PoseName = 0x168 // FName (Size: 0x8)
AnimNode_PoseByName.PoseWeight = 0x170 // float (Size: 0x4)
AnimNode_PoseDriver.SourcePose = 0x168 // FPoseLink (Size: 0x10)
AnimNode_PoseDriver.SourceBones = 0x178 // TArray<FBoneReference> (Size: 0x10)
AnimNode_PoseDriver.OnlyDriveBones = 0x188 // TArray<FBoneReference> (Size: 0x10)
AnimNode_PoseDriver.PoseTargets = 0x198 // TArray<FPoseDriverTarget> (Size: 0x10)
AnimNode_PoseDriver.EvalSpaceBone = 0x1d8 // FBoneReference (Size: 0x10)
AnimNode_PoseDriver.RBFParams = 0x1e8 // FRBFParams (Size: 0x2c)
AnimNode_PoseDriver.DriveSource = 0x214 // EEPoseDriverSource (Size: 0x1)
AnimNode_PoseDriver.DriveOutput = 0x215 // EEPoseDriverOutput (Size: 0x1)
AnimNode_PoseDriver.bOnlyDriveSelectedBones = 0x216 // uint8_t (Size: 0x1)
AnimNode_PoseDriver.LODThreshold = 0x218 // int32_t (Size: 0x4)
AnimNode_PoseHandler.PoseAsset = 0x120 // PoseAsset* (Size: 0x8)
AnimNode_PoseSnapshot.SnapshotName = 0x10 // FName (Size: 0x8)
AnimNode_PoseSnapshot.Snapshot = 0x18 // FPoseSnapshot (Size: 0x38)
AnimNode_PoseSnapshot.Mode = 0x50 // EESnapshotSourceMode (Size: 0x1)
AnimNode_RandomPlayer.Entries = 0x10 // TArray<FRandomPlayerSequenceEntry> (Size: 0x10)
AnimNode_RandomPlayer.bShuffleMode = 0x70 // bool (Size: 0x1)
AnimNode_RefPose.RefPoseType = 0x10 // uint8_t (Size: 0x1)
AnimNode_RigidBody.bUseSelfPhysicsAssetIfExist = 0xd0 // bool (Size: 0x1)
AnimNode_RigidBody.OverridePhysicsAsset = 0xd8 // PhysicsAsset* (Size: 0x8)
AnimNode_RigidBody.OverrideWorldGravity = 0x178 // FVector (Size: 0xc)
AnimNode_RigidBody.ExternalForce = 0x184 // FVector (Size: 0xc)
AnimNode_RigidBody.ComponentLinearAccScale = 0x190 // FVector (Size: 0xc)
AnimNode_RigidBody.ComponentLinearVelScale = 0x19c // FVector (Size: 0xc)
AnimNode_RigidBody.ComponentAppliedLinearAccClamp = 0x1a8 // FVector (Size: 0xc)
AnimNode_RigidBody.SimSpaceSettings = 0x1b4 // FSimSpaceSettings (Size: 0x40)
AnimNode_RigidBody.CachedBoundsScale = 0x1f4 // float (Size: 0x4)
AnimNode_RigidBody.BaseBoneRef = 0x1f8 // FBoneReference (Size: 0x10)
AnimNode_RigidBody.OverlapChannel = 0x208 // uint8_t (Size: 0x1)
AnimNode_RigidBody.SimulationSpace = 0x209 // EESimulationSpace (Size: 0x1)
AnimNode_RigidBody.bForceDisableCollisionBetweenConstraintBodies = 0x20a // bool (Size: 0x1)
AnimNode_RigidBody.bEnableWorldGeometry = 0x20c // uint8_t (Size: 0x1)
AnimNode_RigidBody.bOverrideWorldGravity = 0x20c // uint8_t (Size: 0x1)
AnimNode_RigidBody.bTransferBoneVelocities = 0x20c // uint8_t (Size: 0x1)
AnimNode_RigidBody.bFreezeIncomingPoseOnStart = 0x20c // uint8_t (Size: 0x1)
AnimNode_RigidBody.bClampLinearTranslationLimitToRefPose = 0x20c // uint8_t (Size: 0x1)
AnimNode_RigidBody.WorldSpaceMinimumScale = 0x210 // float (Size: 0x4)
AnimNode_RigidBody.EvaluationResetTime = 0x214 // float (Size: 0x4)
AnimNode_RigidBody.bEnableExternalCollision = 0x218 // uint8_t (Size: 0x1)
AnimNode_RigidBody.ExternalCollisionBone = 0x21c // FBoneReference (Size: 0x10)
AnimNode_RigidBody.ExternalCollisionTarget = 0x230 // SkeletalMeshComponent* (Size: 0x8)
AnimNode_RigidBody.ExternalCollisionTargetCached = 0x238 // SkeletalMeshComponent* (Size: 0x8)
AnimNode_RigidBody.RefPoseLimits = 0x298 // TArray<FRefPoseLimit> (Size: 0x10)
AnimNode_RigidBody.EffectBodyIndex = 0x2a8 // uint8_t (Size: 0x1)
AnimNode_RigidBody.WorldSpaceCorrection_Roll = 0x2ac // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_X = 0x2bc // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_Y = 0x2cc // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_Z = 0x2dc // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_Pitch = 0x2ec // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_Yaw = 0x2fc // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.LocalSpaceCorrection_Roll = 0x30c // FPostPhysicsClampSettings (Size: 0x10)
AnimNode_RigidBody.bLimitLinearVelocity_Simulation = 0x31c // bool (Size: 0x1)
AnimNode_RigidBody.MaxLinearVelocity_Simulation = 0x320 // FVector (Size: 0xc)
AnimNode_RigidBody.bLimitAngularVelocity_Simulation = 0x32c // bool (Size: 0x1)
AnimNode_RigidBody.MaxAngularVelocity_Simulation = 0x330 // FVector (Size: 0xc)
AnimNode_RigidBody.bPrintTransformAfterPhysics = 0x33c // bool (Size: 0x1)
AnimNode_RigidBody.PrintBodyIndex = 0x33d // uint8_t (Size: 0x1)
AnimNode_RigidBody.bEnableDebug_Simulation = 0x33e // bool (Size: 0x1)
AnimNode_RotateRootBone.BasePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_RotateRootBone.Pitch = 0x20 // float (Size: 0x4)
AnimNode_RotateRootBone.Yaw = 0x24 // float (Size: 0x4)
AnimNode_RotateRootBone.PitchScaleBiasClamp = 0x28 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_RotateRootBone.YawScaleBiasClamp = 0x58 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_RotateRootBone.MeshToComponent = 0x88 // FRotator (Size: 0xc)
AnimNode_RotationMultiplier.TargetBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_RotationMultiplier.SourceBone = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_RotationMultiplier.Multiplier = 0xf0 // float (Size: 0x4)
AnimNode_RotationMultiplier.RotationAxisToRefer = 0xf4 // uint8_t (Size: 0x1)
AnimNode_RotationMultiplier.bIsAdditive = 0xf5 // bool (Size: 0x1)
AnimNode_RotationOffsetBlendSpace.BasePose = 0x208 // FPoseLink (Size: 0x10)
AnimNode_RotationOffsetBlendSpace.LODThreshold = 0x218 // int32_t (Size: 0x4)
AnimNode_RotationOffsetBlendSpace.Alpha = 0x21c // float (Size: 0x4)
AnimNode_RotationOffsetBlendSpace.AlphaScaleBias = 0x220 // FInputScaleBias (Size: 0x8)
AnimNode_RotationOffsetBlendSpace.AlphaBoolBlend = 0x228 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_RotationOffsetBlendSpace.AlphaCurveName = 0x270 // FName (Size: 0x8)
AnimNode_RotationOffsetBlendSpace.AlphaScaleBiasClamp = 0x278 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_RotationOffsetBlendSpace.AlphaInputType = 0x2ac // EEAnimAlphaInputType (Size: 0x1)
AnimNode_RotationOffsetBlendSpace.bAlphaBoolEnabled = 0x2ad // bool (Size: 0x1)
AnimNode_ScaleChainLength.InputPose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ScaleChainLength.DefaultChainLength = 0x20 // float (Size: 0x4)
AnimNode_ScaleChainLength.ChainStartBone = 0x24 // FBoneReference (Size: 0x10)
AnimNode_ScaleChainLength.ChainEndBone = 0x34 // FBoneReference (Size: 0x10)
AnimNode_ScaleChainLength.TargetLocation = 0x44 // FVector (Size: 0xc)
AnimNode_ScaleChainLength.Alpha = 0x50 // float (Size: 0x4)
AnimNode_ScaleChainLength.AlphaScaleBias = 0x58 // FInputScaleBias (Size: 0x8)
AnimNode_ScaleChainLength.ChainInitialLength = 0x60 // EEScaleChainInitialLength (Size: 0x1)
AnimNode_SequenceEvaluator.Sequence = 0x120 // AnimSequenceBase* (Size: 0x8)
AnimNode_SequenceEvaluator.ExplicitTime = 0x128 // float (Size: 0x4)
AnimNode_SequenceEvaluator.bShouldLoop = 0x12c // bool (Size: 0x1)
AnimNode_SequenceEvaluator.bTeleportToExplicitTime = 0x12d // bool (Size: 0x1)
AnimNode_SequenceEvaluator.ReinitializationBehavior = 0x12e // uint8_t (Size: 0x1)
AnimNode_SequenceEvaluator.StartPosition = 0x130 // float (Size: 0x4)
AnimNode_SequenceEvaluator.LastPlayAnimSeq = 0x138 // AnimSequenceBase* (Size: 0x8)
AnimNode_SkeletalControlBase.ComponentPose = 0x10 // FComponentSpacePoseLink (Size: 0x10)
AnimNode_SkeletalControlBase.LODThreshold = 0x20 // int32_t (Size: 0x4)
AnimNode_SkeletalControlBase.ActualAlpha = 0x24 // float (Size: 0x4)
AnimNode_SkeletalControlBase.AlphaInputType = 0x28 // EEAnimAlphaInputType (Size: 0x1)
AnimNode_SkeletalControlBase.bAlphaBoolEnabled = 0x29 // bool (Size: 0x1)
AnimNode_SkeletalControlBase.Alpha = 0x2c // float (Size: 0x4)
AnimNode_SkeletalControlBase.AlphaScaleBias = 0x30 // FInputScaleBias (Size: 0x8)
AnimNode_SkeletalControlBase.AlphaScaleMultiplier = 0x38 // float (Size: 0x4)
AnimNode_SkeletalControlBase.AlphaBoolBlend = 0x40 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_SkeletalControlBase.AlphaCurveName = 0x88 // FName (Size: 0x8)
AnimNode_SkeletalControlBase.AlphaScaleBiasClamp = 0x90 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_Slot.Source = 0x10 // FPoseLink (Size: 0x10)
AnimNode_Slot.SlotName = 0x20 // FName (Size: 0x8)
AnimNode_Slot.bAlwaysUpdateSourcePose = 0x28 // bool (Size: 0x1)
AnimNode_SplineIK.StartBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_SplineIK.EndBone = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_SplineIK.BoneAxis = 0xf0 // EESplineBoneAxis (Size: 0x1)
AnimNode_SplineIK.bAutoCalculateSpline = 0xf1 // bool (Size: 0x1)
AnimNode_SplineIK.PointCount = 0xf4 // int32_t (Size: 0x4)
AnimNode_SplineIK.ControlPoints = 0xf8 // TArray<FTransform> (Size: 0x10)
AnimNode_SplineIK.Roll = 0x108 // float (Size: 0x4)
AnimNode_SplineIK.TwistStart = 0x10c // float (Size: 0x4)
AnimNode_SplineIK.TwistEnd = 0x110 // float (Size: 0x4)
AnimNode_SplineIK.TwistBlend = 0x118 // FAlphaBlend (Size: 0x30)
AnimNode_SplineIK.Stretch = 0x148 // float (Size: 0x4)
AnimNode_SplineIK.Offset = 0x14c // float (Size: 0x4)
AnimNode_SpringBone.SpringBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_SpringBone.MaxDisplacement = 0xe0 // float (Size: 0x4)
AnimNode_SpringBone.SpringStiffness = 0xe4 // float (Size: 0x4)
AnimNode_SpringBone.SpringDamping = 0xe8 // float (Size: 0x4)
AnimNode_SpringBone.ErrorResetThresh = 0xec // float (Size: 0x4)
AnimNode_SpringBone.bLimitDisplacement = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bTranslateX = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bTranslateY = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bTranslateZ = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bRotateX = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bRotateY = 0x12c // uint8_t (Size: 0x1)
AnimNode_SpringBone.bRotateZ = 0x12c // uint8_t (Size: 0x1)
AnimNode_Trail.TrailBone = 0x100 // FBoneReference (Size: 0x10)
AnimNode_Trail.ChainLength = 0x110 // int32_t (Size: 0x4)
AnimNode_Trail.ChainBoneAxis = 0x114 // uint8_t (Size: 0x1)
AnimNode_Trail.bInvertChainBoneAxis = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.bLimitStretch = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.bLimitRotation = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.bUsePlanarLimit = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.bActorSpaceFakeVel = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.bReorientParentToChild = 0x115 // uint8_t (Size: 0x1)
AnimNode_Trail.MaxDeltaTime = 0x118 // float (Size: 0x4)
AnimNode_Trail.RelaxationSpeedScale = 0x11c // float (Size: 0x4)
AnimNode_Trail.TrailRelaxationSpeed = 0x120 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_Trail.RelaxationSpeedScaleInputProcessor = 0x1a8 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_Trail.RotationLimits = 0x1d8 // TArray<FRotationLimit> (Size: 0x10)
AnimNode_Trail.RotationOffsets = 0x1e8 // TArray<FVector> (Size: 0x10)
AnimNode_Trail.PlanarLimits = 0x1f8 // TArray<FAnimPhysPlanarLimit> (Size: 0x10)
AnimNode_Trail.StretchLimit = 0x208 // float (Size: 0x4)
AnimNode_Trail.FakeVelocity = 0x20c // FVector (Size: 0xc)
AnimNode_Trail.BaseJoint = 0x218 // FBoneReference (Size: 0x10)
AnimNode_Trail.LastBoneRotationAnimAlphaBlend = 0x228 // float (Size: 0x4)
AnimNode_TwistCorrectiveNode.BaseFrame = 0xd0 // FReferenceBoneFrame (Size: 0x20)
AnimNode_TwistCorrectiveNode.TwistFrame = 0xf0 // FReferenceBoneFrame (Size: 0x20)
AnimNode_TwistCorrectiveNode.TwistPlaneNormalAxis = 0x110 // FAxis (Size: 0x10)
AnimNode_TwistCorrectiveNode.RangeMax = 0x120 // float (Size: 0x4)
AnimNode_TwistCorrectiveNode.RemappedMin = 0x124 // float (Size: 0x4)
AnimNode_TwistCorrectiveNode.RemappedMax = 0x128 // float (Size: 0x4)
AnimNode_TwistCorrectiveNode.Curve = 0x12c // FAnimCurveParam (Size: 0xc)
AnimNode_TwoBoneIK.IKBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_TwoBoneIK.StartStretchRatio = 0xe0 // float (Size: 0x4)
AnimNode_TwoBoneIK.MaxStretchScale = 0xe4 // float (Size: 0x4)
AnimNode_TwoBoneIK.EffectorLocation = 0xe8 // FVector (Size: 0xc)
AnimNode_TwoBoneIK.EffectorTarget = 0x100 // FBoneSocketTarget (Size: 0x60)
AnimNode_TwoBoneIK.JointTargetLocation = 0x160 // FVector (Size: 0xc)
AnimNode_TwoBoneIK.JointTarget = 0x170 // FBoneSocketTarget (Size: 0x60)
AnimNode_TwoBoneIK.TwistAxis = 0x1d0 // FAxis (Size: 0x10)
AnimNode_TwoBoneIK.EffectorLocationSpace = 0x1e0 // uint8_t (Size: 0x1)
AnimNode_TwoBoneIK.JointTargetLocationSpace = 0x1e1 // uint8_t (Size: 0x1)
AnimNode_TwoBoneIK.bAllowStretching = 0x1e2 // uint8_t (Size: 0x1)
AnimNode_TwoBoneIK.bTakeRotationFromEffectorSpace = 0x1e2 // uint8_t (Size: 0x1)
AnimNode_TwoBoneIK.bMaintainEffectorRelRot = 0x1e2 // uint8_t (Size: 0x1)
AnimNode_TwoBoneIK.bAllowTwist = 0x1e2 // uint8_t (Size: 0x1)
AnimNode_TwoWayBlend.A = 0x10 // FPoseLink (Size: 0x10)
AnimNode_TwoWayBlend.B = 0x20 // FPoseLink (Size: 0x10)
AnimNode_TwoWayBlend.AlphaInputType = 0x30 // EEAnimAlphaInputType (Size: 0x1)
AnimNode_TwoWayBlend.bAlphaBoolEnabled = 0x31 // uint8_t (Size: 0x1)
AnimNode_TwoWayBlend.bResetChildOnActivation = 0x31 // uint8_t (Size: 0x1)
AnimNode_TwoWayBlend.Alpha = 0x34 // float (Size: 0x4)
AnimNode_TwoWayBlend.AlphaScaleBias = 0x38 // FInputScaleBias (Size: 0x8)
AnimNode_TwoWayBlend.AlphaBoolBlend = 0x40 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_TwoWayBlend.AlphaCurveName = 0x88 // FName (Size: 0x8)
AnimNode_TwoWayBlend.AlphaScaleBiasClamp = 0x90 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_TwoWayBlend.LODThreshold = 0xc4 // int32_t (Size: 0x4)
AnimNotify_PlayMontageNotify.NotifyName = 0x38 // FName (Size: 0x8)
AnimNotify_PlayMontageNotifyWindow.NotifyName = 0x30 // FName (Size: 0x8)
AnimPhysConstraintSetup.LinearXLimitType = 0x0 // EAnimPhysLinearConstraintType (Size: 0x1)
AnimPhysConstraintSetup.LinearYLimitType = 0x1 // EAnimPhysLinearConstraintType (Size: 0x1)
AnimPhysConstraintSetup.LinearZLimitType = 0x2 // EAnimPhysLinearConstraintType (Size: 0x1)
AnimPhysConstraintSetup.LinearAxesMin = 0x4 // FVector (Size: 0xc)
AnimPhysConstraintSetup.LinearAxesMax = 0x10 // FVector (Size: 0xc)
AnimPhysConstraintSetup.AngularConstraintType = 0x1c // EAnimPhysAngularConstraintType (Size: 0x1)
AnimPhysConstraintSetup.TwistAxis = 0x1d // EAnimPhysTwistAxis (Size: 0x1)
AnimPhysConstraintSetup.AngularTargetAxis = 0x1e // EAnimPhysTwistAxis (Size: 0x1)
AnimPhysConstraintSetup.ConeAngle = 0x20 // float (Size: 0x4)
AnimPhysConstraintSetup.AngularLimitsMin = 0x24 // FVector (Size: 0xc)
AnimPhysConstraintSetup.AngularLimitsMax = 0x30 // FVector (Size: 0xc)
AnimPhysConstraintSetup.AngularTarget = 0x3c // FVector (Size: 0xc)
AnimPhysPlanarLimit.DrivingBone = 0x0 // FBoneReference (Size: 0x10)
AnimPhysPlanarLimit.PlaneTransform = 0x10 // FTransform (Size: 0x30)
AnimPhysSphericalLimit.DrivingBone = 0x0 // FBoneReference (Size: 0x10)
AnimPhysSphericalLimit.SphereLocalOffset = 0x10 // FVector (Size: 0xc)
AnimPhysSphericalLimit.LimitRadius = 0x1c // float (Size: 0x4)
AnimPhysSphericalLimit.LimitType = 0x20 // EESphericalLimitType (Size: 0x1)
BlendBoneByChannelEntry.SourceBone = 0x0 // FBoneReference (Size: 0x10)
BlendBoneByChannelEntry.TargetBone = 0x10 // FBoneReference (Size: 0x10)
BlendBoneByChannelEntry.bBlendTranslation = 0x20 // bool (Size: 0x1)
BlendBoneByChannelEntry.bBlendRotation = 0x21 // bool (Size: 0x1)
BlendBoneByChannelEntry.bBlendScale = 0x22 // bool (Size: 0x1)
BoneSocketTarget.bUseSocket = 0x0 // bool (Size: 0x1)
BoneSocketTarget.BoneReference = 0x4 // FBoneReference (Size: 0x10)
BoneSocketTarget.SocketReference = 0x20 // FSocketReference (Size: 0x40)
Constraint.TargetBone = 0x0 // FBoneReference (Size: 0x10)
Constraint.OffsetOption = 0x10 // EEConstraintOffsetOption (Size: 0x1)
Constraint.TransformType = 0x11 // EETransformConstraintType (Size: 0x1)
Constraint.PerAxis = 0x12 // FFilterOptionPerAxis (Size: 0x3)
PlayMontageCallbackProxy.OnCompleted = 0x28 // FMulticastInlineDelegate (Size: 0x10)
PlayMontageCallbackProxy.OnBlendOut = 0x38 // FMulticastInlineDelegate (Size: 0x10)
PlayMontageCallbackProxy.OnInterrupted = 0x48 // FMulticastInlineDelegate (Size: 0x10)
PlayMontageCallbackProxy.OnNotifyBegin = 0x58 // FMulticastInlineDelegate (Size: 0x10)
PlayMontageCallbackProxy.OnNotifyEnd = 0x68 // FMulticastInlineDelegate (Size: 0x10)
PoseDriverTarget.BoneTransforms = 0x0 // TArray<FPoseDriverTransform> (Size: 0x10)
PoseDriverTarget.TargetRotation = 0x10 // FRotator (Size: 0xc)
PoseDriverTarget.TargetScale = 0x1c // float (Size: 0x4)
PoseDriverTarget.DistanceMethod = 0x20 // EERBFDistanceMethod (Size: 0x1)
PoseDriverTarget.FunctionType = 0x21 // EERBFFunctionType (Size: 0x1)
PoseDriverTarget.bApplyCustomCurve = 0x22 // bool (Size: 0x1)
PoseDriverTarget.CustomCurve = 0x28 // FRichCurve (Size: 0x80)
PoseDriverTarget.DrivenName = 0xa8 // FName (Size: 0x8)
PoseDriverTarget.bIsHidden = 0xb8 // bool (Size: 0x1)
PoseDriverTransform.TargetTranslation = 0x0 // FVector (Size: 0xc)
PoseDriverTransform.TargetRotation = 0xc // FRotator (Size: 0xc)
PositionHistory.Positions = 0x0 // TArray<FVector> (Size: 0x10)
PositionHistory.Range = 0x10 // float (Size: 0x4)
PostPhysicsClampSettings.bEnableCorrection_Manual = 0x0 // uint8_t (Size: 0x1)
PostPhysicsClampSettings.bEnableCorrection_Auto = 0x0 // uint8_t (Size: 0x1)
PostPhysicsClampSettings.MinValue = 0x4 // float (Size: 0x4)
PostPhysicsClampSettings.MaxValue = 0x8 // float (Size: 0x4)
PostPhysicsClampSettings.RangeValue = 0xc // float (Size: 0x4)
RBFEntry.Values = 0x0 // TArray<float> (Size: 0x10)
RBFParams.TargetDimensions = 0x0 // int32_t (Size: 0x4)
RBFParams.SolverType = 0x4 // EERBFSolverType (Size: 0x1)
RBFParams.Radius = 0x8 // float (Size: 0x4)
RBFParams.bAutomaticRadius = 0xc // bool (Size: 0x1)
RBFParams.Function = 0xd // EERBFFunctionType (Size: 0x1)
RBFParams.DistanceMethod = 0xe // EERBFDistanceMethod (Size: 0x1)
RBFParams.TwistAxis = 0xf // uint8_t (Size: 0x1)
RBFParams.WeightThreshold = 0x10 // float (Size: 0x4)
RBFParams.NormalizeMethod = 0x14 // EERBFNormalizeMethod (Size: 0x1)
RBFParams.MedianReference = 0x18 // FVector (Size: 0xc)
RBFParams.MedianMin = 0x24 // float (Size: 0x4)
RBFParams.MedianMax = 0x28 // float (Size: 0x4)
RBFTarget.ScaleFactor = 0x10 // float (Size: 0x4)
RBFTarget.bApplyCustomCurve = 0x14 // bool (Size: 0x1)
RBFTarget.CustomCurve = 0x18 // FRichCurve (Size: 0x80)
RBFTarget.DistanceMethod = 0x98 // EERBFDistanceMethod (Size: 0x1)
RBFTarget.FunctionType = 0x99 // EERBFFunctionType (Size: 0x1)
RandomPlayerSequenceEntry.Sequence = 0x0 // AnimSequence* (Size: 0x8)
RandomPlayerSequenceEntry.ChanceToPlay = 0x8 // float (Size: 0x4)
RandomPlayerSequenceEntry.MinLoopCount = 0xc // int32_t (Size: 0x4)
RandomPlayerSequenceEntry.MaxLoopCount = 0x10 // int32_t (Size: 0x4)
RandomPlayerSequenceEntry.MinPlayRate = 0x14 // float (Size: 0x4)
RandomPlayerSequenceEntry.MaxPlayRate = 0x18 // float (Size: 0x4)
RandomPlayerSequenceEntry.BlendIn = 0x20 // FAlphaBlend (Size: 0x30)
RefPoseLimit.TargetBone = 0x0 // FBoneReference (Size: 0x10)
RefPoseLimit.bConstraintTranslation = 0x10 // bool (Size: 0x1)
RefPoseLimit.TranslationLimitMin = 0x14 // FVector (Size: 0xc)
RefPoseLimit.TranslationLimitMax = 0x20 // FVector (Size: 0xc)
RefPoseLimit.bConstraintRotation = 0x2c // bool (Size: 0x1)
RefPoseLimit.RotationLimitMin = 0x30 // FVector (Size: 0xc)
RefPoseLimit.RotationLimitMax = 0x3c // FVector (Size: 0xc)
RefPoseLimit.bEnableSoftConstraint = 0x48 // bool (Size: 0x1)
RefPoseLimit.Stiffness = 0x4c // float (Size: 0x4)
ReferenceBoneFrame.Bone = 0x0 // FBoneReference (Size: 0x10)
ReferenceBoneFrame.Axis = 0x10 // FAxis (Size: 0x10)
RotationLimit.LimitMin = 0x0 // FVector (Size: 0xc)
RotationLimit.LimitMax = 0xc // FVector (Size: 0xc)
RotationRetargetingInfo.bEnabled = 0x0 // bool (Size: 0x1)
RotationRetargetingInfo.Source = 0x10 // FTransform (Size: 0x30)
RotationRetargetingInfo.Target = 0x40 // FTransform (Size: 0x30)
RotationRetargetingInfo.RotationComponent = 0x70 // EERotationComponent (Size: 0x1)
RotationRetargetingInfo.TwistAxis = 0x74 // FVector (Size: 0xc)
RotationRetargetingInfo.bUseAbsoluteAngle = 0x80 // bool (Size: 0x1)
RotationRetargetingInfo.SourceMinimum = 0x84 // float (Size: 0x4)
RotationRetargetingInfo.SourceMaximum = 0x88 // float (Size: 0x4)
RotationRetargetingInfo.TargetMinimum = 0x8c // float (Size: 0x4)
RotationRetargetingInfo.TargetMaximum = 0x90 // float (Size: 0x4)
RotationRetargetingInfo.EasingType = 0x94 // EEEasingFuncType (Size: 0x1)
RotationRetargetingInfo.CustomCurve = 0x98 // FRuntimeFloatCurve (Size: 0x88)
RotationRetargetingInfo.bFlipEasing = 0x120 // bool (Size: 0x1)
RotationRetargetingInfo.EasingWeight = 0x124 // float (Size: 0x4)
RotationRetargetingInfo.bClamp = 0x128 // bool (Size: 0x1)
SimSpaceSettings.MasterAlpha = 0x0 // float (Size: 0x4)
SimSpaceSettings.VelocityScaleZ = 0x4 // float (Size: 0x4)
SimSpaceSettings.MaxLinearVelocity = 0x8 // float (Size: 0x4)
SimSpaceSettings.MaxAngularVelocity = 0xc // float (Size: 0x4)
SimSpaceSettings.MaxLinearAcceleration = 0x10 // float (Size: 0x4)
SimSpaceSettings.MaxAngularAcceleration = 0x14 // float (Size: 0x4)
SimSpaceSettings.ExternalLinearDrag = 0x18 // float (Size: 0x4)
SimSpaceSettings.ExternalLinearDragV = 0x1c // FVector (Size: 0xc)
SimSpaceSettings.ExternalLinearVelocity = 0x28 // FVector (Size: 0xc)
SimSpaceSettings.ExternalAngularVelocity = 0x34 // FVector (Size: 0xc)
SocketReference.SocketName = 0x30 // FName (Size: 0x8)
SplineIKCachedBoneData.Bone = 0x0 // FBoneReference (Size: 0x10)
SplineIKCachedBoneData.RefSkeletonIndex = 0x10 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetInMs = 0x0 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.MinQuality = 0x4 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.MaxTickRate = 0x8 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.WorkUnitSmoothingSpeed = 0xc // float (Size: 0x4)
AnimationBudgetAllocatorParameters.AlwaysTickFalloffAggression = 0x10 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.InterpolationFalloffAggression = 0x14 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.InterpolationMaxRate = 0x18 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.MaxInterpolatedComponents = 0x1c // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.InterpolationTickMultiplier = 0x20 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.InitialEstimatedWorkUnitTimeMs = 0x24 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.MaxTickedOffsreenComponents = 0x28 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.StateChangeThrottleInFrames = 0x2c // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetFactorBeforeReducedWork = 0x30 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetFactorBeforeReducedWorkEpsilon = 0x34 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetPressureSmoothingSpeed = 0x38 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.ReducedWorkThrottleMinInFrames = 0x3c // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.ReducedWorkThrottleMaxInFrames = 0x40 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetFactorBeforeAggressiveReducedWork = 0x44 // float (Size: 0x4)
AnimationBudgetAllocatorParameters.ReducedWorkThrottleMaxPerFrame = 0x48 // int32_t (Size: 0x4)
AnimationBudgetAllocatorParameters.BudgetPressureBeforeEmergencyReducedWork = 0x4c // float (Size: 0x4)
SkeletalMeshComponentBudgeted.bAutoRegisterWithBudgetAllocator = 0x1108 // uint8_t (Size: 0x1)
SkeletalMeshComponentBudgeted.bAutoCalculateSignificance = 0x1108 // uint8_t (Size: 0x1)
SkeletalMeshComponentBudgeted.bShouldUseActorRenderedFlag = 0x1108 // uint8_t (Size: 0x1)
SkeletalMeshComponentBudgeted.BaseVisibleDistanceFactorThesholds = 0x1110 // TArray<float> (Size: 0x10)
AimConstraintDescription.LookAt_Axis = 0x10 // FAxis (Size: 0x10)
AimConstraintDescription.LookUp_Axis = 0x20 // FAxis (Size: 0x10)
AimConstraintDescription.bUseLookUp = 0x30 // bool (Size: 0x1)
AimConstraintDescription.LookUpTarget = 0x34 // FVector (Size: 0xc)
AnimationDataSourceRegistry.DataSources = 0x28 // TMap<...> (Size: 0x50)
Axis.Axis = 0x0 // FVector (Size: 0xc)
Axis.bInLocalSpace = 0xc // bool (Size: 0x1)
ConstraintData.Constraint = 0x0 // FConstraintDescriptor (Size: 0x10)
ConstraintData.Weight = 0x10 // float (Size: 0x4)
ConstraintData.bMaintainOffset = 0x14 // bool (Size: 0x1)
ConstraintData.Offset = 0x20 // FTransform (Size: 0x30)
ConstraintData.CurrentTransform = 0x50 // FTransform (Size: 0x30)
ConstraintDescription.bTranslation = 0x0 // bool (Size: 0x1)
ConstraintDescription.bRotation = 0x1 // bool (Size: 0x1)
ConstraintDescription.bScale = 0x2 // bool (Size: 0x1)
ConstraintDescription.bParent = 0x3 // bool (Size: 0x1)
ConstraintDescription.TranslationAxes = 0x4 // FFilterOptionPerAxis (Size: 0x3)
ConstraintDescription.RotationAxes = 0x7 // FFilterOptionPerAxis (Size: 0x3)
ConstraintDescription.ScaleAxes = 0xa // FFilterOptionPerAxis (Size: 0x3)
ConstraintDescriptionEx.AxesFilterOption = 0x8 // FFilterOptionPerAxis (Size: 0x3)
ConstraintDescriptor.Type = 0x0 // EEConstraintType (Size: 0x1)
ConstraintOffset.Translation = 0x0 // FVector (Size: 0xc)
ConstraintOffset.Rotation = 0x10 // FQuat (Size: 0x10)
ConstraintOffset.Scale = 0x20 // FVector (Size: 0xc)
ConstraintOffset.Parent = 0x30 // FTransform (Size: 0x30)
EulerTransform.Location = 0x0 // FVector (Size: 0xc)
EulerTransform.Rotation = 0xc // FRotator (Size: 0xc)
EulerTransform.Scale = 0x18 // FVector (Size: 0xc)
FilterOptionPerAxis.bX = 0x0 // bool (Size: 0x1)
FilterOptionPerAxis.bY = 0x1 // bool (Size: 0x1)
FilterOptionPerAxis.bZ = 0x2 // bool (Size: 0x1)
NodeChain.Nodes = 0x0 // TArray<FName> (Size: 0x10)
NodeHierarchyData.Nodes = 0x0 // TArray<FNodeObject> (Size: 0x10)
NodeHierarchyData.Transforms = 0x10 // TArray<FTransform> (Size: 0x10)
NodeHierarchyData.NodeNameToIndexMapping = 0x20 // TMap<...> (Size: 0x50)
NodeHierarchyWithUserData.Hierarchy = 0x8 // FNodeHierarchyData (Size: 0x70)
NodeObject.Name = 0x0 // FName (Size: 0x8)
NodeObject.ParentName = 0x8 // FName (Size: 0x8)
TransformConstraint.Operator = 0x0 // FConstraintDescription (Size: 0xd)
TransformConstraint.SourceNode = 0x10 // FName (Size: 0x8)
TransformConstraint.TargetNode = 0x18 // FName (Size: 0x8)
TransformConstraint.Weight = 0x20 // float (Size: 0x4)
TransformConstraint.bMaintainOffset = 0x24 // bool (Size: 0x1)
TransformConstraintDescription.TransformType = 0x10 // EETransformConstraintType (Size: 0x1)
TransformFilter.TranslationFilter = 0x0 // FFilterOptionPerAxis (Size: 0x3)
TransformFilter.RotationFilter = 0x3 // FFilterOptionPerAxis (Size: 0x3)
TransformFilter.ScaleFilter = 0x6 // FFilterOptionPerAxis (Size: 0x3)
TransformNoScale.Location = 0x0 // FVector (Size: 0xc)
TransformNoScale.Rotation = 0x10 // FQuat (Size: 0x10)
AnimNode_OrientationWarping.LocomotionAngle = 0xd0 // float (Size: 0x4)
AnimNode_OrientationWarping.ActualLocomotionAngle = 0xd4 // float (Size: 0x4)
AnimNode_OrientationWarping.LocomotionAngleBiasClamp = 0xd8 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_OrientationWarping.Settings = 0x108 // FOrientationWarpingSettings (Size: 0x38)
AnimNode_OrientationWarping.SpineBoneDataArray = 0x140 // TArray<FOrientationWarpingSpineBoneData> (Size: 0x10)
AnimNode_OrientationWarping.CachedDeltaTime = 0x164 // float (Size: 0x4)
AnimNode_SlopeWarping.IkFootRootBone = 0xe8 // FBoneReference (Size: 0x10)
AnimNode_SlopeWarping.PelvisBone = 0xf8 // FBoneReference (Size: 0x10)
AnimNode_SlopeWarping.FeetDefinitions = 0x108 // TArray<FSlopeWarpingFootDefinition> (Size: 0x10)
AnimNode_SlopeWarping.FeetData = 0x118 // TArray<FSlopeWarpingFootData> (Size: 0x10)
AnimNode_SlopeWarping.PelvisOffsetInterpolator = 0x128 // FVectorRK4SpringInterpolator (Size: 0x8)
AnimNode_SlopeWarping.GravityDir = 0x164 // FVector (Size: 0xc)
AnimNode_SlopeWarping.CustomFloorOffset = 0x170 // FVector (Size: 0xc)
AnimNode_SlopeWarping.CachedDeltaTime = 0x17c // float (Size: 0x4)
AnimNode_SlopeWarping.TargetFloorNormalWorldSpace = 0x180 // FVector (Size: 0xc)
AnimNode_SlopeWarping.FloorNormalInterpolator = 0x18c // FVectorRK4SpringInterpolator (Size: 0x8)
AnimNode_SlopeWarping.TargetFloorOffsetLocalSpace = 0x1c8 // FVector (Size: 0xc)
AnimNode_SlopeWarping.FloorOffsetInterpolator = 0x1d4 // FVectorRK4SpringInterpolator (Size: 0x8)
AnimNode_SlopeWarping.MaxStepHeight = 0x210 // float (Size: 0x4)
AnimNode_SlopeWarping.bKeepMeshInsideOfCapsule = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.bPullPelvisDown = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.bUseCustomFloorOffset = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.bWasOnGround = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.bShowDebug = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.bFloorSmoothingInitialized = 0x214 // uint8_t (Size: 0x1)
AnimNode_SlopeWarping.ActorLocation = 0x218 // FVector (Size: 0xc)
AnimNode_SlopeWarping.GravityDirCompSpace = 0x224 // FVector (Size: 0xc)
AnimNode_StrideWarping.IkFootRootBone = 0xd8 // FBoneReference (Size: 0x10)
AnimNode_StrideWarping.FeetDefinitions = 0xe8 // TArray<FStrideWarpingFootDefinition> (Size: 0x10)
AnimNode_StrideWarping.FeetData = 0xf8 // TArray<FStrideWarpingFootData> (Size: 0x10)
AnimNode_StrideWarping.PelvisBone = 0x108 // FBoneReference (Size: 0x10)
AnimNode_StrideWarping.StrideWarpingAxisMode = 0x118 // EEStrideWarpingAxisMode (Size: 0x1)
AnimNode_StrideWarping.FloorNormalAxisMode = 0x119 // EEStrideWarpingAxisMode (Size: 0x1)
AnimNode_StrideWarping.GravityDirAxisMode = 0x11a // EEStrideWarpingAxisMode (Size: 0x1)
AnimNode_StrideWarping.StrideScaling = 0x11c // float (Size: 0x4)
AnimNode_StrideWarping.StrideScalingScaleBiasClamp = 0x120 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_StrideWarping.ManualStrideWarpingDir = 0x150 // FVector (Size: 0xc)
AnimNode_StrideWarping.ManualFloorNormalInput = 0x15c // FVector (Size: 0xc)
AnimNode_StrideWarping.ManualGravityDirInput = 0x168 // FVector (Size: 0xc)
AnimNode_StrideWarping.PelvisPostAdjustmentAlpha = 0x174 // float (Size: 0x4)
AnimNode_StrideWarping.PelvisAdjustmentMaxIter = 0x178 // int32_t (Size: 0x4)
AnimNode_StrideWarping.PelvisAdjustmentInterp = 0x17c // FVectorRK4SpringInterpolator (Size: 0x8)
AnimNode_StrideWarping.bAdjustThighBonesRotation = 0x1b8 // uint8_t (Size: 0x1)
AnimNode_StrideWarping.bClampIKUsingFKLeg = 0x1b8 // uint8_t (Size: 0x1)
AnimNode_StrideWarping.bOrientStrideWarpingAxisBasedOnFloorNormal = 0x1b8 // uint8_t (Size: 0x1)
AnimNode_StrideWarping.CachedDeltaTime = 0x1bc // float (Size: 0x4)
OrientationWarpingSettings.YawRotationAxis = 0x0 // uint8_t (Size: 0x1)
OrientationWarpingSettings.BodyOrientationAlpha = 0x4 // float (Size: 0x4)
OrientationWarpingSettings.SpineBones = 0x8 // TArray<FOrientationWarpingSpineBoneSettings> (Size: 0x10)
OrientationWarpingSettings.IkFootRootBone = 0x18 // FBoneReference (Size: 0x10)
OrientationWarpingSettings.IKFootBones = 0x28 // TArray<FBoneReference> (Size: 0x10)
OrientationWarpingSpineBoneSettings.Bone = 0x0 // FBoneReference (Size: 0x10)
SlopeWarpingFootDefinition.IKFootBone = 0x0 // FBoneReference (Size: 0x10)
SlopeWarpingFootDefinition.FKFootBone = 0x10 // FBoneReference (Size: 0x10)
SlopeWarpingFootDefinition.NumBonesInLimb = 0x20 // int32_t (Size: 0x4)
SlopeWarpingFootDefinition.FootSize = 0x24 // float (Size: 0x4)
StrideWarpingFootDefinition.IKFootBone = 0x0 // FBoneReference (Size: 0x10)
StrideWarpingFootDefinition.FKFootBone = 0x10 // FBoneReference (Size: 0x10)
StrideWarpingFootDefinition.NumBonesInLimb = 0x20 // int32_t (Size: 0x4)
AssetRegistryDependencyOptions.bIncludeSoftPackageReferences = 0x0 // bool (Size: 0x1)
AssetRegistryDependencyOptions.bIncludeHardPackageReferences = 0x1 // bool (Size: 0x1)
AssetRegistryDependencyOptions.bIncludeSearchableNames = 0x2 // bool (Size: 0x1)
AssetRegistryDependencyOptions.bIncludeSoftManagementReferences = 0x3 // bool (Size: 0x1)
AssetRegistryDependencyOptions.bIncludeHardManagementReferences = 0x4 // bool (Size: 0x1)
TagAndValue.Tag = 0x0 // FName (Size: 0x8)
TagAndValue.Value = 0x8 // FString (Size: 0x10)
AudioCaptureComponent.JitterLatencyFrames = 0x700 // int32_t (Size: 0x4)
AudioCaptureDeviceInfo.DeviceName = 0x0 // FName (Size: 0x8)
AudioCaptureDeviceInfo.NumInputChannels = 0x8 // int32_t (Size: 0x4)
AudioCaptureDeviceInfo.SampleRate = 0xc // int32_t (Size: 0x4)
SoundfieldEffectBase.Settings = 0x28 // SoundfieldEffectSettingsBase* (Size: 0x8)
SubmixEffectDynamicProcessorFilterSettings.bEnabled = 0x0 // uint8_t (Size: 0x1)
SubmixEffectDynamicProcessorFilterSettings.Cutoff = 0x4 // float (Size: 0x4)
SubmixEffectDynamicProcessorFilterSettings.GainDb = 0x8 // float (Size: 0x4)
SubmixEffectDynamicsProcessorPreset.Settings = 0xe0 // FSubmixEffectDynamicsProcessorSettings (Size: 0x50)
SubmixEffectDynamicsProcessorSettings.DynamicsProcessorType = 0x0 // EESubmixEffectDynamicsProcessorType (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.PeakMode = 0x1 // EESubmixEffectDynamicsPeakMode (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.LinkMode = 0x2 // EESubmixEffectDynamicsChannelLinkMode (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.InputGainDb = 0x4 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.ThresholdDb = 0x8 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.Ratio = 0xc // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.KneeBandwidthDb = 0x10 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.LookAheadMsec = 0x14 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.AttackTimeMsec = 0x18 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.ReleaseTimeMsec = 0x1c // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.ExternalSubmix = 0x20 // SoundSubmix* (Size: 0x8)
SubmixEffectDynamicsProcessorSettings.bChannelLinked = 0x28 // uint8_t (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.bAnalogMode = 0x28 // uint8_t (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.bKeyAudition = 0x28 // uint8_t (Size: 0x1)
SubmixEffectDynamicsProcessorSettings.KeyGainDb = 0x2c // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.OutputGainDb = 0x30 // float (Size: 0x4)
SubmixEffectDynamicsProcessorSettings.KeyHighshelf = 0x34 // FSubmixEffectDynamicProcessorFilterSettings (Size: 0xc)
SubmixEffectDynamicsProcessorSettings.KeyLowshelf = 0x40 // FSubmixEffectDynamicProcessorFilterSettings (Size: 0xc)
SubmixEffectEQBand.Frequency = 0x0 // float (Size: 0x4)
SubmixEffectEQBand.Bandwidth = 0x4 // float (Size: 0x4)
SubmixEffectEQBand.GainDb = 0x8 // float (Size: 0x4)
SubmixEffectEQBand.bEnabled = 0xc // uint8_t (Size: 0x1)
SubmixEffectReverbPreset.Settings = 0xd0 // FSubmixEffectReverbSettings (Size: 0x40)
SubmixEffectReverbSettings.bBypassEarlyReflections = 0x0 // bool (Size: 0x1)
SubmixEffectReverbSettings.ReflectionsDelay = 0x4 // float (Size: 0x4)
SubmixEffectReverbSettings.GainHF = 0x8 // float (Size: 0x4)
SubmixEffectReverbSettings.ReflectionsGain = 0xc // float (Size: 0x4)
SubmixEffectReverbSettings.bBypassLateReflections = 0x10 // bool (Size: 0x1)
SubmixEffectReverbSettings.LateDelay = 0x14 // float (Size: 0x4)
SubmixEffectReverbSettings.DecayTime = 0x18 // float (Size: 0x4)
SubmixEffectReverbSettings.Density = 0x1c // float (Size: 0x4)
SubmixEffectReverbSettings.Diffusion = 0x20 // float (Size: 0x4)
SubmixEffectReverbSettings.AirAbsorptionGainHF = 0x24 // float (Size: 0x4)
SubmixEffectReverbSettings.DecayHFRatio = 0x28 // float (Size: 0x4)
SubmixEffectReverbSettings.LateGain = 0x2c // float (Size: 0x4)
SubmixEffectReverbSettings.Gain = 0x30 // float (Size: 0x4)
SubmixEffectReverbSettings.WetLevel = 0x34 // float (Size: 0x4)
SubmixEffectReverbSettings.DryLevel = 0x38 // float (Size: 0x4)
SubmixEffectReverbSettings.bBypass = 0x3c // bool (Size: 0x1)
SubmixEffectSubmixEQPreset.Settings = 0xa0 // FSubmixEffectSubmixEQSettings (Size: 0x10)
SubmixEffectSubmixEQSettings.EQBands = 0x0 // TArray<FSubmixEffectEQBand> (Size: 0x10)
SynthComponent.bAutoDestroy = 0x238 // uint8_t (Size: 0x1)
SynthComponent.bStopWhenOwnerDestroyed = 0x238 // uint8_t (Size: 0x1)
SynthComponent.bAllowSpatialization = 0x238 // uint8_t (Size: 0x1)
SynthComponent.bOverrideAttenuation = 0x238 // uint8_t (Size: 0x1)
SynthComponent.bOutputToBusOnly = 0x23c // uint8_t (Size: 0x1)
SynthComponent.AttenuationSettings = 0x240 // SoundAttenuation* (Size: 0x8)
SynthComponent.AttenuationOverrides = 0x248 // FSoundAttenuationSettings (Size: 0x3a0)
SynthComponent.ConcurrencySettings = 0x5e8 // SoundConcurrency* (Size: 0x8)
SynthComponent.ConcurrencySet = 0x5f0 // TSet<...> (Size: 0x50)
SynthComponent.SoundClass = 0x640 // SoundClass* (Size: 0x8)
SynthComponent.SourceEffectChain = 0x648 // SoundEffectSourcePresetChain* (Size: 0x8)
SynthComponent.SoundSubmix = 0x650 // SoundSubmixBase* (Size: 0x8)
SynthComponent.SoundSubmixSends = 0x658 // TArray<FSoundSubmixSendInfo> (Size: 0x10)
SynthComponent.BusSends = 0x668 // TArray<FSoundSourceBusSendInfo> (Size: 0x10)
SynthComponent.PreEffectBusSends = 0x678 // TArray<FSoundSourceBusSendInfo> (Size: 0x10)
SynthComponent.bIsUISound = 0x688 // uint8_t (Size: 0x1)
SynthComponent.bIsPreviewSound = 0x688 // uint8_t (Size: 0x1)
SynthComponent.EnvelopeFollowerAttackTime = 0x68c // int32_t (Size: 0x4)
SynthComponent.EnvelopeFollowerReleaseTime = 0x690 // int32_t (Size: 0x4)
SynthComponent.OnAudioEnvelopeValue = 0x698 // FMulticastInlineDelegate (Size: 0x10)
SynthComponent.Synth = 0x6c8 // SynthSound* (Size: 0x8)
SynthComponent.AudioComponent = 0x6d0 // AudioComponent* (Size: 0x8)
SynthSound.OwningSynthComponent = 0x3c0 // SynthComponent* (Size: 0x8)
PlatformRuntimeAudioCompressionOverrides.bOverrideCompressionTimes = 0x0 // bool (Size: 0x1)
PlatformRuntimeAudioCompressionOverrides.DurationThreshold = 0x4 // float (Size: 0x4)
PlatformRuntimeAudioCompressionOverrides.MaxNumRandomBranches = 0x8 // int32_t (Size: 0x4)
PlatformRuntimeAudioCompressionOverrides.SoundCueQualityIndex = 0xc // int32_t (Size: 0x4)
ARBasicLightEstimate.AmbientIntensityLumens = 0x28 // float (Size: 0x4)
ARBasicLightEstimate.AmbientColorTemperatureKelvin = 0x2c // float (Size: 0x4)
ARBasicLightEstimate.AmbientColor = 0x30 // FLinearColor (Size: 0x10)
ARCameraIntrinsics.ImageResolution = 0x0 // FIntPoint (Size: 0x8)
ARCameraIntrinsics.FocalLength = 0x8 // FVector2D (Size: 0x8)
ARCameraIntrinsics.PrincipalPoint = 0x10 // FVector2D (Size: 0x8)
ARCandidateImage.CandidateTexture = 0x30 // Texture2D* (Size: 0x8)
ARCandidateImage.FriendlyName = 0x38 // FString (Size: 0x10)
ARCandidateImage.Width = 0x48 // float (Size: 0x4)
ARCandidateImage.Height = 0x4c // float (Size: 0x4)
ARCandidateImage.Orientation = 0x50 // EEARCandidateImageOrientation (Size: 0x1)
ARCandidateObject.CandidateObjectData = 0x30 // TArray<uint8_t> (Size: 0x10)
ARCandidateObject.FriendlyName = 0x40 // FString (Size: 0x10)
ARCandidateObject.BoundingBox = 0x50 // FBox (Size: 0x1c)
ARComponent.NativeID = 0x238 // FGuid (Size: 0x10)
ARComponent.bUseDefaultReplication = 0x278 // bool (Size: 0x1)
ARComponent.DefaultMeshMaterial = 0x280 // MaterialInterface* (Size: 0x8)
ARComponent.DefaultWireframeMeshMaterial = 0x288 // MaterialInterface* (Size: 0x8)
ARComponent.MRMeshComponent = 0x290 // MRMeshComponent* (Size: 0x8)
ARComponent.MyTrackedGeometry = 0x298 // ARTrackedGeometry* (Size: 0x8)
AREnvironmentCaptureProbe.Extent = 0xf8 // FVector (Size: 0xc)
AREnvironmentCaptureProbe.EnvironmentCaptureTexture = 0x108 // AREnvironmentCaptureProbeTexture* (Size: 0x8)
AREnvironmentCaptureProbeTexture.TextureType = 0x148 // EEARTextureType (Size: 0x1)
AREnvironmentCaptureProbeTexture.Timestamp = 0x14c // float (Size: 0x4)
AREnvironmentCaptureProbeTexture.ExternalTextureGuid = 0x150 // FGuid (Size: 0x10)
AREnvironmentCaptureProbeTexture.Size = 0x160 // FVector2D (Size: 0x8)
AREnvironmentProbeComponent.ReplicatedPayload = 0x2c0 // FAREnvironmentProbeUpdatePayload (Size: 0x30)
AREnvironmentProbeUpdatePayload.WorldTransform = 0x0 // FTransform (Size: 0x30)
ARFaceComponent.TransformSetting = 0x2b8 // EEARFaceTransformMixing (Size: 0x1)
ARFaceComponent.bUpdateVertexNormal = 0x2b9 // bool (Size: 0x1)
ARFaceComponent.bFaceOutOfScreen = 0x2ba // bool (Size: 0x1)
ARFaceComponent.ReplicatedPayload = 0x2c0 // FARFaceUpdatePayload (Size: 0x40)
ARFaceGeometry.LookAtTarget = 0xf8 // FVector (Size: 0xc)
ARFaceGeometry.bIsTracked = 0x104 // bool (Size: 0x1)
ARFaceGeometry.BlendShapes = 0x108 // TMap<...> (Size: 0x50)
ARFaceGeometry.LeftEyeTransform = 0x190 // FTransform (Size: 0x30)
ARFaceGeometry.RightEyeTransform = 0x1c0 // FTransform (Size: 0x30)
ARFaceUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARFaceUpdatePayload.LeftEyePosition = 0x18 // FVector (Size: 0xc)
ARFaceUpdatePayload.RightEyePosition = 0x24 // FVector (Size: 0xc)
ARFaceUpdatePayload.LookAtTarget = 0x30 // FVector (Size: 0xc)
ARGeoAnchorComponent.ReplicatedPayload = 0x2c0 // FARGeoAnchorUpdatePayload (Size: 0x70)
ARGeoAnchorUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARGeoAnchorUpdatePayload.WorldTransform = 0x20 // FTransform (Size: 0x30)
ARGeoAnchorUpdatePayload.Longitude = 0x50 // float (Size: 0x4)
ARGeoAnchorUpdatePayload.Latitude = 0x54 // float (Size: 0x4)
ARGeoAnchorUpdatePayload.AltitudeMeters = 0x58 // float (Size: 0x4)
ARGeoAnchorUpdatePayload.AltitudeSource = 0x5c // EEARAltitudeSource (Size: 0x1)
ARGeoAnchorUpdatePayload.AnchorName = 0x60 // FString (Size: 0x10)
ARGetCandidateObjectAsyncTaskBlueprintProxy.OnSuccess = 0x50 // FMulticastInlineDelegate (Size: 0x10)
ARGetCandidateObjectAsyncTaskBlueprintProxy.OnFailed = 0x60 // FMulticastInlineDelegate (Size: 0x10)
ARImageComponent.ReplicatedPayload = 0x2c0 // FARImageUpdatePayload (Size: 0x60)
ARImageUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARImageUpdatePayload.WorldTransform = 0x20 // FTransform (Size: 0x30)
ARImageUpdatePayload.DetectedImage = 0x50 // ARCandidateImage* (Size: 0x8)
ARImageUpdatePayload.EstimatedSize = 0x58 // FVector2D (Size: 0x8)
ARLifeCycleComponent.OnARActorSpawnedDelegate = 0x238 // FMulticastInlineDelegate (Size: 0x10)
ARLifeCycleComponent.OnARActorToBeDestroyedDelegate = 0x248 // FMulticastInlineDelegate (Size: 0x10)
ARMeshComponent.ReplicatedPayload = 0x2c0 // FARMeshUpdatePayload (Size: 0x60)
ARMeshUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARMeshUpdatePayload.WorldTransform = 0x20 // FTransform (Size: 0x30)
ARMeshUpdatePayload.ObjectClassification = 0x50 // EEARObjectClassification (Size: 0x1)
ARObjectComponent.ReplicatedPayload = 0x2c0 // FARObjectUpdatePayload (Size: 0x30)
ARObjectUpdatePayload.WorldTransform = 0x0 // FTransform (Size: 0x30)
ARPin.TrackedGeometry = 0x28 // ARTrackedGeometry* (Size: 0x8)
ARPin.PinnedComponent = 0x30 // SceneComponent* (Size: 0x8)
ARPin.LocalToTrackingTransform = 0x40 // FTransform (Size: 0x30)
ARPin.LocalToAlignedTrackingTransform = 0x70 // FTransform (Size: 0x30)
ARPin.TrackingState = 0xa0 // EEARTrackingState (Size: 0x1)
ARPin.OnARTrackingStateChanged = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
ARPin.OnARTransformUpdated = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
ARPlaneComponent.ReplicatedPayload = 0x2c0 // FARPlaneUpdatePayload (Size: 0x80)
ARPlaneGeometry.Orientation = 0xf8 // EEARPlaneOrientation (Size: 0x1)
ARPlaneGeometry.Center = 0xfc // FVector (Size: 0xc)
ARPlaneGeometry.Extent = 0x108 // FVector (Size: 0xc)
ARPlaneGeometry.BoundaryPolygon = 0x118 // TArray<FVector> (Size: 0x10)
ARPlaneGeometry.SubsumedBy = 0x128 // ARPlaneGeometry* (Size: 0x8)
ARPlaneUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARPlaneUpdatePayload.WorldTransform = 0x20 // FTransform (Size: 0x30)
ARPlaneUpdatePayload.Center = 0x50 // FVector (Size: 0xc)
ARPlaneUpdatePayload.Extents = 0x5c // FVector (Size: 0xc)
ARPlaneUpdatePayload.BoundaryVertices = 0x68 // TArray<FVector> (Size: 0x10)
ARPlaneUpdatePayload.ObjectClassification = 0x78 // EEARObjectClassification (Size: 0x1)
ARPointComponent.ReplicatedPayload = 0x2b8 // FARPointUpdatePayload (Size: 0x1)
ARPose2D.SkeletonDefinition = 0x0 // FARSkeletonDefinition (Size: 0x28)
ARPose2D.JointLocations = 0x28 // TArray<FVector2D> (Size: 0x10)
ARPose2D.IsJointTracked = 0x38 // TArray<bool> (Size: 0x10)
ARPose3D.SkeletonDefinition = 0x0 // FARSkeletonDefinition (Size: 0x28)
ARPose3D.JointTransforms = 0x28 // TArray<FTransform> (Size: 0x10)
ARPose3D.IsJointTracked = 0x38 // TArray<bool> (Size: 0x10)
ARPose3D.JointTransformSpace = 0x48 // EEARJointTransformSpace (Size: 0x1)
ARPoseComponent.ReplicatedPayload = 0x2c0 // FARPoseUpdatePayload (Size: 0x40)
ARPoseUpdatePayload.WorldTransform = 0x0 // FTransform (Size: 0x30)
ARPoseUpdatePayload.JointTransforms = 0x30 // TArray<FTransform> (Size: 0x10)
ARQRCodeComponent.ReplicatedPayload = 0x2c0 // FARQRCodeUpdatePayload (Size: 0x70)
ARQRCodeUpdatePayload.SessionPayload = 0x0 // FARSessionPayload (Size: 0x18)
ARQRCodeUpdatePayload.WorldTransform = 0x20 // FTransform (Size: 0x30)
ARQRCodeUpdatePayload.Extents = 0x50 // FVector (Size: 0xc)
ARQRCodeUpdatePayload.QRCode = 0x60 // FString (Size: 0x10)
ARSaveWorldAsyncTaskBlueprintProxy.OnSuccess = 0x50 // FMulticastInlineDelegate (Size: 0x10)
ARSaveWorldAsyncTaskBlueprintProxy.OnFailed = 0x60 // FMulticastInlineDelegate (Size: 0x10)
ARSessionConfig.bGenerateMeshDataFromTrackedGeometry = 0x30 // bool (Size: 0x1)
ARSessionConfig.bGenerateCollisionForMeshData = 0x31 // bool (Size: 0x1)
ARSessionConfig.bGenerateNavMeshForMeshData = 0x32 // bool (Size: 0x1)
ARSessionConfig.bUseMeshDataForOcclusion = 0x33 // bool (Size: 0x1)
ARSessionConfig.bRenderMeshDataInWireframe = 0x34 // bool (Size: 0x1)
ARSessionConfig.bTrackSceneObjects = 0x35 // bool (Size: 0x1)
ARSessionConfig.bUsePersonSegmentationForOcclusion = 0x36 // bool (Size: 0x1)
ARSessionConfig.bUseSceneDepthForOcclusion = 0x37 // bool (Size: 0x1)
ARSessionConfig.bUseAutomaticImageScaleEstimation = 0x38 // bool (Size: 0x1)
ARSessionConfig.bUseStandardOnboardingUX = 0x39 // bool (Size: 0x1)
ARSessionConfig.WorldAlignment = 0x3a // EEARWorldAlignment (Size: 0x1)
ARSessionConfig.SessionType = 0x3b // EEARSessionType (Size: 0x1)
ARSessionConfig.PlaneDetectionMode = 0x3c // EEARPlaneDetectionMode (Size: 0x1)
ARSessionConfig.bHorizontalPlaneDetection = 0x3d // bool (Size: 0x1)
ARSessionConfig.bVerticalPlaneDetection = 0x3e // bool (Size: 0x1)
ARSessionConfig.bEnableAutoFocus = 0x3f // bool (Size: 0x1)
ARSessionConfig.LightEstimationMode = 0x40 // EEARLightEstimationMode (Size: 0x1)
ARSessionConfig.FrameSyncMode = 0x41 // EEARFrameSyncMode (Size: 0x1)
ARSessionConfig.bEnableAutomaticCameraOverlay = 0x42 // bool (Size: 0x1)
ARSessionConfig.bEnableAutomaticCameraTracking = 0x43 // bool (Size: 0x1)
ARSessionConfig.bResetCameraTracking = 0x44 // bool (Size: 0x1)
ARSessionConfig.bResetTrackedObjects = 0x45 // bool (Size: 0x1)
ARSessionConfig.CandidateImages = 0x48 // TArray<ARCandidateImage*> (Size: 0x10)
ARSessionConfig.MaxNumSimultaneousImagesTracked = 0x58 // int32_t (Size: 0x4)
ARSessionConfig.EnvironmentCaptureProbeType = 0x5c // EEAREnvironmentCaptureProbeType (Size: 0x1)
ARSessionConfig.WorldMapData = 0x60 // TArray<uint8_t> (Size: 0x10)
ARSessionConfig.CandidateObjects = 0x70 // TArray<ARCandidateObject*> (Size: 0x10)
ARSessionConfig.DesiredVideoFormat = 0x80 // FARVideoFormat (Size: 0xc)
ARSessionConfig.bUseOptimalVideoFormat = 0x8c // bool (Size: 0x1)
ARSessionConfig.FaceTrackingDirection = 0x8d // EEARFaceTrackingDirection (Size: 0x1)
ARSessionConfig.FaceTrackingUpdate = 0x8e // EEARFaceTrackingUpdate (Size: 0x1)
ARSessionConfig.MaxNumberOfTrackedFaces = 0x90 // int32_t (Size: 0x4)
ARSessionConfig.SerializedARCandidateImageDatabase = 0x98 // TArray<uint8_t> (Size: 0x10)
ARSessionConfig.EnabledSessionTrackingFeature = 0xa8 // EEARSessionTrackingFeature (Size: 0x1)
ARSessionConfig.SceneReconstructionMethod = 0xa9 // EEARSceneReconstruction (Size: 0x1)
ARSessionConfig.PlaneComponentClass = 0xb0 // ClassProperty (Size: 0x8)
ARSessionConfig.PointComponentClass = 0xb8 // ClassProperty (Size: 0x8)
ARSessionConfig.FaceComponentClass = 0xc0 // ClassProperty (Size: 0x8)
ARSessionConfig.ImageComponentClass = 0xc8 // ClassProperty (Size: 0x8)
ARSessionConfig.QRCodeComponentClass = 0xd0 // ClassProperty (Size: 0x8)
ARSessionConfig.PoseComponentClass = 0xd8 // ClassProperty (Size: 0x8)
ARSessionConfig.EnvironmentProbeComponentClass = 0xe0 // ClassProperty (Size: 0x8)
ARSessionConfig.ObjectComponentClass = 0xe8 // ClassProperty (Size: 0x8)
ARSessionConfig.MeshComponentClass = 0xf0 // ClassProperty (Size: 0x8)
ARSessionConfig.GeoAnchorComponentClass = 0xf8 // ClassProperty (Size: 0x8)
ARSessionConfig.DefaultMeshMaterial = 0x100 // MaterialInterface* (Size: 0x8)
ARSessionConfig.DefaultWireframeMeshMaterial = 0x108 // MaterialInterface* (Size: 0x8)
ARSessionPayload.ConfigFlags = 0x0 // int32_t (Size: 0x4)
ARSessionPayload.DefaultMeshMaterial = 0x8 // MaterialInterface* (Size: 0x8)
ARSessionPayload.DefaultWireframeMeshMaterial = 0x10 // MaterialInterface* (Size: 0x8)
ARSessionStatus.AdditionalInfo = 0x0 // FString (Size: 0x10)
ARSessionStatus.status = 0x10 // EEARSessionStatus (Size: 0x1)
ARSharedWorldGameMode.BufferSizePerChunk = 0x3f8 // int32_t (Size: 0x4)
ARSharedWorldGameState.PreviewImageData = 0x380 // TArray<uint8_t> (Size: 0x10)
ARSharedWorldGameState.ARWorldData = 0x390 // TArray<uint8_t> (Size: 0x10)
ARSharedWorldGameState.PreviewImageBytesTotal = 0x3a0 // int32_t (Size: 0x4)
ARSharedWorldGameState.ARWorldBytesTotal = 0x3a4 // int32_t (Size: 0x4)
ARSharedWorldGameState.PreviewImageBytesDelivered = 0x3a8 // int32_t (Size: 0x4)
ARSharedWorldGameState.ARWorldBytesDelivered = 0x3ac // int32_t (Size: 0x4)
ARSharedWorldReplicationState.PreviewImageOffset = 0x0 // int32_t (Size: 0x4)
ARSharedWorldReplicationState.ARWorldOffset = 0x4 // int32_t (Size: 0x4)
ARSkeletonDefinition.NumJoints = 0x0 // int32_t (Size: 0x4)
ARSkeletonDefinition.JointNames = 0x8 // TArray<FName> (Size: 0x10)
ARSkeletonDefinition.ParentIndices = 0x18 // TArray<int32_t> (Size: 0x10)
ARSkyLight.CaptureProbe = 0x320 // AREnvironmentCaptureProbe* (Size: 0x8)
ARTexture.TextureType = 0xf0 // EEARTextureType (Size: 0x1)
ARTexture.Timestamp = 0xf4 // float (Size: 0x4)
ARTexture.ExternalTextureGuid = 0xf8 // FGuid (Size: 0x10)
ARTexture.Size = 0x108 // FVector2D (Size: 0x8)
ARTextureCameraDepth.DepthQuality = 0x110 // EEARDepthQuality (Size: 0x1)
ARTextureCameraDepth.DepthAccuracy = 0x111 // EEARDepthAccuracy (Size: 0x1)
ARTextureCameraDepth.bIsTemporallySmoothed = 0x112 // bool (Size: 0x1)
ARTraceResult.DistanceFromCamera = 0x0 // float (Size: 0x4)
ARTraceResult.TraceChannel = 0x4 // EEARLineTraceChannels (Size: 0x1)
ARTraceResult.LocalTransform = 0x10 // FTransform (Size: 0x30)
ARTraceResult.TrackedGeometry = 0x40 // ARTrackedGeometry* (Size: 0x8)
ARTrackableNotifyComponent.OnAddTrackedGeometry = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedGeometry = 0x108 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedGeometry = 0x118 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedPlane = 0x128 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedPlane = 0x138 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedPlane = 0x148 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedPoint = 0x158 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedPoint = 0x168 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedPoint = 0x178 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedImage = 0x188 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedImage = 0x198 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedImage = 0x1a8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedFace = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedFace = 0x1c8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedFace = 0x1d8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedEnvProbe = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedEnvProbe = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedEnvProbe = 0x208 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnAddTrackedObject = 0x218 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnUpdateTrackedObject = 0x228 // FMulticastInlineDelegate (Size: 0x10)
ARTrackableNotifyComponent.OnRemoveTrackedObject = 0x238 // FMulticastInlineDelegate (Size: 0x10)
ARTrackedGeometry.UniqueID = 0x28 // FGuid (Size: 0x10)
ARTrackedGeometry.LocalToTrackingTransform = 0x40 // FTransform (Size: 0x30)
ARTrackedGeometry.LocalToAlignedTrackingTransform = 0x70 // FTransform (Size: 0x30)
ARTrackedGeometry.TrackingState = 0xa0 // EEARTrackingState (Size: 0x1)
ARTrackedGeometry.UnderlyingMesh = 0xb0 // MRMeshComponent* (Size: 0x8)
ARTrackedGeometry.ObjectClassification = 0xb8 // EEARObjectClassification (Size: 0x1)
ARTrackedGeometry.LastUpdateFrameNumber = 0xd0 // int32_t (Size: 0x4)
ARTrackedGeometry.DebugName = 0xe0 // FName (Size: 0x8)
ARTrackedImage.DetectedImage = 0xf8 // ARCandidateImage* (Size: 0x8)
ARTrackedImage.EstimatedSize = 0x100 // FVector2D (Size: 0x8)
ARTrackedObject.DetectedObject = 0xf8 // ARCandidateObject* (Size: 0x8)
ARTrackedPose.TrackedPose = 0xf8 // FARPose3D (Size: 0x50)
ARTrackedQRCode.QRCode = 0x108 // FString (Size: 0x10)
ARTrackedQRCode.Version = 0x118 // int32_t (Size: 0x4)
ARVideoFormat.FPS = 0x0 // int32_t (Size: 0x4)
ARVideoFormat.Width = 0x4 // int32_t (Size: 0x4)
ARVideoFormat.Height = 0x8 // int32_t (Size: 0x4)
CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy.OnSuccess = 0x50 // FMulticastInlineDelegate (Size: 0x10)
CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy.OnFailed = 0x60 // FMulticastInlineDelegate (Size: 0x10)
GetGeoLocationAsyncTaskBlueprintProxy.OnSuccess = 0x50 // FMulticastInlineDelegate (Size: 0x10)
GetGeoLocationAsyncTaskBlueprintProxy.OnFailed = 0x60 // FMulticastInlineDelegate (Size: 0x10)
TrackedGeometryGroup.ARActor = 0x0 // ARActor* (Size: 0x8)
TrackedGeometryGroup.ARComponent = 0x8 // ARComponent* (Size: 0x8)
TrackedGeometryGroup.TrackedGeometry = 0x10 // ARTrackedGeometry* (Size: 0x8)
AvfMediaSettings.NativeAudioOut = 0x28 // bool (Size: 0x1)
BuildPatchManifest.ManifestFileVersion = 0x28 // uint8_t (Size: 0x1)
BuildPatchManifest.bIsFileData = 0x29 // bool (Size: 0x1)
BuildPatchManifest.AppID = 0x2c // uint32_t (Size: 0x4)
BuildPatchManifest.AppName = 0x30 // FString (Size: 0x10)
BuildPatchManifest.BuildVersion = 0x40 // FString (Size: 0x10)
BuildPatchManifest.LaunchExe = 0x50 // FString (Size: 0x10)
BuildPatchManifest.LaunchCommand = 0x60 // FString (Size: 0x10)
BuildPatchManifest.PrereqIds = 0x70 // TSet<...> (Size: 0x50)
BuildPatchManifest.PrereqName = 0xc0 // FString (Size: 0x10)
BuildPatchManifest.PrereqPath = 0xd0 // FString (Size: 0x10)
BuildPatchManifest.PrereqArgs = 0xe0 // FString (Size: 0x10)
BuildPatchManifest.FileManifestList = 0xf0 // TArray<FFileManifestData> (Size: 0x10)
BuildPatchManifest.ChunkList = 0x100 // TArray<FChunkInfoData> (Size: 0x10)
BuildPatchManifest.CustomFields = 0x110 // TArray<FCustomFieldData> (Size: 0x10)
ChunkInfoData.Guid = 0x0 // FGuid (Size: 0x10)
ChunkInfoData.Hash = 0x10 // uint64_t (Size: 0x8)
ChunkInfoData.ShaHash = 0x18 // FSHAHashData (Size: 0x14)
ChunkInfoData.FileSize = 0x30 // int64_t (Size: 0x8)
ChunkInfoData.GroupNumber = 0x38 // uint8_t (Size: 0x1)
ChunkPartData.Guid = 0x0 // FGuid (Size: 0x10)
ChunkPartData.Offset = 0x10 // uint32_t (Size: 0x4)
ChunkPartData.Size = 0x14 // uint32_t (Size: 0x4)
CustomFieldData.Key = 0x0 // FString (Size: 0x10)
CustomFieldData.Value = 0x10 // FString (Size: 0x10)
FileManifestData.Filename = 0x0 // FString (Size: 0x10)
FileManifestData.FileHash = 0x10 // FSHAHashData (Size: 0x14)
FileManifestData.FileChunkParts = 0x28 // TArray<FChunkPartData> (Size: 0x10)
FileManifestData.InstallTags = 0x38 // TArray<FString> (Size: 0x10)
FileManifestData.bIsUnixExecutable = 0x48 // bool (Size: 0x1)
FileManifestData.SymlinkTarget = 0x50 // FString (Size: 0x10)
FileManifestData.bIsReadOnly = 0x60 // bool (Size: 0x1)
FileManifestData.bIsCompressed = 0x61 // bool (Size: 0x1)
SHAHashData.Hash = 0x0 // uint8_t (Size: 0x1)
CableActor.CableComponent = 0x310 // CableComponent* (Size: 0x8)
CableComponent.bAttachStart = 0x600 // bool (Size: 0x1)
CableComponent.bAttachEnd = 0x601 // bool (Size: 0x1)
CableComponent.AttachEndTo = 0x608 // FComponentReference (Size: 0x28)
CableComponent.AttachEndToSocketName = 0x630 // FName (Size: 0x8)
CableComponent.EndLocation = 0x638 // FVector (Size: 0xc)
CableComponent.CableLength = 0x644 // float (Size: 0x4)
CableComponent.NumSegments = 0x648 // int32_t (Size: 0x4)
CableComponent.SubstepTime = 0x64c // float (Size: 0x4)
CableComponent.SolverIterations = 0x650 // int32_t (Size: 0x4)
CableComponent.bEnableStiffness = 0x654 // bool (Size: 0x1)
CableComponent.bUseSubstepping = 0x655 // bool (Size: 0x1)
CableComponent.bSkipCableUpdateWhenNotVisible = 0x656 // bool (Size: 0x1)
CableComponent.bSkipCableUpdateWhenNotOwnerRecentlyRendered = 0x657 // bool (Size: 0x1)
CableComponent.bEnableCollision = 0x658 // bool (Size: 0x1)
CableComponent.CollisionFriction = 0x65c // float (Size: 0x4)
CableComponent.CableForce = 0x660 // FVector (Size: 0xc)
CableComponent.CableGravityScale = 0x66c // float (Size: 0x4)
CableComponent.CableWidth = 0x670 // float (Size: 0x4)
CableComponent.NumSides = 0x674 // int32_t (Size: 0x4)
CableComponent.TileMaterial = 0x678 // float (Size: 0x4)
ChaosSolverConfiguration.Iterations = 0x0 // int32_t (Size: 0x4)
ChaosSolverConfiguration.CollisionPairIterations = 0x4 // int32_t (Size: 0x4)
ChaosSolverConfiguration.PushOutIterations = 0x8 // int32_t (Size: 0x4)
ChaosSolverConfiguration.CollisionPushOutPairIterations = 0xc // int32_t (Size: 0x4)
ChaosSolverConfiguration.CollisionMarginFraction = 0x10 // float (Size: 0x4)
ChaosSolverConfiguration.CollisionMarginMax = 0x14 // float (Size: 0x4)
ChaosSolverConfiguration.CollisionCullDistance = 0x18 // float (Size: 0x4)
ChaosSolverConfiguration.JointPairIterations = 0x1c // int32_t (Size: 0x4)
ChaosSolverConfiguration.JointPushOutPairIterations = 0x20 // int32_t (Size: 0x4)
ChaosSolverConfiguration.ClusterConnectionFactor = 0x24 // float (Size: 0x4)
ChaosSolverConfiguration.ClusterUnionConnectionType = 0x28 // EEClusterUnionMethod (Size: 0x1)
ChaosSolverConfiguration.bGenerateCollisionData = 0x29 // bool (Size: 0x1)
ChaosSolverConfiguration.CollisionFilterSettings = 0x2c // FSolverCollisionFilterSettings (Size: 0x10)
ChaosSolverConfiguration.bGenerateBreakData = 0x3c // bool (Size: 0x1)
ChaosSolverConfiguration.BreakingFilterSettings = 0x40 // FSolverBreakingFilterSettings (Size: 0x10)
ChaosSolverConfiguration.bGenerateTrailingData = 0x50 // bool (Size: 0x1)
ChaosSolverConfiguration.TrailingFilterSettings = 0x54 // FSolverTrailingFilterSettings (Size: 0x10)
ChaosSolverConfiguration.bGenerateContactGraph = 0x64 // bool (Size: 0x1)
RecordedFrame.Transforms = 0x0 // TArray<FTransform> (Size: 0x10)
RecordedFrame.TransformIndices = 0x10 // TArray<int32_t> (Size: 0x10)
RecordedFrame.PreviousTransformIndices = 0x20 // TArray<int32_t> (Size: 0x10)
RecordedFrame.DisabledFlags = 0x30 // TArray<bool> (Size: 0x10)
RecordedFrame.Collisions = 0x40 // TArray<FSolverCollisionData> (Size: 0x10)
RecordedFrame.Breakings = 0x50 // TArray<FSolverBreakingData> (Size: 0x10)
RecordedFrame.Trailings = 0x60 // TSet<...> (Size: 0x50)
RecordedFrame.Timestamp = 0xb0 // float (Size: 0x4)
RecordedTransformTrack.Records = 0x0 // TArray<FRecordedFrame> (Size: 0x10)
SolverBreakingData.Location = 0x0 // FVector (Size: 0xc)
SolverBreakingData.Velocity = 0xc // FVector (Size: 0xc)
SolverBreakingData.AngularVelocity = 0x18 // FVector (Size: 0xc)
SolverBreakingData.Mass = 0x24 // float (Size: 0x4)
SolverBreakingData.ParticleIndex = 0x28 // int32_t (Size: 0x4)
SolverBreakingData.ParticleIndexMesh = 0x2c // int32_t (Size: 0x4)
SolverBreakingFilterSettings.FilterEnabled = 0x0 // bool (Size: 0x1)
SolverBreakingFilterSettings.MinMass = 0x4 // float (Size: 0x4)
SolverBreakingFilterSettings.MinSpeed = 0x8 // float (Size: 0x4)
SolverBreakingFilterSettings.MinVolume = 0xc // float (Size: 0x4)
SolverCollisionData.Location = 0x0 // FVector (Size: 0xc)
SolverCollisionData.AccumulatedImpulse = 0xc // FVector (Size: 0xc)
SolverCollisionData.Normal = 0x18 // FVector (Size: 0xc)
SolverCollisionData.Velocity1 = 0x24 // FVector (Size: 0xc)
SolverCollisionData.Velocity2 = 0x30 // FVector (Size: 0xc)
SolverCollisionData.AngularVelocity1 = 0x3c // FVector (Size: 0xc)
SolverCollisionData.AngularVelocity2 = 0x48 // FVector (Size: 0xc)
SolverCollisionData.Mass1 = 0x54 // float (Size: 0x4)
SolverCollisionData.Mass2 = 0x58 // float (Size: 0x4)
SolverCollisionData.ParticleIndex = 0x5c // int32_t (Size: 0x4)
SolverCollisionData.LevelsetIndex = 0x60 // int32_t (Size: 0x4)
SolverCollisionData.ParticleIndexMesh = 0x64 // int32_t (Size: 0x4)
SolverCollisionData.LevelsetIndexMesh = 0x68 // int32_t (Size: 0x4)
SolverCollisionFilterSettings.FilterEnabled = 0x0 // bool (Size: 0x1)
SolverCollisionFilterSettings.MinMass = 0x4 // float (Size: 0x4)
SolverCollisionFilterSettings.MinSpeed = 0x8 // float (Size: 0x4)
SolverCollisionFilterSettings.MinImpulse = 0xc // float (Size: 0x4)
SolverTrailingData.Location = 0x0 // FVector (Size: 0xc)
SolverTrailingData.Velocity = 0xc // FVector (Size: 0xc)
SolverTrailingData.AngularVelocity = 0x18 // FVector (Size: 0xc)
SolverTrailingData.Mass = 0x24 // float (Size: 0x4)
SolverTrailingData.ParticleIndex = 0x28 // int32_t (Size: 0x4)
SolverTrailingData.ParticleIndexMesh = 0x2c // int32_t (Size: 0x4)
SolverTrailingFilterSettings.FilterEnabled = 0x0 // bool (Size: 0x1)
SolverTrailingFilterSettings.MinMass = 0x4 // float (Size: 0x4)
SolverTrailingFilterSettings.MinSpeed = 0x8 // float (Size: 0x4)
SolverTrailingFilterSettings.MinVolume = 0xc // float (Size: 0x4)
ChaosBreakEvent.Component = 0x0 // PrimitiveComponent* (Size: 0x8)
ChaosBreakEvent.Location = 0x8 // FVector (Size: 0xc)
ChaosBreakEvent.Velocity = 0x14 // FVector (Size: 0xc)
ChaosBreakEvent.AngularVelocity = 0x20 // FVector (Size: 0xc)
ChaosBreakEvent.Mass = 0x2c // float (Size: 0x4)
ChaosDebugSubstepControl.bPause = 0x0 // bool (Size: 0x1)
ChaosDebugSubstepControl.bSubstep = 0x1 // bool (Size: 0x1)
ChaosDebugSubstepControl.bStep = 0x2 // bool (Size: 0x1)
ChaosGameplayEventDispatcher.CollisionEventRegistrations = 0x210 // TMap<...> (Size: 0x50)
ChaosGameplayEventDispatcher.BreakEventRegistrations = 0x260 // TMap<...> (Size: 0x50)
ChaosHandlerSet.ChaosHandlers = 0x8 // TSet<...> (Size: 0x50)
ChaosPhysicsCollisionInfo.Component = 0x0 // PrimitiveComponent* (Size: 0x8)
ChaosPhysicsCollisionInfo.OtherComponent = 0x8 // PrimitiveComponent* (Size: 0x8)
ChaosPhysicsCollisionInfo.Location = 0x10 // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.Normal = 0x1c // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.AccumulatedImpulse = 0x28 // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.Velocity = 0x34 // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.OtherVelocity = 0x40 // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.AngularVelocity = 0x4c // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.OtherAngularVelocity = 0x58 // FVector (Size: 0xc)
ChaosPhysicsCollisionInfo.Mass = 0x64 // float (Size: 0x4)
ChaosPhysicsCollisionInfo.OtherMass = 0x68 // float (Size: 0x4)
ChaosSolverActor.Properties = 0x310 // FChaosSolverConfiguration (Size: 0x68)
ChaosSolverActor.TimeStepMultiplier = 0x378 // float (Size: 0x4)
ChaosSolverActor.CollisionIterations = 0x37c // int32_t (Size: 0x4)
ChaosSolverActor.PushOutIterations = 0x380 // int32_t (Size: 0x4)
ChaosSolverActor.PushOutPairIterations = 0x384 // int32_t (Size: 0x4)
ChaosSolverActor.ClusterConnectionFactor = 0x388 // float (Size: 0x4)
ChaosSolverActor.ClusterUnionConnectionType = 0x38c // EEClusterConnectionTypeEnum (Size: 0x1)
ChaosSolverActor.DoGenerateCollisionData = 0x38d // bool (Size: 0x1)
ChaosSolverActor.CollisionFilterSettings = 0x390 // FSolverCollisionFilterSettings (Size: 0x10)
ChaosSolverActor.DoGenerateBreakingData = 0x3a0 // bool (Size: 0x1)
ChaosSolverActor.BreakingFilterSettings = 0x3a4 // FSolverBreakingFilterSettings (Size: 0x10)
ChaosSolverActor.DoGenerateTrailingData = 0x3b4 // bool (Size: 0x1)
ChaosSolverActor.TrailingFilterSettings = 0x3b8 // FSolverTrailingFilterSettings (Size: 0x10)
ChaosSolverActor.MassScale = 0x3c8 // float (Size: 0x4)
ChaosSolverActor.bGenerateContactGraph = 0x3cc // bool (Size: 0x1)
ChaosSolverActor.bHasFloor = 0x3cd // bool (Size: 0x1)
ChaosSolverActor.FloorHeight = 0x3d0 // float (Size: 0x4)
ChaosSolverActor.ChaosDebugSubstepControl = 0x3d4 // FChaosDebugSubstepControl (Size: 0x3)
ChaosSolverActor.SpriteComponent = 0x3d8 // BillboardComponent* (Size: 0x8)
ChaosSolverActor.GameplayEventDispatcherComponent = 0x3f8 // ChaosGameplayEventDispatcher* (Size: 0x8)
ChaosSolverSettings.DefaultChaosSolverActorClass = 0x40 // FSoftClassPath (Size: 0x18)
CameraFilmbackSettings.SensorWidth = 0x0 // float (Size: 0x4)
CameraFilmbackSettings.SensorHeight = 0x4 // float (Size: 0x4)
CameraFilmbackSettings.SensorAspectRatio = 0x8 // float (Size: 0x4)
CameraFocusSettings.FocusMethod = 0x0 // EECameraFocusMethod (Size: 0x1)
CameraFocusSettings.ManualFocusDistance = 0x4 // float (Size: 0x4)
CameraFocusSettings.TrackingFocusSettings = 0x8 // FCameraTrackingFocusSettings (Size: 0x38)
CameraFocusSettings.bDrawDebugFocusPlane = 0x40 // uint8_t (Size: 0x1)
CameraFocusSettings.DebugFocusPlaneColor = 0x44 // FColor (Size: 0x4)
CameraFocusSettings.bSmoothFocusChanges = 0x48 // uint8_t (Size: 0x1)
CameraFocusSettings.FocusSmoothingInterpSpeed = 0x4c // float (Size: 0x4)
CameraFocusSettings.FocusOffset = 0x50 // float (Size: 0x4)
CameraLensSettings.MinFocalLength = 0x0 // float (Size: 0x4)
CameraLensSettings.MaxFocalLength = 0x4 // float (Size: 0x4)
CameraLensSettings.MinFStop = 0x8 // float (Size: 0x4)
CameraLensSettings.MaxFStop = 0xc // float (Size: 0x4)
CameraLensSettings.MinimumFocusDistance = 0x10 // float (Size: 0x4)
CameraLensSettings.DiaphragmBladeCount = 0x14 // int32_t (Size: 0x4)
CameraLookatTrackingSettings.bEnableLookAtTracking = 0x0 // uint8_t (Size: 0x1)
CameraLookatTrackingSettings.bDrawDebugLookAtTrackingPosition = 0x0 // uint8_t (Size: 0x1)
CameraLookatTrackingSettings.LookAtTrackingInterpSpeed = 0x4 // float (Size: 0x4)
CameraLookatTrackingSettings.ActorToTrack = 0x18 // TSoftObjectPtr<UObject> (Size: 0x28)
CameraLookatTrackingSettings.RelativeOffset = 0x40 // FVector (Size: 0xc)
CameraLookatTrackingSettings.bAllowRoll = 0x4c // uint8_t (Size: 0x1)
CameraRig_Crane.CranePitch = 0x310 // float (Size: 0x4)
CameraRig_Crane.CraneYaw = 0x314 // float (Size: 0x4)
CameraRig_Crane.CraneArmLength = 0x318 // float (Size: 0x4)
CameraRig_Crane.bLockMountPitch = 0x31c // bool (Size: 0x1)
CameraRig_Crane.bLockMountYaw = 0x31d // bool (Size: 0x1)
CameraRig_Crane.TransformComponent = 0x320 // SceneComponent* (Size: 0x8)
CameraRig_Crane.CraneYawControl = 0x328 // SceneComponent* (Size: 0x8)
CameraRig_Crane.CranePitchControl = 0x330 // SceneComponent* (Size: 0x8)
CameraRig_Crane.CraneCameraMount = 0x338 // SceneComponent* (Size: 0x8)
CameraRig_Rail.CurrentPositionOnRail = 0x310 // float (Size: 0x4)
CameraRig_Rail.bLockOrientationToRail = 0x314 // bool (Size: 0x1)
CameraRig_Rail.TransformComponent = 0x318 // SceneComponent* (Size: 0x8)
CameraRig_Rail.RailSplineComponent = 0x320 // SplineComponent* (Size: 0x8)
CameraRig_Rail.RailCameraMount = 0x328 // SceneComponent* (Size: 0x8)
CameraTrackingFocusSettings.ActorToTrack = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
CameraTrackingFocusSettings.RelativeOffset = 0x28 // FVector (Size: 0xc)
CameraTrackingFocusSettings.bDrawDebugTrackingFocusPoint = 0x34 // uint8_t (Size: 0x1)
CineCameraActor.LookatTrackingSettings = 0x9d0 // FCameraLookatTrackingSettings (Size: 0x50)
CineCameraComponent.FilmbackSettings = 0x940 // FCameraFilmbackSettings (Size: 0xc)
CineCameraComponent.Filmback = 0x94c // FCameraFilmbackSettings (Size: 0xc)
CineCameraComponent.LensSettings = 0x958 // FCameraLensSettings (Size: 0x18)
CineCameraComponent.FocusSettings = 0x970 // FCameraFocusSettings (Size: 0x58)
CineCameraComponent.CurrentFocalLength = 0x9c8 // float (Size: 0x4)
CineCameraComponent.CurrentAperture = 0x9cc // float (Size: 0x4)
CineCameraComponent.CurrentFocusDistance = 0x9d0 // float (Size: 0x4)
CineCameraComponent.FilmbackPresets = 0x9e0 // TArray<FNamedFilmbackPreset> (Size: 0x10)
CineCameraComponent.LensPresets = 0x9f0 // TArray<FNamedLensPreset> (Size: 0x10)
CineCameraComponent.DefaultFilmbackPresetName = 0xa00 // FString (Size: 0x10)
CineCameraComponent.DefaultFilmbackPreset = 0xa10 // FString (Size: 0x10)
CineCameraComponent.DefaultLensPresetName = 0xa20 // FString (Size: 0x10)
CineCameraComponent.DefaultLensFocalLength = 0xa30 // float (Size: 0x4)
CineCameraComponent.DefaultLensFStop = 0xa34 // float (Size: 0x4)
NamedFilmbackPreset.Name = 0x0 // FString (Size: 0x10)
NamedFilmbackPreset.FilmbackSettings = 0x10 // FCameraFilmbackSettings (Size: 0xc)
NamedLensPreset.Name = 0x0 // FString (Size: 0x10)
NamedLensPreset.LensSettings = 0x10 // FCameraLensSettings (Size: 0x18)
ClothConfig_Legacy.WindMethod = 0x0 // EEClothingWindMethod_Legacy (Size: 0x1)
ClothConfig_Legacy.VerticalConstraintConfig = 0x4 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfig_Legacy.HorizontalConstraintConfig = 0x14 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfig_Legacy.BendConstraintConfig = 0x24 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfig_Legacy.ShearConstraintConfig = 0x34 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfig_Legacy.SelfCollisionRadius = 0x44 // float (Size: 0x4)
ClothConfig_Legacy.SelfCollisionStiffness = 0x48 // float (Size: 0x4)
ClothConfig_Legacy.SelfCollisionCullScale = 0x4c // float (Size: 0x4)
ClothConfig_Legacy.Damping = 0x50 // FVector (Size: 0xc)
ClothConfig_Legacy.Friction = 0x5c // float (Size: 0x4)
ClothConfig_Legacy.WindDragCoefficient = 0x60 // float (Size: 0x4)
ClothConfig_Legacy.WindLiftCoefficient = 0x64 // float (Size: 0x4)
ClothConfig_Legacy.LinearDrag = 0x68 // FVector (Size: 0xc)
ClothConfig_Legacy.AngularDrag = 0x74 // FVector (Size: 0xc)
ClothConfig_Legacy.LinearInertiaScale = 0x80 // FVector (Size: 0xc)
ClothConfig_Legacy.AngularInertiaScale = 0x8c // FVector (Size: 0xc)
ClothConfig_Legacy.CentrifugalInertiaScale = 0x98 // FVector (Size: 0xc)
ClothConfig_Legacy.SolverFrequency = 0xa4 // float (Size: 0x4)
ClothConfig_Legacy.StiffnessFrequency = 0xa8 // float (Size: 0x4)
ClothConfig_Legacy.GravityScale = 0xac // float (Size: 0x4)
ClothConfig_Legacy.GravityOverride = 0xb0 // FVector (Size: 0xc)
ClothConfig_Legacy.bUseGravityOverride = 0xbc // bool (Size: 0x1)
ClothConfig_Legacy.TetherStiffness = 0xc0 // float (Size: 0x4)
ClothConfig_Legacy.TetherLimit = 0xc4 // float (Size: 0x4)
ClothConfig_Legacy.CollisionThickness = 0xc8 // float (Size: 0x4)
ClothConfig_Legacy.AnimDriveSpringStiffness = 0xcc // float (Size: 0x4)
ClothConfig_Legacy.AnimDriveDamperStiffness = 0xd0 // float (Size: 0x4)
ClothConstraintSetup_Legacy.Stiffness = 0x0 // float (Size: 0x4)
ClothConstraintSetup_Legacy.StiffnessMultiplier = 0x4 // float (Size: 0x4)
ClothConstraintSetup_Legacy.StretchLimit = 0x8 // float (Size: 0x4)
ClothConstraintSetup_Legacy.CompressionLimit = 0xc // float (Size: 0x4)
ClothLODDataCommon.PhysicalMeshData = 0x0 // FClothPhysicalMeshData (Size: 0xf8)
ClothLODDataCommon.CollisionData = 0xf8 // FClothCollisionData (Size: 0x40)
ClothLODDataCommon.bUseMultipleInfluences = 0x138 // bool (Size: 0x1)
ClothLODDataCommon.SkinningKernelRadius = 0x13c // float (Size: 0x4)
ClothLODDataCommon_Legacy.PhysicalMeshData = 0x28 // ClothPhysicalMeshDataBase_Legacy* (Size: 0x8)
ClothLODDataCommon_Legacy.ClothPhysicalMeshData = 0x30 // FClothPhysicalMeshData (Size: 0xf8)
ClothLODDataCommon_Legacy.CollisionData = 0x128 // FClothCollisionData (Size: 0x40)
ClothParameterMask_Legacy.MaskName = 0x0 // FName (Size: 0x8)
ClothParameterMask_Legacy.CurrentTarget = 0x8 // EEWeightMapTargetCommon (Size: 0x1)
ClothParameterMask_Legacy.MaxValue = 0xc // float (Size: 0x4)
ClothParameterMask_Legacy.MinValue = 0x10 // float (Size: 0x4)
ClothParameterMask_Legacy.Values = 0x18 // TArray<float> (Size: 0x10)
ClothParameterMask_Legacy.bEnabled = 0x28 // bool (Size: 0x1)
ClothPhysicalMeshData.Vertices = 0x0 // TArray<FVector> (Size: 0x10)
ClothPhysicalMeshData.Normals = 0x10 // TArray<FVector> (Size: 0x10)
ClothPhysicalMeshData.Indices = 0x20 // TArray<uint32_t> (Size: 0x10)
ClothPhysicalMeshData.WeightMaps = 0x30 // TMap<...> (Size: 0x50)
ClothPhysicalMeshData.InverseMasses = 0x80 // TArray<float> (Size: 0x10)
ClothPhysicalMeshData.BoneData = 0x90 // TArray<FClothVertBoneData> (Size: 0x10)
ClothPhysicalMeshData.MaxBoneWeights = 0xa0 // int32_t (Size: 0x4)
ClothPhysicalMeshData.NumFixedVerts = 0xa4 // int32_t (Size: 0x4)
ClothPhysicalMeshData.SelfCollisionIndices = 0xa8 // TArray<uint32_t> (Size: 0x10)
ClothPhysicalMeshData.MaxDistances = 0xb8 // TArray<float> (Size: 0x10)
ClothPhysicalMeshData.BackstopDistances = 0xc8 // TArray<float> (Size: 0x10)
ClothPhysicalMeshData.BackstopRadiuses = 0xd8 // TArray<float> (Size: 0x10)
ClothPhysicalMeshData.AnimDriveMultipliers = 0xe8 // TArray<float> (Size: 0x10)
ClothingAssetCommon.PhysicsAsset = 0x48 // PhysicsAsset* (Size: 0x8)
ClothingAssetCommon.ClothConfigs = 0x50 // TMap<...> (Size: 0x50)
ClothingAssetCommon.ClothSharedSimConfig = 0xa0 // ClothConfigBase* (Size: 0x8)
ClothingAssetCommon.ClothSimConfig = 0xa8 // ClothConfigBase* (Size: 0x8)
ClothingAssetCommon.ChaosClothSimConfig = 0xb0 // ClothConfigBase* (Size: 0x8)
ClothingAssetCommon.ClothLODData = 0xb8 // TArray<ClothLODDataCommon_Legacy*> (Size: 0x10)
ClothingAssetCommon.LODData = 0xc8 // TArray<FClothLODDataCommon> (Size: 0x10)
ClothingAssetCommon.LodMap = 0xd8 // TArray<int32_t> (Size: 0x10)
ClothingAssetCommon.UsedBoneNames = 0xe8 // TArray<FName> (Size: 0x10)
ClothingAssetCommon.UsedBoneIndices = 0xf8 // TArray<int32_t> (Size: 0x10)
ClothingAssetCommon.ReferenceBoneIndex = 0x108 // int32_t (Size: 0x4)
ClothingAssetCommon.CustomData = 0x110 // ClothingAssetCustomData* (Size: 0x8)
ClothingAssetCommon.ClothConfig = 0x118 // FClothConfig_Legacy (Size: 0xd4)
PointWeightMap.Values = 0x0 // TArray<float> (Size: 0x10)
ClothCollisionData.Spheres = 0x0 // TArray<FClothCollisionPrim_Sphere> (Size: 0x10)
ClothCollisionData.SphereConnections = 0x10 // TArray<FClothCollisionPrim_SphereConnection> (Size: 0x10)
ClothCollisionData.Convexes = 0x20 // TArray<FClothCollisionPrim_Convex> (Size: 0x10)
ClothCollisionData.Boxes = 0x30 // TArray<FClothCollisionPrim_Box> (Size: 0x10)
ClothCollisionPrim_Box.LocalPosition = 0x0 // FVector (Size: 0xc)
ClothCollisionPrim_Box.LocalRotation = 0x10 // FQuat (Size: 0x10)
ClothCollisionPrim_Box.HalfExtents = 0x20 // FVector (Size: 0xc)
ClothCollisionPrim_Box.BoneIndex = 0x2c // int32_t (Size: 0x4)
ClothCollisionPrim_Convex.Planes = 0x0 // TArray<FPlane> (Size: 0x10)
ClothCollisionPrim_Convex.SurfacePoints = 0x10 // TArray<FVector> (Size: 0x10)
ClothCollisionPrim_Convex.BoneIndex = 0x20 // int32_t (Size: 0x4)
ClothCollisionPrim_Sphere.BoneIndex = 0x0 // int32_t (Size: 0x4)
ClothCollisionPrim_Sphere.Radius = 0x4 // float (Size: 0x4)
ClothCollisionPrim_Sphere.LocalPosition = 0x8 // FVector (Size: 0xc)
ClothCollisionPrim_SphereConnection.SphereIndices = 0x0 // int32_t (Size: 0x4)
ClothPhysicalMeshDataBase_Legacy.Vertices = 0x28 // TArray<FVector> (Size: 0x10)
ClothPhysicalMeshDataBase_Legacy.Normals = 0x38 // TArray<FVector> (Size: 0x10)
ClothPhysicalMeshDataBase_Legacy.Indices = 0x48 // TArray<uint32_t> (Size: 0x10)
ClothPhysicalMeshDataBase_Legacy.InverseMasses = 0x58 // TArray<float> (Size: 0x10)
ClothPhysicalMeshDataBase_Legacy.BoneData = 0x68 // TArray<FClothVertBoneData> (Size: 0x10)
ClothPhysicalMeshDataBase_Legacy.NumFixedVerts = 0x78 // int32_t (Size: 0x4)
ClothPhysicalMeshDataBase_Legacy.MaxBoneWeights = 0x7c // int32_t (Size: 0x4)
ClothPhysicalMeshDataBase_Legacy.SelfCollisionIndices = 0x80 // TArray<uint32_t> (Size: 0x10)
ClothVertBoneData.NumInfluences = 0x0 // int32_t (Size: 0x4)
ClothVertBoneData.BoneIndices = 0x4 // uint16_t (Size: 0x2)
ClothVertBoneData.BoneWeights = 0x1c // float (Size: 0x4)
ClothingAssetBase.ImportedFilePath = 0x28 // FString (Size: 0x10)
ClothingAssetBase.AssetGuid = 0x38 // FGuid (Size: 0x10)
ClothConfigNv.ClothingWindMethod = 0x28 // EEClothingWindMethodNv (Size: 0x1)
ClothConfigNv.VerticalConstraint = 0x2c // FClothConstraintSetupNv (Size: 0x10)
ClothConfigNv.HorizontalConstraint = 0x3c // FClothConstraintSetupNv (Size: 0x10)
ClothConfigNv.BendConstraint = 0x4c // FClothConstraintSetupNv (Size: 0x10)
ClothConfigNv.ShearConstraint = 0x5c // FClothConstraintSetupNv (Size: 0x10)
ClothConfigNv.SelfCollisionRadius = 0x6c // float (Size: 0x4)
ClothConfigNv.SelfCollisionStiffness = 0x70 // float (Size: 0x4)
ClothConfigNv.SelfCollisionCullScale = 0x74 // float (Size: 0x4)
ClothConfigNv.Damping = 0x78 // FVector (Size: 0xc)
ClothConfigNv.Friction = 0x84 // float (Size: 0x4)
ClothConfigNv.WindDragCoefficient = 0x88 // float (Size: 0x4)
ClothConfigNv.WindLiftCoefficient = 0x8c // float (Size: 0x4)
ClothConfigNv.LinearDrag = 0x90 // FVector (Size: 0xc)
ClothConfigNv.AngularDrag = 0x9c // FVector (Size: 0xc)
ClothConfigNv.LinearInertiaScale = 0xa8 // FVector (Size: 0xc)
ClothConfigNv.AngularInertiaScale = 0xb4 // FVector (Size: 0xc)
ClothConfigNv.CentrifugalInertiaScale = 0xc0 // FVector (Size: 0xc)
ClothConfigNv.SolverFrequency = 0xcc // float (Size: 0x4)
ClothConfigNv.StiffnessFrequency = 0xd0 // float (Size: 0x4)
ClothConfigNv.GravityScale = 0xd4 // float (Size: 0x4)
ClothConfigNv.GravityOverride = 0xd8 // FVector (Size: 0xc)
ClothConfigNv.bUseGravityOverride = 0xe4 // bool (Size: 0x1)
ClothConfigNv.TetherStiffness = 0xe8 // float (Size: 0x4)
ClothConfigNv.TetherLimit = 0xec // float (Size: 0x4)
ClothConfigNv.CollisionThickness = 0xf0 // float (Size: 0x4)
ClothConfigNv.AnimDriveSpringStiffness = 0xf4 // float (Size: 0x4)
ClothConfigNv.AnimDriveDamperStiffness = 0xf8 // float (Size: 0x4)
ClothConfigNv.WindMethod = 0xfc // EEClothingWindMethod_Legacy (Size: 0x1)
ClothConfigNv.VerticalConstraintConfig = 0x100 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfigNv.HorizontalConstraintConfig = 0x110 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfigNv.BendConstraintConfig = 0x120 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConfigNv.ShearConstraintConfig = 0x130 // FClothConstraintSetup_Legacy (Size: 0x10)
ClothConstraintSetupNv.Stiffness = 0x0 // float (Size: 0x4)
ClothConstraintSetupNv.StiffnessMultiplier = 0x4 // float (Size: 0x4)
ClothConstraintSetupNv.StretchLimit = 0x8 // float (Size: 0x4)
ClothConstraintSetupNv.CompressionLimit = 0xc // float (Size: 0x4)
ClothPhysicalMeshDataNv_Legacy.MaxDistances = 0xe0 // TArray<float> (Size: 0x10)
ClothPhysicalMeshDataNv_Legacy.BackstopDistances = 0xf0 // TArray<float> (Size: 0x10)
ClothPhysicalMeshDataNv_Legacy.BackstopRadiuses = 0x100 // TArray<float> (Size: 0x10)
ClothPhysicalMeshDataNv_Legacy.AnimDriveMultipliers = 0x110 // TArray<float> (Size: 0x10)
AimTarget.Weight = 0x0 // float (Size: 0x4)
AimTarget.Transform = 0x10 // FTransform (Size: 0x30)
AimTarget.AlignVector = 0x40 // FVector (Size: 0xc)
AnimNode_ControlRig.ControlRigClass = 0x170 // ClassProperty (Size: 0x8)
AnimNode_ControlRig.ControlRig = 0x178 // ControlRig* (Size: 0x8)
AnimNode_ControlRig.Alpha = 0x180 // float (Size: 0x4)
AnimNode_ControlRig.AlphaInputType = 0x184 // EEAnimAlphaInputType (Size: 0x1)
AnimNode_ControlRig.bAlphaBoolEnabled = 0x185 // uint8_t (Size: 0x1)
AnimNode_ControlRig.bSetRefPoseFromSkeleton = 0x185 // uint8_t (Size: 0x1)
AnimNode_ControlRig.AlphaScaleBias = 0x188 // FInputScaleBias (Size: 0x8)
AnimNode_ControlRig.AlphaBoolBlend = 0x190 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_ControlRig.AlphaCurveName = 0x1d8 // FName (Size: 0x8)
AnimNode_ControlRig.AlphaScaleBiasClamp = 0x1e0 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_ControlRig.InputMapping = 0x210 // TMap<...> (Size: 0x50)
AnimNode_ControlRig.OutputMapping = 0x260 // TMap<...> (Size: 0x50)
AnimNode_ControlRig.LODThreshold = 0x360 // int32_t (Size: 0x4)
AnimNode_ControlRigBase.Source = 0x58 // FPoseLink (Size: 0x10)
AnimNode_ControlRigBase.ControlRigBoneMapping = 0x68 // TMap<...> (Size: 0x50)
AnimNode_ControlRigBase.ControlRigCurveMapping = 0xb8 // TMap<...> (Size: 0x50)
AnimNode_ControlRigBase.InputToCurveMappingUIDs = 0x108 // TMap<...> (Size: 0x50)
AnimNode_ControlRigBase.NodeMappingContainer = 0x158 // TWeakObjectPtr<UObject> (Size: 0x8)
AnimNode_ControlRigBase.InputSettings = 0x160 // FControlRigIOSettings (Size: 0x2)
AnimNode_ControlRigBase.OutputSettings = 0x162 // FControlRigIOSettings (Size: 0x2)
AnimNode_ControlRigBase.bExecute = 0x164 // bool (Size: 0x1)
AnimNode_ControlRigInputPose.InputPose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ControlRig_ExternalSource.ControlRig = 0x170 // TWeakObjectPtr<UObject> (Size: 0x8)
AnimationHierarchy.UserData = 0x78 // TArray<FConstraintNodeData> (Size: 0x10)
BlendTarget.Transform = 0x0 // FTransform (Size: 0x30)
BlendTarget.Weight = 0x30 // float (Size: 0x4)
CRFourPointBezier.A = 0x0 // FVector (Size: 0xc)
CRFourPointBezier.B = 0xc // FVector (Size: 0xc)
CRFourPointBezier.C = 0x18 // FVector (Size: 0xc)
CRFourPointBezier.D = 0x24 // FVector (Size: 0xc)
CRSimContainer.TimeStep = 0x8 // float (Size: 0x4)
CRSimContainer.AccumulatedTime = 0xc // float (Size: 0x4)
CRSimContainer.TimeLeftForStep = 0x10 // float (Size: 0x4)
CRSimLinearSpring.SubjectA = 0x0 // int32_t (Size: 0x4)
CRSimLinearSpring.SubjectB = 0x4 // int32_t (Size: 0x4)
CRSimLinearSpring.Coefficient = 0x8 // float (Size: 0x4)
CRSimLinearSpring.Equilibrium = 0xc // float (Size: 0x4)
CRSimPoint.Mass = 0x0 // float (Size: 0x4)
CRSimPoint.Size = 0x4 // float (Size: 0x4)
CRSimPoint.LinearDamping = 0x8 // float (Size: 0x4)
CRSimPoint.InheritMotion = 0xc // float (Size: 0x4)
CRSimPoint.position = 0x10 // FVector (Size: 0xc)
CRSimPoint.LinearVelocity = 0x1c // FVector (Size: 0xc)
CRSimPointConstraint.Type = 0x0 // EECRSimConstraintType (Size: 0x1)
CRSimPointConstraint.SubjectA = 0x4 // int32_t (Size: 0x4)
CRSimPointConstraint.SubjectB = 0x8 // int32_t (Size: 0x4)
CRSimPointConstraint.DataA = 0xc // FVector (Size: 0xc)
CRSimPointConstraint.DataB = 0x18 // FVector (Size: 0xc)
CRSimPointContainer.Points = 0x18 // TArray<FCRSimPoint> (Size: 0x10)
CRSimPointContainer.Springs = 0x28 // TArray<FCRSimLinearSpring> (Size: 0x10)
CRSimPointContainer.Forces = 0x38 // TArray<FCRSimPointForce> (Size: 0x10)
CRSimPointContainer.CollisionVolumes = 0x48 // TArray<FCRSimSoftCollision> (Size: 0x10)
CRSimPointContainer.Constraints = 0x58 // TArray<FCRSimPointConstraint> (Size: 0x10)
CRSimPointContainer.PreviousStep = 0x68 // TArray<FCRSimPoint> (Size: 0x10)
CRSimPointForce.ForceType = 0x0 // EECRSimPointForceType (Size: 0x1)
CRSimPointForce.Vector = 0x4 // FVector (Size: 0xc)
CRSimPointForce.Coefficient = 0x10 // float (Size: 0x4)
CRSimPointForce.bNormalize = 0x14 // bool (Size: 0x1)
CRSimSoftCollision.Transform = 0x0 // FTransform (Size: 0x30)
CRSimSoftCollision.ShapeType = 0x30 // EECRSimSoftCollisionType (Size: 0x1)
CRSimSoftCollision.MinimumDistance = 0x34 // float (Size: 0x4)
CRSimSoftCollision.MaximumDistance = 0x38 // float (Size: 0x4)
CRSimSoftCollision.FalloffType = 0x3c // EEControlRigAnimEasingType (Size: 0x1)
CRSimSoftCollision.Coefficient = 0x40 // float (Size: 0x4)
CRSimSoftCollision.bInverted = 0x44 // bool (Size: 0x1)
CachedRigElement.Key = 0x0 // FRigElementKey (Size: 0xc)
CachedRigElement.Index = 0xc // uint16_t (Size: 0x2)
CachedRigElement.ContainerVersion = 0x10 // int32_t (Size: 0x4)
ChannelMapInfo.ControlIndex = 0x0 // int32_t (Size: 0x4)
ChannelMapInfo.TotalChannelIndex = 0x4 // int32_t (Size: 0x4)
ChannelMapInfo.ChannelIndex = 0x8 // int32_t (Size: 0x4)
ChannelMapInfo.ParentControlIndex = 0xc // int32_t (Size: 0x4)
ChannelMapInfo.ChannelTypeName = 0x10 // FName (Size: 0x8)
ConstraintNodeData.RelativeParent = 0x0 // FTransform (Size: 0x30)
ConstraintNodeData.ConstraintOffset = 0x30 // FConstraintOffset (Size: 0x60)
ConstraintNodeData.LinkedNode = 0x90 // FName (Size: 0x8)
ConstraintNodeData.Constraints = 0x98 // TArray<FTransformConstraint> (Size: 0x10)
ConstraintTarget.Transform = 0x0 // FTransform (Size: 0x30)
ConstraintTarget.Weight = 0x30 // float (Size: 0x4)
ConstraintTarget.bMaintainOffset = 0x34 // bool (Size: 0x1)
ConstraintTarget.Filter = 0x35 // FTransformFilter (Size: 0x9)
ControlRig.ExecutionType = 0x45 // EERigExecutionType (Size: 0x1)
ControlRig.VM = 0x48 // RigVM* (Size: 0x8)
ControlRig.Hierarchy = 0x50 // FRigHierarchyContainer (Size: 0x368)
ControlRig.GizmoLibrary = 0x3b8 // TSoftObjectPtr<UObject> (Size: 0x28)
ControlRig.InputProperties = 0x3f0 // TMap<...> (Size: 0x50)
ControlRig.OutputProperties = 0x440 // TMap<...> (Size: 0x50)
ControlRig.DrawContainer = 0x490 // FControlRigDrawContainer (Size: 0x18)
ControlRig.DataSourceRegistry = 0x4c0 // AnimationDataSourceRegistry* (Size: 0x8)
ControlRig.EventQueue = 0x4c8 // TArray<FName> (Size: 0x10)
ControlRig.Influences = 0x550 // FRigInfluenceMapPerEvent (Size: 0x60)
ControlRig.InteractionRig = 0x5b0 // ControlRig* (Size: 0x8)
ControlRig.InteractionRigClass = 0x5b8 // ClassProperty (Size: 0x8)
ControlRig.AssetUserData = 0x5c0 // TArray<AssetUserData*> (Size: 0x10)
ControlRigComponent.ControlRigClass = 0x5c8 // ClassProperty (Size: 0x8)
ControlRigComponent.OnPostInitializeDelegate = 0x5d0 // FMulticastInlineDelegate (Size: 0x10)
ControlRigComponent.OnPreSetupDelegate = 0x5e0 // FMulticastInlineDelegate (Size: 0x10)
ControlRigComponent.OnPostSetupDelegate = 0x5f0 // FMulticastInlineDelegate (Size: 0x10)
ControlRigComponent.OnPreUpdateDelegate = 0x600 // FMulticastInlineDelegate (Size: 0x10)
ControlRigComponent.OnPostUpdateDelegate = 0x610 // FMulticastInlineDelegate (Size: 0x10)
ControlRigComponent.MappedElements = 0x620 // TArray<FControlRigComponentMappedElement> (Size: 0x10)
ControlRigComponent.bResetTransformBeforeTick = 0x630 // bool (Size: 0x1)
ControlRigComponent.bResetInitialsBeforeSetup = 0x631 // bool (Size: 0x1)
ControlRigComponent.bUpdateRigOnTick = 0x632 // bool (Size: 0x1)
ControlRigComponent.bUpdateInEditor = 0x633 // bool (Size: 0x1)
ControlRigComponent.bDrawBones = 0x634 // bool (Size: 0x1)
ControlRigComponent.ControlRig = 0x638 // ControlRig* (Size: 0x8)
ControlRigComponentMappedBone.Source = 0x0 // FName (Size: 0x8)
ControlRigComponentMappedBone.Target = 0x8 // FName (Size: 0x8)
ControlRigComponentMappedComponent.Component = 0x0 // SceneComponent* (Size: 0x8)
ControlRigComponentMappedComponent.ElementName = 0x8 // FName (Size: 0x8)
ControlRigComponentMappedComponent.ElementType = 0x10 // EERigElementType (Size: 0x1)
ControlRigComponentMappedComponent.Direction = 0x11 // EEControlRigComponentMapDirection (Size: 0x1)
ControlRigComponentMappedCurve.Source = 0x0 // FName (Size: 0x8)
ControlRigComponentMappedCurve.Target = 0x8 // FName (Size: 0x8)
ControlRigComponentMappedElement.ComponentReference = 0x0 // FComponentReference (Size: 0x28)
ControlRigComponentMappedElement.TransformIndex = 0x28 // int32_t (Size: 0x4)
ControlRigComponentMappedElement.TransformName = 0x2c // FName (Size: 0x8)
ControlRigComponentMappedElement.ElementType = 0x34 // EERigElementType (Size: 0x1)
ControlRigComponentMappedElement.ElementName = 0x38 // FName (Size: 0x8)
ControlRigComponentMappedElement.Direction = 0x40 // EEControlRigComponentMapDirection (Size: 0x1)
ControlRigComponentMappedElement.Offset = 0x50 // FTransform (Size: 0x30)
ControlRigComponentMappedElement.Weight = 0x80 // float (Size: 0x4)
ControlRigComponentMappedElement.Space = 0x84 // EEControlRigComponentSpace (Size: 0x1)
ControlRigComponentMappedElement.SceneComponent = 0x88 // SceneComponent* (Size: 0x8)
ControlRigComponentMappedElement.ElementIndex = 0x90 // int32_t (Size: 0x4)
ControlRigComponentMappedElement.SubIndex = 0x94 // int32_t (Size: 0x4)
ControlRigControlActor.ActorToTrack = 0x310 // Actor* (Size: 0x8)
ControlRigControlActor.ControlRigClass = 0x318 // ClassProperty (Size: 0x8)
ControlRigControlActor.bRefreshOnTick = 0x320 // bool (Size: 0x1)
ControlRigControlActor.bIsSelectable = 0x321 // bool (Size: 0x1)
ControlRigControlActor.MaterialOverride = 0x328 // MaterialInterface* (Size: 0x8)
ControlRigControlActor.ColorParameter = 0x330 // FString (Size: 0x10)
ControlRigControlActor.bCastShadows = 0x340 // bool (Size: 0x1)
ControlRigControlActor.ActorRootComponent = 0x348 // SceneComponent* (Size: 0x8)
ControlRigControlActor.ControlRig = 0x350 // ControlRig* (Size: 0x8)
ControlRigControlActor.ControlNames = 0x358 // TArray<FName> (Size: 0x10)
ControlRigControlActor.GizmoTransforms = 0x368 // TArray<FTransform> (Size: 0x10)
ControlRigControlActor.Components = 0x378 // TArray<StaticMeshComponent*> (Size: 0x10)
ControlRigControlActor.Materials = 0x388 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
ControlRigControlActor.ColorParameterName = 0x398 // FName (Size: 0x8)
ControlRigDrawContainer.Instructions = 0x8 // TArray<FControlRigDrawInstruction> (Size: 0x10)
ControlRigDrawInstruction.Name = 0x0 // FName (Size: 0x8)
ControlRigDrawInstruction.PrimitiveType = 0x8 // uint8_t (Size: 0x1)
ControlRigDrawInstruction.Positions = 0x10 // TArray<FVector> (Size: 0x10)
ControlRigDrawInstruction.Color = 0x20 // FLinearColor (Size: 0x10)
ControlRigDrawInstruction.Thickness = 0x30 // float (Size: 0x4)
ControlRigDrawInstruction.Transform = 0x40 // FTransform (Size: 0x30)
ControlRigGizmoActor.ActorRootComponent = 0x310 // SceneComponent* (Size: 0x8)
ControlRigGizmoActor.StaticMeshComponent = 0x318 // StaticMeshComponent* (Size: 0x8)
ControlRigGizmoActor.ControlRigIndex = 0x320 // uint32_t (Size: 0x4)
ControlRigGizmoActor.ControlName = 0x324 // FName (Size: 0x8)
ControlRigGizmoActor.ColorParameterName = 0x32c // FName (Size: 0x8)
ControlRigGizmoActor.bEnabled = 0x334 // uint8_t (Size: 0x1)
ControlRigGizmoActor.bSelected = 0x334 // uint8_t (Size: 0x1)
ControlRigGizmoActor.bSelectable = 0x334 // uint8_t (Size: 0x1)
ControlRigGizmoActor.bHovered = 0x334 // uint8_t (Size: 0x1)
ControlRigGizmoDefinition.GizmoName = 0x0 // FName (Size: 0x8)
ControlRigGizmoDefinition.StaticMesh = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
ControlRigGizmoDefinition.Transform = 0x30 // FTransform (Size: 0x30)
ControlRigGizmoLibrary.DefaultGizmo = 0x30 // FControlRigGizmoDefinition (Size: 0x60)
ControlRigGizmoLibrary.DefaultMaterial = 0x90 // TSoftObjectPtr<UObject> (Size: 0x28)
ControlRigGizmoLibrary.MaterialColorParameter = 0xb8 // FName (Size: 0x8)
ControlRigGizmoLibrary.Gizmos = 0xc0 // TArray<FControlRigGizmoDefinition> (Size: 0x10)
ControlRigIOSettings.bUpdatePose = 0x0 // bool (Size: 0x1)
ControlRigIOSettings.bUpdateCurves = 0x1 // bool (Size: 0x1)
ControlRigNumericalValidationPass.bCheckControls = 0x28 // bool (Size: 0x1)
ControlRigNumericalValidationPass.bCheckBones = 0x29 // bool (Size: 0x1)
ControlRigNumericalValidationPass.bCheckCurves = 0x2a // bool (Size: 0x1)
ControlRigNumericalValidationPass.TranslationPrecision = 0x2c // float (Size: 0x4)
ControlRigNumericalValidationPass.RotationPrecision = 0x30 // float (Size: 0x4)
ControlRigNumericalValidationPass.ScalePrecision = 0x34 // float (Size: 0x4)
ControlRigNumericalValidationPass.CurvePrecision = 0x38 // float (Size: 0x4)
ControlRigNumericalValidationPass.EventNameA = 0x3c // FName (Size: 0x8)
ControlRigNumericalValidationPass.EventNameB = 0x44 // FName (Size: 0x8)
ControlRigNumericalValidationPass.pose = 0x50 // FRigPose (Size: 0x10)
ControlRigObjectHolder.Objects = 0x28 // TArray<Object*> (Size: 0x10)
ControlRigSequence.LastExportedToAnimationSequence = 0x1c8 // TSoftObjectPtr<UObject> (Size: 0x28)
ControlRigSequence.LastExportedUsingSkeletalMesh = 0x1f0 // TSoftObjectPtr<UObject> (Size: 0x28)
ControlRigSequence.LastExportedFrameRate = 0x218 // float (Size: 0x4)
ControlRigSequenceObjectReference.ControlRigClass = 0x0 // ClassProperty (Size: 0x8)
ControlRigSequenceObjectReferenceMap.BindingIds = 0x0 // TArray<FGuid> (Size: 0x10)
ControlRigSequenceObjectReferenceMap.References = 0x10 // TArray<FControlRigSequenceObjectReferences> (Size: 0x10)
ControlRigSequenceObjectReferences.Array = 0x0 // TArray<FControlRigSequenceObjectReference> (Size: 0x10)
ControlRigSettingsPerPinBool.Values = 0x0 // TMap<...> (Size: 0x50)
ControlRigValidator.Passes = 0x28 // TArray<ControlRigValidationPass*> (Size: 0x10)
EnumParameterNameAndCurve.ParameterName = 0x0 // FName (Size: 0x8)
EnumParameterNameAndCurve.ParameterCurve = 0x8 // FMovieSceneByteChannel (Size: 0x98)
FKControlRig.IsControlActive = 0x650 // TArray<bool> (Size: 0x10)
FKControlRig.ApplyMode = 0x660 // EEControlRigFKRigExecuteMode (Size: 0x1)
IntegerParameterNameAndCurve.ParameterName = 0x0 // FName (Size: 0x8)
IntegerParameterNameAndCurve.ParameterCurve = 0x8 // FMovieSceneIntegerChannel (Size: 0x90)
MathRBFInterpolateQuatColor_Target.Target = 0x0 // FQuat (Size: 0x10)
MathRBFInterpolateQuatColor_Target.Value = 0x10 // FLinearColor (Size: 0x10)
MathRBFInterpolateQuatFloat_Target.Target = 0x0 // FQuat (Size: 0x10)
MathRBFInterpolateQuatFloat_Target.Value = 0x10 // float (Size: 0x4)
MathRBFInterpolateQuatQuat_Target.Target = 0x0 // FQuat (Size: 0x10)
MathRBFInterpolateQuatQuat_Target.Value = 0x10 // FQuat (Size: 0x10)
MathRBFInterpolateQuatVector_Target.Target = 0x0 // FQuat (Size: 0x10)
MathRBFInterpolateQuatVector_Target.Value = 0x10 // FVector (Size: 0xc)
MathRBFInterpolateQuatXform_Target.Target = 0x0 // FQuat (Size: 0x10)
MathRBFInterpolateQuatXform_Target.Value = 0x10 // FTransform (Size: 0x30)
MathRBFInterpolateVectorColor_Target.Target = 0x0 // FVector (Size: 0xc)
MathRBFInterpolateVectorColor_Target.Value = 0xc // FLinearColor (Size: 0x10)
MathRBFInterpolateVectorFloat_Target.Target = 0x0 // FVector (Size: 0xc)
MathRBFInterpolateVectorFloat_Target.Value = 0xc // float (Size: 0x4)
MathRBFInterpolateVectorQuat_Target.Target = 0x0 // FVector (Size: 0xc)
MathRBFInterpolateVectorQuat_Target.Value = 0x10 // FQuat (Size: 0x10)
MathRBFInterpolateVectorVector_Target.Target = 0x0 // FVector (Size: 0xc)
MathRBFInterpolateVectorVector_Target.Value = 0xc // FVector (Size: 0xc)
MathRBFInterpolateVectorXform_Target.Target = 0x0 // FVector (Size: 0xc)
MathRBFInterpolateVectorXform_Target.Value = 0x10 // FTransform (Size: 0x30)
MovieSceneControlRigInstanceData.bAdditive = 0x8 // bool (Size: 0x1)
MovieSceneControlRigInstanceData.bApplyBoneFilter = 0x9 // bool (Size: 0x1)
MovieSceneControlRigInstanceData.BoneFilter = 0x10 // FInputBlendPose (Size: 0x10)
MovieSceneControlRigInstanceData.Weight = 0x20 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneControlRigInstanceData.Operand = 0xc0 // FMovieSceneEvaluationOperand (Size: 0x14)
MovieSceneControlRigParameterSection.ControlRig = 0x148 // ControlRig* (Size: 0x8)
MovieSceneControlRigParameterSection.ControlsMask = 0x150 // TArray<bool> (Size: 0x10)
MovieSceneControlRigParameterSection.TransformMask = 0x160 // FMovieSceneTransformMask (Size: 0x4)
MovieSceneControlRigParameterSection.bAdditive = 0x164 // bool (Size: 0x1)
MovieSceneControlRigParameterSection.bApplyBoneFilter = 0x165 // bool (Size: 0x1)
MovieSceneControlRigParameterSection.BoneFilter = 0x168 // FInputBlendPose (Size: 0x10)
MovieSceneControlRigParameterSection.Weight = 0x178 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneControlRigParameterSection.ControlChannelMap = 0x218 // TMap<...> (Size: 0x50)
MovieSceneControlRigParameterSection.EnumParameterNamesAndCurves = 0x268 // TArray<FEnumParameterNameAndCurve> (Size: 0x10)
MovieSceneControlRigParameterSection.IntegerParameterNamesAndCurves = 0x278 // TArray<FIntegerParameterNameAndCurve> (Size: 0x10)
MovieSceneControlRigParameterTemplate.Enums = 0x80 // TArray<FEnumParameterNameAndCurve> (Size: 0x10)
MovieSceneControlRigParameterTemplate.Integers = 0x90 // TArray<FIntegerParameterNameAndCurve> (Size: 0x10)
MovieSceneControlRigParameterTrack.ControlRig = 0x88 // ControlRig* (Size: 0x8)
MovieSceneControlRigParameterTrack.SectionToKey = 0x90 // MovieSceneSection* (Size: 0x8)
MovieSceneControlRigParameterTrack.Sections = 0x98 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneControlRigParameterTrack.TrackName = 0xa8 // FName (Size: 0x8)
RigBone.ParentName = 0x18 // FName (Size: 0x8)
RigBone.ParentIndex = 0x20 // int32_t (Size: 0x4)
RigBone.InitialTransform = 0x30 // FTransform (Size: 0x30)
RigBone.GlobalTransform = 0x60 // FTransform (Size: 0x30)
RigBone.LocalTransform = 0x90 // FTransform (Size: 0x30)
RigBone.Dependents = 0xc0 // TArray<int32_t> (Size: 0x10)
RigBone.Type = 0xd0 // EERigBoneType (Size: 0x1)
RigBoneHierarchy.Bones = 0x20 // TArray<FRigBone> (Size: 0x10)
RigBoneHierarchy.NameToIndexMapping = 0x30 // TMap<...> (Size: 0x50)
RigBoneHierarchy.Selection = 0x80 // TArray<FName> (Size: 0x10)
RigControl.ControlType = 0x18 // EERigControlType (Size: 0x1)
RigControl.DisplayName = 0x1c // FName (Size: 0x8)
RigControl.ParentName = 0x24 // FName (Size: 0x8)
RigControl.ParentIndex = 0x2c // int32_t (Size: 0x4)
RigControl.SpaceName = 0x30 // FName (Size: 0x8)
RigControl.SpaceIndex = 0x38 // int32_t (Size: 0x4)
RigControl.OffsetTransform = 0x40 // FTransform (Size: 0x30)
RigControl.InitialValue = 0x70 // FRigControlValue (Size: 0x80)
RigControl.Value = 0xf0 // FRigControlValue (Size: 0x80)
RigControl.PrimaryAxis = 0x170 // EERigControlAxis (Size: 0x1)
RigControl.bIsCurve = 0x171 // bool (Size: 0x1)
RigControl.bAnimatable = 0x172 // bool (Size: 0x1)
RigControl.bLimitTranslation = 0x173 // bool (Size: 0x1)
RigControl.bLimitRotation = 0x174 // bool (Size: 0x1)
RigControl.bLimitScale = 0x175 // bool (Size: 0x1)
RigControl.bDrawLimits = 0x176 // bool (Size: 0x1)
RigControl.MinimumValue = 0x180 // FRigControlValue (Size: 0x80)
RigControl.MaximumValue = 0x200 // FRigControlValue (Size: 0x80)
RigControl.bGizmoEnabled = 0x280 // bool (Size: 0x1)
RigControl.bGizmoVisible = 0x281 // bool (Size: 0x1)
RigControl.GizmoName = 0x284 // FName (Size: 0x8)
RigControl.GizmoTransform = 0x290 // FTransform (Size: 0x30)
RigControl.GizmoColor = 0x2c0 // FLinearColor (Size: 0x10)
RigControl.Dependents = 0x2d0 // TArray<int32_t> (Size: 0x10)
RigControl.bIsTransientControl = 0x2e0 // bool (Size: 0x1)
RigControl.ControlEnum = 0x2e8 // Enum* (Size: 0x8)
RigControlHierarchy.Controls = 0x98 // TArray<FRigControl> (Size: 0x10)
RigControlHierarchy.NameToIndexMapping = 0xa8 // TMap<...> (Size: 0x50)
RigControlHierarchy.Selection = 0xf8 // TArray<FName> (Size: 0x10)
RigControlValue.FloatStorage = 0x0 // FRigControlValueStorage (Size: 0x44)
RigControlValue.Storage = 0x50 // FTransform (Size: 0x30)
RigControlValueStorage.Float00 = 0x0 // float (Size: 0x4)
RigControlValueStorage.Float01 = 0x4 // float (Size: 0x4)
RigControlValueStorage.Float02 = 0x8 // float (Size: 0x4)
RigControlValueStorage.Float03 = 0xc // float (Size: 0x4)
RigControlValueStorage.Float10 = 0x10 // float (Size: 0x4)
RigControlValueStorage.Float11 = 0x14 // float (Size: 0x4)
RigControlValueStorage.Float12 = 0x18 // float (Size: 0x4)
RigControlValueStorage.Float13 = 0x1c // float (Size: 0x4)
RigControlValueStorage.Float20 = 0x20 // float (Size: 0x4)
RigControlValueStorage.Float21 = 0x24 // float (Size: 0x4)
RigControlValueStorage.Float22 = 0x28 // float (Size: 0x4)
RigControlValueStorage.Float23 = 0x2c // float (Size: 0x4)
RigControlValueStorage.Float30 = 0x30 // float (Size: 0x4)
RigControlValueStorage.Float31 = 0x34 // float (Size: 0x4)
RigControlValueStorage.Float32 = 0x38 // float (Size: 0x4)
RigControlValueStorage.Float33 = 0x3c // float (Size: 0x4)
RigControlValueStorage.bValid = 0x40 // bool (Size: 0x1)
RigCurve.Value = 0x18 // float (Size: 0x4)
RigCurveContainer.Curves = 0x20 // TArray<FRigCurve> (Size: 0x10)
RigCurveContainer.NameToIndexMapping = 0x30 // TMap<...> (Size: 0x50)
RigCurveContainer.Selection = 0x80 // TArray<FName> (Size: 0x10)
RigElement.Name = 0x8 // FName (Size: 0x8)
RigElement.Index = 0x10 // int32_t (Size: 0x4)
RigElementKey.Type = 0x0 // EERigElementType (Size: 0x1)
RigElementKey.Name = 0x4 // FName (Size: 0x8)
RigHierarchyContainer.BoneHierarchy = 0x0 // FRigBoneHierarchy (Size: 0x98)
RigHierarchyContainer.SpaceHierarchy = 0x98 // FRigSpaceHierarchy (Size: 0x90)
RigHierarchyContainer.ControlHierarchy = 0x128 // FRigControlHierarchy (Size: 0x108)
RigHierarchyContainer.CurveContainer = 0x230 // FRigCurveContainer (Size: 0x98)
RigHierarchyContainer.Version = 0x2c8 // int32_t (Size: 0x4)
RigHierarchyCopyPasteContent.Types = 0x0 // TArray<EERigElementType> (Size: 0x10)
RigHierarchyCopyPasteContent.Contents = 0x10 // TArray<FString> (Size: 0x10)
RigHierarchyCopyPasteContent.LocalTransforms = 0x20 // TArray<FTransform> (Size: 0x10)
RigHierarchyCopyPasteContent.GlobalTransforms = 0x30 // TArray<FTransform> (Size: 0x10)
RigInfluenceEntry.Source = 0x0 // FRigElementKey (Size: 0xc)
RigInfluenceEntry.AffectedList = 0x10 // TArray<FRigElementKey> (Size: 0x10)
RigInfluenceEntryModifier.AffectedList = 0x0 // TArray<FRigElementKey> (Size: 0x10)
RigInfluenceMap.EventName = 0x0 // FName (Size: 0x8)
RigInfluenceMap.Entries = 0x8 // TArray<FRigInfluenceEntry> (Size: 0x10)
RigInfluenceMap.KeyToIndex = 0x18 // TMap<...> (Size: 0x50)
RigInfluenceMapPerEvent.Maps = 0x0 // TArray<FRigInfluenceMap> (Size: 0x10)
RigInfluenceMapPerEvent.EventToIndex = 0x10 // TMap<...> (Size: 0x50)
RigMirrorSettings.MirrorAxis = 0x0 // uint8_t (Size: 0x1)
RigMirrorSettings.AxisToFlip = 0x1 // uint8_t (Size: 0x1)
RigMirrorSettings.OldName = 0x8 // FString (Size: 0x10)
RigMirrorSettings.NewName = 0x18 // FString (Size: 0x10)
RigPose.Elements = 0x0 // TArray<FRigPoseElement> (Size: 0x10)
RigPoseElement.Index = 0x0 // FCachedRigElement (Size: 0x14)
RigPoseElement.GlobalTransform = 0x20 // FTransform (Size: 0x30)
RigPoseElement.LocalTransform = 0x50 // FTransform (Size: 0x30)
RigPoseElement.CurveValue = 0x80 // float (Size: 0x4)
RigSpace.SpaceType = 0x18 // EERigSpaceType (Size: 0x1)
RigSpace.ParentName = 0x1c // FName (Size: 0x8)
RigSpace.ParentIndex = 0x24 // int32_t (Size: 0x4)
RigSpace.InitialTransform = 0x30 // FTransform (Size: 0x30)
RigSpace.LocalTransform = 0x60 // FTransform (Size: 0x30)
RigSpaceHierarchy.Spaces = 0x20 // TArray<FRigSpace> (Size: 0x10)
RigSpaceHierarchy.NameToIndexMapping = 0x30 // TMap<...> (Size: 0x50)
RigSpaceHierarchy.Selection = 0x80 // TArray<FName> (Size: 0x10)
RigUnitMutable.ExecuteContext = 0x8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_AccumulateFloatAdd.Increment = 0x8 // float (Size: 0x4)
RigUnit_AccumulateFloatAdd.InitialValue = 0xc // float (Size: 0x4)
RigUnit_AccumulateFloatAdd.bIntegrateDeltaTime = 0x10 // bool (Size: 0x1)
RigUnit_AccumulateFloatAdd.Result = 0x14 // float (Size: 0x4)
RigUnit_AccumulateFloatAdd.AccumulatedValue = 0x18 // float (Size: 0x4)
RigUnit_AccumulateFloatLerp.TargetValue = 0x8 // float (Size: 0x4)
RigUnit_AccumulateFloatLerp.InitialValue = 0xc // float (Size: 0x4)
RigUnit_AccumulateFloatLerp.Blend = 0x10 // float (Size: 0x4)
RigUnit_AccumulateFloatLerp.bIntegrateDeltaTime = 0x14 // bool (Size: 0x1)
RigUnit_AccumulateFloatLerp.Result = 0x18 // float (Size: 0x4)
RigUnit_AccumulateFloatLerp.AccumulatedValue = 0x1c // float (Size: 0x4)
RigUnit_AccumulateFloatMul.Multiplier = 0x8 // float (Size: 0x4)
RigUnit_AccumulateFloatMul.InitialValue = 0xc // float (Size: 0x4)
RigUnit_AccumulateFloatMul.bIntegrateDeltaTime = 0x10 // bool (Size: 0x1)
RigUnit_AccumulateFloatMul.Result = 0x14 // float (Size: 0x4)
RigUnit_AccumulateFloatMul.AccumulatedValue = 0x18 // float (Size: 0x4)
RigUnit_AccumulateFloatRange.Value = 0x8 // float (Size: 0x4)
RigUnit_AccumulateFloatRange.Minimum = 0xc // float (Size: 0x4)
RigUnit_AccumulateFloatRange.Maximum = 0x10 // float (Size: 0x4)
RigUnit_AccumulateFloatRange.AccumulatedMinimum = 0x14 // float (Size: 0x4)
RigUnit_AccumulateFloatRange.AccumulatedMaximum = 0x18 // float (Size: 0x4)
RigUnit_AccumulateQuatLerp.TargetValue = 0x10 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatLerp.InitialValue = 0x20 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatLerp.Blend = 0x30 // float (Size: 0x4)
RigUnit_AccumulateQuatLerp.bIntegrateDeltaTime = 0x34 // bool (Size: 0x1)
RigUnit_AccumulateQuatLerp.Result = 0x40 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatLerp.AccumulatedValue = 0x50 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatMul.Multiplier = 0x10 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatMul.InitialValue = 0x20 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatMul.bFlipOrder = 0x30 // bool (Size: 0x1)
RigUnit_AccumulateQuatMul.bIntegrateDeltaTime = 0x31 // bool (Size: 0x1)
RigUnit_AccumulateQuatMul.Result = 0x40 // FQuat (Size: 0x10)
RigUnit_AccumulateQuatMul.AccumulatedValue = 0x50 // FQuat (Size: 0x10)
RigUnit_AccumulateTransformLerp.TargetValue = 0x10 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformLerp.InitialValue = 0x40 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformLerp.Blend = 0x70 // float (Size: 0x4)
RigUnit_AccumulateTransformLerp.bIntegrateDeltaTime = 0x74 // bool (Size: 0x1)
RigUnit_AccumulateTransformLerp.Result = 0x80 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformLerp.AccumulatedValue = 0xb0 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformMul.Multiplier = 0x10 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformMul.InitialValue = 0x40 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformMul.bFlipOrder = 0x70 // bool (Size: 0x1)
RigUnit_AccumulateTransformMul.bIntegrateDeltaTime = 0x71 // bool (Size: 0x1)
RigUnit_AccumulateTransformMul.Result = 0x80 // FTransform (Size: 0x30)
RigUnit_AccumulateTransformMul.AccumulatedValue = 0xb0 // FTransform (Size: 0x30)
RigUnit_AccumulateVectorAdd.Increment = 0x8 // FVector (Size: 0xc)
RigUnit_AccumulateVectorAdd.InitialValue = 0x14 // FVector (Size: 0xc)
RigUnit_AccumulateVectorAdd.bIntegrateDeltaTime = 0x20 // bool (Size: 0x1)
RigUnit_AccumulateVectorAdd.Result = 0x24 // FVector (Size: 0xc)
RigUnit_AccumulateVectorAdd.AccumulatedValue = 0x30 // FVector (Size: 0xc)
RigUnit_AccumulateVectorLerp.TargetValue = 0x8 // FVector (Size: 0xc)
RigUnit_AccumulateVectorLerp.InitialValue = 0x14 // FVector (Size: 0xc)
RigUnit_AccumulateVectorLerp.Blend = 0x20 // float (Size: 0x4)
RigUnit_AccumulateVectorLerp.bIntegrateDeltaTime = 0x24 // bool (Size: 0x1)
RigUnit_AccumulateVectorLerp.Result = 0x28 // FVector (Size: 0xc)
RigUnit_AccumulateVectorLerp.AccumulatedValue = 0x34 // FVector (Size: 0xc)
RigUnit_AccumulateVectorMul.Multiplier = 0x8 // FVector (Size: 0xc)
RigUnit_AccumulateVectorMul.InitialValue = 0x14 // FVector (Size: 0xc)
RigUnit_AccumulateVectorMul.bIntegrateDeltaTime = 0x20 // bool (Size: 0x1)
RigUnit_AccumulateVectorMul.Result = 0x24 // FVector (Size: 0xc)
RigUnit_AccumulateVectorMul.AccumulatedValue = 0x30 // FVector (Size: 0xc)
RigUnit_AccumulateVectorRange.Value = 0x8 // FVector (Size: 0xc)
RigUnit_AccumulateVectorRange.Minimum = 0x14 // FVector (Size: 0xc)
RigUnit_AccumulateVectorRange.Maximum = 0x20 // FVector (Size: 0xc)
RigUnit_AccumulateVectorRange.AccumulatedMinimum = 0x2c // FVector (Size: 0xc)
RigUnit_AccumulateVectorRange.AccumulatedMaximum = 0x38 // FVector (Size: 0xc)
RigUnit_AddBoneTransform.Bone = 0x68 // FName (Size: 0x8)
RigUnit_AddBoneTransform.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_AddBoneTransform.Weight = 0xa0 // float (Size: 0x4)
RigUnit_AddBoneTransform.bPostMultiply = 0xa4 // bool (Size: 0x1)
RigUnit_AddBoneTransform.bPropagateToChildren = 0xa5 // bool (Size: 0x1)
RigUnit_AddBoneTransform.CachedBone = 0xa8 // FCachedRigElement (Size: 0x14)
RigUnit_AimBone.Bone = 0x68 // FName (Size: 0x8)
RigUnit_AimBone.Primary = 0x70 // FRigUnit_AimBone_Target (Size: 0x28)
RigUnit_AimBone.Secondary = 0x98 // FRigUnit_AimBone_Target (Size: 0x28)
RigUnit_AimBone.Weight = 0xc0 // float (Size: 0x4)
RigUnit_AimBone.bPropagateToChildren = 0xc4 // bool (Size: 0x1)
RigUnit_AimBone.DebugSettings = 0xd0 // FRigUnit_AimBone_DebugSettings (Size: 0x40)
RigUnit_AimBone.CachedBoneIndex = 0x110 // FCachedRigElement (Size: 0x14)
RigUnit_AimBone.PrimaryCachedSpace = 0x124 // FCachedRigElement (Size: 0x14)
RigUnit_AimBone.SecondaryCachedSpace = 0x138 // FCachedRigElement (Size: 0x14)
RigUnit_AimBoneMath.InputTransform = 0x10 // FTransform (Size: 0x30)
RigUnit_AimBoneMath.Primary = 0x40 // FRigUnit_AimItem_Target (Size: 0x2c)
RigUnit_AimBoneMath.Secondary = 0x6c // FRigUnit_AimItem_Target (Size: 0x2c)
RigUnit_AimBoneMath.Weight = 0x98 // float (Size: 0x4)
RigUnit_AimBoneMath.Result = 0xa0 // FTransform (Size: 0x30)
RigUnit_AimBoneMath.DebugSettings = 0xd0 // FRigUnit_AimBone_DebugSettings (Size: 0x40)
RigUnit_AimBoneMath.PrimaryCachedSpace = 0x110 // FCachedRigElement (Size: 0x14)
RigUnit_AimBoneMath.SecondaryCachedSpace = 0x124 // FCachedRigElement (Size: 0x14)
RigUnit_AimBone_DebugSettings.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_AimBone_DebugSettings.Scale = 0x4 // float (Size: 0x4)
RigUnit_AimBone_DebugSettings.WorldOffset = 0x10 // FTransform (Size: 0x30)
RigUnit_AimBone_Target.Weight = 0x0 // float (Size: 0x4)
RigUnit_AimBone_Target.Axis = 0x4 // FVector (Size: 0xc)
RigUnit_AimBone_Target.Target = 0x10 // FVector (Size: 0xc)
RigUnit_AimBone_Target.Kind = 0x1c // EEControlRigVectorKind (Size: 0x1)
RigUnit_AimBone_Target.Space = 0x20 // FName (Size: 0x8)
RigUnit_AimConstraint.Joint = 0x68 // FName (Size: 0x8)
RigUnit_AimConstraint.AimMode = 0x70 // EEAimMode (Size: 0x1)
RigUnit_AimConstraint.UpMode = 0x71 // EEAimMode (Size: 0x1)
RigUnit_AimConstraint.AimVector = 0x74 // FVector (Size: 0xc)
RigUnit_AimConstraint.UpVector = 0x80 // FVector (Size: 0xc)
RigUnit_AimConstraint.AimTargets = 0x90 // TArray<FAimTarget> (Size: 0x10)
RigUnit_AimConstraint.UpTargets = 0xa0 // TArray<FAimTarget> (Size: 0x10)
RigUnit_AimConstraint.WorkData = 0xb0 // FRigUnit_AimConstraint_WorkData (Size: 0x10)
RigUnit_AimConstraint_WorkData.ConstraintData = 0x0 // TArray<FConstraintData> (Size: 0x10)
RigUnit_AimItem.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_AimItem.Primary = 0x74 // FRigUnit_AimItem_Target (Size: 0x2c)
RigUnit_AimItem.Secondary = 0xa0 // FRigUnit_AimItem_Target (Size: 0x2c)
RigUnit_AimItem.Weight = 0xcc // float (Size: 0x4)
RigUnit_AimItem.DebugSettings = 0xd0 // FRigUnit_AimBone_DebugSettings (Size: 0x40)
RigUnit_AimItem.CachedItem = 0x110 // FCachedRigElement (Size: 0x14)
RigUnit_AimItem.PrimaryCachedSpace = 0x124 // FCachedRigElement (Size: 0x14)
RigUnit_AimItem.SecondaryCachedSpace = 0x138 // FCachedRigElement (Size: 0x14)
RigUnit_AimItem_Target.Weight = 0x0 // float (Size: 0x4)
RigUnit_AimItem_Target.Axis = 0x4 // FVector (Size: 0xc)
RigUnit_AimItem_Target.Target = 0x10 // FVector (Size: 0xc)
RigUnit_AimItem_Target.Kind = 0x1c // EEControlRigVectorKind (Size: 0x1)
RigUnit_AimItem_Target.Space = 0x20 // FRigElementKey (Size: 0xc)
RigUnit_AlphaInterp.Value = 0x8 // float (Size: 0x4)
RigUnit_AlphaInterp.Scale = 0xc // float (Size: 0x4)
RigUnit_AlphaInterp.Bias = 0x10 // float (Size: 0x4)
RigUnit_AlphaInterp.bMapRange = 0x14 // bool (Size: 0x1)
RigUnit_AlphaInterp.InRange = 0x18 // FInputRange (Size: 0x8)
RigUnit_AlphaInterp.OutRange = 0x20 // FInputRange (Size: 0x8)
RigUnit_AlphaInterp.bClampResult = 0x28 // bool (Size: 0x1)
RigUnit_AlphaInterp.ClampMin = 0x2c // float (Size: 0x4)
RigUnit_AlphaInterp.ClampMax = 0x30 // float (Size: 0x4)
RigUnit_AlphaInterp.bInterpResult = 0x34 // bool (Size: 0x1)
RigUnit_AlphaInterp.InterpSpeedIncreasing = 0x38 // float (Size: 0x4)
RigUnit_AlphaInterp.InterpSpeedDecreasing = 0x3c // float (Size: 0x4)
RigUnit_AlphaInterp.Result = 0x40 // float (Size: 0x4)
RigUnit_AlphaInterp.ScaleBiasClamp = 0x44 // FInputScaleBiasClamp (Size: 0x30)
RigUnit_AlphaInterpVector.Value = 0x8 // FVector (Size: 0xc)
RigUnit_AlphaInterpVector.Scale = 0x14 // float (Size: 0x4)
RigUnit_AlphaInterpVector.Bias = 0x18 // float (Size: 0x4)
RigUnit_AlphaInterpVector.bMapRange = 0x1c // bool (Size: 0x1)
RigUnit_AlphaInterpVector.InRange = 0x20 // FInputRange (Size: 0x8)
RigUnit_AlphaInterpVector.OutRange = 0x28 // FInputRange (Size: 0x8)
RigUnit_AlphaInterpVector.bClampResult = 0x30 // bool (Size: 0x1)
RigUnit_AlphaInterpVector.ClampMin = 0x34 // float (Size: 0x4)
RigUnit_AlphaInterpVector.ClampMax = 0x38 // float (Size: 0x4)
RigUnit_AlphaInterpVector.bInterpResult = 0x3c // bool (Size: 0x1)
RigUnit_AlphaInterpVector.InterpSpeedIncreasing = 0x40 // float (Size: 0x4)
RigUnit_AlphaInterpVector.InterpSpeedDecreasing = 0x44 // float (Size: 0x4)
RigUnit_AlphaInterpVector.Result = 0x48 // FVector (Size: 0xc)
RigUnit_AlphaInterpVector.ScaleBiasClamp = 0x54 // FInputScaleBiasClamp (Size: 0x30)
RigUnit_AnimEasing.Value = 0x8 // float (Size: 0x4)
RigUnit_AnimEasing.Type = 0xc // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_AnimEasing.SourceMinimum = 0x10 // float (Size: 0x4)
RigUnit_AnimEasing.SourceMaximum = 0x14 // float (Size: 0x4)
RigUnit_AnimEasing.TargetMinimum = 0x18 // float (Size: 0x4)
RigUnit_AnimEasing.TargetMaximum = 0x1c // float (Size: 0x4)
RigUnit_AnimEasing.Result = 0x20 // float (Size: 0x4)
RigUnit_AnimEasingType.Type = 0x8 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_AnimEvalRichCurve.Value = 0x8 // float (Size: 0x4)
RigUnit_AnimEvalRichCurve.Curve = 0x10 // FRuntimeFloatCurve (Size: 0x88)
RigUnit_AnimEvalRichCurve.SourceMinimum = 0x98 // float (Size: 0x4)
RigUnit_AnimEvalRichCurve.SourceMaximum = 0x9c // float (Size: 0x4)
RigUnit_AnimEvalRichCurve.TargetMinimum = 0xa0 // float (Size: 0x4)
RigUnit_AnimEvalRichCurve.TargetMaximum = 0xa4 // float (Size: 0x4)
RigUnit_AnimEvalRichCurve.Result = 0xa8 // float (Size: 0x4)
RigUnit_AnimRichCurve.Curve = 0x8 // FRuntimeFloatCurve (Size: 0x88)
RigUnit_ApplyFK.Joint = 0x68 // FName (Size: 0x8)
RigUnit_ApplyFK.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_ApplyFK.Filter = 0xa0 // FTransformFilter (Size: 0x9)
RigUnit_ApplyFK.ApplyTransformMode = 0xa9 // EEApplyTransformMode (Size: 0x1)
RigUnit_ApplyFK.ApplyTransformSpace = 0xaa // EETransformSpaceMode (Size: 0x1)
RigUnit_ApplyFK.BaseTransform = 0xb0 // FTransform (Size: 0x30)
RigUnit_ApplyFK.BaseJoint = 0xe0 // FName (Size: 0x8)
RigUnit_BeginExecution.ExecuteContext = 0x8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_BinaryFloatOp.Argument0 = 0x8 // float (Size: 0x4)
RigUnit_BinaryFloatOp.Argument1 = 0xc // float (Size: 0x4)
RigUnit_BinaryFloatOp.Result = 0x10 // float (Size: 0x4)
RigUnit_BinaryQuaternionOp.Argument0 = 0x10 // FQuat (Size: 0x10)
RigUnit_BinaryQuaternionOp.Argument1 = 0x20 // FQuat (Size: 0x10)
RigUnit_BinaryQuaternionOp.Result = 0x30 // FQuat (Size: 0x10)
RigUnit_BinaryTransformOp.Argument0 = 0x10 // FTransform (Size: 0x30)
RigUnit_BinaryTransformOp.Argument1 = 0x40 // FTransform (Size: 0x30)
RigUnit_BinaryTransformOp.Result = 0x70 // FTransform (Size: 0x30)
RigUnit_BinaryVectorOp.Argument0 = 0x8 // FVector (Size: 0xc)
RigUnit_BinaryVectorOp.Argument1 = 0x14 // FVector (Size: 0xc)
RigUnit_BinaryVectorOp.Result = 0x20 // FVector (Size: 0xc)
RigUnit_BlendTransform.Source = 0x10 // FTransform (Size: 0x30)
RigUnit_BlendTransform.Targets = 0x40 // TArray<FBlendTarget> (Size: 0x10)
RigUnit_BlendTransform.Result = 0x50 // FTransform (Size: 0x30)
RigUnit_BoneHarmonics.Bones = 0x68 // TArray<FRigUnit_BoneHarmonics_BoneTarget> (Size: 0x10)
RigUnit_BoneHarmonics.WaveSpeed = 0x78 // FVector (Size: 0xc)
RigUnit_BoneHarmonics.WaveFrequency = 0x84 // FVector (Size: 0xc)
RigUnit_BoneHarmonics.WaveAmplitude = 0x90 // FVector (Size: 0xc)
RigUnit_BoneHarmonics.WaveOffset = 0x9c // FVector (Size: 0xc)
RigUnit_BoneHarmonics.WaveNoise = 0xa8 // FVector (Size: 0xc)
RigUnit_BoneHarmonics.WaveEase = 0xb4 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_BoneHarmonics.WaveMinimum = 0xb8 // float (Size: 0x4)
RigUnit_BoneHarmonics.WaveMaximum = 0xbc // float (Size: 0x4)
RigUnit_BoneHarmonics.RotationOrder = 0xc0 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_BoneHarmonics.bPropagateToChildren = 0xc1 // bool (Size: 0x1)
RigUnit_BoneHarmonics.WorkData = 0xc8 // FRigUnit_BoneHarmonics_WorkData (Size: 0x20)
RigUnit_BoneHarmonics_BoneTarget.Bone = 0x0 // FName (Size: 0x8)
RigUnit_BoneHarmonics_BoneTarget.Ratio = 0x8 // float (Size: 0x4)
RigUnit_BoneHarmonics_WorkData.CachedItems = 0x0 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_BoneHarmonics_WorkData.WaveTime = 0x10 // FVector (Size: 0xc)
RigUnit_BoneName.Bone = 0x8 // FName (Size: 0x8)
RigUnit_CCDIK.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_CCDIK.EffectorBone = 0x70 // FName (Size: 0x8)
RigUnit_CCDIK.EffectorTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_CCDIK.Precision = 0xb0 // float (Size: 0x4)
RigUnit_CCDIK.Weight = 0xb4 // float (Size: 0x4)
RigUnit_CCDIK.MaxIterations = 0xb8 // int32_t (Size: 0x4)
RigUnit_CCDIK.bStartFromTail = 0xbc // bool (Size: 0x1)
RigUnit_CCDIK.BaseRotationLimit = 0xc0 // float (Size: 0x4)
RigUnit_CCDIK.RotationLimits = 0xc8 // TArray<FRigUnit_CCDIK_RotationLimit> (Size: 0x10)
RigUnit_CCDIK.bPropagateToChildren = 0xd8 // bool (Size: 0x1)
RigUnit_CCDIK.WorkData = 0xe0 // FRigUnit_CCDIK_WorkData (Size: 0x58)
RigUnit_CCDIKPerItem.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CCDIKPerItem.EffectorTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_CCDIKPerItem.Precision = 0xb0 // float (Size: 0x4)
RigUnit_CCDIKPerItem.Weight = 0xb4 // float (Size: 0x4)
RigUnit_CCDIKPerItem.MaxIterations = 0xb8 // int32_t (Size: 0x4)
RigUnit_CCDIKPerItem.bStartFromTail = 0xbc // bool (Size: 0x1)
RigUnit_CCDIKPerItem.BaseRotationLimit = 0xc0 // float (Size: 0x4)
RigUnit_CCDIKPerItem.RotationLimits = 0xc8 // TArray<FRigUnit_CCDIK_RotationLimitPerItem> (Size: 0x10)
RigUnit_CCDIKPerItem.bPropagateToChildren = 0xd8 // bool (Size: 0x1)
RigUnit_CCDIKPerItem.WorkData = 0xe0 // FRigUnit_CCDIK_WorkData (Size: 0x58)
RigUnit_CCDIK_RotationLimit.Bone = 0x0 // FName (Size: 0x8)
RigUnit_CCDIK_RotationLimit.Limit = 0x8 // float (Size: 0x4)
RigUnit_CCDIK_RotationLimitPerItem.item = 0x0 // FRigElementKey (Size: 0xc)
RigUnit_CCDIK_RotationLimitPerItem.Limit = 0xc // float (Size: 0x4)
RigUnit_CCDIK_WorkData.Chain = 0x0 // TArray<FCCDIKChainLink> (Size: 0x10)
RigUnit_CCDIK_WorkData.CachedItems = 0x10 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_CCDIK_WorkData.RotationLimitIndex = 0x20 // TArray<int32_t> (Size: 0x10)
RigUnit_CCDIK_WorkData.RotationLimitsPerItem = 0x30 // TArray<float> (Size: 0x10)
RigUnit_CCDIK_WorkData.CachedEffector = 0x40 // FCachedRigElement (Size: 0x14)
RigUnit_ChainHarmonics.ChainRoot = 0x68 // FName (Size: 0x8)
RigUnit_ChainHarmonics.Speed = 0x70 // FVector (Size: 0xc)
RigUnit_ChainHarmonics.Reach = 0x7c // FRigUnit_ChainHarmonics_Reach (Size: 0x28)
RigUnit_ChainHarmonics.Wave = 0xa4 // FRigUnit_ChainHarmonics_Wave (Size: 0x40)
RigUnit_ChainHarmonics.WaveCurve = 0xe8 // FRuntimeFloatCurve (Size: 0x88)
RigUnit_ChainHarmonics.Pendulum = 0x170 // FRigUnit_ChainHarmonics_Pendulum (Size: 0x3c)
RigUnit_ChainHarmonics.bDrawDebug = 0x1ac // bool (Size: 0x1)
RigUnit_ChainHarmonics.DrawWorldOffset = 0x1b0 // FTransform (Size: 0x30)
RigUnit_ChainHarmonics.WorkData = 0x1e0 // FRigUnit_ChainHarmonics_WorkData (Size: 0x90)
RigUnit_ChainHarmonicsPerItem.ChainRoot = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_ChainHarmonicsPerItem.Speed = 0x74 // FVector (Size: 0xc)
RigUnit_ChainHarmonicsPerItem.Reach = 0x80 // FRigUnit_ChainHarmonics_Reach (Size: 0x28)
RigUnit_ChainHarmonicsPerItem.Wave = 0xa8 // FRigUnit_ChainHarmonics_Wave (Size: 0x40)
RigUnit_ChainHarmonicsPerItem.WaveCurve = 0xe8 // FRuntimeFloatCurve (Size: 0x88)
RigUnit_ChainHarmonicsPerItem.Pendulum = 0x170 // FRigUnit_ChainHarmonics_Pendulum (Size: 0x3c)
RigUnit_ChainHarmonicsPerItem.bDrawDebug = 0x1ac // bool (Size: 0x1)
RigUnit_ChainHarmonicsPerItem.DrawWorldOffset = 0x1b0 // FTransform (Size: 0x30)
RigUnit_ChainHarmonicsPerItem.WorkData = 0x1e0 // FRigUnit_ChainHarmonics_WorkData (Size: 0x90)
RigUnit_ChainHarmonics_Pendulum.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_ChainHarmonics_Pendulum.PendulumStiffness = 0x4 // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.PendulumGravity = 0x8 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Pendulum.PendulumBlend = 0x14 // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.PendulumDrag = 0x18 // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.PendulumMinimum = 0x1c // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.PendulumMaximum = 0x20 // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.PendulumEase = 0x24 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_ChainHarmonics_Pendulum.UnwindAxis = 0x28 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Pendulum.UnwindMinimum = 0x34 // float (Size: 0x4)
RigUnit_ChainHarmonics_Pendulum.UnwindMaximum = 0x38 // float (Size: 0x4)
RigUnit_ChainHarmonics_Reach.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_ChainHarmonics_Reach.ReachTarget = 0x4 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Reach.ReachAxis = 0x10 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Reach.ReachMinimum = 0x1c // float (Size: 0x4)
RigUnit_ChainHarmonics_Reach.ReachMaximum = 0x20 // float (Size: 0x4)
RigUnit_ChainHarmonics_Reach.ReachEase = 0x24 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_ChainHarmonics_Wave.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_ChainHarmonics_Wave.WaveFrequency = 0x4 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Wave.WaveAmplitude = 0x10 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Wave.WaveOffset = 0x1c // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Wave.WaveNoise = 0x28 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_Wave.WaveMinimum = 0x34 // float (Size: 0x4)
RigUnit_ChainHarmonics_Wave.WaveMaximum = 0x38 // float (Size: 0x4)
RigUnit_ChainHarmonics_Wave.WaveEase = 0x3c // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_ChainHarmonics_WorkData.Time = 0x0 // FVector (Size: 0xc)
RigUnit_ChainHarmonics_WorkData.Items = 0x10 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.Ratio = 0x20 // TArray<float> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.LocalTip = 0x30 // TArray<FVector> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.PendulumTip = 0x40 // TArray<FVector> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.PendulumPosition = 0x50 // TArray<FVector> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.PendulumVelocity = 0x60 // TArray<FVector> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.HierarchyLine = 0x70 // TArray<FVector> (Size: 0x10)
RigUnit_ChainHarmonics_WorkData.VelocityLines = 0x80 // TArray<FVector> (Size: 0x10)
RigUnit_Clamp_Float.Value = 0x8 // float (Size: 0x4)
RigUnit_Clamp_Float.Min = 0xc // float (Size: 0x4)
RigUnit_Clamp_Float.Max = 0x10 // float (Size: 0x4)
RigUnit_Clamp_Float.Result = 0x14 // float (Size: 0x4)
RigUnit_CollectionChain.FirstItem = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_CollectionChain.LastItem = 0x14 // FRigElementKey (Size: 0xc)
RigUnit_CollectionChain.Reverse = 0x20 // bool (Size: 0x1)
RigUnit_CollectionChain.Collection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionChain.CachedCollection = 0x38 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionChain.CachedHierarchyHash = 0x48 // int32_t (Size: 0x4)
RigUnit_CollectionChildren.Parent = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_CollectionChildren.bIncludeParent = 0x14 // bool (Size: 0x1)
RigUnit_CollectionChildren.bRecursive = 0x15 // bool (Size: 0x1)
RigUnit_CollectionChildren.TypeToSearch = 0x16 // EERigElementType (Size: 0x1)
RigUnit_CollectionChildren.Collection = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionChildren.CachedCollection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionChildren.CachedHierarchyHash = 0x38 // int32_t (Size: 0x4)
RigUnit_CollectionCount.Collection = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionCount.Count = 0x18 // int32_t (Size: 0x4)
RigUnit_CollectionDifference.A = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionDifference.B = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionDifference.Collection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionIntersection.A = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionIntersection.B = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionIntersection.Collection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionItemAtIndex.Collection = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionItemAtIndex.Index = 0x18 // int32_t (Size: 0x4)
RigUnit_CollectionItemAtIndex.item = 0x1c // FRigElementKey (Size: 0xc)
RigUnit_CollectionItems.Items = 0x8 // TArray<FRigElementKey> (Size: 0x10)
RigUnit_CollectionItems.Collection = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionLoop.Collection = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionLoop.item = 0x78 // FRigElementKey (Size: 0xc)
RigUnit_CollectionLoop.Index = 0x84 // int32_t (Size: 0x4)
RigUnit_CollectionLoop.Count = 0x88 // int32_t (Size: 0x4)
RigUnit_CollectionLoop.Ratio = 0x8c // float (Size: 0x4)
RigUnit_CollectionLoop.Continue = 0x90 // bool (Size: 0x1)
RigUnit_CollectionLoop.Completed = 0x98 // FControlRigExecuteContext (Size: 0x60)
RigUnit_CollectionNameSearch.PartialName = 0x8 // FName (Size: 0x8)
RigUnit_CollectionNameSearch.TypeToSearch = 0x10 // EERigElementType (Size: 0x1)
RigUnit_CollectionNameSearch.Collection = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionNameSearch.CachedCollection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionNameSearch.CachedHierarchyHash = 0x38 // int32_t (Size: 0x4)
RigUnit_CollectionReplaceItems.Items = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionReplaceItems.Old = 0x18 // FName (Size: 0x8)
RigUnit_CollectionReplaceItems.New = 0x20 // FName (Size: 0x8)
RigUnit_CollectionReplaceItems.RemoveInvalidItems = 0x28 // bool (Size: 0x1)
RigUnit_CollectionReplaceItems.Collection = 0x30 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionReplaceItems.CachedCollection = 0x40 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionReplaceItems.CachedHierarchyHash = 0x50 // int32_t (Size: 0x4)
RigUnit_CollectionReverse.Collection = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionReverse.Reversed = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionUnion.A = 0x8 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionUnion.B = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_CollectionUnion.Collection = 0x28 // FRigElementKeyCollection (Size: 0x10)
RigUnit_Contains.Name = 0x8 // FName (Size: 0x8)
RigUnit_Contains.Search = 0x10 // FName (Size: 0x8)
RigUnit_Contains.Result = 0x18 // bool (Size: 0x1)
RigUnit_Control.Transform = 0x8 // FEulerTransform (Size: 0x24)
RigUnit_Control.Base = 0x30 // FTransform (Size: 0x30)
RigUnit_Control.InitTransform = 0x60 // FTransform (Size: 0x30)
RigUnit_Control.Result = 0x90 // FTransform (Size: 0x30)
RigUnit_Control.Filter = 0xc0 // FTransformFilter (Size: 0x9)
RigUnit_ControlName.Control = 0x8 // FName (Size: 0x8)
RigUnit_Control_StaticMesh.MeshTransform = 0xd0 // FTransform (Size: 0x30)
RigUnit_ConvertEulerTransform.Input = 0x8 // FEulerTransform (Size: 0x24)
RigUnit_ConvertEulerTransform.Result = 0x30 // FTransform (Size: 0x30)
RigUnit_ConvertQuaternion.Input = 0x10 // FQuat (Size: 0x10)
RigUnit_ConvertQuaternion.Result = 0x20 // FRotator (Size: 0xc)
RigUnit_ConvertQuaternionToVector.Input = 0x10 // FQuat (Size: 0x10)
RigUnit_ConvertQuaternionToVector.Result = 0x20 // FVector (Size: 0xc)
RigUnit_ConvertRotation.Input = 0x8 // FRotator (Size: 0xc)
RigUnit_ConvertRotation.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_ConvertRotationToVector.Input = 0x8 // FRotator (Size: 0xc)
RigUnit_ConvertRotationToVector.Result = 0x14 // FVector (Size: 0xc)
RigUnit_ConvertTransform.Input = 0x10 // FTransform (Size: 0x30)
RigUnit_ConvertTransform.Result = 0x40 // FEulerTransform (Size: 0x24)
RigUnit_ConvertVectorToQuaternion.Input = 0x8 // FVector (Size: 0xc)
RigUnit_ConvertVectorToQuaternion.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_ConvertVectorToRotation.Input = 0x8 // FVector (Size: 0xc)
RigUnit_ConvertVectorToRotation.Result = 0x14 // FRotator (Size: 0xc)
RigUnit_DebugArc.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugArc.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugArc.Radius = 0xb0 // float (Size: 0x4)
RigUnit_DebugArc.MinimumDegrees = 0xb4 // float (Size: 0x4)
RigUnit_DebugArc.MaximumDegrees = 0xb8 // float (Size: 0x4)
RigUnit_DebugArc.Thickness = 0xbc // float (Size: 0x4)
RigUnit_DebugArc.Detail = 0xc0 // int32_t (Size: 0x4)
RigUnit_DebugArc.Space = 0xc4 // FName (Size: 0x8)
RigUnit_DebugArc.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugArc.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DebugArcItemSpace.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugArcItemSpace.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugArcItemSpace.Radius = 0xb0 // float (Size: 0x4)
RigUnit_DebugArcItemSpace.MinimumDegrees = 0xb4 // float (Size: 0x4)
RigUnit_DebugArcItemSpace.MaximumDegrees = 0xb8 // float (Size: 0x4)
RigUnit_DebugArcItemSpace.Thickness = 0xbc // float (Size: 0x4)
RigUnit_DebugArcItemSpace.Detail = 0xc0 // int32_t (Size: 0x4)
RigUnit_DebugArcItemSpace.Space = 0xc4 // FRigElementKey (Size: 0xc)
RigUnit_DebugArcItemSpace.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugArcItemSpace.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DebugBezier.Bezier = 0x68 // FCRFourPointBezier (Size: 0x30)
RigUnit_DebugBezier.MinimumU = 0x98 // float (Size: 0x4)
RigUnit_DebugBezier.MaximumU = 0x9c // float (Size: 0x4)
RigUnit_DebugBezier.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugBezier.Thickness = 0xb0 // float (Size: 0x4)
RigUnit_DebugBezier.Detail = 0xb4 // int32_t (Size: 0x4)
RigUnit_DebugBezier.Space = 0xb8 // FName (Size: 0x8)
RigUnit_DebugBezier.WorldOffset = 0xc0 // FTransform (Size: 0x30)
RigUnit_DebugBezier.bEnabled = 0xf0 // bool (Size: 0x1)
RigUnit_DebugBezierItemSpace.Bezier = 0x68 // FCRFourPointBezier (Size: 0x30)
RigUnit_DebugBezierItemSpace.MinimumU = 0x98 // float (Size: 0x4)
RigUnit_DebugBezierItemSpace.MaximumU = 0x9c // float (Size: 0x4)
RigUnit_DebugBezierItemSpace.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugBezierItemSpace.Thickness = 0xb0 // float (Size: 0x4)
RigUnit_DebugBezierItemSpace.Detail = 0xb4 // int32_t (Size: 0x4)
RigUnit_DebugBezierItemSpace.Space = 0xb8 // FRigElementKey (Size: 0xc)
RigUnit_DebugBezierItemSpace.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugBezierItemSpace.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DebugHierarchy.Scale = 0x68 // float (Size: 0x4)
RigUnit_DebugHierarchy.Color = 0x6c // FLinearColor (Size: 0x10)
RigUnit_DebugHierarchy.Thickness = 0x7c // float (Size: 0x4)
RigUnit_DebugHierarchy.WorldOffset = 0x80 // FTransform (Size: 0x30)
RigUnit_DebugHierarchy.bEnabled = 0xb0 // bool (Size: 0x1)
RigUnit_DebugLine.A = 0x68 // FVector (Size: 0xc)
RigUnit_DebugLine.B = 0x74 // FVector (Size: 0xc)
RigUnit_DebugLine.Color = 0x80 // FLinearColor (Size: 0x10)
RigUnit_DebugLine.Thickness = 0x90 // float (Size: 0x4)
RigUnit_DebugLine.Space = 0x94 // FName (Size: 0x8)
RigUnit_DebugLine.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugLine.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugLineItemSpace.A = 0x68 // FVector (Size: 0xc)
RigUnit_DebugLineItemSpace.B = 0x74 // FVector (Size: 0xc)
RigUnit_DebugLineItemSpace.Color = 0x80 // FLinearColor (Size: 0x10)
RigUnit_DebugLineItemSpace.Thickness = 0x90 // float (Size: 0x4)
RigUnit_DebugLineItemSpace.Space = 0x94 // FRigElementKey (Size: 0xc)
RigUnit_DebugLineItemSpace.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugLineItemSpace.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugLineStrip.Points = 0x68 // TArray<FVector> (Size: 0x10)
RigUnit_DebugLineStrip.Color = 0x78 // FLinearColor (Size: 0x10)
RigUnit_DebugLineStrip.Thickness = 0x88 // float (Size: 0x4)
RigUnit_DebugLineStrip.Space = 0x8c // FName (Size: 0x8)
RigUnit_DebugLineStrip.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugLineStrip.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugLineStripItemSpace.Points = 0x68 // TArray<FVector> (Size: 0x10)
RigUnit_DebugLineStripItemSpace.Color = 0x78 // FLinearColor (Size: 0x10)
RigUnit_DebugLineStripItemSpace.Thickness = 0x88 // float (Size: 0x4)
RigUnit_DebugLineStripItemSpace.Space = 0x8c // FRigElementKey (Size: 0xc)
RigUnit_DebugLineStripItemSpace.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugLineStripItemSpace.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugPoint.Vector = 0x8 // FVector (Size: 0xc)
RigUnit_DebugPoint.Mode = 0x14 // EERigUnitDebugPointMode (Size: 0x1)
RigUnit_DebugPoint.Color = 0x18 // FLinearColor (Size: 0x10)
RigUnit_DebugPoint.Scale = 0x28 // float (Size: 0x4)
RigUnit_DebugPoint.Thickness = 0x2c // float (Size: 0x4)
RigUnit_DebugPoint.Space = 0x30 // FName (Size: 0x8)
RigUnit_DebugPoint.WorldOffset = 0x40 // FTransform (Size: 0x30)
RigUnit_DebugPoint.bEnabled = 0x70 // bool (Size: 0x1)
RigUnit_DebugPointMutable.Vector = 0x68 // FVector (Size: 0xc)
RigUnit_DebugPointMutable.Mode = 0x74 // EERigUnitDebugPointMode (Size: 0x1)
RigUnit_DebugPointMutable.Color = 0x78 // FLinearColor (Size: 0x10)
RigUnit_DebugPointMutable.Scale = 0x88 // float (Size: 0x4)
RigUnit_DebugPointMutable.Thickness = 0x8c // float (Size: 0x4)
RigUnit_DebugPointMutable.Space = 0x90 // FName (Size: 0x8)
RigUnit_DebugPointMutable.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugPointMutable.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugRectangle.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugRectangle.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugRectangle.Scale = 0xb0 // float (Size: 0x4)
RigUnit_DebugRectangle.Thickness = 0xb4 // float (Size: 0x4)
RigUnit_DebugRectangle.Space = 0xb8 // FName (Size: 0x8)
RigUnit_DebugRectangle.WorldOffset = 0xc0 // FTransform (Size: 0x30)
RigUnit_DebugRectangle.bEnabled = 0xf0 // bool (Size: 0x1)
RigUnit_DebugRectangleItemSpace.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugRectangleItemSpace.Color = 0xa0 // FLinearColor (Size: 0x10)
RigUnit_DebugRectangleItemSpace.Scale = 0xb0 // float (Size: 0x4)
RigUnit_DebugRectangleItemSpace.Thickness = 0xb4 // float (Size: 0x4)
RigUnit_DebugRectangleItemSpace.Space = 0xb8 // FRigElementKey (Size: 0xc)
RigUnit_DebugRectangleItemSpace.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugRectangleItemSpace.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DebugTransform.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_DebugTransform.Mode = 0x40 // EERigUnitDebugTransformMode (Size: 0x1)
RigUnit_DebugTransform.Color = 0x44 // FLinearColor (Size: 0x10)
RigUnit_DebugTransform.Thickness = 0x54 // float (Size: 0x4)
RigUnit_DebugTransform.Scale = 0x58 // float (Size: 0x4)
RigUnit_DebugTransform.Space = 0x5c // FName (Size: 0x8)
RigUnit_DebugTransform.WorldOffset = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugTransform.bEnabled = 0xa0 // bool (Size: 0x1)
RigUnit_DebugTransformArrayMutable.Transforms = 0x68 // TArray<FTransform> (Size: 0x10)
RigUnit_DebugTransformArrayMutable.Mode = 0x78 // EERigUnitDebugTransformMode (Size: 0x1)
RigUnit_DebugTransformArrayMutable.Color = 0x7c // FLinearColor (Size: 0x10)
RigUnit_DebugTransformArrayMutable.Thickness = 0x8c // float (Size: 0x4)
RigUnit_DebugTransformArrayMutable.Scale = 0x90 // float (Size: 0x4)
RigUnit_DebugTransformArrayMutable.Space = 0x94 // FName (Size: 0x8)
RigUnit_DebugTransformArrayMutable.WorldOffset = 0xa0 // FTransform (Size: 0x30)
RigUnit_DebugTransformArrayMutable.bEnabled = 0xd0 // bool (Size: 0x1)
RigUnit_DebugTransformArrayMutable.WorkData = 0xd8 // FRigUnit_DebugTransformArrayMutable_WorkData (Size: 0x10)
RigUnit_DebugTransformArrayMutable_WorkData.DrawTransforms = 0x0 // TArray<FTransform> (Size: 0x10)
RigUnit_DebugTransformMutable.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugTransformMutable.Mode = 0xa0 // EERigUnitDebugTransformMode (Size: 0x1)
RigUnit_DebugTransformMutable.Color = 0xa4 // FLinearColor (Size: 0x10)
RigUnit_DebugTransformMutable.Thickness = 0xb4 // float (Size: 0x4)
RigUnit_DebugTransformMutable.Scale = 0xb8 // float (Size: 0x4)
RigUnit_DebugTransformMutable.Space = 0xbc // FName (Size: 0x8)
RigUnit_DebugTransformMutable.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugTransformMutable.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DebugTransformMutableItemSpace.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_DebugTransformMutableItemSpace.Mode = 0xa0 // EERigUnitDebugTransformMode (Size: 0x1)
RigUnit_DebugTransformMutableItemSpace.Color = 0xa4 // FLinearColor (Size: 0x10)
RigUnit_DebugTransformMutableItemSpace.Thickness = 0xb4 // float (Size: 0x4)
RigUnit_DebugTransformMutableItemSpace.Scale = 0xb8 // float (Size: 0x4)
RigUnit_DebugTransformMutableItemSpace.Space = 0xbc // FRigElementKey (Size: 0xc)
RigUnit_DebugTransformMutableItemSpace.WorldOffset = 0xd0 // FTransform (Size: 0x30)
RigUnit_DebugTransformMutableItemSpace.bEnabled = 0x100 // bool (Size: 0x1)
RigUnit_DeltaFromPreviousFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_DeltaFromPreviousFloat.Delta = 0xc // float (Size: 0x4)
RigUnit_DeltaFromPreviousFloat.PreviousValue = 0x10 // float (Size: 0x4)
RigUnit_DeltaFromPreviousFloat.Cache = 0x14 // float (Size: 0x4)
RigUnit_DeltaFromPreviousQuat.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_DeltaFromPreviousQuat.Delta = 0x20 // FQuat (Size: 0x10)
RigUnit_DeltaFromPreviousQuat.PreviousValue = 0x30 // FQuat (Size: 0x10)
RigUnit_DeltaFromPreviousQuat.Cache = 0x40 // FQuat (Size: 0x10)
RigUnit_DeltaFromPreviousTransform.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_DeltaFromPreviousTransform.Delta = 0x40 // FTransform (Size: 0x30)
RigUnit_DeltaFromPreviousTransform.PreviousValue = 0x70 // FTransform (Size: 0x30)
RigUnit_DeltaFromPreviousTransform.Cache = 0xa0 // FTransform (Size: 0x30)
RigUnit_DeltaFromPreviousVector.Value = 0x8 // FVector (Size: 0xc)
RigUnit_DeltaFromPreviousVector.Delta = 0x14 // FVector (Size: 0xc)
RigUnit_DeltaFromPreviousVector.PreviousValue = 0x20 // FVector (Size: 0xc)
RigUnit_DeltaFromPreviousVector.Cache = 0x2c // FVector (Size: 0xc)
RigUnit_Distance_VectorVector.Argument0 = 0x8 // FVector (Size: 0xc)
RigUnit_Distance_VectorVector.Argument1 = 0x14 // FVector (Size: 0xc)
RigUnit_Distance_VectorVector.Result = 0x20 // float (Size: 0x4)
RigUnit_DistributeRotation.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_DistributeRotation.EndBone = 0x70 // FName (Size: 0x8)
RigUnit_DistributeRotation.Rotations = 0x78 // TArray<FRigUnit_DistributeRotation_Rotation> (Size: 0x10)
RigUnit_DistributeRotation.RotationEaseType = 0x88 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_DistributeRotation.Weight = 0x8c // float (Size: 0x4)
RigUnit_DistributeRotation.bPropagateToChildren = 0x90 // bool (Size: 0x1)
RigUnit_DistributeRotation.WorkData = 0x98 // FRigUnit_DistributeRotation_WorkData (Size: 0x50)
RigUnit_DistributeRotationForCollection.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_DistributeRotationForCollection.Rotations = 0x78 // TArray<FRigUnit_DistributeRotation_Rotation> (Size: 0x10)
RigUnit_DistributeRotationForCollection.RotationEaseType = 0x88 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_DistributeRotationForCollection.Weight = 0x8c // float (Size: 0x4)
RigUnit_DistributeRotationForCollection.WorkData = 0x90 // FRigUnit_DistributeRotation_WorkData (Size: 0x50)
RigUnit_DistributeRotation_Rotation.Rotation = 0x0 // FQuat (Size: 0x10)
RigUnit_DistributeRotation_Rotation.Ratio = 0x10 // float (Size: 0x4)
RigUnit_DistributeRotation_WorkData.CachedItems = 0x0 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_DistributeRotation_WorkData.ItemRotationA = 0x10 // TArray<int32_t> (Size: 0x10)
RigUnit_DistributeRotation_WorkData.ItemRotationB = 0x20 // TArray<int32_t> (Size: 0x10)
RigUnit_DistributeRotation_WorkData.ItemRotationT = 0x30 // TArray<float> (Size: 0x10)
RigUnit_DistributeRotation_WorkData.ItemLocalTransforms = 0x40 // TArray<FTransform> (Size: 0x10)
RigUnit_DrawContainerGetInstruction.InstructionName = 0x8 // FName (Size: 0x8)
RigUnit_DrawContainerGetInstruction.Color = 0x10 // FLinearColor (Size: 0x10)
RigUnit_DrawContainerGetInstruction.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_DrawContainerSetColor.InstructionName = 0x68 // FName (Size: 0x8)
RigUnit_DrawContainerSetColor.Color = 0x70 // FLinearColor (Size: 0x10)
RigUnit_DrawContainerSetThickness.InstructionName = 0x68 // FName (Size: 0x8)
RigUnit_DrawContainerSetThickness.Thickness = 0x70 // float (Size: 0x4)
RigUnit_DrawContainerSetTransform.InstructionName = 0x68 // FName (Size: 0x8)
RigUnit_DrawContainerSetTransform.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_EndProfilingTimer.NumberOfMeasurements = 0x68 // int32_t (Size: 0x4)
RigUnit_EndProfilingTimer.Prefix = 0x70 // FString (Size: 0x10)
RigUnit_EndProfilingTimer.AccumulatedTime = 0x80 // float (Size: 0x4)
RigUnit_EndProfilingTimer.MeasurementsLeft = 0x84 // int32_t (Size: 0x4)
RigUnit_EndsWith.Name = 0x8 // FName (Size: 0x8)
RigUnit_EndsWith.Ending = 0x10 // FName (Size: 0x8)
RigUnit_EndsWith.Result = 0x18 // bool (Size: 0x1)
RigUnit_FABRIK.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_FABRIK.EffectorBone = 0x70 // FName (Size: 0x8)
RigUnit_FABRIK.EffectorTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_FABRIK.Precision = 0xb0 // float (Size: 0x4)
RigUnit_FABRIK.Weight = 0xb4 // float (Size: 0x4)
RigUnit_FABRIK.bPropagateToChildren = 0xb8 // bool (Size: 0x1)
RigUnit_FABRIK.MaxIterations = 0xbc // int32_t (Size: 0x4)
RigUnit_FABRIK.WorkData = 0xc0 // FRigUnit_FABRIK_WorkData (Size: 0x38)
RigUnit_FABRIKPerItem.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_FABRIKPerItem.EffectorTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_FABRIKPerItem.Precision = 0xb0 // float (Size: 0x4)
RigUnit_FABRIKPerItem.Weight = 0xb4 // float (Size: 0x4)
RigUnit_FABRIKPerItem.bPropagateToChildren = 0xb8 // bool (Size: 0x1)
RigUnit_FABRIKPerItem.MaxIterations = 0xbc // int32_t (Size: 0x4)
RigUnit_FABRIKPerItem.WorkData = 0xc0 // FRigUnit_FABRIK_WorkData (Size: 0x38)
RigUnit_FABRIK_WorkData.Chain = 0x0 // TArray<FFABRIKChainLink> (Size: 0x10)
RigUnit_FABRIK_WorkData.CachedItems = 0x10 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_FABRIK_WorkData.CachedEffector = 0x20 // FCachedRigElement (Size: 0x14)
RigUnit_FitChainToCurve.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_FitChainToCurve.EndBone = 0x70 // FName (Size: 0x8)
RigUnit_FitChainToCurve.Bezier = 0x78 // FCRFourPointBezier (Size: 0x30)
RigUnit_FitChainToCurve.Alignment = 0xa8 // EEControlRigCurveAlignment (Size: 0x1)
RigUnit_FitChainToCurve.Minimum = 0xac // float (Size: 0x4)
RigUnit_FitChainToCurve.Maximum = 0xb0 // float (Size: 0x4)
RigUnit_FitChainToCurve.SamplingPrecision = 0xb4 // int32_t (Size: 0x4)
RigUnit_FitChainToCurve.PrimaryAxis = 0xb8 // FVector (Size: 0xc)
RigUnit_FitChainToCurve.SecondaryAxis = 0xc4 // FVector (Size: 0xc)
RigUnit_FitChainToCurve.PoleVectorPosition = 0xd0 // FVector (Size: 0xc)
RigUnit_FitChainToCurve.Rotations = 0xe0 // TArray<FRigUnit_FitChainToCurve_Rotation> (Size: 0x10)
RigUnit_FitChainToCurve.RotationEaseType = 0xf0 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_FitChainToCurve.Weight = 0xf4 // float (Size: 0x4)
RigUnit_FitChainToCurve.bPropagateToChildren = 0xf8 // bool (Size: 0x1)
RigUnit_FitChainToCurve.DebugSettings = 0x100 // FRigUnit_FitChainToCurve_DebugSettings (Size: 0x60)
RigUnit_FitChainToCurve.WorkData = 0x160 // FRigUnit_FitChainToCurve_WorkData (Size: 0x98)
RigUnit_FitChainToCurvePerItem.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_FitChainToCurvePerItem.Bezier = 0x78 // FCRFourPointBezier (Size: 0x30)
RigUnit_FitChainToCurvePerItem.Alignment = 0xa8 // EEControlRigCurveAlignment (Size: 0x1)
RigUnit_FitChainToCurvePerItem.Minimum = 0xac // float (Size: 0x4)
RigUnit_FitChainToCurvePerItem.Maximum = 0xb0 // float (Size: 0x4)
RigUnit_FitChainToCurvePerItem.SamplingPrecision = 0xb4 // int32_t (Size: 0x4)
RigUnit_FitChainToCurvePerItem.PrimaryAxis = 0xb8 // FVector (Size: 0xc)
RigUnit_FitChainToCurvePerItem.SecondaryAxis = 0xc4 // FVector (Size: 0xc)
RigUnit_FitChainToCurvePerItem.PoleVectorPosition = 0xd0 // FVector (Size: 0xc)
RigUnit_FitChainToCurvePerItem.Rotations = 0xe0 // TArray<FRigUnit_FitChainToCurve_Rotation> (Size: 0x10)
RigUnit_FitChainToCurvePerItem.RotationEaseType = 0xf0 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_FitChainToCurvePerItem.Weight = 0xf4 // float (Size: 0x4)
RigUnit_FitChainToCurvePerItem.bPropagateToChildren = 0xf8 // bool (Size: 0x1)
RigUnit_FitChainToCurvePerItem.DebugSettings = 0x100 // FRigUnit_FitChainToCurve_DebugSettings (Size: 0x60)
RigUnit_FitChainToCurvePerItem.WorkData = 0x160 // FRigUnit_FitChainToCurve_WorkData (Size: 0x98)
RigUnit_FitChainToCurve_DebugSettings.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_FitChainToCurve_DebugSettings.Scale = 0x4 // float (Size: 0x4)
RigUnit_FitChainToCurve_DebugSettings.CurveColor = 0x8 // FLinearColor (Size: 0x10)
RigUnit_FitChainToCurve_DebugSettings.SegmentsColor = 0x18 // FLinearColor (Size: 0x10)
RigUnit_FitChainToCurve_DebugSettings.WorldOffset = 0x30 // FTransform (Size: 0x30)
RigUnit_FitChainToCurve_Rotation.Rotation = 0x0 // FQuat (Size: 0x10)
RigUnit_FitChainToCurve_Rotation.Ratio = 0x10 // float (Size: 0x4)
RigUnit_FitChainToCurve_WorkData.ChainLength = 0x0 // float (Size: 0x4)
RigUnit_FitChainToCurve_WorkData.ItemPositions = 0x8 // TArray<FVector> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.ItemSegments = 0x18 // TArray<float> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.CurvePositions = 0x28 // TArray<FVector> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.CurveSegments = 0x38 // TArray<float> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.CachedItems = 0x48 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.ItemRotationA = 0x58 // TArray<int32_t> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.ItemRotationB = 0x68 // TArray<int32_t> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.ItemRotationT = 0x78 // TArray<float> (Size: 0x10)
RigUnit_FitChainToCurve_WorkData.ItemLocalTransforms = 0x88 // TArray<FTransform> (Size: 0x10)
RigUnit_ForLoopCount.Count = 0x68 // int32_t (Size: 0x4)
RigUnit_ForLoopCount.Index = 0x6c // int32_t (Size: 0x4)
RigUnit_ForLoopCount.Ratio = 0x70 // float (Size: 0x4)
RigUnit_ForLoopCount.Continue = 0x74 // bool (Size: 0x1)
RigUnit_ForLoopCount.Completed = 0x78 // FControlRigExecuteContext (Size: 0x60)
RigUnit_FramesToSeconds.Frames = 0x8 // float (Size: 0x4)
RigUnit_FramesToSeconds.Seconds = 0xc // float (Size: 0x4)
RigUnit_GetBoneTransform.Bone = 0x8 // FName (Size: 0x8)
RigUnit_GetBoneTransform.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetBoneTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetBoneTransform.CachedBone = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlBool.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlBool.BoolValue = 0x10 // bool (Size: 0x1)
RigUnit_GetControlBool.CachedControlIndex = 0x14 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlFloat.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlFloat.FloatValue = 0x10 // float (Size: 0x4)
RigUnit_GetControlFloat.Minimum = 0x14 // float (Size: 0x4)
RigUnit_GetControlFloat.Maximum = 0x18 // float (Size: 0x4)
RigUnit_GetControlFloat.CachedControlIndex = 0x1c // FCachedRigElement (Size: 0x14)
RigUnit_GetControlInitialTransform.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlInitialTransform.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetControlInitialTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetControlInitialTransform.CachedControlIndex = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlInteger.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlInteger.IntegerValue = 0x10 // int32_t (Size: 0x4)
RigUnit_GetControlInteger.Minimum = 0x14 // int32_t (Size: 0x4)
RigUnit_GetControlInteger.Maximum = 0x18 // int32_t (Size: 0x4)
RigUnit_GetControlInteger.CachedControlIndex = 0x1c // FCachedRigElement (Size: 0x14)
RigUnit_GetControlRotator.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlRotator.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetControlRotator.Rotator = 0x14 // FRotator (Size: 0xc)
RigUnit_GetControlRotator.Minimum = 0x20 // FRotator (Size: 0xc)
RigUnit_GetControlRotator.Maximum = 0x2c // FRotator (Size: 0xc)
RigUnit_GetControlRotator.CachedControlIndex = 0x38 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlTransform.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlTransform.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetControlTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetControlTransform.Minimum = 0x50 // FTransform (Size: 0x30)
RigUnit_GetControlTransform.Maximum = 0x80 // FTransform (Size: 0x30)
RigUnit_GetControlTransform.CachedControlIndex = 0xb0 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlVector.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlVector.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetControlVector.Vector = 0x14 // FVector (Size: 0xc)
RigUnit_GetControlVector.Minimum = 0x20 // FVector (Size: 0xc)
RigUnit_GetControlVector.Maximum = 0x2c // FVector (Size: 0xc)
RigUnit_GetControlVector.CachedControlIndex = 0x38 // FCachedRigElement (Size: 0x14)
RigUnit_GetControlVector2D.Control = 0x8 // FName (Size: 0x8)
RigUnit_GetControlVector2D.Vector = 0x10 // FVector2D (Size: 0x8)
RigUnit_GetControlVector2D.Minimum = 0x18 // FVector2D (Size: 0x8)
RigUnit_GetControlVector2D.Maximum = 0x20 // FVector2D (Size: 0x8)
RigUnit_GetControlVector2D.CachedControlIndex = 0x28 // FCachedRigElement (Size: 0x14)
RigUnit_GetCurveValue.Curve = 0x8 // FName (Size: 0x8)
RigUnit_GetCurveValue.Value = 0x10 // float (Size: 0x4)
RigUnit_GetCurveValue.CachedCurveIndex = 0x14 // FCachedRigElement (Size: 0x14)
RigUnit_GetDeltaTime.Result = 0x8 // float (Size: 0x4)
RigUnit_GetInitialBoneTransform.Bone = 0x8 // FName (Size: 0x8)
RigUnit_GetInitialBoneTransform.Space = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetInitialBoneTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetInitialBoneTransform.CachedBone = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetJointTransform.Joint = 0x68 // FName (Size: 0x8)
RigUnit_GetJointTransform.Type = 0x70 // EETransformGetterType (Size: 0x1)
RigUnit_GetJointTransform.TransformSpace = 0x71 // EETransformSpaceMode (Size: 0x1)
RigUnit_GetJointTransform.BaseTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_GetJointTransform.BaseJoint = 0xb0 // FName (Size: 0x8)
RigUnit_GetJointTransform.Output = 0xc0 // FTransform (Size: 0x30)
RigUnit_GetRelativeBoneTransform.Bone = 0x8 // FName (Size: 0x8)
RigUnit_GetRelativeBoneTransform.Space = 0x10 // FName (Size: 0x8)
RigUnit_GetRelativeBoneTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetRelativeBoneTransform.CachedBone = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetRelativeBoneTransform.CachedSpace = 0x64 // FCachedRigElement (Size: 0x14)
RigUnit_GetRelativeTransformForItem.Child = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_GetRelativeTransformForItem.bChildInitial = 0x14 // bool (Size: 0x1)
RigUnit_GetRelativeTransformForItem.Parent = 0x18 // FRigElementKey (Size: 0xc)
RigUnit_GetRelativeTransformForItem.bParentInitial = 0x24 // bool (Size: 0x1)
RigUnit_GetRelativeTransformForItem.RelativeTransform = 0x30 // FTransform (Size: 0x30)
RigUnit_GetRelativeTransformForItem.CachedChild = 0x60 // FCachedRigElement (Size: 0x14)
RigUnit_GetRelativeTransformForItem.CachedParent = 0x74 // FCachedRigElement (Size: 0x14)
RigUnit_GetSpaceTransform.Space = 0x8 // FName (Size: 0x8)
RigUnit_GetSpaceTransform.SpaceType = 0x10 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetSpaceTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetSpaceTransform.CachedSpaceIndex = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetTransform.item = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_GetTransform.Space = 0x14 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_GetTransform.bInitial = 0x15 // bool (Size: 0x1)
RigUnit_GetTransform.Transform = 0x20 // FTransform (Size: 0x30)
RigUnit_GetTransform.CachedIndex = 0x50 // FCachedRigElement (Size: 0x14)
RigUnit_GetWorldTime.Year = 0x8 // float (Size: 0x4)
RigUnit_GetWorldTime.Month = 0xc // float (Size: 0x4)
RigUnit_GetWorldTime.Day = 0x10 // float (Size: 0x4)
RigUnit_GetWorldTime.WeekDay = 0x14 // float (Size: 0x4)
RigUnit_GetWorldTime.Hours = 0x18 // float (Size: 0x4)
RigUnit_GetWorldTime.Minutes = 0x1c // float (Size: 0x4)
RigUnit_GetWorldTime.Seconds = 0x20 // float (Size: 0x4)
RigUnit_GetWorldTime.OverallSeconds = 0x24 // float (Size: 0x4)
RigUnit_Harmonics_TargetItem.item = 0x0 // FRigElementKey (Size: 0xc)
RigUnit_Harmonics_TargetItem.Ratio = 0xc // float (Size: 0x4)
RigUnit_HierarchyGetChildren.Parent = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_HierarchyGetChildren.bIncludeParent = 0x14 // bool (Size: 0x1)
RigUnit_HierarchyGetChildren.bRecursive = 0x15 // bool (Size: 0x1)
RigUnit_HierarchyGetChildren.Children = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_HierarchyGetChildren.CachedParent = 0x28 // FCachedRigElement (Size: 0x14)
RigUnit_HierarchyGetChildren.CachedChildren = 0x40 // FRigElementKeyCollection (Size: 0x10)
RigUnit_HierarchyGetParent.Child = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_HierarchyGetParent.Parent = 0x14 // FRigElementKey (Size: 0xc)
RigUnit_HierarchyGetParent.CachedChild = 0x20 // FCachedRigElement (Size: 0x14)
RigUnit_HierarchyGetParent.CachedParent = 0x34 // FCachedRigElement (Size: 0x14)
RigUnit_HierarchyGetParents.Child = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_HierarchyGetParents.bIncludeChild = 0x14 // bool (Size: 0x1)
RigUnit_HierarchyGetParents.bReverse = 0x15 // bool (Size: 0x1)
RigUnit_HierarchyGetParents.Parents = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_HierarchyGetParents.CachedChild = 0x28 // FCachedRigElement (Size: 0x14)
RigUnit_HierarchyGetParents.CachedParents = 0x40 // FRigElementKeyCollection (Size: 0x10)
RigUnit_HierarchyGetSiblings.item = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_HierarchyGetSiblings.bIncludeItem = 0x14 // bool (Size: 0x1)
RigUnit_HierarchyGetSiblings.Siblings = 0x18 // FRigElementKeyCollection (Size: 0x10)
RigUnit_HierarchyGetSiblings.CachedItem = 0x28 // FCachedRigElement (Size: 0x14)
RigUnit_HierarchyGetSiblings.CachedSiblings = 0x40 // FRigElementKeyCollection (Size: 0x10)
RigUnit_InverseExecution.ExecuteContext = 0x8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_IsInteracting.bIsInteracting = 0x8 // bool (Size: 0x1)
RigUnit_Item.item = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_ItemExists.item = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_ItemExists.Exists = 0x14 // bool (Size: 0x1)
RigUnit_ItemExists.CachedIndex = 0x18 // FCachedRigElement (Size: 0x14)
RigUnit_ItemHarmonics.Targets = 0x68 // TArray<FRigUnit_Harmonics_TargetItem> (Size: 0x10)
RigUnit_ItemHarmonics.WaveSpeed = 0x78 // FVector (Size: 0xc)
RigUnit_ItemHarmonics.WaveFrequency = 0x84 // FVector (Size: 0xc)
RigUnit_ItemHarmonics.WaveAmplitude = 0x90 // FVector (Size: 0xc)
RigUnit_ItemHarmonics.WaveOffset = 0x9c // FVector (Size: 0xc)
RigUnit_ItemHarmonics.WaveNoise = 0xa8 // FVector (Size: 0xc)
RigUnit_ItemHarmonics.WaveEase = 0xb4 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_ItemHarmonics.WaveMinimum = 0xb8 // float (Size: 0x4)
RigUnit_ItemHarmonics.WaveMaximum = 0xbc // float (Size: 0x4)
RigUnit_ItemHarmonics.RotationOrder = 0xc0 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_ItemHarmonics.WorkData = 0xc8 // FRigUnit_BoneHarmonics_WorkData (Size: 0x20)
RigUnit_ItemReplace.item = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_ItemReplace.Old = 0x14 // FName (Size: 0x8)
RigUnit_ItemReplace.New = 0x1c // FName (Size: 0x8)
RigUnit_ItemReplace.Result = 0x24 // FRigElementKey (Size: 0xc)
RigUnit_KalmanFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_KalmanFloat.BufferSize = 0xc // int32_t (Size: 0x4)
RigUnit_KalmanFloat.Result = 0x10 // float (Size: 0x4)
RigUnit_KalmanFloat.Buffer = 0x18 // TArray<float> (Size: 0x10)
RigUnit_KalmanFloat.LastInsertIndex = 0x28 // int32_t (Size: 0x4)
RigUnit_KalmanTransform.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_KalmanTransform.BufferSize = 0x40 // int32_t (Size: 0x4)
RigUnit_KalmanTransform.Result = 0x50 // FTransform (Size: 0x30)
RigUnit_KalmanTransform.Buffer = 0x80 // TArray<FTransform> (Size: 0x10)
RigUnit_KalmanTransform.LastInsertIndex = 0x90 // int32_t (Size: 0x4)
RigUnit_KalmanVector.Value = 0x8 // FVector (Size: 0xc)
RigUnit_KalmanVector.BufferSize = 0x14 // int32_t (Size: 0x4)
RigUnit_KalmanVector.Result = 0x18 // FVector (Size: 0xc)
RigUnit_KalmanVector.Buffer = 0x28 // TArray<FVector> (Size: 0x10)
RigUnit_KalmanVector.LastInsertIndex = 0x38 // int32_t (Size: 0x4)
RigUnit_MapRange_Float.Value = 0x8 // float (Size: 0x4)
RigUnit_MapRange_Float.MinIn = 0xc // float (Size: 0x4)
RigUnit_MapRange_Float.MaxIn = 0x10 // float (Size: 0x4)
RigUnit_MapRange_Float.MinOut = 0x14 // float (Size: 0x4)
RigUnit_MapRange_Float.MaxOut = 0x18 // float (Size: 0x4)
RigUnit_MapRange_Float.Result = 0x1c // float (Size: 0x4)
RigUnit_MathBoolBinaryOp.A = 0x8 // bool (Size: 0x1)
RigUnit_MathBoolBinaryOp.B = 0x9 // bool (Size: 0x1)
RigUnit_MathBoolBinaryOp.Result = 0xa // bool (Size: 0x1)
RigUnit_MathBoolConstant.Value = 0x8 // bool (Size: 0x1)
RigUnit_MathBoolEquals.A = 0x8 // bool (Size: 0x1)
RigUnit_MathBoolEquals.B = 0x9 // bool (Size: 0x1)
RigUnit_MathBoolEquals.Result = 0xa // bool (Size: 0x1)
RigUnit_MathBoolNotEquals.A = 0x8 // bool (Size: 0x1)
RigUnit_MathBoolNotEquals.B = 0x9 // bool (Size: 0x1)
RigUnit_MathBoolNotEquals.Result = 0xa // bool (Size: 0x1)
RigUnit_MathBoolUnaryOp.Value = 0x8 // bool (Size: 0x1)
RigUnit_MathBoolUnaryOp.Result = 0x9 // bool (Size: 0x1)
RigUnit_MathColorBinaryOp.A = 0x8 // FLinearColor (Size: 0x10)
RigUnit_MathColorBinaryOp.B = 0x18 // FLinearColor (Size: 0x10)
RigUnit_MathColorBinaryOp.Result = 0x28 // FLinearColor (Size: 0x10)
RigUnit_MathColorFromFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_MathColorFromFloat.Result = 0xc // FLinearColor (Size: 0x10)
RigUnit_MathColorLerp.A = 0x8 // FLinearColor (Size: 0x10)
RigUnit_MathColorLerp.B = 0x18 // FLinearColor (Size: 0x10)
RigUnit_MathColorLerp.T = 0x28 // float (Size: 0x4)
RigUnit_MathColorLerp.Result = 0x2c // FLinearColor (Size: 0x10)
RigUnit_MathFloatBinaryOp.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatBinaryOp.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatBinaryOp.Result = 0x10 // float (Size: 0x4)
RigUnit_MathFloatCeil.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatCeil.Result = 0xc // float (Size: 0x4)
RigUnit_MathFloatCeil.Int = 0x10 // int32_t (Size: 0x4)
RigUnit_MathFloatClamp.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatClamp.Minimum = 0xc // float (Size: 0x4)
RigUnit_MathFloatClamp.Maximum = 0x10 // float (Size: 0x4)
RigUnit_MathFloatClamp.Result = 0x14 // float (Size: 0x4)
RigUnit_MathFloatConstant.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatEquals.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatEquals.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatEquals.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatFloor.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatFloor.Result = 0xc // float (Size: 0x4)
RigUnit_MathFloatFloor.Int = 0x10 // int32_t (Size: 0x4)
RigUnit_MathFloatGreater.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatGreater.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatGreater.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatGreaterEqual.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatGreaterEqual.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatGreaterEqual.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatIsNearlyEqual.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatIsNearlyEqual.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatIsNearlyEqual.Tolerance = 0x10 // float (Size: 0x4)
RigUnit_MathFloatIsNearlyEqual.Result = 0x14 // bool (Size: 0x1)
RigUnit_MathFloatIsNearlyZero.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatIsNearlyZero.Tolerance = 0xc // float (Size: 0x4)
RigUnit_MathFloatIsNearlyZero.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatLawOfCosine.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.C = 0x10 // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.AlphaAngle = 0x14 // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.BetaAngle = 0x18 // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.GammaAngle = 0x1c // float (Size: 0x4)
RigUnit_MathFloatLawOfCosine.bValid = 0x20 // bool (Size: 0x1)
RigUnit_MathFloatLerp.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatLerp.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatLerp.T = 0x10 // float (Size: 0x4)
RigUnit_MathFloatLerp.Result = 0x14 // float (Size: 0x4)
RigUnit_MathFloatLess.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatLess.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatLess.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatLessEqual.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatLessEqual.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatLessEqual.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatNotEquals.A = 0x8 // float (Size: 0x4)
RigUnit_MathFloatNotEquals.B = 0xc // float (Size: 0x4)
RigUnit_MathFloatNotEquals.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathFloatRemap.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatRemap.SourceMinimum = 0xc // float (Size: 0x4)
RigUnit_MathFloatRemap.SourceMaximum = 0x10 // float (Size: 0x4)
RigUnit_MathFloatRemap.TargetMinimum = 0x14 // float (Size: 0x4)
RigUnit_MathFloatRemap.TargetMaximum = 0x18 // float (Size: 0x4)
RigUnit_MathFloatRemap.bClamp = 0x1c // bool (Size: 0x1)
RigUnit_MathFloatRemap.Result = 0x20 // float (Size: 0x4)
RigUnit_MathFloatRound.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatRound.Result = 0xc // float (Size: 0x4)
RigUnit_MathFloatRound.Int = 0x10 // int32_t (Size: 0x4)
RigUnit_MathFloatSelectBool.Condition = 0x8 // bool (Size: 0x1)
RigUnit_MathFloatSelectBool.IfTrue = 0xc // float (Size: 0x4)
RigUnit_MathFloatSelectBool.IfFalse = 0x10 // float (Size: 0x4)
RigUnit_MathFloatSelectBool.Result = 0x14 // float (Size: 0x4)
RigUnit_MathFloatToInt.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatToInt.Result = 0xc // int32_t (Size: 0x4)
RigUnit_MathFloatUnaryOp.Value = 0x8 // float (Size: 0x4)
RigUnit_MathFloatUnaryOp.Result = 0xc // float (Size: 0x4)
RigUnit_MathIntBinaryOp.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntBinaryOp.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntBinaryOp.Result = 0x10 // int32_t (Size: 0x4)
RigUnit_MathIntClamp.Value = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntClamp.Minimum = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntClamp.Maximum = 0x10 // int32_t (Size: 0x4)
RigUnit_MathIntClamp.Result = 0x14 // int32_t (Size: 0x4)
RigUnit_MathIntEquals.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntEquals.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntEquals.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntGreater.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntGreater.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntGreater.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntGreaterEqual.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntGreaterEqual.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntGreaterEqual.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntLess.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntLess.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntLess.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntLessEqual.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntLessEqual.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntLessEqual.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntNotEquals.A = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntNotEquals.B = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntNotEquals.Result = 0x10 // bool (Size: 0x1)
RigUnit_MathIntToFloat.Value = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntToFloat.Result = 0xc // float (Size: 0x4)
RigUnit_MathIntUnaryOp.Value = 0x8 // int32_t (Size: 0x4)
RigUnit_MathIntUnaryOp.Result = 0xc // int32_t (Size: 0x4)
RigUnit_MathIntersectPlane.Start = 0x8 // FVector (Size: 0xc)
RigUnit_MathIntersectPlane.Direction = 0x14 // FVector (Size: 0xc)
RigUnit_MathIntersectPlane.PlanePoint = 0x20 // FVector (Size: 0xc)
RigUnit_MathIntersectPlane.PlaneNormal = 0x2c // FVector (Size: 0xc)
RigUnit_MathIntersectPlane.Result = 0x38 // FVector (Size: 0xc)
RigUnit_MathIntersectPlane.Distance = 0x44 // float (Size: 0x4)
RigUnit_MathQuaternionBinaryOp.A = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionBinaryOp.B = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionBinaryOp.Result = 0x30 // FQuat (Size: 0x10)
RigUnit_MathQuaternionDot.A = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionDot.B = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionDot.Result = 0x30 // float (Size: 0x4)
RigUnit_MathQuaternionEquals.A = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionEquals.B = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionEquals.Result = 0x30 // bool (Size: 0x1)
RigUnit_MathQuaternionFromAxisAndAngle.Axis = 0x8 // FVector (Size: 0xc)
RigUnit_MathQuaternionFromAxisAndAngle.Angle = 0x14 // float (Size: 0x4)
RigUnit_MathQuaternionFromAxisAndAngle.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionFromEuler.Euler = 0x8 // FVector (Size: 0xc)
RigUnit_MathQuaternionFromEuler.RotationOrder = 0x14 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_MathQuaternionFromEuler.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionFromRotator.Rotator = 0x8 // FRotator (Size: 0xc)
RigUnit_MathQuaternionFromRotator.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionFromTwoVectors.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathQuaternionFromTwoVectors.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathQuaternionFromTwoVectors.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionGetAxis.Quaternion = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionGetAxis.Axis = 0x20 // uint8_t (Size: 0x1)
RigUnit_MathQuaternionGetAxis.Result = 0x24 // FVector (Size: 0xc)
RigUnit_MathQuaternionNotEquals.A = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionNotEquals.B = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionNotEquals.Result = 0x30 // bool (Size: 0x1)
RigUnit_MathQuaternionRotateVector.Quaternion = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionRotateVector.Vector = 0x20 // FVector (Size: 0xc)
RigUnit_MathQuaternionRotateVector.Result = 0x2c // FVector (Size: 0xc)
RigUnit_MathQuaternionRotationOrder.RotationOrder = 0x8 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_MathQuaternionScale.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionScale.Scale = 0x20 // float (Size: 0x4)
RigUnit_MathQuaternionSelectBool.Condition = 0x8 // bool (Size: 0x1)
RigUnit_MathQuaternionSelectBool.IfTrue = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSelectBool.IfFalse = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSelectBool.Result = 0x30 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSlerp.A = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSlerp.B = 0x20 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSlerp.T = 0x30 // float (Size: 0x4)
RigUnit_MathQuaternionSlerp.Result = 0x40 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSwingTwist.Input = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSwingTwist.TwistAxis = 0x20 // FVector (Size: 0xc)
RigUnit_MathQuaternionSwingTwist.Swing = 0x30 // FQuat (Size: 0x10)
RigUnit_MathQuaternionSwingTwist.Twist = 0x40 // FQuat (Size: 0x10)
RigUnit_MathQuaternionToAxisAndAngle.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionToAxisAndAngle.Axis = 0x20 // FVector (Size: 0xc)
RigUnit_MathQuaternionToAxisAndAngle.Angle = 0x2c // float (Size: 0x4)
RigUnit_MathQuaternionToEuler.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionToEuler.RotationOrder = 0x20 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_MathQuaternionToEuler.Result = 0x24 // FVector (Size: 0xc)
RigUnit_MathQuaternionToRotator.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionToRotator.Result = 0x20 // FRotator (Size: 0xc)
RigUnit_MathQuaternionUnaryOp.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_MathQuaternionUnaryOp.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_MathRBFInterpolateQuatBase.Input = 0x10 // FQuat (Size: 0x10)
RigUnit_MathRBFInterpolateQuatBase.DistanceFunction = 0x20 // EERBFQuatDistanceType (Size: 0x1)
RigUnit_MathRBFInterpolateQuatBase.SmoothingFunction = 0x21 // EERBFKernelType (Size: 0x1)
RigUnit_MathRBFInterpolateQuatBase.SmoothingAngle = 0x24 // float (Size: 0x4)
RigUnit_MathRBFInterpolateQuatBase.bNormalizeOutput = 0x28 // bool (Size: 0x1)
RigUnit_MathRBFInterpolateQuatBase.TwistAxis = 0x2c // FVector (Size: 0xc)
RigUnit_MathRBFInterpolateQuatBase.WorkData = 0x40 // FRigUnit_MathRBFInterpolateQuatWorkData (Size: 0x90)
RigUnit_MathRBFInterpolateQuatColor.Targets = 0xd0 // TArray<FMathRBFInterpolateQuatColor_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateQuatColor.Output = 0xe0 // FLinearColor (Size: 0x10)
RigUnit_MathRBFInterpolateQuatFloat.Targets = 0xd0 // TArray<FMathRBFInterpolateQuatFloat_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateQuatFloat.Output = 0xe0 // float (Size: 0x4)
RigUnit_MathRBFInterpolateQuatQuat.Targets = 0xd0 // TArray<FMathRBFInterpolateQuatQuat_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateQuatQuat.Output = 0xe0 // FQuat (Size: 0x10)
RigUnit_MathRBFInterpolateQuatVector.Targets = 0xd0 // TArray<FMathRBFInterpolateQuatVector_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateQuatVector.Output = 0xe0 // FVector (Size: 0xc)
RigUnit_MathRBFInterpolateQuatXform.Targets = 0xd0 // TArray<FMathRBFInterpolateQuatXform_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateQuatXform.Output = 0xe0 // FTransform (Size: 0x30)
RigUnit_MathRBFInterpolateVectorBase.Input = 0x8 // FVector (Size: 0xc)
RigUnit_MathRBFInterpolateVectorBase.DistanceFunction = 0x14 // EERBFVectorDistanceType (Size: 0x1)
RigUnit_MathRBFInterpolateVectorBase.SmoothingFunction = 0x15 // EERBFKernelType (Size: 0x1)
RigUnit_MathRBFInterpolateVectorBase.SmoothingRadius = 0x18 // float (Size: 0x4)
RigUnit_MathRBFInterpolateVectorBase.bNormalizeOutput = 0x1c // bool (Size: 0x1)
RigUnit_MathRBFInterpolateVectorBase.WorkData = 0x20 // FRigUnit_MathRBFInterpolateVectorWorkData (Size: 0x90)
RigUnit_MathRBFInterpolateVectorColor.Targets = 0xb0 // TArray<FMathRBFInterpolateVectorColor_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateVectorColor.Output = 0xc0 // FLinearColor (Size: 0x10)
RigUnit_MathRBFInterpolateVectorFloat.Targets = 0xb0 // TArray<FMathRBFInterpolateVectorFloat_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateVectorFloat.Output = 0xc0 // float (Size: 0x4)
RigUnit_MathRBFInterpolateVectorQuat.Targets = 0xb0 // TArray<FMathRBFInterpolateVectorQuat_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateVectorQuat.Output = 0xc0 // FQuat (Size: 0x10)
RigUnit_MathRBFInterpolateVectorVector.Targets = 0xb0 // TArray<FMathRBFInterpolateVectorVector_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateVectorVector.Output = 0xc0 // FVector (Size: 0xc)
RigUnit_MathRBFInterpolateVectorXform.Targets = 0xb0 // TArray<FMathRBFInterpolateVectorXform_Target> (Size: 0x10)
RigUnit_MathRBFInterpolateVectorXform.Output = 0xc0 // FTransform (Size: 0x30)
RigUnit_MathTransformBinaryOp.A = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformBinaryOp.B = 0x40 // FTransform (Size: 0x30)
RigUnit_MathTransformBinaryOp.Result = 0x70 // FTransform (Size: 0x30)
RigUnit_MathTransformClampSpatially.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformClampSpatially.Axis = 0x40 // uint8_t (Size: 0x1)
RigUnit_MathTransformClampSpatially.Type = 0x41 // uint8_t (Size: 0x1)
RigUnit_MathTransformClampSpatially.Minimum = 0x44 // float (Size: 0x4)
RigUnit_MathTransformClampSpatially.Maximum = 0x48 // float (Size: 0x4)
RigUnit_MathTransformClampSpatially.Space = 0x50 // FTransform (Size: 0x30)
RigUnit_MathTransformClampSpatially.bDrawDebug = 0x80 // bool (Size: 0x1)
RigUnit_MathTransformClampSpatially.DebugColor = 0x84 // FLinearColor (Size: 0x10)
RigUnit_MathTransformClampSpatially.DebugThickness = 0x94 // float (Size: 0x4)
RigUnit_MathTransformClampSpatially.Result = 0xa0 // FTransform (Size: 0x30)
RigUnit_MathTransformFromEulerTransform.EulerTransform = 0x8 // FEulerTransform (Size: 0x24)
RigUnit_MathTransformFromEulerTransform.Result = 0x30 // FTransform (Size: 0x30)
RigUnit_MathTransformFromSRT.Location = 0x8 // FVector (Size: 0xc)
RigUnit_MathTransformFromSRT.Rotation = 0x14 // FVector (Size: 0xc)
RigUnit_MathTransformFromSRT.RotationOrder = 0x20 // EEControlRigRotationOrder (Size: 0x1)
RigUnit_MathTransformFromSRT.Scale = 0x24 // FVector (Size: 0xc)
RigUnit_MathTransformFromSRT.Transform = 0x30 // FTransform (Size: 0x30)
RigUnit_MathTransformFromSRT.EulerTransform = 0x60 // FEulerTransform (Size: 0x24)
RigUnit_MathTransformLerp.A = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformLerp.B = 0x40 // FTransform (Size: 0x30)
RigUnit_MathTransformLerp.T = 0x70 // float (Size: 0x4)
RigUnit_MathTransformLerp.Result = 0x80 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeAbsolute.Local = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeAbsolute.Parent = 0x40 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeAbsolute.Global = 0x70 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeRelative.Global = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeRelative.Parent = 0x40 // FTransform (Size: 0x30)
RigUnit_MathTransformMakeRelative.Local = 0x70 // FTransform (Size: 0x30)
RigUnit_MathTransformRotateVector.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformRotateVector.Direction = 0x40 // FVector (Size: 0xc)
RigUnit_MathTransformRotateVector.Result = 0x4c // FVector (Size: 0xc)
RigUnit_MathTransformSelectBool.Condition = 0x8 // bool (Size: 0x1)
RigUnit_MathTransformSelectBool.IfTrue = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformSelectBool.IfFalse = 0x40 // FTransform (Size: 0x30)
RigUnit_MathTransformSelectBool.Result = 0x70 // FTransform (Size: 0x30)
RigUnit_MathTransformToEulerTransform.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformToEulerTransform.Result = 0x40 // FEulerTransform (Size: 0x24)
RigUnit_MathTransformTransformVector.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformTransformVector.Location = 0x40 // FVector (Size: 0xc)
RigUnit_MathTransformTransformVector.Result = 0x4c // FVector (Size: 0xc)
RigUnit_MathTransformUnaryOp.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_MathTransformUnaryOp.Result = 0x40 // FTransform (Size: 0x30)
RigUnit_MathVectorAngle.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorAngle.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorAngle.Result = 0x20 // float (Size: 0x4)
RigUnit_MathVectorBezierFourPoint.Bezier = 0x8 // FCRFourPointBezier (Size: 0x30)
RigUnit_MathVectorBezierFourPoint.T = 0x38 // float (Size: 0x4)
RigUnit_MathVectorBezierFourPoint.Result = 0x3c // FVector (Size: 0xc)
RigUnit_MathVectorBezierFourPoint.Tangent = 0x48 // FVector (Size: 0xc)
RigUnit_MathVectorBinaryOp.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorBinaryOp.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorBinaryOp.Result = 0x20 // FVector (Size: 0xc)
RigUnit_MathVectorClamp.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorClamp.Minimum = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorClamp.Maximum = 0x20 // FVector (Size: 0xc)
RigUnit_MathVectorClamp.Result = 0x2c // FVector (Size: 0xc)
RigUnit_MathVectorClampLength.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorClampLength.MinimumLength = 0x14 // float (Size: 0x4)
RigUnit_MathVectorClampLength.MaximumLength = 0x18 // float (Size: 0x4)
RigUnit_MathVectorClampLength.Result = 0x1c // FVector (Size: 0xc)
RigUnit_MathVectorClampSpatially.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorClampSpatially.Axis = 0x14 // uint8_t (Size: 0x1)
RigUnit_MathVectorClampSpatially.Type = 0x15 // uint8_t (Size: 0x1)
RigUnit_MathVectorClampSpatially.Minimum = 0x18 // float (Size: 0x4)
RigUnit_MathVectorClampSpatially.Maximum = 0x1c // float (Size: 0x4)
RigUnit_MathVectorClampSpatially.Space = 0x20 // FTransform (Size: 0x30)
RigUnit_MathVectorClampSpatially.bDrawDebug = 0x50 // bool (Size: 0x1)
RigUnit_MathVectorClampSpatially.DebugColor = 0x54 // FLinearColor (Size: 0x10)
RigUnit_MathVectorClampSpatially.DebugThickness = 0x64 // float (Size: 0x4)
RigUnit_MathVectorClampSpatially.Result = 0x68 // FVector (Size: 0xc)
RigUnit_MathVectorDistance.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorDistance.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorDistance.Result = 0x20 // float (Size: 0x4)
RigUnit_MathVectorDot.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorDot.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorDot.Result = 0x20 // float (Size: 0x4)
RigUnit_MathVectorEquals.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorEquals.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorEquals.Result = 0x20 // bool (Size: 0x1)
RigUnit_MathVectorFromFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_MathVectorFromFloat.Result = 0xc // FVector (Size: 0xc)
RigUnit_MathVectorIsNearlyEqual.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorIsNearlyEqual.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorIsNearlyEqual.Tolerance = 0x20 // float (Size: 0x4)
RigUnit_MathVectorIsNearlyEqual.Result = 0x24 // bool (Size: 0x1)
RigUnit_MathVectorIsNearlyZero.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorIsNearlyZero.Tolerance = 0x14 // float (Size: 0x4)
RigUnit_MathVectorIsNearlyZero.Result = 0x18 // bool (Size: 0x1)
RigUnit_MathVectorLength.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorLength.Result = 0x14 // float (Size: 0x4)
RigUnit_MathVectorLengthSquared.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorLengthSquared.Result = 0x14 // float (Size: 0x4)
RigUnit_MathVectorLerp.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorLerp.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorLerp.T = 0x20 // float (Size: 0x4)
RigUnit_MathVectorLerp.Result = 0x24 // FVector (Size: 0xc)
RigUnit_MathVectorMakeBezierFourPoint.Bezier = 0x8 // FCRFourPointBezier (Size: 0x30)
RigUnit_MathVectorMirror.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorMirror.Normal = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorMirror.Result = 0x20 // FVector (Size: 0xc)
RigUnit_MathVectorNotEquals.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorNotEquals.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorNotEquals.Result = 0x20 // bool (Size: 0x1)
RigUnit_MathVectorOrthogonal.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorOrthogonal.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorOrthogonal.Result = 0x20 // bool (Size: 0x1)
RigUnit_MathVectorParallel.A = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorParallel.B = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorParallel.Result = 0x20 // bool (Size: 0x1)
RigUnit_MathVectorRemap.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorRemap.SourceMinimum = 0x14 // FVector (Size: 0xc)
RigUnit_MathVectorRemap.SourceMaximum = 0x20 // FVector (Size: 0xc)
RigUnit_MathVectorRemap.TargetMinimum = 0x2c // FVector (Size: 0xc)
RigUnit_MathVectorRemap.TargetMaximum = 0x38 // FVector (Size: 0xc)
RigUnit_MathVectorRemap.bClamp = 0x44 // bool (Size: 0x1)
RigUnit_MathVectorRemap.Result = 0x48 // FVector (Size: 0xc)
RigUnit_MathVectorScale.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorScale.Factor = 0x14 // float (Size: 0x4)
RigUnit_MathVectorScale.Result = 0x18 // FVector (Size: 0xc)
RigUnit_MathVectorSelectBool.Condition = 0x8 // bool (Size: 0x1)
RigUnit_MathVectorSelectBool.IfTrue = 0xc // FVector (Size: 0xc)
RigUnit_MathVectorSelectBool.IfFalse = 0x18 // FVector (Size: 0xc)
RigUnit_MathVectorSelectBool.Result = 0x24 // FVector (Size: 0xc)
RigUnit_MathVectorSetLength.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorSetLength.Length = 0x14 // float (Size: 0x4)
RigUnit_MathVectorSetLength.Result = 0x18 // FVector (Size: 0xc)
RigUnit_MathVectorUnaryOp.Value = 0x8 // FVector (Size: 0xc)
RigUnit_MathVectorUnaryOp.Result = 0x14 // FVector (Size: 0xc)
RigUnit_ModifyBoneTransforms.BoneToModify = 0x68 // TArray<FRigUnit_ModifyBoneTransforms_PerBone> (Size: 0x10)
RigUnit_ModifyBoneTransforms.Weight = 0x78 // float (Size: 0x4)
RigUnit_ModifyBoneTransforms.WeightMinimum = 0x7c // float (Size: 0x4)
RigUnit_ModifyBoneTransforms.WeightMaximum = 0x80 // float (Size: 0x4)
RigUnit_ModifyBoneTransforms.Mode = 0x84 // EEControlRigModifyBoneMode (Size: 0x1)
RigUnit_ModifyBoneTransforms.WorkData = 0x88 // FRigUnit_ModifyBoneTransforms_WorkData (Size: 0x10)
RigUnit_ModifyBoneTransforms_PerBone.Bone = 0x0 // FName (Size: 0x8)
RigUnit_ModifyBoneTransforms_PerBone.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_ModifyTransforms.ItemToModify = 0x68 // TArray<FRigUnit_ModifyTransforms_PerItem> (Size: 0x10)
RigUnit_ModifyTransforms.Weight = 0x78 // float (Size: 0x4)
RigUnit_ModifyTransforms.WeightMinimum = 0x7c // float (Size: 0x4)
RigUnit_ModifyTransforms.WeightMaximum = 0x80 // float (Size: 0x4)
RigUnit_ModifyTransforms.Mode = 0x84 // EEControlRigModifyBoneMode (Size: 0x1)
RigUnit_ModifyTransforms.WorkData = 0x88 // FRigUnit_ModifyTransforms_WorkData (Size: 0x10)
RigUnit_ModifyTransforms_PerItem.item = 0x0 // FRigElementKey (Size: 0xc)
RigUnit_ModifyTransforms_PerItem.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_ModifyTransforms_WorkData.CachedItems = 0x0 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_MultiFABRIK.RootBone = 0x68 // FName (Size: 0x8)
RigUnit_MultiFABRIK.Effectors = 0x70 // TArray<FRigUnit_MultiFABRIK_EndEffector> (Size: 0x10)
RigUnit_MultiFABRIK.Precision = 0x80 // float (Size: 0x4)
RigUnit_MultiFABRIK.bPropagateToChildren = 0x84 // bool (Size: 0x1)
RigUnit_MultiFABRIK.MaxIterations = 0x88 // int32_t (Size: 0x4)
RigUnit_MultiFABRIK.WorkData = 0x90 // FRigUnit_MultiFABRIK_WorkData (Size: 0x60)
RigUnit_MultiFABRIK_EndEffector.Bone = 0x0 // FName (Size: 0x8)
RigUnit_MultiFABRIK_EndEffector.Location = 0x8 // FVector (Size: 0xc)
RigUnit_NameConcat.A = 0x8 // FName (Size: 0x8)
RigUnit_NameConcat.B = 0x10 // FName (Size: 0x8)
RigUnit_NameConcat.Result = 0x18 // FName (Size: 0x8)
RigUnit_NameReplace.Name = 0x8 // FName (Size: 0x8)
RigUnit_NameReplace.Old = 0x10 // FName (Size: 0x8)
RigUnit_NameReplace.New = 0x18 // FName (Size: 0x8)
RigUnit_NameReplace.Result = 0x20 // FName (Size: 0x8)
RigUnit_NameTruncate.Name = 0x8 // FName (Size: 0x8)
RigUnit_NameTruncate.Count = 0x10 // int32_t (Size: 0x4)
RigUnit_NameTruncate.FromEnd = 0x14 // bool (Size: 0x1)
RigUnit_NameTruncate.Remainder = 0x18 // FName (Size: 0x8)
RigUnit_NameTruncate.Chopped = 0x20 // FName (Size: 0x8)
RigUnit_NoiseFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_NoiseFloat.Speed = 0xc // float (Size: 0x4)
RigUnit_NoiseFloat.Frequency = 0x10 // float (Size: 0x4)
RigUnit_NoiseFloat.Minimum = 0x14 // float (Size: 0x4)
RigUnit_NoiseFloat.Maximum = 0x18 // float (Size: 0x4)
RigUnit_NoiseFloat.Result = 0x1c // float (Size: 0x4)
RigUnit_NoiseFloat.Time = 0x20 // float (Size: 0x4)
RigUnit_NoiseVector.position = 0x8 // FVector (Size: 0xc)
RigUnit_NoiseVector.Speed = 0x14 // FVector (Size: 0xc)
RigUnit_NoiseVector.Frequency = 0x20 // FVector (Size: 0xc)
RigUnit_NoiseVector.Minimum = 0x2c // float (Size: 0x4)
RigUnit_NoiseVector.Maximum = 0x30 // float (Size: 0x4)
RigUnit_NoiseVector.Result = 0x34 // FVector (Size: 0xc)
RigUnit_NoiseVector.Time = 0x40 // FVector (Size: 0xc)
RigUnit_OffsetTransformForItem.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_OffsetTransformForItem.OffsetTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_OffsetTransformForItem.Weight = 0xb0 // float (Size: 0x4)
RigUnit_OffsetTransformForItem.bPropagateToChildren = 0xb4 // bool (Size: 0x1)
RigUnit_OffsetTransformForItem.CachedIndex = 0xb8 // FCachedRigElement (Size: 0x14)
RigUnit_ParentSwitchConstraint.Subject = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_ParentSwitchConstraint.ParentIndex = 0x74 // int32_t (Size: 0x4)
RigUnit_ParentSwitchConstraint.Parents = 0x78 // FRigElementKeyCollection (Size: 0x10)
RigUnit_ParentSwitchConstraint.InitialGlobalTransform = 0x90 // FTransform (Size: 0x30)
RigUnit_ParentSwitchConstraint.Weight = 0xc0 // float (Size: 0x4)
RigUnit_ParentSwitchConstraint.Transform = 0xd0 // FTransform (Size: 0x30)
RigUnit_ParentSwitchConstraint.Switched = 0x100 // bool (Size: 0x1)
RigUnit_ParentSwitchConstraint.CachedSubject = 0x104 // FCachedRigElement (Size: 0x14)
RigUnit_ParentSwitchConstraint.CachedParent = 0x118 // FCachedRigElement (Size: 0x14)
RigUnit_ParentSwitchConstraint.RelativeOffset = 0x130 // FTransform (Size: 0x30)
RigUnit_PointSimulation.Points = 0x68 // TArray<FCRSimPoint> (Size: 0x10)
RigUnit_PointSimulation.Links = 0x78 // TArray<FCRSimLinearSpring> (Size: 0x10)
RigUnit_PointSimulation.Forces = 0x88 // TArray<FCRSimPointForce> (Size: 0x10)
RigUnit_PointSimulation.CollisionVolumes = 0x98 // TArray<FCRSimSoftCollision> (Size: 0x10)
RigUnit_PointSimulation.SimulatedStepsPerSecond = 0xa8 // float (Size: 0x4)
RigUnit_PointSimulation.IntegratorType = 0xac // EECRSimPointIntegrateType (Size: 0x1)
RigUnit_PointSimulation.VerletBlend = 0xb0 // float (Size: 0x4)
RigUnit_PointSimulation.BoneTargets = 0xb8 // TArray<FRigUnit_PointSimulation_BoneTarget> (Size: 0x10)
RigUnit_PointSimulation.bLimitLocalPosition = 0xc8 // bool (Size: 0x1)
RigUnit_PointSimulation.bPropagateToChildren = 0xc9 // bool (Size: 0x1)
RigUnit_PointSimulation.PrimaryAimAxis = 0xcc // FVector (Size: 0xc)
RigUnit_PointSimulation.SecondaryAimAxis = 0xd8 // FVector (Size: 0xc)
RigUnit_PointSimulation.DebugSettings = 0xf0 // FRigUnit_PointSimulation_DebugSettings (Size: 0x50)
RigUnit_PointSimulation.Bezier = 0x140 // FCRFourPointBezier (Size: 0x30)
RigUnit_PointSimulation.WorkData = 0x170 // FRigUnit_PointSimulation_WorkData (Size: 0x88)
RigUnit_PointSimulation_BoneTarget.Bone = 0x0 // FName (Size: 0x8)
RigUnit_PointSimulation_BoneTarget.TranslationPoint = 0x8 // int32_t (Size: 0x4)
RigUnit_PointSimulation_BoneTarget.PrimaryAimPoint = 0xc // int32_t (Size: 0x4)
RigUnit_PointSimulation_BoneTarget.SecondaryAimPoint = 0x10 // int32_t (Size: 0x4)
RigUnit_PointSimulation_DebugSettings.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_PointSimulation_DebugSettings.Scale = 0x4 // float (Size: 0x4)
RigUnit_PointSimulation_DebugSettings.CollisionScale = 0x8 // float (Size: 0x4)
RigUnit_PointSimulation_DebugSettings.bDrawPointsAsSpheres = 0xc // bool (Size: 0x1)
RigUnit_PointSimulation_DebugSettings.Color = 0x10 // FLinearColor (Size: 0x10)
RigUnit_PointSimulation_DebugSettings.WorldOffset = 0x20 // FTransform (Size: 0x30)
RigUnit_PointSimulation_WorkData.Simulation = 0x0 // FCRSimPointContainer (Size: 0x78)
RigUnit_PointSimulation_WorkData.BoneIndices = 0x78 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_PrepareForExecution.ExecuteContext = 0x8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_ProjectTransformToNewParent.Child = 0x8 // FRigElementKey (Size: 0xc)
RigUnit_ProjectTransformToNewParent.bChildInitial = 0x14 // bool (Size: 0x1)
RigUnit_ProjectTransformToNewParent.OldParent = 0x18 // FRigElementKey (Size: 0xc)
RigUnit_ProjectTransformToNewParent.bOldParentInitial = 0x24 // bool (Size: 0x1)
RigUnit_ProjectTransformToNewParent.NewParent = 0x28 // FRigElementKey (Size: 0xc)
RigUnit_ProjectTransformToNewParent.bNewParentInitial = 0x34 // bool (Size: 0x1)
RigUnit_ProjectTransformToNewParent.Transform = 0x40 // FTransform (Size: 0x30)
RigUnit_ProjectTransformToNewParent.CachedChild = 0x70 // FCachedRigElement (Size: 0x14)
RigUnit_ProjectTransformToNewParent.CachedOldParent = 0x84 // FCachedRigElement (Size: 0x14)
RigUnit_ProjectTransformToNewParent.CachedNewParent = 0x98 // FCachedRigElement (Size: 0x14)
RigUnit_PropagateTransform.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_PropagateTransform.bRecomputeGlobal = 0x74 // bool (Size: 0x1)
RigUnit_PropagateTransform.bApplyToChildren = 0x75 // bool (Size: 0x1)
RigUnit_PropagateTransform.bRecursive = 0x76 // bool (Size: 0x1)
RigUnit_PropagateTransform.CachedIndex = 0x78 // FCachedRigElement (Size: 0x14)
RigUnit_QuaternionFromAxisAndAngle.Axis = 0x8 // FVector (Size: 0xc)
RigUnit_QuaternionFromAxisAndAngle.Angle = 0x14 // float (Size: 0x4)
RigUnit_QuaternionFromAxisAndAngle.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_QuaternionToAngle.Axis = 0x8 // FVector (Size: 0xc)
RigUnit_QuaternionToAngle.Argument = 0x20 // FQuat (Size: 0x10)
RigUnit_QuaternionToAngle.Angle = 0x30 // float (Size: 0x4)
RigUnit_QuaternionToAxisAndAngle.Argument = 0x10 // FQuat (Size: 0x10)
RigUnit_QuaternionToAxisAndAngle.Axis = 0x20 // FVector (Size: 0xc)
RigUnit_QuaternionToAxisAndAngle.Angle = 0x2c // float (Size: 0x4)
RigUnit_RandomFloat.Seed = 0x8 // int32_t (Size: 0x4)
RigUnit_RandomFloat.Minimum = 0xc // float (Size: 0x4)
RigUnit_RandomFloat.Maximum = 0x10 // float (Size: 0x4)
RigUnit_RandomFloat.Duration = 0x14 // float (Size: 0x4)
RigUnit_RandomFloat.Result = 0x18 // float (Size: 0x4)
RigUnit_RandomFloat.LastResult = 0x1c // float (Size: 0x4)
RigUnit_RandomFloat.LastSeed = 0x20 // int32_t (Size: 0x4)
RigUnit_RandomFloat.TimeLeft = 0x24 // float (Size: 0x4)
RigUnit_RandomVector.Seed = 0x8 // int32_t (Size: 0x4)
RigUnit_RandomVector.Minimum = 0xc // float (Size: 0x4)
RigUnit_RandomVector.Maximum = 0x10 // float (Size: 0x4)
RigUnit_RandomVector.Duration = 0x14 // float (Size: 0x4)
RigUnit_RandomVector.Result = 0x18 // FVector (Size: 0xc)
RigUnit_RandomVector.LastResult = 0x24 // FVector (Size: 0xc)
RigUnit_RandomVector.LastSeed = 0x30 // int32_t (Size: 0x4)
RigUnit_RandomVector.TimeLeft = 0x34 // float (Size: 0x4)
RigUnit_SecondsToFrames.Seconds = 0x8 // float (Size: 0x4)
RigUnit_SecondsToFrames.Frames = 0xc // float (Size: 0x4)
RigUnit_SendEvent.Event = 0x68 // EERigEvent (Size: 0x1)
RigUnit_SendEvent.item = 0x6c // FRigElementKey (Size: 0xc)
RigUnit_SendEvent.OffsetInSeconds = 0x78 // float (Size: 0x4)
RigUnit_SendEvent.bEnable = 0x7c // bool (Size: 0x1)
RigUnit_SendEvent.bOnlyDuringInteraction = 0x7d // bool (Size: 0x1)
RigUnit_SequenceExecution.ExecuteContext = 0x8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_SequenceExecution.A = 0x68 // FControlRigExecuteContext (Size: 0x60)
RigUnit_SequenceExecution.B = 0xc8 // FControlRigExecuteContext (Size: 0x60)
RigUnit_SequenceExecution.C = 0x128 // FControlRigExecuteContext (Size: 0x60)
RigUnit_SequenceExecution.D = 0x188 // FControlRigExecuteContext (Size: 0x60)
RigUnit_SetBoneInitialTransform.Bone = 0x68 // FName (Size: 0x8)
RigUnit_SetBoneInitialTransform.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_SetBoneInitialTransform.Result = 0xa0 // FTransform (Size: 0x30)
RigUnit_SetBoneInitialTransform.Space = 0xd0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetBoneInitialTransform.bPropagateToChildren = 0xd1 // bool (Size: 0x1)
RigUnit_SetBoneInitialTransform.CachedBone = 0xd4 // FCachedRigElement (Size: 0x14)
RigUnit_SetBoneRotation.Bone = 0x68 // FName (Size: 0x8)
RigUnit_SetBoneRotation.Rotation = 0x70 // FQuat (Size: 0x10)
RigUnit_SetBoneRotation.Space = 0x80 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetBoneRotation.Weight = 0x84 // float (Size: 0x4)
RigUnit_SetBoneRotation.bPropagateToChildren = 0x88 // bool (Size: 0x1)
RigUnit_SetBoneRotation.CachedBone = 0x8c // FCachedRigElement (Size: 0x14)
RigUnit_SetBoneTransform.Bone = 0x68 // FName (Size: 0x8)
RigUnit_SetBoneTransform.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_SetBoneTransform.Result = 0xa0 // FTransform (Size: 0x30)
RigUnit_SetBoneTransform.Space = 0xd0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetBoneTransform.Weight = 0xd4 // float (Size: 0x4)
RigUnit_SetBoneTransform.bPropagateToChildren = 0xd8 // bool (Size: 0x1)
RigUnit_SetBoneTransform.CachedBone = 0xdc // FCachedRigElement (Size: 0x14)
RigUnit_SetBoneTranslation.Bone = 0x68 // FName (Size: 0x8)
RigUnit_SetBoneTranslation.Translation = 0x70 // FVector (Size: 0xc)
RigUnit_SetBoneTranslation.Space = 0x7c // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetBoneTranslation.Weight = 0x80 // float (Size: 0x4)
RigUnit_SetBoneTranslation.bPropagateToChildren = 0x84 // bool (Size: 0x1)
RigUnit_SetBoneTranslation.CachedBone = 0x88 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlBool.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlBool.BoolValue = 0x70 // bool (Size: 0x1)
RigUnit_SetControlBool.CachedControlIndex = 0x74 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlColor.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlColor.Color = 0x70 // FLinearColor (Size: 0x10)
RigUnit_SetControlColor.CachedControlIndex = 0x80 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlFloat.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlFloat.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetControlFloat.FloatValue = 0x74 // float (Size: 0x4)
RigUnit_SetControlFloat.CachedControlIndex = 0x78 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlInteger.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlInteger.Weight = 0x70 // int32_t (Size: 0x4)
RigUnit_SetControlInteger.IntegerValue = 0x74 // int32_t (Size: 0x4)
RigUnit_SetControlInteger.CachedControlIndex = 0x78 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlOffset.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlOffset.Offset = 0x70 // FTransform (Size: 0x30)
RigUnit_SetControlOffset.Space = 0xa0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetControlOffset.CachedControlIndex = 0xa4 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlRotator.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlRotator.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetControlRotator.Rotator = 0x74 // FRotator (Size: 0xc)
RigUnit_SetControlRotator.Space = 0x80 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetControlRotator.CachedControlIndex = 0x84 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlTransform.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlTransform.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetControlTransform.Transform = 0x80 // FTransform (Size: 0x30)
RigUnit_SetControlTransform.Space = 0xb0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetControlTransform.CachedControlIndex = 0xb4 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlVector.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlVector.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetControlVector.Vector = 0x74 // FVector (Size: 0xc)
RigUnit_SetControlVector.Space = 0x80 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetControlVector.CachedControlIndex = 0x84 // FCachedRigElement (Size: 0x14)
RigUnit_SetControlVector2D.Control = 0x68 // FName (Size: 0x8)
RigUnit_SetControlVector2D.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetControlVector2D.Vector = 0x74 // FVector2D (Size: 0x8)
RigUnit_SetControlVector2D.CachedControlIndex = 0x7c // FCachedRigElement (Size: 0x14)
RigUnit_SetControlVisibility.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetControlVisibility.Pattern = 0x78 // FString (Size: 0x10)
RigUnit_SetControlVisibility.bVisible = 0x88 // bool (Size: 0x1)
RigUnit_SetControlVisibility.CachedControlIndices = 0x90 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetCurveValue.Curve = 0x68 // FName (Size: 0x8)
RigUnit_SetCurveValue.Value = 0x70 // float (Size: 0x4)
RigUnit_SetCurveValue.CachedCurveIndex = 0x74 // FCachedRigElement (Size: 0x14)
RigUnit_SetMultiControlBool.Entries = 0x68 // TArray<FRigUnit_SetMultiControlBool_Entry> (Size: 0x10)
RigUnit_SetMultiControlBool.CachedControlIndices = 0x78 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetMultiControlBool_Entry.Control = 0x0 // FName (Size: 0x8)
RigUnit_SetMultiControlBool_Entry.BoolValue = 0x8 // bool (Size: 0x1)
RigUnit_SetMultiControlFloat.Entries = 0x68 // TArray<FRigUnit_SetMultiControlFloat_Entry> (Size: 0x10)
RigUnit_SetMultiControlFloat.Weight = 0x78 // float (Size: 0x4)
RigUnit_SetMultiControlFloat.CachedControlIndices = 0x80 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetMultiControlFloat_Entry.Control = 0x0 // FName (Size: 0x8)
RigUnit_SetMultiControlFloat_Entry.FloatValue = 0x8 // float (Size: 0x4)
RigUnit_SetMultiControlInteger.Entries = 0x68 // TArray<FRigUnit_SetMultiControlInteger_Entry> (Size: 0x10)
RigUnit_SetMultiControlInteger.Weight = 0x78 // float (Size: 0x4)
RigUnit_SetMultiControlInteger.CachedControlIndices = 0x80 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetMultiControlInteger_Entry.Control = 0x0 // FName (Size: 0x8)
RigUnit_SetMultiControlInteger_Entry.IntegerValue = 0x8 // int32_t (Size: 0x4)
RigUnit_SetMultiControlRotator.Entries = 0x68 // TArray<FRigUnit_SetMultiControlRotator_Entry> (Size: 0x10)
RigUnit_SetMultiControlRotator.Weight = 0x78 // float (Size: 0x4)
RigUnit_SetMultiControlRotator.CachedControlIndices = 0x80 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetMultiControlRotator_Entry.Control = 0x0 // FName (Size: 0x8)
RigUnit_SetMultiControlRotator_Entry.Rotator = 0x8 // FRotator (Size: 0xc)
RigUnit_SetMultiControlRotator_Entry.Space = 0x14 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetMultiControlVector2D.Entries = 0x68 // TArray<FRigUnit_SetMultiControlVector2D_Entry> (Size: 0x10)
RigUnit_SetMultiControlVector2D.Weight = 0x78 // float (Size: 0x4)
RigUnit_SetMultiControlVector2D.CachedControlIndices = 0x80 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SetMultiControlVector2D_Entry.Control = 0x0 // FName (Size: 0x8)
RigUnit_SetMultiControlVector2D_Entry.Vector = 0x8 // FVector2D (Size: 0x8)
RigUnit_SetRelativeBoneTransform.Bone = 0x68 // FName (Size: 0x8)
RigUnit_SetRelativeBoneTransform.Space = 0x70 // FName (Size: 0x8)
RigUnit_SetRelativeBoneTransform.Transform = 0x80 // FTransform (Size: 0x30)
RigUnit_SetRelativeBoneTransform.Weight = 0xb0 // float (Size: 0x4)
RigUnit_SetRelativeBoneTransform.bPropagateToChildren = 0xb4 // bool (Size: 0x1)
RigUnit_SetRelativeBoneTransform.CachedBone = 0xb8 // FCachedRigElement (Size: 0x14)
RigUnit_SetRelativeBoneTransform.CachedSpaceIndex = 0xcc // FCachedRigElement (Size: 0x14)
RigUnit_SetRelativeTransformForItem.Child = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetRelativeTransformForItem.Parent = 0x74 // FRigElementKey (Size: 0xc)
RigUnit_SetRelativeTransformForItem.bParentInitial = 0x80 // bool (Size: 0x1)
RigUnit_SetRelativeTransformForItem.RelativeTransform = 0x90 // FTransform (Size: 0x30)
RigUnit_SetRelativeTransformForItem.Weight = 0xc0 // float (Size: 0x4)
RigUnit_SetRelativeTransformForItem.bPropagateToChildren = 0xc4 // bool (Size: 0x1)
RigUnit_SetRelativeTransformForItem.CachedChild = 0xc8 // FCachedRigElement (Size: 0x14)
RigUnit_SetRelativeTransformForItem.CachedParent = 0xdc // FCachedRigElement (Size: 0x14)
RigUnit_SetRotation.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetRotation.Space = 0x74 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetRotation.Rotation = 0x80 // FQuat (Size: 0x10)
RigUnit_SetRotation.Weight = 0x90 // float (Size: 0x4)
RigUnit_SetRotation.bPropagateToChildren = 0x94 // bool (Size: 0x1)
RigUnit_SetRotation.CachedIndex = 0x98 // FCachedRigElement (Size: 0x14)
RigUnit_SetScale.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetScale.Space = 0x74 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetScale.Scale = 0x78 // FVector (Size: 0xc)
RigUnit_SetScale.Weight = 0x84 // float (Size: 0x4)
RigUnit_SetScale.bPropagateToChildren = 0x88 // bool (Size: 0x1)
RigUnit_SetScale.CachedIndex = 0x8c // FCachedRigElement (Size: 0x14)
RigUnit_SetSpaceInitialTransform.SpaceName = 0x68 // FName (Size: 0x8)
RigUnit_SetSpaceInitialTransform.Transform = 0x70 // FTransform (Size: 0x30)
RigUnit_SetSpaceInitialTransform.Result = 0xa0 // FTransform (Size: 0x30)
RigUnit_SetSpaceInitialTransform.Space = 0xd0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetSpaceInitialTransform.CachedSpaceIndex = 0xd4 // FCachedRigElement (Size: 0x14)
RigUnit_SetSpaceTransform.Space = 0x68 // FName (Size: 0x8)
RigUnit_SetSpaceTransform.Weight = 0x70 // float (Size: 0x4)
RigUnit_SetSpaceTransform.Transform = 0x80 // FTransform (Size: 0x30)
RigUnit_SetSpaceTransform.SpaceType = 0xb0 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetSpaceTransform.CachedSpaceIndex = 0xb4 // FCachedRigElement (Size: 0x14)
RigUnit_SetTransform.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetTransform.Space = 0x74 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetTransform.bInitial = 0x75 // bool (Size: 0x1)
RigUnit_SetTransform.Transform = 0x80 // FTransform (Size: 0x30)
RigUnit_SetTransform.Weight = 0xb0 // float (Size: 0x4)
RigUnit_SetTransform.bPropagateToChildren = 0xb4 // bool (Size: 0x1)
RigUnit_SetTransform.CachedIndex = 0xb8 // FCachedRigElement (Size: 0x14)
RigUnit_SetTranslation.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_SetTranslation.Space = 0x74 // EEBoneGetterSetterMode (Size: 0x1)
RigUnit_SetTranslation.Translation = 0x78 // FVector (Size: 0xc)
RigUnit_SetTranslation.Weight = 0x84 // float (Size: 0x4)
RigUnit_SetTranslation.bPropagateToChildren = 0x88 // bool (Size: 0x1)
RigUnit_SetTranslation.CachedIndex = 0x8c // FCachedRigElement (Size: 0x14)
RigUnit_SlideChain.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_SlideChain.EndBone = 0x70 // FName (Size: 0x8)
RigUnit_SlideChain.SlideAmount = 0x78 // float (Size: 0x4)
RigUnit_SlideChain.bPropagateToChildren = 0x7c // bool (Size: 0x1)
RigUnit_SlideChain.WorkData = 0x80 // FRigUnit_SlideChain_WorkData (Size: 0x48)
RigUnit_SlideChainPerItem.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_SlideChainPerItem.SlideAmount = 0x78 // float (Size: 0x4)
RigUnit_SlideChainPerItem.bPropagateToChildren = 0x7c // bool (Size: 0x1)
RigUnit_SlideChainPerItem.WorkData = 0x80 // FRigUnit_SlideChain_WorkData (Size: 0x48)
RigUnit_SlideChain_WorkData.ChainLength = 0x0 // float (Size: 0x4)
RigUnit_SlideChain_WorkData.ItemSegments = 0x8 // TArray<float> (Size: 0x10)
RigUnit_SlideChain_WorkData.CachedItems = 0x18 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SlideChain_WorkData.Transforms = 0x28 // TArray<FTransform> (Size: 0x10)
RigUnit_SlideChain_WorkData.BlendedTransforms = 0x38 // TArray<FTransform> (Size: 0x10)
RigUnit_SpaceName.Space = 0x8 // FName (Size: 0x8)
RigUnit_SphereTraceWorld.Start = 0x8 // FVector (Size: 0xc)
RigUnit_SphereTraceWorld.End = 0x14 // FVector (Size: 0xc)
RigUnit_SphereTraceWorld.Channel = 0x20 // uint8_t (Size: 0x1)
RigUnit_SphereTraceWorld.Radius = 0x24 // float (Size: 0x4)
RigUnit_SphereTraceWorld.bHit = 0x28 // bool (Size: 0x1)
RigUnit_SphereTraceWorld.HitLocation = 0x2c // FVector (Size: 0xc)
RigUnit_SphereTraceWorld.HitNormal = 0x38 // FVector (Size: 0xc)
RigUnit_SpringIK.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_SpringIK.EndBone = 0x70 // FName (Size: 0x8)
RigUnit_SpringIK.HierarchyStrength = 0x78 // float (Size: 0x4)
RigUnit_SpringIK.EffectorStrength = 0x7c // float (Size: 0x4)
RigUnit_SpringIK.EffectorRatio = 0x80 // float (Size: 0x4)
RigUnit_SpringIK.RootStrength = 0x84 // float (Size: 0x4)
RigUnit_SpringIK.RootRatio = 0x88 // float (Size: 0x4)
RigUnit_SpringIK.Damping = 0x8c // float (Size: 0x4)
RigUnit_SpringIK.PoleVector = 0x90 // FVector (Size: 0xc)
RigUnit_SpringIK.bFlipPolePlane = 0x9c // bool (Size: 0x1)
RigUnit_SpringIK.PoleVectorKind = 0x9d // EEControlRigVectorKind (Size: 0x1)
RigUnit_SpringIK.PoleVectorSpace = 0xa0 // FName (Size: 0x8)
RigUnit_SpringIK.PrimaryAxis = 0xa8 // FVector (Size: 0xc)
RigUnit_SpringIK.SecondaryAxis = 0xb4 // FVector (Size: 0xc)
RigUnit_SpringIK.bLiveSimulation = 0xc0 // bool (Size: 0x1)
RigUnit_SpringIK.Iterations = 0xc4 // int32_t (Size: 0x4)
RigUnit_SpringIK.bLimitLocalPosition = 0xc8 // bool (Size: 0x1)
RigUnit_SpringIK.bPropagateToChildren = 0xc9 // bool (Size: 0x1)
RigUnit_SpringIK.DebugSettings = 0xd0 // FRigUnit_SpringIK_DebugSettings (Size: 0x50)
RigUnit_SpringIK.WorkData = 0x120 // FRigUnit_SpringIK_WorkData (Size: 0xb0)
RigUnit_SpringIK_DebugSettings.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_SpringIK_DebugSettings.Scale = 0x4 // float (Size: 0x4)
RigUnit_SpringIK_DebugSettings.Color = 0x8 // FLinearColor (Size: 0x10)
RigUnit_SpringIK_DebugSettings.WorldOffset = 0x20 // FTransform (Size: 0x30)
RigUnit_SpringIK_WorkData.BoneIndices = 0x0 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_SpringIK_WorkData.CachedPoleVector = 0x10 // FCachedRigElement (Size: 0x14)
RigUnit_SpringIK_WorkData.Transforms = 0x28 // TArray<FTransform> (Size: 0x10)
RigUnit_SpringIK_WorkData.Simulation = 0x38 // FCRSimPointContainer (Size: 0x78)
RigUnit_StartsWith.Name = 0x8 // FName (Size: 0x8)
RigUnit_StartsWith.Start = 0x10 // FName (Size: 0x8)
RigUnit_StartsWith.Result = 0x18 // bool (Size: 0x1)
RigUnit_TimeOffsetFloat.Value = 0x8 // float (Size: 0x4)
RigUnit_TimeOffsetFloat.SecondsAgo = 0xc // float (Size: 0x4)
RigUnit_TimeOffsetFloat.BufferSize = 0x10 // int32_t (Size: 0x4)
RigUnit_TimeOffsetFloat.TimeRange = 0x14 // float (Size: 0x4)
RigUnit_TimeOffsetFloat.Result = 0x18 // float (Size: 0x4)
RigUnit_TimeOffsetFloat.Buffer = 0x20 // TArray<float> (Size: 0x10)
RigUnit_TimeOffsetFloat.DeltaTimes = 0x30 // TArray<float> (Size: 0x10)
RigUnit_TimeOffsetFloat.LastInsertIndex = 0x40 // int32_t (Size: 0x4)
RigUnit_TimeOffsetFloat.UpperBound = 0x44 // int32_t (Size: 0x4)
RigUnit_TimeOffsetTransform.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_TimeOffsetTransform.SecondsAgo = 0x40 // float (Size: 0x4)
RigUnit_TimeOffsetTransform.BufferSize = 0x44 // int32_t (Size: 0x4)
RigUnit_TimeOffsetTransform.TimeRange = 0x48 // float (Size: 0x4)
RigUnit_TimeOffsetTransform.Result = 0x50 // FTransform (Size: 0x30)
RigUnit_TimeOffsetTransform.Buffer = 0x80 // TArray<FTransform> (Size: 0x10)
RigUnit_TimeOffsetTransform.DeltaTimes = 0x90 // TArray<float> (Size: 0x10)
RigUnit_TimeOffsetTransform.LastInsertIndex = 0xa0 // int32_t (Size: 0x4)
RigUnit_TimeOffsetTransform.UpperBound = 0xa4 // int32_t (Size: 0x4)
RigUnit_TimeOffsetVector.Value = 0x8 // FVector (Size: 0xc)
RigUnit_TimeOffsetVector.SecondsAgo = 0x14 // float (Size: 0x4)
RigUnit_TimeOffsetVector.BufferSize = 0x18 // int32_t (Size: 0x4)
RigUnit_TimeOffsetVector.TimeRange = 0x1c // float (Size: 0x4)
RigUnit_TimeOffsetVector.Result = 0x20 // FVector (Size: 0xc)
RigUnit_TimeOffsetVector.Buffer = 0x30 // TArray<FVector> (Size: 0x10)
RigUnit_TimeOffsetVector.DeltaTimes = 0x40 // TArray<float> (Size: 0x10)
RigUnit_TimeOffsetVector.LastInsertIndex = 0x50 // int32_t (Size: 0x4)
RigUnit_TimeOffsetVector.UpperBound = 0x54 // int32_t (Size: 0x4)
RigUnit_Timeline.Speed = 0x8 // float (Size: 0x4)
RigUnit_Timeline.Time = 0xc // float (Size: 0x4)
RigUnit_Timeline.AccumulatedValue = 0x10 // float (Size: 0x4)
RigUnit_ToRigSpace_Location.Location = 0x8 // FVector (Size: 0xc)
RigUnit_ToRigSpace_Location.Global = 0x14 // FVector (Size: 0xc)
RigUnit_ToRigSpace_Rotation.Rotation = 0x10 // FQuat (Size: 0x10)
RigUnit_ToRigSpace_Rotation.Global = 0x20 // FQuat (Size: 0x10)
RigUnit_ToRigSpace_Transform.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_ToRigSpace_Transform.Global = 0x40 // FTransform (Size: 0x30)
RigUnit_ToSwingAndTwist.Input = 0x10 // FQuat (Size: 0x10)
RigUnit_ToSwingAndTwist.TwistAxis = 0x20 // FVector (Size: 0xc)
RigUnit_ToSwingAndTwist.Swing = 0x30 // FQuat (Size: 0x10)
RigUnit_ToSwingAndTwist.Twist = 0x40 // FQuat (Size: 0x10)
RigUnit_ToWorldSpace_Location.Location = 0x8 // FVector (Size: 0xc)
RigUnit_ToWorldSpace_Location.World = 0x14 // FVector (Size: 0xc)
RigUnit_ToWorldSpace_Rotation.Rotation = 0x10 // FQuat (Size: 0x10)
RigUnit_ToWorldSpace_Rotation.World = 0x20 // FQuat (Size: 0x10)
RigUnit_ToWorldSpace_Transform.Transform = 0x10 // FTransform (Size: 0x30)
RigUnit_ToWorldSpace_Transform.World = 0x40 // FTransform (Size: 0x30)
RigUnit_TransformConstraint.Bone = 0x68 // FName (Size: 0x8)
RigUnit_TransformConstraint.BaseTransformSpace = 0x70 // EETransformSpaceMode (Size: 0x1)
RigUnit_TransformConstraint.BaseTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_TransformConstraint.BaseBone = 0xb0 // FName (Size: 0x8)
RigUnit_TransformConstraint.Targets = 0xb8 // TArray<FConstraintTarget> (Size: 0x10)
RigUnit_TransformConstraint.bUseInitialTransforms = 0xc8 // bool (Size: 0x1)
RigUnit_TransformConstraint.WorkData = 0xd0 // FRigUnit_TransformConstraint_WorkData (Size: 0x60)
RigUnit_TransformConstraintPerItem.item = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_TransformConstraintPerItem.BaseTransformSpace = 0x74 // EETransformSpaceMode (Size: 0x1)
RigUnit_TransformConstraintPerItem.BaseTransform = 0x80 // FTransform (Size: 0x30)
RigUnit_TransformConstraintPerItem.BaseItem = 0xb0 // FRigElementKey (Size: 0xc)
RigUnit_TransformConstraintPerItem.Targets = 0xc0 // TArray<FConstraintTarget> (Size: 0x10)
RigUnit_TransformConstraintPerItem.bUseInitialTransforms = 0xd0 // bool (Size: 0x1)
RigUnit_TransformConstraintPerItem.WorkData = 0xd8 // FRigUnit_TransformConstraint_WorkData (Size: 0x60)
RigUnit_TransformConstraint_WorkData.ConstraintData = 0x0 // TArray<FConstraintData> (Size: 0x10)
RigUnit_TransformConstraint_WorkData.ConstraintDataToTargets = 0x10 // TMap<...> (Size: 0x50)
RigUnit_TwistBones.StartBone = 0x68 // FName (Size: 0x8)
RigUnit_TwistBones.EndBone = 0x70 // FName (Size: 0x8)
RigUnit_TwistBones.TwistAxis = 0x78 // FVector (Size: 0xc)
RigUnit_TwistBones.PoleAxis = 0x84 // FVector (Size: 0xc)
RigUnit_TwistBones.TwistEaseType = 0x90 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_TwistBones.Weight = 0x94 // float (Size: 0x4)
RigUnit_TwistBones.bPropagateToChildren = 0x98 // bool (Size: 0x1)
RigUnit_TwistBones.WorkData = 0xa0 // FRigUnit_TwistBones_WorkData (Size: 0x30)
RigUnit_TwistBonesPerItem.Items = 0x68 // FRigElementKeyCollection (Size: 0x10)
RigUnit_TwistBonesPerItem.TwistAxis = 0x78 // FVector (Size: 0xc)
RigUnit_TwistBonesPerItem.PoleAxis = 0x84 // FVector (Size: 0xc)
RigUnit_TwistBonesPerItem.TwistEaseType = 0x90 // EEControlRigAnimEasingType (Size: 0x1)
RigUnit_TwistBonesPerItem.Weight = 0x94 // float (Size: 0x4)
RigUnit_TwistBonesPerItem.bPropagateToChildren = 0x98 // bool (Size: 0x1)
RigUnit_TwistBonesPerItem.WorkData = 0xa0 // FRigUnit_TwistBones_WorkData (Size: 0x30)
RigUnit_TwistBones_WorkData.CachedItems = 0x0 // TArray<FCachedRigElement> (Size: 0x10)
RigUnit_TwistBones_WorkData.ItemRatios = 0x10 // TArray<float> (Size: 0x10)
RigUnit_TwistBones_WorkData.ItemTransforms = 0x20 // TArray<FTransform> (Size: 0x10)
RigUnit_TwoBoneIKFK.StartJoint = 0x68 // FName (Size: 0x8)
RigUnit_TwoBoneIKFK.EndJoint = 0x70 // FName (Size: 0x8)
RigUnit_TwoBoneIKFK.PoleTarget = 0x78 // FVector (Size: 0xc)
RigUnit_TwoBoneIKFK.Spin = 0x84 // float (Size: 0x4)
RigUnit_TwoBoneIKFK.EndEffector = 0x90 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.IKBlend = 0xc0 // float (Size: 0x4)
RigUnit_TwoBoneIKFK.StartJointFKTransform = 0xd0 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.MidJointFKTransform = 0x100 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.EndJointFKTransform = 0x130 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.PreviousFKIKBlend = 0x160 // float (Size: 0x4)
RigUnit_TwoBoneIKFK.StartJointIKTransform = 0x170 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.MidJointIKTransform = 0x1a0 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.EndJointIKTransform = 0x1d0 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKFK.StartJointIndex = 0x200 // int32_t (Size: 0x4)
RigUnit_TwoBoneIKFK.MidJointIndex = 0x204 // int32_t (Size: 0x4)
RigUnit_TwoBoneIKFK.EndJointIndex = 0x208 // int32_t (Size: 0x4)
RigUnit_TwoBoneIKFK.UpperLimbLength = 0x20c // float (Size: 0x4)
RigUnit_TwoBoneIKFK.LowerLimbLength = 0x210 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.BoneA = 0x68 // FName (Size: 0x8)
RigUnit_TwoBoneIKSimple.BoneB = 0x70 // FName (Size: 0x8)
RigUnit_TwoBoneIKSimple.EffectorBone = 0x78 // FName (Size: 0x8)
RigUnit_TwoBoneIKSimple.Effector = 0x80 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKSimple.PrimaryAxis = 0xb0 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimple.SecondaryAxis = 0xbc // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimple.SecondaryAxisWeight = 0xc8 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.PoleVector = 0xcc // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimple.PoleVectorKind = 0xd8 // EEControlRigVectorKind (Size: 0x1)
RigUnit_TwoBoneIKSimple.PoleVectorSpace = 0xdc // FName (Size: 0x8)
RigUnit_TwoBoneIKSimple.bEnableStretch = 0xe4 // bool (Size: 0x1)
RigUnit_TwoBoneIKSimple.StretchStartRatio = 0xe8 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.StretchMaximumRatio = 0xec // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.Weight = 0xf0 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.BoneALength = 0xf4 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.BoneBLength = 0xf8 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple.bPropagateToChildren = 0xfc // bool (Size: 0x1)
RigUnit_TwoBoneIKSimple.DebugSettings = 0x100 // FRigUnit_TwoBoneIKSimple_DebugSettings (Size: 0x40)
RigUnit_TwoBoneIKSimple.CachedBoneAIndex = 0x140 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimple.CachedBoneBIndex = 0x154 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimple.CachedEffectorBoneIndex = 0x168 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimple.CachedPoleVectorSpaceIndex = 0x17c // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimplePerItem.ItemA = 0x68 // FRigElementKey (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.ItemB = 0x74 // FRigElementKey (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.EffectorItem = 0x80 // FRigElementKey (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.Effector = 0x90 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKSimplePerItem.PrimaryAxis = 0xc0 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.SecondaryAxis = 0xcc // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.SecondaryAxisWeight = 0xd8 // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.PoleVector = 0xdc // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.PoleVectorKind = 0xe8 // EEControlRigVectorKind (Size: 0x1)
RigUnit_TwoBoneIKSimplePerItem.PoleVectorSpace = 0xec // FRigElementKey (Size: 0xc)
RigUnit_TwoBoneIKSimplePerItem.bEnableStretch = 0xf8 // bool (Size: 0x1)
RigUnit_TwoBoneIKSimplePerItem.StretchStartRatio = 0xfc // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.StretchMaximumRatio = 0x100 // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.Weight = 0x104 // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.ItemALength = 0x108 // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.ItemBLength = 0x10c // float (Size: 0x4)
RigUnit_TwoBoneIKSimplePerItem.bPropagateToChildren = 0x110 // bool (Size: 0x1)
RigUnit_TwoBoneIKSimplePerItem.DebugSettings = 0x120 // FRigUnit_TwoBoneIKSimple_DebugSettings (Size: 0x40)
RigUnit_TwoBoneIKSimplePerItem.CachedItemAIndex = 0x160 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimplePerItem.CachedItemBIndex = 0x174 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimplePerItem.CachedEffectorItemIndex = 0x188 // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimplePerItem.CachedPoleVectorSpaceIndex = 0x19c // FCachedRigElement (Size: 0x14)
RigUnit_TwoBoneIKSimpleTransforms.Root = 0x10 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKSimpleTransforms.PoleVector = 0x40 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleTransforms.Effector = 0x50 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKSimpleTransforms.PrimaryAxis = 0x80 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleTransforms.SecondaryAxis = 0x8c // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleTransforms.SecondaryAxisWeight = 0x98 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleTransforms.bEnableStretch = 0x9c // bool (Size: 0x1)
RigUnit_TwoBoneIKSimpleTransforms.StretchStartRatio = 0xa0 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleTransforms.StretchMaximumRatio = 0xa4 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleTransforms.BoneALength = 0xa8 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleTransforms.BoneBLength = 0xac // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleTransforms.Elbow = 0xb0 // FTransform (Size: 0x30)
RigUnit_TwoBoneIKSimpleVectors.Root = 0x8 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleVectors.PoleVector = 0x14 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleVectors.Effector = 0x20 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimpleVectors.bEnableStretch = 0x2c // bool (Size: 0x1)
RigUnit_TwoBoneIKSimpleVectors.StretchStartRatio = 0x30 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleVectors.StretchMaximumRatio = 0x34 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleVectors.BoneALength = 0x38 // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleVectors.BoneBLength = 0x3c // float (Size: 0x4)
RigUnit_TwoBoneIKSimpleVectors.Elbow = 0x40 // FVector (Size: 0xc)
RigUnit_TwoBoneIKSimple_DebugSettings.bEnabled = 0x0 // bool (Size: 0x1)
RigUnit_TwoBoneIKSimple_DebugSettings.Scale = 0x4 // float (Size: 0x4)
RigUnit_TwoBoneIKSimple_DebugSettings.WorldOffset = 0x10 // FTransform (Size: 0x30)
RigUnit_UnaryQuaternionOp.Argument = 0x10 // FQuat (Size: 0x10)
RigUnit_UnaryQuaternionOp.Result = 0x20 // FQuat (Size: 0x10)
RigUnit_VerletIntegrateVector.Target = 0x8 // FVector (Size: 0xc)
RigUnit_VerletIntegrateVector.Strength = 0x14 // float (Size: 0x4)
RigUnit_VerletIntegrateVector.Damp = 0x18 // float (Size: 0x4)
RigUnit_VerletIntegrateVector.Blend = 0x1c // float (Size: 0x4)
RigUnit_VerletIntegrateVector.position = 0x20 // FVector (Size: 0xc)
RigUnit_VerletIntegrateVector.Velocity = 0x2c // FVector (Size: 0xc)
RigUnit_VerletIntegrateVector.Acceleration = 0x38 // FVector (Size: 0xc)
RigUnit_VerletIntegrateVector.Point = 0x44 // FCRSimPoint (Size: 0x28)
RigUnit_VerletIntegrateVector.bInitialized = 0x6c // bool (Size: 0x1)
RigUnit_VisualDebugQuat.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_VisualDebugQuat.bEnabled = 0x20 // bool (Size: 0x1)
RigUnit_VisualDebugQuat.Thickness = 0x24 // float (Size: 0x4)
RigUnit_VisualDebugQuat.Scale = 0x28 // float (Size: 0x4)
RigUnit_VisualDebugQuat.BoneSpace = 0x2c // FName (Size: 0x8)
RigUnit_VisualDebugQuatItemSpace.Value = 0x10 // FQuat (Size: 0x10)
RigUnit_VisualDebugQuatItemSpace.bEnabled = 0x20 // bool (Size: 0x1)
RigUnit_VisualDebugQuatItemSpace.Thickness = 0x24 // float (Size: 0x4)
RigUnit_VisualDebugQuatItemSpace.Scale = 0x28 // float (Size: 0x4)
RigUnit_VisualDebugQuatItemSpace.Space = 0x2c // FRigElementKey (Size: 0xc)
RigUnit_VisualDebugTransform.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_VisualDebugTransform.bEnabled = 0x40 // bool (Size: 0x1)
RigUnit_VisualDebugTransform.Thickness = 0x44 // float (Size: 0x4)
RigUnit_VisualDebugTransform.Scale = 0x48 // float (Size: 0x4)
RigUnit_VisualDebugTransform.BoneSpace = 0x4c // FName (Size: 0x8)
RigUnit_VisualDebugTransformItemSpace.Value = 0x10 // FTransform (Size: 0x30)
RigUnit_VisualDebugTransformItemSpace.bEnabled = 0x40 // bool (Size: 0x1)
RigUnit_VisualDebugTransformItemSpace.Thickness = 0x44 // float (Size: 0x4)
RigUnit_VisualDebugTransformItemSpace.Scale = 0x48 // float (Size: 0x4)
RigUnit_VisualDebugTransformItemSpace.Space = 0x4c // FRigElementKey (Size: 0xc)
RigUnit_VisualDebugVector.Value = 0x8 // FVector (Size: 0xc)
RigUnit_VisualDebugVector.bEnabled = 0x14 // bool (Size: 0x1)
RigUnit_VisualDebugVector.Mode = 0x15 // EERigUnitVisualDebugPointMode (Size: 0x1)
RigUnit_VisualDebugVector.Color = 0x18 // FLinearColor (Size: 0x10)
RigUnit_VisualDebugVector.Thickness = 0x28 // float (Size: 0x4)
RigUnit_VisualDebugVector.Scale = 0x2c // float (Size: 0x4)
RigUnit_VisualDebugVector.BoneSpace = 0x30 // FName (Size: 0x8)
RigUnit_VisualDebugVectorItemSpace.Value = 0x8 // FVector (Size: 0xc)
RigUnit_VisualDebugVectorItemSpace.bEnabled = 0x14 // bool (Size: 0x1)
RigUnit_VisualDebugVectorItemSpace.Mode = 0x15 // EERigUnitVisualDebugPointMode (Size: 0x1)
RigUnit_VisualDebugVectorItemSpace.Color = 0x18 // FLinearColor (Size: 0x10)
RigUnit_VisualDebugVectorItemSpace.Thickness = 0x28 // float (Size: 0x4)
RigUnit_VisualDebugVectorItemSpace.Scale = 0x2c // float (Size: 0x4)
RigUnit_VisualDebugVectorItemSpace.Space = 0x30 // FRigElementKey (Size: 0xc)
ARFilter.PackageNames = 0x0 // TArray<FName> (Size: 0x10)
ARFilter.PackagePaths = 0x10 // TArray<FName> (Size: 0x10)
ARFilter.ObjectPaths = 0x20 // TArray<FName> (Size: 0x10)
ARFilter.ClassNames = 0x30 // TArray<FName> (Size: 0x10)
ARFilter.RecursiveClassesExclusionSet = 0x90 // TSet<...> (Size: 0x50)
ARFilter.bRecursivePaths = 0xe0 // bool (Size: 0x1)
ARFilter.bRecursiveClasses = 0xe1 // bool (Size: 0x1)
ARFilter.bIncludeOnlyOnDiskAssets = 0xe2 // bool (Size: 0x1)
AssetBundleData.Bundles = 0x0 // TArray<FAssetBundleEntry> (Size: 0x10)
AssetBundleEntry.BundleScope = 0x0 // FPrimaryAssetId (Size: 0x10)
AssetBundleEntry.BundleName = 0x10 // FName (Size: 0x8)
AssetBundleEntry.BundleAssets = 0x18 // TArray<FSoftObjectPath> (Size: 0x10)
AssetData.ObjectPath = 0x0 // FName (Size: 0x8)
AssetData.PackageName = 0x8 // FName (Size: 0x8)
AssetData.PackagePath = 0x10 // FName (Size: 0x8)
AssetData.AssetName = 0x18 // FName (Size: 0x8)
AssetData.AssetClass = 0x20 // FName (Size: 0x8)
AutomationEvent.Type = 0x0 // EEAutomationEventType (Size: 0x1)
AutomationEvent.Message = 0x8 // FString (Size: 0x10)
AutomationEvent.Context = 0x18 // FString (Size: 0x10)
AutomationEvent.Artifact = 0x28 // FGuid (Size: 0x10)
AutomationExecutionEntry.Event = 0x0 // FAutomationEvent (Size: 0x38)
AutomationExecutionEntry.Filename = 0x38 // FString (Size: 0x10)
AutomationExecutionEntry.LineNumber = 0x48 // int32_t (Size: 0x4)
AutomationExecutionEntry.Timestamp = 0x50 // FDateTime (Size: 0x8)
Box.Min = 0x0 // FVector (Size: 0xc)
Box.Max = 0xc // FVector (Size: 0xc)
Box.IsValid = 0x18 // uint8_t (Size: 0x1)
Box2D.Min = 0x0 // FVector2D (Size: 0x8)
Box2D.Max = 0x8 // FVector2D (Size: 0x8)
Box2D.bIsValid = 0x10 // uint8_t (Size: 0x1)
BoxSphereBounds.Origin = 0x0 // FVector (Size: 0xc)
BoxSphereBounds.BoxExtent = 0xc // FVector (Size: 0xc)
BoxSphereBounds.SphereRadius = 0x18 // float (Size: 0x4)
Color.B = 0x0 // uint8_t (Size: 0x1)
Color.G = 0x1 // uint8_t (Size: 0x1)
Color.R = 0x2 // uint8_t (Size: 0x1)
Color.A = 0x3 // uint8_t (Size: 0x1)
FloatInterval.Min = 0x0 // float (Size: 0x4)
FloatInterval.Max = 0x4 // float (Size: 0x4)
FloatRange.LowerBound = 0x0 // FFloatRangeBound (Size: 0x8)
FloatRange.UpperBound = 0x8 // FFloatRangeBound (Size: 0x8)
FloatRangeBound.Type = 0x0 // uint8_t (Size: 0x1)
FloatRangeBound.Value = 0x4 // float (Size: 0x4)
FrameNumber.Value = 0x0 // int32_t (Size: 0x4)
FrameNumberRange.LowerBound = 0x0 // FFrameNumberRangeBound (Size: 0x8)
FrameNumberRange.UpperBound = 0x8 // FFrameNumberRangeBound (Size: 0x8)
FrameNumberRangeBound.Type = 0x0 // uint8_t (Size: 0x1)
FrameNumberRangeBound.Value = 0x4 // FFrameNumber (Size: 0x4)
FrameRate.Numerator = 0x0 // int32_t (Size: 0x4)
FrameRate.Denominator = 0x4 // int32_t (Size: 0x4)
FrameTime.FrameNumber = 0x0 // FFrameNumber (Size: 0x4)
FrameTime.SubFrame = 0x4 // float (Size: 0x4)
Guid.A = 0x0 // int32_t (Size: 0x4)
Guid.B = 0x4 // int32_t (Size: 0x4)
Guid.C = 0x8 // int32_t (Size: 0x4)
Guid.D = 0xc // int32_t (Size: 0x4)
Int32Interval.Min = 0x0 // int32_t (Size: 0x4)
Int32Interval.Max = 0x4 // int32_t (Size: 0x4)
Int32Range.LowerBound = 0x0 // FInt32RangeBound (Size: 0x8)
Int32Range.UpperBound = 0x8 // FInt32RangeBound (Size: 0x8)
Int32RangeBound.Type = 0x0 // uint8_t (Size: 0x1)
Int32RangeBound.Value = 0x4 // int32_t (Size: 0x4)
IntPoint.X = 0x0 // int32_t (Size: 0x4)
IntPoint.Y = 0x4 // int32_t (Size: 0x4)
IntVector.X = 0x0 // int32_t (Size: 0x4)
IntVector.Y = 0x4 // int32_t (Size: 0x4)
IntVector.Z = 0x8 // int32_t (Size: 0x4)
InterpCurveFloat.Points = 0x0 // TArray<FInterpCurvePointFloat> (Size: 0x10)
InterpCurveFloat.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveFloat.LoopKeyOffset = 0x14 // float (Size: 0x4)
InterpCurveLinearColor.Points = 0x0 // TArray<FInterpCurvePointLinearColor> (Size: 0x10)
InterpCurveLinearColor.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveLinearColor.LoopKeyOffset = 0x14 // float (Size: 0x4)
InterpCurvePointFloat.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointFloat.OutVal = 0x4 // float (Size: 0x4)
InterpCurvePointFloat.ArriveTangent = 0x8 // float (Size: 0x4)
InterpCurvePointFloat.LeaveTangent = 0xc // float (Size: 0x4)
InterpCurvePointFloat.InterpMode = 0x10 // uint8_t (Size: 0x1)
InterpCurvePointLinearColor.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointLinearColor.OutVal = 0x4 // FLinearColor (Size: 0x10)
InterpCurvePointLinearColor.ArriveTangent = 0x14 // FLinearColor (Size: 0x10)
InterpCurvePointLinearColor.LeaveTangent = 0x24 // FLinearColor (Size: 0x10)
InterpCurvePointLinearColor.InterpMode = 0x34 // uint8_t (Size: 0x1)
InterpCurvePointQuat.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointQuat.OutVal = 0x10 // FQuat (Size: 0x10)
InterpCurvePointQuat.ArriveTangent = 0x20 // FQuat (Size: 0x10)
InterpCurvePointQuat.LeaveTangent = 0x30 // FQuat (Size: 0x10)
InterpCurvePointQuat.InterpMode = 0x40 // uint8_t (Size: 0x1)
InterpCurvePointTwoVectors.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointTwoVectors.OutVal = 0x4 // FTwoVectors (Size: 0x18)
InterpCurvePointTwoVectors.ArriveTangent = 0x1c // FTwoVectors (Size: 0x18)
InterpCurvePointTwoVectors.LeaveTangent = 0x34 // FTwoVectors (Size: 0x18)
InterpCurvePointTwoVectors.InterpMode = 0x4c // uint8_t (Size: 0x1)
InterpCurvePointVector.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointVector.OutVal = 0x4 // FVector (Size: 0xc)
InterpCurvePointVector.ArriveTangent = 0x10 // FVector (Size: 0xc)
InterpCurvePointVector.LeaveTangent = 0x1c // FVector (Size: 0xc)
InterpCurvePointVector.InterpMode = 0x28 // uint8_t (Size: 0x1)
InterpCurvePointVector2D.InVal = 0x0 // float (Size: 0x4)
InterpCurvePointVector2D.OutVal = 0x4 // FVector2D (Size: 0x8)
InterpCurvePointVector2D.ArriveTangent = 0xc // FVector2D (Size: 0x8)
InterpCurvePointVector2D.LeaveTangent = 0x14 // FVector2D (Size: 0x8)
InterpCurvePointVector2D.InterpMode = 0x1c // uint8_t (Size: 0x1)
InterpCurveQuat.Points = 0x0 // TArray<FInterpCurvePointQuat> (Size: 0x10)
InterpCurveQuat.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveQuat.LoopKeyOffset = 0x14 // float (Size: 0x4)
InterpCurveTwoVectors.Points = 0x0 // TArray<FInterpCurvePointTwoVectors> (Size: 0x10)
InterpCurveTwoVectors.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveTwoVectors.LoopKeyOffset = 0x14 // float (Size: 0x4)
InterpCurveVector.Points = 0x0 // TArray<FInterpCurvePointVector> (Size: 0x10)
InterpCurveVector.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveVector.LoopKeyOffset = 0x14 // float (Size: 0x4)
InterpCurveVector2D.Points = 0x0 // TArray<FInterpCurvePointVector2D> (Size: 0x10)
InterpCurveVector2D.bIsLooped = 0x10 // bool (Size: 0x1)
InterpCurveVector2D.LoopKeyOffset = 0x14 // float (Size: 0x4)
JoinabilitySettings.SessionName = 0x0 // FName (Size: 0x8)
JoinabilitySettings.bPublicSearchable = 0x8 // bool (Size: 0x1)
JoinabilitySettings.bAllowInvites = 0x9 // bool (Size: 0x1)
JoinabilitySettings.bJoinViaPresence = 0xa // bool (Size: 0x1)
JoinabilitySettings.bJoinViaPresenceFriendsOnly = 0xb // bool (Size: 0x1)
JoinabilitySettings.MaxPlayers = 0xc // int32_t (Size: 0x4)
JoinabilitySettings.MaxPartySize = 0x10 // int32_t (Size: 0x4)
LinearColor.R = 0x0 // float (Size: 0x4)
LinearColor.G = 0x4 // float (Size: 0x4)
LinearColor.B = 0x8 // float (Size: 0x4)
LinearColor.A = 0xc // float (Size: 0x4)
Matrix.XPlane = 0x0 // FPlane (Size: 0x10)
Matrix.YPlane = 0x10 // FPlane (Size: 0x10)
Matrix.ZPlane = 0x20 // FPlane (Size: 0x10)
Matrix.WPlane = 0x30 // FPlane (Size: 0x10)
OrientedBox.Center = 0x0 // FVector (Size: 0xc)
OrientedBox.AxisX = 0xc // FVector (Size: 0xc)
OrientedBox.AxisY = 0x18 // FVector (Size: 0xc)
OrientedBox.AxisZ = 0x24 // FVector (Size: 0xc)
OrientedBox.ExtentX = 0x30 // float (Size: 0x4)
OrientedBox.ExtentY = 0x34 // float (Size: 0x4)
OrientedBox.ExtentZ = 0x38 // float (Size: 0x4)
PackedNormal.X = 0x0 // uint8_t (Size: 0x1)
PackedNormal.Y = 0x1 // uint8_t (Size: 0x1)
PackedNormal.Z = 0x2 // uint8_t (Size: 0x1)
PackedNormal.W = 0x3 // uint8_t (Size: 0x1)
PackedRGB10A2N.Packed = 0x0 // int32_t (Size: 0x4)
PackedRGBA16N.XY = 0x0 // int32_t (Size: 0x4)
PackedRGBA16N.ZW = 0x4 // int32_t (Size: 0x4)
Plane.W = 0xc // float (Size: 0x4)
PolyglotTextData.Category = 0x0 // EELocalizedTextSourceCategory (Size: 0x1)
PolyglotTextData.NativeCulture = 0x8 // FString (Size: 0x10)
PolyglotTextData.Namespace = 0x18 // FString (Size: 0x10)
PolyglotTextData.Key = 0x28 // FString (Size: 0x10)
PolyglotTextData.NativeString = 0x38 // FString (Size: 0x10)
PolyglotTextData.LocalizedStrings = 0x48 // TMap<...> (Size: 0x50)
PolyglotTextData.bIsMinimalPatch = 0x98 // bool (Size: 0x1)
PolyglotTextData.CachedText = 0xa0 // FText (Size: 0x18)
PrimaryAssetId.PrimaryAssetType = 0x0 // FPrimaryAssetType (Size: 0x8)
PrimaryAssetId.PrimaryAssetName = 0x8 // FName (Size: 0x8)
PrimaryAssetType.Name = 0x0 // FName (Size: 0x8)
QualifiedFrameTime.Time = 0x0 // FFrameTime (Size: 0x8)
QualifiedFrameTime.Rate = 0x8 // FFrameRate (Size: 0x8)
Quat.X = 0x0 // float (Size: 0x4)
Quat.Y = 0x4 // float (Size: 0x4)
Quat.Z = 0x8 // float (Size: 0x4)
Quat.W = 0xc // float (Size: 0x4)
RandomStream.InitialSeed = 0x0 // int32_t (Size: 0x4)
RandomStream.Seed = 0x4 // int32_t (Size: 0x4)
Rotator.Pitch = 0x0 // float (Size: 0x4)
Rotator.Yaw = 0x4 // float (Size: 0x4)
Rotator.Roll = 0x8 // float (Size: 0x4)
SoftObjectPath.AssetPathName = 0x0 // FName (Size: 0x8)
SoftObjectPath.SubPathString = 0x8 // FString (Size: 0x10)
Timecode.Hours = 0x0 // int32_t (Size: 0x4)
Timecode.Minutes = 0x4 // int32_t (Size: 0x4)
Timecode.Seconds = 0x8 // int32_t (Size: 0x4)
Timecode.Frames = 0xc // int32_t (Size: 0x4)
Timecode.bDropFrameFormat = 0x10 // bool (Size: 0x1)
Transform.Rotation = 0x0 // FQuat (Size: 0x10)
Transform.Translation = 0x10 // FVector (Size: 0xc)
Transform.Scale3D = 0x20 // FVector (Size: 0xc)
TwoVectors.v1 = 0x0 // FVector (Size: 0xc)
TwoVectors.v2 = 0xc // FVector (Size: 0xc)
Vector.X = 0x0 // float (Size: 0x4)
Vector.Y = 0x4 // float (Size: 0x4)
Vector.Z = 0x8 // float (Size: 0x4)
Vector2D.X = 0x0 // float (Size: 0x4)
Vector2D.Y = 0x4 // float (Size: 0x4)
Vector4.X = 0x0 // float (Size: 0x4)
Vector4.Y = 0x4 // float (Size: 0x4)
Vector4.Z = 0x8 // float (Size: 0x4)
Vector4.W = 0xc // float (Size: 0x4)
CoverGenerator.bRegenerateAtBeginPlay = 0x310 // bool (Size: 0x1)
CoverGenerator.bRegenerateAtNavigationRebuilt = 0x311 // bool (Size: 0x1)
CoverGenerator.SegmentLength = 0x314 // float (Size: 0x4)
CoverGenerator.MaxSegDist = 0x318 // float (Size: 0x4)
CoverGenerator.CharHeight = 0x31c // float (Size: 0x4)
CoverGenerator.StepDistTrace = 0x320 // float (Size: 0x4)
CoverGenerator.TraceLength = 0x324 // float (Size: 0x4)
CoverGenerator.MinSpaceBetweenValidPoints = 0x328 // float (Size: 0x4)
CoverGenerator.SphereSize = 0x32c // float (Size: 0x4)
CoverGenerator.WidthMaxAgent = 0x330 // float (Size: 0x4)
CoverGenerator.HeightMaxCrouching = 0x334 // float (Size: 0x4)
CoverGenerator.HeightMaxStanding = 0x338 // float (Size: 0x4)
CoverGenerator.OffsetWhenLeaningSides = 0x33c // float (Size: 0x4)
CoverGenerator.OffsetFrontAim = 0x340 // float (Size: 0x4)
CoverGenerator.EscapeRadius = 0x344 // float (Size: 0x4)
CoverGenerator.MinCoverNum = 0x348 // int32_t (Size: 0x4)
CoverGenerator.MinEscapeStep = 0x34c // float (Size: 0x4)
CoverGenerator.VolumeClass = 0x350 // ClassProperty (Size: 0x8)
CoverGenerator.bDraw1AllSegmentPointsTested = 0x358 // bool (Size: 0x1)
CoverGenerator.bDraw2SegmentPointsWithinBounds = 0x359 // bool (Size: 0x1)
CoverGenerator.bDraw3SimpleCoverGeometryTest = 0x35a // bool (Size: 0x1)
CoverGenerator.bDraw4SecondPassTracesSides = 0x35b // bool (Size: 0x1)
CoverGenerator.bDraw4SecondPassTracesSidesFrontAndBottom = 0x35c // bool (Size: 0x1)
CoverGenerator.bDraw5SecondPassArrows = 0x35d // bool (Size: 0x1)
CoverGenerator.DebugDrawAllPoints = 0x35e // bool (Size: 0x1)
CoverGenerator.DebugDrawAllBusyPoints = 0x35f // bool (Size: 0x1)
CoverGenerator.DebugDisplayLog = 0x360 // bool (Size: 0x1)
CoverGenerator.DebugDistance = 0x364 // float (Size: 0x4)
CoverGenerator.bDrawOctreeBounds = 0x368 // bool (Size: 0x1)
CoverGenerator.bDebugVerts = 0x369 // bool (Size: 0x1)
CoverGenerator.bDebugEdgeVerts = 0x36a // bool (Size: 0x1)
CoverGenerator.bDebugPolyVerts = 0x36b // bool (Size: 0x1)
CoverGenerator.AllCoverPoints = 0x378 // TArray<CoverPoint*> (Size: 0x10)
CoverGenerator.CoverPointsCurrentlyUsed = 0x388 // TArray<CoverPoint*> (Size: 0x10)
CoverGenerator.EscapesPoints = 0x398 // TArray<FVector> (Size: 0x10)
CoverPoint.Location = 0x28 // FVector (Size: 0xc)
CoverPoint._DirectionToWall = 0x34 // FVector (Size: 0xc)
CoverPoint.RotatorXToWall = 0x40 // FRotator (Size: 0xc)
CoverPoint.bLeftCoverStanding = 0x4c // bool (Size: 0x1)
CoverPoint.bRightCoverStanding = 0x4d // bool (Size: 0x1)
CoverPoint.bLeftCoverCrouched = 0x4e // bool (Size: 0x1)
CoverPoint.bRightCoverCrouched = 0x4f // bool (Size: 0x1)
CoverPoint.bFrontCoverCrouched = 0x50 // bool (Size: 0x1)
CoverPoint.bCrouchedCover = 0x51 // bool (Size: 0x1)
CoverPoint.OccupiedBy = 0x58 // Controller* (Size: 0x8)
EnvQueryGenerator_CoverFMemory.SquareExtent = 0x50 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_CoverFMemory.BoxHeight = 0x88 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryGenerator_CoverFMemory.GenerateAround = 0xc0 // ClassProperty (Size: 0x8)
EnvQueryTest_IsCoverPosition.TraceData = 0x1f8 // FEnvTraceData (Size: 0x30)
EnvQueryTest_IsCoverPosition.Context = 0x228 // ClassProperty (Size: 0x8)
EnvQueryTest_IsCoverPosition.ContextHorizontalDistanceOffset = 0x230 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_IsCoverPosition.ContextVerticalDistanceOffset = 0x268 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_IsCoverPosition.DebugData = 0x2a0 // FAIDataProviderBoolValue (Size: 0x38)
EnvQueryTest_ParallelToCoverDirection.Context = 0x1f8 // ClassProperty (Size: 0x8)
EnvQueryTest_ParallelToCoverDirection.MaxEpsilon = 0x200 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_TraceDistance.TraceData = 0x1f8 // FEnvTraceData (Size: 0x30)
EnvQueryTest_TraceDistance.Context = 0x228 // ClassProperty (Size: 0x8)
EnvQueryTest_TraceDistance.MaxTraceDistance = 0x230 // FAIDataProviderFloatValue (Size: 0x38)
EnvQueryTest_TraceDistance.VerticalOffset = 0x268 // FAIDataProviderFloatValue (Size: 0x38)
NPCAINavLinkProxy.LinkType = 0x360 // EENavLinkType (Size: 0x1)
NPCAINavLinkProxy.PolyRef = 0x368 // uint64_t (Size: 0x8)
NPCAINavLinkProxy.NodeIndex = 0x370 // int32_t (Size: 0x4)
NavLinkProxyGenerator.EdgeDivisor = 0x310 // float (Size: 0x4)
NavLinkProxyGenerator.JumpHeight = 0x314 // float (Size: 0x4)
NavLinkProxyGenerator.SlantDegree = 0x318 // float (Size: 0x4)
NavLinkProxyGenerator.MinHeight = 0x31c // float (Size: 0x4)
NavLinkProxyGenerator.MaxHeight = 0x320 // float (Size: 0x4)
NavLinkProxyGenerator.MaxZHeight = 0x324 // float (Size: 0x4)
NavLinkProxyGenerator.MaxJumpDistance = 0x328 // float (Size: 0x4)
NavLinkProxyGenerator.MinFenceHeight = 0x32c // float (Size: 0x4)
NavLinkProxyGenerator.MinFenceWidth = 0x330 // float (Size: 0x4)
NavLinkProxyGenerator.bDrawDebugLine = 0x334 // bool (Size: 0x1)
NavLinkProxyGenerator.bGenerateJumpingDown = 0x335 // bool (Size: 0x1)
NavLinkProxyGenerator.bGenerateJumpingOver = 0x336 // bool (Size: 0x1)
NavLinkProxyGenerator.BPNavLinkClass = 0x358 // ClassProperty (Size: 0x8)
DLSSOverrideSettings.EnableDLSSInEditorViewportsOverride = 0x28 // EEDLSSSettingOverride (Size: 0x1)
DLSSOverrideSettings.EnableScreenpercentageManipulationInDLSSEditorViewportsOverride = 0x29 // EEDLSSSettingOverride (Size: 0x1)
DLSSOverrideSettings.EnableDLSSInPlayInEditorViewportsOverride = 0x2a // EEDLSSSettingOverride (Size: 0x1)
DLSSOverrideSettings.bShowDLSSIncompatiblePluginsToolsWarnings = 0x2b // bool (Size: 0x1)
DLSSOverrideSettings.ShowDLSSSDebugOnScreenMessages = 0x2c // EEDLSSSettingOverride (Size: 0x1)
DLSSSettings.bEnableDLSSD3D12 = 0x28 // bool (Size: 0x1)
DLSSSettings.bEnableDLSSD3D11 = 0x29 // bool (Size: 0x1)
DLSSSettings.bEnableDLSSVulkan = 0x2a // bool (Size: 0x1)
DLSSSettings.bEnableDLSSInEditorViewports = 0x2b // bool (Size: 0x1)
DLSSSettings.bEnableScreenpercentageManipulationInDLSSEditorViewports = 0x2c // bool (Size: 0x1)
DLSSSettings.bEnableDLSSInPlayInEditorViewports = 0x2d // bool (Size: 0x1)
DLSSSettings.bShowDLSSSDebugOnScreenMessages = 0x2e // bool (Size: 0x1)
DLSSSettings.GenericDLSSBinaryPath = 0x30 // FString (Size: 0x10)
DLSSSettings.bGenericDLSSBinaryExists = 0x40 // bool (Size: 0x1)
DLSSSettings.NVIDIANGXApplicationId = 0x44 // uint32_t (Size: 0x4)
DLSSSettings.CustomDLSSBinaryPath = 0x48 // FString (Size: 0x10)
DLSSSettings.bCustomDLSSBinaryExists = 0x58 // bool (Size: 0x1)
DLSSSettings.bAllowOTAUpdate = 0x59 // bool (Size: 0x1)
DLSSSettings.bShowDLSSIncompatiblePluginsToolsWarnings = 0x5a // bool (Size: 0x1)
DLSSSettings.DLAAPreset = 0x5b // EEDLSSPreset (Size: 0x1)
DLSSSettings.DLSSQualityPreset = 0x5d // EEDLSSPreset (Size: 0x1)
DLSSSettings.DLSSBalancedPreset = 0x5e // EEDLSSPreset (Size: 0x1)
DLSSSettings.DLSSPerformancePreset = 0x5f // EEDLSSPreset (Size: 0x1)
DLSSSettings.DLSSUltraPerformancePreset = 0x60 // EEDLSSPreset (Size: 0x1)
DLSSSettings.DLAARRPreset = 0x61 // EEDLSSRRPreset (Size: 0x1)
DLSSSettings.DLSSRRQualityPreset = 0x63 // EEDLSSRRPreset (Size: 0x1)
DLSSSettings.DLSSRRBalancedPreset = 0x64 // EEDLSSRRPreset (Size: 0x1)
DLSSSettings.DLSSRRPerformancePreset = 0x65 // EEDLSSRRPreset (Size: 0x1)
DLSSSettings.DLSSRRUltraPerformancePreset = 0x66 // EEDLSSRRPreset (Size: 0x1)
AdaptorPolygon.PolygonGroupID = 0x0 // FPolygonGroupID (Size: 0x4)
AdaptorPolygon.TriangulatedPolygonTriangleIndices = 0x8 // TArray<FAdaptorTriangleID> (Size: 0x10)
AdaptorPolygon2Group.RenderingSectionIndex = 0x0 // uint32_t (Size: 0x4)
AdaptorPolygon2Group.MaterialIndex = 0x4 // int32_t (Size: 0x4)
AdaptorPolygon2Group.MaxTriangles = 0x8 // int32_t (Size: 0x4)
AttributesForEdge.EdgeID = 0x0 // FEdgeID (Size: 0x4)
AttributesForEdge.EdgeAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
AttributesForVertex.VertexID = 0x0 // FVertexID (Size: 0x4)
AttributesForVertex.VertexAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
AttributesForVertexInstance.VertexInstanceID = 0x0 // FVertexInstanceID (Size: 0x4)
AttributesForVertexInstance.VertexInstanceAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
ChangeVertexInstancesForPolygon.PolygonID = 0x0 // FPolygonID (Size: 0x4)
ChangeVertexInstancesForPolygon.PerimeterVertexIndicesAndInstanceIDs = 0x8 // TArray<FVertexIndexAndInstanceID> (Size: 0x10)
ChangeVertexInstancesForPolygon.VertexIndicesAndInstanceIDsForEachHole = 0x18 // TArray<FVertexInstancesForPolygonHole> (Size: 0x10)
EdgeToCreate.VertexID0 = 0x0 // FVertexID (Size: 0x4)
EdgeToCreate.VertexID1 = 0x4 // FVertexID (Size: 0x4)
EdgeToCreate.EdgeAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
EdgeToCreate.OriginalEdgeID = 0x18 // FEdgeID (Size: 0x4)
EditableGeometryCollectionAdapter.GeometryCollection = 0x28 // GeometryCollection* (Size: 0x8)
EditableGeometryCollectionAdapter.OriginalGeometryCollection = 0x30 // GeometryCollection* (Size: 0x8)
EditableGeometryCollectionAdapter.GeometryCollectionLODIndex = 0x38 // int32_t (Size: 0x4)
EditableMesh.Adapters = 0x3b8 // TArray<EditableMeshAdapter*> (Size: 0x10)
EditableMesh.TextureCoordinateCount = 0x3d0 // int32_t (Size: 0x4)
EditableMesh.PendingCompactCounter = 0x51c // int32_t (Size: 0x4)
EditableMesh.SubdivisionCount = 0x520 // int32_t (Size: 0x4)
EditableStaticMeshAdapter.StaticMesh = 0x28 // StaticMesh* (Size: 0x8)
EditableStaticMeshAdapter.OriginalStaticMesh = 0x30 // StaticMesh* (Size: 0x8)
EditableStaticMeshAdapter.StaticMeshLODIndex = 0x38 // int32_t (Size: 0x4)
MeshElementAttributeData.AttributeName = 0x0 // FName (Size: 0x8)
MeshElementAttributeData.AttributeIndex = 0x8 // int32_t (Size: 0x4)
MeshElementAttributeData.AttributeValue = 0x10 // FMeshElementAttributeValue (Size: 0x50)
MeshElementAttributeList.Attributes = 0x0 // TArray<FMeshElementAttributeData> (Size: 0x10)
PolygonGroupForPolygon.PolygonID = 0x0 // FPolygonID (Size: 0x4)
PolygonGroupForPolygon.PolygonGroupID = 0x4 // FPolygonGroupID (Size: 0x4)
PolygonGroupToCreate.PolygonGroupAttributes = 0x0 // FMeshElementAttributeList (Size: 0x10)
PolygonGroupToCreate.OriginalPolygonGroupID = 0x10 // FPolygonGroupID (Size: 0x4)
PolygonToCreate.PolygonGroupID = 0x0 // FPolygonGroupID (Size: 0x4)
PolygonToCreate.PerimeterVertices = 0x8 // TArray<FVertexAndAttributes> (Size: 0x10)
PolygonToCreate.OriginalPolygonID = 0x18 // FPolygonID (Size: 0x4)
PolygonToCreate.PolygonEdgeHardness = 0x1c // EEPolygonEdgeHardness (Size: 0x1)
PolygonToSplit.PolygonID = 0x0 // FPolygonID (Size: 0x4)
PolygonToSplit.VertexPairsToSplitAt = 0x8 // TArray<FVertexPair> (Size: 0x10)
RenderingPolygon.PolygonGroupID = 0x0 // FPolygonGroupID (Size: 0x4)
RenderingPolygon.TriangulatedPolygonTriangleIndices = 0x8 // TArray<FTriangleID> (Size: 0x10)
RenderingPolygonGroup.RenderingSectionIndex = 0x0 // uint32_t (Size: 0x4)
RenderingPolygonGroup.MaterialIndex = 0x4 // int32_t (Size: 0x4)
RenderingPolygonGroup.MaxTriangles = 0x8 // int32_t (Size: 0x4)
SubdividedQuad.QuadVertex0 = 0x0 // FSubdividedQuadVertex (Size: 0x34)
SubdividedQuad.QuadVertex1 = 0x34 // FSubdividedQuadVertex (Size: 0x34)
SubdividedQuad.QuadVertex2 = 0x68 // FSubdividedQuadVertex (Size: 0x34)
SubdividedQuad.QuadVertex3 = 0x9c // FSubdividedQuadVertex (Size: 0x34)
SubdividedQuadVertex.VertexPositionIndex = 0x0 // int32_t (Size: 0x4)
SubdividedQuadVertex.TextureCoordinate0 = 0x4 // FVector2D (Size: 0x8)
SubdividedQuadVertex.TextureCoordinate1 = 0xc // FVector2D (Size: 0x8)
SubdividedQuadVertex.VertexColor = 0x14 // FColor (Size: 0x4)
SubdividedQuadVertex.VertexNormal = 0x18 // FVector (Size: 0xc)
SubdividedQuadVertex.VertexTangent = 0x24 // FVector (Size: 0xc)
SubdividedQuadVertex.VertexBinormalSign = 0x30 // float (Size: 0x4)
SubdividedWireEdge.EdgeVertex0PositionIndex = 0x0 // int32_t (Size: 0x4)
SubdividedWireEdge.EdgeVertex1PositionIndex = 0x4 // int32_t (Size: 0x4)
SubdivisionLimitData.VertexPositions = 0x0 // TArray<FVector> (Size: 0x10)
SubdivisionLimitData.Sections = 0x10 // TArray<FSubdivisionLimitSection> (Size: 0x10)
SubdivisionLimitData.SubdividedWireEdges = 0x20 // TArray<FSubdividedWireEdge> (Size: 0x10)
SubdivisionLimitSection.SubdividedQuads = 0x0 // TArray<FSubdividedQuad> (Size: 0x10)
VertexAndAttributes.VertexInstanceID = 0x0 // FVertexInstanceID (Size: 0x4)
VertexAndAttributes.VertexID = 0x4 // FVertexID (Size: 0x4)
VertexAndAttributes.PolygonVertexAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
VertexAttributesForPolygon.PolygonID = 0x0 // FPolygonID (Size: 0x4)
VertexAttributesForPolygon.PerimeterVertexAttributeLists = 0x8 // TArray<FMeshElementAttributeList> (Size: 0x10)
VertexAttributesForPolygon.VertexAttributeListsForEachHole = 0x18 // TArray<FVertexAttributesForPolygonHole> (Size: 0x10)
VertexAttributesForPolygonHole.VertexAttributeList = 0x0 // TArray<FMeshElementAttributeList> (Size: 0x10)
VertexIndexAndInstanceID.ContourIndex = 0x0 // int32_t (Size: 0x4)
VertexIndexAndInstanceID.VertexInstanceID = 0x4 // FVertexInstanceID (Size: 0x4)
VertexInstanceToCreate.VertexID = 0x0 // FVertexID (Size: 0x4)
VertexInstanceToCreate.VertexInstanceAttributes = 0x8 // FMeshElementAttributeList (Size: 0x10)
VertexInstanceToCreate.OriginalVertexInstanceID = 0x18 // FVertexInstanceID (Size: 0x4)
VertexInstancesForPolygonHole.VertexIndicesAndInstanceIDs = 0x0 // TArray<FVertexIndexAndInstanceID> (Size: 0x10)
VertexPair.VertexID0 = 0x0 // FVertexID (Size: 0x4)
VertexPair.VertexID1 = 0x4 // FVertexID (Size: 0x4)
VertexToCreate.VertexAttributes = 0x0 // FMeshElementAttributeList (Size: 0x10)
VertexToCreate.OriginalVertexID = 0x10 // FVertexID (Size: 0x4)
VertexToMove.VertexID = 0x0 // FVertexID (Size: 0x4)
VertexToMove.NewVertexPosition = 0x4 // FVector (Size: 0xc)
A2CSPose.ComponentSpaceFlags = 0x18 // TArray<uint8_t> (Size: 0x10)
A2Pose.Bones = 0x0 // TArray<FTransform> (Size: 0x10)
AISystemBase.AISystemClassName = 0x28 // FSoftClassPath (Size: 0x18)
AISystemBase.AISystemModuleName = 0x40 // FName (Size: 0x8)
AISystemBase.bInstantiateAISystemOnClient = 0x50 // bool (Size: 0x1)
ActiveCameraShakeInfo.ShakeInstance = 0x0 // CameraShakeBase* (Size: 0x8)
ActiveCameraShakeInfo.ShakeSource = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
ActiveForceFeedbackEffect.ForceFeedbackEffect = 0x0 // ForceFeedbackEffect* (Size: 0x8)
ActiveHapticFeedbackEffect.HapticEffect = 0x0 // HapticFeedbackEffect_Base* (Size: 0x8)
Actor.PrimaryActorTick = 0x28 // FActorTickFunction (Size: 0x40)
Actor.bNetTemporary = 0x68 // uint8_t (Size: 0x1)
Actor.bNetStartup = 0x68 // uint8_t (Size: 0x1)
Actor.bOnlyRelevantToOwner = 0x68 // uint8_t (Size: 0x1)
Actor.bAlwaysRelevant = 0x68 // uint8_t (Size: 0x1)
Actor.bReplicateMovement = 0x68 // uint8_t (Size: 0x1)
Actor.bHidden = 0x68 // uint8_t (Size: 0x1)
Actor.bTearOff = 0x68 // uint8_t (Size: 0x1)
Actor.bExchangedRoles = 0x68 // uint8_t (Size: 0x1)
Actor.bNetLoadOnClient = 0x69 // uint8_t (Size: 0x1)
Actor.bNetUseOwnerRelevancy = 0x69 // uint8_t (Size: 0x1)
Actor.bRelevantForNetworkReplays = 0x69 // uint8_t (Size: 0x1)
Actor.bRelevantForLevelBounds = 0x69 // uint8_t (Size: 0x1)
Actor.bReplayRewindable = 0x69 // uint8_t (Size: 0x1)
Actor.bAllowTickBeforeBeginPlay = 0x69 // uint8_t (Size: 0x1)
Actor.bAutoDestroyWhenFinished = 0x69 // uint8_t (Size: 0x1)
Actor.bCanBeDamaged = 0x69 // uint8_t (Size: 0x1)
Actor.bBlockInput = 0x6a // uint8_t (Size: 0x1)
Actor.bCollideWhenPlacing = 0x6a // uint8_t (Size: 0x1)
Actor.bFindCameraComponentWhenViewTarget = 0x6a // uint8_t (Size: 0x1)
Actor.bGenerateOverlapEventsDuringLevelStreaming = 0x6a // uint8_t (Size: 0x1)
Actor.bIgnoresOriginShifting = 0x6a // uint8_t (Size: 0x1)
Actor.bEnableAutoLODGeneration = 0x6a // uint8_t (Size: 0x1)
Actor.bIsEditorOnlyActor = 0x6a // uint8_t (Size: 0x1)
Actor.bActorSeamlessTraveled = 0x6a // uint8_t (Size: 0x1)
Actor.bForceInCookedBuildActor = 0x6b // uint8_t (Size: 0x1)
Actor.bForceNotInCookedBuildActor = 0x6b // uint8_t (Size: 0x1)
Actor.bNoHLODInOptProcess = 0x6b // uint8_t (Size: 0x1)
Actor.bReplicates = 0x6b // uint8_t (Size: 0x1)
Actor.bCanBeInCluster = 0x6b // uint8_t (Size: 0x1)
Actor.bAllowReceiveTickEventOnDedicatedServer = 0x6b // uint8_t (Size: 0x1)
Actor.bActorEnableCollision = 0x6c // uint8_t (Size: 0x1)
Actor.bActorIsBeingDestroyed = 0x6c // uint8_t (Size: 0x1)
Actor.UpdateOverlapsMethodDuringLevelStreaming = 0x6e // EEActorUpdateOverlapsMethod (Size: 0x1)
Actor.DefaultUpdateOverlapsMethodDuringLevelStreaming = 0x6f // EEActorUpdateOverlapsMethod (Size: 0x1)
Actor.RemoteRole = 0x70 // uint8_t (Size: 0x1)
Actor.bManualReplicates = 0x88 // uint8_t (Size: 0x1)
Actor.bSubobjectsManualReplicates = 0x88 // uint8_t (Size: 0x1)
Actor.bIgnoreAttachmentTranform = 0x88 // uint8_t (Size: 0x1)
Actor.ReplicatedMovement = 0x8c // FRepMovement (Size: 0x34)
Actor.InitialLifeSpan = 0xc0 // float (Size: 0x4)
Actor.CustomTimeDilation = 0xc4 // float (Size: 0x4)
Actor.AttachmentReplication = 0xd0 // FRepAttachment (Size: 0x40)
Actor.Owner = 0x110 // Actor* (Size: 0x8)
Actor.NetDriverName = 0x118 // FName (Size: 0x8)
Actor.Role = 0x120 // uint8_t (Size: 0x1)
Actor.NetDormancy = 0x121 // uint8_t (Size: 0x1)
Actor.SpawnCollisionHandlingMethod = 0x122 // EESpawnActorCollisionHandlingMethod (Size: 0x1)
Actor.AutoReceiveInput = 0x123 // uint8_t (Size: 0x1)
Actor.InputPriority = 0x124 // int32_t (Size: 0x4)
Actor.InputComponent = 0x128 // InputComponent* (Size: 0x8)
Actor.NetCullDistanceSquared = 0x130 // float (Size: 0x4)
Actor.NetTag = 0x134 // int32_t (Size: 0x4)
Actor.NetUpdateFrequency = 0x138 // float (Size: 0x4)
Actor.MinNetUpdateFrequency = 0x13c // float (Size: 0x4)
Actor.NetPriority = 0x140 // float (Size: 0x4)
Actor.Instigator = 0x150 // Pawn* (Size: 0x8)
Actor.Children = 0x158 // TArray<Actor*> (Size: 0x10)
Actor.RootComponent = 0x168 // SceneComponent* (Size: 0x8)
Actor.ControllingMatineeActors = 0x170 // TArray<MatineeActor*> (Size: 0x10)
Actor.Layers = 0x188 // TArray<FName> (Size: 0x10)
Actor.ParentComponent = 0x198 // TWeakObjectPtr<UObject> (Size: 0x8)
Actor.Tags = 0x1a8 // TArray<FName> (Size: 0x10)
Actor.OnTakeAnyDamage = 0x1b8 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnTakePointDamage = 0x1b9 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnTakeRadialDamage = 0x1ba // FMulticastSparseDelegate (Size: 0x1)
Actor.OnActorBeginOverlap = 0x1bb // FMulticastSparseDelegate (Size: 0x1)
Actor.OnActorEndOverlap = 0x1bc // FMulticastSparseDelegate (Size: 0x1)
Actor.OnBeginCursorOver = 0x1bd // FMulticastSparseDelegate (Size: 0x1)
Actor.OnEndCursorOver = 0x1be // FMulticastSparseDelegate (Size: 0x1)
Actor.OnClicked = 0x1bf // FMulticastSparseDelegate (Size: 0x1)
Actor.OnReleased = 0x1c0 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnInputTouchBegin = 0x1c1 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnInputTouchEnd = 0x1c2 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnInputTouchEnter = 0x1c3 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnInputTouchLeave = 0x1c4 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnActorHit = 0x1c5 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnDestroyed = 0x1c6 // FMulticastSparseDelegate (Size: 0x1)
Actor.OnEndPlay = 0x1c7 // FMulticastSparseDelegate (Size: 0x1)
Actor.InstanceComponents = 0x2e0 // TArray<ActorComponent*> (Size: 0x10)
Actor.BlueprintCreatedComponents = 0x2f0 // TArray<ActorComponent*> (Size: 0x10)
ActorChannel.Actor = 0x70 // Actor* (Size: 0x8)
ActorChannel.CreateSubObjects = 0x180 // TArray<Object*> (Size: 0x10)
ActorComponent.PrimaryComponentTick = 0x30 // FActorComponentTickFunction (Size: 0x40)
ActorComponent.ComponentTags = 0x70 // TArray<FName> (Size: 0x10)
ActorComponent.AssetUserData = 0x80 // TArray<AssetUserData*> (Size: 0x10)
ActorComponent.UCSSerializationIndex = 0x94 // int32_t (Size: 0x4)
ActorComponent.bNetAddressable = 0x98 // uint8_t (Size: 0x1)
ActorComponent.bReplicates = 0x98 // uint8_t (Size: 0x1)
ActorComponent.bAutoActivate = 0x99 // uint8_t (Size: 0x1)
ActorComponent.bIsActive = 0x9a // uint8_t (Size: 0x1)
ActorComponent.bEditableWhenInherited = 0x9a // uint8_t (Size: 0x1)
ActorComponent.bCanEverAffectNavigation = 0x9a // uint8_t (Size: 0x1)
ActorComponent.bIsEditorOnly = 0x9a // uint8_t (Size: 0x1)
ActorComponent.CreationMethod = 0x9c // EEComponentCreationMethod (Size: 0x1)
ActorComponent.OnComponentActivated = 0x9d // FMulticastSparseDelegate (Size: 0x1)
ActorComponent.OnComponentDeactivated = 0x9e // FMulticastSparseDelegate (Size: 0x1)
ActorComponent.UCSModifiedProperties = 0xa0 // TArray<FSimpleMemberReference> (Size: 0x10)
ActorComponent.bManualReplicates = 0xc0 // uint8_t (Size: 0x1)
ActorComponent.MinTickInterval = 0xdc // float (Size: 0x4)
ActorComponent.TickRateHandlerUseRate = 0xf4 // float (Size: 0x4)
ActorComponentInstanceData.SourceComponentTemplate = 0x8 // Object* (Size: 0x8)
ActorComponentInstanceData.SourceComponentCreationMethod = 0x10 // EEComponentCreationMethod (Size: 0x1)
ActorComponentInstanceData.SourceComponentTypeSerializedIndex = 0x14 // int32_t (Size: 0x4)
ActorComponentInstanceData.SavedProperties = 0x18 // TArray<uint8_t> (Size: 0x10)
ActorComponentInstanceData.UniqueTransientPackage = 0x28 // FActorComponentDuplicatedObjectData (Size: 0x10)
ActorComponentInstanceData.DuplicatedObjects = 0x38 // TArray<FActorComponentDuplicatedObjectData> (Size: 0x10)
ActorComponentInstanceData.ReferencedObjects = 0x48 // TArray<Object*> (Size: 0x10)
ActorComponentInstanceData.ReferencedNames = 0x58 // TArray<FName> (Size: 0x10)
AlphaBlend.CustomCurve = 0x0 // CurveFloat* (Size: 0x8)
AlphaBlend.BlendTime = 0x8 // float (Size: 0x4)
AlphaBlend.BlendOption = 0x24 // EEAlphaBlendOption (Size: 0x1)
AmbientSound.AudioComponent = 0x310 // AudioComponent* (Size: 0x8)
AngularDriveConstraint.TwistDrive = 0x0 // FConstraintDrive (Size: 0x10)
AngularDriveConstraint.SwingDrive = 0x10 // FConstraintDrive (Size: 0x10)
AngularDriveConstraint.SlerpDrive = 0x20 // FConstraintDrive (Size: 0x10)
AngularDriveConstraint.OrientationTarget = 0x30 // FRotator (Size: 0xc)
AngularDriveConstraint.AngularVelocityTarget = 0x3c // FVector (Size: 0xc)
AngularDriveConstraint.AngularDriveMode = 0x48 // uint8_t (Size: 0x1)
AnimBlueprint.TargetSkeleton = 0xa8 // Skeleton* (Size: 0x8)
AnimBlueprint.Groups = 0xb0 // TArray<FAnimGroupInfo> (Size: 0x10)
AnimBlueprint.bUseMultiThreadedAnimationUpdate = 0xc0 // bool (Size: 0x1)
AnimBlueprint.bWarnAboutBlueprintUsage = 0xc1 // bool (Size: 0x1)
AnimBlueprintFunction.Name = 0x0 // FName (Size: 0x8)
AnimBlueprintFunction.Group = 0x8 // FName (Size: 0x8)
AnimBlueprintFunction.OutputPoseNodeIndex = 0x10 // int32_t (Size: 0x4)
AnimBlueprintFunction.InputPoseNames = 0x18 // TArray<FName> (Size: 0x10)
AnimBlueprintFunction.InputPoseNodeIndices = 0x28 // TArray<int32_t> (Size: 0x10)
AnimBlueprintFunction.bImplemented = 0x60 // bool (Size: 0x1)
AnimBlueprintFunctionData.OutputPoseNodeProperty = 0x0 // FieldPathProperty (Size: 0x20)
AnimBlueprintFunctionData.InputPoseNodeProperties = 0x20 // TArray<FieldPathProperty> (Size: 0x10)
AnimBlueprintFunctionData.InputProperties = 0x30 // TArray<FieldPathProperty> (Size: 0x10)
AnimBlueprintGeneratedClass.BakedStateMachines = 0x330 // TArray<FBakedAnimationStateMachine> (Size: 0x10)
AnimBlueprintGeneratedClass.TargetSkeleton = 0x340 // Skeleton* (Size: 0x8)
AnimBlueprintGeneratedClass.AnimNotifies = 0x348 // TArray<FAnimNotifyEvent> (Size: 0x10)
AnimBlueprintGeneratedClass.OrderedSavedPoseIndicesMap = 0x358 // TMap<...> (Size: 0x50)
AnimBlueprintGeneratedClass.SyncGroupNames = 0x428 // TArray<FName> (Size: 0x10)
AnimBlueprintGeneratedClass.EvaluateGraphExposedInputs = 0x438 // TArray<FExposedValueHandler> (Size: 0x10)
AnimBlueprintGeneratedClass.GraphAssetPlayerInformation = 0x448 // TMap<...> (Size: 0x50)
AnimBlueprintGeneratedClass.GraphBlendOptions = 0x498 // TMap<...> (Size: 0x50)
AnimBlueprintGeneratedClass.PropertyAccessLibrary = 0x4e8 // FPropertyAccessLibrary (Size: 0xc8)
AnimBoneCompressionCodec.Description = 0x28 // FString (Size: 0x10)
AnimBoneCompressionSettings.Codecs = 0x28 // TArray<AnimBoneCompressionCodec*> (Size: 0x10)
AnimClassData.BakedStateMachines = 0x30 // TArray<FBakedAnimationStateMachine> (Size: 0x10)
AnimClassData.TargetSkeleton = 0x40 // Skeleton* (Size: 0x8)
AnimClassData.AnimNotifies = 0x48 // TArray<FAnimNotifyEvent> (Size: 0x10)
AnimClassData.OrderedSavedPoseIndicesMap = 0x58 // TMap<...> (Size: 0x50)
AnimClassData.AnimBlueprintFunctions = 0xa8 // TArray<FAnimBlueprintFunction> (Size: 0x10)
AnimClassData.AnimBlueprintFunctionData = 0xb8 // TArray<FAnimBlueprintFunctionData> (Size: 0x10)
AnimClassData.AnimNodeProperties = 0xc8 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.LinkedAnimGraphNodeProperties = 0xe8 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.LinkedAnimLayerNodeProperties = 0x108 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.PreUpdateNodeProperties = 0x128 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.DynamicResetNodeProperties = 0x148 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.StateMachineNodeProperties = 0x168 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.InitializationNodeProperties = 0x188 // TArray<FieldPathProperty> (Size: 0x10)
AnimClassData.GraphNameAssetPlayers = 0x1a8 // TMap<...> (Size: 0x50)
AnimClassData.SyncGroupNames = 0x1f8 // TArray<FName> (Size: 0x10)
AnimClassData.EvaluateGraphExposedInputs = 0x208 // TArray<FExposedValueHandler> (Size: 0x10)
AnimClassData.GraphBlendOptions = 0x218 // TMap<...> (Size: 0x50)
AnimClassData.PropertyAccessLibrary = 0x268 // FPropertyAccessLibrary (Size: 0xc8)
AnimComposite.AnimationTrack = 0xa8 // FAnimTrack (Size: 0x10)
AnimCompress.bNeedsSkeleton = 0x38 // uint8_t (Size: 0x1)
AnimCompress.TranslationCompressionFormat = 0x3c // uint8_t (Size: 0x1)
AnimCompress.RotationCompressionFormat = 0x3d // uint8_t (Size: 0x1)
AnimCompress.ScaleCompressionFormat = 0x3e // uint8_t (Size: 0x1)
AnimCompress_PerTrackCompression.MaxZeroingThreshold = 0x60 // float (Size: 0x4)
AnimCompress_PerTrackCompression.MaxPosDiffBitwise = 0x64 // float (Size: 0x4)
AnimCompress_PerTrackCompression.MaxAngleDiffBitwise = 0x68 // float (Size: 0x4)
AnimCompress_PerTrackCompression.MaxScaleDiffBitwise = 0x6c // float (Size: 0x4)
AnimCompress_PerTrackCompression.AllowedRotationFormats = 0x70 // TArray<uint8_t> (Size: 0x10)
AnimCompress_PerTrackCompression.AllowedTranslationFormats = 0x80 // TArray<uint8_t> (Size: 0x10)
AnimCompress_PerTrackCompression.AllowedScaleFormats = 0x90 // TArray<uint8_t> (Size: 0x10)
AnimCompress_PerTrackCompression.bResampleAnimation = 0xa0 // uint8_t (Size: 0x1)
AnimCompress_PerTrackCompression.ResampledFramerate = 0xa4 // float (Size: 0x4)
AnimCompress_PerTrackCompression.MinKeysForResampling = 0xa8 // int32_t (Size: 0x4)
AnimCompress_PerTrackCompression.bUseAdaptiveError = 0xac // uint8_t (Size: 0x1)
AnimCompress_PerTrackCompression.bUseOverrideForEndEffectors = 0xac // uint8_t (Size: 0x1)
AnimCompress_PerTrackCompression.TrackHeightBias = 0xb0 // int32_t (Size: 0x4)
AnimCompress_PerTrackCompression.ParentingDivisor = 0xb4 // float (Size: 0x4)
AnimCompress_PerTrackCompression.ParentingDivisorExponent = 0xb8 // float (Size: 0x4)
AnimCompress_PerTrackCompression.bUseAdaptiveError2 = 0xbc // uint8_t (Size: 0x1)
AnimCompress_PerTrackCompression.RotationErrorSourceRatio = 0xc0 // float (Size: 0x4)
AnimCompress_PerTrackCompression.TranslationErrorSourceRatio = 0xc4 // float (Size: 0x4)
AnimCompress_PerTrackCompression.ScaleErrorSourceRatio = 0xc8 // float (Size: 0x4)
AnimCompress_PerTrackCompression.MaxErrorPerTrackRatio = 0xcc // float (Size: 0x4)
AnimCompress_PerTrackCompression.PerturbationProbeSize = 0xd0 // float (Size: 0x4)
AnimCompress_RemoveEverySecondKey.MinKeys = 0x40 // int32_t (Size: 0x4)
AnimCompress_RemoveEverySecondKey.bStartAtSecondKey = 0x44 // uint8_t (Size: 0x1)
AnimCompress_RemoveLinearKeys.MaxPosDiff = 0x40 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.MaxAngleDiff = 0x44 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.MaxScaleDiff = 0x48 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.MaxEffectorDiff = 0x4c // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.MinEffectorDiff = 0x50 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.EffectorDiffSocket = 0x54 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.ParentKeyScale = 0x58 // float (Size: 0x4)
AnimCompress_RemoveLinearKeys.bRetarget = 0x5c // uint8_t (Size: 0x1)
AnimCompress_RemoveLinearKeys.bActuallyFilterLinearKeys = 0x5c // uint8_t (Size: 0x1)
AnimCompress_RemoveTrivialKeys.MaxPosDiff = 0x40 // float (Size: 0x4)
AnimCompress_RemoveTrivialKeys.MaxAngleDiff = 0x44 // float (Size: 0x4)
AnimCompress_RemoveTrivialKeys.MaxScaleDiff = 0x48 // float (Size: 0x4)
AnimControlTrackKey.StartTime = 0x0 // float (Size: 0x4)
AnimControlTrackKey.AnimSeq = 0x8 // AnimSequence* (Size: 0x8)
AnimControlTrackKey.AnimStartOffset = 0x10 // float (Size: 0x4)
AnimControlTrackKey.AnimEndOffset = 0x14 // float (Size: 0x4)
AnimControlTrackKey.AnimPlayRate = 0x18 // float (Size: 0x4)
AnimControlTrackKey.bLooping = 0x1c // uint8_t (Size: 0x1)
AnimControlTrackKey.bReverse = 0x1c // uint8_t (Size: 0x1)
AnimCurveBase.LastObservedName = 0x0 // FName (Size: 0x8)
AnimCurveBase.Name = 0x8 // FSmartName (Size: 0xc)
AnimCurveBase.CurveTypeFlags = 0x14 // int32_t (Size: 0x4)
AnimCurveCompressionSettings.Codec = 0x28 // AnimCurveCompressionCodec* (Size: 0x8)
AnimCurveParam.Name = 0x0 // FName (Size: 0x8)
AnimGraphBlendOptions.BlendInTime = 0x0 // float (Size: 0x4)
AnimGraphBlendOptions.BlendOutTime = 0x4 // float (Size: 0x4)
AnimGroupInfo.Name = 0x0 // FName (Size: 0x8)
AnimGroupInfo.Color = 0x8 // FLinearColor (Size: 0x10)
AnimInstance.CurrentSkeleton = 0x28 // Skeleton* (Size: 0x8)
AnimInstance.RootMotionMode = 0x30 // uint8_t (Size: 0x1)
AnimInstance.bUseMultiThreadedAnimationUpdate = 0x31 // uint8_t (Size: 0x1)
AnimInstance.bUsingCopyPoseFromMesh = 0x31 // uint8_t (Size: 0x1)
AnimInstance.bReceiveNotifiesFromLinkedInstances = 0x31 // uint8_t (Size: 0x1)
AnimInstance.bPropagateNotifiesToLinkedInstances = 0x31 // uint8_t (Size: 0x1)
AnimInstance.bQueueMontageEvents = 0x31 // uint8_t (Size: 0x1)
AnimInstance.OnMontageBlendingOut = 0x38 // FMulticastInlineDelegate (Size: 0x10)
AnimInstance.OnMontageStarted = 0x48 // FMulticastInlineDelegate (Size: 0x10)
AnimInstance.OnMontageEnded = 0x58 // FMulticastInlineDelegate (Size: 0x10)
AnimInstance.OnAllMontageInstancesEnded = 0x68 // FMulticastInlineDelegate (Size: 0x10)
AnimInstance.NotifyQueue = 0x100 // FAnimNotifyQueue (Size: 0x70)
AnimInstance.ActiveAnimNotifyState = 0x170 // TArray<FAnimNotifyEvent> (Size: 0x10)
AnimLinkableElement.LinkedMontage = 0x8 // AnimMontage* (Size: 0x8)
AnimLinkableElement.SlotIndex = 0x10 // int32_t (Size: 0x4)
AnimLinkableElement.SegmentIndex = 0x14 // int32_t (Size: 0x4)
AnimLinkableElement.LinkMethod = 0x18 // uint8_t (Size: 0x1)
AnimLinkableElement.CachedLinkMethod = 0x19 // uint8_t (Size: 0x1)
AnimLinkableElement.SegmentBeginTime = 0x1c // float (Size: 0x4)
AnimLinkableElement.SegmentLength = 0x20 // float (Size: 0x4)
AnimLinkableElement.LinkValue = 0x24 // float (Size: 0x4)
AnimLinkableElement.LinkedSequence = 0x28 // AnimSequenceBase* (Size: 0x8)
AnimMontage.BlendIn = 0xa8 // FAlphaBlend (Size: 0x30)
AnimMontage.BlendInTime = 0xd8 // float (Size: 0x4)
AnimMontage.BlendOut = 0xe0 // FAlphaBlend (Size: 0x30)
AnimMontage.BlendOutTime = 0x110 // float (Size: 0x4)
AnimMontage.BlendOutTriggerTime = 0x114 // float (Size: 0x4)
AnimMontage.SyncGroup = 0x118 // FName (Size: 0x8)
AnimMontage.SyncSlotIndex = 0x120 // int32_t (Size: 0x4)
AnimMontage.MarkerData = 0x128 // FMarkerSyncData (Size: 0x20)
AnimMontage.CompositeSections = 0x148 // TArray<FCompositeSection> (Size: 0x10)
AnimMontage.SlotAnimTracks = 0x158 // TArray<FSlotAnimationTrack> (Size: 0x10)
AnimMontage.BranchingPoints = 0x168 // TArray<FBranchingPoint> (Size: 0x10)
AnimMontage.bEnableRootMotionTranslation = 0x178 // bool (Size: 0x1)
AnimMontage.bEnableRootMotionRotation = 0x179 // bool (Size: 0x1)
AnimMontage.bEnableAutoBlendOut = 0x17a // bool (Size: 0x1)
AnimMontage.RootMotionRootLock = 0x17b // uint8_t (Size: 0x1)
AnimMontage.BranchingPointMarkers = 0x180 // TArray<FBranchingPointMarker> (Size: 0x10)
AnimMontage.BranchingPointStateNotifyIndices = 0x190 // TArray<int32_t> (Size: 0x10)
AnimMontage.TimeStretchCurve = 0x1a0 // FTimeStretchCurve (Size: 0x28)
AnimMontage.TimeStretchCurveName = 0x1c8 // FName (Size: 0x8)
AnimMontageInstance.Montage = 0x0 // AnimMontage* (Size: 0x8)
AnimMontageInstance.bPlaying = 0x28 // bool (Size: 0x1)
AnimMontageInstance.DefaultBlendTimeMultiplier = 0x2c // float (Size: 0x4)
AnimMontageInstance.NextSections = 0xe8 // TArray<int32_t> (Size: 0x10)
AnimMontageInstance.PrevSections = 0xf8 // TArray<int32_t> (Size: 0x10)
AnimMontageInstance.ActiveStateBranchingPoints = 0x118 // TArray<FAnimNotifyEvent> (Size: 0x10)
AnimMontageInstance.position = 0x128 // float (Size: 0x4)
AnimMontageInstance.PlayRate = 0x12c // float (Size: 0x4)
AnimMontageInstance.Blend = 0x130 // FAlphaBlend (Size: 0x30)
AnimMontageInstance.DisableRootMotionCount = 0x18c // int32_t (Size: 0x4)
AnimNode_ApplyMeshSpaceAdditive.Base = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ApplyMeshSpaceAdditive.Additive = 0x20 // FPoseLink (Size: 0x10)
AnimNode_ApplyMeshSpaceAdditive.AlphaInputType = 0x30 // EEAnimAlphaInputType (Size: 0x1)
AnimNode_ApplyMeshSpaceAdditive.Alpha = 0x34 // float (Size: 0x4)
AnimNode_ApplyMeshSpaceAdditive.bAlphaBoolEnabled = 0x38 // uint8_t (Size: 0x1)
AnimNode_ApplyMeshSpaceAdditive.AlphaBoolBlend = 0x40 // FInputAlphaBoolBlend (Size: 0x48)
AnimNode_ApplyMeshSpaceAdditive.AlphaCurveName = 0x88 // FName (Size: 0x8)
AnimNode_ApplyMeshSpaceAdditive.AlphaScaleBias = 0x90 // FInputScaleBias (Size: 0x8)
AnimNode_ApplyMeshSpaceAdditive.AlphaScaleBiasClamp = 0x98 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_ApplyMeshSpaceAdditive.LODThreshold = 0xc8 // int32_t (Size: 0x4)
AnimNode_AssetPlayerBase.GroupName = 0x10 // FName (Size: 0x8)
AnimNode_AssetPlayerBase.GroupRole = 0x18 // uint8_t (Size: 0x1)
AnimNode_AssetPlayerBase.GroupScope = 0x19 // EEAnimSyncGroupScope (Size: 0x1)
AnimNode_AssetPlayerBase.bIgnoreForRelevancyTest = 0x1a // bool (Size: 0x1)
AnimNode_AssetPlayerBase.BlendWeight = 0x1c // float (Size: 0x4)
AnimNode_AssetPlayerBase.InternalTimeAccumulator = 0x20 // float (Size: 0x4)
AnimNode_ConvertComponentToLocalSpace.ComponentPose = 0x10 // FComponentSpacePoseLink (Size: 0x10)
AnimNode_ConvertLocalToComponentSpace.LocalPose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_CustomProperty.SourcePropertyNames = 0x10 // TArray<FName> (Size: 0x10)
AnimNode_CustomProperty.DestPropertyNames = 0x20 // TArray<FName> (Size: 0x10)
AnimNode_CustomProperty.TargetInstance = 0x30 // Object* (Size: 0x8)
AnimNode_Inertialization.Source = 0x10 // FPoseLink (Size: 0x10)
AnimNode_LinkedAnimGraph.InputPoses = 0x58 // TArray<FPoseLink> (Size: 0x10)
AnimNode_LinkedAnimGraph.InputPoseNames = 0x68 // TArray<FName> (Size: 0x10)
AnimNode_LinkedAnimGraph.InstanceClass = 0x78 // ClassProperty (Size: 0x8)
AnimNode_LinkedAnimGraph.Tag = 0x80 // FName (Size: 0x8)
AnimNode_LinkedAnimGraph.bReceiveNotifiesFromLinkedInstances = 0x9c // uint8_t (Size: 0x1)
AnimNode_LinkedAnimGraph.bPropagateNotifiesToLinkedInstances = 0x9c // uint8_t (Size: 0x1)
AnimNode_LinkedAnimLayer.Interface = 0xa0 // ClassProperty (Size: 0x8)
AnimNode_LinkedAnimLayer.Layer = 0xa8 // FName (Size: 0x8)
AnimNode_LinkedInputPose.Name = 0x10 // FName (Size: 0x8)
AnimNode_LinkedInputPose.Graph = 0x18 // FName (Size: 0x8)
AnimNode_LinkedInputPose.InputPose = 0x20 // FPoseLink (Size: 0x10)
AnimNode_Root.Result = 0x10 // FPoseLink (Size: 0x10)
AnimNode_Root.Name = 0x20 // FName (Size: 0x8)
AnimNode_Root.Group = 0x28 // FName (Size: 0x8)
AnimNode_SaveCachedPose.pose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_SaveCachedPose.CachePoseName = 0x20 // FName (Size: 0x8)
AnimNode_SaveCachedPose.bCachePoseInAnimInstanceProxy = 0x2c // bool (Size: 0x1)
AnimNode_SequencePlayer.Sequence = 0x120 // AnimSequenceBase* (Size: 0x8)
AnimNode_SequencePlayer.PlayRateBasis = 0x128 // float (Size: 0x4)
AnimNode_SequencePlayer.PlayRate = 0x12c // float (Size: 0x4)
AnimNode_SequencePlayer.PlayRateScaleBiasClamp = 0x130 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_SequencePlayer.StartPosition = 0x160 // float (Size: 0x4)
AnimNode_SequencePlayer.bLoopAnimation = 0x164 // bool (Size: 0x1)
AnimNode_SequencePlayer.bResetAccumulateTimeWhenActive = 0x165 // bool (Size: 0x1)
AnimNode_SequencePlayer.bSyncPlayTimeRatio = 0x16c // bool (Size: 0x1)
AnimNode_SequencePlayer.LastPlayAnimSeq = 0x170 // AnimSequenceBase* (Size: 0x8)
AnimNode_SingleNode.SourcePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_StateMachine.StateMachineIndexInClass = 0x10 // int32_t (Size: 0x4)
AnimNode_StateMachine.MaxTransitionsPerFrame = 0x14 // int32_t (Size: 0x4)
AnimNode_StateMachine.bSkipFirstUpdateTransition = 0x18 // bool (Size: 0x1)
AnimNode_StateMachine.bReinitializeOnBecomingRelevant = 0x19 // bool (Size: 0x1)
AnimNode_TransitionPoseEvaluator.FramesToCachePose = 0xe8 // int32_t (Size: 0x4)
AnimNode_TransitionPoseEvaluator.DataSource = 0xf0 // uint8_t (Size: 0x1)
AnimNode_TransitionPoseEvaluator.EvaluatorMode = 0xf1 // uint8_t (Size: 0x1)
AnimNode_TransitionResult.bCanEnterTransition = 0x10 // bool (Size: 0x1)
AnimNode_UseCachedPose.LinkToCachingNode = 0x10 // FPoseLink (Size: 0x10)
AnimNode_UseCachedPose.CachePoseName = 0x20 // FName (Size: 0x8)
AnimNotifyArray.Notifies = 0x0 // TArray<FAnimNotifyEventReference> (Size: 0x10)
AnimNotifyEvent.DisplayTime = 0x30 // float (Size: 0x4)
AnimNotifyEvent.TriggerTimeOffset = 0x34 // float (Size: 0x4)
AnimNotifyEvent.EndTriggerTimeOffset = 0x38 // float (Size: 0x4)
AnimNotifyEvent.TriggerWeightThreshold = 0x3c // float (Size: 0x4)
AnimNotifyEvent.NotifyName = 0x40 // FName (Size: 0x8)
AnimNotifyEvent.Notify = 0x48 // AnimNotify* (Size: 0x8)
AnimNotifyEvent.NotifyStateClass = 0x50 // AnimNotifyState* (Size: 0x8)
AnimNotifyEvent.Duration = 0x58 // float (Size: 0x4)
AnimNotifyEvent.EndLink = 0x60 // FAnimLinkableElement (Size: 0x30)
AnimNotifyEvent.bConvertedFromBranchingPoint = 0x90 // bool (Size: 0x1)
AnimNotifyEvent.MontageTickType = 0x91 // uint8_t (Size: 0x1)
AnimNotifyEvent.NotifyTriggerChance = 0x94 // float (Size: 0x4)
AnimNotifyEvent.NotifyFilterType = 0x98 // uint8_t (Size: 0x1)
AnimNotifyEvent.NotifyFilterLOD = 0x9c // int32_t (Size: 0x4)
AnimNotifyEvent.bTriggerOnDedicatedServer = 0xa0 // bool (Size: 0x1)
AnimNotifyEvent.bTriggerOnFollower = 0xa1 // bool (Size: 0x1)
AnimNotifyEvent.TrackIndex = 0xa4 // int32_t (Size: 0x4)
AnimNotifyEventReference.NotifySource = 0x8 // Object* (Size: 0x8)
AnimNotifyQueue.AnimNotifies = 0x10 // TArray<FAnimNotifyEventReference> (Size: 0x10)
AnimNotifyQueue.UnfilteredMontageAnimNotifies = 0x20 // TMap<...> (Size: 0x50)
AnimNotifyState_TimedParticleEffect.PSTemplate = 0x30 // ParticleSystem* (Size: 0x8)
AnimNotifyState_TimedParticleEffect.SocketName = 0x38 // FName (Size: 0x8)
AnimNotifyState_TimedParticleEffect.LocationOffset = 0x40 // FVector (Size: 0xc)
AnimNotifyState_TimedParticleEffect.RotationOffset = 0x4c // FRotator (Size: 0xc)
AnimNotifyState_TimedParticleEffect.bDestroyAtEnd = 0x58 // bool (Size: 0x1)
AnimNotifyState_Trail.PSTemplate = 0x30 // ParticleSystem* (Size: 0x8)
AnimNotifyState_Trail.FirstSocketName = 0x38 // FName (Size: 0x8)
AnimNotifyState_Trail.SecondSocketName = 0x40 // FName (Size: 0x8)
AnimNotifyState_Trail.WidthScaleMode = 0x48 // uint8_t (Size: 0x1)
AnimNotifyState_Trail.WidthScaleCurve = 0x4c // FName (Size: 0x8)
AnimNotifyState_Trail.bRecycleSpawnedSystems = 0x54 // uint8_t (Size: 0x1)
AnimNotifyTrack.TrackName = 0x0 // FName (Size: 0x8)
AnimNotifyTrack.TrackColor = 0x8 // FLinearColor (Size: 0x10)
AnimNotify_PlayParticleEffect.PSTemplate = 0x38 // ParticleSystem* (Size: 0x8)
AnimNotify_PlayParticleEffect.LocationOffset = 0x40 // FVector (Size: 0xc)
AnimNotify_PlayParticleEffect.RotationOffset = 0x4c // FRotator (Size: 0xc)
AnimNotify_PlayParticleEffect.Scale = 0x58 // FVector (Size: 0xc)
AnimNotify_PlayParticleEffect.TranslucentSortPriority = 0x64 // int32_t (Size: 0x4)
AnimNotify_PlayParticleEffect.Attached = 0x80 // uint8_t (Size: 0x1)
AnimNotify_PlayParticleEffect.SocketName = 0x84 // FName (Size: 0x8)
AnimNotify_PlaySound.Sound = 0x38 // SoundBase* (Size: 0x8)
AnimNotify_PlaySound.VolumeMultiplier = 0x40 // float (Size: 0x4)
AnimNotify_PlaySound.PitchMultiplier = 0x44 // float (Size: 0x4)
AnimNotify_PlaySound.bFollow = 0x48 // uint8_t (Size: 0x1)
AnimNotify_PlaySound.AttachName = 0x4c // FName (Size: 0x8)
AnimParentNodeAssetOverride.NewAsset = 0x0 // AnimationAsset* (Size: 0x8)
AnimParentNodeAssetOverride.ParentNodeGuid = 0x8 // FGuid (Size: 0x10)
AnimSegment.AnimReference = 0x0 // AnimSequenceBase* (Size: 0x8)
AnimSegment.StartPos = 0x8 // float (Size: 0x4)
AnimSegment.AnimStartTime = 0xc // float (Size: 0x4)
AnimSegment.AnimEndTime = 0x10 // float (Size: 0x4)
AnimSegment.AnimPlayRate = 0x14 // float (Size: 0x4)
AnimSegment.LoopingCount = 0x18 // int32_t (Size: 0x4)
AnimSequence.NumFrames = 0xa8 // int32_t (Size: 0x4)
AnimSequence.TrackToSkeletonMapTable = 0xb0 // TArray<FTrackToSkeletonMap> (Size: 0x10)
AnimSequence.BoneCompressionSettings = 0xd0 // AnimBoneCompressionSettings* (Size: 0x8)
AnimSequence.CurveCompressionSettings = 0xd8 // AnimCurveCompressionSettings* (Size: 0x8)
AnimSequence.AdditiveAnimType = 0x150 // uint8_t (Size: 0x1)
AnimSequence.RefPoseType = 0x151 // uint8_t (Size: 0x1)
AnimSequence.RefPoseSeq = 0x158 // AnimSequence* (Size: 0x8)
AnimSequence.RefFrameIndex = 0x160 // int32_t (Size: 0x4)
AnimSequence.RetargetSource = 0x164 // FName (Size: 0x8)
AnimSequence.Interpolation = 0x16c // EEAnimInterpolationType (Size: 0x1)
AnimSequence.bEnableRootMotion = 0x16d // bool (Size: 0x1)
AnimSequence.RootMotionRootLock = 0x16e // uint8_t (Size: 0x1)
AnimSequence.bForceRootLock = 0x16f // bool (Size: 0x1)
AnimSequence.bUseNormalizedRootMotionScale = 0x170 // bool (Size: 0x1)
AnimSequence.bRootMotionSettingsCopiedFromMontage = 0x171 // bool (Size: 0x1)
AnimSequence.AuthoredSyncMarkers = 0x178 // TArray<FAnimSyncMarker> (Size: 0x10)
AnimSequence.BakedPerBoneCustomAttributeData = 0x1a0 // TArray<FBakedCustomAttributePerBoneData> (Size: 0x10)
AnimSequenceBase.Notifies = 0x80 // TArray<FAnimNotifyEvent> (Size: 0x10)
AnimSequenceBase.SequenceLength = 0x90 // float (Size: 0x4)
AnimSequenceBase.RateScale = 0x94 // float (Size: 0x4)
AnimSequenceBase.RawCurveData = 0x98 // FRawCurveTracks (Size: 0x10)
AnimSequenceTrackContainer.AnimationTracks = 0x0 // TArray<FRawAnimSequenceTrack> (Size: 0x10)
AnimSequenceTrackContainer.TrackNames = 0x10 // TArray<FName> (Size: 0x10)
AnimSet.bAnimRotationOnly = 0x28 // uint8_t (Size: 0x1)
AnimSet.TrackBoneNames = 0x30 // TArray<FName> (Size: 0x10)
AnimSet.LinkupCache = 0x40 // TArray<FAnimSetMeshLinkup> (Size: 0x10)
AnimSet.BoneUseAnimTranslation = 0x50 // TArray<uint8_t> (Size: 0x10)
AnimSet.ForceUseMeshTranslation = 0x60 // TArray<uint8_t> (Size: 0x10)
AnimSet.UseTranslationBoneNames = 0x70 // TArray<FName> (Size: 0x10)
AnimSet.ForceMeshTranslationBoneNames = 0x80 // TArray<FName> (Size: 0x10)
AnimSet.PreviewSkelMeshName = 0x90 // FName (Size: 0x8)
AnimSet.BestRatioSkelMeshName = 0x98 // FName (Size: 0x8)
AnimSetMeshLinkup.BoneToTrackTable = 0x0 // TArray<int32_t> (Size: 0x10)
AnimSingleNodeInstance.CurrentAsset = 0x2b8 // AnimationAsset* (Size: 0x8)
AnimSingleNodeInstance.PostEvaluateAnimEvent = 0x2c0 // FDelegate (Size: 0x10)
AnimSlotDesc.SlotName = 0x0 // FName (Size: 0x8)
AnimSlotDesc.NumChannels = 0x8 // int32_t (Size: 0x4)
AnimSlotGroup.GroupName = 0x0 // FName (Size: 0x8)
AnimSlotGroup.SlotNames = 0x8 // TArray<FName> (Size: 0x10)
AnimSlotInfo.SlotName = 0x0 // FName (Size: 0x8)
AnimSlotInfo.ChannelWeights = 0x8 // TArray<float> (Size: 0x10)
AnimStreamable.NumFrames = 0xa8 // int32_t (Size: 0x4)
AnimStreamable.Interpolation = 0xac // EEAnimInterpolationType (Size: 0x1)
AnimStreamable.RetargetSource = 0xb0 // FName (Size: 0x8)
AnimStreamable.BoneCompressionSettings = 0xc8 // AnimBoneCompressionSettings* (Size: 0x8)
AnimStreamable.CurveCompressionSettings = 0xd0 // AnimCurveCompressionSettings* (Size: 0x8)
AnimStreamable.bEnableRootMotion = 0xd8 // bool (Size: 0x1)
AnimStreamable.RootMotionRootLock = 0xd9 // uint8_t (Size: 0x1)
AnimStreamable.bForceRootLock = 0xda // bool (Size: 0x1)
AnimStreamable.bUseNormalizedRootMotionScale = 0xdb // bool (Size: 0x1)
AnimSyncMarker.MarkerName = 0x0 // FName (Size: 0x8)
AnimSyncMarker.Time = 0x8 // float (Size: 0x4)
AnimTickRecord.SourceAsset = 0x0 // AnimationAsset* (Size: 0x8)
AnimTrack.AnimSegments = 0x0 // TArray<FAnimSegment> (Size: 0x10)
AnimUpdateRateParameters.ShiftBucket = 0x1 // EEUpdateRateShiftBucket (Size: 0x1)
AnimUpdateRateParameters.bInterpolateSkippedFrames = 0x2 // uint8_t (Size: 0x1)
AnimUpdateRateParameters.bShouldUseLodMap = 0x2 // uint8_t (Size: 0x1)
AnimUpdateRateParameters.bShouldUseMinLod = 0x2 // uint8_t (Size: 0x1)
AnimUpdateRateParameters.bSkipUpdate = 0x2 // uint8_t (Size: 0x1)
AnimUpdateRateParameters.bSkipEvaluation = 0x2 // uint8_t (Size: 0x1)
AnimUpdateRateParameters.UpdateRate = 0x4 // int32_t (Size: 0x4)
AnimUpdateRateParameters.EvaluationRate = 0x8 // int32_t (Size: 0x4)
AnimUpdateRateParameters.TickedPoseOffestTime = 0xc // float (Size: 0x4)
AnimUpdateRateParameters.AdditionalTime = 0x10 // float (Size: 0x4)
AnimUpdateRateParameters.BaseNonRenderedUpdateRate = 0x18 // int32_t (Size: 0x4)
AnimUpdateRateParameters.MaxEvalRateForInterpolation = 0x1c // int32_t (Size: 0x4)
AnimUpdateRateParameters.BaseVisibleDistanceFactorThesholds = 0x20 // TArray<float> (Size: 0x10)
AnimUpdateRateParameters.LODToFrameSkipMap = 0x30 // TMap<...> (Size: 0x50)
AnimUpdateRateParameters.SkippedUpdateFrames = 0x80 // int32_t (Size: 0x4)
AnimUpdateRateParameters.SkippedEvalFrames = 0x84 // int32_t (Size: 0x4)
AnimUpdateRateParameters.bEnableLoadBalance = 0x88 // bool (Size: 0x1)
AnimUpdateRateParameters.LogicUpdateRate = 0x8c // int32_t (Size: 0x4)
AnimUpdateRateParameters.LoadBalanceTag = 0x90 // FName (Size: 0x8)
AnimUpdateRateParameters.LoadBalanceTrackerNum = 0x98 // int32_t (Size: 0x4)
AnimUpdateRateParameters.MaxEvalRateForInterpolationAfterLoadBalance = 0x9c // int32_t (Size: 0x4)
AnimUpdateRateParameters.LoadBalanceBudget = 0xa0 // float (Size: 0x4)
AnimUpdateRateParameters.LoadBalanceBudgetUsed = 0xa4 // float (Size: 0x4)
AnimUpdateRateParameters.LoadBalanceBudgetUsedOptimized = 0xa8 // float (Size: 0x4)
AnimUpdateRateParameters.UpdateRateBeforeLoadBalance = 0xac // int32_t (Size: 0x4)
AnimUpdateRateParameters.bUseParentURO = 0xb0 // bool (Size: 0x1)
AnimUpdateRateParameters.bOnlyUseFirstRegisteredComponentDistFactor = 0xb1 // bool (Size: 0x1)
AnimUpdateRateParameters.bNeedsEveryFrameWhenPlayingMontage = 0xb2 // bool (Size: 0x1)
AnimUpdateRateParameters.bNeedsEveryFrame = 0xb3 // bool (Size: 0x1)
AnimationActiveTransitionEntry.BlendProfile = 0xb8 // BlendProfile* (Size: 0x8)
AnimationAsset.Skeleton = 0x38 // Skeleton* (Size: 0x8)
AnimationAsset.MetaData = 0x60 // TArray<AnimMetaData*> (Size: 0x10)
AnimationAsset.AssetUserData = 0x70 // TArray<AssetUserData*> (Size: 0x10)
AnimationGroupReference.GroupName = 0x0 // FName (Size: 0x8)
AnimationGroupReference.GroupRole = 0x8 // uint8_t (Size: 0x1)
AnimationGroupReference.GroupScope = 0x9 // EEAnimSyncGroupScope (Size: 0x1)
AnimationRecordingSettings.bRecordInWorldSpace = 0x0 // bool (Size: 0x1)
AnimationRecordingSettings.bRemoveRootAnimation = 0x1 // bool (Size: 0x1)
AnimationRecordingSettings.bAutoSaveAsset = 0x2 // bool (Size: 0x1)
AnimationRecordingSettings.SampleRate = 0x4 // float (Size: 0x4)
AnimationRecordingSettings.Length = 0x8 // float (Size: 0x4)
AnimationRecordingSettings.InterpMode = 0xc // uint8_t (Size: 0x1)
AnimationRecordingSettings.TangentMode = 0xd // uint8_t (Size: 0x1)
AnimationRecordingSettings.bRecordTransforms = 0xf // bool (Size: 0x1)
AnimationRecordingSettings.bRecordCurves = 0x10 // bool (Size: 0x1)
AnimationSettings.CompressCommandletVersion = 0x38 // int32_t (Size: 0x4)
AnimationSettings.KeyEndEffectorsMatchNameArray = 0x40 // TArray<FString> (Size: 0x10)
AnimationSettings.ForceRecompression = 0x50 // bool (Size: 0x1)
AnimationSettings.bForceBelowThreshold = 0x51 // bool (Size: 0x1)
AnimationSettings.bFirstRecompressUsingCurrentOrDefault = 0x52 // bool (Size: 0x1)
AnimationSettings.bRaiseMaxErrorToExisting = 0x53 // bool (Size: 0x1)
AnimationSettings.bEnablePerformanceLog = 0x54 // bool (Size: 0x1)
AnimationSettings.bStripAnimationDataOnDedicatedServer = 0x55 // bool (Size: 0x1)
AnimationSettings.bTickAnimationOnSkeletalMeshInit = 0x56 // bool (Size: 0x1)
AnimationSettings.BoneCustomAttributesNames = 0x58 // TArray<FCustomAttributeSetting> (Size: 0x10)
AnimationSettings.BoneNamesWithCustomAttributes = 0x68 // TArray<FString> (Size: 0x10)
AnimationSettings.AttributeBlendModes = 0x78 // TMap<...> (Size: 0x50)
AnimationSettings.DefaultAttributeBlendMode = 0xc8 // EECustomAttributeBlendType (Size: 0x1)
AnimationSettings.bEnableAnimNodeModifyBoneSkipEvaluateWhenBoneTransformUnchanged = 0xc9 // bool (Size: 0x1)
AnimationState.Transitions = 0x8 // TArray<FAnimationTransitionRule> (Size: 0x10)
AnimationState.StateRootNodeIndex = 0x18 // int32_t (Size: 0x4)
AnimationState.StartNotify = 0x1c // int32_t (Size: 0x4)
AnimationState.EndNotify = 0x20 // int32_t (Size: 0x4)
AnimationState.FullyBlendedNotify = 0x24 // int32_t (Size: 0x4)
AnimationStateBase.StateName = 0x0 // FName (Size: 0x8)
AnimationTransitionBetweenStates.PreviousState = 0x8 // int32_t (Size: 0x4)
AnimationTransitionBetweenStates.NextState = 0xc // int32_t (Size: 0x4)
AnimationTransitionBetweenStates.CrossfadeDuration = 0x10 // float (Size: 0x4)
AnimationTransitionBetweenStates.StartNotify = 0x14 // int32_t (Size: 0x4)
AnimationTransitionBetweenStates.EndNotify = 0x18 // int32_t (Size: 0x4)
AnimationTransitionBetweenStates.InterruptNotify = 0x1c // int32_t (Size: 0x4)
AnimationTransitionBetweenStates.BlendMode = 0x20 // EEAlphaBlendOption (Size: 0x1)
AnimationTransitionBetweenStates.CustomCurve = 0x28 // CurveFloat* (Size: 0x8)
AnimationTransitionBetweenStates.BlendProfile = 0x30 // BlendProfile* (Size: 0x8)
AnimationTransitionBetweenStates.LogicType = 0x38 // uint8_t (Size: 0x1)
AnimationTransitionRule.RuleToExecute = 0x0 // FName (Size: 0x8)
AnimationTransitionRule.TransitionReturnVal = 0x8 // bool (Size: 0x1)
AnimationTransitionRule.TransitionIndex = 0xc // int32_t (Size: 0x4)
ApplicationLifecycleComponent.ApplicationWillDeactivateDelegate = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationHasReactivatedDelegate = 0x108 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationWillEnterBackgroundDelegate = 0x118 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationHasEnteredForegroundDelegate = 0x128 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationWillTerminateDelegate = 0x138 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationShouldUnloadResourcesDelegate = 0x148 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.ApplicationReceivedStartupArgumentsDelegate = 0x158 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.OnTemperatureChangeDelegate = 0x168 // FMulticastInlineDelegate (Size: 0x10)
ApplicationLifecycleComponent.OnLowPowerModeDelegate = 0x178 // FMulticastInlineDelegate (Size: 0x10)
ArrowComponent.ArrowColor = 0x5c8 // FColor (Size: 0x4)
ArrowComponent.ArrowSize = 0x5cc // float (Size: 0x4)
ArrowComponent.ArrowLength = 0x5d0 // float (Size: 0x4)
ArrowComponent.ScreenSize = 0x5d4 // float (Size: 0x4)
ArrowComponent.bIsScreenSizeScaled = 0x5d8 // uint8_t (Size: 0x1)
ArrowComponent.bTreatAsASprite = 0x5d8 // uint8_t (Size: 0x1)
AssetEditorOrbitCameraPosition.bIsSet = 0x0 // bool (Size: 0x1)
AssetEditorOrbitCameraPosition.CamOrbitPoint = 0x4 // FVector (Size: 0xc)
AssetEditorOrbitCameraPosition.CamOrbitZoom = 0x10 // FVector (Size: 0xc)
AssetEditorOrbitCameraPosition.CamOrbitRotation = 0x1c // FRotator (Size: 0xc)
AssetExportTask.Object = 0x28 // Object* (Size: 0x8)
AssetExportTask.Exporter = 0x30 // Exporter* (Size: 0x8)
AssetExportTask.Filename = 0x38 // FString (Size: 0x10)
AssetExportTask.bSelected = 0x48 // bool (Size: 0x1)
AssetExportTask.bReplaceIdentical = 0x49 // bool (Size: 0x1)
AssetExportTask.bPrompt = 0x4a // bool (Size: 0x1)
AssetExportTask.bAutomated = 0x4b // bool (Size: 0x1)
AssetExportTask.bUseFileArchive = 0x4c // bool (Size: 0x1)
AssetExportTask.bWriteEmptyFiles = 0x4d // bool (Size: 0x1)
AssetExportTask.IgnoreObjectList = 0x50 // TArray<Object*> (Size: 0x10)
AssetExportTask.Options = 0x60 // Object* (Size: 0x8)
AssetExportTask.Errors = 0x68 // TArray<FString> (Size: 0x10)
AssetManager.ObjectReferenceList = 0x2c0 // TArray<Object*> (Size: 0x10)
AssetManager.bIsGlobalAsyncScanEnvironment = 0x2d0 // bool (Size: 0x1)
AssetManager.bShouldGuessTypeAndName = 0x2d1 // bool (Size: 0x1)
AssetManager.bShouldUseSynchronousLoad = 0x2d2 // bool (Size: 0x1)
AssetManager.bIsLoadingFromPakFiles = 0x2d3 // bool (Size: 0x1)
AssetManager.bShouldAcquireMissingChunksOnLoad = 0x2d4 // bool (Size: 0x1)
AssetManager.bOnlyCookProductionAssets = 0x2d5 // bool (Size: 0x1)
AssetManager.bIsBulkScanning = 0x2d6 // bool (Size: 0x1)
AssetManager.bIsPrimaryAssetDirectoryCurrent = 0x2d7 // bool (Size: 0x1)
AssetManager.bIsManagementDatabaseCurrent = 0x2d8 // bool (Size: 0x1)
AssetManager.bUpdateManagementDatabaseAfterScan = 0x2d9 // bool (Size: 0x1)
AssetManager.bIncludeOnlyOnDiskAssets = 0x2da // bool (Size: 0x1)
AssetManager.bHasCompletedInitialScan = 0x2db // bool (Size: 0x1)
AssetManager.NumberOfSpawnedNotifications = 0x2dc // int32_t (Size: 0x4)
AssetManagerRedirect.Old = 0x0 // FString (Size: 0x10)
AssetManagerRedirect.New = 0x10 // FString (Size: 0x10)
AssetManagerSettings.PrimaryAssetTypesToScan = 0x38 // TArray<FPrimaryAssetTypeInfo> (Size: 0x10)
AssetManagerSettings.DirectoriesToExclude = 0x48 // TArray<FDirectoryPath> (Size: 0x10)
AssetManagerSettings.PrimaryAssetRules = 0x58 // TArray<FPrimaryAssetRulesOverride> (Size: 0x10)
AssetManagerSettings.CustomPrimaryAssetRules = 0x68 // TArray<FPrimaryAssetRulesCustomOverride> (Size: 0x10)
AssetManagerSettings.bOnlyCookProductionAssets = 0x78 // bool (Size: 0x1)
AssetManagerSettings.bShouldManagerDetermineTypeAndName = 0x79 // bool (Size: 0x1)
AssetManagerSettings.bShouldGuessTypeAndNameInEditor = 0x7a // bool (Size: 0x1)
AssetManagerSettings.bShouldAcquireMissingChunksOnLoad = 0x7b // bool (Size: 0x1)
AssetManagerSettings.PrimaryAssetIdRedirects = 0x80 // TArray<FAssetManagerRedirect> (Size: 0x10)
AssetManagerSettings.PrimaryAssetTypeRedirects = 0x90 // TArray<FAssetManagerRedirect> (Size: 0x10)
AssetManagerSettings.AssetPathRedirects = 0xa0 // TArray<FAssetManagerRedirect> (Size: 0x10)
AssetManagerSettings.MetaDataTagsForAssetRegistry = 0xb0 // TSet<...> (Size: 0x50)
AssetMapping.SourceAsset = 0x0 // AnimationAsset* (Size: 0x8)
AssetMapping.TargetAsset = 0x8 // AnimationAsset* (Size: 0x8)
AssetMappingTable.MappedAssets = 0x28 // TArray<FAssetMapping> (Size: 0x10)
AsyncActionChangePrimaryAssetBundles.Completed = 0x78 // FMulticastInlineDelegate (Size: 0x10)
AsyncActionHandleSaveGame.Completed = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AsyncActionHandleSaveGame.SaveGameObject = 0x60 // SaveGame* (Size: 0x8)
AsyncActionLoadPrimaryAsset.Completed = 0x78 // FMulticastInlineDelegate (Size: 0x10)
AsyncActionLoadPrimaryAssetClass.Completed = 0x78 // FMulticastInlineDelegate (Size: 0x10)
AsyncActionLoadPrimaryAssetClassList.Completed = 0x78 // FMulticastInlineDelegate (Size: 0x10)
AsyncActionLoadPrimaryAssetList.Completed = 0x78 // FMulticastInlineDelegate (Size: 0x10)
AtmospherePrecomputeParameters.DensityHeight = 0x0 // float (Size: 0x4)
AtmospherePrecomputeParameters.DecayHeight = 0x4 // float (Size: 0x4)
AtmospherePrecomputeParameters.MaxScatteringOrder = 0x8 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.TransmittanceTexWidth = 0xc // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.TransmittanceTexHeight = 0x10 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.IrradianceTexWidth = 0x14 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.IrradianceTexHeight = 0x18 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.InscatterAltitudeSampleNum = 0x1c // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.InscatterMuNum = 0x20 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.InscatterMuSNum = 0x24 // int32_t (Size: 0x4)
AtmospherePrecomputeParameters.InscatterNuNum = 0x28 // int32_t (Size: 0x4)
AtmosphericFog.AtmosphericFogComponent = 0x310 // AtmosphericFogComponent* (Size: 0x8)
AtmosphericFogComponent.SunMultiplier = 0x238 // float (Size: 0x4)
AtmosphericFogComponent.FogMultiplier = 0x23c // float (Size: 0x4)
AtmosphericFogComponent.DensityMultiplier = 0x240 // float (Size: 0x4)
AtmosphericFogComponent.DensityOffset = 0x244 // float (Size: 0x4)
AtmosphericFogComponent.DistanceScale = 0x248 // float (Size: 0x4)
AtmosphericFogComponent.AltitudeScale = 0x24c // float (Size: 0x4)
AtmosphericFogComponent.DistanceOffset = 0x250 // float (Size: 0x4)
AtmosphericFogComponent.GroundOffset = 0x254 // float (Size: 0x4)
AtmosphericFogComponent.StartDistance = 0x258 // float (Size: 0x4)
AtmosphericFogComponent.SunDiscScale = 0x25c // float (Size: 0x4)
AtmosphericFogComponent.DefaultBrightness = 0x260 // float (Size: 0x4)
AtmosphericFogComponent.DefaultLightColor = 0x264 // FColor (Size: 0x4)
AtmosphericFogComponent.bDisableSunDisk = 0x268 // uint8_t (Size: 0x1)
AtmosphericFogComponent.bAtmosphereAffectsSunIlluminance = 0x268 // uint8_t (Size: 0x1)
AtmosphericFogComponent.bDisableGroundScattering = 0x268 // uint8_t (Size: 0x1)
AtmosphericFogComponent.PrecomputeParams = 0x26c // FAtmospherePrecomputeParameters (Size: 0x2c)
AtmosphericFogComponent.TransmittanceTexture = 0x298 // Texture2D* (Size: 0x8)
AtmosphericFogComponent.IrradianceTexture = 0x2a0 // Texture2D* (Size: 0x8)
AttenuationSubmixSendSettings.Submix = 0x0 // SoundSubmixBase* (Size: 0x8)
AttenuationSubmixSendSettings.SubmixSendMethod = 0x8 // EESubmixSendMethod (Size: 0x1)
AttenuationSubmixSendSettings.SubmixSendLevelMin = 0xc // float (Size: 0x4)
AttenuationSubmixSendSettings.SubmixSendLevelMax = 0x10 // float (Size: 0x4)
AttenuationSubmixSendSettings.SubmixSendDistanceMin = 0x14 // float (Size: 0x4)
AttenuationSubmixSendSettings.SubmixSendDistanceMax = 0x18 // float (Size: 0x4)
AttenuationSubmixSendSettings.ManualSubmixSendLevel = 0x1c // float (Size: 0x4)
AttenuationSubmixSendSettings.CustomSubmixSendCurve = 0x20 // FRuntimeFloatCurve (Size: 0x88)
AudioBus.AudioBusChannels = 0x28 // EEAudioBusChannels (Size: 0x1)
AudioBus.bIsAutomatic = 0x29 // bool (Size: 0x1)
AudioComponent.Sound = 0x238 // SoundBase* (Size: 0x8)
AudioComponent.InstanceParameters = 0x240 // TArray<FAudioComponentParam> (Size: 0x10)
AudioComponent.SoundClassOverride = 0x250 // SoundClass* (Size: 0x8)
AudioComponent.bAutoDestroy = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bStopWhenOwnerDestroyed = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bShouldRemainActiveIfDropped = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bAllowSpatialization = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bOverrideAttenuation = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bOverrideSubtitlePriority = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bIsUISound = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bEnableLowPassFilter = 0x258 // uint8_t (Size: 0x1)
AudioComponent.bOverridePriority = 0x259 // uint8_t (Size: 0x1)
AudioComponent.bSuppressSubtitles = 0x259 // uint8_t (Size: 0x1)
AudioComponent.bAutoManageAttachment = 0x25a // uint8_t (Size: 0x1)
AudioComponent.AudioComponentUserID = 0x260 // FName (Size: 0x8)
AudioComponent.PitchModulationMin = 0x268 // float (Size: 0x4)
AudioComponent.PitchModulationMax = 0x26c // float (Size: 0x4)
AudioComponent.VolumeModulationMin = 0x270 // float (Size: 0x4)
AudioComponent.VolumeModulationMax = 0x274 // float (Size: 0x4)
AudioComponent.VolumeMultiplier = 0x278 // float (Size: 0x4)
AudioComponent.EnvelopeFollowerAttackTime = 0x27c // int32_t (Size: 0x4)
AudioComponent.EnvelopeFollowerReleaseTime = 0x280 // int32_t (Size: 0x4)
AudioComponent.Priority = 0x284 // float (Size: 0x4)
AudioComponent.SubtitlePriority = 0x288 // float (Size: 0x4)
AudioComponent.SourceEffectChain = 0x290 // SoundEffectSourcePresetChain* (Size: 0x8)
AudioComponent.PitchMultiplier = 0x298 // float (Size: 0x4)
AudioComponent.LowPassFilterFrequency = 0x29c // float (Size: 0x4)
AudioComponent.AttenuationSettings = 0x2a8 // SoundAttenuation* (Size: 0x8)
AudioComponent.AttenuationOverrides = 0x2b0 // FSoundAttenuationSettings (Size: 0x3a0)
AudioComponent.ConcurrencySettings = 0x650 // SoundConcurrency* (Size: 0x8)
AudioComponent.ConcurrencySet = 0x658 // TSet<...> (Size: 0x50)
AudioComponent.AutoAttachLocationRule = 0x6b4 // EEAttachmentRule (Size: 0x1)
AudioComponent.AutoAttachRotationRule = 0x6b5 // EEAttachmentRule (Size: 0x1)
AudioComponent.AutoAttachScaleRule = 0x6b6 // EEAttachmentRule (Size: 0x1)
AudioComponent.ModulationRouting = 0x6b8 // FSoundModulationDefaultRoutingSettings (Size: 0x48)
AudioComponent.OnAudioPlayStateChanged = 0x700 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnAudioVirtualizationChanged = 0x728 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnAudioFinished = 0x750 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnAudioPlaybackPercent = 0x778 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnAudioSingleEnvelopeValue = 0x7a0 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnAudioMultiEnvelopeValue = 0x7c8 // FMulticastInlineDelegate (Size: 0x10)
AudioComponent.OnQueueSubtitles = 0x7f0 // FDelegate (Size: 0x10)
AudioComponent.AutoAttachParent = 0x800 // TWeakObjectPtr<UObject> (Size: 0x8)
AudioComponent.AutoAttachSocketName = 0x808 // FName (Size: 0x8)
AudioComponentParam.ParamName = 0x0 // FName (Size: 0x8)
AudioComponentParam.FloatParam = 0x8 // float (Size: 0x4)
AudioComponentParam.BoolParam = 0xc // bool (Size: 0x1)
AudioComponentParam.IntParam = 0x10 // int32_t (Size: 0x4)
AudioComponentParam.SoundWaveParam = 0x18 // SoundWave* (Size: 0x8)
AudioEQEffect.FrequencyCenter0 = 0x10 // float (Size: 0x4)
AudioEQEffect.Gain0 = 0x14 // float (Size: 0x4)
AudioEQEffect.Bandwidth0 = 0x18 // float (Size: 0x4)
AudioEQEffect.FrequencyCenter1 = 0x1c // float (Size: 0x4)
AudioEQEffect.Gain1 = 0x20 // float (Size: 0x4)
AudioEQEffect.Bandwidth1 = 0x24 // float (Size: 0x4)
AudioEQEffect.FrequencyCenter2 = 0x28 // float (Size: 0x4)
AudioEQEffect.Gain2 = 0x2c // float (Size: 0x4)
AudioEQEffect.Bandwidth2 = 0x30 // float (Size: 0x4)
AudioEQEffect.FrequencyCenter3 = 0x34 // float (Size: 0x4)
AudioEQEffect.Gain3 = 0x38 // float (Size: 0x4)
AudioEQEffect.Bandwidth3 = 0x3c // float (Size: 0x4)
AudioQualitySettings.DisplayName = 0x0 // FText (Size: 0x18)
AudioQualitySettings.MaxChannels = 0x18 // int32_t (Size: 0x4)
AudioSettings.DefaultSoundClassName = 0x38 // FSoftObjectPath (Size: 0x18)
AudioSettings.DefaultMediaSoundClassName = 0x50 // FSoftObjectPath (Size: 0x18)
AudioSettings.DefaultSoundConcurrencyName = 0x68 // FSoftObjectPath (Size: 0x18)
AudioSettings.DefaultBaseSoundMix = 0x80 // FSoftObjectPath (Size: 0x18)
AudioSettings.VoiPSoundClass = 0x98 // FSoftObjectPath (Size: 0x18)
AudioSettings.MasterSubmix = 0xb0 // FSoftObjectPath (Size: 0x18)
AudioSettings.ReverbSubmix = 0xc8 // FSoftObjectPath (Size: 0x18)
AudioSettings.EQSubmix = 0xe0 // FSoftObjectPath (Size: 0x18)
AudioSettings.VoiPSampleRate = 0xf8 // EEVoiceSampleRate (Size: 0x4)
AudioSettings.DefaultReverbSendLevel = 0xfc // float (Size: 0x4)
AudioSettings.MaximumConcurrentStreams = 0x100 // int32_t (Size: 0x4)
AudioSettings.GlobalMinPitchScale = 0x104 // float (Size: 0x4)
AudioSettings.GlobalMaxPitchScale = 0x108 // float (Size: 0x4)
AudioSettings.QualityLevels = 0x110 // TArray<FAudioQualitySettings> (Size: 0x10)
AudioSettings.bAllowPlayWhenSilent = 0x120 // uint8_t (Size: 0x1)
AudioSettings.bDisableMasterEQ = 0x120 // uint8_t (Size: 0x1)
AudioSettings.bAllowCenterChannel3DPanning = 0x120 // uint8_t (Size: 0x1)
AudioSettings.NumStoppingSources = 0x124 // uint32_t (Size: 0x4)
AudioSettings.PanningMethod = 0x128 // EEPanningMethod (Size: 0x1)
AudioSettings.MonoChannelUpmixMethod = 0x129 // EEMonoChannelUpmixMethod (Size: 0x1)
AudioSettings.DialogueFilenameFormat = 0x130 // FString (Size: 0x10)
AudioVolume.Priority = 0x348 // float (Size: 0x4)
AudioVolume.bEnabled = 0x34c // uint8_t (Size: 0x1)
AudioVolume.Settings = 0x350 // FReverbSettings (Size: 0x20)
AudioVolume.AmbientZoneSettings = 0x370 // FInteriorSettings (Size: 0x24)
AudioVolume.SubmixSendSettings = 0x398 // TArray<FAudioVolumeSubmixSendSettings> (Size: 0x10)
AudioVolume.SubmixOverrideSettings = 0x3a8 // TArray<FAudioVolumeSubmixOverrideSettings> (Size: 0x10)
AudioVolumeSubmixOverrideSettings.Submix = 0x0 // SoundSubmix* (Size: 0x8)
AudioVolumeSubmixOverrideSettings.SubmixEffectChain = 0x8 // TArray<SoundEffectSubmixPreset*> (Size: 0x10)
AudioVolumeSubmixOverrideSettings.CrossfadeTime = 0x18 // float (Size: 0x4)
AudioVolumeSubmixSendSettings.ListenerLocationState = 0x0 // EEAudioVolumeLocationState (Size: 0x1)
AudioVolumeSubmixSendSettings.SourceLocationState = 0x1 // EEAudioVolumeLocationState (Size: 0x1)
AudioVolumeSubmixSendSettings.SubmixSends = 0x8 // TArray<FSoundSubmixSendInfo> (Size: 0x10)
AutoColorGrading.bEnabled = 0x310 // bool (Size: 0x1)
AutoColorGrading.UseStyle = 0x314 // float (Size: 0x4)
AutoColorGrading.SmoothRatio = 0x318 // float (Size: 0x4)
AutoColorGrading.WholeBlendRatio = 0x31c // float (Size: 0x4)
AutoColorGrading.AllLayers = 0x320 // TArray<FAutoColorGradingLayer> (Size: 0x10)
AutoColorGrading.TheDirectionalLightComponent = 0x3b0 // DirectionalLightComponent* (Size: 0x8)
AutoColorGrading.TheSkylightComponent = 0x3b8 // SkyLightComponent* (Size: 0x8)
AutoColorGrading.TheSkyAtomosphereComponent = 0x3c0 // SkyAtmosphereComponent* (Size: 0x8)
AutoColorGradingData.Parameter = 0x0 // FVector4 (Size: 0x10)
AutoColorGradingData.ExtraData = 0x10 // FVector4 (Size: 0x10)
AutoColorGradingData.Enabled = 0x20 // bool (Size: 0x1)
AutoColorGradingIdxAndWeight.Idx = 0x0 // int32_t (Size: 0x4)
AutoColorGradingIdxAndWeight.Weight = 0x4 // float (Size: 0x4)
AutoColorGradingIdxAndWeight.Extra = 0x8 // TArray<float> (Size: 0x10)
AutoColorGradingLayer.LayerName = 0x0 // FString (Size: 0x10)
AutoColorGradingLayer.LayerSpec = 0x10 // TArray<float> (Size: 0x10)
AutoColorGradingLayer.Parameters = 0x20 // TArray<FAutoColorGradingData> (Size: 0x10)
AutoColorGradingLayer.MinHistogramIdx = 0x30 // float (Size: 0x4)
AutoColorGradingLayer.MaxHistogramIdx = 0x34 // float (Size: 0x4)
AutoColorGradingLayer.MinHistogramDiff = 0x38 // float (Size: 0x4)
AutoColorGradingLayer.MaxHistogramDiff = 0x3c // float (Size: 0x4)
AutoCompleteNode.IndexChar = 0x0 // int32_t (Size: 0x4)
AutoCompleteNode.AutoCompleteListIndices = 0x8 // TArray<int32_t> (Size: 0x10)
AutoDestroySubsystem.ActorsToPoll = 0x38 // TArray<Actor*> (Size: 0x10)
AutomationTestSettings.EngineTestModules = 0x28 // TArray<FString> (Size: 0x10)
AutomationTestSettings.EditorTestModules = 0x38 // TArray<FString> (Size: 0x10)
AutomationTestSettings.AutomationTestmap = 0x48 // FSoftObjectPath (Size: 0x18)
AutomationTestSettings.EditorPerformanceTestMaps = 0x60 // TArray<FEditorMapPerformanceTestDefinition> (Size: 0x10)
AutomationTestSettings.AssetsToOpen = 0x70 // TArray<FSoftObjectPath> (Size: 0x10)
AutomationTestSettings.MapsToPIETest = 0x80 // TArray<FString> (Size: 0x10)
AutomationTestSettings.BuildPromotionTest = 0x90 // FBuildPromotionTestSettings (Size: 0x1f0)
AutomationTestSettings.MaterialEditorPromotionTest = 0x280 // FMaterialEditorPromotionSettings (Size: 0x30)
AutomationTestSettings.ParticleEditorPromotionTest = 0x2b0 // FParticleEditorPromotionSettings (Size: 0x10)
AutomationTestSettings.BlueprintEditorPromotionTest = 0x2c0 // FBlueprintEditorPromotionSettings (Size: 0x30)
AutomationTestSettings.TestLevelFolders = 0x2f0 // TArray<FString> (Size: 0x10)
AutomationTestSettings.ExternalTools = 0x300 // TArray<FExternalToolDefinition> (Size: 0x10)
AutomationTestSettings.ImportExportTestDefinitions = 0x310 // TArray<FEditorImportExportTestDefinition> (Size: 0x10)
AutomationTestSettings.LaunchOnSettings = 0x320 // TArray<FLaunchOnTestSettings> (Size: 0x10)
AutomationTestSettings.DefaultScreenshotResolution = 0x330 // FIntPoint (Size: 0x8)
AutomationTestSettings.PIETestDuration = 0x338 // float (Size: 0x4)
AvoidanceManager.DefaultTimeToLive = 0x30 // float (Size: 0x4)
AvoidanceManager.LockTimeAfterAvoid = 0x34 // float (Size: 0x4)
AvoidanceManager.LockTimeAfterClean = 0x38 // float (Size: 0x4)
AvoidanceManager.DeltaTimeToPredict = 0x3c // float (Size: 0x4)
AvoidanceManager.ArtificialRadiusExpansion = 0x40 // float (Size: 0x4)
AvoidanceManager.TestHeightDifference = 0x44 // float (Size: 0x4)
AvoidanceManager.HeightCheckMargin = 0x48 // float (Size: 0x4)
BPComponentClassOverride.ComponentName = 0x0 // FName (Size: 0x8)
BPComponentClassOverride.ComponentClass = 0x8 // ClassProperty (Size: 0x8)
BPEditorBookmarkNode.NodeGuid = 0x0 // FGuid (Size: 0x10)
BPEditorBookmarkNode.ParentGuid = 0x10 // FGuid (Size: 0x10)
BPEditorBookmarkNode.DisplayName = 0x20 // FText (Size: 0x18)
BPInterfaceDescription.Interface = 0x0 // ClassProperty (Size: 0x8)
BPInterfaceDescription.Graphs = 0x8 // TArray<EdGraph*> (Size: 0x10)
BPVariableDescription.VarName = 0x0 // FName (Size: 0x8)
BPVariableDescription.VarGuid = 0x8 // FGuid (Size: 0x10)
BPVariableDescription.VarType = 0x18 // FEdGraphPinType (Size: 0x58)
BPVariableDescription.FriendlyName = 0x70 // FString (Size: 0x10)
BPVariableDescription.Category = 0x80 // FText (Size: 0x18)
BPVariableDescription.PropertyFlags = 0x98 // uint64_t (Size: 0x8)
BPVariableDescription.RepNotifyFunc = 0xa0 // FName (Size: 0x8)
BPVariableDescription.ReplicationCondition = 0xa8 // uint8_t (Size: 0x1)
BPVariableDescription.MetaDataArray = 0xb0 // TArray<FBPVariableMetaDataEntry> (Size: 0x10)
BPVariableDescription.DefaultValue = 0xc0 // FString (Size: 0x10)
BPVariableMetaDataEntry.DataKey = 0x0 // FName (Size: 0x8)
BPVariableMetaDataEntry.DataValue = 0x8 // FString (Size: 0x10)
BakedAnimationState.StateName = 0x0 // FName (Size: 0x8)
BakedAnimationState.Transitions = 0x8 // TArray<FBakedStateExitTransition> (Size: 0x10)
BakedAnimationState.StateRootNodeIndex = 0x18 // int32_t (Size: 0x4)
BakedAnimationState.StartNotify = 0x1c // int32_t (Size: 0x4)
BakedAnimationState.EndNotify = 0x20 // int32_t (Size: 0x4)
BakedAnimationState.FullyBlendedNotify = 0x24 // int32_t (Size: 0x4)
BakedAnimationState.bIsAConduit = 0x28 // bool (Size: 0x1)
BakedAnimationState.EntryRuleNodeIndex = 0x2c // int32_t (Size: 0x4)
BakedAnimationState.PlayerNodeIndices = 0x30 // TArray<int32_t> (Size: 0x10)
BakedAnimationState.LayerNodeIndices = 0x40 // TArray<int32_t> (Size: 0x10)
BakedAnimationState.bAlwaysResetOnEntry = 0x50 // bool (Size: 0x1)
BakedAnimationStateMachine.MachineName = 0x0 // FName (Size: 0x8)
BakedAnimationStateMachine.InitialState = 0x8 // int32_t (Size: 0x4)
BakedAnimationStateMachine.States = 0x10 // TArray<FBakedAnimationState> (Size: 0x10)
BakedAnimationStateMachine.Transitions = 0x20 // TArray<FAnimationTransitionBetweenStates> (Size: 0x10)
BakedCustomAttributePerBoneData.BoneTreeIndex = 0x0 // int32_t (Size: 0x4)
BakedCustomAttributePerBoneData.StringAttributes = 0x8 // TArray<FBakedStringCustomAttribute> (Size: 0x10)
BakedCustomAttributePerBoneData.IntAttributes = 0x18 // TArray<FBakedIntegerCustomAttribute> (Size: 0x10)
BakedCustomAttributePerBoneData.FloatAttributes = 0x28 // TArray<FBakedFloatCustomAttribute> (Size: 0x10)
BakedFloatCustomAttribute.AttributeName = 0x0 // FName (Size: 0x8)
BakedFloatCustomAttribute.FloatCurve = 0x8 // FSimpleCurve (Size: 0x88)
BakedIntegerCustomAttribute.AttributeName = 0x0 // FName (Size: 0x8)
BakedIntegerCustomAttribute.IntCurve = 0x8 // FIntegralCurve (Size: 0x80)
BakedStateExitTransition.CanTakeDelegateIndex = 0x0 // int32_t (Size: 0x4)
BakedStateExitTransition.CustomResultNodeIndex = 0x4 // int32_t (Size: 0x4)
BakedStateExitTransition.TransitionIndex = 0x8 // int32_t (Size: 0x4)
BakedStateExitTransition.bDesiredTransitionReturnValue = 0xc // bool (Size: 0x1)
BakedStateExitTransition.bAutomaticRemainingTimeRule = 0xd // bool (Size: 0x1)
BakedStateExitTransition.PoseEvaluatorLinks = 0x10 // TArray<int32_t> (Size: 0x10)
BakedStringCustomAttribute.AttributeName = 0x0 // FName (Size: 0x8)
BakedStringCustomAttribute.StringCurve = 0x8 // FStringCurve (Size: 0x88)
BandwidthTestActor.BandwidthGenerator = 0x310 // FBandwidthTestGenerator (Size: 0x20)
BandwidthTestGenerator.ReplicatedBuffers = 0x0 // TArray<FBandwidthTestItem> (Size: 0x10)
BandwidthTestItem.Kilobyte = 0x0 // TArray<uint8_t> (Size: 0x10)
BaseAttenuationSettings.DistanceAlgorithm = 0x8 // EEAttenuationDistanceModel (Size: 0x1)
BaseAttenuationSettings.AttenuationShape = 0x9 // uint8_t (Size: 0x1)
BaseAttenuationSettings.dBAttenuationAtMax = 0xc // float (Size: 0x4)
BaseAttenuationSettings.FalloffMode = 0x10 // EENaturalSoundFalloffMode (Size: 0x1)
BaseAttenuationSettings.AttenuationShapeExtents = 0x14 // FVector (Size: 0xc)
BaseAttenuationSettings.ConeOffset = 0x20 // float (Size: 0x4)
BaseAttenuationSettings.FalloffDistance = 0x24 // float (Size: 0x4)
BaseAttenuationSettings.CustomAttenuationCurve = 0x28 // FRuntimeFloatCurve (Size: 0x88)
BasedMovementInfo.MovementBase = 0x0 // PrimitiveComponent* (Size: 0x8)
BasedMovementInfo.BoneName = 0x8 // FName (Size: 0x8)
BasedMovementInfo.Location = 0x10 // FVector_NetQuantize100 (Size: 0xc)
BasedMovementInfo.Rotation = 0x1c // FRotator (Size: 0xc)
BasedMovementInfo.bServerHasBaseComponent = 0x28 // bool (Size: 0x1)
BasedMovementInfo.bRelativeRotation = 0x29 // bool (Size: 0x1)
BasedMovementInfo.bServerHasVelocity = 0x2a // bool (Size: 0x1)
BasedMovementInfo.PhysMaterial = 0x30 // PhysicalMaterial* (Size: 0x8)
BasedPosition.Base = 0x0 // Actor* (Size: 0x8)
BasedPosition.position = 0x8 // FVector (Size: 0xc)
BasedPosition.CachedBaseLocation = 0x14 // FVector (Size: 0xc)
BasedPosition.CachedBaseRotation = 0x20 // FRotator (Size: 0xc)
BasedPosition.CachedTransPosition = 0x2c // FVector (Size: 0xc)
BatchedLine.Start = 0x0 // FVector (Size: 0xc)
BatchedLine.End = 0xc // FVector (Size: 0xc)
BatchedLine.Color = 0x18 // FLinearColor (Size: 0x10)
BatchedLine.Thickness = 0x28 // float (Size: 0x4)
BatchedLine.RemainingLifeTime = 0x2c // float (Size: 0x4)
BatchedLine.DepthPriority = 0x30 // uint8_t (Size: 0x1)
BatchedPoint.position = 0x0 // FVector (Size: 0xc)
BatchedPoint.Color = 0xc // FLinearColor (Size: 0x10)
BatchedPoint.PointSize = 0x1c // float (Size: 0x4)
BatchedPoint.RemainingLifeTime = 0x20 // float (Size: 0x4)
BatchedPoint.DepthPriority = 0x24 // uint8_t (Size: 0x1)
BeamModifierOptions.bModify = 0x0 // uint8_t (Size: 0x1)
BeamModifierOptions.bScale = 0x0 // uint8_t (Size: 0x1)
BeamModifierOptions.bLock = 0x0 // uint8_t (Size: 0x1)
BeamTargetData.TargetName = 0x0 // FName (Size: 0x8)
BeamTargetData.TargetPercentage = 0x8 // float (Size: 0x4)
BillboardComponent.Sprite = 0x5c8 // Texture2D* (Size: 0x8)
BillboardComponent.bIsScreenSizeScaled = 0x5d0 // uint8_t (Size: 0x1)
BillboardComponent.ScreenSize = 0x5d4 // float (Size: 0x4)
BillboardComponent.U = 0x5d8 // float (Size: 0x4)
BillboardComponent.UL = 0x5dc // float (Size: 0x4)
BillboardComponent.V = 0x5e0 // float (Size: 0x4)
BillboardComponent.VL = 0x5e4 // float (Size: 0x4)
BlendParameter.DisplayName = 0x0 // FString (Size: 0x10)
BlendParameter.Min = 0x10 // float (Size: 0x4)
BlendParameter.Max = 0x14 // float (Size: 0x4)
BlendParameter.GridNum = 0x18 // int32_t (Size: 0x4)
BlendProfile.OwningSkeleton = 0x30 // Skeleton* (Size: 0x8)
BlendProfile.ProfileEntries = 0x38 // TArray<FBlendProfileBoneEntry> (Size: 0x10)
BlendProfileBoneEntry.BoneReference = 0x0 // FBoneReference (Size: 0x10)
BlendProfileBoneEntry.BlendScale = 0x10 // float (Size: 0x4)
BlendSample.Animation = 0x0 // AnimSequence* (Size: 0x8)
BlendSample.SampleValue = 0x8 // FVector (Size: 0xc)
BlendSample.RateScale = 0x14 // float (Size: 0x4)
BlendSampleData.SampleDataIndex = 0x0 // int32_t (Size: 0x4)
BlendSampleData.Animation = 0x8 // AnimSequence* (Size: 0x8)
BlendSampleData.TotalWeight = 0x10 // float (Size: 0x4)
BlendSampleData.Time = 0x14 // float (Size: 0x4)
BlendSampleData.PreviousTime = 0x18 // float (Size: 0x4)
BlendSampleData.SamplePlayRate = 0x1c // float (Size: 0x4)
BlendSpace.AxisToScaleAnimation = 0x168 // uint8_t (Size: 0x1)
BlendSpace1D.bScaleAnimation = 0x168 // bool (Size: 0x1)
BlendSpaceBase.bRotationBlendInMeshSpace = 0x88 // bool (Size: 0x1)
BlendSpaceBase.AnimLength = 0x8c // float (Size: 0x4)
BlendSpaceBase.InterpolationParam = 0x90 // FInterpolationParameter (Size: 0x8)
BlendSpaceBase.bUseOverrideInterpolationParam = 0xa8 // bool (Size: 0x1)
BlendSpaceBase.bActualUseOverrideInterpolationParam = 0xa9 // bool (Size: 0x1)
BlendSpaceBase.OverrideInterpolationParam = 0xac // FInterpolationParameter (Size: 0x8)
BlendSpaceBase.TargetWeightInterpolationSpeedPerSec = 0xc4 // float (Size: 0x4)
BlendSpaceBase.NotifyTriggerMode = 0xc8 // uint8_t (Size: 0x1)
BlendSpaceBase.PerBoneBlend = 0xd0 // TArray<FPerBoneInterpolation> (Size: 0x10)
BlendSpaceBase.SampleIndexWithMarkers = 0xe0 // int32_t (Size: 0x4)
BlendSpaceBase.SampleData = 0xe8 // TArray<FBlendSample> (Size: 0x10)
BlendSpaceBase.GridSamples = 0xf8 // TArray<FEditorElement> (Size: 0x10)
BlendSpaceBase.BlendParameters = 0x108 // FBlendParameter (Size: 0x20)
Blueprint.ParentClass = 0x50 // ClassProperty (Size: 0x8)
Blueprint.BlueprintType = 0x58 // uint8_t (Size: 0x1)
Blueprint.bRecompileOnLoad = 0x59 // uint8_t (Size: 0x1)
Blueprint.bHasBeenRegenerated = 0x59 // uint8_t (Size: 0x1)
Blueprint.bIsRegeneratingOnLoad = 0x59 // uint8_t (Size: 0x1)
Blueprint.BlueprintSystemVersion = 0x5c // int32_t (Size: 0x4)
Blueprint.SimpleConstructionScript = 0x60 // SimpleConstructionScript* (Size: 0x8)
Blueprint.ComponentTemplates = 0x68 // TArray<ActorComponent*> (Size: 0x10)
Blueprint.Timelines = 0x78 // TArray<TimelineTemplate*> (Size: 0x10)
Blueprint.ComponentClassOverrides = 0x88 // TArray<FBPComponentClassOverride> (Size: 0x10)
Blueprint.InheritableComponentHandler = 0x98 // InheritableComponentHandler* (Size: 0x8)
BlueprintComponentChangedPropertyInfo.PropertyName = 0x0 // FName (Size: 0x8)
BlueprintComponentChangedPropertyInfo.ArrayIndex = 0x8 // int32_t (Size: 0x4)
BlueprintComponentChangedPropertyInfo.PropertyScope = 0x10 // Struct* (Size: 0x8)
BlueprintComponentDelegateBinding.ComponentPropertyName = 0x0 // FName (Size: 0x8)
BlueprintComponentDelegateBinding.DelegatePropertyName = 0x8 // FName (Size: 0x8)
BlueprintComponentDelegateBinding.FunctionNameToBind = 0x10 // FName (Size: 0x8)
BlueprintCookedComponentInstancingData.ChangedPropertyList = 0x0 // TArray<FBlueprintComponentChangedPropertyInfo> (Size: 0x10)
BlueprintCookedComponentInstancingData.bHasValidCookedData = 0x21 // bool (Size: 0x1)
BlueprintCore.SkeletonGeneratedClass = 0x28 // ClassProperty (Size: 0x8)
BlueprintCore.GeneratedClass = 0x30 // ClassProperty (Size: 0x8)
BlueprintCore.bLegacyNeedToPurgeSkelRefs = 0x38 // bool (Size: 0x1)
BlueprintCore.BlueprintGuid = 0x3c // FGuid (Size: 0x10)
BlueprintEditorPromotionSettings.FirstMeshPath = 0x0 // FFilePath (Size: 0x10)
BlueprintEditorPromotionSettings.SecondMeshPath = 0x10 // FFilePath (Size: 0x10)
BlueprintEditorPromotionSettings.DefaultParticleAsset = 0x20 // FFilePath (Size: 0x10)
BlueprintGeneratedClass.NumReplicatedProperties = 0x230 // int32_t (Size: 0x4)
BlueprintGeneratedClass.bHasNativizedParent = 0x234 // uint8_t (Size: 0x1)
BlueprintGeneratedClass.bHasCookedComponentInstancingData = 0x234 // uint8_t (Size: 0x1)
BlueprintGeneratedClass.DynamicBindingObjects = 0x238 // TArray<DynamicBlueprintBinding*> (Size: 0x10)
BlueprintGeneratedClass.ComponentTemplates = 0x248 // TArray<ActorComponent*> (Size: 0x10)
BlueprintGeneratedClass.Timelines = 0x258 // TArray<TimelineTemplate*> (Size: 0x10)
BlueprintGeneratedClass.ComponentClassOverrides = 0x268 // TArray<FBPComponentClassOverride> (Size: 0x10)
BlueprintGeneratedClass.SimpleConstructionScript = 0x278 // SimpleConstructionScript* (Size: 0x8)
BlueprintGeneratedClass.InheritableComponentHandler = 0x280 // InheritableComponentHandler* (Size: 0x8)
BlueprintGeneratedClass.UberGraphFramePointerProperty = 0x288 // StructProperty* (Size: 0x8)
BlueprintGeneratedClass.UberGraphFunction = 0x298 // Function* (Size: 0x8)
BlueprintGeneratedClass.CookedComponentInstancingData = 0x2a0 // TMap<...> (Size: 0x50)
BlueprintInputActionDelegateBinding.InputActionName = 0x4 // FName (Size: 0x8)
BlueprintInputActionDelegateBinding.InputKeyEvent = 0xc // uint8_t (Size: 0x1)
BlueprintInputActionDelegateBinding.FunctionNameToBind = 0x10 // FName (Size: 0x8)
BlueprintInputAxisDelegateBinding.InputAxisName = 0x4 // FName (Size: 0x8)
BlueprintInputAxisDelegateBinding.FunctionNameToBind = 0xc // FName (Size: 0x8)
BlueprintInputAxisKeyDelegateBinding.AxisKey = 0x8 // FKey (Size: 0x18)
BlueprintInputAxisKeyDelegateBinding.FunctionNameToBind = 0x20 // FName (Size: 0x8)
BlueprintInputDelegateBinding.bConsumeInput = 0x0 // uint8_t (Size: 0x1)
BlueprintInputDelegateBinding.bExecuteWhenPaused = 0x0 // uint8_t (Size: 0x1)
BlueprintInputDelegateBinding.bOverrideParentBinding = 0x0 // uint8_t (Size: 0x1)
BlueprintInputKeyDelegateBinding.InputChord = 0x8 // FInputChord (Size: 0x20)
BlueprintInputKeyDelegateBinding.InputKeyEvent = 0x28 // uint8_t (Size: 0x1)
BlueprintInputKeyDelegateBinding.FunctionNameToBind = 0x2c // FName (Size: 0x8)
BlueprintInputTouchDelegateBinding.InputKeyEvent = 0x4 // uint8_t (Size: 0x1)
BlueprintInputTouchDelegateBinding.FunctionNameToBind = 0x8 // FName (Size: 0x8)
BodyInstance.ObjectType = 0x1e // uint8_t (Size: 0x1)
BodyInstance.CollisionEnabled = 0x20 // uint8_t (Size: 0x1)
BodyInstance.SleepFamily = 0x59 // EESleepFamily (Size: 0x1)
BodyInstance.DOFMode = 0x5a // uint8_t (Size: 0x1)
BodyInstance.bUseCCD = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bIgnoreAnalyticCollisions = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bNotifyRigidBodyCollision = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bLockTranslation = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bLockRotation = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bLockXTranslation = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bLockYTranslation = 0x5b // uint8_t (Size: 0x1)
BodyInstance.bLockZTranslation = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bLockXRotation = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bLockYRotation = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bLockZRotation = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bOverrideMaxAngularVelocity = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bOverrideMaxDepenetrationVelocity = 0x5c // uint8_t (Size: 0x1)
BodyInstance.bOverrideWalkableSlopeOnInstance = 0x5d // uint8_t (Size: 0x1)
BodyInstance.bInterpolateWhenSubStepping = 0x5d // uint8_t (Size: 0x1)
BodyInstance.CollisionProfileName = 0x6c // FName (Size: 0x8)
BodyInstance.PositionSolverIterationCount = 0x74 // uint8_t (Size: 0x1)
BodyInstance.VelocitySolverIterationCount = 0x75 // uint8_t (Size: 0x1)
BodyInstance.CollisionResponses = 0x78 // FCollisionResponse (Size: 0x30)
BodyInstance.MaxDepenetrationVelocity = 0xa8 // float (Size: 0x4)
BodyInstance.MassInKgOverride = 0xac // float (Size: 0x4)
BodyInstance.LinearDamping = 0xb8 // float (Size: 0x4)
BodyInstance.AngularDamping = 0xbc // float (Size: 0x4)
BodyInstance.CustomDOFPlaneNormal = 0xc0 // FVector (Size: 0xc)
BodyInstance.COMNudge = 0xcc // FVector (Size: 0xc)
BodyInstance.MassScale = 0xd8 // float (Size: 0x4)
BodyInstance.InertiaTensorScale = 0xdc // FVector (Size: 0xc)
BodyInstance.WalkableSlopeOverride = 0xf8 // FWalkableSlopeOverride (Size: 0x10)
BodyInstance.PhysMaterialOverride = 0x108 // PhysicalMaterial* (Size: 0x8)
BodyInstance.MaxAngularVelocity = 0x110 // float (Size: 0x4)
BodyInstance.CustomSleepThresholdMultiplier = 0x114 // float (Size: 0x4)
BodyInstance.StabilizationThresholdMultiplier = 0x118 // float (Size: 0x4)
BodyInstance.PhysicsBlendWeight = 0x11c // float (Size: 0x4)
BodySetup.AggGeom = 0x48 // FKAggregateGeom (Size: 0x58)
BodySetup.bAlwaysFullAnimWeight = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bConsiderForBounds = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bMeshCollideAll = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bDoubleSidedGeometry = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bGenerateNonMirroredCollision = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bSharedCookedData = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bGenerateMirroredCollision = 0xa0 // uint8_t (Size: 0x1)
BodySetup.bSupportUVsAndFaceRemap = 0xa0 // uint8_t (Size: 0x1)
BodySetup.PhysMaterial = 0xa8 // PhysicalMaterial* (Size: 0x8)
BodySetup.WalkableSlopeOverride = 0xb0 // FWalkableSlopeOverride (Size: 0x10)
BodySetup.DefaultInstance = 0x128 // FBodyInstance (Size: 0x158)
BodySetup.BuildScale3D = 0x288 // FVector (Size: 0xc)
BodySetup.AggGeomBound = 0x294 // FBox (Size: 0x1c)
BoneFilter.bExcludeSelf = 0x0 // bool (Size: 0x1)
BoneFilter.BoneName = 0x4 // FName (Size: 0x8)
BoneMaskFilter.BlendPoses = 0x28 // TArray<FInputBlendPose> (Size: 0x10)
BoneMirrorExport.BoneName = 0x0 // FName (Size: 0x8)
BoneMirrorExport.SourceBoneName = 0x8 // FName (Size: 0x8)
BoneMirrorExport.BoneFlipAxis = 0x10 // uint8_t (Size: 0x1)
BoneMirrorInfo.SourceIndex = 0x0 // int32_t (Size: 0x4)
BoneMirrorInfo.BoneFlipAxis = 0x4 // uint8_t (Size: 0x1)
BoneNode.Name = 0x0 // FName (Size: 0x8)
BoneNode.ParentIndex = 0x8 // int32_t (Size: 0x4)
BoneNode.TranslationRetargetingMode = 0xc // uint8_t (Size: 0x1)
BoneReductionSetting.BonesToRemove = 0x0 // TArray<FName> (Size: 0x10)
BoneReference.BoneName = 0x0 // FName (Size: 0x8)
BookMark.Location = 0x28 // FVector (Size: 0xc)
BookMark.Rotation = 0x34 // FRotator (Size: 0xc)
BookMark.HiddenLevels = 0x40 // TArray<FString> (Size: 0x10)
BookMark2D.Zoom2D = 0x28 // float (Size: 0x4)
BookMark2D.Location = 0x2c // FIntPoint (Size: 0x8)
BoolTrackKey.Time = 0x0 // float (Size: 0x4)
BoolTrackKey.Value = 0x4 // uint8_t (Size: 0x1)
BoundsCopyComponent.BoundsSourceActor = 0xf8 // TSoftObjectPtr<UObject> (Size: 0x28)
BoundsCopyComponent.bUseCollidingComponentsForSourceBounds = 0x120 // bool (Size: 0x1)
BoundsCopyComponent.bKeepOwnBoundsScale = 0x121 // bool (Size: 0x1)
BoundsCopyComponent.bUseCollidingComponentsForOwnBounds = 0x122 // bool (Size: 0x1)
BoundsCopyComponent.PostTransform = 0x130 // FTransform (Size: 0x30)
BoundsCopyComponent.bCopyXBounds = 0x160 // bool (Size: 0x1)
BoundsCopyComponent.bCopyYBounds = 0x161 // bool (Size: 0x1)
BoundsCopyComponent.bCopyZBounds = 0x162 // bool (Size: 0x1)
BoxComponent.BoxExtent = 0x5e0 // FVector (Size: 0xc)
BoxComponent.LineThickness = 0x5ec // float (Size: 0x4)
BoxReflectionCaptureComponent.BoxTransitionDistance = 0x2e8 // float (Size: 0x4)
BoxReflectionCaptureComponent.PreviewInfluenceBox = 0x2f0 // BoxComponent* (Size: 0x8)
BoxReflectionCaptureComponent.PreviewCaptureBox = 0x2f8 // BoxComponent* (Size: 0x8)
BranchFilter.BoneName = 0x0 // FName (Size: 0x8)
BranchFilter.BlendDepth = 0x8 // int32_t (Size: 0x4)
BranchingPoint.EventName = 0x30 // FName (Size: 0x8)
BranchingPoint.DisplayTime = 0x38 // float (Size: 0x4)
BranchingPoint.TriggerTimeOffset = 0x3c // float (Size: 0x4)
BranchingPointMarker.NotifyIndex = 0x0 // int32_t (Size: 0x4)
BranchingPointMarker.TriggerTime = 0x4 // float (Size: 0x4)
BranchingPointMarker.NotifyEventType = 0x8 // uint8_t (Size: 0x1)
Breakpoint.bEnabled = 0x28 // uint8_t (Size: 0x1)
Breakpoint.Node = 0x30 // EdGraphNode* (Size: 0x8)
Breakpoint.bStepOnce = 0x38 // uint8_t (Size: 0x1)
Breakpoint.bStepOnce_WasPreviouslyDisabled = 0x38 // uint8_t (Size: 0x1)
Breakpoint.bStepOnce_RemoveAfterHit = 0x38 // uint8_t (Size: 0x1)
BroadphaseSettings.bUseMBPOnClient = 0x0 // bool (Size: 0x1)
BroadphaseSettings.bUseMBPOnServer = 0x1 // bool (Size: 0x1)
BroadphaseSettings.bUseMBPOuterBounds = 0x2 // bool (Size: 0x1)
BroadphaseSettings.MBPBounds = 0x4 // FBox (Size: 0x1c)
BroadphaseSettings.MBPOuterBounds = 0x20 // FBox (Size: 0x1c)
BroadphaseSettings.MBPNumSubdivs = 0x3c // uint32_t (Size: 0x4)
Brush.BrushType = 0x310 // uint8_t (Size: 0x1)
Brush.BrushColor = 0x314 // FColor (Size: 0x4)
Brush.PolyFlags = 0x318 // int32_t (Size: 0x4)
Brush.bColored = 0x31c // uint8_t (Size: 0x1)
Brush.bSolidWhenSelected = 0x31c // uint8_t (Size: 0x1)
Brush.bPlaceableFromClassBrowser = 0x31c // uint8_t (Size: 0x1)
Brush.bNotForClientOrServer = 0x31c // uint8_t (Size: 0x1)
Brush.Brush = 0x320 // Model* (Size: 0x8)
Brush.BrushComponent = 0x328 // BrushComponent* (Size: 0x8)
Brush.bInManipulation = 0x330 // uint8_t (Size: 0x1)
Brush.SavedSelections = 0x338 // TArray<FGeomSelection> (Size: 0x10)
BrushBuilder.BitmapFilename = 0x28 // FString (Size: 0x10)
BrushBuilder.ToolTip = 0x38 // FString (Size: 0x10)
BrushBuilder.NotifyBadParams = 0x48 // uint8_t (Size: 0x1)
BrushBuilder.Vertices = 0x50 // TArray<FVector> (Size: 0x10)
BrushBuilder.Polys = 0x60 // TArray<FBuilderPoly> (Size: 0x10)
BrushBuilder.Layer = 0x70 // FName (Size: 0x8)
BrushBuilder.MergeCoplanars = 0x78 // uint8_t (Size: 0x1)
BrushComponent.Brush = 0x5c8 // Model* (Size: 0x8)
BrushComponent.BrushBodySetup = 0x5d0 // BodySetup* (Size: 0x8)
BuildPromotionImportWorkflowSettings.Diffuse = 0x0 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.Normal = 0x20 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.StaticMesh = 0x40 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.ReimportStaticMesh = 0x60 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.BlendShapeMesh = 0x80 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.MorphMesh = 0xa0 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.SkeletalMesh = 0xc0 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.Animation = 0xe0 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.Sound = 0x100 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.SurroundSound = 0x120 // FEditorImportWorkflowDefinition (Size: 0x20)
BuildPromotionImportWorkflowSettings.OtherAssetsToImport = 0x140 // TArray<FEditorImportWorkflowDefinition> (Size: 0x10)
BuildPromotionNewProjectSettings.NewProjectFolderOverride = 0x0 // FDirectoryPath (Size: 0x10)
BuildPromotionNewProjectSettings.NewProjectNameOverride = 0x10 // FString (Size: 0x10)
BuildPromotionOpenAssetSettings.BlueprintAsset = 0x0 // FFilePath (Size: 0x10)
BuildPromotionOpenAssetSettings.MaterialAsset = 0x10 // FFilePath (Size: 0x10)
BuildPromotionOpenAssetSettings.ParticleSystemAsset = 0x20 // FFilePath (Size: 0x10)
BuildPromotionOpenAssetSettings.SkeletalMeshAsset = 0x30 // FFilePath (Size: 0x10)
BuildPromotionOpenAssetSettings.StaticMeshAsset = 0x40 // FFilePath (Size: 0x10)
BuildPromotionOpenAssetSettings.TextureAsset = 0x50 // FFilePath (Size: 0x10)
BuildPromotionTestSettings.DefaultStaticMeshAsset = 0x0 // FFilePath (Size: 0x10)
BuildPromotionTestSettings.ImportWorkflow = 0x10 // FBuildPromotionImportWorkflowSettings (Size: 0x150)
BuildPromotionTestSettings.OpenAssets = 0x160 // FBuildPromotionOpenAssetSettings (Size: 0x60)
BuildPromotionTestSettings.NewProjectSettings = 0x1c0 // FBuildPromotionNewProjectSettings (Size: 0x20)
BuildPromotionTestSettings.SourceControlMaterial = 0x1e0 // FFilePath (Size: 0x10)
BuilderPoly.VertexIndices = 0x0 // TArray<int32_t> (Size: 0x10)
BuilderPoly.Direction = 0x10 // int32_t (Size: 0x4)
BuilderPoly.ItemName = 0x14 // FName (Size: 0x8)
BuilderPoly.PolyFlags = 0x1c // int32_t (Size: 0x4)
ButtonStyleAsset.ButtonStyle = 0x28 // FButtonStyle (Size: 0x298)
CachedAnimAssetPlayerData.StateMachineName = 0x0 // FName (Size: 0x8)
CachedAnimAssetPlayerData.StateName = 0x8 // FName (Size: 0x8)
CachedAnimRelevancyData.StateMachineName = 0x0 // FName (Size: 0x8)
CachedAnimRelevancyData.StateName = 0x8 // FName (Size: 0x8)
CachedAnimStateArray.States = 0x0 // TArray<FCachedAnimStateData> (Size: 0x10)
CachedAnimStateData.StateMachineName = 0x0 // FName (Size: 0x8)
CachedAnimStateData.StateName = 0x8 // FName (Size: 0x8)
CachedAnimTransitionData.StateMachineName = 0x0 // FName (Size: 0x8)
CachedAnimTransitionData.FromStateName = 0x8 // FName (Size: 0x8)
CachedAnimTransitionData.ToStateName = 0x10 // FName (Size: 0x8)
CachedKeyToActionInfo.PlayerInput = 0x0 // PlayerInput* (Size: 0x8)
CachedPoseIndices.OrderedSavedPoseNodeIndices = 0x0 // TArray<int32_t> (Size: 0x10)
CameraActor.AutoActivateForPlayer = 0x310 // uint8_t (Size: 0x1)
CameraActor.CameraComponent = 0x318 // CameraComponent* (Size: 0x8)
CameraActor.SceneComponent = 0x320 // SceneComponent* (Size: 0x8)
CameraActor.bConstrainAspectRatio = 0x330 // uint8_t (Size: 0x1)
CameraActor.AspectRatio = 0x334 // float (Size: 0x4)
CameraActor.FOVAngle = 0x338 // float (Size: 0x4)
CameraActor.PostProcessBlendWeight = 0x33c // float (Size: 0x4)
CameraActor.PostProcessSettings = 0x340 // FPostProcessSettings (Size: 0x690)
CameraAnim.CameraInterpGroup = 0x28 // InterpGroup* (Size: 0x8)
CameraAnim.AnimLength = 0x30 // float (Size: 0x4)
CameraAnim.BoundingBox = 0x34 // FBox (Size: 0x1c)
CameraAnim.bRelativeToInitialTransform = 0x50 // uint8_t (Size: 0x1)
CameraAnim.bRelativeToInitialFOV = 0x50 // uint8_t (Size: 0x1)
CameraAnim.BaseFov = 0x54 // float (Size: 0x4)
CameraAnim.BasePostProcessSettings = 0x60 // FPostProcessSettings (Size: 0x690)
CameraAnim.BasePostProcessBlendWeight = 0x6f0 // float (Size: 0x4)
CameraAnimInst.CamAnim = 0x28 // CameraAnim* (Size: 0x8)
CameraAnimInst.InterpGroupInst = 0x30 // InterpGroupInst* (Size: 0x8)
CameraAnimInst.PlayRate = 0x50 // float (Size: 0x4)
CameraAnimInst.MoveTrack = 0x68 // InterpTrackMove* (Size: 0x8)
CameraAnimInst.MoveInst = 0x70 // InterpTrackInstMove* (Size: 0x8)
CameraAnimInst.PlaySpace = 0x78 // EECameraShakePlaySpace (Size: 0x1)
CameraCacheEntry.Timestamp = 0x0 // float (Size: 0x4)
CameraCacheEntry.POV = 0x10 // FMinimalViewInfo (Size: 0x720)
CameraComponent.FieldOfView = 0x238 // float (Size: 0x4)
CameraComponent.OrthoWidth = 0x23c // float (Size: 0x4)
CameraComponent.OrthoNearClipPlane = 0x240 // float (Size: 0x4)
CameraComponent.OrthoFarClipPlane = 0x244 // float (Size: 0x4)
CameraComponent.AspectRatio = 0x248 // float (Size: 0x4)
CameraComponent.bConstrainAspectRatio = 0x24c // uint8_t (Size: 0x1)
CameraComponent.bUseFieldOfViewForLOD = 0x24c // uint8_t (Size: 0x1)
CameraComponent.bLockToHmd = 0x24c // uint8_t (Size: 0x1)
CameraComponent.bUsePawnControlRotation = 0x24c // uint8_t (Size: 0x1)
CameraComponent.ProjectionMode = 0x24d // uint8_t (Size: 0x1)
CameraComponent.PostProcessBlendWeight = 0x280 // float (Size: 0x4)
CameraComponent.PostProcessSettings = 0x2b0 // FPostProcessSettings (Size: 0x690)
CameraCutInfo.Location = 0x0 // FVector (Size: 0xc)
CameraCutInfo.Timestamp = 0xc // float (Size: 0x4)
CameraExposureSettings.Method = 0x0 // uint8_t (Size: 0x1)
CameraExposureSettings.LowPercent = 0x4 // float (Size: 0x4)
CameraExposureSettings.HighPercent = 0x8 // float (Size: 0x4)
CameraExposureSettings.MinBrightness = 0xc // float (Size: 0x4)
CameraExposureSettings.MaxBrightness = 0x10 // float (Size: 0x4)
CameraExposureSettings.SpeedUp = 0x14 // float (Size: 0x4)
CameraExposureSettings.SpeedDown = 0x18 // float (Size: 0x4)
CameraExposureSettings.Bias = 0x1c // float (Size: 0x4)
CameraExposureSettings.BiasCurve = 0x20 // CurveFloat* (Size: 0x8)
CameraExposureSettings.MeterMask = 0x28 // Texture* (Size: 0x8)
CameraExposureSettings.HistogramLogMin = 0x30 // float (Size: 0x4)
CameraExposureSettings.HistogramLogMax = 0x34 // float (Size: 0x4)
CameraExposureSettings.CalibrationConstant = 0x38 // float (Size: 0x4)
CameraExposureSettings.ApplyPhysicalCameraExposure = 0x3c // uint8_t (Size: 0x1)
CameraModifier.bDebug = 0x28 // uint8_t (Size: 0x1)
CameraModifier.bExclusive = 0x28 // uint8_t (Size: 0x1)
CameraModifier.Priority = 0x2c // uint8_t (Size: 0x1)
CameraModifier.CameraOwner = 0x30 // PlayerCameraManager* (Size: 0x8)
CameraModifier.AlphaInTime = 0x38 // float (Size: 0x4)
CameraModifier.AlphaOutTime = 0x3c // float (Size: 0x4)
CameraModifier.Alpha = 0x40 // float (Size: 0x4)
CameraModifier_CameraShake.ActiveShakes = 0x48 // TArray<FActiveCameraShakeInfo> (Size: 0x10)
CameraModifier_CameraShake.ExpiredPooledShakesMap = 0x58 // TMap<...> (Size: 0x50)
CameraModifier_CameraShake.SplitScreenShakeScale = 0xa8 // float (Size: 0x4)
CameraPreviewInfo.PawnClass = 0x0 // ClassProperty (Size: 0x8)
CameraPreviewInfo.AnimSeq = 0x8 // AnimSequence* (Size: 0x8)
CameraPreviewInfo.Location = 0x10 // FVector (Size: 0xc)
CameraPreviewInfo.Rotation = 0x1c // FRotator (Size: 0xc)
CameraPreviewInfo.PawnInst = 0x28 // Pawn* (Size: 0x8)
CameraShakeBase.bSingleInstance = 0x28 // bool (Size: 0x1)
CameraShakeBase.ShakeScale = 0x2c // float (Size: 0x4)
CameraShakeBase.CameraManager = 0x30 // PlayerCameraManager* (Size: 0x8)
CameraShakeDuration.Duration = 0x0 // float (Size: 0x4)
CameraShakeDuration.Type = 0x4 // EECameraShakeDurationType (Size: 0x1)
CameraShakeInfo.Duration = 0x0 // FCameraShakeDuration (Size: 0x8)
CameraShakeInfo.BlendIn = 0x8 // float (Size: 0x4)
CameraShakeInfo.BlendOut = 0xc // float (Size: 0x4)
CameraShakeSourceActor.CameraShakeSourceComponent = 0x310 // CameraShakeSourceComponent* (Size: 0x8)
CameraShakeSourceComponent.Attenuation = 0x238 // EECameraShakeAttenuation (Size: 0x1)
CameraShakeSourceComponent.InnerAttenuationRadius = 0x23c // float (Size: 0x4)
CameraShakeSourceComponent.OuterAttenuationRadius = 0x240 // float (Size: 0x4)
CameraShakeSourceComponent.CameraShake = 0x248 // ClassProperty (Size: 0x8)
CameraShakeSourceComponent.bAutoStart = 0x250 // bool (Size: 0x1)
Canvas.OrgX = 0x28 // float (Size: 0x4)
Canvas.OrgY = 0x2c // float (Size: 0x4)
Canvas.ClipX = 0x30 // float (Size: 0x4)
Canvas.ClipY = 0x34 // float (Size: 0x4)
Canvas.DrawColor = 0x38 // FColor (Size: 0x4)
Canvas.bCenterX = 0x3c // uint8_t (Size: 0x1)
Canvas.bCenterY = 0x3c // uint8_t (Size: 0x1)
Canvas.bNoSmooth = 0x3c // uint8_t (Size: 0x1)
Canvas.SizeX = 0x40 // int32_t (Size: 0x4)
Canvas.SizeY = 0x44 // int32_t (Size: 0x4)
Canvas.ColorModulate = 0x50 // FPlane (Size: 0x10)
Canvas.DefaultTexture = 0x60 // Texture2D* (Size: 0x8)
Canvas.GradientTexture0 = 0x68 // Texture2D* (Size: 0x8)
Canvas.ReporterGraph = 0x70 // ReporterGraph* (Size: 0x8)
CanvasIcon.Texture = 0x0 // Texture* (Size: 0x8)
CanvasIcon.U = 0x8 // float (Size: 0x4)
CanvasIcon.V = 0xc // float (Size: 0x4)
CanvasIcon.UL = 0x10 // float (Size: 0x4)
CanvasIcon.VL = 0x14 // float (Size: 0x4)
CanvasRenderTarget2D.OnCanvasRenderTargetUpdate = 0x120 // FMulticastInlineDelegate (Size: 0x10)
CanvasRenderTarget2D.World = 0x130 // TWeakObjectPtr<UObject> (Size: 0x8)
CanvasRenderTarget2D.bShouldClearRenderTargetOnReceiveUpdate = 0x138 // bool (Size: 0x1)
CanvasUVTri.V0_Pos = 0x0 // FVector2D (Size: 0x8)
CanvasUVTri.V0_UV = 0x8 // FVector2D (Size: 0x8)
CanvasUVTri.V0_Color = 0x10 // FLinearColor (Size: 0x10)
CanvasUVTri.V1_Pos = 0x20 // FVector2D (Size: 0x8)
CanvasUVTri.V1_UV = 0x28 // FVector2D (Size: 0x8)
CanvasUVTri.V1_Color = 0x30 // FLinearColor (Size: 0x10)
CanvasUVTri.V2_Pos = 0x40 // FVector2D (Size: 0x8)
CanvasUVTri.V2_UV = 0x48 // FVector2D (Size: 0x8)
CanvasUVTri.V2_Color = 0x50 // FLinearColor (Size: 0x10)
CapsuleComponent.CapsuleHalfHeight = 0x5e0 // float (Size: 0x4)
CapsuleComponent.CapsuleRadius = 0x5e4 // float (Size: 0x4)
Channel.Connection = 0x28 // NetConnection* (Size: 0x8)
ChannelDefinition.ChannelName = 0x0 // FName (Size: 0x8)
ChannelDefinition.ClassName = 0x8 // FName (Size: 0x8)
ChannelDefinition.ChannelClass = 0x10 // ClassProperty (Size: 0x8)
ChannelDefinition.StaticChannelIndex = 0x18 // int32_t (Size: 0x4)
ChannelDefinition.bTickOnCreate = 0x1c // bool (Size: 0x1)
ChannelDefinition.bServerOpen = 0x1d // bool (Size: 0x1)
ChannelDefinition.bClientOpen = 0x1e // bool (Size: 0x1)
ChannelDefinition.bInitialServer = 0x1f // bool (Size: 0x1)
ChannelDefinition.bInitialClient = 0x20 // bool (Size: 0x1)
ChaosPhysicsSettings.DefaultThreadingModel = 0x0 // EEChaosThreadingMode (Size: 0x1)
ChaosPhysicsSettings.DedicatedThreadTickMode = 0x1 // EEChaosSolverTickMode (Size: 0x1)
ChaosPhysicsSettings.DedicatedThreadBufferMode = 0x2 // EEChaosBufferMode (Size: 0x1)
Character.Mesh = 0x380 // SkeletalMeshComponent* (Size: 0x8)
Character.CharacterMovement = 0x388 // CharacterMovementComponent* (Size: 0x8)
Character.CapsuleComponent = 0x390 // CapsuleComponent* (Size: 0x8)
Character.BasedMovement = 0x398 // FBasedMovementInfo (Size: 0x38)
Character.ReplicatedBasedMovement = 0x3d0 // FBasedMovementInfo (Size: 0x38)
Character.AnimRootMotionTranslationScale = 0x408 // float (Size: 0x4)
Character.BaseTranslationOffset = 0x40c // FVector (Size: 0xc)
Character.BaseRotationOffset = 0x420 // FQuat (Size: 0x10)
Character.ReplicatedServerLastTransformUpdateTimeStamp = 0x430 // float (Size: 0x4)
Character.ReplayLastTransformUpdateTimeStamp = 0x434 // float (Size: 0x4)
Character.ReplicatedMovementMode = 0x438 // uint8_t (Size: 0x1)
Character.bInBaseReplication = 0x439 // bool (Size: 0x1)
Character.CrouchedEyeHeight = 0x43c // float (Size: 0x4)
Character.bIsCrouched = 0x440 // uint8_t (Size: 0x1)
Character.bProxyIsJumpForceApplied = 0x440 // uint8_t (Size: 0x1)
Character.bPressedJump = 0x440 // uint8_t (Size: 0x1)
Character.bClientUpdating = 0x440 // uint8_t (Size: 0x1)
Character.bClientWasFalling = 0x440 // uint8_t (Size: 0x1)
Character.bClientResimulateRootMotion = 0x440 // uint8_t (Size: 0x1)
Character.bClientResimulateRootMotionSources = 0x440 // uint8_t (Size: 0x1)
Character.bSimGravityDisabled = 0x440 // uint8_t (Size: 0x1)
Character.bClientCheckEncroachmentOnNetUpdate = 0x441 // uint8_t (Size: 0x1)
Character.bServerMoveIgnoreRootMotion = 0x441 // uint8_t (Size: 0x1)
Character.bWasJumping = 0x441 // uint8_t (Size: 0x1)
Character.JumpKeyHoldTime = 0x444 // float (Size: 0x4)
Character.JumpForceTimeRemaining = 0x448 // float (Size: 0x4)
Character.ProxyJumpForceStartedTime = 0x44c // float (Size: 0x4)
Character.JumpMaxHoldTime = 0x450 // float (Size: 0x4)
Character.JumpMaxCount = 0x454 // int32_t (Size: 0x4)
Character.JumpCurrentCount = 0x458 // int32_t (Size: 0x4)
Character.JumpCurrentCountPreJump = 0x45c // int32_t (Size: 0x4)
Character.OnReachedJumpApex = 0x468 // FMulticastInlineDelegate (Size: 0x10)
Character.MovementModeChangedDelegate = 0x488 // FMulticastInlineDelegate (Size: 0x10)
Character.OnCharacterMovementUpdated = 0x498 // FMulticastInlineDelegate (Size: 0x10)
Character.SavedRootMotion = 0x4a8 // FRootMotionSourceGroup (Size: 0x38)
Character.ClientRootMotionParams = 0x4e0 // FRootMotionMovementParams (Size: 0x40)
Character.RootMotionRepMoves = 0x520 // TArray<FSimulatedRootMotionReplicatedMove> (Size: 0x10)
Character.RepRootMotion = 0x530 // FRepRootMotionMontage (Size: 0x98)
CharacterMovementComponent.CharacterOwner = 0x190 // Character* (Size: 0x8)
CharacterMovementComponent.GravityScale = 0x198 // float (Size: 0x4)
CharacterMovementComponent.MaxStepHeight = 0x19c // float (Size: 0x4)
CharacterMovementComponent.MaxStepHeightWithoutConsiderWalkable = 0x1a0 // float (Size: 0x4)
CharacterMovementComponent.JumpZVelocity = 0x1a4 // float (Size: 0x4)
CharacterMovementComponent.JumpOffJumpZFactor = 0x1a8 // float (Size: 0x4)
CharacterMovementComponent.WalkableFloorAngle = 0x1ac // float (Size: 0x4)
CharacterMovementComponent.WalkableFloorZ = 0x1b0 // float (Size: 0x4)
CharacterMovementComponent.MovementMode = 0x1cc // uint8_t (Size: 0x1)
CharacterMovementComponent.CustomMovementMode = 0x1cd // uint8_t (Size: 0x1)
CharacterMovementComponent.NetworkSmoothingMode = 0x1ce // EENetworkSmoothingMode (Size: 0x1)
CharacterMovementComponent.GroundFriction = 0x1d0 // float (Size: 0x4)
CharacterMovementComponent.MaxWalkSpeed = 0x1fc // float (Size: 0x4)
CharacterMovementComponent.MaxWalkSpeedCrouched = 0x200 // float (Size: 0x4)
CharacterMovementComponent.MaxSwimSpeed = 0x204 // float (Size: 0x4)
CharacterMovementComponent.MaxFlySpeed = 0x208 // float (Size: 0x4)
CharacterMovementComponent.MaxCustomMovementSpeed = 0x20c // float (Size: 0x4)
CharacterMovementComponent.MaxAcceleration = 0x210 // float (Size: 0x4)
CharacterMovementComponent.MinAnalogWalkSpeed = 0x214 // float (Size: 0x4)
CharacterMovementComponent.BrakingFrictionFactor = 0x218 // float (Size: 0x4)
CharacterMovementComponent.BrakingFriction = 0x21c // float (Size: 0x4)
CharacterMovementComponent.BrakingSubStepTime = 0x220 // float (Size: 0x4)
CharacterMovementComponent.BrakingDecelerationWalking = 0x224 // float (Size: 0x4)
CharacterMovementComponent.BrakingDecelerationFalling = 0x228 // float (Size: 0x4)
CharacterMovementComponent.BrakingDecelerationSwimming = 0x22c // float (Size: 0x4)
CharacterMovementComponent.BrakingDecelerationFlying = 0x230 // float (Size: 0x4)
CharacterMovementComponent.AirControl = 0x234 // float (Size: 0x4)
CharacterMovementComponent.AirControlBoostMultiplier = 0x238 // float (Size: 0x4)
CharacterMovementComponent.AirControlBoostVelocityThreshold = 0x23c // float (Size: 0x4)
CharacterMovementComponent.FallingLateralFriction = 0x240 // float (Size: 0x4)
CharacterMovementComponent.CrouchedHalfHeight = 0x244 // float (Size: 0x4)
CharacterMovementComponent.Buoyancy = 0x248 // float (Size: 0x4)
CharacterMovementComponent.PerchRadiusThreshold = 0x24c // float (Size: 0x4)
CharacterMovementComponent.PerchAdditionalHeight = 0x250 // float (Size: 0x4)
CharacterMovementComponent.RotationRate = 0x254 // FRotator (Size: 0xc)
CharacterMovementComponent.bUseSeparateBrakingFriction = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bApplyGravityWhileJumping = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bUseControllerDesiredRotation = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bOrientRotationToMovement = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bSweepWhileNavWalking = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bMovementInProgress = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bEnableScopedMovementUpdates = 0x260 // uint8_t (Size: 0x1)
CharacterMovementComponent.bEnableServerDualMoveScopedMovementUpdates = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bForceMaxAccel = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bRunPhysicsWithNoController = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bForceNextFloorCheck = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bShrinkProxyCapsule = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bCanWalkOffLedges = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bCanWalkOffLedgesWhenCrouching = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bSimulateMovementUseNavData = 0x261 // uint8_t (Size: 0x1)
CharacterMovementComponent.bNetworkSkipProxyPredictionOnNetUpdate = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bNetworkAlwaysReplicateTransformUpdateTimestamp = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bDeferUpdateMoveComponent = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bEnablePhysicsInteraction = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bTouchForceScaledToMass = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bPushForceScaledToMass = 0x262 // uint8_t (Size: 0x1)
CharacterMovementComponent.bPushForceUsingZOffset = 0x263 // uint8_t (Size: 0x1)
CharacterMovementComponent.bScalePushForceToVelocity = 0x263 // uint8_t (Size: 0x1)
CharacterMovementComponent.DeferredUpdatedMoveComponent = 0x268 // SceneComponent* (Size: 0x8)
CharacterMovementComponent.MaxOutOfWaterStepHeight = 0x270 // float (Size: 0x4)
CharacterMovementComponent.OutofWaterZ = 0x274 // float (Size: 0x4)
CharacterMovementComponent.Mass = 0x278 // float (Size: 0x4)
CharacterMovementComponent.StandingDownwardForceScale = 0x27c // float (Size: 0x4)
CharacterMovementComponent.InitialPushForceFactor = 0x280 // float (Size: 0x4)
CharacterMovementComponent.PushForceFactor = 0x284 // float (Size: 0x4)
CharacterMovementComponent.PushForcePointZOffsetFactor = 0x288 // float (Size: 0x4)
CharacterMovementComponent.TouchForceFactor = 0x28c // float (Size: 0x4)
CharacterMovementComponent.MinTouchForce = 0x290 // float (Size: 0x4)
CharacterMovementComponent.MaxTouchForce = 0x294 // float (Size: 0x4)
CharacterMovementComponent.RepulsionForce = 0x298 // float (Size: 0x4)
CharacterMovementComponent.Acceleration = 0x29c // FVector (Size: 0xc)
CharacterMovementComponent.LastUpdateRotation = 0x2b0 // FQuat (Size: 0x10)
CharacterMovementComponent.LastUpdateLocation = 0x2c0 // FVector (Size: 0xc)
CharacterMovementComponent.LastUpdateVelocity = 0x2cc // FVector (Size: 0xc)
CharacterMovementComponent.ServerLastTransformUpdateTimeStamp = 0x2d8 // float (Size: 0x4)
CharacterMovementComponent.ServerLastClientGoodMoveAckTime = 0x2dc // float (Size: 0x4)
CharacterMovementComponent.ServerLastClientAdjustmentTime = 0x2e0 // float (Size: 0x4)
CharacterMovementComponent.PendingImpulseToApply = 0x2e4 // FVector (Size: 0xc)
CharacterMovementComponent.PendingForceToApply = 0x2f0 // FVector (Size: 0xc)
CharacterMovementComponent.AnalogInputModifier = 0x2fc // float (Size: 0x4)
CharacterMovementComponent.MaxSimulationTimeStep = 0x30c // float (Size: 0x4)
CharacterMovementComponent.MaxSimulationIterations = 0x310 // int32_t (Size: 0x4)
CharacterMovementComponent.MaxJumpApexAttemptsPerSimulation = 0x314 // int32_t (Size: 0x4)
CharacterMovementComponent.MaxDepenetrationWithGeometry = 0x318 // float (Size: 0x4)
CharacterMovementComponent.MaxDepenetrationWithGeometryAsProxy = 0x31c // float (Size: 0x4)
CharacterMovementComponent.MaxDepenetrationWithPawn = 0x320 // float (Size: 0x4)
CharacterMovementComponent.MaxDepenetrationWithPawnAsProxy = 0x324 // float (Size: 0x4)
CharacterMovementComponent.NetworkSimulatedSmoothLocationTime = 0x328 // float (Size: 0x4)
CharacterMovementComponent.NetworkSimulatedSmoothRotationTime = 0x32c // float (Size: 0x4)
CharacterMovementComponent.ListenServerNetworkSimulatedSmoothLocationTime = 0x330 // float (Size: 0x4)
CharacterMovementComponent.ListenServerNetworkSimulatedSmoothRotationTime = 0x334 // float (Size: 0x4)
CharacterMovementComponent.NetProxyShrinkRadius = 0x338 // float (Size: 0x4)
CharacterMovementComponent.NetProxyShrinkHalfHeight = 0x33c // float (Size: 0x4)
CharacterMovementComponent.NetworkMaxSmoothUpdateDistance = 0x340 // float (Size: 0x4)
CharacterMovementComponent.NetworkNoSmoothUpdateDistance = 0x344 // float (Size: 0x4)
CharacterMovementComponent.NetworkMinTimeBetweenClientAckGoodMoves = 0x348 // float (Size: 0x4)
CharacterMovementComponent.NetworkMinTimeBetweenClientAdjustments = 0x34c // float (Size: 0x4)
CharacterMovementComponent.NetworkMinTimeBetweenClientAdjustmentsLargeCorrection = 0x350 // float (Size: 0x4)
CharacterMovementComponent.NetworkLargeClientCorrectionDistance = 0x354 // float (Size: 0x4)
CharacterMovementComponent.LedgeCheckThreshold = 0x358 // float (Size: 0x4)
CharacterMovementComponent.JumpOutOfWaterPitch = 0x35c // float (Size: 0x4)
CharacterMovementComponent.CurrentFloor = 0x360 // FFindFloorResult (Size: 0xa8)
CharacterMovementComponent.DefaultLandMovementMode = 0x408 // uint8_t (Size: 0x1)
CharacterMovementComponent.DefaultWaterMovementMode = 0x409 // uint8_t (Size: 0x1)
CharacterMovementComponent.GroundMovementMode = 0x410 // uint8_t (Size: 0x1)
CharacterMovementComponent.bMaintainHorizontalGroundVelocity = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bImpartBaseVelocityX = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bImpartBaseVelocityY = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bImpartBaseVelocityZ = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bImpartBaseAngularVelocity = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bJustTeleported = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bNetworkUpdateReceived = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bNetworkMovementModeChanged = 0x411 // uint8_t (Size: 0x1)
CharacterMovementComponent.bIgnoreClientMovementErrorChecksAndCorrection = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bServerAcceptClientAuthoritativePosition = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bNotifyApex = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bCheatFlying = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bWantsToCrouch = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bCrouchMaintainsBaseLocation = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bIgnoreBaseRotation = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bFastAttachedMove = 0x412 // uint8_t (Size: 0x1)
CharacterMovementComponent.bAlwaysCheckFloor = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bUseFlatBaseForFloorChecks = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bPerformingJumpOff = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bWantsToLeaveNavWalking = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bUseRVOAvoidance = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bRequestedMoveUseAcceleration = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bWasSimulatingRootMotion = 0x413 // uint8_t (Size: 0x1)
CharacterMovementComponent.bAllowPhysicsRotationDuringAnimRootMotion = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.bHasRequestedVelocity = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.bRequestedMoveWithMaxSpeed = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.bWasAvoidanceUpdated = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.bProjectNavMeshWalking = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.bProjectNavMeshOnBothWorldChannels = 0x414 // uint8_t (Size: 0x1)
CharacterMovementComponent.AvoidanceConsiderationRadius = 0x428 // float (Size: 0x4)
CharacterMovementComponent.RequestedVelocity = 0x42c // FVector (Size: 0xc)
CharacterMovementComponent.AvoidanceUID = 0x438 // int32_t (Size: 0x4)
CharacterMovementComponent.AvoidanceGroup = 0x43c // FNavAvoidanceMask (Size: 0x4)
CharacterMovementComponent.GroupsToAvoid = 0x440 // FNavAvoidanceMask (Size: 0x4)
CharacterMovementComponent.GroupsToIgnore = 0x444 // FNavAvoidanceMask (Size: 0x4)
CharacterMovementComponent.AvoidanceWeight = 0x448 // float (Size: 0x4)
CharacterMovementComponent.PendingLaunchVelocity = 0x44c // FVector (Size: 0xc)
CharacterMovementComponent.NavMeshProjectionInterval = 0x508 // float (Size: 0x4)
CharacterMovementComponent.NavMeshProjectionTimer = 0x50c // float (Size: 0x4)
CharacterMovementComponent.NavMeshProjectionInterpSpeed = 0x510 // float (Size: 0x4)
CharacterMovementComponent.NavMeshProjectionHeightScaleUp = 0x514 // float (Size: 0x4)
CharacterMovementComponent.NavMeshProjectionHeightScaleDown = 0x518 // float (Size: 0x4)
CharacterMovementComponent.NavWalkingFloorDistTolerance = 0x51c // float (Size: 0x4)
CharacterMovementComponent.PostPhysicsTickFunction = 0x520 // FCharacterMovementComponentPostPhysicsTickFunction (Size: 0x40)
CharacterMovementComponent.MinTimeBetweenTimeStampResets = 0x588 // float (Size: 0x4)
CharacterMovementComponent.CurrentRootMotion = 0xa68 // FRootMotionSourceGroup (Size: 0x38)
CharacterMovementComponent.ServerCorrectionRootMotion = 0xaa0 // FRootMotionSourceGroup (Size: 0x38)
CharacterMovementComponent.RootMotionParams = 0xb70 // FRootMotionMovementParams (Size: 0x40)
CharacterMovementComponent.AnimRootMotionVelocity = 0xbb0 // FVector (Size: 0xc)
CharacterMovementComponent.bEnableRootMotionMontageParallelUpdate = 0xbbc // uint8_t (Size: 0x1)
CharacterMovementComponent.bEnableLedgeMove = 0xbbc // uint8_t (Size: 0x1)
CheatManager.DebugCameraControllerRef = 0x28 // DebugCameraController* (Size: 0x8)
CheatManager.DebugCameraControllerClass = 0x30 // ClassProperty (Size: 0x8)
CheckBoxStyleAsset.CheckBoxStyle = 0x28 // FCheckBoxStyle (Size: 0x5c8)
ChildActorAttachedActorInfo.Actor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
ChildActorAttachedActorInfo.SocketName = 0x8 // FName (Size: 0x8)
ChildActorAttachedActorInfo.RelativeTransform = 0x10 // FTransform (Size: 0x30)
ChildActorComponent.ChildActorClass = 0x238 // ClassProperty (Size: 0x8)
ChildActorComponent.ChildActor = 0x240 // Actor* (Size: 0x8)
ChildActorComponent.ChildActorTemplate = 0x248 // Actor* (Size: 0x8)
ChildActorComponentInstanceData.ChildActorClass = 0xb8 // ClassProperty (Size: 0x8)
ChildActorComponentInstanceData.ChildActorName = 0xc0 // FName (Size: 0x8)
ChildActorComponentInstanceData.AttachedActors = 0xc8 // TArray<FChildActorAttachedActorInfo> (Size: 0x10)
ChildConnection.Parent = 0x1ba8 // NetConnection* (Size: 0x8)
ClassRedirect.ObjectName = 0x0 // FName (Size: 0x8)
ClassRedirect.OldClassName = 0x8 // FName (Size: 0x8)
ClassRedirect.NewClassName = 0x10 // FName (Size: 0x8)
ClassRedirect.OldSubobjName = 0x18 // FName (Size: 0x8)
ClassRedirect.NewSubobjName = 0x20 // FName (Size: 0x8)
ClassRedirect.NewClassClass = 0x28 // FName (Size: 0x8)
ClassRedirect.NewClassPackage = 0x30 // FName (Size: 0x8)
ClassRedirect.InstanceOnly = 0x38 // bool (Size: 0x1)
ClientReceiveData.LocalPC = 0x0 // PlayerController* (Size: 0x8)
ClientReceiveData.MessageType = 0x8 // FName (Size: 0x8)
ClientReceiveData.MessageIndex = 0x10 // int32_t (Size: 0x4)
ClientReceiveData.MessageString = 0x18 // FString (Size: 0x10)
ClientReceiveData.RelatedPlayerState_2 = 0x28 // PlayerState* (Size: 0x8)
ClientReceiveData.RelatedPlayerState_3 = 0x30 // PlayerState* (Size: 0x8)
ClientReceiveData.OptionalObject = 0x38 // Object* (Size: 0x8)
ClothPhysicsProperties_Legacy.VerticalResistance = 0x0 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.HorizontalResistance = 0x4 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.BendResistance = 0x8 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.ShearResistance = 0xc // float (Size: 0x4)
ClothPhysicsProperties_Legacy.Friction = 0x10 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.Damping = 0x14 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.TetherStiffness = 0x18 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.TetherLimit = 0x1c // float (Size: 0x4)
ClothPhysicsProperties_Legacy.Drag = 0x20 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.StiffnessFrequency = 0x24 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.GravityScale = 0x28 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.MassScale = 0x2c // float (Size: 0x4)
ClothPhysicsProperties_Legacy.InertiaBlend = 0x30 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.SelfCollisionThickness = 0x34 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.SelfCollisionSquashScale = 0x38 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.SelfCollisionStiffness = 0x3c // float (Size: 0x4)
ClothPhysicsProperties_Legacy.SolverFrequency = 0x40 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.FiberCompression = 0x44 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.FiberExpansion = 0x48 // float (Size: 0x4)
ClothPhysicsProperties_Legacy.FiberResistance = 0x4c // float (Size: 0x4)
ClothingAssetData_Legacy.AssetName = 0x0 // FName (Size: 0x8)
ClothingAssetData_Legacy.ApexFileName = 0x8 // FString (Size: 0x10)
ClothingAssetData_Legacy.bClothPropertiesChanged = 0x18 // bool (Size: 0x1)
ClothingAssetData_Legacy.PhysicsProperties = 0x1c // FClothPhysicsProperties_Legacy (Size: 0x50)
CloudStorageBase.LocalCloudFiles = 0x38 // TArray<FString> (Size: 0x10)
CloudStorageBase.bSuppressDelegateCalls = 0x48 // uint8_t (Size: 0x1)
ClusterNode.BoundMin = 0x0 // FVector (Size: 0xc)
ClusterNode.FirstChild = 0xc // int32_t (Size: 0x4)
ClusterNode.BoundMax = 0x10 // FVector (Size: 0xc)
ClusterNode.LastChild = 0x1c // int32_t (Size: 0x4)
ClusterNode.FirstInstance = 0x20 // int32_t (Size: 0x4)
ClusterNode.LastInstance = 0x24 // int32_t (Size: 0x4)
ClusterNode.MinInstanceScale = 0x28 // FVector (Size: 0xc)
ClusterNode.MaxInstanceScale = 0x34 // FVector (Size: 0xc)
ClusterNode_DEPRECATED.BoundMin = 0x0 // FVector (Size: 0xc)
ClusterNode_DEPRECATED.FirstChild = 0xc // int32_t (Size: 0x4)
ClusterNode_DEPRECATED.BoundMax = 0x10 // FVector (Size: 0xc)
ClusterNode_DEPRECATED.LastChild = 0x1c // int32_t (Size: 0x4)
ClusterNode_DEPRECATED.FirstInstance = 0x20 // int32_t (Size: 0x4)
ClusterNode_DEPRECATED.LastInstance = 0x24 // int32_t (Size: 0x4)
CollectionParameterBase.ParameterName = 0x0 // FName (Size: 0x8)
CollectionParameterBase.ID = 0x8 // FGuid (Size: 0x10)
CollectionReference.CollectionName = 0x0 // FName (Size: 0x8)
CollectionScalarParameter.DefaultValue = 0x18 // float (Size: 0x4)
CollectionVectorParameter.DefaultValue = 0x18 // FLinearColor (Size: 0x10)
CollisionImpactData.ContactInfos = 0x0 // TArray<FRigidBodyContactInfo> (Size: 0x10)
CollisionImpactData.TotalNormalImpulse = 0x10 // FVector (Size: 0xc)
CollisionImpactData.TotalFrictionImpulse = 0x1c // FVector (Size: 0xc)
CollisionImpactData.bIsVelocityDeltaUnderThreshold = 0x28 // bool (Size: 0x1)
CollisionProfile.Profiles = 0x38 // TArray<FCollisionResponseTemplate> (Size: 0x10)
CollisionProfile.DefaultChannelResponses = 0x48 // TArray<FCustomChannelSetup> (Size: 0x10)
CollisionProfile.EditProfiles = 0x58 // TArray<FCustomProfile> (Size: 0x10)
CollisionProfile.ProfileRedirects = 0x68 // TArray<FRedirector> (Size: 0x10)
CollisionProfile.CollisionChannelRedirects = 0x78 // TArray<FRedirector> (Size: 0x10)
CollisionProfileName.Name = 0x0 // FName (Size: 0x8)
CollisionResponse.ResponseToChannels = 0x0 // FCollisionResponseContainer (Size: 0x20)
CollisionResponse.ResponseArray = 0x20 // TArray<FResponseChannel> (Size: 0x10)
CollisionResponseContainer.WorldStatic = 0x0 // uint8_t (Size: 0x1)
CollisionResponseContainer.WorldDynamic = 0x1 // uint8_t (Size: 0x1)
CollisionResponseContainer.Pawn = 0x2 // uint8_t (Size: 0x1)
CollisionResponseContainer.Visibility = 0x3 // uint8_t (Size: 0x1)
CollisionResponseContainer.Camera = 0x4 // uint8_t (Size: 0x1)
CollisionResponseContainer.PhysicsBody = 0x5 // uint8_t (Size: 0x1)
CollisionResponseContainer.Vehicle = 0x6 // uint8_t (Size: 0x1)
CollisionResponseContainer.Destructible = 0x7 // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel1 = 0x8 // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel2 = 0x9 // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel3 = 0xa // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel4 = 0xb // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel5 = 0xc // uint8_t (Size: 0x1)
CollisionResponseContainer.EngineTraceChannel6 = 0xd // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel1 = 0xe // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel2 = 0xf // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel3 = 0x10 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel4 = 0x11 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel5 = 0x12 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel6 = 0x13 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel7 = 0x14 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel8 = 0x15 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel9 = 0x16 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel10 = 0x17 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel11 = 0x18 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel12 = 0x19 // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel13 = 0x1a // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel14 = 0x1b // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel15 = 0x1c // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel16 = 0x1d // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel17 = 0x1e // uint8_t (Size: 0x1)
CollisionResponseContainer.GameTraceChannel18 = 0x1f // uint8_t (Size: 0x1)
CollisionResponseTemplate.Name = 0x0 // FName (Size: 0x8)
CollisionResponseTemplate.CollisionEnabled = 0x8 // uint8_t (Size: 0x1)
CollisionResponseTemplate.bCanModify = 0xa // bool (Size: 0x1)
CollisionResponseTemplate.ObjectTypeName = 0x2c // FName (Size: 0x8)
CollisionResponseTemplate.CustomResponses = 0x38 // TArray<FResponseChannel> (Size: 0x10)
ColorGradePerRangeSettings.Saturation = 0x0 // FVector4 (Size: 0x10)
ColorGradePerRangeSettings.Contrast = 0x10 // FVector4 (Size: 0x10)
ColorGradePerRangeSettings.Gamma = 0x20 // FVector4 (Size: 0x10)
ColorGradePerRangeSettings.Gain = 0x30 // FVector4 (Size: 0x10)
ColorGradePerRangeSettings.Offset = 0x40 // FVector4 (Size: 0x10)
ColorGradePerRangeSettings.Vibrance = 0x50 // float (Size: 0x4)
ColorGradingSettings.Global = 0x0 // FColorGradePerRangeSettings (Size: 0x60)
ColorGradingSettings.Shadows = 0x60 // FColorGradePerRangeSettings (Size: 0x60)
ColorGradingSettings.Midtones = 0xc0 // FColorGradePerRangeSettings (Size: 0x60)
ColorGradingSettings.Highlights = 0x120 // FColorGradePerRangeSettings (Size: 0x60)
ColorGradingSettings.ShadowsMax = 0x180 // float (Size: 0x4)
ColorGradingSettings.HighlightsMin = 0x184 // float (Size: 0x4)
Commandlet.HelpDescription = 0x28 // FString (Size: 0x10)
Commandlet.HelpUsage = 0x38 // FString (Size: 0x10)
Commandlet.HelpWebLink = 0x48 // FString (Size: 0x10)
Commandlet.HelpParamNames = 0x58 // TArray<FString> (Size: 0x10)
Commandlet.HelpParamDescriptions = 0x68 // TArray<FString> (Size: 0x10)
Commandlet.IsServer = 0x78 // uint8_t (Size: 0x1)
Commandlet.IsClient = 0x78 // uint8_t (Size: 0x1)
Commandlet.IsEditor = 0x78 // uint8_t (Size: 0x1)
Commandlet.LogToConsole = 0x78 // uint8_t (Size: 0x1)
Commandlet.ShowErrorCount = 0x78 // uint8_t (Size: 0x1)
Commandlet.ShowProgress = 0x78 // uint8_t (Size: 0x1)
CompilerNativizationOptions.PlatformName = 0x0 // FName (Size: 0x8)
CompilerNativizationOptions.ServerOnlyPlatform = 0x8 // bool (Size: 0x1)
CompilerNativizationOptions.ClientOnlyPlatform = 0x9 // bool (Size: 0x1)
CompilerNativizationOptions.bExcludeMonolithicHeaders = 0xa // bool (Size: 0x1)
CompilerNativizationOptions.ExcludedModules = 0x10 // TArray<FName> (Size: 0x10)
CompilerNativizationOptions.ExcludedAssets = 0x20 // TSet<...> (Size: 0x50)
CompilerNativizationOptions.ExcludedFolderPaths = 0x70 // TArray<FString> (Size: 0x10)
ComponentDelegateBinding.ComponentDelegateBindings = 0x28 // TArray<FBlueprintComponentDelegateBinding> (Size: 0x10)
ComponentKey.OwnerClass = 0x0 // ClassProperty (Size: 0x8)
ComponentKey.SCSVariableName = 0x8 // FName (Size: 0x8)
ComponentKey.AssociatedGuid = 0x10 // FGuid (Size: 0x10)
ComponentOverrideRecord.ComponentClass = 0x0 // ClassProperty (Size: 0x8)
ComponentOverrideRecord.ComponentTemplate = 0x8 // ActorComponent* (Size: 0x8)
ComponentOverrideRecord.ComponentKey = 0x10 // FComponentKey (Size: 0x20)
ComponentOverrideRecord.CookedComponentInstancingData = 0x30 // FBlueprintCookedComponentInstancingData (Size: 0x48)
ComponentReference.OtherActor = 0x0 // Actor* (Size: 0x8)
ComponentReference.ComponentProperty = 0x8 // FName (Size: 0x8)
ComponentReference.PathToComponent = 0x10 // FString (Size: 0x10)
ComponentSpacePose.Transforms = 0x0 // TArray<FTransform> (Size: 0x10)
ComponentSpacePose.Names = 0x10 // TArray<FName> (Size: 0x10)
ComponentSync.Name = 0x0 // FName (Size: 0x8)
ComponentSync.SyncOption = 0x8 // EESyncOption (Size: 0x1)
CompositeCurveTable.ParentTables = 0xa0 // TArray<CurveTable*> (Size: 0x10)
CompositeCurveTable.OldParentTables = 0xb0 // TArray<CurveTable*> (Size: 0x10)
CompositeDataTable.ParentTables = 0xb0 // TArray<DataTable*> (Size: 0x10)
CompositeDataTable.OldParentTables = 0xc0 // TArray<DataTable*> (Size: 0x10)
CompositeSection.SectionName = 0x30 // FName (Size: 0x8)
CompositeSection.StartTime = 0x38 // float (Size: 0x4)
CompositeSection.NextSectionName = 0x3c // FName (Size: 0x8)
CompositeSection.MetaData = 0x48 // TArray<AnimMetaData*> (Size: 0x10)
CompressedTrack.ByteStream = 0x0 // TArray<uint8_t> (Size: 0x10)
CompressedTrack.Times = 0x10 // TArray<float> (Size: 0x10)
CompressedTrack.Mins = 0x20 // float (Size: 0x4)
CompressedTrack.Ranges = 0x2c // float (Size: 0x4)
ConeConstraint.Swing1LimitDegrees = 0x14 // float (Size: 0x4)
ConeConstraint.Swing2LimitDegrees = 0x18 // float (Size: 0x4)
ConeConstraint.Swing1Motion = 0x1c // uint8_t (Size: 0x1)
ConeConstraint.Swing2Motion = 0x1d // uint8_t (Size: 0x1)
Console.ConsoleTargetPlayer = 0x38 // LocalPlayer* (Size: 0x8)
Console.DefaultTexture_Black = 0x40 // Texture2D* (Size: 0x8)
Console.DefaultTexture_White = 0x48 // Texture2D* (Size: 0x8)
Console.HistoryBuffer = 0x68 // TArray<FString> (Size: 0x10)
ConstrainComponentPropName.ComponentName = 0x0 // FName (Size: 0x8)
ConstraintBaseParams.Stiffness = 0x0 // float (Size: 0x4)
ConstraintBaseParams.Damping = 0x4 // float (Size: 0x4)
ConstraintBaseParams.Restitution = 0x8 // float (Size: 0x4)
ConstraintBaseParams.ContactDistance = 0xc // float (Size: 0x4)
ConstraintBaseParams.bSoftConstraint = 0x10 // uint8_t (Size: 0x1)
ConstraintDrive.Stiffness = 0x0 // float (Size: 0x4)
ConstraintDrive.Damping = 0x4 // float (Size: 0x4)
ConstraintDrive.MaxForce = 0x8 // float (Size: 0x4)
ConstraintDrive.bEnablePositionDrive = 0xc // uint8_t (Size: 0x1)
ConstraintDrive.bEnableVelocityDrive = 0xc // uint8_t (Size: 0x1)
ConstraintInstance.JointName = 0x18 // FName (Size: 0x8)
ConstraintInstance.ConstraintBone1 = 0x20 // FName (Size: 0x8)
ConstraintInstance.ConstraintBone2 = 0x28 // FName (Size: 0x8)
ConstraintInstance.Pos1 = 0x30 // FVector (Size: 0xc)
ConstraintInstance.PriAxis1 = 0x3c // FVector (Size: 0xc)
ConstraintInstance.SecAxis1 = 0x48 // FVector (Size: 0xc)
ConstraintInstance.Pos2 = 0x54 // FVector (Size: 0xc)
ConstraintInstance.PriAxis2 = 0x60 // FVector (Size: 0xc)
ConstraintInstance.SecAxis2 = 0x6c // FVector (Size: 0xc)
ConstraintInstance.AngularRotationOffset = 0x78 // FRotator (Size: 0xc)
ConstraintInstance.bScaleLinearLimits = 0x84 // uint8_t (Size: 0x1)
ConstraintInstance.ProfileInstance = 0x8c // FConstraintProfileProperties (Size: 0x10c)
ConstraintProfileProperties.ProjectionLinearTolerance = 0x0 // float (Size: 0x4)
ConstraintProfileProperties.ProjectionAngularTolerance = 0x4 // float (Size: 0x4)
ConstraintProfileProperties.ProjectionLinearAlpha = 0x8 // float (Size: 0x4)
ConstraintProfileProperties.ProjectionAngularAlpha = 0xc // float (Size: 0x4)
ConstraintProfileProperties.LinearBreakThreshold = 0x10 // float (Size: 0x4)
ConstraintProfileProperties.AngularBreakThreshold = 0x14 // float (Size: 0x4)
ConstraintProfileProperties.LinearLimit = 0x18 // FLinearConstraint (Size: 0x1c)
ConstraintProfileProperties.ConeLimit = 0x34 // FConeConstraint (Size: 0x20)
ConstraintProfileProperties.TwistLimit = 0x54 // FTwistConstraint (Size: 0x1c)
ConstraintProfileProperties.LinearDrive = 0x70 // FLinearDriveConstraint (Size: 0x4c)
ConstraintProfileProperties.AngularDrive = 0xbc // FAngularDriveConstraint (Size: 0x4c)
ConstraintProfileProperties.bDisableCollision = 0x108 // uint8_t (Size: 0x1)
ConstraintProfileProperties.bParentDominates = 0x108 // uint8_t (Size: 0x1)
ConstraintProfileProperties.bEnableProjection = 0x108 // uint8_t (Size: 0x1)
ConstraintProfileProperties.bEnableSoftProjection = 0x108 // uint8_t (Size: 0x1)
ConstraintProfileProperties.bAngularBreakable = 0x108 // uint8_t (Size: 0x1)
ConstraintProfileProperties.bLinearBreakable = 0x108 // uint8_t (Size: 0x1)
Controller.PlayerState = 0x318 // PlayerState* (Size: 0x8)
Controller.OnInstigatedAnyDamage = 0x328 // FMulticastInlineDelegate (Size: 0x10)
Controller.StateName = 0x338 // FName (Size: 0x8)
Controller.Pawn = 0x340 // Pawn* (Size: 0x8)
Controller.Character = 0x350 // Character* (Size: 0x8)
Controller.TransformComponent = 0x358 // SceneComponent* (Size: 0x8)
Controller.ControlRotation = 0x378 // FRotator (Size: 0xc)
Controller.bAttachToPawn = 0x384 // uint8_t (Size: 0x1)
ConvolutionBloomSettings.Texture = 0x0 // Texture2D* (Size: 0x8)
ConvolutionBloomSettings.Size = 0x8 // float (Size: 0x4)
ConvolutionBloomSettings.CenterUV = 0xc // FVector2D (Size: 0x8)
ConvolutionBloomSettings.PreFilterMin = 0x14 // float (Size: 0x4)
ConvolutionBloomSettings.PreFilterMax = 0x18 // float (Size: 0x4)
ConvolutionBloomSettings.PreFilterMult = 0x1c // float (Size: 0x4)
ConvolutionBloomSettings.BufferScale = 0x20 // float (Size: 0x4)
CullDistanceSizePair.Size = 0x0 // float (Size: 0x4)
CullDistanceSizePair.CullDistance = 0x4 // float (Size: 0x4)
CullDistanceVolume.CullDistances = 0x348 // TArray<FCullDistanceSizePair> (Size: 0x10)
CullDistanceVolume.bEnabled = 0x358 // uint8_t (Size: 0x1)
CurveEdEntry.CurveObject = 0x0 // Object* (Size: 0x8)
CurveEdEntry.CurveColor = 0x8 // FColor (Size: 0x4)
CurveEdEntry.CurveName = 0x10 // FString (Size: 0x10)
CurveEdEntry.bHideCurve = 0x20 // int32_t (Size: 0x4)
CurveEdEntry.bColorCurve = 0x24 // int32_t (Size: 0x4)
CurveEdEntry.bFloatingPointColorCurve = 0x28 // int32_t (Size: 0x4)
CurveEdEntry.bClamp = 0x2c // int32_t (Size: 0x4)
CurveEdEntry.ClampLow = 0x30 // float (Size: 0x4)
CurveEdEntry.ClampHigh = 0x34 // float (Size: 0x4)
CurveEdTab.TabName = 0x0 // FString (Size: 0x10)
CurveEdTab.Curves = 0x10 // TArray<FCurveEdEntry> (Size: 0x10)
CurveEdTab.ViewStartInput = 0x20 // float (Size: 0x4)
CurveEdTab.ViewEndInput = 0x24 // float (Size: 0x4)
CurveEdTab.ViewStartOutput = 0x28 // float (Size: 0x4)
CurveEdTab.ViewEndOutput = 0x2c // float (Size: 0x4)
CurveFloat.FloatCurve = 0x30 // FRichCurve (Size: 0x80)
CurveFloat.bIsEventCurve = 0xb0 // bool (Size: 0x1)
CurveLinearColor.FloatCurves = 0x30 // FRichCurve (Size: 0x80)
CurveLinearColor.AdjustHue = 0x230 // float (Size: 0x4)
CurveLinearColor.AdjustSaturation = 0x234 // float (Size: 0x4)
CurveLinearColor.AdjustBrightness = 0x238 // float (Size: 0x4)
CurveLinearColor.AdjustBrightnessCurve = 0x23c // float (Size: 0x4)
CurveLinearColor.AdjustVibrance = 0x240 // float (Size: 0x4)
CurveLinearColor.AdjustMinAlpha = 0x244 // float (Size: 0x4)
CurveLinearColor.AdjustMaxAlpha = 0x248 // float (Size: 0x4)
CurveLinearColorAtlas.TextureSize = 0x118 // uint32_t (Size: 0x4)
CurveLinearColorAtlas.GradientCurves = 0x120 // TArray<CurveLinearColor*> (Size: 0x10)
CurveTableRowHandle.CurveTable = 0x0 // CurveTable* (Size: 0x8)
CurveTableRowHandle.RowName = 0x8 // FName (Size: 0x8)
CurveTrack.CurveName = 0x0 // FName (Size: 0x8)
CurveTrack.CurveWeights = 0x8 // TArray<float> (Size: 0x10)
CurveVector.FloatCurves = 0x30 // FRichCurve (Size: 0x80)
CustomAttribute.Name = 0x0 // FName (Size: 0x8)
CustomAttribute.VariantType = 0x8 // int32_t (Size: 0x4)
CustomAttribute.Times = 0x10 // TArray<float> (Size: 0x10)
CustomAttributePerBoneData.BoneTreeIndex = 0x0 // int32_t (Size: 0x4)
CustomAttributePerBoneData.Attributes = 0x8 // TArray<FCustomAttribute> (Size: 0x10)
CustomAttributeSetting.Name = 0x0 // FString (Size: 0x10)
CustomAttributeSetting.Meaning = 0x10 // FString (Size: 0x10)
CustomChannelSetup.Channel = 0x0 // uint8_t (Size: 0x1)
CustomChannelSetup.DefaultResponse = 0x1 // uint8_t (Size: 0x1)
CustomChannelSetup.bTraceType = 0x2 // bool (Size: 0x1)
CustomChannelSetup.bStaticObject = 0x3 // bool (Size: 0x1)
CustomChannelSetup.Name = 0x4 // FName (Size: 0x8)
CustomDefine.DefineName = 0x0 // FString (Size: 0x10)
CustomDefine.DefineValue = 0x10 // FString (Size: 0x10)
CustomInput.InputName = 0x0 // FName (Size: 0x8)
CustomInput.Input = 0x8 // FExpressionInput (Size: 0xc)
CustomOutput.OutputName = 0x0 // FName (Size: 0x8)
CustomOutput.OutputType = 0x8 // uint8_t (Size: 0x1)
CustomPrimitiveData.Data = 0x0 // TArray<float> (Size: 0x10)
CustomProfile.Name = 0x0 // FName (Size: 0x8)
CustomProfile.CustomResponses = 0x8 // TArray<FResponseChannel> (Size: 0x10)
DamageEvent.DamageTypeClass = 0x8 // ClassProperty (Size: 0x8)
DamageType.bCausedByWorld = 0x28 // uint8_t (Size: 0x1)
DamageType.bScaleMomentumByMass = 0x28 // uint8_t (Size: 0x1)
DamageType.bRadialDamageVelChange = 0x28 // uint8_t (Size: 0x1)
DamageType.DamageImpulse = 0x2c // float (Size: 0x4)
DamageType.DestructibleImpulse = 0x30 // float (Size: 0x4)
DamageType.DestructibleDamageSpreadScale = 0x34 // float (Size: 0x4)
DamageType.DamageFalloff = 0x38 // float (Size: 0x4)
DataAsset.NativeClass = 0x28 // ClassProperty (Size: 0x8)
DataTable.RowStruct = 0x28 // ScriptStruct* (Size: 0x8)
DataTable.bStripFromClientBuilds = 0x80 // uint8_t (Size: 0x1)
DataTable.bIgnoreExtraFields = 0x80 // uint8_t (Size: 0x1)
DataTable.bIgnoreMissingFields = 0x80 // uint8_t (Size: 0x1)
DataTable.ImportKeyField = 0x88 // FString (Size: 0x10)
DataTableCategoryHandle.DataTable = 0x0 // DataTable* (Size: 0x8)
DataTableCategoryHandle.ColumnName = 0x8 // FName (Size: 0x8)
DataTableCategoryHandle.RowContents = 0x10 // FName (Size: 0x8)
DataTableRowHandle.DataTable = 0x0 // DataTable* (Size: 0x8)
DataTableRowHandle.RowName = 0x8 // FName (Size: 0x8)
DebugCameraController.bShowSelectedInfo = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bIsFrozenRendering = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bIsOrbitingSelectedActor = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bOrbitPivotUseCenter = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bEnableBufferVisualization = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bEnableBufferVisualizationFullMode = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bIsBufferVisualizationInputSetup = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.bLastDisplayEnabled = 0x670 // uint8_t (Size: 0x1)
DebugCameraController.DrawFrustum = 0x678 // DrawFrustumComponent* (Size: 0x8)
DebugCameraController.SelectedActor = 0x680 // Actor* (Size: 0x8)
DebugCameraController.SelectedComponent = 0x688 // PrimitiveComponent* (Size: 0x8)
DebugCameraController.SelectedHitPoint = 0x690 // FHitResult (Size: 0x98)
DebugCameraController.OriginalControllerRef = 0x728 // PlayerController* (Size: 0x8)
DebugCameraController.OriginalPlayer = 0x730 // Player* (Size: 0x8)
DebugCameraController.SpeedScale = 0x738 // float (Size: 0x4)
DebugCameraController.InitialMaxSpeed = 0x73c // float (Size: 0x4)
DebugCameraController.InitialAccel = 0x740 // float (Size: 0x4)
DebugCameraController.InitialDecel = 0x744 // float (Size: 0x4)
DebugCameraControllerSettings.CycleViewModes = 0x38 // TArray<FDebugCameraControllerSettingsViewModeIndex> (Size: 0x10)
DebugCameraControllerSettingsViewModeIndex.ViewModeIndex = 0x8 // uint8_t (Size: 0x1)
DebugDisplayProperty.Obj = 0x0 // Object* (Size: 0x8)
DebugDisplayProperty.WithinClass = 0x8 // ClassProperty (Size: 0x8)
DebugFloatHistory.Samples = 0x0 // TArray<float> (Size: 0x10)
DebugFloatHistory.MaxSamples = 0x10 // float (Size: 0x4)
DebugFloatHistory.MinValue = 0x14 // float (Size: 0x4)
DebugFloatHistory.MaxValue = 0x18 // float (Size: 0x4)
DebugFloatHistory.bAutoAdjustMinMax = 0x1c // bool (Size: 0x1)
DebugTextInfo.SrcActor = 0x0 // Actor* (Size: 0x8)
DebugTextInfo.SrcActorOffset = 0x8 // FVector (Size: 0xc)
DebugTextInfo.SrcActorDesiredOffset = 0x14 // FVector (Size: 0xc)
DebugTextInfo.DebugText = 0x20 // FString (Size: 0x10)
DebugTextInfo.TimeRemaining = 0x30 // float (Size: 0x4)
DebugTextInfo.Duration = 0x34 // float (Size: 0x4)
DebugTextInfo.TextColor = 0x38 // FColor (Size: 0x4)
DebugTextInfo.bAbsoluteLocation = 0x3c // uint8_t (Size: 0x1)
DebugTextInfo.bKeepAttachedToActor = 0x3c // uint8_t (Size: 0x1)
DebugTextInfo.bDrawShadow = 0x3c // uint8_t (Size: 0x1)
DebugTextInfo.OrigActorLocation = 0x40 // FVector (Size: 0xc)
DebugTextInfo.Font = 0x50 // Font* (Size: 0x8)
DebugTextInfo.FontScale = 0x58 // float (Size: 0x4)
DecalActor.Decal = 0x310 // DecalComponent* (Size: 0x8)
DecalComponent.DecalMaterial = 0x238 // MaterialInterface* (Size: 0x8)
DecalComponent.sortOrder = 0x240 // int32_t (Size: 0x4)
DecalComponent.FadeScreenSize = 0x244 // float (Size: 0x4)
DecalComponent.FadeStartDelay = 0x248 // float (Size: 0x4)
DecalComponent.FadeDuration = 0x24c // float (Size: 0x4)
DecalComponent.FadeInDuration = 0x250 // float (Size: 0x4)
DecalComponent.FadeInStartDelay = 0x254 // float (Size: 0x4)
DecalComponent.bDestroyOwnerAfterFade = 0x258 // uint8_t (Size: 0x1)
DecalComponent.DecalSize = 0x25c // FVector (Size: 0xc)
DefaultPawn.BaseTurnRate = 0x380 // float (Size: 0x4)
DefaultPawn.BaseLookUpRate = 0x384 // float (Size: 0x4)
DefaultPawn.MovementComponent = 0x388 // PawnMovementComponent* (Size: 0x8)
DefaultPawn.CollisionComponent = 0x390 // SphereComponent* (Size: 0x8)
DefaultPawn.MeshComponent = 0x398 // StaticMeshComponent* (Size: 0x8)
DefaultPawn.bAddDefaultMovementBindings = 0x3a0 // uint8_t (Size: 0x1)
DefferedDestroyActorManager.DestroyActorQueue = 0x28 // TArray<Actor*> (Size: 0x10)
DefferedDestroyActorManager.PendingCloseChannels = 0x38 // TArray<ActorChannel*> (Size: 0x10)
DelegateArray.Delegates = 0x0 // TArray<FDelegate> (Size: 0x10)
DemoNetDriver.RollbackNetStartupActors = 0x8e0 // TMap<...> (Size: 0x50)
DemoNetDriver.CheckpointSaveMaxMSPerFrame = 0xa8c // float (Size: 0x4)
DemoNetDriver.MulticastRecordOptions = 0xab0 // TArray<FMulticastRecordOptions> (Size: 0x10)
DemoNetDriver.bIsLocalReplay = 0xac0 // bool (Size: 0x1)
DemoNetDriver.SpectatorControllers = 0xac8 // TArray<PlayerController*> (Size: 0x10)
DepthFieldGlowInfo.bEnableGlow = 0x0 // uint8_t (Size: 0x1)
DepthFieldGlowInfo.GlowColor = 0x4 // FLinearColor (Size: 0x10)
DepthFieldGlowInfo.GlowOuterRadius = 0x14 // FVector2D (Size: 0x8)
DepthFieldGlowInfo.GlowInnerRadius = 0x1c // FVector2D (Size: 0x8)
DeviceProfile.DeviceType = 0x38 // FString (Size: 0x10)
DeviceProfile.BaseProfileName = 0x48 // FString (Size: 0x10)
DeviceProfile.Parent = 0x58 // Object* (Size: 0x8)
DeviceProfile.CVars = 0x88 // TArray<FString> (Size: 0x10)
DeviceProfileManager.Profiles = 0x28 // TArray<Object*> (Size: 0x10)
DialogueContext.Speaker = 0x0 // DialogueVoice* (Size: 0x8)
DialogueContext.Targets = 0x8 // TArray<DialogueVoice*> (Size: 0x10)
DialogueContextMapping.Context = 0x0 // FDialogueContext (Size: 0x18)
DialogueContextMapping.SoundWave = 0x18 // SoundWave* (Size: 0x8)
DialogueContextMapping.LocalizationKeyFormat = 0x20 // FString (Size: 0x10)
DialogueContextMapping.Proxy = 0x30 // DialogueSoundWaveProxy* (Size: 0x8)
DialogueVoice.Gender = 0x28 // uint8_t (Size: 0x1)
DialogueVoice.Plurality = 0x29 // uint8_t (Size: 0x1)
DialogueVoice.LocalizationGUID = 0x2c // FGuid (Size: 0x10)
DialogueWave.bMature = 0x28 // uint8_t (Size: 0x1)
DialogueWave.bOverride_SubtitleOverride = 0x28 // uint8_t (Size: 0x1)
DialogueWave.SpokenText = 0x30 // FString (Size: 0x10)
DialogueWave.SubtitleOverride = 0x40 // FString (Size: 0x10)
DialogueWave.ContextMappings = 0x50 // TArray<FDialogueContextMapping> (Size: 0x10)
DialogueWave.LocalizationGUID = 0x60 // FGuid (Size: 0x10)
DialogueWaveParameter.DialogueWave = 0x0 // DialogueWave* (Size: 0x8)
DialogueWaveParameter.Context = 0x8 // FDialogueContext (Size: 0x18)
DirectionalLightComponent.ShadowCascadeBiasDistribution = 0x3a8 // float (Size: 0x4)
DirectionalLightComponent.bEnableLightShaftOcclusion = 0x3ac // uint8_t (Size: 0x1)
DirectionalLightComponent.OcclusionMaskDarkness = 0x3b0 // float (Size: 0x4)
DirectionalLightComponent.OcclusionDepthRange = 0x3b4 // float (Size: 0x4)
DirectionalLightComponent.LightShaftOverrideDirection = 0x3b8 // FVector (Size: 0xc)
DirectionalLightComponent.WholeSceneDynamicShadowRadius = 0x3c4 // float (Size: 0x4)
DirectionalLightComponent.DynamicShadowDistanceMovableLight = 0x3c8 // float (Size: 0x4)
DirectionalLightComponent.DynamicShadowDistanceStationaryLight = 0x3cc // float (Size: 0x4)
DirectionalLightComponent.DynamicShadowCascades = 0x3d0 // int32_t (Size: 0x4)
DirectionalLightComponent.CascadeDistributionExponent = 0x3d4 // float (Size: 0x4)
DirectionalLightComponent.CascadeTransitionFraction = 0x3d8 // float (Size: 0x4)
DirectionalLightComponent.ShadowDistanceFadeoutFraction = 0x3dc // float (Size: 0x4)
DirectionalLightComponent.bUseInsetShadowsForMovableObjects = 0x3e0 // uint8_t (Size: 0x1)
DirectionalLightComponent.FarShadowCascadeCount = 0x3e4 // int32_t (Size: 0x4)
DirectionalLightComponent.FarShadowDistance = 0x3e8 // float (Size: 0x4)
DirectionalLightComponent.DistanceFieldShadowDistance = 0x3ec // float (Size: 0x4)
DirectionalLightComponent.LightSourceAngle = 0x3f0 // float (Size: 0x4)
DirectionalLightComponent.LightSourceSoftAngle = 0x3f4 // float (Size: 0x4)
DirectionalLightComponent.ShadowSourceAngleFactor = 0x3f8 // float (Size: 0x4)
DirectionalLightComponent.TraceDistance = 0x3fc // float (Size: 0x4)
DirectionalLightComponent.bUsedAsAtmosphereSunLight = 0x400 // uint8_t (Size: 0x1)
DirectionalLightComponent.AtmosphereSunLightIndex = 0x404 // int32_t (Size: 0x4)
DirectionalLightComponent.AtmosphereSunDiskColorScale = 0x408 // FLinearColor (Size: 0x10)
DirectionalLightComponent.bPerPixelAtmosphereTransmittance = 0x418 // uint8_t (Size: 0x1)
DirectionalLightComponent.bCastShadowsOnClouds = 0x418 // uint8_t (Size: 0x1)
DirectionalLightComponent.bCastShadowsOnAtmosphere = 0x418 // uint8_t (Size: 0x1)
DirectionalLightComponent.bCastCloudShadows = 0x418 // uint8_t (Size: 0x1)
DirectionalLightComponent.CloudShadowStrength = 0x41c // float (Size: 0x4)
DirectionalLightComponent.CloudShadowOnAtmosphereStrength = 0x420 // float (Size: 0x4)
DirectionalLightComponent.CloudShadowOnSurfaceStrength = 0x424 // float (Size: 0x4)
DirectionalLightComponent.CloudShadowDepthBias = 0x428 // float (Size: 0x4)
DirectionalLightComponent.CloudShadowExtent = 0x42c // float (Size: 0x4)
DirectionalLightComponent.CloudShadowMapResolutionScale = 0x430 // float (Size: 0x4)
DirectionalLightComponent.CloudShadowRaySampleCountScale = 0x434 // float (Size: 0x4)
DirectionalLightComponent.CloudScatteredLuminanceScale = 0x438 // FLinearColor (Size: 0x10)
DirectionalLightComponent.LightmassSettings = 0x448 // FLightmassDirectionalLightSettings (Size: 0x10)
DirectionalLightComponent.bCastModulatedShadows = 0x458 // uint8_t (Size: 0x1)
DirectionalLightComponent.ModulatedShadowColor = 0x45c // FColor (Size: 0x4)
DirectionalLightComponent.ShadowAmount = 0x460 // float (Size: 0x4)
DirectionalLightComponent.bEnableCSMCache = 0x464 // uint8_t (Size: 0x1)
DirectionalLightComponent.bEnableLobbyMode = 0x464 // uint8_t (Size: 0x1)
DirectionalLightComponent.LobbyModeCenter = 0x468 // FVector (Size: 0xc)
DirectionalLightComponent.LobbyModeRadius = 0x474 // float (Size: 0x4)
DirectorTrackCut.Time = 0x0 // float (Size: 0x4)
DirectorTrackCut.TransitionTime = 0x4 // float (Size: 0x4)
DirectorTrackCut.TargetCamGroup = 0x8 // FName (Size: 0x8)
DirectorTrackCut.ShotNumber = 0x10 // int32_t (Size: 0x4)
DirectoryPath.Path = 0x0 // FString (Size: 0x10)
DistanceDatum.FadeInDistanceStart = 0x0 // float (Size: 0x4)
DistanceDatum.FadeInDistanceEnd = 0x4 // float (Size: 0x4)
DistanceDatum.FadeOutDistanceStart = 0x8 // float (Size: 0x4)
DistanceDatum.FadeOutDistanceEnd = 0xc // float (Size: 0x4)
DistanceDatum.Volume = 0x10 // float (Size: 0x4)
DistributionFloat.bCanBeBaked = 0x30 // uint8_t (Size: 0x1)
DistributionFloat.bBakedDataSuccesfully = 0x30 // uint8_t (Size: 0x1)
DistributionFloatConstant.Constant = 0x38 // float (Size: 0x4)
DistributionFloatConstantCurve.ConstantCurve = 0x38 // FInterpCurveFloat (Size: 0x18)
DistributionFloatParameterBase.ParameterName = 0x40 // FName (Size: 0x8)
DistributionFloatParameterBase.MinInput = 0x48 // float (Size: 0x4)
DistributionFloatParameterBase.MaxInput = 0x4c // float (Size: 0x4)
DistributionFloatParameterBase.MinOutput = 0x50 // float (Size: 0x4)
DistributionFloatParameterBase.MaxOutput = 0x54 // float (Size: 0x4)
DistributionFloatParameterBase.ParamMode = 0x58 // uint8_t (Size: 0x1)
DistributionFloatUniform.Min = 0x38 // float (Size: 0x4)
DistributionFloatUniform.Max = 0x3c // float (Size: 0x4)
DistributionFloatUniformCurve.ConstantCurve = 0x38 // FInterpCurveVector2D (Size: 0x18)
DistributionLookupTable.TimeScale = 0x0 // float (Size: 0x4)
DistributionLookupTable.TimeBias = 0x4 // float (Size: 0x4)
DistributionLookupTable.Values = 0x8 // TArray<float> (Size: 0x10)
DistributionLookupTable.Op = 0x18 // uint8_t (Size: 0x1)
DistributionLookupTable.EntryCount = 0x19 // uint8_t (Size: 0x1)
DistributionLookupTable.EntryStride = 0x1a // uint8_t (Size: 0x1)
DistributionLookupTable.SubEntryStride = 0x1b // uint8_t (Size: 0x1)
DistributionLookupTable.LockFlag = 0x1c // uint8_t (Size: 0x1)
DistributionVector.bCanBeBaked = 0x30 // uint8_t (Size: 0x1)
DistributionVector.bIsDirty = 0x30 // uint8_t (Size: 0x1)
DistributionVector.bBakedDataSuccesfully = 0x30 // uint8_t (Size: 0x1)
DistributionVectorConstant.Constant = 0x38 // FVector (Size: 0xc)
DistributionVectorConstant.bLockAxes = 0x44 // uint8_t (Size: 0x1)
DistributionVectorConstant.LockedAxes = 0x48 // uint8_t (Size: 0x1)
DistributionVectorConstantCurve.ConstantCurve = 0x38 // FInterpCurveVector (Size: 0x18)
DistributionVectorConstantCurve.bLockAxes = 0x50 // uint8_t (Size: 0x1)
DistributionVectorConstantCurve.LockedAxes = 0x54 // uint8_t (Size: 0x1)
DistributionVectorParameterBase.ParameterName = 0x50 // FName (Size: 0x8)
DistributionVectorParameterBase.MinInput = 0x58 // FVector (Size: 0xc)
DistributionVectorParameterBase.MaxInput = 0x64 // FVector (Size: 0xc)
DistributionVectorParameterBase.MinOutput = 0x70 // FVector (Size: 0xc)
DistributionVectorParameterBase.MaxOutput = 0x7c // FVector (Size: 0xc)
DistributionVectorParameterBase.ParamModes = 0x88 // uint8_t (Size: 0x1)
DistributionVectorUniform.Max = 0x38 // FVector (Size: 0xc)
DistributionVectorUniform.Min = 0x44 // FVector (Size: 0xc)
DistributionVectorUniform.bLockAxes = 0x50 // uint8_t (Size: 0x1)
DistributionVectorUniform.LockedAxes = 0x54 // uint8_t (Size: 0x1)
DistributionVectorUniform.MirrorFlags = 0x55 // uint8_t (Size: 0x1)
DistributionVectorUniform.bUseExtremes = 0x58 // uint8_t (Size: 0x1)
DistributionVectorUniformCurve.ConstantCurve = 0x38 // FInterpCurveTwoVectors (Size: 0x18)
DistributionVectorUniformCurve.bLockAxes1 = 0x50 // uint8_t (Size: 0x1)
DistributionVectorUniformCurve.bLockAxes2 = 0x50 // uint8_t (Size: 0x1)
DistributionVectorUniformCurve.LockedAxes = 0x54 // uint8_t (Size: 0x1)
DistributionVectorUniformCurve.MirrorFlags = 0x56 // uint8_t (Size: 0x1)
DistributionVectorUniformCurve.bUseExtremes = 0x5c // uint8_t (Size: 0x1)
DrawFrustumComponent.FrustumColor = 0x5c8 // FColor (Size: 0x4)
DrawFrustumComponent.FrustumAngle = 0x5cc // float (Size: 0x4)
DrawFrustumComponent.FrustumAspectRatio = 0x5d0 // float (Size: 0x4)
DrawFrustumComponent.FrustumStartDist = 0x5d4 // float (Size: 0x4)
DrawFrustumComponent.FrustumEndDist = 0x5d8 // float (Size: 0x4)
DrawFrustumComponent.Texture = 0x5e0 // Texture* (Size: 0x8)
DrawToRenderTargetContext.RenderTarget = 0x0 // TextureRenderTarget2D* (Size: 0x8)
DropNoteInfo.Location = 0x0 // FVector (Size: 0xc)
DropNoteInfo.Rotation = 0xc // FRotator (Size: 0xc)
DropNoteInfo.Comment = 0x18 // FString (Size: 0x10)
DynamicTextureInstance.Texture = 0x28 // Texture2D* (Size: 0x8)
DynamicTextureInstance.bAttached = 0x30 // bool (Size: 0x1)
DynamicTextureInstance.OriginalRadius = 0x34 // float (Size: 0x4)
EdGraph.Schema = 0x28 // ClassProperty (Size: 0x8)
EdGraph.Nodes = 0x30 // TArray<EdGraphNode*> (Size: 0x10)
EdGraph.bEditable = 0x40 // uint8_t (Size: 0x1)
EdGraph.bAllowDeletion = 0x40 // uint8_t (Size: 0x1)
EdGraph.bAllowRenaming = 0x40 // uint8_t (Size: 0x1)
EdGraphNode.DeprecatedPins = 0x38 // TArray<EdGraphPin_Deprecated*> (Size: 0x10)
EdGraphNode.NodePosX = 0x48 // int32_t (Size: 0x4)
EdGraphNode.NodePosY = 0x4c // int32_t (Size: 0x4)
EdGraphNode.NodeWidth = 0x50 // int32_t (Size: 0x4)
EdGraphNode.NodeHeight = 0x54 // int32_t (Size: 0x4)
EdGraphNode.AdvancedPinDisplay = 0x58 // uint8_t (Size: 0x1)
EdGraphNode.EnabledState = 0x59 // EENodeEnabledState (Size: 0x1)
EdGraphNode.bDisplayAsDisabled = 0x5b // uint8_t (Size: 0x1)
EdGraphNode.bUserSetEnabledState = 0x5b // uint8_t (Size: 0x1)
EdGraphNode.bIsNodeEnabled = 0x5b // uint8_t (Size: 0x1)
EdGraphNode.bHasCompilerMessage = 0x5b // uint8_t (Size: 0x1)
EdGraphNode.NodeComment = 0x60 // FString (Size: 0x10)
EdGraphNode.ErrorType = 0x70 // int32_t (Size: 0x4)
EdGraphNode.ErrorMsg = 0x78 // FString (Size: 0x10)
EdGraphNode.NodeGuid = 0x88 // FGuid (Size: 0x10)
EdGraphNode_Documentation.Link = 0x98 // FString (Size: 0x10)
EdGraphNode_Documentation.Excerpt = 0xa8 // FString (Size: 0x10)
EdGraphPinReference.OwningNode = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
EdGraphPinReference.PinId = 0x8 // FGuid (Size: 0x10)
EdGraphPinType.PinCategory = 0x0 // FName (Size: 0x8)
EdGraphPinType.PinSubCategory = 0x8 // FName (Size: 0x8)
EdGraphPinType.PinSubCategoryObject = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
EdGraphPinType.PinSubCategoryMemberReference = 0x18 // FSimpleMemberReference (Size: 0x20)
EdGraphPinType.PinValueType = 0x38 // FEdGraphTerminalType (Size: 0x1c)
EdGraphPinType.ContainerType = 0x54 // EEPinContainerType (Size: 0x1)
EdGraphPinType.bIsArray = 0x55 // uint8_t (Size: 0x1)
EdGraphPinType.bIsReference = 0x55 // uint8_t (Size: 0x1)
EdGraphPinType.bIsConst = 0x55 // uint8_t (Size: 0x1)
EdGraphPinType.bIsWeakPointer = 0x55 // uint8_t (Size: 0x1)
EdGraphPinType.bIsUObjectWrapper = 0x55 // uint8_t (Size: 0x1)
EdGraphPin_Deprecated.PinName = 0x28 // FString (Size: 0x10)
EdGraphPin_Deprecated.PinToolTip = 0x38 // FString (Size: 0x10)
EdGraphPin_Deprecated.Direction = 0x48 // uint8_t (Size: 0x1)
EdGraphPin_Deprecated.PinType = 0x50 // FEdGraphPinType (Size: 0x58)
EdGraphPin_Deprecated.DefaultValue = 0xa8 // FString (Size: 0x10)
EdGraphPin_Deprecated.AutogeneratedDefaultValue = 0xb8 // FString (Size: 0x10)
EdGraphPin_Deprecated.DefaultObject = 0xc8 // Object* (Size: 0x8)
EdGraphPin_Deprecated.DefaultTextValue = 0xd0 // FText (Size: 0x18)
EdGraphPin_Deprecated.LinkedTo = 0xe8 // TArray<EdGraphPin_Deprecated*> (Size: 0x10)
EdGraphPin_Deprecated.SubPins = 0xf8 // TArray<EdGraphPin_Deprecated*> (Size: 0x10)
EdGraphPin_Deprecated.ParentPin = 0x108 // EdGraphPin_Deprecated* (Size: 0x8)
EdGraphPin_Deprecated.ReferencePassThroughConnection = 0x110 // EdGraphPin_Deprecated* (Size: 0x8)
EdGraphSchemaAction.MenuDescription = 0x8 // FText (Size: 0x18)
EdGraphSchemaAction.TooltipDescription = 0x20 // FText (Size: 0x18)
EdGraphSchemaAction.Category = 0x38 // FText (Size: 0x18)
EdGraphSchemaAction.Keywords = 0x50 // FText (Size: 0x18)
EdGraphSchemaAction.Grouping = 0x68 // int32_t (Size: 0x4)
EdGraphSchemaAction.SectionID = 0x6c // int32_t (Size: 0x4)
EdGraphSchemaAction.MenuDescriptionArray = 0x70 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.FullSearchTitlesArray = 0x80 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.FullSearchKeywordsArray = 0x90 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.FullSearchCategoryArray = 0xa0 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.LocalizedMenuDescriptionArray = 0xb0 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.LocalizedFullSearchTitlesArray = 0xc0 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.LocalizedFullSearchKeywordsArray = 0xd0 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.LocalizedFullSearchCategoryArray = 0xe0 // TArray<FString> (Size: 0x10)
EdGraphSchemaAction.SearchText = 0xf0 // FString (Size: 0x10)
EdGraphSchemaAction_NewNode.NodeTemplate = 0x100 // EdGraphNode* (Size: 0x8)
EdGraphTerminalType.TerminalCategory = 0x0 // FName (Size: 0x8)
EdGraphTerminalType.TerminalSubCategory = 0x8 // FName (Size: 0x8)
EdGraphTerminalType.TerminalSubCategoryObject = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
EdGraphTerminalType.bTerminalIsConst = 0x18 // bool (Size: 0x1)
EdGraphTerminalType.bTerminalIsWeakPointer = 0x19 // bool (Size: 0x1)
EdGraphTerminalType.bTerminalIsUObjectWrapper = 0x1a // bool (Size: 0x1)
EditedDocumentInfo.EditedObjectPath = 0x0 // FSoftObjectPath (Size: 0x18)
EditedDocumentInfo.SavedViewOffset = 0x18 // FVector2D (Size: 0x8)
EditedDocumentInfo.SavedZoomAmount = 0x20 // float (Size: 0x4)
EditedDocumentInfo.EditedObject = 0x28 // Object* (Size: 0x8)
EditorElement.Indices = 0x0 // int32_t (Size: 0x4)
EditorElement.Weights = 0xc // float (Size: 0x4)
EditorImportExportTestDefinition.ImportFilePath = 0x0 // FFilePath (Size: 0x10)
EditorImportExportTestDefinition.ExportFileExtension = 0x10 // FString (Size: 0x10)
EditorImportExportTestDefinition.bSkipExport = 0x20 // bool (Size: 0x1)
EditorImportExportTestDefinition.FactorySettings = 0x28 // TArray<FImportFactorySettingValues> (Size: 0x10)
EditorImportWorkflowDefinition.ImportFilePath = 0x0 // FFilePath (Size: 0x10)
EditorImportWorkflowDefinition.FactorySettings = 0x10 // TArray<FImportFactorySettingValues> (Size: 0x10)
EditorMapPerformanceTestDefinition.PerformanceTestmap = 0x0 // FSoftObjectPath (Size: 0x18)
EditorMapPerformanceTestDefinition.TestTimer = 0x18 // int32_t (Size: 0x4)
Emitter.ParticleSystemComponent = 0x310 // ParticleSystemComponent* (Size: 0x8)
Emitter.bDestroyOnSystemFinish = 0x318 // uint8_t (Size: 0x1)
Emitter.bPostUpdateTickGroup = 0x318 // uint8_t (Size: 0x1)
Emitter.bCurrentlyActive = 0x318 // uint8_t (Size: 0x1)
Emitter.OnParticleSpawn = 0x320 // FMulticastInlineDelegate (Size: 0x10)
Emitter.OnParticleBurst = 0x330 // FMulticastInlineDelegate (Size: 0x10)
Emitter.OnParticleDeath = 0x340 // FMulticastInlineDelegate (Size: 0x10)
Emitter.OnParticleCollide = 0x350 // FMulticastInlineDelegate (Size: 0x10)
EmitterCameraLensEffectBase.PS_CameraEffect = 0x360 // ParticleSystem* (Size: 0x8)
EmitterCameraLensEffectBase.PS_CameraEffectNonExtremeContent = 0x368 // ParticleSystem* (Size: 0x8)
EmitterCameraLensEffectBase.BaseCamera = 0x370 // PlayerCameraManager* (Size: 0x8)
EmitterCameraLensEffectBase.RelativeTransform = 0x380 // FTransform (Size: 0x30)
EmitterCameraLensEffectBase.BaseFov = 0x3b0 // float (Size: 0x4)
EmitterCameraLensEffectBase.bAllowMultipleInstances = 0x3b4 // uint8_t (Size: 0x1)
EmitterCameraLensEffectBase.bResetWhenRetriggered = 0x3b4 // uint8_t (Size: 0x1)
EmitterCameraLensEffectBase.EmittersToTreatAsSame = 0x3b8 // TArray<ClassProperty> (Size: 0x10)
EmitterCameraLensEffectBase.DistFromCamera = 0x3c8 // float (Size: 0x4)
EmitterDynamicParameter.ParamName = 0x0 // FName (Size: 0x8)
EmitterDynamicParameter.bUseEmitterTime = 0x8 // uint8_t (Size: 0x1)
EmitterDynamicParameter.bSpawnTimeOnly = 0x8 // uint8_t (Size: 0x1)
EmitterDynamicParameter.ValueMethod = 0xc // uint8_t (Size: 0x1)
EmitterDynamicParameter.bScaleVelocityByParamValue = 0x10 // uint8_t (Size: 0x1)
EmitterDynamicParameter.ParamValue = 0x18 // FRawDistributionFloat (Size: 0x30)
EndpointSubmix.EndpointType = 0x38 // FName (Size: 0x8)
EndpointSubmix.EndpointSettingsClass = 0x40 // ClassProperty (Size: 0x8)
EndpointSubmix.EndpointSettings = 0x48 // AudioEndpointSettingsBase* (Size: 0x8)
Engine.TinyFont = 0x30 // Font* (Size: 0x8)
Engine.TinyFontName = 0x38 // FSoftObjectPath (Size: 0x18)
Engine.SmallFont = 0x50 // Font* (Size: 0x8)
Engine.StatSmallFont = 0x58 // Font* (Size: 0x8)
Engine.SmallFontName = 0x60 // FSoftObjectPath (Size: 0x18)
Engine.MediumFont = 0x78 // Font* (Size: 0x8)
Engine.MediumFontName = 0x80 // FSoftObjectPath (Size: 0x18)
Engine.LargeFont = 0x98 // Font* (Size: 0x8)
Engine.LargeFontName = 0xa0 // FSoftObjectPath (Size: 0x18)
Engine.SubtitleFont = 0xb8 // Font* (Size: 0x8)
Engine.SubtitleFontName = 0xc0 // FSoftObjectPath (Size: 0x18)
Engine.AdditionalFonts = 0xd8 // TArray<Font*> (Size: 0x10)
Engine.AdditionalFontNames = 0xe8 // TArray<FString> (Size: 0x10)
Engine.ConsoleClass = 0xf8 // ClassProperty (Size: 0x8)
Engine.ConsoleClassName = 0x100 // FSoftClassPath (Size: 0x18)
Engine.GameViewportClientClass = 0x118 // ClassProperty (Size: 0x8)
Engine.GameViewportClientClassName = 0x120 // FSoftClassPath (Size: 0x18)
Engine.LocalPlayerClass = 0x138 // ClassProperty (Size: 0x8)
Engine.LocalPlayerClassName = 0x140 // FSoftClassPath (Size: 0x18)
Engine.WorldSettingsClass = 0x158 // ClassProperty (Size: 0x8)
Engine.WorldSettingsClassName = 0x160 // FSoftClassPath (Size: 0x18)
Engine.NavigationSystemClassName = 0x178 // FSoftClassPath (Size: 0x18)
Engine.NavigationSystemClass = 0x190 // ClassProperty (Size: 0x8)
Engine.NavigationSystemConfigClassName = 0x198 // FSoftClassPath (Size: 0x18)
Engine.NavigationSystemConfigClass = 0x1b0 // ClassProperty (Size: 0x8)
Engine.AvoidanceManagerClassName = 0x1b8 // FSoftClassPath (Size: 0x18)
Engine.AvoidanceManagerClass = 0x1d0 // ClassProperty (Size: 0x8)
Engine.AIControllerClassName = 0x1d8 // FSoftClassPath (Size: 0x18)
Engine.PhysicsCollisionHandlerClass = 0x1f0 // ClassProperty (Size: 0x8)
Engine.PhysicsCollisionHandlerClassName = 0x1f8 // FSoftClassPath (Size: 0x18)
Engine.GameUserSettingsClassName = 0x210 // FSoftClassPath (Size: 0x18)
Engine.GameUserSettingsClass = 0x228 // ClassProperty (Size: 0x8)
Engine.GameUserSettings = 0x230 // GameUserSettings* (Size: 0x8)
Engine.LevelScriptActorClass = 0x238 // ClassProperty (Size: 0x8)
Engine.LevelScriptActorClassName = 0x240 // FSoftClassPath (Size: 0x18)
Engine.DefaultBlueprintBaseClassName = 0x258 // FSoftClassPath (Size: 0x18)
Engine.GameSingletonClassName = 0x270 // FSoftClassPath (Size: 0x18)
Engine.GameSingleton = 0x288 // Object* (Size: 0x8)
Engine.AssetManagerClassName = 0x290 // FSoftClassPath (Size: 0x18)
Engine.AssetManager = 0x2a8 // AssetManager* (Size: 0x8)
Engine.DefaultTexture = 0x2b0 // Texture2D* (Size: 0x8)
Engine.DefaultTextureName = 0x2b8 // FSoftObjectPath (Size: 0x18)
Engine.DefaultDiffuseTexture = 0x2d0 // Texture* (Size: 0x8)
Engine.DefaultDiffuseTextureName = 0x2d8 // FSoftObjectPath (Size: 0x18)
Engine.DefaultBSPVertexTexture = 0x2f0 // Texture2D* (Size: 0x8)
Engine.DefaultBSPVertexTextureName = 0x2f8 // FSoftObjectPath (Size: 0x18)
Engine.HighFrequencyNoiseTexture = 0x310 // Texture2D* (Size: 0x8)
Engine.HighFrequencyNoiseTextureName = 0x318 // FSoftObjectPath (Size: 0x18)
Engine.DefaultBokehTexture = 0x330 // Texture2D* (Size: 0x8)
Engine.DefaultBokehTextureName = 0x338 // FSoftObjectPath (Size: 0x18)
Engine.DefaultBloomKernelTexture = 0x350 // Texture2D* (Size: 0x8)
Engine.DefaultBloomKernelTextureName = 0x358 // FSoftObjectPath (Size: 0x18)
Engine.WireframeMaterial = 0x370 // Material* (Size: 0x8)
Engine.WireframeMaterialName = 0x378 // FString (Size: 0x10)
Engine.DebugMeshMaterial = 0x388 // Material* (Size: 0x8)
Engine.DebugMeshMaterialName = 0x390 // FSoftObjectPath (Size: 0x18)
Engine.EmissiveMeshMaterial = 0x3a8 // Material* (Size: 0x8)
Engine.EmissiveMeshMaterialName = 0x3b0 // FSoftObjectPath (Size: 0x18)
Engine.LevelColorationLitMaterial = 0x3c8 // Material* (Size: 0x8)
Engine.LevelColorationLitMaterialName = 0x3d0 // FString (Size: 0x10)
Engine.LevelColorationUnlitMaterial = 0x3e0 // Material* (Size: 0x8)
Engine.LevelColorationUnlitMaterialName = 0x3e8 // FString (Size: 0x10)
Engine.LightingTexelDensityMaterial = 0x3f8 // Material* (Size: 0x8)
Engine.LightingTexelDensityName = 0x400 // FString (Size: 0x10)
Engine.ShadedLevelColorationLitMaterial = 0x410 // Material* (Size: 0x8)
Engine.ShadedLevelColorationLitMaterialName = 0x418 // FString (Size: 0x10)
Engine.ShadedLevelColorationUnlitMaterial = 0x428 // Material* (Size: 0x8)
Engine.ShadedLevelColorationUnlitMaterialName = 0x430 // FString (Size: 0x10)
Engine.RemoveSurfaceMaterial = 0x440 // Material* (Size: 0x8)
Engine.RemoveSurfaceMaterialName = 0x448 // FSoftObjectPath (Size: 0x18)
Engine.VertexColorMaterial = 0x460 // Material* (Size: 0x8)
Engine.VertexColorMaterialName = 0x468 // FString (Size: 0x10)
Engine.VertexColorViewModeMaterial_ColorOnly = 0x478 // Material* (Size: 0x8)
Engine.VertexColorViewModeMaterialName_ColorOnly = 0x480 // FString (Size: 0x10)
Engine.VertexColorViewModeMaterial_AlphaAsColor = 0x490 // Material* (Size: 0x8)
Engine.VertexColorViewModeMaterialName_AlphaAsColor = 0x498 // FString (Size: 0x10)
Engine.VertexColorViewModeMaterial_RedOnly = 0x4a8 // Material* (Size: 0x8)
Engine.VertexColorViewModeMaterialName_RedOnly = 0x4b0 // FString (Size: 0x10)
Engine.VertexColorViewModeMaterial_GreenOnly = 0x4c0 // Material* (Size: 0x8)
Engine.VertexColorViewModeMaterialName_GreenOnly = 0x4c8 // FString (Size: 0x10)
Engine.VertexColorViewModeMaterial_BlueOnly = 0x4d8 // Material* (Size: 0x8)
Engine.VertexColorViewModeMaterialName_BlueOnly = 0x4e0 // FString (Size: 0x10)
Engine.DebugEditorMaterialName = 0x4f0 // FSoftObjectPath (Size: 0x18)
Engine.ConstraintLimitMaterial = 0x508 // Material* (Size: 0x8)
Engine.ConstraintLimitMaterialX = 0x510 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialXAxis = 0x518 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialY = 0x520 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialYAxis = 0x528 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialZ = 0x530 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialZAxis = 0x538 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ConstraintLimitMaterialPrismatic = 0x540 // MaterialInstanceDynamic* (Size: 0x8)
Engine.InvalidLightmapSettingsMaterial = 0x548 // Material* (Size: 0x8)
Engine.InvalidLightmapSettingsMaterialName = 0x550 // FSoftObjectPath (Size: 0x18)
Engine.PreviewShadowsIndicatorMaterial = 0x568 // Material* (Size: 0x8)
Engine.PreviewShadowsIndicatorMaterialName = 0x570 // FSoftObjectPath (Size: 0x18)
Engine.ArrowMaterial = 0x588 // Material* (Size: 0x8)
Engine.ArrowMaterialYellow = 0x590 // MaterialInstanceDynamic* (Size: 0x8)
Engine.ArrowMaterialName = 0x598 // FSoftObjectPath (Size: 0x18)
Engine.LightingOnlyBrightness = 0x5b0 // FLinearColor (Size: 0x10)
Engine.ShaderComplexityColors = 0x5c0 // TArray<FLinearColor> (Size: 0x10)
Engine.QuadComplexityColors = 0x5d0 // TArray<FLinearColor> (Size: 0x10)
Engine.LightComplexityColors = 0x5e0 // TArray<FLinearColor> (Size: 0x10)
Engine.StationaryLightOverlapColors = 0x5f0 // TArray<FLinearColor> (Size: 0x10)
Engine.LODColorationColors = 0x600 // TArray<FLinearColor> (Size: 0x10)
Engine.HLODColorationColors = 0x610 // TArray<FLinearColor> (Size: 0x10)
Engine.StreamingAccuracyColors = 0x620 // TArray<FLinearColor> (Size: 0x10)
Engine.MaxPixelShaderAdditiveComplexityCount = 0x630 // float (Size: 0x4)
Engine.MaxES3PixelShaderAdditiveComplexityCount = 0x634 // float (Size: 0x4)
Engine.MinLightMapDensity = 0x638 // float (Size: 0x4)
Engine.IdealLightMapDensity = 0x63c // float (Size: 0x4)
Engine.MaxLightMapDensity = 0x640 // float (Size: 0x4)
Engine.bRenderLightMapDensityGrayscale = 0x644 // uint8_t (Size: 0x1)
Engine.RenderLightMapDensityGrayscaleScale = 0x648 // float (Size: 0x4)
Engine.RenderLightMapDensityColorScale = 0x64c // float (Size: 0x4)
Engine.LightMapDensityVertexMappedColor = 0x650 // FLinearColor (Size: 0x10)
Engine.LightMapDensitySelectedColor = 0x660 // FLinearColor (Size: 0x10)
Engine.StatColorMappings = 0x670 // TArray<FStatColorMapping> (Size: 0x10)
Engine.DefaultPhysMaterial = 0x680 // PhysicalMaterial* (Size: 0x8)
Engine.DefaultPhysMaterialName = 0x688 // FSoftObjectPath (Size: 0x18)
Engine.ActiveGameNameRedirects = 0x6a0 // TArray<FGameNameRedirect> (Size: 0x10)
Engine.ActiveClassRedirects = 0x6b0 // TArray<FClassRedirect> (Size: 0x10)
Engine.ActivePluginRedirects = 0x6c0 // TArray<FPluginRedirect> (Size: 0x10)
Engine.ActiveStructRedirects = 0x6d0 // TArray<FStructRedirect> (Size: 0x10)
Engine.PreIntegratedSkinBRDFTexture = 0x6e0 // Texture2D* (Size: 0x8)
Engine.PreIntegratedSkinBRDFTextureName = 0x6e8 // FSoftObjectPath (Size: 0x18)
Engine.BlueNoiseTexture = 0x700 // Texture2D* (Size: 0x8)
Engine.BlueNoiseTextureName = 0x708 // FSoftObjectPath (Size: 0x18)
Engine.MiniFontTexture = 0x720 // Texture2D* (Size: 0x8)
Engine.MiniFontTextureName = 0x728 // FSoftObjectPath (Size: 0x18)
Engine.WeightMapPlaceholderTexture = 0x740 // Texture* (Size: 0x8)
Engine.WeightMapPlaceholderTextureName = 0x748 // FSoftObjectPath (Size: 0x18)
Engine.LightMapDensityTexture = 0x760 // Texture2D* (Size: 0x8)
Engine.LightMapDensityTextureName = 0x768 // FSoftObjectPath (Size: 0x18)
Engine.GameViewport = 0x788 // GameViewportClient* (Size: 0x8)
Engine.DeferredCommands = 0x790 // TArray<FString> (Size: 0x10)
Engine.NearClipPlane = 0x7a0 // float (Size: 0x4)
Engine.bSubtitlesEnabled = 0x7a4 // uint8_t (Size: 0x1)
Engine.bSubtitlesForcedOff = 0x7a4 // uint8_t (Size: 0x1)
Engine.MaximumLoopIterationCount = 0x7a8 // int32_t (Size: 0x4)
Engine.bCanBlueprintsTickByDefault = 0x7ac // uint8_t (Size: 0x1)
Engine.bOptimizeAnimBlueprintMemberVariableAccess = 0x7ac // uint8_t (Size: 0x1)
Engine.bAllowMultiThreadedAnimationUpdate = 0x7ac // uint8_t (Size: 0x1)
Engine.bEnableEditorPSysRealtimeLOD = 0x7ac // uint8_t (Size: 0x1)
Engine.bSmoothFrameRate = 0x7ac // uint8_t (Size: 0x1)
Engine.bUseFixedFrameRate = 0x7ac // uint8_t (Size: 0x1)
Engine.FixedFrameRate = 0x7b0 // float (Size: 0x4)
Engine.SmoothedFrameRateRange = 0x7b4 // FFloatRange (Size: 0x10)
Engine.CustomTimeStep = 0x7c8 // EngineCustomTimeStep* (Size: 0x8)
Engine.CustomTimeStepClassName = 0x7f0 // FSoftClassPath (Size: 0x18)
Engine.TimecodeProvider = 0x808 // TimecodeProvider* (Size: 0x8)
Engine.TimecodeProviderClassName = 0x830 // FSoftClassPath (Size: 0x18)
Engine.bGenerateDefaultTimecode = 0x848 // bool (Size: 0x1)
Engine.GenerateDefaultTimecodeFrameRate = 0x84c // FFrameRate (Size: 0x8)
Engine.GenerateDefaultTimecodeFrameDelay = 0x854 // float (Size: 0x4)
Engine.bCheckForMultiplePawnsSpawnedInAFrame = 0x858 // uint8_t (Size: 0x1)
Engine.NumPawnsAllowedToBeSpawnedInAFrame = 0x85c // int32_t (Size: 0x4)
Engine.bShouldGenerateLowQualityLightmaps = 0x860 // uint8_t (Size: 0x1)
Engine.C_WorldBox = 0x864 // FColor (Size: 0x4)
Engine.C_BrushWire = 0x868 // FColor (Size: 0x4)
Engine.C_AddWire = 0x86c // FColor (Size: 0x4)
Engine.C_SubtractWire = 0x870 // FColor (Size: 0x4)
Engine.C_SemiSolidWire = 0x874 // FColor (Size: 0x4)
Engine.C_NonSolidWire = 0x878 // FColor (Size: 0x4)
Engine.C_WireBackground = 0x87c // FColor (Size: 0x4)
Engine.C_ScaleBoxHi = 0x880 // FColor (Size: 0x4)
Engine.C_VolumeCollision = 0x884 // FColor (Size: 0x4)
Engine.C_BSPCollision = 0x888 // FColor (Size: 0x4)
Engine.C_OrthoBackground = 0x88c // FColor (Size: 0x4)
Engine.C_Volume = 0x890 // FColor (Size: 0x4)
Engine.C_BrushShape = 0x894 // FColor (Size: 0x4)
Engine.StreamingDistanceFactor = 0x898 // float (Size: 0x4)
Engine.GameScreenshotSaveDirectory = 0x8a0 // FDirectoryPath (Size: 0x10)
Engine.TransitionType = 0x8b0 // EETransitionType (Size: 0x1)
Engine.TransitionDescription = 0x8b8 // FString (Size: 0x10)
Engine.TransitionGameMode = 0x8c8 // FString (Size: 0x10)
Engine.bAllowMatureLanguage = 0x8d8 // uint8_t (Size: 0x1)
Engine.CameraRotationThreshold = 0x8dc // float (Size: 0x4)
Engine.CameraTranslationThreshold = 0x8e0 // float (Size: 0x4)
Engine.PrimitiveProbablyVisibleTime = 0x8e4 // float (Size: 0x4)
Engine.MaxOcclusionPixelsFraction = 0x8e8 // float (Size: 0x4)
Engine.bPauseOnLossOfFocus = 0x8ec // uint8_t (Size: 0x1)
Engine.MaxParticleResize = 0x8f0 // int32_t (Size: 0x4)
Engine.MaxParticleResizeWarn = 0x8f4 // int32_t (Size: 0x4)
Engine.PendingDroppedNotes = 0x8f8 // TArray<FDropNoteInfo> (Size: 0x10)
Engine.NetClientTicksPerSecond = 0x908 // float (Size: 0x4)
Engine.DisplayGamma = 0x90c // float (Size: 0x4)
Engine.MinDesiredFrameRate = 0x910 // float (Size: 0x4)
Engine.DefaultSelectedMaterialColor = 0x914 // FLinearColor (Size: 0x10)
Engine.SelectedMaterialColor = 0x924 // FLinearColor (Size: 0x10)
Engine.SelectionOutlineColor = 0x934 // FLinearColor (Size: 0x10)
Engine.SubduedSelectionOutlineColor = 0x944 // FLinearColor (Size: 0x10)
Engine.SelectedMaterialColorOverride = 0x954 // FLinearColor (Size: 0x10)
Engine.bIsOverridingSelectedColor = 0x964 // bool (Size: 0x1)
Engine.bEnableOnScreenDebugMessages = 0x968 // uint8_t (Size: 0x1)
Engine.bEnableOnScreenDebugMessagesDisplay = 0x968 // uint8_t (Size: 0x1)
Engine.bSuppressMapWarnings = 0x968 // uint8_t (Size: 0x1)
Engine.bDisableAILogging = 0x968 // uint8_t (Size: 0x1)
Engine.bEnableVisualLogRecordingOnStart = 0x96c // uint32_t (Size: 0x4)
Engine.ScreenSaverInhibitorSemaphore = 0x970 // int32_t (Size: 0x4)
Engine.bLockReadOnlyLevels = 0x974 // uint8_t (Size: 0x1)
Engine.ParticleEventManagerClassPath = 0x978 // FString (Size: 0x10)
Engine.SelectionHighlightIntensity = 0x988 // float (Size: 0x4)
Engine.BSPSelectionHighlightIntensity = 0x98c // float (Size: 0x4)
Engine.SelectionHighlightIntensityBillboards = 0x990 // float (Size: 0x4)
Engine.NetDriverDefinitions = 0xc60 // TArray<FNetDriverDefinition> (Size: 0x10)
Engine.ServerActors = 0xc70 // TArray<FString> (Size: 0x10)
Engine.RuntimeServerActors = 0xc80 // TArray<FString> (Size: 0x10)
Engine.NetErrorLogInterval = 0xc90 // float (Size: 0x4)
Engine.bStartedLoadMapMovie = 0xc94 // uint8_t (Size: 0x1)
Engine.NextWorldContextHandle = 0xcb0 // int32_t (Size: 0x4)
EngineMessage.FailedPlaceMessage = 0x28 // FString (Size: 0x10)
EngineMessage.MaxedOutMessage = 0x38 // FString (Size: 0x10)
EngineMessage.EnteredMessage = 0x48 // FString (Size: 0x10)
EngineMessage.LeftMessage = 0x58 // FString (Size: 0x10)
EngineMessage.GlobalNameChange = 0x68 // FString (Size: 0x10)
EngineMessage.SpecEnteredMessage = 0x78 // FString (Size: 0x10)
EngineMessage.NewPlayerMessage = 0x88 // FString (Size: 0x10)
EngineMessage.NewSpecMessage = 0x98 // FString (Size: 0x10)
EngineShowFlagsSetting.ShowFlagName = 0x0 // FString (Size: 0x10)
EngineShowFlagsSetting.Enabled = 0x10 // bool (Size: 0x1)
EquirectProps.LeftUVRect = 0x0 // FBox2D (Size: 0x14)
EquirectProps.RightUVRect = 0x14 // FBox2D (Size: 0x14)
EquirectProps.LeftScale = 0x28 // FVector2D (Size: 0x8)
EquirectProps.RightScale = 0x30 // FVector2D (Size: 0x8)
EquirectProps.LeftBias = 0x38 // FVector2D (Size: 0x8)
EquirectProps.RightBias = 0x40 // FVector2D (Size: 0x8)
EventGraphFastCallPair.FunctionToPatch = 0x0 // Function* (Size: 0x8)
EventGraphFastCallPair.EventGraphCallOffset = 0x8 // int32_t (Size: 0x4)
EventTrackKey.Time = 0x0 // float (Size: 0x4)
EventTrackKey.EventName = 0x4 // FName (Size: 0x8)
ExponentialHeightFog.Component = 0x310 // ExponentialHeightFogComponent* (Size: 0x8)
ExponentialHeightFog.bEnabled = 0x318 // uint8_t (Size: 0x1)
ExponentialHeightFogComponent.FogDensity = 0x238 // float (Size: 0x4)
ExponentialHeightFogComponent.FogHeightFalloff = 0x23c // float (Size: 0x4)
ExponentialHeightFogComponent.SecondFogData = 0x240 // FExponentialHeightFogData (Size: 0xc)
ExponentialHeightFogComponent.FogInscatteringColor = 0x24c // FLinearColor (Size: 0x10)
ExponentialHeightFogComponent.InscatteringColorCubemap = 0x260 // TextureCube* (Size: 0x8)
ExponentialHeightFogComponent.InscatteringColorCubemapAngle = 0x268 // float (Size: 0x4)
ExponentialHeightFogComponent.InscatteringTextureTint = 0x26c // FLinearColor (Size: 0x10)
ExponentialHeightFogComponent.FullyDirectionalInscatteringColorDistance = 0x27c // float (Size: 0x4)
ExponentialHeightFogComponent.NonDirectionalInscatteringColorDistance = 0x280 // float (Size: 0x4)
ExponentialHeightFogComponent.DirectionalInscatteringExponent = 0x284 // float (Size: 0x4)
ExponentialHeightFogComponent.DirectionalInscatteringStartDistance = 0x288 // float (Size: 0x4)
ExponentialHeightFogComponent.DirectionalInscatteringColor = 0x28c // FLinearColor (Size: 0x10)
ExponentialHeightFogComponent.FogMaxOpacity = 0x29c // float (Size: 0x4)
ExponentialHeightFogComponent.StartDistance = 0x2a0 // float (Size: 0x4)
ExponentialHeightFogComponent.FogCutoffDistance = 0x2a4 // float (Size: 0x4)
ExponentialHeightFogComponent.LightAttenuation = 0x2a8 // float (Size: 0x4)
ExponentialHeightFogComponent.bEnableVolumetricFog = 0x2ac // bool (Size: 0x1)
ExponentialHeightFogComponent.VolumetricFogScatteringDistribution = 0x2b0 // float (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogAlbedo = 0x2b4 // FColor (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogEmissive = 0x2b8 // FLinearColor (Size: 0x10)
ExponentialHeightFogComponent.VolumetricFogExtinctionScale = 0x2c8 // float (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogExtinctionConvergeMultiplier = 0x2cc // float (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogExtinctionConvergeDistance = 0x2d0 // float (Size: 0x4)
ExponentialHeightFogComponent.bVolumetricFogUseExtinctionForInterior = 0x2d4 // bool (Size: 0x1)
ExponentialHeightFogComponent.VolumetricFogExtinctionForInterior = 0x2d8 // float (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogDistance = 0x2dc // float (Size: 0x4)
ExponentialHeightFogComponent.VolumetricFogStaticLightingScatteringIntensity = 0x2e0 // float (Size: 0x4)
ExponentialHeightFogComponent.bOverrideLightColorsWithFogInscatteringColors = 0x2e4 // bool (Size: 0x1)
ExponentialHeightFogData.FogDensity = 0x0 // float (Size: 0x4)
ExponentialHeightFogData.FogHeightFalloff = 0x4 // float (Size: 0x4)
ExponentialHeightFogData.FogHeightOffset = 0x8 // float (Size: 0x4)
Exporter.SupportedClass = 0x28 // ClassProperty (Size: 0x8)
Exporter.ExportRootScope = 0x30 // Object* (Size: 0x8)
Exporter.FormatExtension = 0x38 // TArray<FString> (Size: 0x10)
Exporter.FormatDescription = 0x48 // TArray<FString> (Size: 0x10)
Exporter.PreferredFormatIndex = 0x58 // int32_t (Size: 0x4)
Exporter.TextIndent = 0x5c // int32_t (Size: 0x4)
Exporter.bText = 0x60 // uint8_t (Size: 0x1)
Exporter.bSelectedOnly = 0x60 // uint8_t (Size: 0x1)
Exporter.bForceFileOperations = 0x60 // uint8_t (Size: 0x1)
Exporter.ExportTask = 0x68 // AssetExportTask* (Size: 0x8)
ExposedValueCopyRecord.CopyIndex = 0x0 // int32_t (Size: 0x4)
ExposedValueCopyRecord.PostCopyOperation = 0x4 // EEPostCopyOperation (Size: 0x1)
ExposedValueHandler.BoundFunction = 0x0 // FName (Size: 0x8)
ExposedValueHandler.CopyRecords = 0x8 // TArray<FExposedValueCopyRecord> (Size: 0x10)
ExposedValueHandler.Function = 0x18 // Function* (Size: 0x8)
ExposedValueHandler.ValueHandlerNodeProperty = 0x20 // FieldPathProperty (Size: 0x20)
ExposureSettings.FixedEV100 = 0x0 // float (Size: 0x4)
ExposureSettings.bFixed = 0x4 // bool (Size: 0x1)
ExpressionInput.OutputIndex = 0x0 // int32_t (Size: 0x4)
ExpressionInput.ExpressionName = 0x4 // FName (Size: 0x8)
ExpressionOutput.OutputName = 0x0 // FName (Size: 0x8)
ExternalToolDefinition.ToolName = 0x0 // FString (Size: 0x10)
ExternalToolDefinition.ExecutablePath = 0x10 // FFilePath (Size: 0x10)
ExternalToolDefinition.CommandLineOptions = 0x20 // FString (Size: 0x10)
ExternalToolDefinition.WorkingDirectory = 0x30 // FDirectoryPath (Size: 0x10)
ExternalToolDefinition.ScriptExtension = 0x40 // FString (Size: 0x10)
ExternalToolDefinition.ScriptDirectory = 0x50 // FDirectoryPath (Size: 0x10)
FOscillator.Amplitude = 0x0 // float (Size: 0x4)
FOscillator.Frequency = 0x4 // float (Size: 0x4)
FOscillator.InitialOffset = 0x8 // uint8_t (Size: 0x1)
FOscillator.Waveform = 0x9 // EEOscillatorWaveform (Size: 0x1)
FXSystemAsset.MaxPoolSize = 0x28 // uint32_t (Size: 0x4)
FXSystemAsset.PoolPrimeSize = 0x2c // uint32_t (Size: 0x4)
FastArraySerializer.ArrayReplicationKey = 0x5c // int32_t (Size: 0x4)
FastArraySerializer.DeltaFlags = 0x108 // EEFastArraySerializerDeltaFlags (Size: 0x1)
FastArraySerializerItem.ReplicationID = 0x0 // int32_t (Size: 0x4)
FastArraySerializerItem.ReplicationKey = 0x4 // int32_t (Size: 0x4)
FastArraySerializerItem.MostRecentArrayReplicationKey = 0x8 // int32_t (Size: 0x4)
FilePath.FilePath = 0x0 // FString (Size: 0x10)
FilmStockSettings.Slope = 0x0 // float (Size: 0x4)
FilmStockSettings.Toe = 0x4 // float (Size: 0x4)
FilmStockSettings.Shoulder = 0x8 // float (Size: 0x4)
FilmStockSettings.BlackClip = 0xc // float (Size: 0x4)
FilmStockSettings.WhiteClip = 0x10 // float (Size: 0x4)
FindFloorResult.bBlockingHit = 0x0 // uint8_t (Size: 0x1)
FindFloorResult.bWalkableFloor = 0x0 // uint8_t (Size: 0x1)
FindFloorResult.bLineTrace = 0x0 // uint8_t (Size: 0x1)
FindFloorResult.FloorDist = 0x4 // float (Size: 0x4)
FindFloorResult.LineDist = 0x8 // float (Size: 0x4)
FindFloorResult.HitResult = 0x10 // FHitResult (Size: 0x98)
FloatCurve.FloatCurve = 0x18 // FRichCurve (Size: 0x80)
FloatDistribution.Table = 0x0 // FDistributionLookupTable (Size: 0x20)
FloatRK4SpringInterpolator.StiffnessConstant = 0x0 // float (Size: 0x4)
FloatRK4SpringInterpolator.DampeningRatio = 0x4 // float (Size: 0x4)
FloatingPawnMovement.MaxSpeed = 0x180 // float (Size: 0x4)
FloatingPawnMovement.Acceleration = 0x184 // float (Size: 0x4)
FloatingPawnMovement.Deceleration = 0x188 // float (Size: 0x4)
FloatingPawnMovement.TurningBoost = 0x18c // float (Size: 0x4)
FloatingPawnMovement.bPositionCorrected = 0x190 // uint8_t (Size: 0x1)
Font.FontCacheType = 0x30 // EEFontCacheType (Size: 0x1)
Font.Characters = 0x38 // TArray<FFontCharacter> (Size: 0x10)
Font.Textures = 0x48 // TArray<Texture2D*> (Size: 0x10)
Font.IsRemapped = 0x58 // int32_t (Size: 0x4)
Font.EmScale = 0x5c // float (Size: 0x4)
Font.Ascent = 0x60 // float (Size: 0x4)
Font.Descent = 0x64 // float (Size: 0x4)
Font.Leading = 0x68 // float (Size: 0x4)
Font.Kerning = 0x6c // int32_t (Size: 0x4)
Font.ImportOptions = 0x70 // FFontImportOptionsData (Size: 0xb0)
Font.NumCharacters = 0x120 // int32_t (Size: 0x4)
Font.MaxCharHeight = 0x128 // TArray<int32_t> (Size: 0x10)
Font.ScalingFactor = 0x138 // float (Size: 0x4)
Font.LegacyFontSize = 0x13c // int32_t (Size: 0x4)
Font.LegacyFontName = 0x140 // FName (Size: 0x8)
Font.CompositeFont = 0x148 // FCompositeFont (Size: 0x38)
FontCharacter.StartU = 0x0 // int32_t (Size: 0x4)
FontCharacter.StartV = 0x4 // int32_t (Size: 0x4)
FontCharacter.USize = 0x8 // int32_t (Size: 0x4)
FontCharacter.VSize = 0xc // int32_t (Size: 0x4)
FontCharacter.TextureIndex = 0x10 // uint8_t (Size: 0x1)
FontCharacter.VerticalOffset = 0x14 // int32_t (Size: 0x4)
FontFace.SourceFilename = 0x30 // FString (Size: 0x10)
FontFace.Hinting = 0x40 // EEFontHinting (Size: 0x1)
FontFace.LoadingPolicy = 0x41 // EEFontLoadingPolicy (Size: 0x1)
FontFace.LayoutMethod = 0x42 // EEFontLayoutMethod (Size: 0x1)
FontImportOptions.Data = 0x28 // FFontImportOptionsData (Size: 0xb0)
FontImportOptionsData.FontName = 0x0 // FString (Size: 0x10)
FontImportOptionsData.Height = 0x10 // float (Size: 0x4)
FontImportOptionsData.bEnableAntialiasing = 0x14 // uint8_t (Size: 0x1)
FontImportOptionsData.bEnableBold = 0x14 // uint8_t (Size: 0x1)
FontImportOptionsData.bEnableItalic = 0x14 // uint8_t (Size: 0x1)
FontImportOptionsData.bEnableUnderline = 0x14 // uint8_t (Size: 0x1)
FontImportOptionsData.bAlphaOnly = 0x14 // uint8_t (Size: 0x1)
FontImportOptionsData.CharacterSet = 0x18 // uint8_t (Size: 0x1)
FontImportOptionsData.Chars = 0x20 // FString (Size: 0x10)
FontImportOptionsData.UnicodeRange = 0x30 // FString (Size: 0x10)
FontImportOptionsData.CharsFilePath = 0x40 // FString (Size: 0x10)
FontImportOptionsData.CharsFileWildcard = 0x50 // FString (Size: 0x10)
FontImportOptionsData.bCreatePrintableOnly = 0x60 // uint8_t (Size: 0x1)
FontImportOptionsData.bIncludeASCIIRange = 0x60 // uint8_t (Size: 0x1)
FontImportOptionsData.ForegroundColor = 0x64 // FLinearColor (Size: 0x10)
FontImportOptionsData.bEnableDropShadow = 0x74 // uint8_t (Size: 0x1)
FontImportOptionsData.TexturePageWidth = 0x78 // int32_t (Size: 0x4)
FontImportOptionsData.TexturePageMaxHeight = 0x7c // int32_t (Size: 0x4)
FontImportOptionsData.XPadding = 0x80 // int32_t (Size: 0x4)
FontImportOptionsData.YPadding = 0x84 // int32_t (Size: 0x4)
FontImportOptionsData.ExtendBoxTop = 0x88 // int32_t (Size: 0x4)
FontImportOptionsData.ExtendBoxBottom = 0x8c // int32_t (Size: 0x4)
FontImportOptionsData.ExtendBoxRight = 0x90 // int32_t (Size: 0x4)
FontImportOptionsData.ExtendBoxLeft = 0x94 // int32_t (Size: 0x4)
FontImportOptionsData.bEnableLegacyMode = 0x98 // uint8_t (Size: 0x1)
FontImportOptionsData.Kerning = 0x9c // int32_t (Size: 0x4)
FontImportOptionsData.bUseDistanceFieldAlpha = 0xa0 // uint8_t (Size: 0x1)
FontImportOptionsData.DistanceFieldScaleFactor = 0xa4 // int32_t (Size: 0x4)
FontImportOptionsData.DistanceFieldScanRadiusScale = 0xa8 // float (Size: 0x4)
FontParameterValue.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
FontParameterValue.FontValue = 0x10 // Font* (Size: 0x8)
FontParameterValue.FontPage = 0x18 // int32_t (Size: 0x4)
FontParameterValue.ExpressionGUID = 0x1c // FGuid (Size: 0x10)
FontRenderInfo.bClipText = 0x0 // uint8_t (Size: 0x1)
FontRenderInfo.bEnableShadow = 0x0 // uint8_t (Size: 0x1)
FontRenderInfo.GlowInfo = 0x4 // FDepthFieldGlowInfo (Size: 0x24)
ForceFeedbackAttenuation.Attenuation = 0x28 // FForceFeedbackAttenuationSettings (Size: 0xb0)
ForceFeedbackChannelDetails.bAffectsLeftLarge = 0x0 // uint8_t (Size: 0x1)
ForceFeedbackChannelDetails.bAffectsLeftSmall = 0x0 // uint8_t (Size: 0x1)
ForceFeedbackChannelDetails.bAffectsRightLarge = 0x0 // uint8_t (Size: 0x1)
ForceFeedbackChannelDetails.bAffectsRightSmall = 0x0 // uint8_t (Size: 0x1)
ForceFeedbackChannelDetails.Curve = 0x8 // FRuntimeFloatCurve (Size: 0x88)
ForceFeedbackComponent.ForceFeedbackEffect = 0x238 // ForceFeedbackEffect* (Size: 0x8)
ForceFeedbackComponent.bAutoDestroy = 0x240 // uint8_t (Size: 0x1)
ForceFeedbackComponent.bStopWhenOwnerDestroyed = 0x240 // uint8_t (Size: 0x1)
ForceFeedbackComponent.bLooping = 0x240 // uint8_t (Size: 0x1)
ForceFeedbackComponent.bIgnoreTimeDilation = 0x240 // uint8_t (Size: 0x1)
ForceFeedbackComponent.bOverrideAttenuation = 0x240 // uint8_t (Size: 0x1)
ForceFeedbackComponent.IntensityMultiplier = 0x244 // float (Size: 0x4)
ForceFeedbackComponent.AttenuationSettings = 0x248 // ForceFeedbackAttenuation* (Size: 0x8)
ForceFeedbackComponent.AttenuationOverrides = 0x250 // FForceFeedbackAttenuationSettings (Size: 0xb0)
ForceFeedbackComponent.OnForceFeedbackFinished = 0x300 // FMulticastInlineDelegate (Size: 0x10)
ForceFeedbackEffect.ChannelDetails = 0x28 // TArray<FForceFeedbackChannelDetails> (Size: 0x10)
ForceFeedbackEffect.Duration = 0x38 // float (Size: 0x4)
ForceFeedbackParameters.Tag = 0x0 // FName (Size: 0x8)
ForceFeedbackParameters.bLooping = 0x8 // bool (Size: 0x1)
ForceFeedbackParameters.bIgnoreTimeDilation = 0x9 // bool (Size: 0x1)
ForceFeedbackParameters.bPlayWhilePaused = 0xa // bool (Size: 0x1)
FormatArgumentData.ArgumentName = 0x0 // FString (Size: 0x10)
FormatArgumentData.ArgumentValueType = 0x10 // uint8_t (Size: 0x1)
FormatArgumentData.ArgumentValue = 0x18 // FText (Size: 0x18)
FormatArgumentData.ArgumentValueInt = 0x30 // int32_t (Size: 0x4)
FormatArgumentData.ArgumentValueFloat = 0x34 // float (Size: 0x4)
FormatArgumentData.ArgumentValueGender = 0x38 // EETextGender (Size: 0x1)
FractureEffect.ParticleSystem = 0x0 // ParticleSystem* (Size: 0x8)
FractureEffect.Sound = 0x8 // SoundBase* (Size: 0x8)
FullyLoadedPackagesInfo.FullyLoadType = 0x0 // uint8_t (Size: 0x1)
FullyLoadedPackagesInfo.Tag = 0x8 // FString (Size: 0x10)
FullyLoadedPackagesInfo.PackagesToLoad = 0x18 // TArray<FName> (Size: 0x10)
FullyLoadedPackagesInfo.LoadedObjects = 0x28 // TArray<Object*> (Size: 0x10)
FunctionExpressionInput.ExpressionInput = 0x0 // MaterialExpressionFunctionInput* (Size: 0x8)
FunctionExpressionInput.ExpressionInputId = 0x8 // FGuid (Size: 0x10)
FunctionExpressionInput.Input = 0x18 // FExpressionInput (Size: 0xc)
FunctionExpressionOutput.ExpressionOutput = 0x0 // MaterialExpressionFunctionOutput* (Size: 0x8)
FunctionExpressionOutput.ExpressionOutputId = 0x8 // FGuid (Size: 0x10)
FunctionExpressionOutput.Output = 0x18 // FExpressionOutput (Size: 0x8)
GPUSpriteEmitterInfo.RequiredModule = 0x0 // ParticleModuleRequired* (Size: 0x8)
GPUSpriteEmitterInfo.SpawnModule = 0x8 // ParticleModuleSpawn* (Size: 0x8)
GPUSpriteEmitterInfo.SpawnPerUnitModule = 0x10 // ParticleModuleSpawnPerUnit* (Size: 0x8)
GPUSpriteEmitterInfo.SpawnModules = 0x18 // TArray<ParticleModule*> (Size: 0x10)
GPUSpriteEmitterInfo.LocalVectorField = 0x30 // FGPUSpriteLocalVectorFieldInfo (Size: 0x70)
GPUSpriteEmitterInfo.VectorFieldScale = 0xa0 // FFloatDistribution (Size: 0x20)
GPUSpriteEmitterInfo.DragCoefficient = 0xc0 // FFloatDistribution (Size: 0x20)
GPUSpriteEmitterInfo.PointAttractorStrength = 0xe0 // FFloatDistribution (Size: 0x20)
GPUSpriteEmitterInfo.Resilience = 0x100 // FFloatDistribution (Size: 0x20)
GPUSpriteEmitterInfo.ConstantAcceleration = 0x120 // FVector (Size: 0xc)
GPUSpriteEmitterInfo.PointAttractorPosition = 0x12c // FVector (Size: 0xc)
GPUSpriteEmitterInfo.PointAttractorRadiusSq = 0x138 // float (Size: 0x4)
GPUSpriteEmitterInfo.OrbitOffsetBase = 0x13c // FVector (Size: 0xc)
GPUSpriteEmitterInfo.OrbitOffsetRange = 0x148 // FVector (Size: 0xc)
GPUSpriteEmitterInfo.InvMaxSize = 0x154 // FVector2D (Size: 0x8)
GPUSpriteEmitterInfo.InvRotationRateScale = 0x15c // float (Size: 0x4)
GPUSpriteEmitterInfo.MaxLifeTime = 0x160 // float (Size: 0x4)
GPUSpriteEmitterInfo.MaxParticleCount = 0x164 // int32_t (Size: 0x4)
GPUSpriteEmitterInfo.ScreenAlignment = 0x168 // uint8_t (Size: 0x1)
GPUSpriteEmitterInfo.LockAxisFlag = 0x169 // uint8_t (Size: 0x1)
GPUSpriteEmitterInfo.bEnableCollision = 0x16c // uint8_t (Size: 0x1)
GPUSpriteEmitterInfo.CollisionMode = 0x170 // uint8_t (Size: 0x1)
GPUSpriteEmitterInfo.bRemoveHMDRoll = 0x174 // uint8_t (Size: 0x1)
GPUSpriteEmitterInfo.MinFacingCameraBlendDistance = 0x178 // float (Size: 0x4)
GPUSpriteEmitterInfo.MaxFacingCameraBlendDistance = 0x17c // float (Size: 0x4)
GPUSpriteEmitterInfo.DynamicColor = 0x180 // FRawDistributionVector (Size: 0x48)
GPUSpriteEmitterInfo.DynamicAlpha = 0x1c8 // FRawDistributionFloat (Size: 0x30)
GPUSpriteEmitterInfo.DynamicColorScale = 0x1f8 // FRawDistributionVector (Size: 0x48)
GPUSpriteEmitterInfo.DynamicAlphaScale = 0x240 // FRawDistributionFloat (Size: 0x30)
GPUSpriteLocalVectorFieldInfo.Field = 0x0 // VectorField* (Size: 0x8)
GPUSpriteLocalVectorFieldInfo.Transform = 0x10 // FTransform (Size: 0x30)
GPUSpriteLocalVectorFieldInfo.MinInitialRotation = 0x40 // FRotator (Size: 0xc)
GPUSpriteLocalVectorFieldInfo.MaxInitialRotation = 0x4c // FRotator (Size: 0xc)
GPUSpriteLocalVectorFieldInfo.RotationRate = 0x58 // FRotator (Size: 0xc)
GPUSpriteLocalVectorFieldInfo.Intensity = 0x64 // float (Size: 0x4)
GPUSpriteLocalVectorFieldInfo.Tightness = 0x68 // float (Size: 0x4)
GPUSpriteLocalVectorFieldInfo.bIgnoreComponentTransform = 0x6c // uint8_t (Size: 0x1)
GPUSpriteLocalVectorFieldInfo.bTileX = 0x6c // uint8_t (Size: 0x1)
GPUSpriteLocalVectorFieldInfo.bTileY = 0x6c // uint8_t (Size: 0x1)
GPUSpriteLocalVectorFieldInfo.bTileZ = 0x6c // uint8_t (Size: 0x1)
GPUSpriteLocalVectorFieldInfo.bUseFixDT = 0x6c // uint8_t (Size: 0x1)
GPUSpriteResourceData.QuantizedColorSamples = 0x0 // TArray<FColor> (Size: 0x10)
GPUSpriteResourceData.QuantizedMiscSamples = 0x10 // TArray<FColor> (Size: 0x10)
GPUSpriteResourceData.QuantizedSimulationAttrSamples = 0x20 // TArray<FColor> (Size: 0x10)
GPUSpriteResourceData.ColorScale = 0x30 // FVector4 (Size: 0x10)
GPUSpriteResourceData.ColorBias = 0x40 // FVector4 (Size: 0x10)
GPUSpriteResourceData.MiscScale = 0x50 // FVector4 (Size: 0x10)
GPUSpriteResourceData.MiscBias = 0x60 // FVector4 (Size: 0x10)
GPUSpriteResourceData.SimulationAttrCurveScale = 0x70 // FVector4 (Size: 0x10)
GPUSpriteResourceData.SimulationAttrCurveBias = 0x80 // FVector4 (Size: 0x10)
GPUSpriteResourceData.SubImageSize = 0x90 // FVector4 (Size: 0x10)
GPUSpriteResourceData.SizeBySpeed = 0xa0 // FVector4 (Size: 0x10)
GPUSpriteResourceData.ConstantAcceleration = 0xb0 // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitOffsetBase = 0xbc // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitOffsetRange = 0xc8 // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitFrequencyBase = 0xd4 // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitFrequencyRange = 0xe0 // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitPhaseBase = 0xec // FVector (Size: 0xc)
GPUSpriteResourceData.OrbitPhaseRange = 0xf8 // FVector (Size: 0xc)
GPUSpriteResourceData.GlobalVectorFieldScale = 0x104 // float (Size: 0x4)
GPUSpriteResourceData.GlobalVectorFieldTightness = 0x108 // float (Size: 0x4)
GPUSpriteResourceData.PerParticleVectorFieldScale = 0x10c // float (Size: 0x4)
GPUSpriteResourceData.PerParticleVectorFieldBias = 0x110 // float (Size: 0x4)
GPUSpriteResourceData.DragCoefficientScale = 0x114 // float (Size: 0x4)
GPUSpriteResourceData.DragCoefficientBias = 0x118 // float (Size: 0x4)
GPUSpriteResourceData.ResilienceScale = 0x11c // float (Size: 0x4)
GPUSpriteResourceData.ResilienceBias = 0x120 // float (Size: 0x4)
GPUSpriteResourceData.CollisionRadiusScale = 0x124 // float (Size: 0x4)
GPUSpriteResourceData.CollisionRadiusBias = 0x128 // float (Size: 0x4)
GPUSpriteResourceData.CollisionTimeBias = 0x12c // float (Size: 0x4)
GPUSpriteResourceData.CollisionRandomSpread = 0x130 // float (Size: 0x4)
GPUSpriteResourceData.CollisionRandomDistribution = 0x134 // float (Size: 0x4)
GPUSpriteResourceData.OneMinusFriction = 0x138 // float (Size: 0x4)
GPUSpriteResourceData.RotationRateScale = 0x13c // float (Size: 0x4)
GPUSpriteResourceData.CameraMotionBlurAmount = 0x140 // float (Size: 0x4)
GPUSpriteResourceData.ScreenAlignment = 0x144 // uint8_t (Size: 0x1)
GPUSpriteResourceData.LockAxisFlag = 0x145 // uint8_t (Size: 0x1)
GPUSpriteResourceData.PivotOffset = 0x148 // FVector2D (Size: 0x8)
GPUSpriteResourceData.bRemoveHMDRoll = 0x150 // uint8_t (Size: 0x1)
GPUSpriteResourceData.MinFacingCameraBlendDistance = 0x154 // float (Size: 0x4)
GPUSpriteResourceData.MaxFacingCameraBlendDistance = 0x158 // float (Size: 0x4)
GameEngine.MaxDeltaTime = 0xe48 // float (Size: 0x4)
GameEngine.ServerFlushLogInterval = 0xe4c // float (Size: 0x4)
GameEngine.GameInstance = 0xe50 // GameInstance* (Size: 0x8)
GameInstance.LocalPlayers = 0x38 // TArray<LocalPlayer*> (Size: 0x10)
GameInstance.OnlineSession = 0x48 // OnlineSession* (Size: 0x8)
GameInstance.ReferencedObjects = 0x50 // TArray<Object*> (Size: 0x10)
GameInstance.OnPawnControllerChangedDelegates = 0x78 // FMulticastInlineDelegate (Size: 0x10)
GameMode.MatchState = 0x3b0 // FName (Size: 0x8)
GameMode.bDelayedStart = 0x3b8 // uint8_t (Size: 0x1)
GameMode.NumSpectators = 0x3bc // int32_t (Size: 0x4)
GameMode.NumPlayers = 0x3c0 // int32_t (Size: 0x4)
GameMode.NumBots = 0x3c4 // int32_t (Size: 0x4)
GameMode.MinRespawnDelay = 0x3c8 // float (Size: 0x4)
GameMode.NumTravellingPlayers = 0x3cc // int32_t (Size: 0x4)
GameMode.EngineMessageClass = 0x3d0 // ClassProperty (Size: 0x8)
GameMode.InactivePlayerArray = 0x3d8 // TArray<PlayerState*> (Size: 0x10)
GameMode.InactivePlayerStateLifeSpan = 0x3e8 // float (Size: 0x4)
GameMode.MaxInactivePlayers = 0x3ec // int32_t (Size: 0x4)
GameMode.bHandleDedicatedServerReplays = 0x3f0 // bool (Size: 0x1)
GameModeBase.OptionsString = 0x310 // FString (Size: 0x10)
GameModeBase.GameSessionClass = 0x320 // ClassProperty (Size: 0x8)
GameModeBase.GameStateClass = 0x328 // ClassProperty (Size: 0x8)
GameModeBase.PlayerControllerClass = 0x330 // ClassProperty (Size: 0x8)
GameModeBase.PlayerStateClass = 0x338 // ClassProperty (Size: 0x8)
GameModeBase.HUDClass = 0x340 // ClassProperty (Size: 0x8)
GameModeBase.DefaultPawnClass = 0x348 // ClassProperty (Size: 0x8)
GameModeBase.SpectatorClass = 0x350 // ClassProperty (Size: 0x8)
GameModeBase.ReplaySpectatorPlayerControllerClass = 0x358 // ClassProperty (Size: 0x8)
GameModeBase.ServerStatReplicatorClass = 0x360 // ClassProperty (Size: 0x8)
GameModeBase.GameSession = 0x368 // GameSession* (Size: 0x8)
GameModeBase.GameState = 0x370 // GameStateBase* (Size: 0x8)
GameModeBase.ServerStatReplicator = 0x378 // ServerStatReplicator* (Size: 0x8)
GameModeBase.DefaultPlayerName = 0x380 // FText (Size: 0x18)
GameModeBase.bUseSeamlessTravel = 0x398 // uint8_t (Size: 0x1)
GameModeBase.bStartPlayersAsSpectators = 0x398 // uint8_t (Size: 0x1)
GameModeBase.bPauseable = 0x398 // uint8_t (Size: 0x1)
GameNameRedirect.OldGameName = 0x0 // FName (Size: 0x8)
GameNameRedirect.NewGameName = 0x8 // FName (Size: 0x8)
GameNetworkManager.BadPacketLossThreshold = 0x310 // float (Size: 0x4)
GameNetworkManager.SeverePacketLossThreshold = 0x314 // float (Size: 0x4)
GameNetworkManager.BadPingThreshold = 0x318 // int32_t (Size: 0x4)
GameNetworkManager.SeverePingThreshold = 0x31c // int32_t (Size: 0x4)
GameNetworkManager.AdjustedNetSpeed = 0x320 // int32_t (Size: 0x4)
GameNetworkManager.LastNetSpeedUpdateTime = 0x328 // double (Size: 0x8)
GameNetworkManager.TotalNetBandwidth = 0x330 // int32_t (Size: 0x4)
GameNetworkManager.MinDynamicBandwidth = 0x334 // int32_t (Size: 0x4)
GameNetworkManager.MaxDynamicBandwidth = 0x338 // int32_t (Size: 0x4)
GameNetworkManager.bIsStandbyCheckingEnabled = 0x33c // uint8_t (Size: 0x1)
GameNetworkManager.bHasStandbyCheatTriggered = 0x33c // uint8_t (Size: 0x1)
GameNetworkManager.StandbyRxCheatTime = 0x340 // float (Size: 0x4)
GameNetworkManager.StandbyTxCheatTime = 0x344 // float (Size: 0x4)
GameNetworkManager.PercentMissingForRxStandby = 0x348 // float (Size: 0x4)
GameNetworkManager.PercentMissingForTxStandby = 0x34c // float (Size: 0x4)
GameNetworkManager.PercentForBadPing = 0x350 // float (Size: 0x4)
GameNetworkManager.JoinInProgressStandbyWaitTime = 0x354 // float (Size: 0x4)
GameNetworkManager.MoveRepSize = 0x358 // float (Size: 0x4)
GameNetworkManager.MAXPOSITIONERRORSQUARED = 0x35c // float (Size: 0x4)
GameNetworkManager.MAXNEARZEROVELOCITYSQUARED = 0x360 // float (Size: 0x4)
GameNetworkManager.CLIENTADJUSTUPDATECOST = 0x364 // float (Size: 0x4)
GameNetworkManager.MAXCLIENTUPDATEINTERVAL = 0x368 // float (Size: 0x4)
GameNetworkManager.MaxClientForcedUpdateDuration = 0x36c // float (Size: 0x4)
GameNetworkManager.ServerForcedUpdateHitchThreshold = 0x370 // float (Size: 0x4)
GameNetworkManager.ServerForcedUpdateHitchCooldown = 0x374 // float (Size: 0x4)
GameNetworkManager.ServerForcedUpdatePrintLogThreshold = 0x378 // float (Size: 0x4)
GameNetworkManager.MaxMoveDeltaTime = 0x37c // float (Size: 0x4)
GameNetworkManager.MaxClientSmoothingDeltaTime = 0x380 // float (Size: 0x4)
GameNetworkManager.ClientNetSendMoveDeltaTime = 0x384 // float (Size: 0x4)
GameNetworkManager.ClientNetSendMoveDeltaTimeThrottled = 0x388 // float (Size: 0x4)
GameNetworkManager.ClientNetSendMoveDeltaTimeStationary = 0x38c // float (Size: 0x4)
GameNetworkManager.ClientNetSendMoveThrottleAtNetSpeed = 0x390 // int32_t (Size: 0x4)
GameNetworkManager.ClientNetSendMoveThrottleOverPlayerCount = 0x394 // int32_t (Size: 0x4)
GameNetworkManager.ClientAuthorativePosition = 0x398 // bool (Size: 0x1)
GameNetworkManager.ClientErrorUpdateRateLimit = 0x39c // float (Size: 0x4)
GameNetworkManager.ClientNetCamUpdateDeltaTime = 0x3a0 // float (Size: 0x4)
GameNetworkManager.ClientNetCamUpdatePositionLimit = 0x3a4 // float (Size: 0x4)
GameNetworkManager.bMovementTimeDiscrepancyDetection = 0x3a8 // bool (Size: 0x1)
GameNetworkManager.bMovementTimeDiscrepancyResolution = 0x3a9 // bool (Size: 0x1)
GameNetworkManager.MovementTimeDiscrepancyMaxTimeMargin = 0x3ac // float (Size: 0x4)
GameNetworkManager.MovementTimeDiscrepancyMinTimeMargin = 0x3b0 // float (Size: 0x4)
GameNetworkManager.MovementTimeDiscrepancyResolutionRate = 0x3b4 // float (Size: 0x4)
GameNetworkManager.MovementTimeDiscrepancyDriftAllowance = 0x3b8 // float (Size: 0x4)
GameNetworkManager.bMovementTimeDiscrepancyForceCorrectionsDuringResolution = 0x3bc // bool (Size: 0x1)
GameNetworkManager.bUseDistanceBasedRelevancy = 0x3bd // bool (Size: 0x1)
GameSession.MaxSpectators = 0x310 // int32_t (Size: 0x4)
GameSession.MaxPlayers = 0x314 // int32_t (Size: 0x4)
GameSession.MaxPartySize = 0x318 // int32_t (Size: 0x4)
GameSession.MaxSplitscreensPerConnection = 0x31c // uint8_t (Size: 0x1)
GameSession.bRequiresPushToTalk = 0x31d // bool (Size: 0x1)
GameSession.SessionName = 0x320 // FName (Size: 0x8)
GameState.MatchState = 0x360 // FName (Size: 0x8)
GameState.PreviousMatchState = 0x368 // FName (Size: 0x8)
GameState.ElapsedTime = 0x370 // int32_t (Size: 0x4)
GameStateBase.GameModeClass = 0x310 // ClassProperty (Size: 0x8)
GameStateBase.AuthorityGameMode = 0x318 // GameModeBase* (Size: 0x8)
GameStateBase.SpectatorClass = 0x320 // ClassProperty (Size: 0x8)
GameStateBase.PlayerArray = 0x328 // TArray<PlayerState*> (Size: 0x10)
GameStateBase.bReplicatedHasBegunPlay = 0x338 // bool (Size: 0x1)
GameStateBase.ReplicatedWorldTimeSeconds = 0x33c // float (Size: 0x4)
GameStateBase.ServerWorldTimeSecondsDelta = 0x340 // float (Size: 0x4)
GameStateBase.ServerWorldTimeSecondsUpdateFrequency = 0x344 // float (Size: 0x4)
GameUserSettings.bUseVSync = 0x28 // bool (Size: 0x1)
GameUserSettings.bUseDynamicResolution = 0x29 // bool (Size: 0x1)
GameUserSettings.ResolutionSizeX = 0x88 // uint32_t (Size: 0x4)
GameUserSettings.ResolutionSizeY = 0x8c // uint32_t (Size: 0x4)
GameUserSettings.LastUserConfirmedResolutionSizeX = 0x90 // uint32_t (Size: 0x4)
GameUserSettings.LastUserConfirmedResolutionSizeY = 0x94 // uint32_t (Size: 0x4)
GameUserSettings.WindowPosX = 0x98 // int32_t (Size: 0x4)
GameUserSettings.WindowPosY = 0x9c // int32_t (Size: 0x4)
GameUserSettings.FullscreenMode = 0xa0 // int32_t (Size: 0x4)
GameUserSettings.LastConfirmedFullscreenMode = 0xa4 // int32_t (Size: 0x4)
GameUserSettings.PreferredFullscreenMode = 0xa8 // int32_t (Size: 0x4)
GameUserSettings.Version = 0xac // uint32_t (Size: 0x4)
GameUserSettings.AudioQualityLevel = 0xb0 // int32_t (Size: 0x4)
GameUserSettings.LastConfirmedAudioQualityLevel = 0xb4 // int32_t (Size: 0x4)
GameUserSettings.FrameRateLimit = 0xb8 // float (Size: 0x4)
GameUserSettings.DesiredScreenWidth = 0xc0 // int32_t (Size: 0x4)
GameUserSettings.bUseDesiredScreenHeight = 0xc4 // bool (Size: 0x1)
GameUserSettings.DesiredScreenHeight = 0xc8 // int32_t (Size: 0x4)
GameUserSettings.LastUserConfirmedDesiredScreenWidth = 0xcc // int32_t (Size: 0x4)
GameUserSettings.LastUserConfirmedDesiredScreenHeight = 0xd0 // int32_t (Size: 0x4)
GameUserSettings.LastRecommendedScreenWidth = 0xd4 // float (Size: 0x4)
GameUserSettings.LastRecommendedScreenHeight = 0xd8 // float (Size: 0x4)
GameUserSettings.LastCPUBenchmarkResult = 0xdc // float (Size: 0x4)
GameUserSettings.LastGPUBenchmarkResult = 0xe0 // float (Size: 0x4)
GameUserSettings.LastCPUBenchmarkSteps = 0xe8 // TArray<float> (Size: 0x10)
GameUserSettings.LastGPUBenchmarkSteps = 0xf8 // TArray<float> (Size: 0x10)
GameUserSettings.LastGPUBenchmarkMultiplier = 0x108 // float (Size: 0x4)
GameUserSettings.bUseHDRDisplayOutput = 0x10c // bool (Size: 0x1)
GameUserSettings.HDRDisplayOutputNits = 0x110 // int32_t (Size: 0x4)
GameUserSettings.OnGameUserSettingsUINeedsUpdate = 0x118 // FMulticastInlineDelegate (Size: 0x10)
GameViewportClient.ViewportConsole = 0x40 // Console* (Size: 0x8)
GameViewportClient.DebugProperties = 0x48 // TArray<FDebugDisplayProperty> (Size: 0x10)
GameViewportClient.MaxSplitscreenPlayers = 0x68 // int32_t (Size: 0x4)
GameViewportClient.World = 0x78 // World* (Size: 0x8)
GameViewportClient.GameInstance = 0x80 // GameInstance* (Size: 0x8)
GameViewportClient.CurrentSpecialScope = 0x390 // SceneCaptureComponent2D* (Size: 0x8)
GarbageCollectionSettings.TimeBetweenPurgingPendingKillObjects = 0x38 // float (Size: 0x4)
GarbageCollectionSettings.FlushStreamingOnGC = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.AllowParallelGC = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.IncrementalBeginDestroyEnabled = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.MultithreadedDestructionEnabled = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.CreateGCClusters = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.AssetClusteringEnabled = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.ActorClusteringEnabled = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.BlueprintClusteringEnabled = 0x3c // uint8_t (Size: 0x1)
GarbageCollectionSettings.UseDisregardForGCOnDedicatedServers = 0x3d // uint8_t (Size: 0x1)
GarbageCollectionSettings.MinGCClusterSize = 0x40 // int32_t (Size: 0x4)
GarbageCollectionSettings.NumRetriesBeforeForcingGC = 0x44 // int32_t (Size: 0x4)
GarbageCollectionSettings.MaxObjectsNotConsideredByGC = 0x48 // int32_t (Size: 0x4)
GarbageCollectionSettings.SizeOfPermanentObjectPool = 0x4c // int32_t (Size: 0x4)
GarbageCollectionSettings.MaxObjectsInGame = 0x50 // int32_t (Size: 0x4)
GarbageCollectionSettings.MaxObjectsInEditor = 0x54 // int32_t (Size: 0x4)
GaussianSumBloomSettings.Intensity = 0x0 // float (Size: 0x4)
GaussianSumBloomSettings.Threshold = 0x4 // float (Size: 0x4)
GaussianSumBloomSettings.SizeScale = 0x8 // float (Size: 0x4)
GaussianSumBloomSettings.Filter1Size = 0xc // float (Size: 0x4)
GaussianSumBloomSettings.Filter2Size = 0x10 // float (Size: 0x4)
GaussianSumBloomSettings.Filter3Size = 0x14 // float (Size: 0x4)
GaussianSumBloomSettings.Filter4Size = 0x18 // float (Size: 0x4)
GaussianSumBloomSettings.Filter5Size = 0x1c // float (Size: 0x4)
GaussianSumBloomSettings.Filter6Size = 0x20 // float (Size: 0x4)
GaussianSumBloomSettings.Filter1Tint = 0x24 // FLinearColor (Size: 0x10)
GaussianSumBloomSettings.Filter2Tint = 0x34 // FLinearColor (Size: 0x10)
GaussianSumBloomSettings.Filter3Tint = 0x44 // FLinearColor (Size: 0x10)
GaussianSumBloomSettings.Filter4Tint = 0x54 // FLinearColor (Size: 0x10)
GaussianSumBloomSettings.Filter5Tint = 0x64 // FLinearColor (Size: 0x10)
GaussianSumBloomSettings.Filter6Tint = 0x74 // FLinearColor (Size: 0x10)
GenericStruct.Data = 0x0 // int32_t (Size: 0x4)
GeomSelection.Type = 0x0 // int32_t (Size: 0x4)
GeomSelection.Index = 0x4 // int32_t (Size: 0x4)
GeomSelection.SelectionIndex = 0x8 // int32_t (Size: 0x4)
GlobalDFShadowSettings.TraceStart = 0x0 // float (Size: 0x4)
GlobalDFShadowSettings.HitDistance = 0x4 // float (Size: 0x4)
GlobalDFShadowSettings.SmoothDistance = 0x8 // float (Size: 0x4)
GlobalILCActor.bIsGlobalILC = 0x310 // bool (Size: 0x1)
GlobalILCActor.ILCComponent = 0x318 // GlobalILCComponent* (Size: 0x8)
GlobalILCComponent.VolumeType = 0x5c8 // uint8_t (Size: 0x1)
GlobalILCComponent.BoxExtent = 0x5cc // FVector (Size: 0xc)
GlobalILCComponent.LineThickness = 0x5d8 // float (Size: 0x4)
GraphAssetPlayerInformation.PlayerNodeIndices = 0x0 // TArray<int32_t> (Size: 0x10)
GraphNodeContextMenuContext.Blueprint = 0x28 // Blueprint* (Size: 0x8)
GraphNodeContextMenuContext.Graph = 0x30 // EdGraph* (Size: 0x8)
GraphNodeContextMenuContext.Node = 0x38 // EdGraphNode* (Size: 0x8)
GraphNodeContextMenuContext.bIsDebugging = 0x48 // bool (Size: 0x1)
GraphReference.MacroGraph = 0x0 // EdGraph* (Size: 0x8)
GraphReference.GraphBlueprint = 0x8 // Blueprint* (Size: 0x8)
GraphReference.GraphGuid = 0x10 // FGuid (Size: 0x10)
GridBlendSample.GridElement = 0x0 // FEditorElement (Size: 0x18)
GridBlendSample.BlendWeight = 0x18 // float (Size: 0x4)
HLODGridComponentInfo.RelatedTransforms = 0x0 // TArray<FTransform> (Size: 0x10)
HLODGridComponentInfo.ComponentNames = 0x10 // TArray<FString> (Size: 0x10)
HLODGridComponentInfo.Components = 0x20 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
HLODGridInfo.RelatedLevels = 0x0 // TArray<FString> (Size: 0x10)
HLODGridInfo.RelatedActorNames = 0x10 // TArray<FString> (Size: 0x10)
HLODGridInfo.RelatedComponents = 0x20 // TArray<FHLODGridComponentInfo> (Size: 0x10)
HLODISMComponentDesc.StaticMesh = 0x0 // StaticMesh* (Size: 0x8)
HLODISMComponentDesc.Material = 0x8 // MaterialInterface* (Size: 0x8)
HLODISMComponentDesc.Instances = 0x10 // TArray<FTransform> (Size: 0x10)
HLODProxy.ProxyMeshes = 0x28 // TArray<FHLODProxyMesh> (Size: 0x10)
HLODProxy.HLODActors = 0x38 // TMap<...> (Size: 0x50)
HLODProxyMesh.LODActor = 0x0 // TLazyObjectPtr<UObject> (Size: 0x1c)
HLODProxyMesh.StaticMesh = 0x20 // StaticMesh* (Size: 0x8)
HLODProxyMesh.Key = 0x28 // FName (Size: 0x8)
HUD.PlayerOwner = 0x310 // PlayerController* (Size: 0x8)
HUD.bLostFocusPaused = 0x318 // uint8_t (Size: 0x1)
HUD.bShowHUD = 0x318 // uint8_t (Size: 0x1)
HUD.bShowDebugInfo = 0x318 // uint8_t (Size: 0x1)
HUD.CurrentTargetIndex = 0x31c // int32_t (Size: 0x4)
HUD.bShowHitBoxDebugInfo = 0x320 // uint8_t (Size: 0x1)
HUD.bShowOverlays = 0x320 // uint8_t (Size: 0x1)
HUD.bEnableDebugTextShadow = 0x320 // uint8_t (Size: 0x1)
HUD.PostRenderedActors = 0x328 // TArray<Actor*> (Size: 0x10)
HUD.DebugDisplay = 0x348 // TArray<FName> (Size: 0x10)
HUD.ToggledDebugCategories = 0x358 // TArray<FName> (Size: 0x10)
HUD.Canvas = 0x368 // Canvas* (Size: 0x8)
HUD.DebugCanvas = 0x370 // Canvas* (Size: 0x8)
HUD.DebugTextList = 0x378 // TArray<FDebugTextInfo> (Size: 0x10)
HUD.ShowDebugTargetDesiredClass = 0x388 // ClassProperty (Size: 0x8)
HUD.ShowDebugTargetActor = 0x390 // Actor* (Size: 0x8)
HapticFeedbackDetails_Curve.Frequency = 0x0 // FRuntimeFloatCurve (Size: 0x88)
HapticFeedbackDetails_Curve.Amplitude = 0x88 // FRuntimeFloatCurve (Size: 0x88)
HapticFeedbackEffect_Buffer.Amplitudes = 0x28 // TArray<uint8_t> (Size: 0x10)
HapticFeedbackEffect_Buffer.SampleRate = 0x38 // int32_t (Size: 0x4)
HapticFeedbackEffect_Curve.HapticDetails = 0x28 // FHapticFeedbackDetails_Curve (Size: 0x110)
HapticFeedbackEffect_SoundWave.SoundWave = 0x28 // SoundWave* (Size: 0x8)
HardwareCursorReference.CursorPath = 0x0 // FName (Size: 0x8)
HardwareCursorReference.HotSpot = 0x8 // FVector2D (Size: 0x8)
HierarchicalInstancedStaticMeshComponent.SortedInstances = 0x738 // TArray<int32_t> (Size: 0x10)
HierarchicalInstancedStaticMeshComponent.NumBuiltInstances = 0x748 // int32_t (Size: 0x4)
HierarchicalInstancedStaticMeshComponent.BuiltInstanceBounds = 0x750 // FBox (Size: 0x1c)
HierarchicalInstancedStaticMeshComponent.UnbuiltInstanceBounds = 0x76c // FBox (Size: 0x1c)
HierarchicalInstancedStaticMeshComponent.UnbuiltInstanceBoundsList = 0x788 // TArray<FBox> (Size: 0x10)
HierarchicalInstancedStaticMeshComponent.bEnableDensityScaling = 0x798 // uint8_t (Size: 0x1)
HierarchicalInstancedStaticMeshComponent.OcclusionLayerNumNodes = 0x7a0 // int32_t (Size: 0x4)
HierarchicalInstancedStaticMeshComponent.CacheMeshExtendedBounds = 0x7a4 // FBoxSphereBounds (Size: 0x1c)
HierarchicalInstancedStaticMeshComponent.bDisableCollision = 0x7c0 // bool (Size: 0x1)
HierarchicalInstancedStaticMeshComponent.InstanceCountToRender = 0x7c4 // int32_t (Size: 0x4)
HierarchicalLODSetup.HierarchicalLODSetup = 0x28 // TArray<FHierarchicalSimplification> (Size: 0x10)
HierarchicalLODSetup.OverrideBaseMaterial = 0x38 // TSoftObjectPtr<UObject> (Size: 0x28)
HierarchicalSimplification.TransitionScreenSize = 0x0 // float (Size: 0x4)
HierarchicalSimplification.OverrideDrawDistance = 0x4 // float (Size: 0x4)
HierarchicalSimplification.bUseOverrideDrawDistance = 0x8 // uint8_t (Size: 0x1)
HierarchicalSimplification.bAllowSpecificExclusion = 0x8 // uint8_t (Size: 0x1)
HierarchicalSimplification.MinExtentSizeSquared = 0xc // float (Size: 0x4)
HierarchicalSimplification.bSimplifyMesh = 0x10 // uint8_t (Size: 0x1)
HierarchicalSimplification.bOnlyGenerateClustersForVolumes = 0x10 // uint8_t (Size: 0x1)
HierarchicalSimplification.bReusePreviousLevelClusters = 0x10 // uint8_t (Size: 0x1)
HierarchicalSimplification.ProxySetting = 0x14 // FMeshProxySettings (Size: 0xb0)
HierarchicalSimplification.MergeSetting = 0xc4 // FMeshMergingSettings (Size: 0xa8)
HierarchicalSimplification.DesiredBoundRadius = 0x16c // float (Size: 0x4)
HierarchicalSimplification.DesiredFillingPercentage = 0x170 // float (Size: 0x4)
HierarchicalSimplification.MinNumberOfActorsToBuild = 0x174 // int32_t (Size: 0x4)
HitResult.bBlockingHit = 0x0 // uint8_t (Size: 0x1)
HitResult.bStartPenetrating = 0x0 // uint8_t (Size: 0x1)
HitResult.FaceIndex = 0x4 // int32_t (Size: 0x4)
HitResult.Time = 0x8 // float (Size: 0x4)
HitResult.Distance = 0xc // float (Size: 0x4)
HitResult.Location = 0x10 // FVector_NetQuantize (Size: 0xc)
HitResult.ImpactPoint = 0x1c // FVector_NetQuantize (Size: 0xc)
HitResult.Normal = 0x28 // FVector_NetQuantizeNormal (Size: 0xc)
HitResult.ImpactNormal = 0x34 // FVector_NetQuantizeNormal (Size: 0xc)
HitResult.TraceStart = 0x40 // FVector_NetQuantize (Size: 0xc)
HitResult.TraceEnd = 0x4c // FVector_NetQuantize (Size: 0xc)
HitResult.PenetrationDepth = 0x58 // float (Size: 0x4)
HitResult.item = 0x5c // int32_t (Size: 0x4)
HitResult.ElementIndex = 0x60 // uint8_t (Size: 0x1)
HitResult.PhysMaterial = 0x64 // TWeakObjectPtr<UObject> (Size: 0x8)
HitResult.Actor = 0x6c // TWeakObjectPtr<UObject> (Size: 0x8)
HitResult.Component = 0x74 // TWeakObjectPtr<UObject> (Size: 0x8)
HitResult.BoneName = 0x7c // FName (Size: 0x8)
HitResult.MyBoneName = 0x84 // FName (Size: 0x8)
IBLPrecomputedDataAsset.FilteredCubemap = 0x30 // TextureCube* (Size: 0x8)
IBLPrecomputedDataAsset.AverageBrightness = 0x38 // float (Size: 0x4)
IBLPrecomputedDataAsset.DynamicSkyAverageBrightness = 0x3c // float (Size: 0x4)
IBLPrecomputedDataAsset.EncodeType = 0x40 // uint8_t (Size: 0x1)
IBLPrecomputedDataAsset.MaxValueRGBM = 0x44 // float (Size: 0x4)
IBLPrecomputedDataAsset.IrradianceEnvironmentMapFloats = 0x48 // TArray<float> (Size: 0x10)
ImportFactorySettingValues.SettingName = 0x0 // FString (Size: 0x10)
ImportFactorySettingValues.Value = 0x10 // FString (Size: 0x10)
ImportanceTexture.Size = 0x0 // FIntPoint (Size: 0x8)
ImportanceTexture.NumMips = 0x8 // int32_t (Size: 0x4)
ImportanceTexture.MarginalCDF = 0x10 // TArray<float> (Size: 0x10)
ImportanceTexture.ConditionalCDF = 0x20 // TArray<float> (Size: 0x10)
ImportanceTexture.TextureData = 0x30 // TArray<FColor> (Size: 0x10)
ImportanceTexture.Texture = 0x40 // TWeakObjectPtr<UObject> (Size: 0x8)
ImportanceTexture.Weighting = 0x48 // uint8_t (Size: 0x1)
InGameAdManager.bShouldPauseWhileAdOpen = 0x38 // uint8_t (Size: 0x1)
InGameAdManager.ClickedBannerDelegates = 0x40 // TArray<FDelegate> (Size: 0x10)
InGameAdManager.ClosedAdDelegates = 0x50 // TArray<FDelegate> (Size: 0x10)
IndexedCurve.KeyHandlesToIndices = 0x8 // FKeyHandleMap (Size: 0x60)
InheritableComponentHandler.Records = 0x28 // TArray<FComponentOverrideRecord> (Size: 0x10)
InheritableComponentHandler.UnnecessaryComponents = 0x38 // TArray<ActorComponent*> (Size: 0x10)
InputActionDelegateBinding.InputActionDelegateBindings = 0x28 // TArray<FBlueprintInputActionDelegateBinding> (Size: 0x10)
InputActionKeyMapping.ActionName = 0x0 // FName (Size: 0x8)
InputActionKeyMapping.bShift = 0x8 // uint8_t (Size: 0x1)
InputActionKeyMapping.bCtrl = 0x8 // uint8_t (Size: 0x1)
InputActionKeyMapping.bAlt = 0x8 // uint8_t (Size: 0x1)
InputActionKeyMapping.bCmd = 0x8 // uint8_t (Size: 0x1)
InputActionKeyMapping.Key = 0x10 // FKey (Size: 0x18)
InputActionSpeechMapping.ActionName = 0x0 // FName (Size: 0x8)
InputActionSpeechMapping.SpeechKeyword = 0x8 // FName (Size: 0x8)
InputAlphaBoolBlend.BlendInTime = 0x0 // float (Size: 0x4)
InputAlphaBoolBlend.BlendOutTime = 0x4 // float (Size: 0x4)
InputAlphaBoolBlend.BlendOption = 0x8 // EEAlphaBlendOption (Size: 0x1)
InputAlphaBoolBlend.bInitialized = 0x9 // bool (Size: 0x1)
InputAlphaBoolBlend.CustomCurve = 0x10 // CurveFloat* (Size: 0x8)
InputAlphaBoolBlend.AlphaBlend = 0x18 // FAlphaBlend (Size: 0x30)
InputAxisConfigEntry.AxisKeyName = 0x0 // FName (Size: 0x8)
InputAxisConfigEntry.AxisProperties = 0x8 // FInputAxisProperties (Size: 0x10)
InputAxisDelegateBinding.InputAxisDelegateBindings = 0x28 // TArray<FBlueprintInputAxisDelegateBinding> (Size: 0x10)
InputAxisKeyDelegateBinding.InputAxisKeyDelegateBindings = 0x28 // TArray<FBlueprintInputAxisKeyDelegateBinding> (Size: 0x10)
InputAxisKeyMapping.AxisName = 0x0 // FName (Size: 0x8)
InputAxisKeyMapping.Scale = 0x8 // float (Size: 0x4)
InputAxisKeyMapping.Key = 0x10 // FKey (Size: 0x18)
InputAxisProperties.DeadZone = 0x0 // float (Size: 0x4)
InputAxisProperties.Sensitivity = 0x4 // float (Size: 0x4)
InputAxisProperties.Exponent = 0x8 // float (Size: 0x4)
InputAxisProperties.bInvert = 0xc // uint8_t (Size: 0x1)
InputBlendPose.BranchFilters = 0x0 // TArray<FBranchFilter> (Size: 0x10)
InputComponent.CachedKeyToActionInfo = 0x168 // TArray<FCachedKeyToActionInfo> (Size: 0x10)
InputKeyDelegateBinding.InputKeyDelegateBindings = 0x28 // TArray<FBlueprintInputKeyDelegateBinding> (Size: 0x10)
InputRInterp.bInterpResult = 0x0 // bool (Size: 0x1)
InputRInterp.bConstInterp = 0x1 // bool (Size: 0x1)
InputRInterp.InterpSpeedIncreasing = 0x4 // float (Size: 0x4)
InputRInterp.InterpSpeedDecreasing = 0x8 // float (Size: 0x4)
InputRange.Min = 0x0 // float (Size: 0x4)
InputRange.Max = 0x4 // float (Size: 0x4)
InputScaleBias.Scale = 0x0 // float (Size: 0x4)
InputScaleBias.Bias = 0x4 // float (Size: 0x4)
InputScaleBiasClamp.bMapRange = 0x0 // bool (Size: 0x1)
InputScaleBiasClamp.bClampResult = 0x1 // bool (Size: 0x1)
InputScaleBiasClamp.bInterpResult = 0x2 // bool (Size: 0x1)
InputScaleBiasClamp.InRange = 0x4 // FInputRange (Size: 0x8)
InputScaleBiasClamp.OutRange = 0xc // FInputRange (Size: 0x8)
InputScaleBiasClamp.Scale = 0x14 // float (Size: 0x4)
InputScaleBiasClamp.Bias = 0x18 // float (Size: 0x4)
InputScaleBiasClamp.ClampMin = 0x1c // float (Size: 0x4)
InputScaleBiasClamp.ClampMax = 0x20 // float (Size: 0x4)
InputScaleBiasClamp.InterpSpeedIncreasing = 0x24 // float (Size: 0x4)
InputScaleBiasClamp.InterpSpeedDecreasing = 0x28 // float (Size: 0x4)
InputSettings.AxisConfig = 0x28 // TArray<FInputAxisConfigEntry> (Size: 0x10)
InputSettings.bAltEnterTogglesFullscreen = 0x38 // uint8_t (Size: 0x1)
InputSettings.bF11TogglesFullscreen = 0x38 // uint8_t (Size: 0x1)
InputSettings.bUseMouseForTouch = 0x38 // uint8_t (Size: 0x1)
InputSettings.bEnableMouseSmoothing = 0x38 // uint8_t (Size: 0x1)
InputSettings.bEnableFOVScaling = 0x38 // uint8_t (Size: 0x1)
InputSettings.bCaptureMouseOnLaunch = 0x38 // uint8_t (Size: 0x1)
InputSettings.bDefaultViewportMouseLock = 0x38 // uint8_t (Size: 0x1)
InputSettings.bAlwaysShowTouchInterface = 0x38 // uint8_t (Size: 0x1)
InputSettings.bShowConsoleOnFourFingerTap = 0x39 // uint8_t (Size: 0x1)
InputSettings.bEnableGestureRecognizer = 0x39 // uint8_t (Size: 0x1)
InputSettings.bUseAutocorrect = 0x3a // bool (Size: 0x1)
InputSettings.ExcludedAutocorrectOS = 0x40 // TArray<FString> (Size: 0x10)
InputSettings.ExcludedAutocorrectCultures = 0x50 // TArray<FString> (Size: 0x10)
InputSettings.ExcludedAutocorrectDeviceModels = 0x60 // TArray<FString> (Size: 0x10)
InputSettings.DefaultViewportMouseCaptureMode = 0x70 // EEMouseCaptureMode (Size: 0x1)
InputSettings.DefaultViewportMouseLockMode = 0x71 // EEMouseLockMode (Size: 0x1)
InputSettings.FOVScale = 0x74 // float (Size: 0x4)
InputSettings.DoubleClickTime = 0x78 // float (Size: 0x4)
InputSettings.ActionMappings = 0x80 // TArray<FInputActionKeyMapping> (Size: 0x10)
InputSettings.AxisMappings = 0x90 // TArray<FInputAxisKeyMapping> (Size: 0x10)
InputSettings.SpeechMappings = 0xa0 // TArray<FInputActionSpeechMapping> (Size: 0x10)
InputSettings.DefaultPlayerInputClass = 0xb0 // TSoftClassPtr<UObject> (Size: 0x28)
InputSettings.DefaultInputComponentClass = 0xd8 // TSoftClassPtr<UObject> (Size: 0x28)
InputSettings.DefaultTouchInterface = 0x100 // FSoftObjectPath (Size: 0x18)
InputSettings.ConsoleKey = 0x118 // FKey (Size: 0x18)
InputSettings.ConsoleKeys = 0x130 // TArray<FKey> (Size: 0x10)
InputTouchDelegateBinding.InputTouchDelegateBindings = 0x28 // TArray<FBlueprintInputTouchDelegateBinding> (Size: 0x10)
InputVInterp.bInterpResult = 0x0 // bool (Size: 0x1)
InputVInterp.bConstInterp = 0x1 // bool (Size: 0x1)
InputVInterp.InterpSpeedIncreasing = 0x4 // float (Size: 0x4)
InputVInterp.InterpSpeedDecreasing = 0x8 // float (Size: 0x4)
InstancedStaticMeshComponent.PerInstanceSMData = 0x670 // TArray<FInstancedStaticMeshInstanceData> (Size: 0x10)
InstancedStaticMeshComponent.NumCustomDataFloats = 0x680 // int32_t (Size: 0x4)
InstancedStaticMeshComponent.PerInstanceSMCustomData = 0x688 // TArray<float> (Size: 0x10)
InstancedStaticMeshComponent.InstancingRandomSeed = 0x698 // int32_t (Size: 0x4)
InstancedStaticMeshComponent.InstanceStartCullDistance = 0x69c // int32_t (Size: 0x4)
InstancedStaticMeshComponent.InstanceEndCullDistance = 0x6a0 // int32_t (Size: 0x4)
InstancedStaticMeshComponent.InstanceFallOffExponent = 0x6a4 // float (Size: 0x4)
InstancedStaticMeshComponent.InstanceReorderTable = 0x6a8 // TArray<int32_t> (Size: 0x10)
InstancedStaticMeshComponent.NumPendingLightmaps = 0x700 // int32_t (Size: 0x4)
InstancedStaticMeshComponent.CachedMappings = 0x708 // TArray<FInstancedStaticMeshMappingInfo> (Size: 0x10)
InstancedStaticMeshComponentInstanceData.StaticMesh = 0xb8 // StaticMesh* (Size: 0x8)
InstancedStaticMeshComponentInstanceData.CachedStaticLighting = 0xc0 // FInstancedStaticMeshLightMapInstanceData (Size: 0x40)
InstancedStaticMeshComponentInstanceData.PerInstanceSMData = 0x100 // TArray<FInstancedStaticMeshInstanceData> (Size: 0x10)
InstancedStaticMeshComponentInstanceData.PerInstanceSMCustomData = 0x110 // TArray<float> (Size: 0x10)
InstancedStaticMeshComponentInstanceData.InstancingRandomSeed = 0x140 // int32_t (Size: 0x4)
InstancedStaticMeshInstanceData.Transform = 0x0 // FMatrix (Size: 0x40)
InstancedStaticMeshLightMapInstanceData.Transform = 0x0 // FTransform (Size: 0x30)
InstancedStaticMeshLightMapInstanceData.MapBuildDataIds = 0x30 // TArray<FGuid> (Size: 0x10)
IntSerialization.UnsignedInt16Variable = 0x28 // uint16_t (Size: 0x2)
IntSerialization.UnsignedInt32Variable = 0x2c // uint32_t (Size: 0x4)
IntSerialization.UnsignedInt64Variable = 0x30 // uint64_t (Size: 0x8)
IntSerialization.SignedInt8Variable = 0x38 // int8_t (Size: 0x1)
IntSerialization.SignedInt16Variable = 0x3a // int16_t (Size: 0x2)
IntSerialization.SignedInt64Variable = 0x40 // int64_t (Size: 0x8)
IntSerialization.UnsignedInt8Variable = 0x48 // uint8_t (Size: 0x1)
IntSerialization.SignedInt32Variable = 0x4c // int32_t (Size: 0x4)
IntegralCurve.Keys = 0x68 // TArray<FIntegralKey> (Size: 0x10)
IntegralCurve.DefaultValue = 0x78 // int32_t (Size: 0x4)
IntegralCurve.bUseDefaultValueBeforeFirstKey = 0x7c // bool (Size: 0x1)
IntegralKey.Time = 0x0 // float (Size: 0x4)
IntegralKey.Value = 0x4 // int32_t (Size: 0x4)
InteriorSettings.bIsWorldSettings = 0x0 // bool (Size: 0x1)
InteriorSettings.ExteriorVolume = 0x4 // float (Size: 0x4)
InteriorSettings.ExteriorTime = 0x8 // float (Size: 0x4)
InteriorSettings.ExteriorLPF = 0xc // float (Size: 0x4)
InteriorSettings.ExteriorLPFTime = 0x10 // float (Size: 0x4)
InteriorSettings.InteriorVolume = 0x14 // float (Size: 0x4)
InteriorSettings.InteriorTime = 0x18 // float (Size: 0x4)
InteriorSettings.InteriorLPF = 0x1c // float (Size: 0x4)
InteriorSettings.InteriorLPFTime = 0x20 // float (Size: 0x4)
InterpControlPoint.PositionControlPoint = 0x0 // FVector (Size: 0xc)
InterpControlPoint.bPositionIsRelative = 0xc // bool (Size: 0x1)
InterpCurveEdSetup.Tabs = 0x28 // TArray<FCurveEdTab> (Size: 0x10)
InterpCurveEdSetup.ActiveTab = 0x38 // int32_t (Size: 0x4)
InterpData.InterpLength = 0x28 // float (Size: 0x4)
InterpData.PathBuildTime = 0x2c // float (Size: 0x4)
InterpData.InterpGroups = 0x30 // TArray<InterpGroup*> (Size: 0x10)
InterpData.CurveEdSetup = 0x40 // InterpCurveEdSetup* (Size: 0x8)
InterpData.EdSectionStart = 0x48 // float (Size: 0x4)
InterpData.EdSectionEnd = 0x4c // float (Size: 0x4)
InterpData.bShouldBakeAndPrune = 0x50 // uint8_t (Size: 0x1)
InterpData.CachedDirectorGroup = 0x58 // InterpGroupDirector* (Size: 0x8)
InterpData.AllEventNames = 0x60 // TArray<FName> (Size: 0x10)
InterpEdSelKey.Group = 0x0 // InterpGroup* (Size: 0x8)
InterpEdSelKey.Track = 0x8 // InterpTrack* (Size: 0x8)
InterpEdSelKey.KeyIndex = 0x10 // int32_t (Size: 0x4)
InterpEdSelKey.UnsnappedPosition = 0x14 // float (Size: 0x4)
InterpFilter.Caption = 0x28 // FString (Size: 0x10)
InterpGroup.InterpTracks = 0x30 // TArray<InterpTrack*> (Size: 0x10)
InterpGroup.GroupName = 0x40 // FName (Size: 0x8)
InterpGroup.GroupColor = 0x48 // FColor (Size: 0x4)
InterpGroup.bCollapsed = 0x4c // uint8_t (Size: 0x1)
InterpGroup.bVisible = 0x4c // uint8_t (Size: 0x1)
InterpGroup.bIsFolder = 0x4c // uint8_t (Size: 0x1)
InterpGroup.bIsParented = 0x4c // uint8_t (Size: 0x1)
InterpGroup.bIsSelected = 0x4c // uint8_t (Size: 0x1)
InterpGroupActorInfo.ObjectName = 0x0 // FName (Size: 0x8)
InterpGroupActorInfo.Actors = 0x8 // TArray<Actor*> (Size: 0x10)
InterpGroupCamera.CameraAnimInst = 0x50 // CameraAnim* (Size: 0x8)
InterpGroupCamera.CompressTolerance = 0x58 // float (Size: 0x4)
InterpGroupInst.Group = 0x28 // InterpGroup* (Size: 0x8)
InterpGroupInst.GroupActor = 0x30 // Actor* (Size: 0x8)
InterpGroupInst.TrackInst = 0x38 // TArray<InterpTrackInst*> (Size: 0x10)
InterpLookupPoint.GroupName = 0x0 // FName (Size: 0x8)
InterpLookupPoint.Time = 0x8 // float (Size: 0x4)
InterpLookupTrack.Points = 0x0 // TArray<FInterpLookupPoint> (Size: 0x10)
InterpToMovementComponent.Duration = 0x138 // float (Size: 0x4)
InterpToMovementComponent.bPauseOnImpact = 0x13c // uint8_t (Size: 0x1)
InterpToMovementComponent.bSweep = 0x140 // bool (Size: 0x1)
InterpToMovementComponent.TeleportType = 0x141 // EETeleportType (Size: 0x1)
InterpToMovementComponent.BehaviourType = 0x142 // EEInterpToBehaviourType (Size: 0x1)
InterpToMovementComponent.bCheckIfStillInWorld = 0x143 // bool (Size: 0x1)
InterpToMovementComponent.bForceSubStepping = 0x144 // uint8_t (Size: 0x1)
InterpToMovementComponent.OnInterpToReverse = 0x148 // FMulticastInlineDelegate (Size: 0x10)
InterpToMovementComponent.OnInterpToStop = 0x158 // FMulticastInlineDelegate (Size: 0x10)
InterpToMovementComponent.OnWaitBeginDelegate = 0x168 // FMulticastInlineDelegate (Size: 0x10)
InterpToMovementComponent.OnWaitEndDelegate = 0x178 // FMulticastInlineDelegate (Size: 0x10)
InterpToMovementComponent.OnResetDelegate = 0x188 // FMulticastInlineDelegate (Size: 0x10)
InterpToMovementComponent.MaxSimulationTimeStep = 0x198 // float (Size: 0x4)
InterpToMovementComponent.MaxSimulationIterations = 0x19c // int32_t (Size: 0x4)
InterpToMovementComponent.ControlPoints = 0x1a0 // TArray<FInterpControlPoint> (Size: 0x10)
InterpTrack.SubTracks = 0x38 // TArray<InterpTrack*> (Size: 0x10)
InterpTrack.TrackInstClass = 0x48 // ClassProperty (Size: 0x8)
InterpTrack.ActiveCondition = 0x50 // uint8_t (Size: 0x1)
InterpTrack.TrackTitle = 0x58 // FString (Size: 0x10)
InterpTrack.bOnePerGroup = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bDirGroupOnly = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bDisableTrack = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bIsSelected = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bIsAnimControlTrack = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bSubTrackOnly = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bVisible = 0x68 // uint8_t (Size: 0x1)
InterpTrack.bIsRecording = 0x68 // uint8_t (Size: 0x1)
InterpTrackAnimControl.SlotName = 0x90 // FName (Size: 0x8)
InterpTrackAnimControl.AnimSeqs = 0x98 // TArray<FAnimControlTrackKey> (Size: 0x10)
InterpTrackAnimControl.bSkipAnimNotifiers = 0xa8 // uint8_t (Size: 0x1)
InterpTrackBoolProp.BoolTrack = 0x70 // TArray<FBoolTrackKey> (Size: 0x10)
InterpTrackBoolProp.PropertyName = 0x80 // FName (Size: 0x8)
InterpTrackColorProp.PropertyName = 0x90 // FName (Size: 0x8)
InterpTrackDirector.CutTrack = 0x70 // TArray<FDirectorTrackCut> (Size: 0x10)
InterpTrackDirector.bSimulateCameraCutsOnClients = 0x80 // uint8_t (Size: 0x1)
InterpTrackEvent.EventTrack = 0x70 // TArray<FEventTrackKey> (Size: 0x10)
InterpTrackEvent.bFireEventsWhenForwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackEvent.bFireEventsWhenBackwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackEvent.bFireEventsWhenJumpingForwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackEvent.bUseCustomEventName = 0x80 // uint8_t (Size: 0x1)
InterpTrackFade.bPersistFade = 0x90 // uint8_t (Size: 0x1)
InterpTrackFade.bFadeAudio = 0x90 // uint8_t (Size: 0x1)
InterpTrackFade.FadeColor = 0x94 // FLinearColor (Size: 0x10)
InterpTrackFloatAnimBPParam.AnimBlueprintClass = 0x90 // ClassProperty (Size: 0x8)
InterpTrackFloatAnimBPParam.AnimClass = 0x98 // ClassProperty (Size: 0x8)
InterpTrackFloatAnimBPParam.ParamName = 0xa0 // FName (Size: 0x8)
InterpTrackFloatBase.FloatTrack = 0x70 // FInterpCurveFloat (Size: 0x18)
InterpTrackFloatBase.CurveTension = 0x88 // float (Size: 0x4)
InterpTrackFloatMaterialParam.TargetMaterials = 0x90 // TArray<MaterialInterface*> (Size: 0x10)
InterpTrackFloatMaterialParam.ParamName = 0xa0 // FName (Size: 0x8)
InterpTrackFloatParticleParam.ParamName = 0x90 // FName (Size: 0x8)
InterpTrackFloatProp.PropertyName = 0x90 // FName (Size: 0x8)
InterpTrackInstAnimControl.LastUpdatePosition = 0x28 // float (Size: 0x4)
InterpTrackInstBoolProp.ResetBool = 0x60 // bool (Size: 0x1)
InterpTrackInstColorProp.ResetColor = 0x58 // FColor (Size: 0x4)
InterpTrackInstDirector.OldViewTarget = 0x28 // Actor* (Size: 0x8)
InterpTrackInstEvent.LastUpdatePosition = 0x28 // float (Size: 0x4)
InterpTrackInstFloatAnimBPParam.AnimScriptInstance = 0x28 // AnimInstance* (Size: 0x8)
InterpTrackInstFloatAnimBPParam.ResetFloat = 0x30 // float (Size: 0x4)
InterpTrackInstFloatMaterialParam.MaterialInstances = 0x28 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
InterpTrackInstFloatMaterialParam.ResetFloats = 0x38 // TArray<float> (Size: 0x10)
InterpTrackInstFloatMaterialParam.PrimitiveMaterialRefs = 0x48 // TArray<FPrimitiveMaterialRef> (Size: 0x10)
InterpTrackInstFloatMaterialParam.InstancedTrack = 0x58 // InterpTrackFloatMaterialParam* (Size: 0x8)
InterpTrackInstFloatParticleParam.ResetFloat = 0x28 // float (Size: 0x4)
InterpTrackInstFloatProp.ResetFloat = 0x58 // float (Size: 0x4)
InterpTrackInstLinearColorProp.ResetColor = 0x58 // FLinearColor (Size: 0x10)
InterpTrackInstMove.ResetLocation = 0x28 // FVector (Size: 0xc)
InterpTrackInstMove.ResetRotation = 0x34 // FRotator (Size: 0xc)
InterpTrackInstParticleReplay.LastUpdatePosition = 0x28 // float (Size: 0x4)
InterpTrackInstProperty.InterpProperty = 0x28 // FieldPathProperty (Size: 0x20)
InterpTrackInstProperty.PropertyOuterObjectInst = 0x48 // Object* (Size: 0x8)
InterpTrackInstSlomo.OldTimeDilation = 0x28 // float (Size: 0x4)
InterpTrackInstSound.LastUpdatePosition = 0x28 // float (Size: 0x4)
InterpTrackInstSound.PlayAudioComp = 0x30 // AudioComponent* (Size: 0x8)
InterpTrackInstToggle.Action = 0x28 // uint8_t (Size: 0x1)
InterpTrackInstToggle.LastUpdatePosition = 0x2c // float (Size: 0x4)
InterpTrackInstToggle.bSavedActiveState = 0x30 // uint8_t (Size: 0x1)
InterpTrackInstVectorMaterialParam.MaterialInstances = 0x28 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
InterpTrackInstVectorMaterialParam.ResetVectors = 0x38 // TArray<FVector> (Size: 0x10)
InterpTrackInstVectorMaterialParam.PrimitiveMaterialRefs = 0x48 // TArray<FPrimitiveMaterialRef> (Size: 0x10)
InterpTrackInstVectorMaterialParam.InstancedTrack = 0x58 // InterpTrackVectorMaterialParam* (Size: 0x8)
InterpTrackInstVectorProp.ResetVector = 0x58 // FVector (Size: 0xc)
InterpTrackInstVisibility.Action = 0x28 // uint8_t (Size: 0x1)
InterpTrackInstVisibility.LastUpdatePosition = 0x2c // float (Size: 0x4)
InterpTrackLinearColorBase.LinearColorTrack = 0x70 // FInterpCurveLinearColor (Size: 0x18)
InterpTrackLinearColorBase.CurveTension = 0x88 // float (Size: 0x4)
InterpTrackLinearColorProp.PropertyName = 0x90 // FName (Size: 0x8)
InterpTrackMove.PosTrack = 0x70 // FInterpCurveVector (Size: 0x18)
InterpTrackMove.EulerTrack = 0x88 // FInterpCurveVector (Size: 0x18)
InterpTrackMove.LookupTrack = 0xa0 // FInterpLookupTrack (Size: 0x10)
InterpTrackMove.LookAtGroupName = 0xb0 // FName (Size: 0x8)
InterpTrackMove.LinCurveTension = 0xb8 // float (Size: 0x4)
InterpTrackMove.AngCurveTension = 0xbc // float (Size: 0x4)
InterpTrackMove.bUseQuatInterpolation = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.bShowArrowAtKeys = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.bDisableMovement = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.bShowTranslationOnCurveEd = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.bShowRotationOnCurveEd = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.bHide3DTrack = 0xc0 // uint8_t (Size: 0x1)
InterpTrackMove.RotMode = 0xc4 // uint8_t (Size: 0x1)
InterpTrackMoveAxis.MoveAxis = 0x90 // uint8_t (Size: 0x1)
InterpTrackMoveAxis.LookupTrack = 0x98 // FInterpLookupTrack (Size: 0x10)
InterpTrackParticleReplay.TrackKeys = 0x70 // TArray<FParticleReplayTrackKey> (Size: 0x10)
InterpTrackSound.Sounds = 0x90 // TArray<FSoundTrackKey> (Size: 0x10)
InterpTrackSound.bPlayOnReverse = 0xa0 // uint8_t (Size: 0x1)
InterpTrackSound.bContinueSoundOnMatineeEnd = 0xa0 // uint8_t (Size: 0x1)
InterpTrackSound.bSuppressSubtitles = 0xa0 // uint8_t (Size: 0x1)
InterpTrackSound.bTreatAsDialogue = 0xa0 // uint8_t (Size: 0x1)
InterpTrackSound.bAttach = 0xa0 // uint8_t (Size: 0x1)
InterpTrackToggle.ToggleTrack = 0x70 // TArray<FToggleTrackKey> (Size: 0x10)
InterpTrackToggle.bActivateSystemEachUpdate = 0x80 // uint8_t (Size: 0x1)
InterpTrackToggle.bActivateWithJustAttachedFlag = 0x80 // uint8_t (Size: 0x1)
InterpTrackToggle.bFireEventsWhenForwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackToggle.bFireEventsWhenBackwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackToggle.bFireEventsWhenJumpingForwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackVectorBase.VectorTrack = 0x70 // FInterpCurveVector (Size: 0x18)
InterpTrackVectorBase.CurveTension = 0x88 // float (Size: 0x4)
InterpTrackVectorMaterialParam.TargetMaterials = 0x90 // TArray<MaterialInterface*> (Size: 0x10)
InterpTrackVectorMaterialParam.ParamName = 0xa0 // FName (Size: 0x8)
InterpTrackVectorProp.PropertyName = 0x90 // FName (Size: 0x8)
InterpTrackVisibility.VisibilityTrack = 0x70 // TArray<FVisibilityTrackKey> (Size: 0x10)
InterpTrackVisibility.bFireEventsWhenForwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackVisibility.bFireEventsWhenBackwards = 0x80 // uint8_t (Size: 0x1)
InterpTrackVisibility.bFireEventsWhenJumpingForwards = 0x80 // uint8_t (Size: 0x1)
InterpolationParameter.InterpolationTime = 0x0 // float (Size: 0x4)
InterpolationParameter.InterpolationType = 0x4 // uint8_t (Size: 0x1)
KAggregateGeom.SphereElems = 0x0 // TArray<FKSphereElem> (Size: 0x10)
KAggregateGeom.BoxElems = 0x10 // TArray<FKBoxElem> (Size: 0x10)
KAggregateGeom.SphylElems = 0x20 // TArray<FKSphylElem> (Size: 0x10)
KAggregateGeom.ConvexElems = 0x30 // TArray<FKConvexElem> (Size: 0x10)
KAggregateGeom.TaperedCapsuleElems = 0x40 // TArray<FKTaperedCapsuleElem> (Size: 0x10)
KBoxElem.Center = 0x30 // FVector (Size: 0xc)
KBoxElem.Rotation = 0x3c // FRotator (Size: 0xc)
KBoxElem.X = 0x48 // float (Size: 0x4)
KBoxElem.Y = 0x4c // float (Size: 0x4)
KBoxElem.Z = 0x50 // float (Size: 0x4)
KConvexElem.VertexData = 0x30 // TArray<FVector> (Size: 0x10)
KConvexElem.IndexData = 0x40 // TArray<int32_t> (Size: 0x10)
KConvexElem.ElemBox = 0x50 // FBox (Size: 0x1c)
KConvexElem.Transform = 0x70 // FTransform (Size: 0x30)
KShapeElem.RestOffset = 0x8 // float (Size: 0x4)
KShapeElem.Name = 0xc // FName (Size: 0x8)
KShapeElem.bContributeToMass = 0x18 // uint8_t (Size: 0x1)
KShapeElem.CollisionEnabled = 0x19 // uint8_t (Size: 0x1)
KSphereElem.Center = 0x30 // FVector (Size: 0xc)
KSphereElem.Radius = 0x3c // float (Size: 0x4)
KSphylElem.Center = 0x30 // FVector (Size: 0xc)
KSphylElem.Rotation = 0x3c // FRotator (Size: 0xc)
KSphylElem.Radius = 0x48 // float (Size: 0x4)
KSphylElem.Length = 0x4c // float (Size: 0x4)
KTaperedCapsuleElem.Center = 0x30 // FVector (Size: 0xc)
KTaperedCapsuleElem.Rotation = 0x3c // FRotator (Size: 0xc)
KTaperedCapsuleElem.Radius0 = 0x48 // float (Size: 0x4)
KTaperedCapsuleElem.Radius1 = 0x4c // float (Size: 0x4)
KTaperedCapsuleElem.Length = 0x50 // float (Size: 0x4)
KeyBind.Key = 0x0 // FKey (Size: 0x18)
KeyBind.Command = 0x18 // FString (Size: 0x10)
KeyBind.Control = 0x28 // uint8_t (Size: 0x1)
KeyBind.Shift = 0x28 // uint8_t (Size: 0x1)
KeyBind.Alt = 0x28 // uint8_t (Size: 0x1)
KeyBind.Cmd = 0x28 // uint8_t (Size: 0x1)
KeyBind.bIgnoreCtrl = 0x28 // uint8_t (Size: 0x1)
KeyBind.bIgnoreShift = 0x28 // uint8_t (Size: 0x1)
KeyBind.bIgnoreAlt = 0x28 // uint8_t (Size: 0x1)
KeyBind.bIgnoreCmd = 0x28 // uint8_t (Size: 0x1)
KeyBind.bDisabled = 0x29 // uint8_t (Size: 0x1)
LODActor.StaticMeshComponent = 0x310 // StaticMeshComponent* (Size: 0x8)
LODActor.ImpostersStaticMeshComponents = 0x318 // TMap<...> (Size: 0x50)
LODActor.Proxy = 0x368 // HLODProxy* (Size: 0x8)
LODActor.Key = 0x370 // FName (Size: 0x8)
LODActor.LODDrawDistance = 0x378 // float (Size: 0x4)
LODActor.LODLevel = 0x37c // int32_t (Size: 0x4)
LODActor.SubActors = 0x380 // TArray<Actor*> (Size: 0x10)
LODActor.LazySubActors = 0x390 // TArray<TLazyObjectPtr<UObject>> (Size: 0x10)
LODActor.ParentLevel = 0x3a0 // TLazyObjectPtr<UObject> (Size: 0x1c)
LODActor.CachedNumHLODLevels = 0x420 // uint8_t (Size: 0x1)
LODActor.RelatedGridInfo = 0x428 // FHLODGridInfo (Size: 0x80)
LODMappingData.Mapping = 0x0 // TArray<int32_t> (Size: 0x10)
LODMappingData.InverseMapping = 0x10 // TArray<int32_t> (Size: 0x10)
LODSoloTrack.SoloEnableSetting = 0x0 // TArray<uint8_t> (Size: 0x10)
LODSyncComponent.NumLODs = 0xf8 // int32_t (Size: 0x4)
LODSyncComponent.ForcedLOD = 0xfc // int32_t (Size: 0x4)
LODSyncComponent.ComponentsToSync = 0x100 // TArray<FComponentSync> (Size: 0x10)
LODSyncComponent.CustomLODMapping = 0x110 // TMap<...> (Size: 0x50)
LODSyncComponent.CurrentLOD = 0x160 // int32_t (Size: 0x4)
LODSyncComponent.CurrentNumLODs = 0x164 // int32_t (Size: 0x4)
LODSyncComponent.DriveComponents = 0x168 // TArray<PrimitiveComponent*> (Size: 0x10)
LODSyncComponent.SubComponents = 0x178 // TArray<PrimitiveComponent*> (Size: 0x10)
LatentActionInfo.Linkage = 0x0 // int32_t (Size: 0x4)
LatentActionInfo.UUID = 0x4 // int32_t (Size: 0x4)
LatentActionInfo.ExecutionFunction = 0x8 // FName (Size: 0x8)
LatentActionInfo.CallbackTarget = 0x10 // Object* (Size: 0x8)
LaunchOnTestSettings.LaunchOnTestmap = 0x0 // FFilePath (Size: 0x10)
LaunchOnTestSettings.DeviceID = 0x10 // FString (Size: 0x10)
Layer.LayerName = 0x28 // FName (Size: 0x8)
Layer.bIsVisible = 0x30 // uint8_t (Size: 0x1)
Layer.ActorStats = 0x38 // TArray<FLayerActorStats> (Size: 0x10)
LayerActorStats.Type = 0x0 // ClassProperty (Size: 0x8)
LayerActorStats.Total = 0x8 // int32_t (Size: 0x4)
LensBloomSettings.GaussianSum = 0x0 // FGaussianSumBloomSettings (Size: 0x84)
LensBloomSettings.Convolution = 0x88 // FConvolutionBloomSettings (Size: 0x28)
LensBloomSettings.Method = 0xb0 // uint8_t (Size: 0x1)
LensImperfectionSettings.DirtMask = 0x0 // Texture* (Size: 0x8)
LensImperfectionSettings.DirtMaskIntensity = 0x8 // float (Size: 0x4)
LensImperfectionSettings.DirtMaskTint = 0xc // FLinearColor (Size: 0x10)
LensSettings.Bloom = 0x0 // FLensBloomSettings (Size: 0xb8)
LensSettings.Imperfections = 0xb8 // FLensImperfectionSettings (Size: 0x20)
LensSettings.ChromaticAberration = 0xd8 // float (Size: 0x4)
Level.OwningWorld = 0xb8 // World* (Size: 0x8)
Level.Model = 0xc0 // Model* (Size: 0x8)
Level.ModelComponents = 0xc8 // TArray<ModelComponent*> (Size: 0x10)
Level.ActorCluster = 0xd8 // LevelActorContainer* (Size: 0x8)
Level.NumTextureStreamingUnbuiltComponents = 0xe0 // int32_t (Size: 0x4)
Level.NumTextureStreamingDirtyResources = 0xe4 // int32_t (Size: 0x4)
Level.LevelScriptActor = 0xe8 // LevelScriptActor* (Size: 0x8)
Level.NavListStart = 0xf0 // NavigationObjectBase* (Size: 0x8)
Level.NavListEnd = 0xf8 // NavigationObjectBase* (Size: 0x8)
Level.NavDataChunks = 0x100 // TArray<NavigationDataChunk*> (Size: 0x10)
Level.LightmapTotalSize = 0x110 // float (Size: 0x4)
Level.ShadowmapTotalSize = 0x114 // float (Size: 0x4)
Level.StaticNavigableGeometry = 0x118 // TArray<FVector> (Size: 0x10)
Level.StreamingTextureGuids = 0x128 // TArray<FGuid> (Size: 0x10)
Level.LevelBuildDataId = 0x3a8 // FGuid (Size: 0x10)
Level.MapBuildData = 0x3b8 // MapBuildDataRegistry* (Size: 0x8)
Level.LightBuildLevelOffset = 0x3c0 // FIntVector (Size: 0xc)
Level.bIsLightingScenario = 0x3cc // uint8_t (Size: 0x1)
Level.bTextureStreamingRotationChanged = 0x3cc // uint8_t (Size: 0x1)
Level.bStaticComponentsRegisteredInStreamingManager = 0x3cc // uint8_t (Size: 0x1)
Level.bIsVisible = 0x3cc // uint8_t (Size: 0x1)
Level.WorldSettings = 0x440 // WorldSettings* (Size: 0x8)
Level.AssetUserData = 0x450 // TArray<AssetUserData*> (Size: 0x10)
Level.DestroyedReplicatedStaticActors = 0x470 // TArray<FReplicatedStaticActorDestructionInfo> (Size: 0x10)
LevelActorContainer.Actors = 0x28 // TArray<Actor*> (Size: 0x10)
LevelBounds.BoxComponent = 0x310 // BoxComponent* (Size: 0x8)
LevelBounds.bAutoUpdateBounds = 0x318 // bool (Size: 0x1)
LevelCollection.GameState = 0x8 // GameStateBase* (Size: 0x8)
LevelCollection.NetDriver = 0x10 // NetDriver* (Size: 0x8)
LevelCollection.DemoNetDriver = 0x18 // DemoNetDriver* (Size: 0x8)
LevelCollection.PersistentLevel = 0x20 // Level* (Size: 0x8)
LevelCollection.Levels = 0x28 // TSet<...> (Size: 0x50)
LevelNameAndTime.LevelName = 0x0 // FString (Size: 0x10)
LevelNameAndTime.LevelChangeTimeInMS = 0x10 // uint32_t (Size: 0x4)
LevelScriptActor.bInputEnabled = 0x310 // uint8_t (Size: 0x1)
LevelSimplificationDetails.bCreatePackagePerAsset = 0x0 // bool (Size: 0x1)
LevelSimplificationDetails.DetailsPercentage = 0x4 // float (Size: 0x4)
LevelSimplificationDetails.StaticMeshMaterialSettings = 0x8 // FMaterialProxySettings (Size: 0x90)
LevelSimplificationDetails.bOverrideLandscapeExportLOD = 0x98 // bool (Size: 0x1)
LevelSimplificationDetails.LandscapeExportLOD = 0x9c // int32_t (Size: 0x4)
LevelSimplificationDetails.LandscapeMaterialSettings = 0xa0 // FMaterialProxySettings (Size: 0x90)
LevelSimplificationDetails.bBakeFoliageToLandscape = 0x130 // bool (Size: 0x1)
LevelSimplificationDetails.bBakeGrassToLandscape = 0x131 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateMeshNormalMap = 0x132 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateMeshMetallicMap = 0x133 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateMeshRoughnessMap = 0x134 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateMeshSpecularMap = 0x135 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateLandscapeNormalMap = 0x136 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateLandscapeMetallicMap = 0x137 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateLandscapeRoughnessMap = 0x138 // bool (Size: 0x1)
LevelSimplificationDetails.bGenerateLandscapeSpecularMap = 0x139 // bool (Size: 0x1)
LevelStreaming.WorldAsset = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
LevelStreaming.PackageNameToLoad = 0x50 // FName (Size: 0x8)
LevelStreaming.LODPackageNames = 0x58 // TArray<FName> (Size: 0x10)
LevelStreaming.LevelTransform = 0x80 // FTransform (Size: 0x30)
LevelStreaming.LevelLODIndex = 0xb0 // int32_t (Size: 0x4)
LevelStreaming.StreamingPriority = 0xb4 // int32_t (Size: 0x4)
LevelStreaming.bShouldBeVisible = 0xba // uint8_t (Size: 0x1)
LevelStreaming.bShouldBeLoaded = 0xba // uint8_t (Size: 0x1)
LevelStreaming.bLocked = 0xba // uint8_t (Size: 0x1)
LevelStreaming.bIsStatic = 0xba // uint8_t (Size: 0x1)
LevelStreaming.bShouldBlockOnLoad = 0xba // uint8_t (Size: 0x1)
LevelStreaming.bShouldBlockOnUnload = 0xbb // uint8_t (Size: 0x1)
LevelStreaming.bDisableDistanceStreaming = 0xbb // uint8_t (Size: 0x1)
LevelStreaming.bDrawOnLevelStatusMap = 0xbb // uint8_t (Size: 0x1)
LevelStreaming.LevelColor = 0xbc // FLinearColor (Size: 0x10)
LevelStreaming.EditorStreamingVolumes = 0xd0 // TArray<LevelStreamingVolume*> (Size: 0x10)
LevelStreaming.MinTimeBetweenVolumeUnloadRequests = 0xe0 // float (Size: 0x4)
LevelStreaming.OnLevelLoaded = 0xe8 // FMulticastInlineDelegate (Size: 0x10)
LevelStreaming.OnLevelUnloaded = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
LevelStreaming.OnLevelShown = 0x108 // FMulticastInlineDelegate (Size: 0x10)
LevelStreaming.OnLevelHidden = 0x118 // FMulticastInlineDelegate (Size: 0x10)
LevelStreaming.LoadedLevel = 0x128 // Level* (Size: 0x8)
LevelStreaming.PendingUnloadLevel = 0x130 // Level* (Size: 0x8)
LevelStreamingDynamic.bInitiallyLoaded = 0x148 // uint8_t (Size: 0x1)
LevelStreamingDynamic.bInitiallyVisible = 0x148 // uint8_t (Size: 0x1)
LevelStreamingStatus.PackageName = 0x0 // FName (Size: 0x8)
LevelStreamingStatus.bShouldBeLoaded = 0x8 // uint8_t (Size: 0x1)
LevelStreamingStatus.bShouldBeVisible = 0x8 // uint8_t (Size: 0x1)
LevelStreamingStatus.LODIndex = 0xc // uint32_t (Size: 0x4)
LevelStreamingVolume.StreamingLevelFilterStrings = 0x348 // TArray<FString> (Size: 0x10)
LevelStreamingVolume.StreamingLevelIgnoreStrings = 0x358 // TArray<FString> (Size: 0x10)
LevelStreamingVolume.bExcludeWorldComposition = 0x368 // uint8_t (Size: 0x1)
LevelStreamingVolume.StreamingLevelNames = 0x370 // TArray<FName> (Size: 0x10)
LevelStreamingVolume.bEditorPreVisOnly = 0x380 // uint8_t (Size: 0x1)
LevelStreamingVolume.bDisabled = 0x380 // uint8_t (Size: 0x1)
LevelStreamingVolume.StreamingUsage = 0x384 // uint8_t (Size: 0x1)
LevelViewportInfo.CamPosition = 0x0 // FVector (Size: 0xc)
LevelViewportInfo.CamRotation = 0xc // FRotator (Size: 0xc)
LevelViewportInfo.CamOrthoZoom = 0x18 // float (Size: 0x4)
LevelViewportInfo.CamUpdated = 0x1c // bool (Size: 0x1)
Light.LightComponent = 0x310 // LightComponent* (Size: 0x8)
Light.bEnabled = 0x318 // uint8_t (Size: 0x1)
LightComponent.Temperature = 0x278 // float (Size: 0x4)
LightComponent.MaxDrawDistance = 0x27c // float (Size: 0x4)
LightComponent.MaxDistanceFadeRange = 0x280 // float (Size: 0x4)
LightComponent.bUseTemperature = 0x284 // uint8_t (Size: 0x1)
LightComponent.ShadowMapChannel = 0x288 // int32_t (Size: 0x4)
LightComponent.MinRoughness = 0x290 // float (Size: 0x4)
LightComponent.SpecularScale = 0x294 // float (Size: 0x4)
LightComponent.ShadowResolutionScale = 0x298 // float (Size: 0x4)
LightComponent.ShadowBias = 0x29c // float (Size: 0x4)
LightComponent.ShadowSlopeBias = 0x2a0 // float (Size: 0x4)
LightComponent.ShadowReceiverBias = 0x2a4 // float (Size: 0x4)
LightComponent.ShadowReceiverNormalBias = 0x2a8 // float (Size: 0x4)
LightComponent.ShadowSharpen = 0x2ac // float (Size: 0x4)
LightComponent.ContactShadowLength = 0x2b0 // float (Size: 0x4)
LightComponent.ContactShadowLengthInWS = 0x2b4 // uint8_t (Size: 0x1)
LightComponent.InverseSquaredFalloff = 0x2b4 // uint8_t (Size: 0x1)
LightComponent.CastTranslucentShadows = 0x2b4 // uint8_t (Size: 0x1)
LightComponent.ContactHardeningShadow = 0x2b4 // uint8_t (Size: 0x1)
LightComponent.MinPenumbraScale = 0x2b8 // float (Size: 0x4)
LightComponent.MaxPenumbraScale = 0x2bc // float (Size: 0x4)
LightComponent.MinOccluderDepth = 0x2c0 // float (Size: 0x4)
LightComponent.MaxOccluderDepth = 0x2c4 // float (Size: 0x4)
LightComponent.bCastShadowsFromCinematicObjectsOnly = 0x2c8 // uint8_t (Size: 0x1)
LightComponent.bAffectDynamicIndirectLighting = 0x2c8 // uint8_t (Size: 0x1)
LightComponent.bForceCachedShadowsForMovablePrimitives = 0x2c8 // uint8_t (Size: 0x1)
LightComponent.bLightingFoliage = 0x2c8 // uint8_t (Size: 0x1)
LightComponent.bVisibleInScalabilityCine = 0x2cc // uint8_t (Size: 0x1)
LightComponent.bVisibleInScalabilityVeryHigh = 0x2cc // uint8_t (Size: 0x1)
LightComponent.bVisibleInScalabilityHigh = 0x2cc // uint8_t (Size: 0x1)
LightComponent.bVisibleInScalabilityNormal = 0x2cc // uint8_t (Size: 0x1)
LightComponent.bVisibleInScalabilityLow = 0x2cc // uint8_t (Size: 0x1)
LightComponent.bIgnoreMaxLightCount = 0x2cc // uint8_t (Size: 0x1)
LightComponent.LightingChannels = 0x2cd // FLightingChannels (Size: 0x1)
LightComponent.LightFunctionMaterial = 0x2d0 // MaterialInterface* (Size: 0x8)
LightComponent.LightFunctionScale = 0x2d8 // FVector (Size: 0xc)
LightComponent.IESTexture = 0x2e8 // TextureLightProfile* (Size: 0x8)
LightComponent.bUseIESBrightness = 0x2f0 // uint8_t (Size: 0x1)
LightComponent.IESBrightnessScale = 0x2f4 // float (Size: 0x4)
LightComponent.LightFunctionFadeDistance = 0x2f8 // float (Size: 0x4)
LightComponent.DisabledBrightness = 0x2fc // float (Size: 0x4)
LightComponent.bEnableLightShaftBloom = 0x300 // uint8_t (Size: 0x1)
LightComponent.BloomScale = 0x304 // float (Size: 0x4)
LightComponent.BloomThreshold = 0x308 // float (Size: 0x4)
LightComponent.BloomMaxBrightness = 0x30c // float (Size: 0x4)
LightComponent.BloomTint = 0x310 // FColor (Size: 0x4)
LightComponent.bTranslucentLocalLightShadow = 0x314 // uint8_t (Size: 0x1)
LightComponent.bUseRayTracedDistanceFieldShadows = 0x318 // bool (Size: 0x1)
LightComponent.DistanceFieldShadowObjectCullSize = 0x31c // float (Size: 0x4)
LightComponent.RayStartOffsetDepthScale = 0x320 // float (Size: 0x4)
LightComponent.ShadowCastHiddenComponents = 0x328 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
LightComponentBase.LightGuid = 0x238 // FGuid (Size: 0x10)
LightComponentBase.Brightness = 0x248 // float (Size: 0x4)
LightComponentBase.Intensity = 0x24c // float (Size: 0x4)
LightComponentBase.LightColor = 0x250 // FColor (Size: 0x4)
LightComponentBase.bAffectsWorld = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.CastShadows = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.CastStaticShadows = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.CastDynamicShadows = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.bAffectTranslucentLighting = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.bTransmission = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.bCastVolumetricShadow = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.bCastDeepShadow = 0x254 // uint8_t (Size: 0x1)
LightComponentBase.bCastRaytracedShadow = 0x255 // uint8_t (Size: 0x1)
LightComponentBase.bAffectReflection = 0x255 // uint8_t (Size: 0x1)
LightComponentBase.bAffectGlobalIllumination = 0x255 // uint8_t (Size: 0x1)
LightComponentBase.DeepShadowLayerDistribution = 0x258 // float (Size: 0x4)
LightComponentBase.IndirectLightingIntensity = 0x25c // float (Size: 0x4)
LightComponentBase.ExtraIndirectLightingSaturation = 0x260 // float (Size: 0x4)
LightComponentBase.VolumetricScatteringIntensity = 0x264 // float (Size: 0x4)
LightComponentBase.GlobalDFShadowSettings = 0x268 // FGlobalDFShadowSettings (Size: 0xc)
LightComponentBase.SamplesPerPixel = 0x274 // int32_t (Size: 0x4)
LightMapVirtualTexture2D.TypeToLayer = 0x118 // TArray<int8_t> (Size: 0x10)
LightingChannels.bChannel0 = 0x0 // uint8_t (Size: 0x1)
LightingChannels.bChannel1 = 0x0 // uint8_t (Size: 0x1)
LightingChannels.bChannel2 = 0x0 // uint8_t (Size: 0x1)
LightmappedSurfaceCollection.SourceModel = 0x28 // Model* (Size: 0x8)
LightmappedSurfaceCollection.Surfaces = 0x30 // TArray<int32_t> (Size: 0x10)
LightmassDebugOptions.bDebugMode = 0x0 // uint8_t (Size: 0x1)
LightmassDebugOptions.bStatsEnabled = 0x0 // uint8_t (Size: 0x1)
LightmassDebugOptions.bGatherBSPSurfacesAcrossComponents = 0x0 // uint8_t (Size: 0x1)
LightmassDebugOptions.CoplanarTolerance = 0x4 // float (Size: 0x4)
LightmassDebugOptions.bUseImmediateImport = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bImmediateProcessMappings = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bSortMappings = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bDumpBinaryFiles = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bDebugMaterials = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bPadMappings = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bDebugPaddings = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bOnlyCalcDebugTexelMappings = 0x8 // uint8_t (Size: 0x1)
LightmassDebugOptions.bUseRandomColors = 0x9 // uint8_t (Size: 0x1)
LightmassDebugOptions.bColorBordersGreen = 0x9 // uint8_t (Size: 0x1)
LightmassDebugOptions.bColorByExecutionTime = 0x9 // uint8_t (Size: 0x1)
LightmassDebugOptions.ExecutionTimeDivisor = 0xc // float (Size: 0x4)
LightmassDirectionalLightSettings.LightSourceAngle = 0xc // float (Size: 0x4)
LightmassDivideVolume.VolumeUniqueId = 0x348 // uint32_t (Size: 0x4)
LightmassDivideVolume.bUseToDivideILC = 0x34c // uint8_t (Size: 0x1)
LightmassDivideVolume.bUseToOcclusionILC = 0x34c // uint8_t (Size: 0x1)
LightmassDivideVolume.bForceDiscardNearbyILCOutsideVolume = 0x34c // uint8_t (Size: 0x1)
LightmassDivideVolume.EdgeScale = 0x350 // float (Size: 0x4)
LightmassInteriorMaskActor.Maskid = 0x348 // uint32_t (Size: 0x4)
LightmassInteriorMaskActor.bIsGlobalMask = 0x34c // uint8_t (Size: 0x1)
LightmassInteriorMaskActor.bUseToDivideILC = 0x350 // uint8_t (Size: 0x1)
LightmassInteriorMaskActor.bUseToOcclusionILC = 0x350 // uint8_t (Size: 0x1)
LightmassLightSettings.IndirectLightingSaturation = 0x0 // float (Size: 0x4)
LightmassLightSettings.ShadowExponent = 0x4 // float (Size: 0x4)
LightmassLightSettings.bUseAreaShadowsForStationaryLight = 0x8 // bool (Size: 0x1)
LightmassMaterialInterfaceSettings.EmissiveBoost = 0x0 // float (Size: 0x4)
LightmassMaterialInterfaceSettings.DiffuseBoost = 0x4 // float (Size: 0x4)
LightmassMaterialInterfaceSettings.ExportResolutionScale = 0x8 // float (Size: 0x4)
LightmassMaterialInterfaceSettings.bCastShadowAsMasked = 0xc // uint8_t (Size: 0x1)
LightmassMaterialInterfaceSettings.bOverrideCastShadowAsMasked = 0xc // uint8_t (Size: 0x1)
LightmassMaterialInterfaceSettings.bOverrideEmissiveBoost = 0xc // uint8_t (Size: 0x1)
LightmassMaterialInterfaceSettings.bOverrideDiffuseBoost = 0xc // uint8_t (Size: 0x1)
LightmassMaterialInterfaceSettings.bOverrideExportResolutionScale = 0xc // uint8_t (Size: 0x1)
LightmassMaterialInterfaceSettings.SpecialMode = 0xd // uint8_t (Size: 0x1)
LightmassPortal.PortalComponent = 0x310 // LightmassPortalComponent* (Size: 0x8)
LightmassPortalComponent.PreviewBox = 0x238 // BoxComponent* (Size: 0x8)
LightmassPrimitiveSettings.bUseTwoSidedLighting = 0x0 // uint8_t (Size: 0x1)
LightmassPrimitiveSettings.bShadowIndirectOnly = 0x0 // uint8_t (Size: 0x1)
LightmassPrimitiveSettings.bUseEmissiveForStaticLighting = 0x0 // uint8_t (Size: 0x1)
LightmassPrimitiveSettings.bUseVertexNormalForHemisphereGather = 0x0 // uint8_t (Size: 0x1)
LightmassPrimitiveSettings.EmissiveLightFalloffExponent = 0x4 // float (Size: 0x4)
LightmassPrimitiveSettings.EmissiveLightExplicitInfluenceRadius = 0x8 // float (Size: 0x4)
LightmassPrimitiveSettings.EmissiveBoost = 0xc // float (Size: 0x4)
LightmassPrimitiveSettings.DiffuseBoost = 0x10 // float (Size: 0x4)
LightmassPrimitiveSettings.FullyOccludedSamplesFraction = 0x14 // float (Size: 0x4)
LightmassPrimitiveSettingsObject.LightmassSettings = 0x28 // FLightmassPrimitiveSettings (Size: 0x18)
LightmassWorldInfoSettings.StaticLightingLevelScale = 0x0 // float (Size: 0x4)
LightmassWorldInfoSettings.NumIndirectLightingBounces = 0x4 // int32_t (Size: 0x4)
LightmassWorldInfoSettings.NumSkyLightingBounces = 0x8 // int32_t (Size: 0x4)
LightmassWorldInfoSettings.IndirectLightingQuality = 0xc // float (Size: 0x4)
LightmassWorldInfoSettings.IndirectLightingSmoothness = 0x10 // float (Size: 0x4)
LightmassWorldInfoSettings.EnvironmentColor = 0x14 // FColor (Size: 0x4)
LightmassWorldInfoSettings.EnvironmentIntensity = 0x18 // float (Size: 0x4)
LightmassWorldInfoSettings.EmissiveBoost = 0x1c // float (Size: 0x4)
LightmassWorldInfoSettings.DiffuseBoost = 0x20 // float (Size: 0x4)
LightmassWorldInfoSettings.VolumeLightingMethod = 0x24 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bUseAmbientOcclusion = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bGenerateAmbientOcclusionMaterialMask = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bVisualizeMaterialDiffuse = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bVisualizeAmbientOcclusion = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bCompressLightmaps = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bPackSkyVisibilityIntoLQLightmap = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bNoLightmapForLandscape = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bNoShadowmap = 0x25 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.bBuildStaticShadowMaskForLightmap = 0x26 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.VolumetricLightmapDetailCellSize = 0x28 // float (Size: 0x4)
LightmassWorldInfoSettings.VolumetricLightmapMaximumBrickMemoryMb = 0x2c // float (Size: 0x4)
LightmassWorldInfoSettings.VolumetricLightmapSphericalHarmonicSmoothing = 0x30 // float (Size: 0x4)
LightmassWorldInfoSettings.bVolumetricLightmapFilterForBorder = 0x34 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.VolumeLightSamplePlacementScale = 0x38 // float (Size: 0x4)
LightmassWorldInfoSettings.VolumeLightSampleSmoothing = 0x3c // float (Size: 0x4)
LightmassWorldInfoSettings.bDiscardExteriorVolumeLightSamples = 0x40 // uint8_t (Size: 0x1)
LightmassWorldInfoSettings.DirectIlluminationOcclusionFraction = 0x44 // float (Size: 0x4)
LightmassWorldInfoSettings.IndirectIlluminationOcclusionFraction = 0x48 // float (Size: 0x4)
LightmassWorldInfoSettings.OcclusionExponent = 0x4c // float (Size: 0x4)
LightmassWorldInfoSettings.FullyOccludedSamplesFraction = 0x50 // float (Size: 0x4)
LightmassWorldInfoSettings.MaxOcclusionDistance = 0x54 // float (Size: 0x4)
LinearConstraint.Limit = 0x14 // float (Size: 0x4)
LinearConstraint.XMotion = 0x18 // uint8_t (Size: 0x1)
LinearConstraint.YMotion = 0x19 // uint8_t (Size: 0x1)
LinearConstraint.ZMotion = 0x1a // uint8_t (Size: 0x1)
LinearDriveConstraint.PositionTarget = 0x0 // FVector (Size: 0xc)
LinearDriveConstraint.VelocityTarget = 0xc // FVector (Size: 0xc)
LinearDriveConstraint.XDrive = 0x18 // FConstraintDrive (Size: 0x10)
LinearDriveConstraint.YDrive = 0x28 // FConstraintDrive (Size: 0x10)
LinearDriveConstraint.ZDrive = 0x38 // FConstraintDrive (Size: 0x10)
LinearDriveConstraint.bEnablePositionDrive = 0x48 // uint8_t (Size: 0x1)
LocalLightComponent.LocalLightID = 0x3a8 // int32_t (Size: 0x4)
LocalLightComponent.SampleRadius = 0x3ac // int32_t (Size: 0x4)
LocalLightComponent.IntensityUnits = 0x3b0 // EELightUnits (Size: 0x1)
LocalLightComponent.Radius = 0x3b4 // float (Size: 0x4)
LocalLightComponent.AttenuationRadius = 0x3b8 // float (Size: 0x4)
LocalLightComponent.LightmassSettings = 0x3bc // FLightmassPointLightSettings (Size: 0xc)
LocalLightComponent.ShadowDetailMode = 0x3c8 // EEShadowDetailMode (Size: 0x1)
LocalLightComponent.LocalLightOcclusionData = 0x3d0 // FLocalLightOcclusionData (Size: 0x28)
LocalLightOcclusionData.Radius = 0x0 // float (Size: 0x4)
LocalLightOcclusionData.VertexArray = 0x8 // TArray<FVector> (Size: 0x10)
LocalLightOcclusionData.IndexArray = 0x18 // TArray<uint16_t> (Size: 0x10)
LocalPlayer.ViewportClient = 0x70 // GameViewportClient* (Size: 0x8)
LocalPlayer.AspectRatioAxisConstraint = 0x94 // uint8_t (Size: 0x1)
LocalPlayer.PendingLevelPlayerControllerClass = 0x98 // ClassProperty (Size: 0x8)
LocalPlayer.bSentSplitJoin = 0xa0 // uint8_t (Size: 0x1)
LocalPlayer.ControllerId = 0xb8 // int32_t (Size: 0x4)
LocalSpacePose.Transforms = 0x0 // TArray<FTransform> (Size: 0x10)
LocalSpacePose.Names = 0x10 // TArray<FName> (Size: 0x10)
LocationBoneSocketInfo.BoneSocketName = 0x0 // FName (Size: 0x8)
LocationBoneSocketInfo.Offset = 0x8 // FVector (Size: 0xc)
MFAmbientGIActor.GIComponent = 0x310 // MFAmbientGIComponent* (Size: 0x8)
MFAmbientGIComponent.BounceIntensity = 0x238 // float (Size: 0x4)
MFAmbientGIComponent.BounceIntensityBackFace = 0x23c // float (Size: 0x4)
MFAmbientGIComponent.BounceFalloffDistance = 0x240 // float (Size: 0x4)
MFAmbientGIComponent.SkyLowerHemispherePatchIntensity = 0x244 // float (Size: 0x4)
MFAmbientGIComponent.SkyLowerHemispherePatchMargin = 0x248 // float (Size: 0x4)
MFAmbientGIComponent.IVGridSize = 0x24c // float (Size: 0x4)
MFAmbientGIComponent.IVGridSurfaceBias = 0x250 // float (Size: 0x4)
MFAmbientGIComponent.IVGridViewBias = 0x254 // float (Size: 0x4)
MFAmbientGIComponent.AOFalloffDistance = 0x258 // float (Size: 0x4)
MFAmbientGIComponent.AOConeTraceHalfAngle = 0x25c // float (Size: 0x4)
MFAmbientGIComponent.AOPositionBias = 0x260 // float (Size: 0x4)
MFAmbientGIComponent.AORayBias = 0x264 // float (Size: 0x4)
MFAmbientGIComponent.SkyLightOcclusionMin = 0x268 // float (Size: 0x4)
MFAmbientGIComponent.SkyLightOcclusionMax = 0x26c // float (Size: 0x4)
MFAmbientGIComponent.FoliageTraceWrapping = 0x270 // float (Size: 0x4)
MFAmbientGIComponent.bReduceSkyReflection = 0x274 // bool (Size: 0x1)
MFAmbientGIComponent.UserData = 0x278 // int32_t (Size: 0x4)
MFGpuDrivenMeshSettings.Type = 0x0 // EEMFGpuDrivenMeshType (Size: 0x1)
MTDResult.Direction = 0x0 // FVector (Size: 0xc)
MTDResult.Distance = 0xc // float (Size: 0x4)
MapBuildDataRegistry.LevelLightingQuality = 0x28 // uint8_t (Size: 0x1)
MarkerSyncAnimPosition.PreviousMarkerName = 0x0 // FName (Size: 0x8)
MarkerSyncAnimPosition.NextMarkerName = 0x8 // FName (Size: 0x8)
MarkerSyncAnimPosition.PositionBetweenMarkers = 0x10 // float (Size: 0x4)
MarkerSyncData.AuthoredSyncMarkers = 0x0 // TArray<FAnimSyncMarker> (Size: 0x10)
Material.PhysMaterial = 0x90 // PhysicalMaterial* (Size: 0x8)
Material.PhysMaterialMask = 0x98 // PhysicalMaterialMask* (Size: 0x8)
Material.PhysicalMaterialMap = 0xa0 // PhysicalMaterial* (Size: 0x8)
Material.Metallic = 0xe0 // FScalarMaterialInput (Size: 0xc)
Material.Specular = 0xf4 // FScalarMaterialInput (Size: 0xc)
Material.Anisotropy = 0x108 // FScalarMaterialInput (Size: 0xc)
Material.Normal = 0x11c // FVectorMaterialInput (Size: 0xc)
Material.Tangent = 0x130 // FVectorMaterialInput (Size: 0xc)
Material.EmissiveColor = 0x144 // FColorMaterialInput (Size: 0xc)
Material.MaterialDomain = 0x158 // uint8_t (Size: 0x1)
Material.BlendMode = 0x159 // uint8_t (Size: 0x1)
Material.DecalBlendMode = 0x15a // uint8_t (Size: 0x1)
Material.MaterialDecalResponse = 0x15b // uint8_t (Size: 0x1)
Material.ShadingModel = 0x15c // uint8_t (Size: 0x1)
Material.MaterialDynamicModes = 0x160 // TArray<uint8_t> (Size: 0x10)
Material.bCastDynamicShadowAsMasked = 0x170 // uint8_t (Size: 0x1)
Material.ShadingModels = 0x172 // FMaterialShadingModelField (Size: 0x2)
Material.OpacityMaskClipValue = 0x174 // float (Size: 0x4)
Material.DirLightShadowBiasMethodOverride = 0x178 // uint8_t (Size: 0x1)
Material.ScreenSpaceVariance = 0x17c // float (Size: 0x4)
Material.Threshold = 0x180 // float (Size: 0x4)
Material.WorldPositionOffset = 0x184 // FVectorMaterialInput (Size: 0xc)
Material.Refraction = 0x198 // FScalarMaterialInput (Size: 0xc)
Material.MaterialAttributes = 0x1b0 // FMaterialAttributesInput (Size: 0x18)
Material.PixelDepthOffset = 0x1d0 // FScalarMaterialInput (Size: 0xc)
Material.ShadingModelFromMaterialExpression = 0x1e4 // FShadingModelMaterialInput (Size: 0xc)
Material.bEnableSeparateTranslucency = 0x1f8 // uint8_t (Size: 0x1)
Material.bEnableResponsiveAA = 0x1f8 // uint8_t (Size: 0x1)
Material.bScreenSpaceReflections = 0x1f8 // uint8_t (Size: 0x1)
Material.bContactShadows = 0x1f8 // uint8_t (Size: 0x1)
Material.TwoSided = 0x1f8 // uint8_t (Size: 0x1)
Material.DitheredLODTransition = 0x1f8 // uint8_t (Size: 0x1)
Material.DitherOpacityMask = 0x1f8 // uint8_t (Size: 0x1)
Material.bAllowNegativeEmissiveColor = 0x1f8 // uint8_t (Size: 0x1)
Material.TranslucencyLightingMode = 0x1f9 // uint8_t (Size: 0x1)
Material.bEnableMobileSeparateTranslucency = 0x1fa // uint8_t (Size: 0x1)
Material.NumCustomizedUVs = 0x1fc // int32_t (Size: 0x4)
Material.NumCustomDataVector = 0x200 // int32_t (Size: 0x4)
Material.TranslucencyDirectionalLightingIntensity = 0x204 // float (Size: 0x4)
Material.TranslucentShadowDensityScale = 0x208 // float (Size: 0x4)
Material.TranslucentSelfShadowDensityScale = 0x20c // float (Size: 0x4)
Material.TranslucentSelfShadowSecondDensityScale = 0x210 // float (Size: 0x4)
Material.TranslucentSelfShadowSecondOpacity = 0x214 // float (Size: 0x4)
Material.TranslucentBackscatteringExponent = 0x218 // float (Size: 0x4)
Material.TranslucentMultipleScatteringExtinction = 0x21c // FLinearColor (Size: 0x10)
Material.TranslucentShadowStartOffset = 0x22c // float (Size: 0x4)
Material.TranslucencySortPriorityOffset = 0x230 // int16_t (Size: 0x2)
Material.MaterialStencilTypeForMpe = 0x232 // int16_t (Size: 0x2)
Material.bDisableDepthTest = 0x234 // uint8_t (Size: 0x1)
Material.bWriteOnlyAlpha = 0x234 // uint8_t (Size: 0x1)
Material.bGenerateSphericalParticleNormals = 0x234 // uint8_t (Size: 0x1)
Material.bTangentSpaceNormal = 0x234 // uint8_t (Size: 0x1)
Material.bUseEmissiveForDynamicAreaLighting = 0x234 // uint8_t (Size: 0x1)
Material.bBlockGI = 0x234 // uint8_t (Size: 0x1)
Material.bUsedAsSpecialEngineMaterial = 0x234 // uint8_t (Size: 0x1)
Material.bUsedWithSkeletalMesh = 0x234 // uint8_t (Size: 0x1)
Material.bUsedWithEditorCompositing = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithParticleSprites = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithBeamTrails = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithMeshParticles = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithNiagaraSprites = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithNiagaraRibbons = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithNiagaraMeshParticles = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithGeometryCache = 0x235 // uint8_t (Size: 0x1)
Material.bUsedWithStaticLighting = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithMorphTargets = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithSplineMeshes = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithInstancedStaticMeshes = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithMergedInstancedStaticMeshes = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithGeometryCollections = 0x236 // uint8_t (Size: 0x1)
Material.bUsesDistortion = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithClothing = 0x236 // uint8_t (Size: 0x1)
Material.bUsedWithWater = 0x238 // uint8_t (Size: 0x1)
Material.bUsedWithHairStrands = 0x238 // uint8_t (Size: 0x1)
Material.bUsedWithLidarPointCloud = 0x238 // uint8_t (Size: 0x1)
Material.bUsedWithVirtualHeightfieldMesh = 0x238 // uint8_t (Size: 0x1)
Material.bUsedWithUI = 0x23c // uint8_t (Size: 0x1)
Material.bAutomaticallySetUsageInEditor = 0x23c // uint8_t (Size: 0x1)
Material.bFullyRough = 0x23c // uint8_t (Size: 0x1)
Material.bUseDBuffer = 0x23c // uint8_t (Size: 0x1)
Material.bMaterialWiseOutputVelocity = 0x23c // uint8_t (Size: 0x1)
Material.bForwardShadingVoxelReflection = 0x23c // uint8_t (Size: 0x1)
Material.bForceDisableILC = 0x23c // uint8_t (Size: 0x1)
Material.bForceDisableDynamicLightShadow = 0x23c // uint8_t (Size: 0x1)
Material.bForceEnableTwoSidedFoliageDBufferInput = 0x23d // uint8_t (Size: 0x1)
Material.bMaterialOnlyBeUsedOutdoor = 0x23d // uint8_t (Size: 0x1)
Material.bUseVolumetricDistanceMap = 0x23d // uint8_t (Size: 0x1)
Material.bDisableVRS = 0x23d // uint8_t (Size: 0x1)
Material.bDisableBindlessVertexColor = 0x23d // uint8_t (Size: 0x1)
Material.bDisableBindlessLightmap = 0x23d // uint8_t (Size: 0x1)
Material.bUseFullPrecision = 0x23d // uint8_t (Size: 0x1)
Material.FloatPrecisionMode = 0x23e // uint8_t (Size: 0x1)
Material.FloatPrecisionModeVulkanOverride = 0x23f // uint8_t (Size: 0x1)
Material.bUseFullPrecisionPreZOnly = 0x240 // uint8_t (Size: 0x1)
Material.bUseFullPrecisionSpecular = 0x240 // uint8_t (Size: 0x1)
Material.bUseFullPrecisionUniform = 0x240 // uint8_t (Size: 0x1)
Material.bUseLightmapDirectionality = 0x240 // uint8_t (Size: 0x1)
Material.bUseAlphaToCoverage = 0x240 // uint8_t (Size: 0x1)
Material.bForwardRenderUsePreintegratedGFForSimpleIBL = 0x244 // uint8_t (Size: 0x1)
Material.bMobilePointLightSSSEnable = 0x248 // uint8_t (Size: 0x1)
Material.MobilePreIntegratedBRDFLUT = 0x250 // Texture2D* (Size: 0x8)
Material.bRenderInEarlyDepthPass = 0x258 // uint8_t (Size: 0x1)
Material.bDisableInstancing = 0x258 // uint8_t (Size: 0x1)
Material.bUseHQForwardReflections = 0x258 // uint8_t (Size: 0x1)
Material.bUsePlanarForwardReflections = 0x258 // uint8_t (Size: 0x1)
Material.bForceDisableAdditiveReflection = 0x258 // uint8_t (Size: 0x1)
Material.bForceDisableLocalTonemapping = 0x258 // uint8_t (Size: 0x1)
Material.bNormalCurvatureToRoughness = 0x258 // uint8_t (Size: 0x1)
Material.D3D11TessellationMode = 0x259 // uint8_t (Size: 0x1)
Material.bEnableCrackFreeDisplacement = 0x25a // uint8_t (Size: 0x1)
Material.bEnableAdaptiveTessellation = 0x25a // uint8_t (Size: 0x1)
Material.AllowTranslucentCustomDepthWrites = 0x25a // uint8_t (Size: 0x1)
Material.Wireframe = 0x25a // uint8_t (Size: 0x1)
Material.ShadingRate = 0x25b // uint8_t (Size: 0x1)
Material.MaxShadingRate = 0x25c // uint8_t (Size: 0x1)
Material.bForceDXC = 0x25d // uint8_t (Size: 0x1)
Material.bAllowInlineRayTracing = 0x25d // uint8_t (Size: 0x1)
Material.bCanMaskedBeAssumedOpaque = 0x25d // uint8_t (Size: 0x1)
Material.bIsMasked = 0x25d // uint8_t (Size: 0x1)
Material.bIsPreviewMaterial = 0x25d // uint8_t (Size: 0x1)
Material.bIsFunctionPreviewMaterial = 0x25d // uint8_t (Size: 0x1)
Material.bUseMaterialAttributes = 0x25d // uint8_t (Size: 0x1)
Material.bCastRayTracedShadows = 0x25d // uint8_t (Size: 0x1)
Material.bUseTranslucencyVertexFog = 0x25e // uint8_t (Size: 0x1)
Material.bApplyCloudFogging = 0x25e // uint8_t (Size: 0x1)
Material.bMobileHair = 0x25e // uint8_t (Size: 0x1)
Material.bIsMainCharForMpe = 0x25e // uint8_t (Size: 0x1)
Material.bIsSky = 0x25e // uint8_t (Size: 0x1)
Material.bComputeFogPerPixel = 0x25e // uint8_t (Size: 0x1)
Material.bOutputTranslucentVelocity = 0x25e // uint8_t (Size: 0x1)
Material.bAllowDevelopmentShaderCompile = 0x25e // uint8_t (Size: 0x1)
Material.bIsMaterialEditorStatsMaterial = 0x25f // uint8_t (Size: 0x1)
Material.BlendableLocation = 0x260 // uint8_t (Size: 0x1)
Material.BlendableOutputAlpha = 0x261 // uint8_t (Size: 0x1)
Material.bEnableStencilTest = 0x261 // uint8_t (Size: 0x1)
Material.StencilCompare = 0x262 // uint8_t (Size: 0x1)
Material.StencilRefValue = 0x263 // uint8_t (Size: 0x1)
Material.RefractionMode = 0x264 // uint8_t (Size: 0x1)
Material.BlendablePriority = 0x268 // int32_t (Size: 0x4)
Material.bIsBlendable = 0x26c // uint8_t (Size: 0x1)
Material.bIsForceIgnoreBlend = 0x26d // bool (Size: 0x1)
Material.bForceResolveDepth = 0x26e // uint8_t (Size: 0x1)
Material.WriteToInput = 0x26f // uint8_t (Size: 0x1)
Material.UsageFlagWarnings = 0x270 // uint32_t (Size: 0x4)
Material.RefractionDepthBias = 0x274 // float (Size: 0x4)
Material.StateId = 0x278 // FGuid (Size: 0x10)
Material.MaxDisplacement = 0x288 // float (Size: 0x4)
Material.CachedExpressionData = 0x2c0 // FMaterialCachedExpressionData (Size: 0x228)
MaterialAttributesInput.PropertyConnectedBitmask = 0x10 // uint64_t (Size: 0x8)
MaterialBillboardComponent.Elements = 0x5c8 // TArray<FMaterialSpriteElement> (Size: 0x10)
MaterialCachedExpressionData.Parameters = 0x0 // FMaterialCachedParameters (Size: 0x1a0)
MaterialCachedExpressionData.ReferencedTextures = 0x1a0 // TArray<Object*> (Size: 0x10)
MaterialCachedExpressionData.FunctionInfos = 0x1b0 // TArray<FMaterialFunctionInfo> (Size: 0x10)
MaterialCachedExpressionData.ParameterCollectionInfos = 0x1c0 // TArray<FMaterialParameterCollectionInfo> (Size: 0x10)
MaterialCachedExpressionData.DefaultLayers = 0x1d0 // TArray<MaterialFunctionInterface*> (Size: 0x10)
MaterialCachedExpressionData.DefaultLayerBlends = 0x1e0 // TArray<MaterialFunctionInterface*> (Size: 0x10)
MaterialCachedExpressionData.GrassTypes = 0x1f0 // TArray<LandscapeGrassType*> (Size: 0x10)
MaterialCachedExpressionData.DynamicParameterNames = 0x200 // TArray<FName> (Size: 0x10)
MaterialCachedExpressionData.QualityLevelsUsed = 0x210 // TArray<bool> (Size: 0x10)
MaterialCachedExpressionData.bHasRuntimeVirtualTextureOutput = 0x220 // uint8_t (Size: 0x1)
MaterialCachedExpressionData.bHasSceneColor = 0x220 // uint8_t (Size: 0x1)
MaterialCachedParameterEntry.NameHashes = 0x0 // TArray<uint64_t> (Size: 0x10)
MaterialCachedParameterEntry.ParameterInfos = 0x10 // TArray<FMaterialParameterInfo> (Size: 0x10)
MaterialCachedParameterEntry.ExpressionGuids = 0x20 // TArray<FGuid> (Size: 0x10)
MaterialCachedParameterEntry.Overrides = 0x30 // TArray<bool> (Size: 0x10)
MaterialCachedParameters.RuntimeEntries = 0x0 // FMaterialCachedParameterEntry (Size: 0x40)
MaterialCachedParameters.ScalarValues = 0x140 // TArray<float> (Size: 0x10)
MaterialCachedParameters.VectorValues = 0x150 // TArray<FLinearColor> (Size: 0x10)
MaterialCachedParameters.TextureValues = 0x160 // TArray<Texture*> (Size: 0x10)
MaterialCachedParameters.FontValues = 0x170 // TArray<Font*> (Size: 0x10)
MaterialCachedParameters.FontPageValues = 0x180 // TArray<int32_t> (Size: 0x10)
MaterialCachedParameters.RuntimeVirtualTextureValues = 0x190 // TArray<RuntimeVirtualTexture*> (Size: 0x10)
MaterialEditorPromotionSettings.DefaultMaterialAsset = 0x0 // FFilePath (Size: 0x10)
MaterialEditorPromotionSettings.DefaultDiffuseTexture = 0x10 // FFilePath (Size: 0x10)
MaterialEditorPromotionSettings.DefaultNormalTexture = 0x20 // FFilePath (Size: 0x10)
MaterialExpression.Material = 0x28 // Material* (Size: 0x8)
MaterialExpression.Function = 0x30 // MaterialFunction* (Size: 0x8)
MaterialExpression.bIsParameterExpression = 0x38 // uint8_t (Size: 0x1)
MaterialExpressionAbs.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionAdd.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionAdd.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionAdd.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionAdd.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionAntialiasedTextureMask.Threshold = 0x80 // float (Size: 0x4)
MaterialExpressionAntialiasedTextureMask.Channel = 0x84 // uint8_t (Size: 0x1)
MaterialExpressionAppendVector.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionAppendVector.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionArccosine.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArccosineFast.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArcsine.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArcsineFast.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangent.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangent2.Y = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangent2.X = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangent2Fast.Y = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangent2Fast.X = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionArctangentFast.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionAtmosphericFogColor.WorldPosition = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionBentNormalCustomOutput.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionBlackBody.Temp = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionBlendMaterialAttributes.A = 0x40 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionBlendMaterialAttributes.B = 0x60 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionBlendMaterialAttributes.Alpha = 0x80 // FExpressionInput (Size: 0xc)
MaterialExpressionBlendMaterialAttributes.PixelAttributeBlendType = 0x94 // uint8_t (Size: 0x1)
MaterialExpressionBlendMaterialAttributes.VertexAttributeBlendType = 0x95 // uint8_t (Size: 0x1)
MaterialExpressionBreakMaterialAttributes.MaterialAttributes = 0x40 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionBumpOffset.coordinate = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionBumpOffset.Height = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionBumpOffset.HeightRatioInput = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionBumpOffset.HeightRatio = 0x7c // float (Size: 0x4)
MaterialExpressionBumpOffset.ReferencePlane = 0x80 // float (Size: 0x4)
MaterialExpressionBumpOffset.ConstCoordinate = 0x84 // uint32_t (Size: 0x4)
MaterialExpressionCAShadowSettingsOutput.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionCeil.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionChannelMaskParameter.MaskChannel = 0x70 // uint8_t (Size: 0x1)
MaterialExpressionClamp.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionClamp.Min = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionClamp.Max = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionClamp.ClampMode = 0x7c // uint8_t (Size: 0x1)
MaterialExpressionClamp.MinDefault = 0x80 // float (Size: 0x4)
MaterialExpressionClamp.MaxDefault = 0x84 // float (Size: 0x4)
MaterialExpressionClearCoatNormalCustomOutput.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionCollectionParameter.Collection = 0x40 // MaterialParameterCollection* (Size: 0x8)
MaterialExpressionCollectionParameter.ParameterName = 0x48 // FName (Size: 0x8)
MaterialExpressionCollectionParameter.ParameterId = 0x50 // FGuid (Size: 0x10)
MaterialExpressionComment.SizeX = 0x40 // int32_t (Size: 0x4)
MaterialExpressionComment.SizeY = 0x44 // int32_t (Size: 0x4)
MaterialExpressionComment.Text = 0x48 // FString (Size: 0x10)
MaterialExpressionComment.CommentColor = 0x58 // FLinearColor (Size: 0x10)
MaterialExpressionComment.FontSize = 0x68 // int32_t (Size: 0x4)
MaterialExpressionComponentMask.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionComponentMask.R = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionComponentMask.G = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionComponentMask.B = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionComponentMask.A = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionConstant.R = 0x40 // float (Size: 0x4)
MaterialExpressionConstant2Vector.R = 0x40 // float (Size: 0x4)
MaterialExpressionConstant2Vector.G = 0x44 // float (Size: 0x4)
MaterialExpressionConstant3Vector.Constant = 0x40 // FLinearColor (Size: 0x10)
MaterialExpressionConstant4Vector.Constant = 0x40 // FLinearColor (Size: 0x10)
MaterialExpressionConstantBiasScale.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionConstantBiasScale.Bias = 0x54 // float (Size: 0x4)
MaterialExpressionConstantBiasScale.Scale = 0x58 // float (Size: 0x4)
MaterialExpressionCosine.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionCosine.Period = 0x54 // float (Size: 0x4)
MaterialExpressionCrossProduct.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionCrossProduct.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionCurveAtlasRowParameter.Curve = 0x60 // CurveLinearColor* (Size: 0x8)
MaterialExpressionCurveAtlasRowParameter.Atlas = 0x68 // CurveLinearColorAtlas* (Size: 0x8)
MaterialExpressionCurveAtlasRowParameter.InputTime = 0x70 // FExpressionInput (Size: 0xc)
MaterialExpressionCustom.Code = 0x40 // FString (Size: 0x10)
MaterialExpressionCustom.OutputType = 0x50 // uint8_t (Size: 0x1)
MaterialExpressionCustom.Description = 0x58 // FString (Size: 0x10)
MaterialExpressionCustom.Inputs = 0x68 // TArray<FCustomInput> (Size: 0x10)
MaterialExpressionCustom.AdditionalOutputs = 0x78 // TArray<FCustomOutput> (Size: 0x10)
MaterialExpressionCustom.AdditionalDefines = 0x88 // TArray<FCustomDefine> (Size: 0x10)
MaterialExpressionCustom.IncludeFilePaths = 0x98 // TArray<FString> (Size: 0x10)
MaterialExpressionCustom.bForceFullPrecision = 0xa8 // bool (Size: 0x1)
MaterialExpressionDDX.Value = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDDY.Value = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDecalMipmapLevel.TextureSize = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDecalMipmapLevel.ConstWidth = 0x54 // float (Size: 0x4)
MaterialExpressionDecalMipmapLevel.ConstHeight = 0x58 // float (Size: 0x4)
MaterialExpressionDepthFade.InOpacity = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDepthFade.FadeDistance = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionDepthFade.OpacityDefault = 0x68 // float (Size: 0x4)
MaterialExpressionDepthFade.FadeDistanceDefault = 0x6c // float (Size: 0x4)
MaterialExpressionDepthOfFieldFunction.FunctionValue = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionDepthOfFieldFunction.Depth = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionDeriveNormalZ.InXY = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDesaturation.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDesaturation.Fraction = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionDesaturation.LuminanceFactors = 0x68 // FLinearColor (Size: 0x10)
MaterialExpressionDistance.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDistance.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionDistanceFieldGradient.position = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDistanceToNearestSurface.position = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDistanceToNearestSurface.bUseMeshSDF = 0x54 // bool (Size: 0x1)
MaterialExpressionDistanceToNearestSurface.MaxDistance = 0x58 // float (Size: 0x4)
MaterialExpressionDistanceToNearestSurface.Clipmap = 0x5c // int32_t (Size: 0x4)
MaterialExpressionDivide.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDivide.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionDivide.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionDivide.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionDotProduct.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDotProduct.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicBranch.bUseMaterialAttributes = 0x40 // bool (Size: 0x1)
MaterialExpressionDynamicBranch.Condition = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicBranch.IfTrue = 0x58 // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicBranch.IfFalse = 0x6c // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicBranch.IfTrueAttr = 0x80 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionDynamicBranch.IfFalseAttr = 0xa0 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionDynamicBranch.BypassAttr = 0xc0 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionDynamicBranch.AttributeBranchTypes = 0xe0 // TArray<FGuid> (Size: 0x10)
MaterialExpressionDynamicBranchScope.In = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicBranchScope.bUseMaterialAttribute = 0x54 // bool (Size: 0x1)
MaterialExpressionDynamicModeSwitch.Inputs = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionDynamicParameter.ParamNames = 0x40 // TArray<FString> (Size: 0x10)
MaterialExpressionDynamicParameter.DefaultValue = 0x50 // FLinearColor (Size: 0x10)
MaterialExpressionDynamicParameter.ParameterIndex = 0x60 // uint32_t (Size: 0x4)
MaterialExpressionFeatureLevelSwitch.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFloor.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFmod.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFmod.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionFontSample.Font = 0x40 // Font* (Size: 0x8)
MaterialExpressionFontSample.FontTexturePage = 0x48 // int32_t (Size: 0x4)
MaterialExpressionFontSampleParameter.ParameterName = 0x50 // FName (Size: 0x8)
MaterialExpressionFontSampleParameter.ExpressionGUID = 0x58 // FGuid (Size: 0x10)
MaterialExpressionFontSampleParameter.Group = 0x68 // FName (Size: 0x8)
MaterialExpressionFrac.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFresnel.ExponentIn = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFresnel.Exponent = 0x54 // float (Size: 0x4)
MaterialExpressionFresnel.BaseReflectFractionIn = 0x58 // FExpressionInput (Size: 0xc)
MaterialExpressionFresnel.BaseReflectFraction = 0x6c // float (Size: 0x4)
MaterialExpressionFresnel.Normal = 0x70 // FExpressionInput (Size: 0xc)
MaterialExpressionFunctionInput.Preview = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionFunctionInput.InputName = 0x54 // FName (Size: 0x8)
MaterialExpressionFunctionInput.Description = 0x60 // FString (Size: 0x10)
MaterialExpressionFunctionInput.ID = 0x70 // FGuid (Size: 0x10)
MaterialExpressionFunctionInput.InputType = 0x80 // uint8_t (Size: 0x1)
MaterialExpressionFunctionInput.PreviewValue = 0x90 // FVector4 (Size: 0x10)
MaterialExpressionFunctionInput.bUsePreviewValueAsDefault = 0xa0 // uint8_t (Size: 0x1)
MaterialExpressionFunctionInput.SortPriority = 0xa4 // int32_t (Size: 0x4)
MaterialExpressionFunctionInput.bCompilingFunctionPreview = 0xa8 // uint8_t (Size: 0x1)
MaterialExpressionFunctionOutput.OutputName = 0x40 // FName (Size: 0x8)
MaterialExpressionFunctionOutput.Description = 0x48 // FString (Size: 0x10)
MaterialExpressionFunctionOutput.SortPriority = 0x58 // int32_t (Size: 0x4)
MaterialExpressionFunctionOutput.A = 0x5c // FExpressionInput (Size: 0xc)
MaterialExpressionFunctionOutput.bLastPreviewed = 0x70 // uint8_t (Size: 0x1)
MaterialExpressionFunctionOutput.ID = 0x74 // FGuid (Size: 0x10)
MaterialExpressionGIReplace.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionGIReplace.StaticIndirect = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionGIReplace.DynamicIndirect = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionGetMaterialAttributes.MaterialAttributes = 0x40 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionGetMaterialAttributes.AttributeGetTypes = 0x60 // TArray<FGuid> (Size: 0x10)
MaterialExpressionHairAttributes.bUseTangentSpace = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionHairColor.Melanin = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionHairColor.Redness = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionHairColor.DyeColor = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionIf.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionIf.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionIf.AGreaterThanB = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionIf.AEqualsB = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionIf.ALessThanB = 0x90 // FExpressionInput (Size: 0xc)
MaterialExpressionIf.EqualsThreshold = 0xa4 // float (Size: 0x4)
MaterialExpressionIf.ConstB = 0xa8 // float (Size: 0x4)
MaterialExpressionIf.ConstAEqualsB = 0xac // float (Size: 0x4)
MaterialExpressionIndirectLightingSamplePositionOffsetCustomOutput.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionInverseLinearInterpolate.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionInverseLinearInterpolate.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionInverseLinearInterpolate.Value = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionInverseLinearInterpolate.ConstA = 0x7c // float (Size: 0x4)
MaterialExpressionInverseLinearInterpolate.ConstB = 0x80 // float (Size: 0x4)
MaterialExpressionInverseLinearInterpolate.ConstValue = 0x84 // float (Size: 0x4)
MaterialExpressionInverseLinearInterpolate.bClampResult = 0x88 // bool (Size: 0x1)
MaterialExpressionLightmassReplace.Realtime = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLightmassReplace.Lightmass = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionLinearInterpolate.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLinearInterpolate.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionLinearInterpolate.Alpha = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionLinearInterpolate.ConstA = 0x7c // float (Size: 0x4)
MaterialExpressionLinearInterpolate.ConstB = 0x80 // float (Size: 0x4)
MaterialExpressionLinearInterpolate.ConstAlpha = 0x84 // float (Size: 0x4)
MaterialExpressionLogarithm10.X = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLogarithm2.X = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMFAmbientGI.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.BaseColor = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Metallic = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Specular = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Roughness = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Anisotropy = 0x90 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.EmissiveColor = 0xa4 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Opacity = 0xb8 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.OpacityMask = 0xcc // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Normal = 0xe0 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Tangent = 0xf4 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.WorldPositionOffset = 0x108 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.WorldDisplacement = 0x11c // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.TessellationMultiplier = 0x130 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.SubsurfaceColor = 0x144 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.ClearCoat = 0x158 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.ClearCoatRoughness = 0x16c // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.AmbientOcclusion = 0x180 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.Refraction = 0x194 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.CustomizedUVs = 0x1a8 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.PixelDepthOffset = 0x248 // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.ShadingModel = 0x25c // FExpressionInput (Size: 0xc)
MaterialExpressionMakeMaterialAttributes.CustomDataVector = 0x270 // FExpressionInput (Size: 0xc)
MaterialExpressionMapARPassthroughCameraUV.Coordinates = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMaterialAttributeLayers.ParameterName = 0x40 // FName (Size: 0x8)
MaterialExpressionMaterialAttributeLayers.ExpressionGUID = 0x48 // FGuid (Size: 0x10)
MaterialExpressionMaterialAttributeLayers.Input = 0x58 // FMaterialAttributesInput (Size: 0x18)
MaterialExpressionMaterialAttributeLayers.DefaultLayers = 0x78 // FMaterialLayersFunctions (Size: 0x40)
MaterialExpressionMaterialAttributeLayers.LayerCallers = 0xb8 // TArray<MaterialExpressionMaterialFunctionCall*> (Size: 0x10)
MaterialExpressionMaterialAttributeLayers.NumActiveLayerCallers = 0xc8 // int32_t (Size: 0x4)
MaterialExpressionMaterialAttributeLayers.BlendCallers = 0xd0 // TArray<MaterialExpressionMaterialFunctionCall*> (Size: 0x10)
MaterialExpressionMaterialAttributeLayers.NumActiveBlendCallers = 0xe0 // int32_t (Size: 0x4)
MaterialExpressionMaterialAttributeLayers.bIsLayerGraphBuilt = 0xe4 // bool (Size: 0x1)
MaterialExpressionMaterialFunctionCall.MaterialFunction = 0x40 // MaterialFunctionInterface* (Size: 0x8)
MaterialExpressionMaterialFunctionCall.FunctionParameterInfo = 0x48 // FMaterialParameterInfo (Size: 0x10)
MaterialExpressionMaterialFunctionCall.bForceFullPrecision = 0x58 // bool (Size: 0x1)
MaterialExpressionMaterialProxyReplace.Realtime = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMaterialProxyReplace.MaterialProxy = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionMax.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMax.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionMax.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionMax.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionMin.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMin.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionMin.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionMin.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionMultiply.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionMultiply.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionMultiply.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionMultiply.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionNoise.position = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionNoise.FilterWidth = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionNoise.Scale = 0x68 // float (Size: 0x4)
MaterialExpressionNoise.quality = 0x6c // int32_t (Size: 0x4)
MaterialExpressionNoise.NoiseFunction = 0x70 // uint8_t (Size: 0x1)
MaterialExpressionNoise.bTurbulence = 0x74 // uint8_t (Size: 0x1)
MaterialExpressionNoise.Levels = 0x78 // int32_t (Size: 0x4)
MaterialExpressionNoise.OutputMin = 0x7c // float (Size: 0x4)
MaterialExpressionNoise.OutputMax = 0x80 // float (Size: 0x4)
MaterialExpressionNoise.LevelScale = 0x84 // float (Size: 0x4)
MaterialExpressionNoise.bTiling = 0x88 // uint8_t (Size: 0x1)
MaterialExpressionNoise.RepeatSize = 0x8c // uint32_t (Size: 0x4)
MaterialExpressionNormalize.VectorInput = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionOneMinus.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionPanner.coordinate = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionPanner.Time = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionPanner.Speed = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionPanner.SpeedX = 0x7c // float (Size: 0x4)
MaterialExpressionPanner.SpeedY = 0x80 // float (Size: 0x4)
MaterialExpressionPanner.ConstCoordinate = 0x84 // uint32_t (Size: 0x4)
MaterialExpressionPanner.bFractionalPart = 0x88 // bool (Size: 0x1)
MaterialExpressionParameter.ParameterName = 0x40 // FName (Size: 0x8)
MaterialExpressionParameter.ExpressionGUID = 0x48 // FGuid (Size: 0x10)
MaterialExpressionParticleSubUV.bBlend = 0x60 // uint8_t (Size: 0x1)
MaterialExpressionPerInstanceCustomData.DefaultValue = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionPerInstanceCustomData.ConstDefaultValue = 0x54 // float (Size: 0x4)
MaterialExpressionPerInstanceCustomData.DataIndex = 0x58 // uint32_t (Size: 0x4)
MaterialExpressionPower.Base = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionPower.Exponent = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionPower.ConstExponent = 0x68 // float (Size: 0x4)
MaterialExpressionPreviousFrameSwitch.CurrentFrame = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionPreviousFrameSwitch.PreviousFrame = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionQualitySwitch.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionQualitySwitch.Inputs = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRayTracingQualitySwitch.Normal = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRayTracingQualitySwitch.RayTraced = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRayTracingReflectionSwitch.RTRDisabled = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRayTracingReflectionSwitch.RTREnabled = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionReflectionCapturePassSwitch.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionReflectionCapturePassSwitch.Reflection = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionReflectionVectorWS.CustomWorldNormal = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionReflectionVectorWS.bNormalizeCustomWorldNormal = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionReroute.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRotateAboutAxis.NormalizedRotationAxis = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRotateAboutAxis.RotationAngle = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRotateAboutAxis.PivotPoint = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionRotateAboutAxis.position = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionRotateAboutAxis.Period = 0x90 // float (Size: 0x4)
MaterialExpressionRotator.coordinate = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRotator.Time = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRotator.CenterX = 0x68 // float (Size: 0x4)
MaterialExpressionRotator.CenterY = 0x6c // float (Size: 0x4)
MaterialExpressionRotator.Speed = 0x70 // float (Size: 0x4)
MaterialExpressionRotator.ConstCoordinate = 0x74 // uint32_t (Size: 0x4)
MaterialExpressionRound.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.Condition = 0xb0 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackColor = 0xc4 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackSpecular = 0xd8 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackRoughness = 0xec // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackNormal = 0x100 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackWorldHeight = 0x114 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.FallbackMask = 0x128 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureDynamicSampleParameter.DynamicRVTMode = 0x13c // EEDynamicRVTMode (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureOutput.BaseColor = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.Specular = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.Roughness = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.Normal = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.WorldHeight = 0x90 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.Opacity = 0xa4 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.Mask = 0xb8 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.OpacityMask = 0xcc // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureOutput.bIsBlendMasked = 0xe0 // bool (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureOutput.BlendMaskClipValue = 0xe4 // float (Size: 0x4)
MaterialExpressionRuntimeVirtualTextureReplace.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureReplace.VirtualTextureOutput = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureSample.Coordinates = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureSample.WorldPosition = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureSample.MipValue = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionRuntimeVirtualTextureSample.VirtualTexture = 0x80 // RuntimeVirtualTexture* (Size: 0x8)
MaterialExpressionRuntimeVirtualTextureSample.MaterialType = 0x88 // EERuntimeVirtualTextureMaterialType (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.bSinglePhysicalSpace = 0x89 // bool (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.bAdaptive = 0x8a // bool (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.MipValueMode = 0x8b // uint8_t (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.TextureAddressMode = 0x8c // uint8_t (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.bEnableAnisotropy = 0x8d // bool (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSample.bEnableFeedback = 0x8e // bool (Size: 0x1)
MaterialExpressionRuntimeVirtualTextureSampleParameter.ParameterName = 0x90 // FName (Size: 0x8)
MaterialExpressionRuntimeVirtualTextureSampleParameter.ExpressionGUID = 0x98 // FGuid (Size: 0x10)
MaterialExpressionRuntimeVirtualTextureSampleParameter.Group = 0xa8 // FName (Size: 0x8)
MaterialExpressionSaturate.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionScalarParameter.DefaultValue = 0x58 // float (Size: 0x4)
MaterialExpressionScalarParameter.bUseCustomPrimitiveData = 0x5c // bool (Size: 0x1)
MaterialExpressionScalarParameter.PrimitiveDataIndex = 0x5d // uint8_t (Size: 0x1)
MaterialExpressionSceneColor.InputMode = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionSceneColor.Input = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneColor.OffsetFraction = 0x58 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneColor.ConstInput = 0x6c // FVector2D (Size: 0x8)
MaterialExpressionSceneDepth.InputMode = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionSceneDepth.Input = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneDepth.Coordinates = 0x58 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneDepth.ConstInput = 0x6c // FVector2D (Size: 0x8)
MaterialExpressionSceneDepthWithoutWater.InputMode = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionSceneDepthWithoutWater.Input = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneDepthWithoutWater.ConstInput = 0x58 // FVector2D (Size: 0x8)
MaterialExpressionSceneDepthWithoutWater.FallbackDepth = 0x60 // float (Size: 0x4)
MaterialExpressionSceneTexture.Coordinates = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSceneTexture.SceneTextureId = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionSceneTexture.bFiltered = 0x55 // bool (Size: 0x1)
MaterialExpressionSetMaterialAttributes.Inputs = 0x40 // TArray<FExpressionInput> (Size: 0x10)
MaterialExpressionSetMaterialAttributes.AttributeSetTypes = 0x50 // TArray<FGuid> (Size: 0x10)
MaterialExpressionShaderStageSwitch.PixelShader = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionShaderStageSwitch.VertexShader = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionShadingModel.ShadingModel = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionShadingPathSwitch.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionShadingPathSwitch.Inputs = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionShadowReplace.Default = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionShadowReplace.Shadow = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSign.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSine.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSine.Period = 0x54 // float (Size: 0x4)
MaterialExpressionSingleLayerWaterMaterialOutput.ScatteringCoefficients = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSingleLayerWaterMaterialOutput.AbsorptionCoefficients = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSingleLayerWaterMaterialOutput.PhaseG = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionSingleLayerWaterMaterialOutput.ColorScaleBehindWater = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionSkyAtmosphereAerialPerspective.WorldPosition = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSkyAtmosphereLightDirection.LightIndex = 0x40 // int32_t (Size: 0x4)
MaterialExpressionSkyAtmosphereLightDiskLuminance.LightIndex = 0x40 // int32_t (Size: 0x4)
MaterialExpressionSkyAtmosphereLightIlluminance.LightIndex = 0x40 // int32_t (Size: 0x4)
MaterialExpressionSkyAtmosphereLightIlluminance.WorldPosition = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionSmoothStep.Min = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSmoothStep.Max = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSmoothStep.Value = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionSmoothStep.ConstMin = 0x7c // float (Size: 0x4)
MaterialExpressionSmoothStep.ConstMax = 0x80 // float (Size: 0x4)
MaterialExpressionSmoothStep.ConstValue = 0x84 // float (Size: 0x4)
MaterialExpressionSobol.Cell = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSobol.Index = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSobol.Seed = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionSobol.ConstIndex = 0x7c // uint32_t (Size: 0x4)
MaterialExpressionSobol.ConstSeed = 0x80 // FVector2D (Size: 0x8)
MaterialExpressionSpeedTree.GeometryInput = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSpeedTree.WindInput = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSpeedTree.LODInput = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionSpeedTree.ExtraBendWS = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionSpeedTree.GeometryType = 0x90 // uint8_t (Size: 0x1)
MaterialExpressionSpeedTree.WindType = 0x91 // uint8_t (Size: 0x1)
MaterialExpressionSpeedTree.LODType = 0x92 // uint8_t (Size: 0x1)
MaterialExpressionSpeedTree.BillboardThreshold = 0x94 // float (Size: 0x4)
MaterialExpressionSpeedTree.bAccurateWindVelocities = 0x98 // bool (Size: 0x1)
MaterialExpressionSphereMask.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSphereMask.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSphereMask.Radius = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionSphereMask.Hardness = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionSphereMask.AttenuationRadius = 0x90 // float (Size: 0x4)
MaterialExpressionSphereMask.HardnessPercent = 0x94 // float (Size: 0x4)
MaterialExpressionSphericalParticleOpacity.Density = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSphericalParticleOpacity.ConstantDensity = 0x54 // float (Size: 0x4)
MaterialExpressionSquareRoot.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionStaticBool.Value = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionStaticBoolParameter.DefaultValue = 0x58 // uint8_t (Size: 0x1)
MaterialExpressionStaticComponentMaskParameter.DefaultR = 0x58 // uint8_t (Size: 0x1)
MaterialExpressionStaticComponentMaskParameter.DefaultG = 0x58 // uint8_t (Size: 0x1)
MaterialExpressionStaticComponentMaskParameter.DefaultB = 0x58 // uint8_t (Size: 0x1)
MaterialExpressionStaticComponentMaskParameter.DefaultA = 0x58 // uint8_t (Size: 0x1)
MaterialExpressionStaticSwitch.DefaultValue = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionStaticSwitch.A = 0x44 // FExpressionInput (Size: 0xc)
MaterialExpressionStaticSwitch.B = 0x58 // FExpressionInput (Size: 0xc)
MaterialExpressionStaticSwitch.Value = 0x6c // FExpressionInput (Size: 0xc)
MaterialExpressionStep.Y = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionStep.X = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionStep.ConstY = 0x68 // float (Size: 0x4)
MaterialExpressionStep.ConstX = 0x6c // float (Size: 0x4)
MaterialExpressionSubtract.A = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionSubtract.B = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionSubtract.ConstA = 0x68 // float (Size: 0x4)
MaterialExpressionSubtract.ConstB = 0x6c // float (Size: 0x4)
MaterialExpressionTangent.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTangent.Period = 0x54 // float (Size: 0x4)
MaterialExpressionTangentOutput.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTemporalSobol.Index = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTemporalSobol.Seed = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionTemporalSobol.ConstIndex = 0x68 // uint32_t (Size: 0x4)
MaterialExpressionTemporalSobol.ConstSeed = 0x6c // FVector2D (Size: 0x8)
MaterialExpressionTextureBase.Texture = 0x40 // Texture* (Size: 0x8)
MaterialExpressionTextureCoordinate.CoordinateIndex = 0x40 // int32_t (Size: 0x4)
MaterialExpressionTextureCoordinate.UTiling = 0x44 // float (Size: 0x4)
MaterialExpressionTextureCoordinate.VTiling = 0x48 // float (Size: 0x4)
MaterialExpressionTextureCoordinate.UnMirrorU = 0x4c // uint8_t (Size: 0x1)
MaterialExpressionTextureCoordinate.UnMirrorV = 0x4c // uint8_t (Size: 0x1)
MaterialExpressionTextureProperty.TextureObject = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTextureProperty.Property = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionTextureSample.Coordinates = 0x48 // FExpressionInput (Size: 0xc)
MaterialExpressionTextureSampleParameter.ParameterName = 0x60 // FName (Size: 0x8)
MaterialExpressionTextureSampleParameter.ExpressionGUID = 0x68 // FGuid (Size: 0x10)
MaterialExpressionTextureSampleParameter.Group = 0x78 // FName (Size: 0x8)
MaterialExpressionTextureSampleParameterSubUV.bBlend = 0x80 // uint8_t (Size: 0x1)
MaterialExpressionThinTranslucentMaterialOutput.TransmittanceColor = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTime.bIgnorePause = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionTime.bOverride_Period = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionTime.Period = 0x44 // float (Size: 0x4)
MaterialExpressionTransform.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTransform.TransformSourceType = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionTransform.TransformType = 0x55 // uint8_t (Size: 0x1)
MaterialExpressionTransformPosition.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionTransformPosition.TransformSourceType = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionTransformPosition.TransformType = 0x55 // uint8_t (Size: 0x1)
MaterialExpressionTruncate.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionVectorNoise.position = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionVectorNoise.NoiseFunction = 0x54 // uint8_t (Size: 0x1)
MaterialExpressionVectorNoise.quality = 0x58 // int32_t (Size: 0x4)
MaterialExpressionVectorNoise.bTiling = 0x5c // uint8_t (Size: 0x1)
MaterialExpressionVectorNoise.TileSize = 0x60 // uint32_t (Size: 0x4)
MaterialExpressionVectorParameter.DefaultValue = 0x58 // FLinearColor (Size: 0x10)
MaterialExpressionVectorParameter.bUseCustomPrimitiveData = 0x68 // bool (Size: 0x1)
MaterialExpressionVectorParameter.PrimitiveDataIndex = 0x69 // uint8_t (Size: 0x1)
MaterialExpressionVertexInterpolator.Input = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionViewProperty.Property = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionVirtualTextureFeatureSwitch.No = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionVirtualTextureFeatureSwitch.Yes = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.PhaseG = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.PhaseG2 = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.PhaseBlend = 0x68 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.MultiScatteringContribution = 0x7c // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.MultiScatteringOcclusion = 0x90 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.MultiScatteringEccentricity = 0xa4 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConservativeDensity = 0xb8 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.LodExtinctionSample = 0xcc // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.ExtraParameterA = 0xe0 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.TopLayerCloud = 0xf4 // FExpressionInput (Size: 0xc)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstPhaseG = 0x108 // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstPhaseG2 = 0x10c // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstPhaseBlend = 0x110 // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.PerSamplePhaseEvaluation = 0x114 // bool (Size: 0x1)
MaterialExpressionVolumetricAdvancedMaterialOutput.MultiScatteringApproximationOctaveCount = 0x118 // uint32_t (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstMultiScatteringContribution = 0x11c // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstMultiScatteringOcclusion = 0x120 // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.ConstMultiScatteringEccentricity = 0x124 // float (Size: 0x4)
MaterialExpressionVolumetricAdvancedMaterialOutput.bGroundContribution = 0x128 // bool (Size: 0x1)
MaterialExpressionVolumetricAdvancedMaterialOutput.bGrayScaleMaterial = 0x129 // bool (Size: 0x1)
MaterialExpressionVolumetricAdvancedMaterialOutput.bRayMarchVolumeShadow = 0x12a // bool (Size: 0x1)
MaterialExpressionWorldPosition.WorldPositionShaderOffset = 0x40 // uint8_t (Size: 0x1)
MaterialFunction.Description = 0x40 // FString (Size: 0x10)
MaterialFunction.bExposeToLibrary = 0x50 // uint8_t (Size: 0x1)
MaterialFunction.bPrefixParameterNames = 0x50 // uint8_t (Size: 0x1)
MaterialFunctionInfo.StateId = 0x0 // FGuid (Size: 0x10)
MaterialFunctionInfo.Function = 0x10 // MaterialFunctionInterface* (Size: 0x8)
MaterialFunctionInstance.Parent = 0x40 // MaterialFunctionInterface* (Size: 0x8)
MaterialFunctionInstance.Base = 0x48 // MaterialFunctionInterface* (Size: 0x8)
MaterialFunctionInstance.ScalarParameterValues = 0x50 // TArray<FScalarParameterValue> (Size: 0x10)
MaterialFunctionInstance.VectorParameterValues = 0x60 // TArray<FVectorParameterValue> (Size: 0x10)
MaterialFunctionInstance.TextureParameterValues = 0x70 // TArray<FTextureParameterValue> (Size: 0x10)
MaterialFunctionInstance.FontParameterValues = 0x80 // TArray<FFontParameterValue> (Size: 0x10)
MaterialFunctionInstance.StaticSwitchParameterValues = 0x90 // TArray<FStaticSwitchParameter> (Size: 0x10)
MaterialFunctionInstance.StaticComponentMaskParameterValues = 0xa0 // TArray<FStaticComponentMaskParameter> (Size: 0x10)
MaterialFunctionInstance.RuntimeVirtualTextureParameterValues = 0xb0 // TArray<FRuntimeVirtualTextureParameterValue> (Size: 0x10)
MaterialFunctionInterface.StateId = 0x28 // FGuid (Size: 0x10)
MaterialFunctionInterface.MaterialFunctionUsage = 0x38 // EEMaterialFunctionUsage (Size: 0x1)
MaterialInput.OutputIndex = 0x0 // int32_t (Size: 0x4)
MaterialInput.ExpressionName = 0x4 // FName (Size: 0x8)
MaterialInstance.PhysMaterial = 0x90 // PhysicalMaterial* (Size: 0x8)
MaterialInstance.PhysicalMaterialMap = 0x98 // PhysicalMaterial* (Size: 0x8)
MaterialInstance.Parent = 0xd8 // MaterialInterface* (Size: 0x8)
MaterialInstance.bHasStaticPermutationResource = 0xe0 // uint8_t (Size: 0x1)
MaterialInstance.bOverrideSubsurfaceProfile = 0xe0 // uint8_t (Size: 0x1)
MaterialInstance.ScalarParameterValues = 0x100 // TArray<FScalarParameterValue> (Size: 0x10)
MaterialInstance.VectorParameterValues = 0x110 // TArray<FVectorParameterValue> (Size: 0x10)
MaterialInstance.TextureParameterValues = 0x120 // TArray<FTextureParameterValue> (Size: 0x10)
MaterialInstance.RuntimeVirtualTextureParameterValues = 0x130 // TArray<FRuntimeVirtualTextureParameterValue> (Size: 0x10)
MaterialInstance.FontParameterValues = 0x140 // TArray<FFontParameterValue> (Size: 0x10)
MaterialInstance.BasePropertyOverrides = 0x150 // FMaterialInstanceBasePropertyOverrides (Size: 0x28)
MaterialInstance.StaticParameters = 0x188 // FStaticParameterSet (Size: 0x40)
MaterialInstance.CachedLayerParameters = 0x1c8 // FMaterialCachedParameters (Size: 0x1a0)
MaterialInstance.CachedReferencedTextures = 0x368 // TArray<Object*> (Size: 0x10)
MaterialInstanceActor.TargetActors = 0x310 // TArray<Actor*> (Size: 0x10)
MaterialInstanceBasePropertyOverrides.bOverride_OpacityMaskClipValue = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_ScreenSpaceVariance = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_Threshold = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_TranslucencySortPriorityOffset = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_MaterialStencilTypeForMpe = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_RenderInEarlyDepthPass = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_MaterialFloatPrecisionMode = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_MaterialFloatPrecisionModeVulkanOverride = 0x0 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_ForceDisableDynamicLightShadow = 0x1 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_ForceEnableTwoSidedFoliageDBufferInput = 0x1 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_DisableBindlessVertexColor = 0x1 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bDisableBindlessVertexColor = 0x2 // bool (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_DisableBindlessLightmap = 0x3 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bDisableBindlessLightmap = 0x4 // bool (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_AllowInlineRayTracing = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_BlendMode = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_ShadingModel = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_DitheredLODTransition = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_CastDynamicShadowAsMasked = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_TwoSided = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.TwoSided = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.DitheredLODTransition = 0x5 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bCastDynamicShadowAsMasked = 0x6 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.BlendMode = 0x7 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.ShadingModel = 0x8 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.OpacityMaskClipValue = 0xc // float (Size: 0x4)
MaterialInstanceBasePropertyOverrides.ScreenSpaceVariance = 0x10 // float (Size: 0x4)
MaterialInstanceBasePropertyOverrides.Threshold = 0x14 // float (Size: 0x4)
MaterialInstanceBasePropertyOverrides.bOverride_ShadowCacheMode = 0x18 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.ShadowCacheMode = 0x19 // EEMaterialShadowCacheMode (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_TranslucentLocalLightShadow = 0x1a // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bTranslucentLocalLightShadow = 0x1a // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bOverride_TranslucentLocalLightShadowQuality = 0x1a // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.TranslucentLocalLightShadowQuality = 0x1b // int8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.TranslucencySortPriorityOffset = 0x1c // int16_t (Size: 0x2)
MaterialInstanceBasePropertyOverrides.MaterialStencilTypeForMpe = 0x1e // int16_t (Size: 0x2)
MaterialInstanceBasePropertyOverrides.bRenderInEarlyDepthPass = 0x20 // bool (Size: 0x1)
MaterialInstanceBasePropertyOverrides.FloatPrecisionMode = 0x21 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.FloatPrecisionModeVulkanOverride = 0x22 // uint8_t (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bForceDisableDynamicLightShadow = 0x23 // bool (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bForceEnableTwoSidedFoliageDBufferInput = 0x24 // bool (Size: 0x1)
MaterialInstanceBasePropertyOverrides.bAllowInlineRayTracing = 0x25 // bool (Size: 0x1)
MaterialInstanceConstant.PhysMaterialMask = 0x3a0 // PhysicalMaterialMask* (Size: 0x8)
MaterialInterface.SubsurfaceProfile = 0x38 // SubsurfaceProfile* (Size: 0x8)
MaterialInterface.LightmassSettings = 0x50 // FLightmassMaterialInterfaceSettings (Size: 0x10)
MaterialInterface.TextureStreamingData = 0x60 // TArray<FMaterialTextureInfo> (Size: 0x10)
MaterialInterface.AssetUserData = 0x70 // TArray<AssetUserData*> (Size: 0x10)
MaterialInterface.CurDynamicMode_GameThread = 0x80 // uint8_t (Size: 0x1)
MaterialInterface.bTranslucentLocalLightShadow = 0x89 // uint8_t (Size: 0x1)
MaterialInterface.TranslucentLocalLightShadowQuality = 0x8a // int8_t (Size: 0x1)
MaterialLayersFunctions.Layers = 0x0 // TArray<MaterialFunctionInterface*> (Size: 0x10)
MaterialLayersFunctions.Blends = 0x10 // TArray<MaterialFunctionInterface*> (Size: 0x10)
MaterialLayersFunctions.LayerStates = 0x20 // TArray<bool> (Size: 0x10)
MaterialLayersFunctions.KeyString = 0x30 // FString (Size: 0x10)
MaterialParameterCollection.StateId = 0x28 // FGuid (Size: 0x10)
MaterialParameterCollection.ScalarParameters = 0x38 // TArray<FCollectionScalarParameter> (Size: 0x10)
MaterialParameterCollection.VectorParameters = 0x48 // TArray<FCollectionVectorParameter> (Size: 0x10)
MaterialParameterCollectionInfo.StateId = 0x0 // FGuid (Size: 0x10)
MaterialParameterCollectionInfo.ParameterCollection = 0x10 // MaterialParameterCollection* (Size: 0x8)
MaterialParameterCollectionInstance.Collection = 0x30 // MaterialParameterCollection* (Size: 0x8)
MaterialParameterInfo.Name = 0x0 // FName (Size: 0x8)
MaterialParameterInfo.Association = 0x8 // uint8_t (Size: 0x1)
MaterialParameterInfo.Index = 0xc // int32_t (Size: 0x4)
MaterialProxySettings.TextureSize = 0x0 // FIntPoint (Size: 0x8)
MaterialProxySettings.bDetermineTextureSizeByMaterials = 0x8 // uint8_t (Size: 0x1)
MaterialProxySettings.DetermineTextureSizeScale = 0xc // float (Size: 0x4)
MaterialProxySettings.GutterSpace = 0x10 // float (Size: 0x4)
MaterialProxySettings.MetallicConstant = 0x14 // float (Size: 0x4)
MaterialProxySettings.RoughnessConstant = 0x18 // float (Size: 0x4)
MaterialProxySettings.AnisotropyConstant = 0x1c // float (Size: 0x4)
MaterialProxySettings.SpecularConstant = 0x20 // float (Size: 0x4)
MaterialProxySettings.OpacityConstant = 0x24 // float (Size: 0x4)
MaterialProxySettings.OpacityMaskConstant = 0x28 // float (Size: 0x4)
MaterialProxySettings.AmbientOcclusionConstant = 0x2c // float (Size: 0x4)
MaterialProxySettings.TextureSizingType = 0x30 // uint8_t (Size: 0x1)
MaterialProxySettings.MaterialMergeType = 0x31 // uint8_t (Size: 0x1)
MaterialProxySettings.BlendMode = 0x32 // uint8_t (Size: 0x1)
MaterialProxySettings.bAllowTwoSidedMaterial = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bNormalMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bTangentMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bMetallicMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bRoughnessMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bAnisotropyMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bSpecularMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bEmissiveMap = 0x33 // uint8_t (Size: 0x1)
MaterialProxySettings.bOpacityMap = 0x34 // uint8_t (Size: 0x1)
MaterialProxySettings.bOpacityMaskMap = 0x34 // uint8_t (Size: 0x1)
MaterialProxySettings.bAmbientOcclusionMap = 0x34 // uint8_t (Size: 0x1)
MaterialProxySettings.DiffuseTextureSize = 0x38 // FIntPoint (Size: 0x8)
MaterialProxySettings.NormalTextureSize = 0x40 // FIntPoint (Size: 0x8)
MaterialProxySettings.TangentTextureSize = 0x48 // FIntPoint (Size: 0x8)
MaterialProxySettings.MetallicTextureSize = 0x50 // FIntPoint (Size: 0x8)
MaterialProxySettings.RoughnessTextureSize = 0x58 // FIntPoint (Size: 0x8)
MaterialProxySettings.AnisotropyTextureSize = 0x60 // FIntPoint (Size: 0x8)
MaterialProxySettings.SpecularTextureSize = 0x68 // FIntPoint (Size: 0x8)
MaterialProxySettings.EmissiveTextureSize = 0x70 // FIntPoint (Size: 0x8)
MaterialProxySettings.OpacityTextureSize = 0x78 // FIntPoint (Size: 0x8)
MaterialProxySettings.OpacityMaskTextureSize = 0x80 // FIntPoint (Size: 0x8)
MaterialProxySettings.AmbientOcclusionTextureSize = 0x88 // FIntPoint (Size: 0x8)
MaterialRemapIndex.ImportVersionKey = 0x0 // uint32_t (Size: 0x4)
MaterialRemapIndex.MaterialRemap = 0x8 // TArray<int32_t> (Size: 0x10)
MaterialShadingModelField.ShadingModelField = 0x0 // uint16_t (Size: 0x2)
MaterialSpriteElement.Material = 0x0 // MaterialInterface* (Size: 0x8)
MaterialSpriteElement.DistanceToOpacityCurve = 0x8 // CurveFloat* (Size: 0x8)
MaterialSpriteElement.bSizeIsInScreenSpace = 0x10 // uint8_t (Size: 0x1)
MaterialSpriteElement.BaseSizeX = 0x14 // float (Size: 0x4)
MaterialSpriteElement.BaseSizeY = 0x18 // float (Size: 0x4)
MaterialSpriteElement.DistanceToSizeCurve = 0x20 // CurveFloat* (Size: 0x8)
MaterialTextureInfo.SamplingScale = 0x0 // float (Size: 0x4)
MaterialTextureInfo.UVChannelIndex = 0x4 // int32_t (Size: 0x4)
MaterialTextureInfo.TextureName = 0x8 // FName (Size: 0x8)
MatineeActor.MatineeData = 0x310 // InterpData* (Size: 0x8)
MatineeActor.MatineeControllerName = 0x318 // FName (Size: 0x8)
MatineeActor.PlayRate = 0x320 // float (Size: 0x4)
MatineeActor.bPlayOnLevelLoad = 0x324 // uint8_t (Size: 0x1)
MatineeActor.bForceStartPos = 0x324 // uint8_t (Size: 0x1)
MatineeActor.ForceStartPosition = 0x328 // float (Size: 0x4)
MatineeActor.bLooping = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bRewindOnPlay = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bNoResetOnRewind = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bRewindIfAlreadyPlaying = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bDisableRadioFilter = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bClientSideOnly = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bSkipUpdateIfNotVisible = 0x32c // uint8_t (Size: 0x1)
MatineeActor.bIsSkippable = 0x32c // uint8_t (Size: 0x1)
MatineeActor.PreferredSplitScreenNum = 0x330 // int32_t (Size: 0x4)
MatineeActor.bDisableMovementInput = 0x334 // uint8_t (Size: 0x1)
MatineeActor.bDisableLookAtInput = 0x334 // uint8_t (Size: 0x1)
MatineeActor.bHidePlayer = 0x334 // uint8_t (Size: 0x1)
MatineeActor.bHideHud = 0x334 // uint8_t (Size: 0x1)
MatineeActor.GroupActorInfos = 0x338 // TArray<FInterpGroupActorInfo> (Size: 0x10)
MatineeActor.bShouldShowGore = 0x348 // uint8_t (Size: 0x1)
MatineeActor.GroupInst = 0x350 // TArray<InterpGroupInst*> (Size: 0x10)
MatineeActor.CameraCuts = 0x360 // TArray<FCameraCutInfo> (Size: 0x10)
MatineeActor.bIsPlaying = 0x370 // uint8_t (Size: 0x1)
MatineeActor.bReversePlayback = 0x370 // uint8_t (Size: 0x1)
MatineeActor.bPaused = 0x370 // uint8_t (Size: 0x1)
MatineeActor.bPendingStop = 0x370 // uint8_t (Size: 0x1)
MatineeActor.InterpPosition = 0x374 // float (Size: 0x4)
MatineeActor.ReplicationForceIsPlaying = 0x37c // uint8_t (Size: 0x1)
MatineeActor.OnPlay = 0x380 // FMulticastInlineDelegate (Size: 0x10)
MatineeActor.OnStop = 0x390 // FMulticastInlineDelegate (Size: 0x10)
MatineeActor.OnPause = 0x3a0 // FMulticastInlineDelegate (Size: 0x10)
MatineeActorCameraAnim.CameraAnim = 0x3b8 // CameraAnim* (Size: 0x8)
MatineeCameraShake.OscillationDuration = 0x98 // float (Size: 0x4)
MatineeCameraShake.OscillationBlendInTime = 0x9c // float (Size: 0x4)
MatineeCameraShake.OscillationBlendOutTime = 0xa0 // float (Size: 0x4)
MatineeCameraShake.RotOscillation = 0xa4 // FROscillator (Size: 0x24)
MatineeCameraShake.LocOscillation = 0xc8 // FVOscillator (Size: 0x24)
MatineeCameraShake.FOVOscillation = 0xec // FFOscillator (Size: 0xc)
MatineeCameraShake.AnimPlayRate = 0xf8 // float (Size: 0x4)
MatineeCameraShake.AnimScale = 0xfc // float (Size: 0x4)
MatineeCameraShake.AnimBlendInTime = 0x100 // float (Size: 0x4)
MatineeCameraShake.AnimBlendOutTime = 0x104 // float (Size: 0x4)
MatineeCameraShake.RandomAnimSegmentDuration = 0x108 // float (Size: 0x4)
MatineeCameraShake.Anim = 0x110 // CameraAnim* (Size: 0x8)
MatineeCameraShake.bRandomAnimSegment = 0x118 // uint8_t (Size: 0x1)
MatineeCameraShake.OscillatorTimeRemaining = 0x11c // float (Size: 0x4)
MatineeCameraShake.AnimInst = 0x120 // CameraAnimInst* (Size: 0x8)
MemberReference.MemberParent = 0x0 // Object* (Size: 0x8)
MemberReference.MemberScope = 0x8 // FString (Size: 0x10)
MemberReference.MemberName = 0x18 // FName (Size: 0x8)
MemberReference.MemberGuid = 0x20 // FGuid (Size: 0x10)
MemberReference.bSelfContext = 0x30 // bool (Size: 0x1)
MemberReference.bWasDeprecated = 0x31 // bool (Size: 0x1)
MeshBuildSettings.bUseMikkTSpace = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bRecomputeNormals = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bRecomputeTangents = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bComputeWeightedNormals = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bRemoveDegenerates = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bBuildAdjacencyBuffer = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bBuildReversedIndexBuffer = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bUseHighPrecisionTangentBasis = 0x0 // uint8_t (Size: 0x1)
MeshBuildSettings.bUseFullPrecisionUVs = 0x1 // uint8_t (Size: 0x1)
MeshBuildSettings.bGenerateLightmapUVs = 0x1 // uint8_t (Size: 0x1)
MeshBuildSettings.bGenerateDistanceFieldAsIfTwoSided = 0x1 // uint8_t (Size: 0x1)
MeshBuildSettings.bSupportFaceRemap = 0x1 // uint8_t (Size: 0x1)
MeshBuildSettings.MinLightmapResolution = 0x4 // int32_t (Size: 0x4)
MeshBuildSettings.SrcLightmapIndex = 0x8 // int32_t (Size: 0x4)
MeshBuildSettings.DstLightmapIndex = 0xc // int32_t (Size: 0x4)
MeshBuildSettings.BuildScale = 0x10 // float (Size: 0x4)
MeshBuildSettings.BuildScale3D = 0x14 // FVector (Size: 0xc)
MeshBuildSettings.DistanceFieldResolutionScale = 0x20 // float (Size: 0x4)
MeshBuildSettings.DistanceFieldReplacementMesh = 0x28 // StaticMesh* (Size: 0x8)
MeshBuildSettings.RandomPosPickRate = 0x30 // float (Size: 0x4)
MeshBuildSettings.HitBackRatioThreshold = 0x34 // float (Size: 0x4)
MeshBuildSettings.MinDistanceClamp = 0x38 // float (Size: 0x4)
MeshBuildSettings.bUseOriginalAlgorithm = 0x3c // uint8_t (Size: 0x1)
MeshBuildSettings.BackfaceClampDistance = 0x40 // float (Size: 0x4)
MeshBuildSettings.DistanceFieldOpacityMaskFactor = 0x44 // int32_t (Size: 0x4)
MeshBuildSettings.MostlyTwoSidedThreshold = 0x48 // float (Size: 0x4)
MeshComponent.OverrideMaterials = 0x5c8 // TArray<MaterialInterface*> (Size: 0x10)
MeshComponent.bEnableMaterialParameterCaching = 0x5e8 // uint8_t (Size: 0x1)
MeshComponent.IndirectLightingSampleActor = 0x5f0 // Actor* (Size: 0x8)
MeshComponent.bUseIndirectLightingSampleActorLocation = 0x5f8 // uint8_t (Size: 0x1)
MeshComponent.bTickComponentEvenHidden = 0x5f8 // uint8_t (Size: 0x1)
MeshInstancingSettings.ActorClassToUse = 0x0 // ClassProperty (Size: 0x8)
MeshInstancingSettings.InstanceReplacementThreshold = 0x8 // int32_t (Size: 0x4)
MeshInstancingSettings.MeshReplacementMethod = 0xc // EEMeshInstancingReplacementMethod (Size: 0x1)
MeshInstancingSettings.bSkipMeshesWithVertexColors = 0xd // bool (Size: 0x1)
MeshInstancingSettings.bUseHLODVolumes = 0xe // bool (Size: 0x1)
MeshInstancingSettings.ISMComponentToUse = 0x10 // ClassProperty (Size: 0x8)
MeshMergingSettings.TargetLightMapResolution = 0x0 // int32_t (Size: 0x4)
MeshMergingSettings.OutputUVs = 0x4 // EEUVOutput (Size: 0x1)
MeshMergingSettings.MaterialSettings = 0xc // FMaterialProxySettings (Size: 0x90)
MeshMergingSettings.GutterSize = 0x9c // int32_t (Size: 0x4)
MeshMergingSettings.SpecificLOD = 0xa0 // int32_t (Size: 0x4)
MeshMergingSettings.LODSelectionType = 0xa4 // EEMeshLODSelectionType (Size: 0x1)
MeshMergingSettings.bGenerateLightMapUV = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bComputedLightMapResolution = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bPivotPointAtZero = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bMergePhysicsData = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bMergeMaterials = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bCreateMergedMaterial = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bBakeVertexDataToMesh = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bUseVertexDataForBakingMaterial = 0xa5 // uint8_t (Size: 0x1)
MeshMergingSettings.bUseTextureBinning = 0xa6 // uint8_t (Size: 0x1)
MeshMergingSettings.bReuseMeshLightmapUVs = 0xa6 // uint8_t (Size: 0x1)
MeshMergingSettings.bMergeEquivalentMaterials = 0xa6 // uint8_t (Size: 0x1)
MeshMergingSettings.bUseLandscapeCulling = 0xa6 // uint8_t (Size: 0x1)
MeshMergingSettings.bIncludeImposters = 0xa6 // uint8_t (Size: 0x1)
MeshMergingSettings.bAllowDistanceField = 0xa6 // uint8_t (Size: 0x1)
MeshProxySettings.ScreenSize = 0x0 // int32_t (Size: 0x4)
MeshProxySettings.VoxelSize = 0x4 // float (Size: 0x4)
MeshProxySettings.MaterialSettings = 0x8 // FMaterialProxySettings (Size: 0x90)
MeshProxySettings.MergeDistance = 0x98 // float (Size: 0x4)
MeshProxySettings.UnresolvedGeometryColor = 0x9c // FColor (Size: 0x4)
MeshProxySettings.MaxRayCastDist = 0xa0 // float (Size: 0x4)
MeshProxySettings.HardAngleThreshold = 0xa4 // float (Size: 0x4)
MeshProxySettings.LightMapResolution = 0xa8 // int32_t (Size: 0x4)
MeshProxySettings.NormalCalculationMethod = 0xac // uint8_t (Size: 0x1)
MeshProxySettings.LandscapeCullingPrecision = 0xad // uint8_t (Size: 0x1)
MeshProxySettings.bCalculateCorrectLODModel = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bOverrideVoxelSize = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bOverrideTransferDistance = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bUseHardAngleThreshold = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bComputeLightMapResolution = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bRecalculateNormals = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bUseLandscapeCulling = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bAllowAdjacency = 0xae // uint8_t (Size: 0x1)
MeshProxySettings.bAllowDistanceField = 0xaf // uint8_t (Size: 0x1)
MeshProxySettings.bReuseMeshLightmapUVs = 0xaf // uint8_t (Size: 0x1)
MeshProxySettings.bCreateCollision = 0xaf // uint8_t (Size: 0x1)
MeshProxySettings.bAllowVertexColors = 0xaf // uint8_t (Size: 0x1)
MeshProxySettings.bGenerateLightmapUVs = 0xaf // uint8_t (Size: 0x1)
MeshReductionSettings.PercentTriangles = 0x0 // float (Size: 0x4)
MeshReductionSettings.PercentVertices = 0x4 // float (Size: 0x4)
MeshReductionSettings.MaxDeviation = 0x8 // float (Size: 0x4)
MeshReductionSettings.PixelError = 0xc // float (Size: 0x4)
MeshReductionSettings.WeldingThreshold = 0x10 // float (Size: 0x4)
MeshReductionSettings.HardAngleThreshold = 0x14 // float (Size: 0x4)
MeshReductionSettings.EdgePreserveLength = 0x18 // float (Size: 0x4)
MeshReductionSettings.BaseLODModel = 0x1c // int32_t (Size: 0x4)
MeshReductionSettings.SilhouetteImportance = 0x20 // uint8_t (Size: 0x1)
MeshReductionSettings.TextureImportance = 0x21 // uint8_t (Size: 0x1)
MeshReductionSettings.ShadingImportance = 0x22 // uint8_t (Size: 0x1)
MeshReductionSettings.bRecalculateNormals = 0x23 // uint8_t (Size: 0x1)
MeshReductionSettings.bGenerateUniqueLightmapUVs = 0x23 // uint8_t (Size: 0x1)
MeshReductionSettings.bKeepSymmetry = 0x23 // uint8_t (Size: 0x1)
MeshReductionSettings.bVisibilityAided = 0x23 // uint8_t (Size: 0x1)
MeshReductionSettings.bCullOccluded = 0x23 // uint8_t (Size: 0x1)
MeshReductionSettings.TerminationCriterion = 0x24 // EEStaticMeshReductionTerimationCriterion (Size: 0x1)
MeshReductionSettings.VisibilityAggressiveness = 0x25 // uint8_t (Size: 0x1)
MeshReductionSettings.VertexColorImportance = 0x26 // uint8_t (Size: 0x1)
MeshReductionSettings.MaxLOD0Triangles = 0x28 // int32_t (Size: 0x4)
MeshSectionInfo.MaterialIndex = 0x0 // int32_t (Size: 0x4)
MeshSectionInfo.bEnableCollision = 0x4 // bool (Size: 0x1)
MeshSectionInfo.bCastShadow = 0x5 // bool (Size: 0x1)
MeshSectionInfo.bVisibleInRayTracing = 0x6 // bool (Size: 0x1)
MeshSectionInfo.bForceOpaque = 0x7 // bool (Size: 0x1)
MeshSectionInfo.OpacityMicromap = 0x8 // FOpacityMicromap (Size: 0x20)
MeshSectionInfoMap.Map = 0x0 // TMap<...> (Size: 0x50)
MeshSimplificationSettings.MeshReductionModuleName = 0x38 // FName (Size: 0x8)
MeshUVChannelInfo.bInitialized = 0x0 // bool (Size: 0x1)
MeshUVChannelInfo.bOverrideDensities = 0x1 // bool (Size: 0x1)
MeshUVChannelInfo.LocalUVDensities = 0x4 // float (Size: 0x4)
MicroTransactionBase.AvailableProducts = 0x38 // TArray<FPurchaseInfo> (Size: 0x10)
MicroTransactionBase.LastError = 0x48 // FString (Size: 0x10)
MicroTransactionBase.LastErrorSolution = 0x58 // FString (Size: 0x10)
MinimalViewInfo.Location = 0x0 // FVector (Size: 0xc)
MinimalViewInfo.Rotation = 0xc // FRotator (Size: 0xc)
MinimalViewInfo.FOV = 0x18 // float (Size: 0x4)
MinimalViewInfo.ShadowFOV = 0x1c // float (Size: 0x4)
MinimalViewInfo.DesiredFOV = 0x20 // float (Size: 0x4)
MinimalViewInfo.OrthoWidth = 0x24 // float (Size: 0x4)
MinimalViewInfo.OrthoNearClipPlane = 0x28 // float (Size: 0x4)
MinimalViewInfo.OrthoFarClipPlane = 0x2c // float (Size: 0x4)
MinimalViewInfo.AspectRatio = 0x30 // float (Size: 0x4)
MinimalViewInfo.bConstrainAspectRatio = 0x34 // uint8_t (Size: 0x1)
MinimalViewInfo.bUseFieldOfViewForLOD = 0x34 // uint8_t (Size: 0x1)
MinimalViewInfo.ProjectionMode = 0x38 // uint8_t (Size: 0x1)
MinimalViewInfo.PostProcessBlendWeight = 0x3c // float (Size: 0x4)
MinimalViewInfo.PostProcessSettings = 0x40 // FPostProcessSettings (Size: 0x690)
MinimalViewInfo.OffCenterProjectionOffset = 0x6d0 // FVector2D (Size: 0x8)
MinimalViewInfo.FOVMode = 0x6d8 // uint8_t (Size: 0x1)
ModelComponent.ModelBodySetup = 0x5e0 // BodySetup* (Size: 0x8)
ModulatorContinuousParams.ParameterName = 0x0 // FName (Size: 0x8)
ModulatorContinuousParams.Default = 0x8 // float (Size: 0x4)
ModulatorContinuousParams.MinInput = 0xc // float (Size: 0x4)
ModulatorContinuousParams.MaxInput = 0x10 // float (Size: 0x4)
ModulatorContinuousParams.MinOutput = 0x14 // float (Size: 0x4)
ModulatorContinuousParams.MaxOutput = 0x18 // float (Size: 0x4)
ModulatorContinuousParams.ParamMode = 0x1c // uint8_t (Size: 0x1)
MorphTarget.BaseSkelMesh = 0x28 // SkeletalMesh* (Size: 0x8)
MovementComponent.UpdatedComponent = 0xf8 // SceneComponent* (Size: 0x8)
MovementComponent.UpdatedPrimitive = 0x100 // PrimitiveComponent* (Size: 0x8)
MovementComponent.Velocity = 0x10c // FVector (Size: 0xc)
MovementComponent.PlaneConstraintNormal = 0x118 // FVector (Size: 0xc)
MovementComponent.PlaneConstraintOrigin = 0x124 // FVector (Size: 0xc)
MovementComponent.bUpdateOnlyIfRendered = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bAutoUpdateTickRegistration = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bTickBeforeOwner = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bAutoRegisterUpdatedComponent = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bConstrainToPlane = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bSnapToPlaneAtStart = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bAutoRegisterPhysicsVolumeUpdates = 0x130 // uint8_t (Size: 0x1)
MovementComponent.bComponentShouldUpdatePhysicsVolume = 0x130 // uint8_t (Size: 0x1)
MovementComponent.PlaneConstraintAxisSetting = 0x133 // EEPlaneConstraintAxisSetting (Size: 0x1)
MovementProperties.bCanCrouch = 0x0 // uint8_t (Size: 0x1)
MovementProperties.bCanJump = 0x0 // uint8_t (Size: 0x1)
MovementProperties.bCanWalk = 0x0 // uint8_t (Size: 0x1)
MovementProperties.bCanSwim = 0x0 // uint8_t (Size: 0x1)
MovementProperties.bCanFly = 0x0 // uint8_t (Size: 0x1)
MulticastRecordOptions.FuncPathName = 0x0 // FString (Size: 0x10)
MulticastRecordOptions.bServerSkip = 0x10 // bool (Size: 0x1)
MulticastRecordOptions.bClientSkip = 0x11 // bool (Size: 0x1)
NameCurve.Keys = 0x68 // TArray<FNameCurveKey> (Size: 0x10)
NameCurveKey.Time = 0x0 // float (Size: 0x4)
NameCurveKey.Value = 0x4 // FName (Size: 0x8)
NameMapping.NodeName = 0x0 // FName (Size: 0x8)
NameMapping.BoneName = 0x8 // FName (Size: 0x8)
NamedColor.Value = 0x0 // FColor (Size: 0x4)
NamedColor.Name = 0x4 // FName (Size: 0x8)
NamedCurveValue.Name = 0x0 // FName (Size: 0x8)
NamedCurveValue.Value = 0x8 // float (Size: 0x4)
NamedEmitterMaterial.Name = 0x0 // FName (Size: 0x8)
NamedEmitterMaterial.Material = 0x8 // MaterialInterface* (Size: 0x8)
NamedFloat.Value = 0x0 // float (Size: 0x4)
NamedFloat.Name = 0x4 // FName (Size: 0x8)
NamedNetDriver.NetDriver = 0x0 // NetDriver* (Size: 0x8)
NamedTransform.Value = 0x0 // FTransform (Size: 0x30)
NamedTransform.Name = 0x30 // FName (Size: 0x8)
NamedVector.Value = 0x0 // FVector (Size: 0xc)
NamedVector.Name = 0xc // FName (Size: 0x8)
NavAgentProperties.AgentRadius = 0x4 // float (Size: 0x4)
NavAgentProperties.AgentHeight = 0x8 // float (Size: 0x4)
NavAgentProperties.AgentStepHeight = 0xc // float (Size: 0x4)
NavAgentProperties.NavWalkingSearchHeightScale = 0x10 // float (Size: 0x4)
NavAgentProperties.PreferredNavData = 0x18 // FSoftClassPath (Size: 0x18)
NavAgentSelector.bSupportsAgent0 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent1 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent2 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent3 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent4 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent5 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent6 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent7 = 0x0 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent8 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent9 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent10 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent11 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent12 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent13 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent14 = 0x1 // uint8_t (Size: 0x1)
NavAgentSelector.bSupportsAgent15 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup0 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup1 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup2 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup3 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup4 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup5 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup6 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup7 = 0x0 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup8 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup9 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup10 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup11 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup12 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup13 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup14 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup15 = 0x1 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup16 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup17 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup18 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup19 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup20 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup21 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup22 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup23 = 0x2 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup24 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup25 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup26 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup27 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup28 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup29 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup30 = 0x3 // uint8_t (Size: 0x1)
NavAvoidanceMask.bGroup31 = 0x3 // uint8_t (Size: 0x1)
NavCollisionBase.bIsDynamicObstacle = 0x28 // uint8_t (Size: 0x1)
NavDataConfig.Name = 0x30 // FName (Size: 0x8)
NavDataConfig.Color = 0x38 // FColor (Size: 0x4)
NavDataConfig.DefaultQueryExtent = 0x3c // FVector (Size: 0xc)
NavDataConfig.NavigationDataClass = 0x48 // ClassProperty (Size: 0x8)
NavDataConfig.NavDataClass = 0x50 // TSoftClassPtr<UObject> (Size: 0x28)
NavLinkDefinition.Links = 0x28 // TArray<FNavigationLink> (Size: 0x10)
NavLinkDefinition.SegmentLinks = 0x38 // TArray<FNavigationSegmentLink> (Size: 0x10)
NavLinkId.ID = 0x0 // uint64_t (Size: 0x8)
NavMovementComponent.NavAgentProps = 0x138 // FNavAgentProperties (Size: 0x30)
NavMovementComponent.FixedPathBrakingDistance = 0x168 // float (Size: 0x4)
NavMovementComponent.bUpdateNavAgentWithOwnersCollision = 0x16c // uint8_t (Size: 0x1)
NavMovementComponent.bUseAccelerationForPaths = 0x16c // uint8_t (Size: 0x1)
NavMovementComponent.bUseFixedBrakingDistanceForPaths = 0x16c // uint8_t (Size: 0x1)
NavMovementComponent.MovementState = 0x16d // FMovementProperties (Size: 0x1)
NavMovementComponent.PathFollowingComp = 0x170 // Object* (Size: 0x8)
NavigationDataChunk.NavigationDataName = 0x28 // FName (Size: 0x8)
NavigationLink.Left = 0x30 // FVector (Size: 0xc)
NavigationLink.Right = 0x3c // FVector (Size: 0xc)
NavigationLinkBase.LeftProjectHeight = 0x0 // float (Size: 0x4)
NavigationLinkBase.MaxFallDownLength = 0x4 // float (Size: 0x4)
NavigationLinkBase.SnapRadius = 0xc // float (Size: 0x4)
NavigationLinkBase.SnapHeight = 0x10 // float (Size: 0x4)
NavigationLinkBase.SupportedAgents = 0x14 // FNavAgentSelector (Size: 0x4)
NavigationLinkBase.bSupportsAgent0 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent1 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent2 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent3 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent4 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent5 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent6 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent7 = 0x18 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent8 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent9 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent10 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent11 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent12 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent13 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent14 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.bSupportsAgent15 = 0x19 // uint8_t (Size: 0x1)
NavigationLinkBase.Direction = 0x1c // uint8_t (Size: 0x1)
NavigationLinkBase.bUseSnapHeight = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bSnapToCheapestArea = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag0 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag1 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag2 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag3 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag4 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag5 = 0x1d // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag6 = 0x1e // uint8_t (Size: 0x1)
NavigationLinkBase.bCustomFlag7 = 0x1e // uint8_t (Size: 0x1)
NavigationLinkBase.AreaClass = 0x20 // ClassProperty (Size: 0x8)
NavigationObjectBase.CapsuleComponent = 0x318 // CapsuleComponent* (Size: 0x8)
NavigationObjectBase.GoodSprite = 0x320 // BillboardComponent* (Size: 0x8)
NavigationObjectBase.BadSprite = 0x328 // BillboardComponent* (Size: 0x8)
NavigationObjectBase.bIsPIEPlayerStart = 0x330 // uint8_t (Size: 0x1)
NavigationSegmentLink.LeftStart = 0x30 // FVector (Size: 0xc)
NavigationSegmentLink.LeftEnd = 0x3c // FVector (Size: 0xc)
NavigationSegmentLink.RightStart = 0x48 // FVector (Size: 0xc)
NavigationSegmentLink.RightEnd = 0x54 // FVector (Size: 0xc)
NavigationSystemConfig.NavigationSystemClass = 0x28 // FSoftClassPath (Size: 0x18)
NavigationSystemConfig.SupportedAgentsMask = 0x40 // FNavAgentSelector (Size: 0x4)
NavigationSystemConfig.DefaultAgentName = 0x44 // FName (Size: 0x8)
NavigationSystemConfig.bIsOverriden = 0x4c // uint8_t (Size: 0x1)
NetConnection.Children = 0x48 // TArray<ChildConnection*> (Size: 0x10)
NetConnection.Driver = 0x58 // NetDriver* (Size: 0x8)
NetConnection.PackageMapClass = 0x60 // ClassProperty (Size: 0x8)
NetConnection.PackageMap = 0x68 // PackageMap* (Size: 0x8)
NetConnection.OpenChannels = 0x70 // TArray<Channel*> (Size: 0x10)
NetConnection.SentTemporaries = 0x80 // TArray<Actor*> (Size: 0x10)
NetConnection.ViewTarget = 0x90 // Actor* (Size: 0x8)
NetConnection.OwningActor = 0x98 // Actor* (Size: 0x8)
NetConnection.MaxPacket = 0xa0 // int32_t (Size: 0x4)
NetConnection.bClientNotSendClose = 0xa4 // bool (Size: 0x1)
NetConnection.InternalAck = 0xa8 // uint8_t (Size: 0x1)
NetConnection.PlayerId = 0x188 // FUniqueNetIdRepl (Size: 0x28)
NetConnection.LastReceiveTime = 0x1f8 // double (Size: 0x8)
NetConnection.HasSentDormantDestructionInfoChannelsMap = 0x1408 // TMap<...> (Size: 0x50)
NetConnection.ChannelsToTick = 0x15a0 // TArray<Channel*> (Size: 0x10)
NetConnection.RPCMonitorArray = 0x1b80 // TArray<FRPCMonitorStruct> (Size: 0x10)
NetConnection.MonitorSecondsPerStruct = 0x1b98 // int32_t (Size: 0x4)
NetDriver.NetConnectionClassName = 0x30 // FString (Size: 0x10)
NetDriver.ReplicationDriverClassName = 0x40 // FString (Size: 0x10)
NetDriver.MaxDownloadSize = 0x50 // int32_t (Size: 0x4)
NetDriver.bClampListenServerTickRate = 0x54 // uint8_t (Size: 0x1)
NetDriver.NetServerMaxTickRate = 0x58 // int32_t (Size: 0x4)
NetDriver.MaxNetTickRate = 0x5c // int32_t (Size: 0x4)
NetDriver.MaxInternetClientRate = 0x60 // int32_t (Size: 0x4)
NetDriver.MaxClientRate = 0x64 // int32_t (Size: 0x4)
NetDriver.ServerTravelPause = 0x68 // float (Size: 0x4)
NetDriver.SpawnPrioritySeconds = 0x6c // float (Size: 0x4)
NetDriver.RelevantTimeout = 0x70 // float (Size: 0x4)
NetDriver.KeepAliveTime = 0x74 // float (Size: 0x4)
NetDriver.InitialConnectTimeout = 0x78 // float (Size: 0x4)
NetDriver.ConnectionTimeout = 0x7c // float (Size: 0x4)
NetDriver.TimeoutMultiplierForUnoptimizedBuilds = 0x80 // float (Size: 0x4)
NetDriver.bNoTimeouts = 0x84 // bool (Size: 0x1)
NetDriver.bNeverApplyNetworkEmulationSettings = 0x85 // bool (Size: 0x1)
NetDriver.ServerConnection = 0x88 // NetConnection* (Size: 0x8)
NetDriver.ClientConnections = 0x90 // TArray<NetConnection*> (Size: 0x10)
NetDriver.RecentlyDisconnectedTrackingTime = 0x100 // int32_t (Size: 0x4)
NetDriver.World = 0x140 // World* (Size: 0x8)
NetDriver.WorldPackage = 0x148 // Package* (Size: 0x8)
NetDriver.NetConnectionClass = 0x170 // ClassProperty (Size: 0x8)
NetDriver.ReplicationDriverClass = 0x178 // ClassProperty (Size: 0x8)
NetDriver.NetDriverName = 0x190 // FName (Size: 0x8)
NetDriver.ChannelDefinitions = 0x198 // TArray<FChannelDefinition> (Size: 0x10)
NetDriver.ChannelDefinitionMap = 0x1a8 // TMap<...> (Size: 0x50)
NetDriver.ActorChannelPool = 0x1f8 // TArray<Channel*> (Size: 0x10)
NetDriver.Time = 0x210 // float (Size: 0x4)
NetDriver.ReplicationDriver = 0x6f8 // ReplicationDriver* (Size: 0x8)
NetDriverDefinition.DefName = 0x0 // FName (Size: 0x8)
NetDriverDefinition.DriverClassName = 0x8 // FName (Size: 0x8)
NetDriverDefinition.DriverClassNameFallback = 0x10 // FName (Size: 0x8)
NetViewer.Connection = 0x0 // NetConnection* (Size: 0x8)
NetViewer.InViewer = 0x8 // Actor* (Size: 0x8)
NetViewer.ViewTarget = 0x10 // Actor* (Size: 0x8)
NetViewer.ViewLocation = 0x18 // FVector (Size: 0xc)
NetViewer.ViewDir = 0x24 // FVector (Size: 0xc)
NetworkEmulationProfileDescription.ProfileName = 0x0 // FString (Size: 0x10)
NetworkEmulationProfileDescription.ToolTip = 0x10 // FString (Size: 0x10)
NetworkObjPoolRulesObject.RuleClassName = 0x28 // FString (Size: 0x10)
NetworkSettings.bVerifyPeer = 0x38 // uint8_t (Size: 0x1)
NetworkSettings.bEnableMultiplayerWorldOriginRebasing = 0x38 // uint8_t (Size: 0x1)
NetworkSettings.MaxRepArraySize = 0x3c // int32_t (Size: 0x4)
NetworkSettings.MaxRepArrayMemory = 0x40 // int32_t (Size: 0x4)
NetworkSettings.NetworkEmulationProfiles = 0x48 // TArray<FNetworkEmulationProfileDescription> (Size: 0x10)
Node.Name = 0x0 // FName (Size: 0x8)
Node.ParentName = 0x8 // FName (Size: 0x8)
Node.Transform = 0x10 // FTransform (Size: 0x30)
Node.DisplayName = 0x40 // FString (Size: 0x10)
Node.bAdvanced = 0x50 // bool (Size: 0x1)
NodeItem.ParentName = 0x0 // FName (Size: 0x8)
NodeItem.Transform = 0x10 // FTransform (Size: 0x30)
NodeMappingContainer.SourceItems = 0x28 // TMap<...> (Size: 0x50)
NodeMappingContainer.TargetItems = 0x78 // TMap<...> (Size: 0x50)
NodeMappingContainer.SourceToTarget = 0xc8 // TMap<...> (Size: 0x50)
NodeMappingContainer.SourceAsset = 0x118 // TSoftObjectPtr<UObject> (Size: 0x28)
NodeMappingContainer.TargetAsset = 0x140 // TSoftObjectPtr<UObject> (Size: 0x28)
ObjectLibrary.ObjectBaseClass = 0x28 // ClassProperty (Size: 0x8)
ObjectLibrary.bHasBlueprintClasses = 0x30 // bool (Size: 0x1)
ObjectLibrary.Objects = 0x38 // TArray<Object*> (Size: 0x10)
ObjectLibrary.WeakObjects = 0x48 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
ObjectLibrary.bUseWeakReferences = 0x58 // bool (Size: 0x1)
ObjectLibrary.bIsFullyLoaded = 0x59 // bool (Size: 0x1)
ObjectReferencer.ReferencedObjects = 0x28 // TArray<Object*> (Size: 0x10)
OpacityMicromap.bEnabled = 0x0 // bool (Size: 0x1)
OpacityMicromap.SubdivisionLevel = 0x4 // uint32_t (Size: 0x4)
OpacityMicromap.UVChannelIndex = 0x8 // uint32_t (Size: 0x4)
OpacityMicromap.TextureChannelIndex = 0xc // uint32_t (Size: 0x4)
OpacityMicromap.DynamicSubdivisionScale = 0x10 // float (Size: 0x4)
OpacityMicromap.Format = 0x14 // EEOpacityMicromapFormat (Size: 0x2)
OpacityMicromap.Texture = 0x18 // Texture2D* (Size: 0x8)
OrbitOptions.bProcessDuringSpawn = 0x0 // uint8_t (Size: 0x1)
OrbitOptions.bProcessDuringUpdate = 0x0 // uint8_t (Size: 0x1)
OrbitOptions.bUseEmitterTime = 0x0 // uint8_t (Size: 0x1)
OverlapResult.Actor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
OverlapResult.Component = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
OverlapResult.bBlockingHit = 0x14 // uint8_t (Size: 0x1)
POV.Location = 0x0 // FVector (Size: 0xc)
POV.Rotation = 0xc // FRotator (Size: 0xc)
POV.FOV = 0x18 // float (Size: 0x4)
PSCPool.FreeElements = 0x0 // TArray<FPSCPoolElem> (Size: 0x10)
PSCPool.InUseComponents_Auto = 0x10 // TArray<ParticleSystemComponent*> (Size: 0x10)
PSCPool.InUseComponents_Manual = 0x20 // TArray<ParticleSystemComponent*> (Size: 0x10)
PSCPoolElem.PSC = 0x0 // ParticleSystemComponent* (Size: 0x8)
PacketSimulationSettings.PktLoss = 0x0 // int32_t (Size: 0x4)
PacketSimulationSettings.PktLossMaxSize = 0x4 // int32_t (Size: 0x4)
PacketSimulationSettings.PktLossMinSize = 0x8 // int32_t (Size: 0x4)
PacketSimulationSettings.PktOrder = 0xc // int32_t (Size: 0x4)
PacketSimulationSettings.PktDup = 0x10 // int32_t (Size: 0x4)
PacketSimulationSettings.PktLag = 0x14 // int32_t (Size: 0x4)
PacketSimulationSettings.PktLagVariance = 0x18 // int32_t (Size: 0x4)
PacketSimulationSettings.PktLagMin = 0x1c // int32_t (Size: 0x4)
PacketSimulationSettings.PktLagMax = 0x20 // int32_t (Size: 0x4)
PacketSimulationSettings.PktIncomingLagMin = 0x24 // int32_t (Size: 0x4)
PacketSimulationSettings.PktIncomingLagMax = 0x28 // int32_t (Size: 0x4)
PacketSimulationSettings.PktIncomingLoss = 0x2c // int32_t (Size: 0x4)
PacketSimulationSettings.PktJitter = 0x30 // int32_t (Size: 0x4)
PainCausingVolume.bPainCausing = 0x358 // uint8_t (Size: 0x1)
PainCausingVolume.DamagePerSec = 0x35c // float (Size: 0x4)
PainCausingVolume.DamageType = 0x360 // ClassProperty (Size: 0x8)
PainCausingVolume.PainInterval = 0x368 // float (Size: 0x4)
PainCausingVolume.bEntryPain = 0x36c // uint8_t (Size: 0x1)
PainCausingVolume.BACKUP_bPainCausing = 0x36c // uint8_t (Size: 0x1)
PainCausingVolume.DamageInstigator = 0x370 // Controller* (Size: 0x8)
PaintedVertex.position = 0x0 // FVector (Size: 0xc)
PaintedVertex.Color = 0xc // FColor (Size: 0x4)
PaintedVertex.Normal = 0x10 // FVector4 (Size: 0x10)
ParameterChannelNames.R = 0x0 // FText (Size: 0x18)
ParameterChannelNames.G = 0x18 // FText (Size: 0x18)
ParameterChannelNames.B = 0x30 // FText (Size: 0x18)
ParameterChannelNames.A = 0x48 // FText (Size: 0x18)
ParameterGroupData.GroupName = 0x0 // FString (Size: 0x10)
ParameterGroupData.GroupSortPriority = 0x10 // int32_t (Size: 0x4)
ParticleBurst.Count = 0x0 // int32_t (Size: 0x4)
ParticleBurst.CountLow = 0x4 // int32_t (Size: 0x4)
ParticleBurst.Time = 0x8 // float (Size: 0x4)
ParticleCurvePair.CurveName = 0x0 // FString (Size: 0x10)
ParticleCurvePair.CurveObject = 0x10 // Object* (Size: 0x8)
ParticleEditorPromotionSettings.DefaultParticleAsset = 0x0 // FFilePath (Size: 0x10)
ParticleEmitter.EmitterName = 0x28 // FName (Size: 0x8)
ParticleEmitter.SubUVDataOffset = 0x30 // int32_t (Size: 0x4)
ParticleEmitter.EmitterRenderMode = 0x34 // uint8_t (Size: 0x1)
ParticleEmitter.SignificanceLevel = 0x35 // EEParticleSignificanceLevel (Size: 0x1)
ParticleEmitter.bUseLegacySpawningBehavior = 0x37 // uint8_t (Size: 0x1)
ParticleEmitter.ConvertedModules = 0x37 // uint8_t (Size: 0x1)
ParticleEmitter.bIsSoloing = 0x37 // uint8_t (Size: 0x1)
ParticleEmitter.bCookedOut = 0x37 // uint8_t (Size: 0x1)
ParticleEmitter.bDisabledLODsKeepEmitterAlive = 0x37 // uint8_t (Size: 0x1)
ParticleEmitter.bDisableWhenInsignficant = 0x38 // uint8_t (Size: 0x1)
ParticleEmitter.LODLevels = 0x40 // TArray<ParticleLODLevel*> (Size: 0x10)
ParticleEmitter.PeakActiveParticles = 0x50 // int32_t (Size: 0x4)
ParticleEmitter.InitialAllocationCount = 0x54 // int32_t (Size: 0x4)
ParticleEmitter.QualityLevelSpawnRateScale = 0x58 // float (Size: 0x4)
ParticleEmitter.DetailModeBitmask = 0x5c // uint32_t (Size: 0x4)
ParticleEvent_GenerateInfo.Type = 0x0 // uint8_t (Size: 0x1)
ParticleEvent_GenerateInfo.Frequency = 0x4 // int32_t (Size: 0x4)
ParticleEvent_GenerateInfo.ParticleFrequency = 0x8 // int32_t (Size: 0x4)
ParticleEvent_GenerateInfo.FirstTimeOnly = 0xc // uint8_t (Size: 0x1)
ParticleEvent_GenerateInfo.LastTimeOnly = 0xc // uint8_t (Size: 0x1)
ParticleEvent_GenerateInfo.UseReflectedImpactVector = 0xc // uint8_t (Size: 0x1)
ParticleEvent_GenerateInfo.bUseOrbitOffset = 0xc // uint8_t (Size: 0x1)
ParticleEvent_GenerateInfo.CustomName = 0x10 // FName (Size: 0x8)
ParticleEvent_GenerateInfo.ParticleModuleEventsToSendToGame = 0x18 // TArray<ParticleModuleEventSendToGame*> (Size: 0x10)
ParticleLODLevel.Level = 0x28 // int32_t (Size: 0x4)
ParticleLODLevel.bEnabled = 0x2c // uint8_t (Size: 0x1)
ParticleLODLevel.RequiredModule = 0x30 // ParticleModuleRequired* (Size: 0x8)
ParticleLODLevel.Modules = 0x38 // TArray<ParticleModule*> (Size: 0x10)
ParticleLODLevel.TypeDataModule = 0x48 // ParticleModuleTypeDataBase* (Size: 0x8)
ParticleLODLevel.SpawnModule = 0x50 // ParticleModuleSpawn* (Size: 0x8)
ParticleLODLevel.EventGenerator = 0x58 // ParticleModuleEventGenerator* (Size: 0x8)
ParticleLODLevel.SpawningModules = 0x60 // TArray<ParticleModuleSpawnBase*> (Size: 0x10)
ParticleLODLevel.SpawnModules = 0x70 // TArray<ParticleModule*> (Size: 0x10)
ParticleLODLevel.UpdateModules = 0x80 // TArray<ParticleModule*> (Size: 0x10)
ParticleLODLevel.OrbitModules = 0x90 // TArray<ParticleModuleOrbit*> (Size: 0x10)
ParticleLODLevel.EventReceiverModules = 0xa0 // TArray<ParticleModuleEventReceiverBase*> (Size: 0x10)
ParticleLODLevel.ConvertedModules = 0xb0 // uint8_t (Size: 0x1)
ParticleLODLevel.PeakActiveParticles = 0xb4 // int32_t (Size: 0x4)
ParticleModule.bSpawnModule = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bUpdateModule = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bFinalUpdateModule = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bUpdateForGPUEmitter = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bCurvesAsColor = 0x28 // uint8_t (Size: 0x1)
ParticleModule.b3DDrawMode = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bSupported3DDrawMode = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bEnabled = 0x28 // uint8_t (Size: 0x1)
ParticleModule.bEditable = 0x29 // uint8_t (Size: 0x1)
ParticleModule.LODDuplicate = 0x29 // uint8_t (Size: 0x1)
ParticleModule.bSupportsRandomSeed = 0x29 // uint8_t (Size: 0x1)
ParticleModule.bRequiresLoopingNotification = 0x29 // uint8_t (Size: 0x1)
ParticleModule.LODValidity = 0x2a // uint8_t (Size: 0x1)
ParticleModuleAcceleration.Acceleration = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleAcceleration.bApplyOwnerScale = 0x80 // uint8_t (Size: 0x1)
ParticleModuleAccelerationBase.bAlwaysInWorldSpace = 0x30 // uint8_t (Size: 0x1)
ParticleModuleAccelerationConstant.Acceleration = 0x38 // FVector (Size: 0xc)
ParticleModuleAccelerationDrag.DragCoefficient = 0x38 // DistributionFloat* (Size: 0x8)
ParticleModuleAccelerationDrag.DragCoefficientRaw = 0x40 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAccelerationDragScaleOverLife.DragScale = 0x38 // DistributionFloat* (Size: 0x8)
ParticleModuleAccelerationDragScaleOverLife.DragScaleRaw = 0x40 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAccelerationOverLifetime.AccelOverLife = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleAttractorLine.EndPoint0 = 0x30 // FVector (Size: 0xc)
ParticleModuleAttractorLine.EndPoint1 = 0x3c // FVector (Size: 0xc)
ParticleModuleAttractorLine.Range = 0x48 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorLine.Strength = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorParticle.EmitterName = 0x30 // FName (Size: 0x8)
ParticleModuleAttractorParticle.Range = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorParticle.bStrengthByDistance = 0x68 // uint8_t (Size: 0x1)
ParticleModuleAttractorParticle.Strength = 0x70 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorParticle.bAffectBaseVelocity = 0xa0 // uint8_t (Size: 0x1)
ParticleModuleAttractorParticle.SelectionMethod = 0xa4 // uint8_t (Size: 0x1)
ParticleModuleAttractorParticle.bRenewSource = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleAttractorParticle.bInheritSourceVel = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleAttractorParticle.LastSelIndex = 0xac // int32_t (Size: 0x4)
ParticleModuleAttractorPoint.position = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleAttractorPoint.Range = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorPoint.Strength = 0xa8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleAttractorPoint.StrengthByDistance = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.bAffectBaseVelocity = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.bOverrideVelocity = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.bUseWorldSpacePosition = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Positive_X = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Positive_Y = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Positive_Z = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Negative_X = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Negative_Y = 0xd9 // uint8_t (Size: 0x1)
ParticleModuleAttractorPoint.Negative_Z = 0xd9 // uint8_t (Size: 0x1)
ParticleModuleAttractorPointGravity.position = 0x30 // FVector (Size: 0xc)
ParticleModuleAttractorPointGravity.Radius = 0x3c // float (Size: 0x4)
ParticleModuleAttractorPointGravity.Strength = 0x40 // DistributionFloat* (Size: 0x8)
ParticleModuleAttractorPointGravity.StrengthRaw = 0x48 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamModifier.ModifierType = 0x30 // uint8_t (Size: 0x1)
ParticleModuleBeamModifier.PositionOptions = 0x34 // FBeamModifierOptions (Size: 0x4)
ParticleModuleBeamModifier.position = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamModifier.TangentOptions = 0x80 // FBeamModifierOptions (Size: 0x4)
ParticleModuleBeamModifier.Tangent = 0x88 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamModifier.bAbsoluteTangent = 0xd0 // uint8_t (Size: 0x1)
ParticleModuleBeamModifier.StrengthOptions = 0xd4 // FBeamModifierOptions (Size: 0x4)
ParticleModuleBeamModifier.Strength = 0xd8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamNoise.bLowFreq_Enabled = 0x30 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.Frequency = 0x34 // int32_t (Size: 0x4)
ParticleModuleBeamNoise.Frequency_LowRange = 0x38 // int32_t (Size: 0x4)
ParticleModuleBeamNoise.NoiseRange = 0x40 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamNoise.NoiseRangeScale = 0x88 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamNoise.bNRScaleEmitterTime = 0xb8 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.NoiseSpeed = 0xc0 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamNoise.bSmooth = 0x108 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.NoiseLockRadius = 0x10c // float (Size: 0x4)
ParticleModuleBeamNoise.bNoiseLock = 0x110 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.bOscillate = 0x110 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.NoiseLockTime = 0x114 // float (Size: 0x4)
ParticleModuleBeamNoise.NoiseTension = 0x118 // float (Size: 0x4)
ParticleModuleBeamNoise.bUseNoiseTangents = 0x11c // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.NoiseTangentStrength = 0x120 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamNoise.NoiseTessellation = 0x150 // int32_t (Size: 0x4)
ParticleModuleBeamNoise.bTargetNoise = 0x154 // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.FrequencyDistance = 0x158 // float (Size: 0x4)
ParticleModuleBeamNoise.bApplyNoiseScale = 0x15c // uint8_t (Size: 0x1)
ParticleModuleBeamNoise.NoiseScale = 0x160 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamSource.SourceMethod = 0x30 // uint8_t (Size: 0x1)
ParticleModuleBeamSource.SourceName = 0x34 // FName (Size: 0x8)
ParticleModuleBeamSource.bSourceAbsolute = 0x3c // uint8_t (Size: 0x1)
ParticleModuleBeamSource.Source = 0x40 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamSource.bLockSource = 0x88 // uint8_t (Size: 0x1)
ParticleModuleBeamSource.SourceTangentMethod = 0x8c // uint8_t (Size: 0x1)
ParticleModuleBeamSource.SourceTangent = 0x90 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamSource.bLockSourceTangent = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleBeamSource.SourceStrength = 0xe0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamSource.bLockSourceStength = 0x110 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.TargetMethod = 0x30 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.TargetName = 0x34 // FName (Size: 0x8)
ParticleModuleBeamTarget.Target = 0x40 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamTarget.bTargetAbsolute = 0x88 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.bLockTarget = 0x88 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.TargetTangentMethod = 0x8c // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.TargetTangent = 0x90 // FRawDistributionVector (Size: 0x48)
ParticleModuleBeamTarget.bLockTargetTangent = 0xd8 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.TargetStrength = 0xe0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleBeamTarget.bLockTargetStength = 0x110 // uint8_t (Size: 0x1)
ParticleModuleBeamTarget.LockRadius = 0x114 // float (Size: 0x4)
ParticleModuleCameraOffset.CameraOffset = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCameraOffset.bSpawnTimeOnly = 0x60 // uint8_t (Size: 0x1)
ParticleModuleCameraOffset.UpdateMethod = 0x64 // uint8_t (Size: 0x1)
ParticleModuleCollision.DampingFactor = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleCollision.DampingFactorRotation = 0x78 // FRawDistributionVector (Size: 0x48)
ParticleModuleCollision.MaxCollisions = 0xc0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCollision.CollisionCompletionOption = 0xf0 // uint8_t (Size: 0x1)
ParticleModuleCollision.CollisionTypes = 0xf8 // TArray<uint8_t> (Size: 0x10)
ParticleModuleCollision.bApplyPhysics = 0x110 // uint8_t (Size: 0x1)
ParticleModuleCollision.bIgnoreTriggerVolumes = 0x110 // uint8_t (Size: 0x1)
ParticleModuleCollision.ParticleMass = 0x118 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCollision.DirScalar = 0x148 // float (Size: 0x4)
ParticleModuleCollision.bPawnsDoNotDecrementCount = 0x14c // uint8_t (Size: 0x1)
ParticleModuleCollision.bOnlyVerticalNormalsDecrementCount = 0x14c // uint8_t (Size: 0x1)
ParticleModuleCollision.VerticalFudgeFactor = 0x150 // float (Size: 0x4)
ParticleModuleCollision.DelayAmount = 0x158 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCollision.bDropDetail = 0x188 // uint8_t (Size: 0x1)
ParticleModuleCollision.bCollideOnlyIfVisible = 0x188 // uint8_t (Size: 0x1)
ParticleModuleCollision.bIgnoreSourceActor = 0x188 // uint8_t (Size: 0x1)
ParticleModuleCollision.MaxCollisionDistance = 0x18c // float (Size: 0x4)
ParticleModuleCollisionGPU.Resilience = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCollisionGPU.ResilienceScaleOverLife = 0x60 // FRawDistributionFloat (Size: 0x30)
ParticleModuleCollisionGPU.Friction = 0x90 // float (Size: 0x4)
ParticleModuleCollisionGPU.RandomSpread = 0x94 // float (Size: 0x4)
ParticleModuleCollisionGPU.RandomDistribution = 0x98 // float (Size: 0x4)
ParticleModuleCollisionGPU.RadiusScale = 0x9c // float (Size: 0x4)
ParticleModuleCollisionGPU.RadiusBias = 0xa0 // float (Size: 0x4)
ParticleModuleCollisionGPU.Response = 0xa4 // uint8_t (Size: 0x1)
ParticleModuleCollisionGPU.CollisionMode = 0xa5 // uint8_t (Size: 0x1)
ParticleModuleColor.StartColor = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleColor.StartAlpha = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleColor.bClampAlpha = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleColorOverLife.ColorOverLife = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleColorOverLife.AlphaOverLife = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleColorOverLife.bClampAlpha = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleColorScaleOverLife.ColorScaleOverLife = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleColorScaleOverLife.AlphaScaleOverLife = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleColorScaleOverLife.bEmitterTime = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleColor_Seeded.RandomSeedInfo = 0xb0 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleEventGenerator.Events = 0x30 // TArray<FParticleEvent_GenerateInfo> (Size: 0x10)
ParticleModuleEventReceiverBase.EventGeneratorType = 0x30 // uint8_t (Size: 0x1)
ParticleModuleEventReceiverBase.EventName = 0x34 // FName (Size: 0x8)
ParticleModuleEventReceiverKillParticles.bStopSpawning = 0x40 // uint8_t (Size: 0x1)
ParticleModuleEventReceiverSpawn.SpawnCount = 0x40 // FRawDistributionFloat (Size: 0x30)
ParticleModuleEventReceiverSpawn.bUseParticleTime = 0x70 // uint8_t (Size: 0x1)
ParticleModuleEventReceiverSpawn.bUsePSysLocation = 0x70 // uint8_t (Size: 0x1)
ParticleModuleEventReceiverSpawn.bInheritVelocity = 0x70 // uint8_t (Size: 0x1)
ParticleModuleEventReceiverSpawn.InheritVelocityScale = 0x78 // FRawDistributionVector (Size: 0x48)
ParticleModuleEventReceiverSpawn.PhysicalMaterials = 0xc0 // TArray<PhysicalMaterial*> (Size: 0x10)
ParticleModuleEventReceiverSpawn.bBanPhysicalMaterials = 0xd0 // uint8_t (Size: 0x1)
ParticleModuleKillBox.LowerLeftCorner = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleKillBox.UpperRightCorner = 0x78 // FRawDistributionVector (Size: 0x48)
ParticleModuleKillBox.bAbsolute = 0xc0 // uint8_t (Size: 0x1)
ParticleModuleKillBox.bKillInside = 0xc0 // uint8_t (Size: 0x1)
ParticleModuleKillBox.bAxisAlignedAndFixedSize = 0xc0 // uint8_t (Size: 0x1)
ParticleModuleKillHeight.Height = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleKillHeight.bAbsolute = 0x60 // uint8_t (Size: 0x1)
ParticleModuleKillHeight.bFloor = 0x60 // uint8_t (Size: 0x1)
ParticleModuleKillHeight.bApplyPSysScale = 0x60 // uint8_t (Size: 0x1)
ParticleModuleLifetime.LifeTime = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLifetime_Seeded.RandomSeedInfo = 0x60 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleLight.bUseInverseSquaredFalloff = 0x30 // bool (Size: 0x1)
ParticleModuleLight.bAffectsTranslucency = 0x31 // bool (Size: 0x1)
ParticleModuleLight.bPreviewLightRadius = 0x32 // bool (Size: 0x1)
ParticleModuleLight.SpawnFraction = 0x34 // float (Size: 0x4)
ParticleModuleLight.ColorScaleOverLife = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleLight.BrightnessOverLife = 0x80 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLight.RadiusScale = 0xb0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLight.LightExponent = 0xe0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLight.LightingChannels = 0x110 // FLightingChannels (Size: 0x1)
ParticleModuleLight.VolumetricScatteringIntensity = 0x114 // float (Size: 0x4)
ParticleModuleLight.bHighQualityLights = 0x118 // bool (Size: 0x1)
ParticleModuleLight.bShadowCastingLights = 0x119 // bool (Size: 0x1)
ParticleModuleLight_Seeded.RandomSeedInfo = 0x120 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleLocation.StartLocation = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocation.DistributeOverNPoints = 0x78 // float (Size: 0x4)
ParticleModuleLocation.DistributeThreshold = 0x7c // float (Size: 0x4)
ParticleModuleLocationBoneSocket.SourceType = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationBoneSocket.UniversalOffset = 0x34 // FVector (Size: 0xc)
ParticleModuleLocationBoneSocket.SourceLocations = 0x40 // TArray<FLocationBoneSocketInfo> (Size: 0x10)
ParticleModuleLocationBoneSocket.SelectionMethod = 0x50 // uint8_t (Size: 0x1)
ParticleModuleLocationBoneSocket.bUpdatePositionEachFrame = 0x54 // uint8_t (Size: 0x1)
ParticleModuleLocationBoneSocket.bOrientMeshEmitters = 0x54 // uint8_t (Size: 0x1)
ParticleModuleLocationBoneSocket.bInheritBoneVelocity = 0x54 // uint8_t (Size: 0x1)
ParticleModuleLocationBoneSocket.InheritVelocityScale = 0x58 // float (Size: 0x4)
ParticleModuleLocationBoneSocket.SkelMeshActorParamName = 0x5c // FName (Size: 0x8)
ParticleModuleLocationBoneSocket.NumPreSelectedIndices = 0x64 // int32_t (Size: 0x4)
ParticleModuleLocationDirect.Location = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationDirect.LocationOffset = 0x78 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationDirect.ScaleFactor = 0xc0 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationDirect.Direction = 0x108 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationEmitter.EmitterName = 0x30 // FName (Size: 0x8)
ParticleModuleLocationEmitter.SelectionMethod = 0x38 // uint8_t (Size: 0x1)
ParticleModuleLocationEmitter.InheritSourceVelocity = 0x3c // uint8_t (Size: 0x1)
ParticleModuleLocationEmitter.InheritSourceVelocityScale = 0x40 // float (Size: 0x4)
ParticleModuleLocationEmitter.bInheritSourceRotation = 0x44 // uint8_t (Size: 0x1)
ParticleModuleLocationEmitter.InheritSourceRotationScale = 0x48 // float (Size: 0x4)
ParticleModuleLocationEmitterDirect.EmitterName = 0x30 // FName (Size: 0x8)
ParticleModuleLocationPrimitiveBase.Positive_X = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Positive_Y = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Positive_Z = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Negative_X = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Negative_Y = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Negative_Z = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.SurfaceOnly = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.Velocity = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveBase.VelocityScale = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveBase.StartLocation = 0x68 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationPrimitiveCylinder.RadialVelocity = 0xb0 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveCylinder.StartRadius = 0xb8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveCylinder.StartHeight = 0xe8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveCylinder.HeightAxis = 0x118 // uint8_t (Size: 0x1)
ParticleModuleLocationPrimitiveCylinder_Seeded.RandomSeedInfo = 0x120 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleLocationPrimitiveSphere.StartRadius = 0xb0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveSphere_Seeded.RandomSeedInfo = 0xe0 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleLocationPrimitiveTriangle.StartOffset = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleLocationPrimitiveTriangle.Height = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveTriangle.Angle = 0xa8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationPrimitiveTriangle.Thickness = 0xd8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleLocationSkelVertSurface.SourceType = 0x30 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.UniversalOffset = 0x34 // FVector (Size: 0xc)
ParticleModuleLocationSkelVertSurface.bUpdatePositionEachFrame = 0x40 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.bOrientMeshEmitters = 0x40 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.bInheritBoneVelocity = 0x40 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.InheritVelocityScale = 0x44 // float (Size: 0x4)
ParticleModuleLocationSkelVertSurface.SkelMeshActorParamName = 0x48 // FName (Size: 0x8)
ParticleModuleLocationSkelVertSurface.ValidAssociatedBones = 0x50 // TArray<FName> (Size: 0x10)
ParticleModuleLocationSkelVertSurface.bEnforceNormalCheck = 0x60 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.NormalToCompare = 0x64 // FVector (Size: 0xc)
ParticleModuleLocationSkelVertSurface.NormalCheckToleranceDegrees = 0x70 // float (Size: 0x4)
ParticleModuleLocationSkelVertSurface.NormalCheckTolerance = 0x74 // float (Size: 0x4)
ParticleModuleLocationSkelVertSurface.ValidMaterialIndices = 0x78 // TArray<int32_t> (Size: 0x10)
ParticleModuleLocationSkelVertSurface.bInheritVertexColor = 0x88 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.bInheritUV = 0x88 // uint8_t (Size: 0x1)
ParticleModuleLocationSkelVertSurface.InheritUVChannel = 0x8c // uint32_t (Size: 0x4)
ParticleModuleLocationWorldOffset_Seeded.RandomSeedInfo = 0x80 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleLocation_Seeded.RandomSeedInfo = 0x80 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleMeshMaterial.MeshMaterials = 0x30 // TArray<MaterialInterface*> (Size: 0x10)
ParticleModuleMeshRotation.StartRotation = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleMeshRotation.bInheritParent = 0x78 // uint8_t (Size: 0x1)
ParticleModuleMeshRotationRate.StartRotationRate = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleMeshRotationRateMultiplyLife.LifeMultiplier = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleMeshRotationRateOverLife.RotRate = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleMeshRotationRateOverLife.bScaleRotRate = 0x78 // uint8_t (Size: 0x1)
ParticleModuleMeshRotationRate_Seeded.RandomSeedInfo = 0x78 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleMeshRotation_Seeded.RandomSeedInfo = 0x80 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleOrbit.ChainMode = 0x38 // uint8_t (Size: 0x1)
ParticleModuleOrbit.OffsetAmount = 0x40 // FRawDistributionVector (Size: 0x48)
ParticleModuleOrbit.OffsetOptions = 0x88 // FOrbitOptions (Size: 0x4)
ParticleModuleOrbit.RotationAmount = 0x90 // FRawDistributionVector (Size: 0x48)
ParticleModuleOrbit.RotationOptions = 0xd8 // FOrbitOptions (Size: 0x4)
ParticleModuleOrbit.RotationRateAmount = 0xe0 // FRawDistributionVector (Size: 0x48)
ParticleModuleOrbit.RotationRateOptions = 0x128 // FOrbitOptions (Size: 0x4)
ParticleModuleOrbitBase.bUseEmitterTime = 0x30 // uint8_t (Size: 0x1)
ParticleModuleOrientationAxisLock.LockAxisFlags = 0x30 // uint8_t (Size: 0x1)
ParticleModuleParameterDynamic.DynamicParams = 0x30 // TArray<FEmitterDynamicParameter> (Size: 0x10)
ParticleModuleParameterDynamic.UpdateFlags = 0x40 // int32_t (Size: 0x4)
ParticleModuleParameterDynamic.bUsesVelocity = 0x44 // uint8_t (Size: 0x1)
ParticleModuleParameterDynamic_Seeded.RandomSeedInfo = 0x48 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModulePivotOffset.PivotOffset = 0x30 // FVector2D (Size: 0x8)
ParticleModuleRequired.Material = 0x30 // MaterialInterface* (Size: 0x8)
ParticleModuleRequired.MinFacingCameraBlendDistance = 0x38 // float (Size: 0x4)
ParticleModuleRequired.MaxFacingCameraBlendDistance = 0x3c // float (Size: 0x4)
ParticleModuleRequired.EmitterOrigin = 0x40 // FVector (Size: 0xc)
ParticleModuleRequired.EmitterRotation = 0x4c // FRotator (Size: 0xc)
ParticleModuleRequired.ScreenAlignment = 0x58 // uint8_t (Size: 0x1)
ParticleModuleRequired.bUseLocalSpace = 0x59 // uint8_t (Size: 0x1)
ParticleModuleRequired.bKillOnDeactivate = 0x59 // uint8_t (Size: 0x1)
ParticleModuleRequired.bKillOnCompleted = 0x59 // uint8_t (Size: 0x1)
ParticleModuleRequired.SortMode = 0x5a // uint8_t (Size: 0x1)
ParticleModuleRequired.bUseLegacyEmitterTime = 0x5b // uint8_t (Size: 0x1)
ParticleModuleRequired.bRemoveHMDRoll = 0x5b // uint8_t (Size: 0x1)
ParticleModuleRequired.bEmitterDurationUseRange = 0x5b // uint8_t (Size: 0x1)
ParticleModuleRequired.EmitterDuration = 0x5c // float (Size: 0x4)
ParticleModuleRequired.SpawnRate = 0x60 // FRawDistributionFloat (Size: 0x30)
ParticleModuleRequired.BurstList = 0x90 // TArray<FParticleBurst> (Size: 0x10)
ParticleModuleRequired.EmitterDelay = 0xa0 // float (Size: 0x4)
ParticleModuleRequired.EmitterDelayLow = 0xa4 // float (Size: 0x4)
ParticleModuleRequired.bDelayFirstLoopOnly = 0xa8 // uint8_t (Size: 0x1)
ParticleModuleRequired.InterpolationMethod = 0xa9 // uint8_t (Size: 0x1)
ParticleModuleRequired.bScaleUV = 0xaa // uint8_t (Size: 0x1)
ParticleModuleRequired.bEmitterDelayUseRange = 0xaa // uint8_t (Size: 0x1)
ParticleModuleRequired.ParticleBurstMethod = 0xab // uint8_t (Size: 0x1)
ParticleModuleRequired.bOverrideSystemMacroUV = 0xac // uint8_t (Size: 0x1)
ParticleModuleRequired.bUseMaxDrawCount = 0xac // uint8_t (Size: 0x1)
ParticleModuleRequired.OpacitySourceMode = 0xad // uint8_t (Size: 0x1)
ParticleModuleRequired.EmitterNormalsMode = 0xae // uint8_t (Size: 0x1)
ParticleModuleRequired.bOrbitModuleAffectsVelocityAlignment = 0xaf // uint8_t (Size: 0x1)
ParticleModuleRequired.SubImages_Horizontal = 0xb0 // int32_t (Size: 0x4)
ParticleModuleRequired.SubImages_Vertical = 0xb4 // int32_t (Size: 0x4)
ParticleModuleRequired.RandomImageTime = 0xb8 // float (Size: 0x4)
ParticleModuleRequired.RandomImageChanges = 0xbc // int32_t (Size: 0x4)
ParticleModuleRequired.MacroUVPosition = 0xc0 // FVector (Size: 0xc)
ParticleModuleRequired.MacroUVRadius = 0xcc // float (Size: 0x4)
ParticleModuleRequired.UVFlippingMode = 0xd0 // EEParticleUVFlipMode (Size: 0x1)
ParticleModuleRequired.BoundingMode = 0xd1 // uint8_t (Size: 0x1)
ParticleModuleRequired.bDurationRecalcEachLoop = 0xd2 // uint8_t (Size: 0x1)
ParticleModuleRequired.NormalsSphereCenter = 0xd4 // FVector (Size: 0xc)
ParticleModuleRequired.AlphaThreshold = 0xe0 // float (Size: 0x4)
ParticleModuleRequired.EmitterLoops = 0xe4 // int32_t (Size: 0x4)
ParticleModuleRequired.CutoutTexture = 0xe8 // Texture2D* (Size: 0x8)
ParticleModuleRequired.MaxDrawCount = 0xf0 // int32_t (Size: 0x4)
ParticleModuleRequired.EmitterDurationLow = 0xf4 // float (Size: 0x4)
ParticleModuleRequired.NormalsCylinderDirection = 0xf8 // FVector (Size: 0xc)
ParticleModuleRequired.NamedMaterialOverrides = 0x108 // TArray<FName> (Size: 0x10)
ParticleModuleRotation.StartRotation = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleRotationOverLifetime.RotationOverLife = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleRotationOverLifetime.Scale = 0x60 // uint8_t (Size: 0x1)
ParticleModuleRotationRate.StartRotationRate = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleRotationRateMultiplyLife.LifeMultiplier = 0x30 // FRawDistributionFloat (Size: 0x30)
ParticleModuleRotationRate_Seeded.RandomSeedInfo = 0x60 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleRotation_Seeded.RandomSeedInfo = 0x60 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleSize.StartSize = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleSizeMultiplyLife.LifeMultiplier = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleSizeMultiplyLife.MultiplyX = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeMultiplyLife.MultiplyY = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeMultiplyLife.MultiplyZ = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeScale.SizeScale = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleSizeScale.EnableX = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeScale.EnableY = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeScale.EnableZ = 0x78 // uint8_t (Size: 0x1)
ParticleModuleSizeScaleBySpeed.SpeedScale = 0x30 // FVector2D (Size: 0x8)
ParticleModuleSizeScaleBySpeed.MaxScale = 0x38 // FVector2D (Size: 0x8)
ParticleModuleSize_Seeded.RandomSeedInfo = 0x78 // FParticleRandomSeedInfo (Size: 0x20)
ParticleModuleSourceMovement.SourceMovementScale = 0x30 // FRawDistributionVector (Size: 0x48)
ParticleModuleSpawn.Rate = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSpawn.RateScale = 0x68 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSpawn.ParticleBurstMethod = 0x98 // uint8_t (Size: 0x1)
ParticleModuleSpawn.BurstList = 0xa0 // TArray<FParticleBurst> (Size: 0x10)
ParticleModuleSpawn.BurstScale = 0xb0 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSpawn.bApplyGlobalSpawnRateScale = 0xe0 // uint8_t (Size: 0x1)
ParticleModuleSpawnBase.bProcessSpawnRate = 0x30 // uint8_t (Size: 0x1)
ParticleModuleSpawnBase.bProcessBurstList = 0x30 // uint8_t (Size: 0x1)
ParticleModuleSpawnPerUnit.UnitScalar = 0x38 // float (Size: 0x4)
ParticleModuleSpawnPerUnit.MovementTolerance = 0x3c // float (Size: 0x4)
ParticleModuleSpawnPerUnit.SpawnPerUnit = 0x40 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSpawnPerUnit.MaxFrameDistance = 0x70 // float (Size: 0x4)
ParticleModuleSpawnPerUnit.bIgnoreSpawnRateWhenMoving = 0x74 // uint8_t (Size: 0x1)
ParticleModuleSpawnPerUnit.bIgnoreMovementAlongX = 0x74 // uint8_t (Size: 0x1)
ParticleModuleSpawnPerUnit.bIgnoreMovementAlongY = 0x74 // uint8_t (Size: 0x1)
ParticleModuleSpawnPerUnit.bIgnoreMovementAlongZ = 0x74 // uint8_t (Size: 0x1)
ParticleModuleSubUV.Animation = 0x30 // SubUVAnimation* (Size: 0x8)
ParticleModuleSubUV.SubImageIndex = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSubUV.bUseRealTime = 0x68 // uint8_t (Size: 0x1)
ParticleModuleSubUVMovie.bUseEmitterTime = 0x70 // uint8_t (Size: 0x1)
ParticleModuleSubUVMovie.FrameRate = 0x78 // FRawDistributionFloat (Size: 0x30)
ParticleModuleSubUVMovie.StartingFrame = 0xa8 // int32_t (Size: 0x4)
ParticleModuleTrailSource.SourceMethod = 0x30 // uint8_t (Size: 0x1)
ParticleModuleTrailSource.SourceName = 0x34 // FName (Size: 0x8)
ParticleModuleTrailSource.SourceStrength = 0x40 // FRawDistributionFloat (Size: 0x30)
ParticleModuleTrailSource.bLockSourceStength = 0x70 // uint8_t (Size: 0x1)
ParticleModuleTrailSource.SourceOffsetCount = 0x74 // int32_t (Size: 0x4)
ParticleModuleTrailSource.SourceOffsetDefaults = 0x78 // TArray<FVector> (Size: 0x10)
ParticleModuleTrailSource.SelectionMethod = 0x88 // uint8_t (Size: 0x1)
ParticleModuleTrailSource.bInheritRotation = 0x8c // uint8_t (Size: 0x1)
ParticleModuleTypeDataAnimTrail.bDeadTrailsOnDeactivate = 0x30 // uint8_t (Size: 0x1)
ParticleModuleTypeDataAnimTrail.bEnablePreviousTangentRecalculation = 0x30 // uint8_t (Size: 0x1)
ParticleModuleTypeDataAnimTrail.bTangentRecalculationEveryFrame = 0x30 // uint8_t (Size: 0x1)
ParticleModuleTypeDataAnimTrail.TilingDistance = 0x34 // float (Size: 0x4)
ParticleModuleTypeDataAnimTrail.DistanceTessellationStepSize = 0x38 // float (Size: 0x4)
ParticleModuleTypeDataAnimTrail.TangentTessellationStepSize = 0x3c // float (Size: 0x4)
ParticleModuleTypeDataAnimTrail.WidthTessellationStepSize = 0x40 // float (Size: 0x4)
ParticleModuleTypeDataBeam2.BeamMethod = 0x30 // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.TextureTile = 0x34 // int32_t (Size: 0x4)
ParticleModuleTypeDataBeam2.TextureTileDistance = 0x38 // float (Size: 0x4)
ParticleModuleTypeDataBeam2.Sheets = 0x3c // int32_t (Size: 0x4)
ParticleModuleTypeDataBeam2.MaxBeamCount = 0x40 // int32_t (Size: 0x4)
ParticleModuleTypeDataBeam2.Speed = 0x44 // float (Size: 0x4)
ParticleModuleTypeDataBeam2.InterpolationPoints = 0x48 // int32_t (Size: 0x4)
ParticleModuleTypeDataBeam2.bAlwaysOn = 0x4c // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.UpVectorStepSize = 0x50 // int32_t (Size: 0x4)
ParticleModuleTypeDataBeam2.BranchParentName = 0x54 // FName (Size: 0x8)
ParticleModuleTypeDataBeam2.Distance = 0x60 // FRawDistributionFloat (Size: 0x30)
ParticleModuleTypeDataBeam2.TaperMethod = 0x90 // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.TaperFactor = 0x98 // FRawDistributionFloat (Size: 0x30)
ParticleModuleTypeDataBeam2.TaperScale = 0xc8 // FRawDistributionFloat (Size: 0x30)
ParticleModuleTypeDataBeam2.RenderGeometry = 0xf8 // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.RenderDirectLine = 0xf8 // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.RenderLines = 0xf8 // uint8_t (Size: 0x1)
ParticleModuleTypeDataBeam2.RenderTessellation = 0xf8 // uint8_t (Size: 0x1)
ParticleModuleTypeDataGpu.EmitterInfo = 0x30 // FGPUSpriteEmitterInfo (Size: 0x280)
ParticleModuleTypeDataGpu.ResourceData = 0x2b0 // FGPUSpriteResourceData (Size: 0x160)
ParticleModuleTypeDataGpu.CameraMotionBlurAmount = 0x410 // float (Size: 0x4)
ParticleModuleTypeDataGpu.bClearExistingParticlesOnInit = 0x414 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.Mesh = 0x30 // StaticMesh* (Size: 0x8)
ParticleModuleTypeDataMesh.LODSizeScale = 0x40 // float (Size: 0x4)
ParticleModuleTypeDataMesh.bUseStaticMeshLODs = 0x44 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.CastShadows = 0x44 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.DoCollisions = 0x44 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.MeshAlignment = 0x45 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bOverrideMaterial = 0x46 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bOverrideDefaultMotionBlurSettings = 0x46 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bEnableMotionBlur = 0x46 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.RollPitchYawRange = 0x48 // FRawDistributionVector (Size: 0x48)
ParticleModuleTypeDataMesh.AxisLockOption = 0x90 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bCameraFacing = 0x91 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.CameraFacingUpAxisOption = 0x92 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.CameraFacingOption = 0x93 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bApplyParticleRotationAsSpin = 0x94 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bFaceCameraDirectionRatherThanPosition = 0x94 // uint8_t (Size: 0x1)
ParticleModuleTypeDataMesh.bCollisionsConsiderPartilceSize = 0x94 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.MaxTessellationBetweenParticles = 0x30 // int32_t (Size: 0x4)
ParticleModuleTypeDataRibbon.SheetsPerTrail = 0x34 // int32_t (Size: 0x4)
ParticleModuleTypeDataRibbon.MaxTrailCount = 0x38 // int32_t (Size: 0x4)
ParticleModuleTypeDataRibbon.MaxParticleInTrailCount = 0x3c // int32_t (Size: 0x4)
ParticleModuleTypeDataRibbon.bDeadTrailsOnDeactivate = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bDeadTrailsOnSourceLoss = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bClipSourceSegement = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bEnablePreviousTangentRecalculation = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bTangentRecalculationEveryFrame = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bSpawnInitialParticle = 0x40 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.RenderAxis = 0x44 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.TangentSpawningScalar = 0x48 // float (Size: 0x4)
ParticleModuleTypeDataRibbon.bRenderGeometry = 0x4c // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bRenderSpawnPoints = 0x4c // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bRenderTangents = 0x4c // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.bRenderTessellation = 0x4c // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.TilingDistance = 0x50 // float (Size: 0x4)
ParticleModuleTypeDataRibbon.DistanceTessellationStepSize = 0x54 // float (Size: 0x4)
ParticleModuleTypeDataRibbon.bEnableTangentDiffInterpScale = 0x58 // uint8_t (Size: 0x1)
ParticleModuleTypeDataRibbon.TangentTessellationScalar = 0x5c // float (Size: 0x4)
ParticleModuleVectorFieldGlobal.bOverrideGlobalVectorFieldTightness = 0x30 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldGlobal.GlobalVectorFieldScale = 0x34 // float (Size: 0x4)
ParticleModuleVectorFieldGlobal.GlobalVectorFieldTightness = 0x38 // float (Size: 0x4)
ParticleModuleVectorFieldLocal.VectorField = 0x30 // VectorField* (Size: 0x8)
ParticleModuleVectorFieldLocal.RelativeTranslation = 0x38 // FVector (Size: 0xc)
ParticleModuleVectorFieldLocal.RelativeRotation = 0x44 // FRotator (Size: 0xc)
ParticleModuleVectorFieldLocal.RelativeScale3D = 0x50 // FVector (Size: 0xc)
ParticleModuleVectorFieldLocal.Intensity = 0x5c // float (Size: 0x4)
ParticleModuleVectorFieldLocal.Tightness = 0x60 // float (Size: 0x4)
ParticleModuleVectorFieldLocal.bIgnoreComponentTransform = 0x64 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldLocal.bTileX = 0x64 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldLocal.bTileY = 0x64 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldLocal.bTileZ = 0x64 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldLocal.bUseFixDT = 0x64 // uint8_t (Size: 0x1)
ParticleModuleVectorFieldRotation.MinInitialRotation = 0x30 // FVector (Size: 0xc)
ParticleModuleVectorFieldRotation.MaxInitialRotation = 0x3c // FVector (Size: 0xc)
ParticleModuleVectorFieldRotationRate.RotationRate = 0x30 // FVector (Size: 0xc)
ParticleModuleVectorFieldScale.VectorFieldScale = 0x30 // DistributionFloat* (Size: 0x8)
ParticleModuleVectorFieldScale.VectorFieldScaleRaw = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleVectorFieldScaleOverLife.VectorFieldScaleOverLife = 0x30 // DistributionFloat* (Size: 0x8)
ParticleModuleVectorFieldScaleOverLife.VectorFieldScaleOverLifeRaw = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleVelocity.StartVelocity = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleVelocity.StartVelocityRadial = 0x80 // FRawDistributionFloat (Size: 0x30)
ParticleModuleVelocityBase.bInWorldSpace = 0x30 // uint8_t (Size: 0x1)
ParticleModuleVelocityBase.bApplyOwnerScale = 0x30 // uint8_t (Size: 0x1)
ParticleModuleVelocityCone.Angle = 0x38 // FRawDistributionFloat (Size: 0x30)
ParticleModuleVelocityCone.Velocity = 0x68 // FRawDistributionFloat (Size: 0x30)
ParticleModuleVelocityCone.Direction = 0x98 // FVector (Size: 0xc)
ParticleModuleVelocityInheritParent.Scale = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleVelocityOverLifetime.VelOverLife = 0x38 // FRawDistributionVector (Size: 0x48)
ParticleModuleVelocityOverLifetime.Absolute = 0x80 // uint8_t (Size: 0x1)
ParticleModuleVelocity_Seeded.RandomSeedInfo = 0xb0 // FParticleRandomSeedInfo (Size: 0x20)
ParticleRandomSeedInfo.ParameterName = 0x0 // FName (Size: 0x8)
ParticleRandomSeedInfo.bGetSeedFromInstance = 0x8 // uint8_t (Size: 0x1)
ParticleRandomSeedInfo.bInstanceSeedIsIndex = 0x8 // uint8_t (Size: 0x1)
ParticleRandomSeedInfo.bResetSeedOnEmitterLooping = 0x8 // uint8_t (Size: 0x1)
ParticleRandomSeedInfo.bRandomlySelectSeedArray = 0x8 // uint8_t (Size: 0x1)
ParticleRandomSeedInfo.RandomSeeds = 0x10 // TArray<int32_t> (Size: 0x10)
ParticleReplayTrackKey.Time = 0x0 // float (Size: 0x4)
ParticleReplayTrackKey.Duration = 0x4 // float (Size: 0x4)
ParticleReplayTrackKey.ClipIDNumber = 0x8 // int32_t (Size: 0x4)
ParticleSysParam.Name = 0x0 // FName (Size: 0x8)
ParticleSysParam.ParamType = 0x8 // uint8_t (Size: 0x1)
ParticleSysParam.Scalar = 0xc // float (Size: 0x4)
ParticleSysParam.Scalar_Low = 0x10 // float (Size: 0x4)
ParticleSysParam.Vector = 0x14 // FVector (Size: 0xc)
ParticleSysParam.Vector_Low = 0x20 // FVector (Size: 0xc)
ParticleSysParam.Color = 0x2c // FColor (Size: 0x4)
ParticleSysParam.Actor = 0x30 // Actor* (Size: 0x8)
ParticleSysParam.Material = 0x38 // MaterialInterface* (Size: 0x8)
ParticleSystem.UpdateTime_FPS = 0x30 // float (Size: 0x4)
ParticleSystem.UpdateTime_Delta = 0x34 // float (Size: 0x4)
ParticleSystem.WarmupTime = 0x38 // float (Size: 0x4)
ParticleSystem.WarmupTickRate = 0x3c // float (Size: 0x4)
ParticleSystem.Emitters = 0x40 // TArray<ParticleEmitter*> (Size: 0x10)
ParticleSystem.PreviewComponent = 0x50 // ParticleSystemComponent* (Size: 0x8)
ParticleSystem.CurveEdSetup = 0x58 // InterpCurveEdSetup* (Size: 0x8)
ParticleSystem.LODDistanceCheckTime = 0x60 // float (Size: 0x4)
ParticleSystem.MacroUVRadius = 0x64 // float (Size: 0x4)
ParticleSystem.LODDistances = 0x68 // TArray<float> (Size: 0x10)
ParticleSystem.LODSettings = 0x78 // TArray<FParticleSystemLOD> (Size: 0x10)
ParticleSystem.FixedRelativeBoundingBox = 0x88 // FBox (Size: 0x1c)
ParticleSystem.SecondsBeforeInactive = 0xa4 // float (Size: 0x4)
ParticleSystem.Delay = 0xa8 // float (Size: 0x4)
ParticleSystem.DelayLow = 0xac // float (Size: 0x4)
ParticleSystem.bOrientZAxisTowardCamera = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.bUseFixedRelativeBoundingBox = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.bShouldResetPeakCounts = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.bHasPhysics = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.bUseRealtimeThumbnail = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.ThumbnailImageOutOfDate = 0xb0 // uint8_t (Size: 0x1)
ParticleSystem.bUseDelayRange = 0xb1 // uint8_t (Size: 0x1)
ParticleSystem.bAllowManagedTicking = 0xb1 // uint8_t (Size: 0x1)
ParticleSystem.bAutoDeactivate = 0xb1 // uint8_t (Size: 0x1)
ParticleSystem.bRegenerateLODDuplicate = 0xb1 // uint8_t (Size: 0x1)
ParticleSystem.SystemUpdateMode = 0xb2 // uint8_t (Size: 0x1)
ParticleSystem.LODMethod = 0xb3 // uint8_t (Size: 0x1)
ParticleSystem.InsignificantReaction = 0xb4 // EEParticleSystemInsignificanceReaction (Size: 0x1)
ParticleSystem.OcclusionBoundsMethod = 0xb5 // uint8_t (Size: 0x1)
ParticleSystem.MaxSignificanceLevel = 0xb7 // EEParticleSignificanceLevel (Size: 0x1)
ParticleSystem.MinTimeBetweenTicks = 0xb8 // uint32_t (Size: 0x4)
ParticleSystem.InsignificanceDelay = 0xbc // float (Size: 0x4)
ParticleSystem.MacroUVPosition = 0xc0 // FVector (Size: 0xc)
ParticleSystem.CustomOcclusionBounds = 0xcc // FBox (Size: 0x1c)
ParticleSystem.SoloTracking = 0xe8 // TArray<FLODSoloTrack> (Size: 0x10)
ParticleSystem.NamedMaterialSlots = 0xf8 // TArray<FNamedEmitterMaterial> (Size: 0x10)
ParticleSystem.bOnlyOverrideOneLOD = 0x108 // bool (Size: 0x1)
ParticleSystemComponent.Template = 0x5c8 // ParticleSystem* (Size: 0x8)
ParticleSystemComponent.EmitterMaterials = 0x5d0 // TArray<MaterialInterface*> (Size: 0x10)
ParticleSystemComponent.SkelMeshComponents = 0x5e0 // TArray<SkeletalMeshComponent*> (Size: 0x10)
ParticleSystemComponent.bResetOnDetach = 0x5f1 // uint8_t (Size: 0x1)
ParticleSystemComponent.bUpdateOnDedicatedServer = 0x5f1 // uint8_t (Size: 0x1)
ParticleSystemComponent.bAllowRecycling = 0x5f1 // uint8_t (Size: 0x1)
ParticleSystemComponent.bAutoManageAttachment = 0x5f1 // uint8_t (Size: 0x1)
ParticleSystemComponent.bAutoAttachWeldSimulatedBodies = 0x5f1 // uint8_t (Size: 0x1)
ParticleSystemComponent.bWarmingUp = 0x5f2 // uint8_t (Size: 0x1)
ParticleSystemComponent.bOverrideLODMethod = 0x5f2 // uint8_t (Size: 0x1)
ParticleSystemComponent.bSkipUpdateDynamicDataDuringTick = 0x5f2 // uint8_t (Size: 0x1)
ParticleSystemComponent.LODMethod = 0x5fd // uint8_t (Size: 0x1)
ParticleSystemComponent.RequiredSignificance = 0x5fe // EEParticleSignificanceLevel (Size: 0x1)
ParticleSystemComponent.InstanceParameters = 0x600 // TArray<FParticleSysParam> (Size: 0x10)
ParticleSystemComponent.OnParticleSpawn = 0x610 // FMulticastInlineDelegate (Size: 0x10)
ParticleSystemComponent.OnParticleBurst = 0x620 // FMulticastInlineDelegate (Size: 0x10)
ParticleSystemComponent.OnParticleDeath = 0x630 // FMulticastInlineDelegate (Size: 0x10)
ParticleSystemComponent.OnParticleCollide = 0x640 // FMulticastInlineDelegate (Size: 0x10)
ParticleSystemComponent.bOldPositionValid = 0x650 // bool (Size: 0x1)
ParticleSystemComponent.OldPosition = 0x654 // FVector (Size: 0xc)
ParticleSystemComponent.PartSysVelocity = 0x660 // FVector (Size: 0xc)
ParticleSystemComponent.WarmupTime = 0x66c // float (Size: 0x4)
ParticleSystemComponent.WarmupTickRate = 0x670 // float (Size: 0x4)
ParticleSystemComponent.SecondsBeforeInactive = 0x678 // float (Size: 0x4)
ParticleSystemComponent.MaxTimeBeforeForceUpdateTransform = 0x680 // float (Size: 0x4)
ParticleSystemComponent.ReplayClips = 0x6a0 // TArray<ParticleSystemReplay*> (Size: 0x10)
ParticleSystemComponent.CustomTimeDilation = 0x6b8 // float (Size: 0x4)
ParticleSystemComponent.AutoAttachParent = 0x710 // TWeakObjectPtr<UObject> (Size: 0x8)
ParticleSystemComponent.AutoAttachSocketName = 0x718 // FName (Size: 0x8)
ParticleSystemComponent.AutoAttachLocationRule = 0x720 // EEAttachmentRule (Size: 0x1)
ParticleSystemComponent.AutoAttachRotationRule = 0x721 // EEAttachmentRule (Size: 0x1)
ParticleSystemComponent.AutoAttachScaleRule = 0x722 // EEAttachmentRule (Size: 0x1)
ParticleSystemComponent.OnSystemFinished = 0x750 // FMulticastInlineDelegate (Size: 0x10)
ParticleSystemReplay.ClipIDNumber = 0x28 // int32_t (Size: 0x4)
PassiveSoundMixModifier.SoundMix = 0x0 // SoundMix* (Size: 0x8)
PassiveSoundMixModifier.MinVolumeThreshold = 0x8 // float (Size: 0x4)
PassiveSoundMixModifier.MaxVolumeThreshold = 0xc // float (Size: 0x4)
Pawn.bUseControllerRotationPitch = 0x318 // uint8_t (Size: 0x1)
Pawn.bUseControllerRotationYaw = 0x318 // uint8_t (Size: 0x1)
Pawn.bUseControllerRotationRoll = 0x318 // uint8_t (Size: 0x1)
Pawn.bCanAffectNavigationGeneration = 0x318 // uint8_t (Size: 0x1)
Pawn.BaseEyeHeight = 0x31c // float (Size: 0x4)
Pawn.AutoPossessPlayer = 0x320 // uint8_t (Size: 0x1)
Pawn.AutoPossessAI = 0x321 // EEAutoPossessAI (Size: 0x1)
Pawn.RemoteViewPitch = 0x322 // uint8_t (Size: 0x1)
Pawn.AIControllerClass = 0x328 // ClassProperty (Size: 0x8)
Pawn.OnReceivePhysicsEvent = 0x330 // FMulticastInlineDelegate (Size: 0x10)
Pawn.PlayerState = 0x340 // PlayerState* (Size: 0x8)
Pawn.LastHitBy = 0x350 // Controller* (Size: 0x8)
Pawn.Controller = 0x358 // Controller* (Size: 0x8)
Pawn.ControlInputVector = 0x364 // FVector (Size: 0xc)
Pawn.LastControlInputVector = 0x370 // FVector (Size: 0xc)
PawnMovementComponent.PawnOwner = 0x178 // Pawn* (Size: 0x8)
PawnNoiseEmitterComponent.bAIPerceptionSystemCompatibilityMode = 0xf8 // uint8_t (Size: 0x1)
PawnNoiseEmitterComponent.LastRemoteNoisePosition = 0xfc // FVector (Size: 0xc)
PawnNoiseEmitterComponent.NoiseLifetime = 0x108 // float (Size: 0x4)
PawnNoiseEmitterComponent.LastRemoteNoiseVolume = 0x10c // float (Size: 0x4)
PawnNoiseEmitterComponent.LastRemoteNoiseTime = 0x110 // float (Size: 0x4)
PawnNoiseEmitterComponent.LastLocalNoiseVolume = 0x114 // float (Size: 0x4)
PawnNoiseEmitterComponent.LastLocalNoiseTime = 0x118 // float (Size: 0x4)
PendingNetGame.NetDriver = 0x30 // NetDriver* (Size: 0x8)
PendingNetGame.DemoNetDriver = 0x38 // DemoNetDriver* (Size: 0x8)
PerBoneBlendWeight.SourceIndex = 0x0 // int32_t (Size: 0x4)
PerBoneBlendWeight.BlendWeight = 0x4 // float (Size: 0x4)
PerBoneBlendWeights.BoneBlendWeights = 0x0 // TArray<FPerBoneBlendWeight> (Size: 0x10)
PerBoneInterpolation.BoneReference = 0x0 // FBoneReference (Size: 0x10)
PerBoneInterpolation.InterpolationSpeedPerSec = 0x10 // float (Size: 0x4)
PerPlatformBool.Default = 0x0 // bool (Size: 0x1)
PerPlatformFloat.Default = 0x0 // float (Size: 0x4)
PerPlatformInt.Default = 0x0 // int32_t (Size: 0x4)
PerPlatformInt.ScalableBias = 0x4 // int32_t (Size: 0x4)
PhysicalAnimationComponent.StrengthMultiplyer = 0xf8 // float (Size: 0x4)
PhysicalAnimationComponent.SkeletalMeshComponent = 0x100 // SkeletalMeshComponent* (Size: 0x8)
PhysicalAnimationData.BodyName = 0x0 // FName (Size: 0x8)
PhysicalAnimationData.bIsLocalSimulation = 0x8 // uint8_t (Size: 0x1)
PhysicalAnimationData.OrientationStrength = 0xc // float (Size: 0x4)
PhysicalAnimationData.AngularVelocityStrength = 0x10 // float (Size: 0x4)
PhysicalAnimationData.PositionStrength = 0x14 // float (Size: 0x4)
PhysicalAnimationData.VelocityStrength = 0x18 // float (Size: 0x4)
PhysicalAnimationData.MaxLinearForce = 0x1c // float (Size: 0x4)
PhysicalAnimationData.MaxAngularForce = 0x20 // float (Size: 0x4)
PhysicalAnimationProfile.ProfileName = 0x0 // FName (Size: 0x8)
PhysicalAnimationProfile.PhysicalAnimationData = 0x8 // FPhysicalAnimationData (Size: 0x24)
PhysicalMaterialMask.UVChannelIndex = 0x28 // int32_t (Size: 0x4)
PhysicalMaterialMask.AddressX = 0x2c // uint8_t (Size: 0x1)
PhysicalMaterialMask.AddressY = 0x2d // uint8_t (Size: 0x1)
PhysicalSurfaceName.Type = 0x0 // uint8_t (Size: 0x1)
PhysicalSurfaceName.Name = 0x4 // FName (Size: 0x8)
PhysicsAsset.BoundsBodies = 0x30 // TArray<int32_t> (Size: 0x10)
PhysicsAsset.SkeletalBodySetups = 0x40 // TArray<SkeletalBodySetup*> (Size: 0x10)
PhysicsAsset.ConstraintSetup = 0x50 // TArray<PhysicsConstraintTemplate*> (Size: 0x10)
PhysicsAsset.SolverIterations = 0x60 // FSolverIterations (Size: 0x1c)
PhysicsAsset.bNotForDedicatedServer = 0x7c // uint8_t (Size: 0x1)
PhysicsAsset.ThumbnailInfo = 0x120 // ThumbnailInfo* (Size: 0x8)
PhysicsAsset.BodySetup = 0x128 // TArray<BodySetup*> (Size: 0x10)
PhysicsCollisionHandler.ImpactThreshold = 0x28 // float (Size: 0x4)
PhysicsCollisionHandler.ImpactReFireDelay = 0x2c // float (Size: 0x4)
PhysicsCollisionHandler.DefaultImpactSound = 0x30 // SoundBase* (Size: 0x8)
PhysicsCollisionHandler.LastImpactSoundTime = 0x38 // float (Size: 0x4)
PhysicsConstraintActor.ConstraintComp = 0x310 // PhysicsConstraintComponent* (Size: 0x8)
PhysicsConstraintActor.ConstraintActor1 = 0x318 // Actor* (Size: 0x8)
PhysicsConstraintActor.ConstraintActor2 = 0x320 // Actor* (Size: 0x8)
PhysicsConstraintActor.bDisableCollision = 0x328 // uint8_t (Size: 0x1)
PhysicsConstraintComponent.ConstraintActor1 = 0x238 // Actor* (Size: 0x8)
PhysicsConstraintComponent.ComponentName1 = 0x240 // FConstrainComponentPropName (Size: 0x8)
PhysicsConstraintComponent.ConstraintActor2 = 0x248 // Actor* (Size: 0x8)
PhysicsConstraintComponent.ComponentName2 = 0x250 // FConstrainComponentPropName (Size: 0x8)
PhysicsConstraintComponent.ConstraintSetup = 0x268 // PhysicsConstraintTemplate* (Size: 0x8)
PhysicsConstraintComponent.OnConstraintBroken = 0x270 // FMulticastInlineDelegate (Size: 0x10)
PhysicsConstraintComponent.ConstraintInstance = 0x280 // FConstraintInstance (Size: 0x1c0)
PhysicsConstraintProfileHandle.ProfileProperties = 0x0 // FConstraintProfileProperties (Size: 0x10c)
PhysicsConstraintProfileHandle.ProfileName = 0x10c // FName (Size: 0x8)
PhysicsConstraintTemplate.DefaultInstance = 0x28 // FConstraintInstance (Size: 0x1c0)
PhysicsConstraintTemplate.ProfileHandles = 0x1e8 // TArray<FPhysicsConstraintProfileHandle> (Size: 0x10)
PhysicsConstraintTemplate.DefaultProfile = 0x1f8 // FConstraintProfileProperties (Size: 0x10c)
PhysicsHandleComponent.GrabbedComponent = 0xf8 // PrimitiveComponent* (Size: 0x8)
PhysicsHandleComponent.bSoftAngularConstraint = 0x108 // uint8_t (Size: 0x1)
PhysicsHandleComponent.bSoftLinearConstraint = 0x108 // uint8_t (Size: 0x1)
PhysicsHandleComponent.bInterpolateTarget = 0x108 // uint8_t (Size: 0x1)
PhysicsHandleComponent.LinearDamping = 0x10c // float (Size: 0x4)
PhysicsHandleComponent.LinearStiffness = 0x110 // float (Size: 0x4)
PhysicsHandleComponent.AngularDamping = 0x114 // float (Size: 0x4)
PhysicsHandleComponent.AngularStiffness = 0x118 // float (Size: 0x4)
PhysicsHandleComponent.InterpolationSpeed = 0x180 // float (Size: 0x4)
PhysicsSettings.PhysicErrorCorrection = 0xe0 // FRigidBodyErrorCorrection (Size: 0x34)
PhysicsSettings.LockedAxis = 0x114 // uint8_t (Size: 0x1)
PhysicsSettings.DefaultDegreesOfFreedom = 0x115 // uint8_t (Size: 0x1)
PhysicsSettings.bSuppressFaceRemapTable = 0x116 // bool (Size: 0x1)
PhysicsSettings.bSupportUVFromHitResults = 0x117 // bool (Size: 0x1)
PhysicsSettings.bDisableActiveActors = 0x118 // bool (Size: 0x1)
PhysicsSettings.bDisableKinematicStaticPairs = 0x119 // bool (Size: 0x1)
PhysicsSettings.bDisableKinematicKinematicPairs = 0x11a // bool (Size: 0x1)
PhysicsSettings.bDisableCCD = 0x11b // bool (Size: 0x1)
PhysicsSettings.bEnableEnhancedDeterminism = 0x11c // bool (Size: 0x1)
PhysicsSettings.AnimPhysicsMinDeltaTime = 0x120 // float (Size: 0x4)
PhysicsSettings.bSimulateAnimPhysicsAfterReset = 0x124 // bool (Size: 0x1)
PhysicsSettings.MaxPhysicsDeltaTime = 0x128 // float (Size: 0x4)
PhysicsSettings.bSubstepping = 0x12c // bool (Size: 0x1)
PhysicsSettings.bSubsteppingAsync = 0x12d // bool (Size: 0x1)
PhysicsSettings.MaxSubstepDeltaTime = 0x130 // float (Size: 0x4)
PhysicsSettings.MaxSubsteps = 0x134 // int32_t (Size: 0x4)
PhysicsSettings.SyncSceneSmoothingFactor = 0x138 // float (Size: 0x4)
PhysicsSettings.InitialAverageFrameRate = 0x13c // float (Size: 0x4)
PhysicsSettings.PhysXTreeRebuildRate = 0x140 // int32_t (Size: 0x4)
PhysicsSettings.PhysicalSurfaces = 0x148 // TArray<FPhysicalSurfaceName> (Size: 0x10)
PhysicsSettings.DefaultBroadphaseSettings = 0x158 // FBroadphaseSettings (Size: 0x40)
PhysicsSettings.MinDeltaVelocityForHitEvents = 0x198 // float (Size: 0x4)
PhysicsSettings.ChaosSettings = 0x19c // FChaosPhysicsSettings (Size: 0x3)
PhysicsSpringComponent.SpringStiffness = 0x238 // float (Size: 0x4)
PhysicsSpringComponent.SpringDamping = 0x23c // float (Size: 0x4)
PhysicsSpringComponent.SpringLengthAtRest = 0x240 // float (Size: 0x4)
PhysicsSpringComponent.SpringRadius = 0x244 // float (Size: 0x4)
PhysicsSpringComponent.SpringChannel = 0x248 // uint8_t (Size: 0x1)
PhysicsSpringComponent.bIgnoreSelf = 0x249 // bool (Size: 0x1)
PhysicsSpringComponent.SpringCompression = 0x24c // float (Size: 0x4)
PhysicsThruster.ThrusterComponent = 0x310 // PhysicsThrusterComponent* (Size: 0x8)
PhysicsThrusterComponent.ThrustStrength = 0x238 // float (Size: 0x4)
PhysicsVolume.TerminalVelocity = 0x348 // float (Size: 0x4)
PhysicsVolume.Priority = 0x34c // int32_t (Size: 0x4)
PhysicsVolume.FluidFriction = 0x350 // float (Size: 0x4)
PhysicsVolume.bWaterVolume = 0x354 // uint8_t (Size: 0x1)
PhysicsVolume.bPhysicsOnContact = 0x354 // uint8_t (Size: 0x1)
PlanarReflection.PlanarReflectionComponent = 0x320 // PlanarReflectionComponent* (Size: 0x8)
PlanarReflection.bShowPreviewPlane = 0x328 // bool (Size: 0x1)
PlanarReflectionComponent.PreviewBox = 0x318 // BoxComponent* (Size: 0x8)
PlanarReflectionComponent.NormalDistortionStrength = 0x320 // float (Size: 0x4)
PlanarReflectionComponent.PrefilterRoughness = 0x324 // float (Size: 0x4)
PlanarReflectionComponent.PrefilterRoughnessDistance = 0x328 // float (Size: 0x4)
PlanarReflectionComponent.ScreenPercentage = 0x32c // int32_t (Size: 0x4)
PlanarReflectionComponent.ExtraFOV = 0x330 // float (Size: 0x4)
PlanarReflectionComponent.MinDrawDistance = 0x334 // float (Size: 0x4)
PlanarReflectionComponent.DistanceFromPlaneFadeStart = 0x338 // float (Size: 0x4)
PlanarReflectionComponent.DistanceFromPlaneFadeEnd = 0x33c // float (Size: 0x4)
PlanarReflectionComponent.DistanceFromPlaneFadeoutStart = 0x340 // float (Size: 0x4)
PlanarReflectionComponent.DistanceFromPlaneFadeoutEnd = 0x344 // float (Size: 0x4)
PlanarReflectionComponent.AngleFromPlaneFadeStart = 0x348 // float (Size: 0x4)
PlanarReflectionComponent.AngleFromPlaneFadeEnd = 0x34c // float (Size: 0x4)
PlanarReflectionComponent.bShowPreviewPlane = 0x350 // bool (Size: 0x1)
PlanarReflectionComponent.bRenderSceneTwoSided = 0x351 // bool (Size: 0x1)
PlaneReflectionCaptureComponent.InfluenceRadiusScale = 0x2e8 // float (Size: 0x4)
PlaneReflectionCaptureComponent.PreviewInfluenceRadius = 0x2f0 // DrawSphereComponent* (Size: 0x8)
PlaneReflectionCaptureComponent.PreviewCaptureBox = 0x2f8 // BoxComponent* (Size: 0x8)
PlatformEventsComponent.PlatformChangedToLaptopModeDelegate = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
PlatformEventsComponent.PlatformChangedToTabletModeDelegate = 0x108 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationWillDeactivateDelegate = 0x1a8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationHasReactivatedDelegate = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationWillEnterBackgroundDelegate = 0x1c8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationHasEnteredForegroundDelegate = 0x1d8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationWillTerminateDelegate = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationShouldUnloadResourcesDelegate = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationReceivedStartupArgumentsDelegate = 0x208 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationRegisteredForRemoteNotificationsDelegate = 0x218 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationRegisteredForUserNotificationsDelegate = 0x228 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationFailedToRegisterForRemoteNotificationsDelegate = 0x238 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationReceivedRemoteNotificationDelegate = 0x248 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationReceivedLocalNotificationDelegate = 0x258 // FMulticastInlineDelegate (Size: 0x10)
PlatformGameInstance.ApplicationReceivedScreenOrientationChangedNotificationDelegate = 0x268 // FMulticastInlineDelegate (Size: 0x10)
PlatformInterfaceBase.AllDelegates = 0x28 // TArray<FDelegateArray> (Size: 0x10)
PlatformInterfaceData.DataName = 0x0 // FName (Size: 0x8)
PlatformInterfaceData.Type = 0x8 // uint8_t (Size: 0x1)
PlatformInterfaceData.IntValue = 0xc // int32_t (Size: 0x4)
PlatformInterfaceData.FloatValue = 0x10 // float (Size: 0x4)
PlatformInterfaceData.StringValue = 0x18 // FString (Size: 0x10)
PlatformInterfaceData.ObjectValue = 0x28 // Object* (Size: 0x8)
PlatformInterfaceDelegateResult.bSuccessful = 0x0 // bool (Size: 0x1)
PlatformInterfaceDelegateResult.Data = 0x8 // FPlatformInterfaceData (Size: 0x30)
PlatformInterfaceWebResponse.OriginalURL = 0x28 // FString (Size: 0x10)
PlatformInterfaceWebResponse.ResponseCode = 0x38 // int32_t (Size: 0x4)
PlatformInterfaceWebResponse.Tag = 0x3c // int32_t (Size: 0x4)
PlatformInterfaceWebResponse.StringResponse = 0x40 // FString (Size: 0x10)
PlatformInterfaceWebResponse.BinaryResponse = 0x50 // TArray<uint8_t> (Size: 0x10)
Player.PlayerController = 0x30 // PlayerController* (Size: 0x8)
Player.CurrentNetSpeed = 0x38 // int32_t (Size: 0x4)
Player.ConfiguredInternetSpeed = 0x3c // int32_t (Size: 0x4)
Player.ConfiguredLanSpeed = 0x40 // int32_t (Size: 0x4)
PlayerCameraManager.PCOwner = 0x310 // PlayerController* (Size: 0x8)
PlayerCameraManager.TransformComponent = 0x318 // SceneComponent* (Size: 0x8)
PlayerCameraManager.DefaultFOV = 0x328 // float (Size: 0x4)
PlayerCameraManager.DefaultOrthoWidth = 0x330 // float (Size: 0x4)
PlayerCameraManager.DefaultAspectRatio = 0x338 // float (Size: 0x4)
PlayerCameraManager.CameraCache = 0x380 // FCameraCacheEntry (Size: 0x730)
PlayerCameraManager.LastFrameCameraCache = 0xab0 // FCameraCacheEntry (Size: 0x730)
PlayerCameraManager.ViewTarget = 0x11e0 // FTViewTarget (Size: 0x740)
PlayerCameraManager.PendingViewTarget = 0x1920 // FTViewTarget (Size: 0x740)
PlayerCameraManager.CameraCachePrivate = 0x2090 // FCameraCacheEntry (Size: 0x730)
PlayerCameraManager.LastFrameCameraCachePrivate = 0x27c0 // FCameraCacheEntry (Size: 0x730)
PlayerCameraManager.ModifierList = 0x2ef0 // TArray<CameraModifier*> (Size: 0x10)
PlayerCameraManager.DefaultModifiers = 0x2f00 // TArray<ClassProperty> (Size: 0x10)
PlayerCameraManager.FreeCamDistance = 0x2f10 // float (Size: 0x4)
PlayerCameraManager.FreeCamOffset = 0x2f14 // FVector (Size: 0xc)
PlayerCameraManager.ViewTargetOffset = 0x2f20 // FVector (Size: 0xc)
PlayerCameraManager.OnAudioFadeChangeEvent = 0x2f30 // FMulticastInlineDelegate (Size: 0x10)
PlayerCameraManager.CameraLensEffects = 0x2f50 // TArray<EmitterCameraLensEffectBase*> (Size: 0x10)
PlayerCameraManager.CachedCameraShakeMod = 0x2f60 // CameraModifier_CameraShake* (Size: 0x8)
PlayerCameraManager.AnimInstPool = 0x2f68 // CameraAnimInst* (Size: 0x8)
PlayerCameraManager.PostProcessBlendCache = 0x2fa8 // TArray<FPostProcessSettings> (Size: 0x10)
PlayerCameraManager.ActiveAnims = 0x2fc8 // TArray<CameraAnimInst*> (Size: 0x10)
PlayerCameraManager.FreeAnims = 0x2fd8 // TArray<CameraAnimInst*> (Size: 0x10)
PlayerCameraManager.AnimCameraActor = 0x2fe8 // CameraActor* (Size: 0x8)
PlayerCameraManager.bIsOrthographic = 0x2ff0 // uint8_t (Size: 0x1)
PlayerCameraManager.bDefaultConstrainAspectRatio = 0x2ff0 // uint8_t (Size: 0x1)
PlayerCameraManager.bClientSimulatingViewTarget = 0x2ff0 // uint8_t (Size: 0x1)
PlayerCameraManager.bUseClientSideCameraUpdates = 0x2ff0 // uint8_t (Size: 0x1)
PlayerCameraManager.bGameCameraCutThisFrame = 0x2ff1 // uint8_t (Size: 0x1)
PlayerCameraManager.ViewPitchMin = 0x2ff4 // float (Size: 0x4)
PlayerCameraManager.ViewPitchMax = 0x2ff8 // float (Size: 0x4)
PlayerCameraManager.ViewYawMin = 0x2ffc // float (Size: 0x4)
PlayerCameraManager.ViewYawMax = 0x3000 // float (Size: 0x4)
PlayerCameraManager.ViewRollMin = 0x3004 // float (Size: 0x4)
PlayerCameraManager.ViewRollMax = 0x3008 // float (Size: 0x4)
PlayerCameraManager.ServerUpdateCameraTimeout = 0x3010 // float (Size: 0x4)
PlayerController.Player = 0x388 // Player* (Size: 0x8)
PlayerController.AcknowledgedPawn = 0x390 // Pawn* (Size: 0x8)
PlayerController.ControllingDirTrackInst = 0x398 // InterpTrackInstDirector* (Size: 0x8)
PlayerController.MyHUD = 0x3a0 // HUD* (Size: 0x8)
PlayerController.PlayerCameraManager = 0x3a8 // PlayerCameraManager* (Size: 0x8)
PlayerController.PlayerCameraManagerClass = 0x3b0 // ClassProperty (Size: 0x8)
PlayerController.bAutoManageActiveCameraTarget = 0x3b8 // bool (Size: 0x1)
PlayerController.TargetViewRotation = 0x3bc // FRotator (Size: 0xc)
PlayerController.SmoothTargetViewRotationSpeed = 0x3d4 // float (Size: 0x4)
PlayerController.HiddenActors = 0x3e0 // TArray<Actor*> (Size: 0x10)
PlayerController.HiddenPrimitiveComponents = 0x3f0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
PlayerController.LastSpectatorStateSynchTime = 0x404 // float (Size: 0x4)
PlayerController.LastSpectatorSyncLocation = 0x408 // FVector (Size: 0xc)
PlayerController.LastSpectatorSyncRotation = 0x414 // FRotator (Size: 0xc)
PlayerController.ClientCap = 0x420 // int32_t (Size: 0x4)
PlayerController.CheatManager = 0x428 // CheatManager* (Size: 0x8)
PlayerController.CheatClass = 0x430 // ClassProperty (Size: 0x8)
PlayerController.PlayerInput = 0x438 // PlayerInput* (Size: 0x8)
PlayerController.ActiveForceFeedbackEffects = 0x440 // TArray<FActiveForceFeedbackEffect> (Size: 0x10)
PlayerController.bSlateForceFeedbackEnable = 0x450 // bool (Size: 0x1)
PlayerController.bProcessDynamicFeedbackEnable = 0x451 // bool (Size: 0x1)
PlayerController.bPlayerIsWaiting = 0x4c8 // uint8_t (Size: 0x1)
PlayerController.NetPlayerIndex = 0x4cc // uint8_t (Size: 0x1)
PlayerController.PendingSwapConnection = 0x508 // NetConnection* (Size: 0x8)
PlayerController.NetConnection = 0x510 // NetConnection* (Size: 0x8)
PlayerController.InputYawScale = 0x524 // float (Size: 0x4)
PlayerController.InputPitchScale = 0x528 // float (Size: 0x4)
PlayerController.InputRollScale = 0x52c // float (Size: 0x4)
PlayerController.bShowMouseCursor = 0x530 // uint8_t (Size: 0x1)
PlayerController.bEnableClickEvents = 0x530 // uint8_t (Size: 0x1)
PlayerController.bEnableTouchEvents = 0x530 // uint8_t (Size: 0x1)
PlayerController.bEnableMouseOverEvents = 0x530 // uint8_t (Size: 0x1)
PlayerController.bEnableTouchOverEvents = 0x530 // uint8_t (Size: 0x1)
PlayerController.bForceFeedbackEnabled = 0x530 // uint8_t (Size: 0x1)
PlayerController.ForceFeedbackScale = 0x534 // float (Size: 0x4)
PlayerController.ClickEventKeys = 0x538 // TArray<FKey> (Size: 0x10)
PlayerController.DefaultMouseCursor = 0x548 // uint8_t (Size: 0x1)
PlayerController.CurrentMouseCursor = 0x549 // uint8_t (Size: 0x1)
PlayerController.DefaultClickTraceChannel = 0x54a // uint8_t (Size: 0x1)
PlayerController.CurrentClickTraceChannel = 0x54b // uint8_t (Size: 0x1)
PlayerController.HitResultTraceDistance = 0x54c // float (Size: 0x4)
PlayerController.SeamlessTravelCount = 0x550 // uint16_t (Size: 0x2)
PlayerController.LastCompletedSeamlessTravelCount = 0x552 // uint16_t (Size: 0x2)
PlayerController.InactiveStateInputComponent = 0x5c8 // InputComponent* (Size: 0x8)
PlayerController.bShouldPerformFullTickWhenPaused = 0x5d0 // uint8_t (Size: 0x1)
PlayerController.CurrentTouchInterface = 0x5e8 // TouchInterface* (Size: 0x8)
PlayerController.SpectatorPawn = 0x640 // SpectatorPawn* (Size: 0x8)
PlayerController.bIsLocalPlayerController = 0x64c // bool (Size: 0x1)
PlayerController.SpawnLocation = 0x650 // FVector (Size: 0xc)
PlayerInput.DebugExecBindings = 0x120 // TArray<FKeyBind> (Size: 0x10)
PlayerInput.InvertedAxis = 0x160 // TArray<FName> (Size: 0x10)
PlayerMuteList.bHasVoiceHandshakeCompleted = 0x30 // bool (Size: 0x1)
PlayerMuteList.VoiceChannelIdx = 0x34 // int32_t (Size: 0x4)
PlayerStart.PlayerStartTag = 0x338 // FName (Size: 0x8)
PlayerState.Score = 0x310 // float (Size: 0x4)
PlayerState.PlayerId = 0x314 // int32_t (Size: 0x4)
PlayerState.Ping = 0x318 // uint8_t (Size: 0x1)
PlayerState.bShouldUpdateReplicatedPing = 0x31a // uint8_t (Size: 0x1)
PlayerState.bIsSpectator = 0x31a // uint8_t (Size: 0x1)
PlayerState.bOnlySpectator = 0x31a // uint8_t (Size: 0x1)
PlayerState.bIsABot = 0x31a // uint8_t (Size: 0x1)
PlayerState.bIsInactive = 0x31a // uint8_t (Size: 0x1)
PlayerState.bFromPreviousLevel = 0x31a // uint8_t (Size: 0x1)
PlayerState.StartTime = 0x31c // int32_t (Size: 0x4)
PlayerState.EngineMessageClass = 0x320 // ClassProperty (Size: 0x8)
PlayerState.ExactPing = 0x328 // float (Size: 0x4)
PlayerState.ExactPingV2 = 0x32c // float (Size: 0x4)
PlayerState.SavedNetworkAddress = 0x330 // FString (Size: 0x10)
PlayerState.UniqueID = 0x340 // FUniqueNetIdRepl (Size: 0x28)
PlayerState.PawnPrivate = 0x370 // Pawn* (Size: 0x8)
PlayerState.PlayerNamePrivate = 0x3f0 // FString (Size: 0x10)
PluginRedirect.OldPluginName = 0x0 // FString (Size: 0x10)
PluginRedirect.NewPluginName = 0x10 // FString (Size: 0x10)
PointDamageEvent.Damage = 0x10 // float (Size: 0x4)
PointDamageEvent.ShotDirection = 0x14 // FVector_NetQuantizeNormal (Size: 0xc)
PointDamageEvent.HitInfo = 0x20 // FHitResult (Size: 0x98)
PointLight.PointLightComponent = 0x320 // PointLightComponent* (Size: 0x8)
PointLightComponent.bUseInverseSquaredFalloff = 0x3f8 // uint8_t (Size: 0x1)
PointLightComponent.LightFalloffExponent = 0x3fc // float (Size: 0x4)
PointLightComponent.SourceRadius = 0x400 // float (Size: 0x4)
PointLightComponent.SoftSourceRadius = 0x404 // float (Size: 0x4)
PointLightComponent.SourceLength = 0x408 // float (Size: 0x4)
PooledCameraShakes.PooledShakes = 0x0 // TArray<CameraShakeBase*> (Size: 0x10)
PoseAsset.PoseContainer = 0x80 // FPoseDataContainer (Size: 0x90)
PoseAsset.bAdditivePose = 0x110 // bool (Size: 0x1)
PoseAsset.BasePoseIndex = 0x114 // int32_t (Size: 0x4)
PoseAsset.RetargetSource = 0x118 // FName (Size: 0x8)
PoseData.LocalSpacePose = 0x0 // TArray<FTransform> (Size: 0x10)
PoseData.TrackToBufferIndex = 0x10 // TMap<...> (Size: 0x50)
PoseData.CurveData = 0x60 // TArray<float> (Size: 0x10)
PoseDataContainer.PoseNames = 0x0 // TArray<FSmartName> (Size: 0x10)
PoseDataContainer.Tracks = 0x10 // TArray<FName> (Size: 0x10)
PoseDataContainer.TrackMap = 0x20 // TMap<...> (Size: 0x50)
PoseDataContainer.Poses = 0x70 // TArray<FPoseData> (Size: 0x10)
PoseDataContainer.Curves = 0x80 // TArray<FAnimCurveBase> (Size: 0x10)
PoseLinkBase.LinkId = 0x0 // int32_t (Size: 0x4)
PoseSnapshot.LocalTransforms = 0x0 // TArray<FTransform> (Size: 0x10)
PoseSnapshot.BoneNames = 0x10 // TArray<FName> (Size: 0x10)
PoseSnapshot.SkeletalMeshName = 0x20 // FName (Size: 0x8)
PoseSnapshot.SnapshotName = 0x28 // FName (Size: 0x8)
PoseSnapshot.bIsValid = 0x30 // bool (Size: 0x1)
PoseWatch.Node = 0x28 // EdGraphNode* (Size: 0x8)
PoseWatch.PoseWatchColour = 0x30 // FColor (Size: 0x4)
PostProcessComponent.Settings = 0x240 // FPostProcessSettings (Size: 0x690)
PostProcessComponent.Priority = 0x8d0 // float (Size: 0x4)
PostProcessComponent.BlendRadius = 0x8d4 // float (Size: 0x4)
PostProcessComponent.BlendWeight = 0x8d8 // float (Size: 0x4)
PostProcessComponent.bEnabled = 0x8dc // uint8_t (Size: 0x1)
PostProcessComponent.bUnbound = 0x8dc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_WhiteTemp = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_WhiteTint = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorSaturation = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorContrast = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGamma = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGain = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorOffset = 0x0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MobileLDRColorSaturation = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MobileLDRColorOffset = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MobileLDRColorGain = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorSaturationShadows = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorContrastShadows = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGammaShadows = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGainShadows = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorOffsetShadows = 0x1 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorSaturationMidtones = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorContrastMidtones = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGammaMidtones = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGainMidtones = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorOffsetMidtones = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorSaturationHighlights = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorContrastHighlights = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGammaHighlights = 0x2 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGainHighlights = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorOffsetHighlights = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorCorrectionShadowsMax = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorCorrectionHighlightsMin = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BlueCorrection = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ExpandGamut = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ToneCurveAmount = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmWhitePoint = 0x3 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmSaturation = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmChannelMixerRed = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmChannelMixerGreen = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmChannelMixerBlue = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmContrast = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmDynamicRange = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmHealAmount = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmToeAmount = 0x4 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmShadowTint = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmShadowTintBlend = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmShadowTintAmount = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmSlope = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmToe = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmShoulder = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmBlackClip = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FilmWhiteClip = 0x5 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_SceneColorTint = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_SceneFringeIntensity = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ChromaticAberrationStartOffset = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientCubemapTint = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientCubemapIntensity = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomMethod = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomIntensity = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomThreshold = 0x6 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom1Tint = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom1Size = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom2Size = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom2Tint = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom3Tint = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom3Size = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom4Tint = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom4Size = 0x7 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom5Tint = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom5Size = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom6Tint = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_Bloom6Size = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomSizeScale = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionTexture = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionSize = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionCenterUV = 0x8 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionPreFilter = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionPreFilterMin = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionPreFilterMax = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionPreFilterMult = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomConvolutionBufferScale = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomDirtMaskIntensity = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomDirtMaskTint = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_BloomDirtMask = 0x9 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_CameraShutterSpeed = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_CameraISO = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMethod = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureLowPercent = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureHighPercent = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMinBrightness = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMaxBrightness = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureCalibrationConstant = 0xa // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureSpeedUp = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureSpeedDown = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureBias = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureBiasCurve = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_CompensateCurveBaseEV = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FXExposureCompensationOffset = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FXExposureCompensationSlope = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_FXExposureCompensationSecondSlope = 0xb // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMeterMask = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMeterMaskWeight = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureApplyPhysicalCameraExposure = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_HistogramLogMin = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_HistogramLogMax = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMeterMaskWeightAdjustmentMin = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMeterMaskWeightAdjustmentMax = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AutoExposureMeterMaskWeightAdjustmentPower = 0xc // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureContrastScale = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureHighlightContrastScale = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureShadowContrastScale = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureDetailStrength = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureBlurredLuminanceBlend = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureBlurredLuminanceKernelSizePercent = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalExposureMiddleGreyBias = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareIntensity = 0xd // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareTint = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareTints = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareBokehSize = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareBokehShape = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LensFlareThreshold = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_VignetteIntensity = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_GrainIntensity = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_GrainJitter = 0xe // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionIntensity = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionIntensityFoliage = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionStaticFraction = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionRadius = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionFarRadius = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionFadeDistance = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionFadeRadius = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionDistance = 0xf // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionRadiusInWS = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionPower = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionBias = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionQuality = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionMipBlend = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionMipScale = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionMipThreshold = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientOcclusionTemporalBlendWeight = 0x10 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingAO = 0x14 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingAOSamplesPerPixel = 0x14 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingAOIntensity = 0x14 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingAORadius = 0x14 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVIntensity = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVDirectionalOcclusionIntensity = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVDirectionalOcclusionRadius = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVDiffuseOcclusionExponent = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVSpecularOcclusionExponent = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVDiffuseOcclusionIntensity = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVSpecularOcclusionIntensity = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVSize = 0x18 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVSecondaryOcclusionIntensity = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVSecondaryBounceIntensity = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVGeometryVolumeBias = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVVplInjectionBias = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVEmissiveInjectionIntensity = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVFadeRange = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LPVDirectionalOcclusionFadeRange = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_IndirectLightingColor = 0x19 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_IndirectLightingIntensity = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_SkyVisibilityScale = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_TODGIAndSkyVisibilityScaleChangeSpeed = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ShadowReduceSpecularAOIntensity = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MinimalIndirectLightingLuminance = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingBrighterAreaIntensity = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingBrighterAreaEVDiffThreshold = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingDarkerAreaIntensity = 0x1a // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingDarkerAreaEVDiffThreshold = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingSceneEVOffset = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LocalTonemappingMinSkyVisibility = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGradingIntensity = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ColorGradingLUT = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldFocalDistance = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_EnableForegroundOnlyDOF = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldCustomFOVForegroundOnly = 0x1b // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldMaxBackgroundRadius = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldFstop = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldMinFstop = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldBladeCount = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldSensorWidth = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldDepthBlurRadius = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldDepthBlurAmount = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldFocalRegion = 0x1c // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldNearTransitionRegion = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldFarTransitionRegion = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldScale = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldNearBlurSize = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldFarBlurSize = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MobileHQGaussian = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldOcclusion = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldSkyFocusDistance = 0x1d // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DepthOfFieldVignetteSize = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_UABlurScopeRadius = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_UABlurScopeThreshold = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_UABlurCircle = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_UABlurOptimal = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MotionBlurAmount = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MotionBlurMax = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MotionBlurTargetFPS = 0x1e // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_MotionBlurPerObjectSize = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenPercentage = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenSpaceReflectionIntensity = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenSpaceReflectionQuality = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenSpaceReflectionMaxRoughness = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenSpaceReflectionRoughnessScale = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ScreenSpaceReflectionStochastic = 0x1f // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ReflectionsType = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_DisableSLWRTR = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_ShadowsType = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingReflectionsMaxRoughness = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingReflectionsMaxBounces = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingReflectionsSamplesPerPixel = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingReflectionsShadows = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingReflectionsTranslucency = 0x20 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_TranslucencyType = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingTranslucencyMaxRoughness = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingTranslucencyRefractionRays = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingTranslucencySamplesPerPixel = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingTranslucencyShadows = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingTranslucencyRefraction = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LightmapMixingTypeOverride = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LumenSceneDetail = 0x21 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LumenSceneLightingUpdateSpeed = 0x22 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LumenFinalGatherQuality = 0x22 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LumenSkylightLeaking = 0x22 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_LumenTraceMeshSDFs = 0x24 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingGI = 0x28 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingGIMaxBounces = 0x28 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_RayTracingGISamplesPerPixel = 0x28 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_PathTracingMaxBounces = 0x28 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_PathTracingSamplesPerPixel = 0x28 // uint8_t (Size: 0x1)
PostProcessSettings.bMobileHQGaussian = 0x2c // uint8_t (Size: 0x1)
PostProcessSettings.BloomMethod = 0x2d // uint8_t (Size: 0x1)
PostProcessSettings.AutoExposureMethod = 0x2e // uint8_t (Size: 0x1)
PostProcessSettings.WhiteTemp = 0x30 // float (Size: 0x4)
PostProcessSettings.WhiteTint = 0x34 // float (Size: 0x4)
PostProcessSettings.ColorSaturation = 0x40 // FVector4 (Size: 0x10)
PostProcessSettings.ColorContrast = 0x50 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGamma = 0x60 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGain = 0x70 // FVector4 (Size: 0x10)
PostProcessSettings.ColorOffset = 0x80 // FVector4 (Size: 0x10)
PostProcessSettings.ColorVibrance = 0x90 // float (Size: 0x4)
PostProcessSettings.MobileLDRColorSaturation = 0xa0 // FVector4 (Size: 0x10)
PostProcessSettings.MobileLDRColorGain = 0xb0 // FVector4 (Size: 0x10)
PostProcessSettings.MobileLDRColorOffset = 0xc0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorSaturationShadows = 0xd0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorContrastShadows = 0xe0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGammaShadows = 0xf0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGainShadows = 0x100 // FVector4 (Size: 0x10)
PostProcessSettings.ColorOffsetShadows = 0x110 // FVector4 (Size: 0x10)
PostProcessSettings.ColorSaturationMidtones = 0x120 // FVector4 (Size: 0x10)
PostProcessSettings.ColorContrastMidtones = 0x130 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGammaMidtones = 0x140 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGainMidtones = 0x150 // FVector4 (Size: 0x10)
PostProcessSettings.ColorOffsetMidtones = 0x160 // FVector4 (Size: 0x10)
PostProcessSettings.ColorSaturationHighlights = 0x170 // FVector4 (Size: 0x10)
PostProcessSettings.ColorContrastHighlights = 0x180 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGammaHighlights = 0x190 // FVector4 (Size: 0x10)
PostProcessSettings.ColorGainHighlights = 0x1a0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorOffsetHighlights = 0x1b0 // FVector4 (Size: 0x10)
PostProcessSettings.ColorCorrectionHighlightsMin = 0x1c0 // float (Size: 0x4)
PostProcessSettings.ColorCorrectionShadowsMax = 0x1c4 // float (Size: 0x4)
PostProcessSettings.BlueCorrection = 0x1c8 // float (Size: 0x4)
PostProcessSettings.ExpandGamut = 0x1cc // float (Size: 0x4)
PostProcessSettings.ToneCurveAmount = 0x1d0 // float (Size: 0x4)
PostProcessSettings.FilmSlope = 0x1d4 // float (Size: 0x4)
PostProcessSettings.FilmToe = 0x1d8 // float (Size: 0x4)
PostProcessSettings.FilmShoulder = 0x1dc // float (Size: 0x4)
PostProcessSettings.FilmBlackClip = 0x1e0 // float (Size: 0x4)
PostProcessSettings.FilmWhiteClip = 0x1e4 // float (Size: 0x4)
PostProcessSettings.FilmWhitePoint = 0x1e8 // FLinearColor (Size: 0x10)
PostProcessSettings.FilmShadowTint = 0x1f8 // FLinearColor (Size: 0x10)
PostProcessSettings.FilmShadowTintBlend = 0x208 // float (Size: 0x4)
PostProcessSettings.FilmShadowTintAmount = 0x20c // float (Size: 0x4)
PostProcessSettings.FilmSaturation = 0x210 // float (Size: 0x4)
PostProcessSettings.FilmChannelMixerRed = 0x214 // FLinearColor (Size: 0x10)
PostProcessSettings.FilmChannelMixerGreen = 0x224 // FLinearColor (Size: 0x10)
PostProcessSettings.FilmChannelMixerBlue = 0x234 // FLinearColor (Size: 0x10)
PostProcessSettings.FilmContrast = 0x244 // float (Size: 0x4)
PostProcessSettings.FilmToeAmount = 0x248 // float (Size: 0x4)
PostProcessSettings.FilmHealAmount = 0x24c // float (Size: 0x4)
PostProcessSettings.FilmDynamicRange = 0x250 // float (Size: 0x4)
PostProcessSettings.SceneColorTint = 0x254 // FLinearColor (Size: 0x10)
PostProcessSettings.SceneFringeIntensity = 0x264 // float (Size: 0x4)
PostProcessSettings.ChromaticAberrationStartOffset = 0x268 // float (Size: 0x4)
PostProcessSettings.BloomIntensity = 0x26c // float (Size: 0x4)
PostProcessSettings.BloomThreshold = 0x270 // float (Size: 0x4)
PostProcessSettings.BloomSizeScale = 0x274 // float (Size: 0x4)
PostProcessSettings.Bloom1Size = 0x278 // float (Size: 0x4)
PostProcessSettings.Bloom2Size = 0x27c // float (Size: 0x4)
PostProcessSettings.Bloom3Size = 0x280 // float (Size: 0x4)
PostProcessSettings.Bloom4Size = 0x284 // float (Size: 0x4)
PostProcessSettings.Bloom5Size = 0x288 // float (Size: 0x4)
PostProcessSettings.Bloom6Size = 0x28c // float (Size: 0x4)
PostProcessSettings.Bloom1Tint = 0x290 // FLinearColor (Size: 0x10)
PostProcessSettings.Bloom2Tint = 0x2a0 // FLinearColor (Size: 0x10)
PostProcessSettings.Bloom3Tint = 0x2b0 // FLinearColor (Size: 0x10)
PostProcessSettings.Bloom4Tint = 0x2c0 // FLinearColor (Size: 0x10)
PostProcessSettings.Bloom5Tint = 0x2d0 // FLinearColor (Size: 0x10)
PostProcessSettings.Bloom6Tint = 0x2e0 // FLinearColor (Size: 0x10)
PostProcessSettings.BloomConvolutionSize = 0x2f0 // float (Size: 0x4)
PostProcessSettings.BloomConvolutionTexture = 0x2f8 // Texture2D* (Size: 0x8)
PostProcessSettings.BloomConvolutionCenterUV = 0x300 // FVector2D (Size: 0x8)
PostProcessSettings.BloomConvolutionPreFilterMin = 0x308 // float (Size: 0x4)
PostProcessSettings.BloomConvolutionPreFilterMax = 0x30c // float (Size: 0x4)
PostProcessSettings.BloomConvolutionPreFilterMult = 0x310 // float (Size: 0x4)
PostProcessSettings.BloomConvolutionBufferScale = 0x314 // float (Size: 0x4)
PostProcessSettings.BloomDirtMask = 0x318 // Texture* (Size: 0x8)
PostProcessSettings.BloomDirtMaskIntensity = 0x320 // float (Size: 0x4)
PostProcessSettings.BloomDirtMaskTint = 0x324 // FLinearColor (Size: 0x10)
PostProcessSettings.AmbientCubemapTint = 0x334 // FLinearColor (Size: 0x10)
PostProcessSettings.AmbientCubemapIntensity = 0x344 // float (Size: 0x4)
PostProcessSettings.AmbientCubemap = 0x348 // TextureCube* (Size: 0x8)
PostProcessSettings.CameraShutterSpeed = 0x350 // float (Size: 0x4)
PostProcessSettings.CameraISO = 0x354 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldFstop = 0x358 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldMinFstop = 0x35c // float (Size: 0x4)
PostProcessSettings.DepthOfFieldBladeCount = 0x360 // int32_t (Size: 0x4)
PostProcessSettings.AutoExposureBias = 0x364 // float (Size: 0x4)
PostProcessSettings.AutoExposureBiasBackup = 0x368 // float (Size: 0x4)
PostProcessSettings.bOverride_AutoExposureBiasBackup = 0x36c // uint8_t (Size: 0x1)
PostProcessSettings.AutoExposureApplyPhysicalCameraExposure = 0x370 // uint8_t (Size: 0x1)
PostProcessSettings.AutoExposureBiasCurve = 0x378 // CurveFloat* (Size: 0x8)
PostProcessSettings.CompensateCurveBaseEV = 0x380 // float (Size: 0x4)
PostProcessSettings.AutoExposureMeterMask = 0x388 // Texture* (Size: 0x8)
PostProcessSettings.AutoExposureMeterMaskWeightAdjustmentMin = 0x390 // float (Size: 0x4)
PostProcessSettings.AutoExposureMeterMaskWeightAdjustmentMax = 0x394 // float (Size: 0x4)
PostProcessSettings.AutoExposureMeterMaskWeightAdjustmentPower = 0x398 // float (Size: 0x4)
PostProcessSettings.AutoExposureMeterMaskWeight = 0x39c // float (Size: 0x4)
PostProcessSettings.AutoExposureLowPercent = 0x3a0 // float (Size: 0x4)
PostProcessSettings.AutoExposureHighPercent = 0x3a4 // float (Size: 0x4)
PostProcessSettings.AutoExposureMinBrightness = 0x3a8 // float (Size: 0x4)
PostProcessSettings.AutoExposureMaxBrightness = 0x3ac // float (Size: 0x4)
PostProcessSettings.AutoExposureSpeedUp = 0x3b0 // float (Size: 0x4)
PostProcessSettings.AutoExposureSpeedDown = 0x3b4 // float (Size: 0x4)
PostProcessSettings.FXExposureCompensationOffset = 0x3b8 // float (Size: 0x4)
PostProcessSettings.FXExposureCompensationSlope = 0x3bc // float (Size: 0x4)
PostProcessSettings.FXExposureCompensationSecondSlope = 0x3c0 // float (Size: 0x4)
PostProcessSettings.HistogramLogMin = 0x3c4 // float (Size: 0x4)
PostProcessSettings.HistogramLogMax = 0x3c8 // float (Size: 0x4)
PostProcessSettings.AutoExposureCalibrationConstant = 0x3cc // float (Size: 0x4)
PostProcessSettings.LocalExposureContrastScale = 0x3d0 // float (Size: 0x4)
PostProcessSettings.LocalExposureHighlightContrastScale = 0x3d4 // float (Size: 0x4)
PostProcessSettings.LocalExposureShadowContrastScale = 0x3d8 // float (Size: 0x4)
PostProcessSettings.LocalExposureDetailStrength = 0x3dc // float (Size: 0x4)
PostProcessSettings.LocalExposureBlurredLuminanceBlend = 0x3e0 // float (Size: 0x4)
PostProcessSettings.LocalExposureBlurredLuminanceKernelSizePercent = 0x3e4 // float (Size: 0x4)
PostProcessSettings.LocalExposureMiddleGreyBias = 0x3e8 // float (Size: 0x4)
PostProcessSettings.LensFlareIntensity = 0x3ec // float (Size: 0x4)
PostProcessSettings.LensFlareTint = 0x3f0 // FLinearColor (Size: 0x10)
PostProcessSettings.LensFlareBokehSize = 0x400 // float (Size: 0x4)
PostProcessSettings.LensFlareThreshold = 0x404 // float (Size: 0x4)
PostProcessSettings.LensFlareBokehShape = 0x408 // Texture* (Size: 0x8)
PostProcessSettings.LensFlareTints = 0x410 // TArray<FLinearColor> (Size: 0x10)
PostProcessSettings.VignetteIntensity = 0x420 // float (Size: 0x4)
PostProcessSettings.GrainJitter = 0x424 // float (Size: 0x4)
PostProcessSettings.GrainIntensity = 0x428 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionIntensity = 0x42c // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionFarIntensity = 0x430 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionFadeOutRadius = 0x434 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionFadeOutDistance = 0x438 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionStaticFraction = 0x43c // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionRadius = 0x440 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionFarRadius = 0x444 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionRadiusInWS = 0x448 // uint8_t (Size: 0x1)
PostProcessSettings.AmbientOcclusionFadeDistance = 0x44c // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionFadeRadius = 0x450 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionDistance = 0x454 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionPower = 0x458 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionBias = 0x45c // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionQuality = 0x460 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionMipBlend = 0x464 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionMipScale = 0x468 // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionMipThreshold = 0x46c // float (Size: 0x4)
PostProcessSettings.AmbientOcclusionTemporalBlendWeight = 0x470 // float (Size: 0x4)
PostProcessSettings.RayTracingAO = 0x474 // uint8_t (Size: 0x1)
PostProcessSettings.RayTracingAOSamplesPerPixel = 0x478 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingAOIntensity = 0x47c // float (Size: 0x4)
PostProcessSettings.RayTracingAORadius = 0x480 // float (Size: 0x4)
PostProcessSettings.IndirectLightingColor = 0x484 // FLinearColor (Size: 0x10)
PostProcessSettings.IndirectLightingIntensity = 0x494 // float (Size: 0x4)
PostProcessSettings.LumenSceneDetail = 0x498 // float (Size: 0x4)
PostProcessSettings.LumenSceneLightingUpdateSpeed = 0x49c // float (Size: 0x4)
PostProcessSettings.LumenFinalGatherQuality = 0x4a0 // float (Size: 0x4)
PostProcessSettings.LumenSkylightLeaking = 0x4a4 // float (Size: 0x4)
PostProcessSettings.LumenTraceMeshSDFs = 0x4a8 // uint8_t (Size: 0x1)
PostProcessSettings.SkyVisibilityScale = 0x4ac // float (Size: 0x4)
PostProcessSettings.TODGIAndSkyVisibilityScaleChangeSpeed = 0x4b0 // float (Size: 0x4)
PostProcessSettings.ShadowReduceSpecularAOIntensity = 0x4b4 // float (Size: 0x4)
PostProcessSettings.MinimalIndirectLightingLuminance = 0x4b8 // float (Size: 0x4)
PostProcessSettings.LocalTonemappingBrighterAreaIntensity = 0x4bc // float (Size: 0x4)
PostProcessSettings.LocalTonemappingBrighterAreaEVDiffThreshold = 0x4c0 // float (Size: 0x4)
PostProcessSettings.LocalTonemappingDarkerAreaIntensity = 0x4c4 // float (Size: 0x4)
PostProcessSettings.LocalTonemappingDarkerAreaEVDiffThreshold = 0x4c8 // float (Size: 0x4)
PostProcessSettings.LocalTonemappingSceneEVOffset = 0x4cc // float (Size: 0x4)
PostProcessSettings.LocalTonemappingMinSkyVisibility = 0x4d0 // float (Size: 0x4)
PostProcessSettings.ColorGainMultiplier = 0x4d4 // float (Size: 0x4)
PostProcessSettings.ColorSaturationMultiplier = 0x4d8 // float (Size: 0x4)
PostProcessSettings.ColorContrastMultiplier = 0x4dc // float (Size: 0x4)
PostProcessSettings.ColorGammaMultiplier = 0x4e0 // FVector (Size: 0xc)
PostProcessSettings.RayTracingGIType = 0x4ec // EERayTracingGlobalIlluminationType (Size: 0x1)
PostProcessSettings.RayTracingGIMaxBounces = 0x4f0 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingGISamplesPerPixel = 0x4f4 // int32_t (Size: 0x4)
PostProcessSettings.ColorGradingIntensity = 0x4f8 // float (Size: 0x4)
PostProcessSettings.ColorGradingLUT = 0x500 // Texture* (Size: 0x8)
PostProcessSettings.DepthOfFieldSensorWidth = 0x508 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldFocalDistance = 0x50c // float (Size: 0x4)
PostProcessSettings.EnableForegroundOnlyDOF = 0x510 // uint8_t (Size: 0x1)
PostProcessSettings.DepthOfFieldCustomFOVForegroundOnly = 0x514 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldMaxBackgroundRadius = 0x518 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldDepthBlurAmount = 0x51c // float (Size: 0x4)
PostProcessSettings.DepthOfFieldDepthBlurRadius = 0x520 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldFocalRegion = 0x524 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldNearTransitionRegion = 0x528 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldFarTransitionRegion = 0x52c // float (Size: 0x4)
PostProcessSettings.DepthOfFieldScale = 0x530 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldNearBlurSize = 0x534 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldFarBlurSize = 0x538 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldOcclusion = 0x53c // float (Size: 0x4)
PostProcessSettings.DepthOfFieldSkyFocusDistance = 0x540 // float (Size: 0x4)
PostProcessSettings.DepthOfFieldVignetteSize = 0x544 // float (Size: 0x4)
PostProcessSettings.UABlurScopeRadius = 0x548 // float (Size: 0x4)
PostProcessSettings.UABlurScopeThreshold = 0x54c // float (Size: 0x4)
PostProcessSettings.bUABlurCircle = 0x550 // uint8_t (Size: 0x1)
PostProcessSettings.bUABlurOptimal = 0x550 // uint8_t (Size: 0x1)
PostProcessSettings.MotionBlurAmount = 0x554 // float (Size: 0x4)
PostProcessSettings.MotionBlurMax = 0x558 // float (Size: 0x4)
PostProcessSettings.MotionBlurTargetFPS = 0x55c // int32_t (Size: 0x4)
PostProcessSettings.MotionBlurPerObjectSize = 0x560 // float (Size: 0x4)
PostProcessSettings.LPVIntensity = 0x564 // float (Size: 0x4)
PostProcessSettings.LPVVplInjectionBias = 0x568 // float (Size: 0x4)
PostProcessSettings.LPVSize = 0x56c // float (Size: 0x4)
PostProcessSettings.LPVSecondaryOcclusionIntensity = 0x570 // float (Size: 0x4)
PostProcessSettings.LPVSecondaryBounceIntensity = 0x574 // float (Size: 0x4)
PostProcessSettings.LPVGeometryVolumeBias = 0x578 // float (Size: 0x4)
PostProcessSettings.LPVEmissiveInjectionIntensity = 0x57c // float (Size: 0x4)
PostProcessSettings.LPVDirectionalOcclusionIntensity = 0x580 // float (Size: 0x4)
PostProcessSettings.LPVDirectionalOcclusionRadius = 0x584 // float (Size: 0x4)
PostProcessSettings.LPVDiffuseOcclusionExponent = 0x588 // float (Size: 0x4)
PostProcessSettings.LPVSpecularOcclusionExponent = 0x58c // float (Size: 0x4)
PostProcessSettings.LPVDiffuseOcclusionIntensity = 0x590 // float (Size: 0x4)
PostProcessSettings.LPVSpecularOcclusionIntensity = 0x594 // float (Size: 0x4)
PostProcessSettings.ReflectionsType = 0x598 // EEReflectionsType (Size: 0x1)
PostProcessSettings.DisableSLWRTR = 0x599 // uint8_t (Size: 0x1)
PostProcessSettings.ShadowsType = 0x59a // EEShadowsType (Size: 0x1)
PostProcessSettings.ScreenSpaceReflectionIntensity = 0x59c // float (Size: 0x4)
PostProcessSettings.ScreenSpaceReflectionQuality = 0x5a0 // float (Size: 0x4)
PostProcessSettings.ScreenSpaceReflectionMaxRoughness = 0x5a4 // float (Size: 0x4)
PostProcessSettings.ScreenSpaceReflectionStochastic = 0x5a8 // uint8_t (Size: 0x1)
PostProcessSettings.RayTracingReflectionsMaxRoughness = 0x5ac // float (Size: 0x4)
PostProcessSettings.RayTracingReflectionsMaxBounces = 0x5b0 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingReflectionsSamplesPerPixel = 0x5b4 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingReflectionsShadows = 0x5b8 // EEReflectedAndRefractedRayTracedShadows (Size: 0x1)
PostProcessSettings.RayTracingReflectionsTranslucency = 0x5b9 // uint8_t (Size: 0x1)
PostProcessSettings.TranslucencyType = 0x5ba // EETranslucencyType (Size: 0x1)
PostProcessSettings.RayTracingTranslucencyMaxRoughness = 0x5bc // float (Size: 0x4)
PostProcessSettings.RayTracingTranslucencyRefractionRays = 0x5c0 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingTranslucencySamplesPerPixel = 0x5c4 // int32_t (Size: 0x4)
PostProcessSettings.RayTracingTranslucencyShadows = 0x5c8 // EEReflectedAndRefractedRayTracedShadows (Size: 0x1)
PostProcessSettings.RayTracingTranslucencyRefraction = 0x5c9 // uint8_t (Size: 0x1)
PostProcessSettings.LightmapMixingTypeOverride = 0x5ca // EELightmapMixingTypeOverride (Size: 0x1)
PostProcessSettings.PathTracingMaxBounces = 0x5cc // int32_t (Size: 0x4)
PostProcessSettings.PathTracingSamplesPerPixel = 0x5d0 // int32_t (Size: 0x4)
PostProcessSettings.LPVFadeRange = 0x5d4 // float (Size: 0x4)
PostProcessSettings.LPVDirectionalOcclusionFadeRange = 0x5d8 // float (Size: 0x4)
PostProcessSettings.ScreenPercentage = 0x5dc // float (Size: 0x4)
PostProcessSettings.bOverride_HeightFogReductionIndoorDepth = 0x5e0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_HeightFogReductionBegin = 0x5e0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_HeightFogReductionEnd = 0x5e0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_HeightFogReductionSkyIrradianceFactor = 0x5e0 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_VolumetricFogReduction = 0x5e0 // uint8_t (Size: 0x1)
PostProcessSettings.HeightFogReductionIndoorDepth = 0x5e4 // float (Size: 0x4)
PostProcessSettings.HeightFogReductionBegin = 0x5e8 // float (Size: 0x4)
PostProcessSettings.HeightFogReductionEnd = 0x5ec // float (Size: 0x4)
PostProcessSettings.HeightFogReductionSkyIrradianceFactor = 0x5f0 // float (Size: 0x4)
PostProcessSettings.VolumetricFogReduction = 0x5f4 // float (Size: 0x4)
PostProcessSettings.bOverride_IndoorMaskTraceDistance = 0x5f8 // uint8_t (Size: 0x1)
PostProcessSettings.IndoorMaskTraceDistance = 0x5fc // float (Size: 0x4)
PostProcessSettings.bOverride_CASSharpness = 0x600 // uint8_t (Size: 0x1)
PostProcessSettings.CASSharpness = 0x604 // float (Size: 0x4)
PostProcessSettings.bOverride_ShouldRenderDynamicDirectionalLights = 0x608 // uint8_t (Size: 0x1)
PostProcessSettings.ShouldRenderDynamicDirectionalLights = 0x60c // float (Size: 0x4)
PostProcessSettings.bOverride_VolumetricFogStaticLightingScatteringScale = 0x610 // uint8_t (Size: 0x1)
PostProcessSettings.VolumetricFogStaticLightingScatteringScale = 0x614 // float (Size: 0x4)
PostProcessSettings.bOverride_AmbientGIBounceIntensity = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIBounceFalloffDistance = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGISkyOcclusionMin = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGISkyOcclusionMax = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIFoliageSkyOcclusionMin = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIFoliageSkyOcclusionMax = 0x618 // uint8_t (Size: 0x1)
PostProcessSettings.AmbientGIBounceIntensity = 0x61c // float (Size: 0x4)
PostProcessSettings.AmbientGIBounceFalloffDistance = 0x620 // float (Size: 0x4)
PostProcessSettings.AmbientGISkyOcclusionMin = 0x624 // float (Size: 0x4)
PostProcessSettings.AmbientGISkyOcclusionMax = 0x628 // float (Size: 0x4)
PostProcessSettings.AmbientGIFoliageSkyOcclusionMin = 0x62c // float (Size: 0x4)
PostProcessSettings.AmbientGIFoliageSkyOcclusionMax = 0x630 // float (Size: 0x4)
PostProcessSettings.bOverride_AmbientGIReSTIROverallIntensity = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRBounceIntensity = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRFoliageIntensity = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRBounceFalloffDistance = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRSkylightRoughness = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRSkyOcclusionMin = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRSkyOcclusionMax = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRCoverageBasedSkylightLeakingOpaque = 0x634 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRCoverageBasedSkylightLeakingFoliage = 0x635 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRFoliageSkyOcclusionMin = 0x635 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRFoliageSkyOcclusionMax = 0x635 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_AmbientGIReSTIRSurfaceBiasScale = 0x635 // uint8_t (Size: 0x1)
PostProcessSettings.AmbientGIReSTIROverallIntensity = 0x638 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRBounceIntensity = 0x63c // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRFoliageIntensity = 0x640 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRBounceFalloffDistance = 0x644 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRSkylightRoughness = 0x648 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRSkyOcclusionMin = 0x64c // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRSkyOcclusionMax = 0x650 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRCoverageBasedSkylightLeakingOpaque = 0x654 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRCoverageBasedSkylightLeakingFoliage = 0x658 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRFoliageSkyOcclusionMin = 0x65c // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRFoliageSkyOcclusionMax = 0x660 // float (Size: 0x4)
PostProcessSettings.AmbientGIReSTIRSurfaceBiasScale = 0x664 // float (Size: 0x4)
PostProcessSettings.bOverride_CACharacterIndirectMinLuminanceIndoor = 0x668 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_CACharacterIndirectMinLuminanceOutdoor = 0x668 // uint8_t (Size: 0x1)
PostProcessSettings.bOverride_CACharacterIndirectCompensationLuminance = 0x668 // uint8_t (Size: 0x1)
PostProcessSettings.CACharacterIndirectMinLuminanceIndoor = 0x66c // float (Size: 0x4)
PostProcessSettings.CACharacterIndirectMinLuminanceOutdoor = 0x670 // float (Size: 0x4)
PostProcessSettings.CACharacterIndirectCompensationLuminance = 0x674 // float (Size: 0x4)
PostProcessSettings.bOverride_FSR3CreateReactiveMask = 0x678 // uint8_t (Size: 0x1)
PostProcessSettings.FSR3CreateReactiveMask = 0x678 // uint8_t (Size: 0x1)
PostProcessSettings.WeightedBlendables = 0x680 // FWeightedBlendables (Size: 0x10)
PostProcessVolume.Settings = 0x350 // FPostProcessSettings (Size: 0x690)
PostProcessVolume.Priority = 0x9e0 // float (Size: 0x4)
PostProcessVolume.BlendRadius = 0x9e4 // float (Size: 0x4)
PostProcessVolume.BlendWeight = 0x9e8 // float (Size: 0x4)
PostProcessVolume.bEnabled = 0x9ec // uint8_t (Size: 0x1)
PostProcessVolume.bUnbound = 0x9ec // uint8_t (Size: 0x1)
PrecomputedLightInstanceData.Transform = 0xc0 // FTransform (Size: 0x30)
PrecomputedLightInstanceData.LightGuid = 0xf0 // FGuid (Size: 0x10)
PrecomputedLightInstanceData.PreviewShadowMapChannel = 0x100 // int32_t (Size: 0x4)
PrecomputedSkyLightInstanceData.LightGuid = 0xb8 // FGuid (Size: 0x10)
PrecomputedSkyLightInstanceData.AverageBrightness = 0xc8 // float (Size: 0x4)
PrecomputedVisibilityOverrideVolume.OverrideVisibleActors = 0x348 // TArray<Actor*> (Size: 0x10)
PrecomputedVisibilityOverrideVolume.OverrideInvisibleActors = 0x358 // TArray<Actor*> (Size: 0x10)
PrecomputedVisibilityOverrideVolume.OverrideInvisibleLevels = 0x368 // TArray<FName> (Size: 0x10)
PredictProjectilePathParams.StartLocation = 0x0 // FVector (Size: 0xc)
PredictProjectilePathParams.LaunchVelocity = 0xc // FVector (Size: 0xc)
PredictProjectilePathParams.bTraceWithCollision = 0x18 // bool (Size: 0x1)
PredictProjectilePathParams.ProjectileRadius = 0x1c // float (Size: 0x4)
PredictProjectilePathParams.MaxSimTime = 0x20 // float (Size: 0x4)
PredictProjectilePathParams.bTraceWithChannel = 0x24 // bool (Size: 0x1)
PredictProjectilePathParams.TraceChannel = 0x25 // uint8_t (Size: 0x1)
PredictProjectilePathParams.ObjectTypes = 0x28 // TArray<uint8_t> (Size: 0x10)
PredictProjectilePathParams.ActorsToIgnore = 0x38 // TArray<Actor*> (Size: 0x10)
PredictProjectilePathParams.SimFrequency = 0x48 // float (Size: 0x4)
PredictProjectilePathParams.OverrideGravityZ = 0x4c // float (Size: 0x4)
PredictProjectilePathParams.DrawDebugType = 0x50 // uint8_t (Size: 0x1)
PredictProjectilePathParams.DrawDebugTime = 0x54 // float (Size: 0x4)
PredictProjectilePathParams.bTraceComplex = 0x58 // bool (Size: 0x1)
PredictProjectilePathPointData.Location = 0x0 // FVector (Size: 0xc)
PredictProjectilePathPointData.Velocity = 0xc // FVector (Size: 0xc)
PredictProjectilePathPointData.Time = 0x18 // float (Size: 0x4)
PredictProjectilePathResult.PathData = 0x0 // TArray<FPredictProjectilePathPointData> (Size: 0x10)
PredictProjectilePathResult.LastTraceDestination = 0x10 // FPredictProjectilePathPointData (Size: 0x1c)
PredictProjectilePathResult.HitResult = 0x30 // FHitResult (Size: 0x98)
PreviewAssetAttachContainer.AttachedObjects = 0x0 // TArray<FPreviewAttachedObjectPair> (Size: 0x10)
PreviewAttachedObjectPair.AttachedObject = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
PreviewAttachedObjectPair.Object = 0x28 // Object* (Size: 0x8)
PreviewAttachedObjectPair.AttachedTo = 0x30 // FName (Size: 0x8)
PreviewMeshCollection.Skeleton = 0x38 // Skeleton* (Size: 0x8)
PreviewMeshCollection.SkeletalMeshes = 0x40 // TArray<FPreviewMeshCollectionEntry> (Size: 0x10)
PreviewMeshCollectionEntry.SkeletalMesh = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
PrimaryAssetLabel.rules = 0x30 // FPrimaryAssetRules (Size: 0xc)
PrimaryAssetLabel.bLabelAssetsInMyDirectory = 0x3c // uint8_t (Size: 0x1)
PrimaryAssetLabel.bLabelCustomDirectory = 0x3c // uint8_t (Size: 0x1)
PrimaryAssetLabel.LabelCustomContent = 0x40 // TArray<FDirectoryPath> (Size: 0x10)
PrimaryAssetLabel.bIsRuntimeLabel = 0x50 // uint8_t (Size: 0x1)
PrimaryAssetLabel.ExplicitAssets = 0x58 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
PrimaryAssetLabel.ExplicitBlueprints = 0x68 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
PrimaryAssetLabel.AssetCollection = 0x78 // FCollectionReference (Size: 0x8)
PrimaryAssetRules.Priority = 0x0 // int32_t (Size: 0x4)
PrimaryAssetRules.ChunkId = 0x4 // int32_t (Size: 0x4)
PrimaryAssetRules.bApplyRecursively = 0x8 // bool (Size: 0x1)
PrimaryAssetRules.CookRule = 0x9 // EEPrimaryAssetCookRule (Size: 0x1)
PrimaryAssetRulesCustomOverride.PrimaryAssetType = 0x0 // FPrimaryAssetType (Size: 0x8)
PrimaryAssetRulesCustomOverride.FilterDirectory = 0x8 // FDirectoryPath (Size: 0x10)
PrimaryAssetRulesCustomOverride.FilterString = 0x18 // FString (Size: 0x10)
PrimaryAssetRulesCustomOverride.rules = 0x28 // FPrimaryAssetRules (Size: 0xc)
PrimaryAssetRulesOverride.PrimaryAssetId = 0x0 // FPrimaryAssetId (Size: 0x10)
PrimaryAssetRulesOverride.rules = 0x10 // FPrimaryAssetRules (Size: 0xc)
PrimaryAssetTypeInfo.PrimaryAssetType = 0x0 // FName (Size: 0x8)
PrimaryAssetTypeInfo.AssetBaseClass = 0x8 // TSoftClassPtr<UObject> (Size: 0x28)
PrimaryAssetTypeInfo.AssetBaseClassLoaded = 0x30 // ClassProperty (Size: 0x8)
PrimaryAssetTypeInfo.bHasBlueprintClasses = 0x38 // bool (Size: 0x1)
PrimaryAssetTypeInfo.bIsEditorOnly = 0x39 // bool (Size: 0x1)
PrimaryAssetTypeInfo.Directories = 0x40 // TArray<FDirectoryPath> (Size: 0x10)
PrimaryAssetTypeInfo.SpecificAssets = 0x50 // TArray<FSoftObjectPath> (Size: 0x10)
PrimaryAssetTypeInfo.rules = 0x60 // FPrimaryAssetRules (Size: 0xc)
PrimaryAssetTypeInfo.AssetScanPaths = 0x70 // TArray<FString> (Size: 0x10)
PrimaryAssetTypeInfo.bIsDynamicAsset = 0x80 // bool (Size: 0x1)
PrimaryAssetTypeInfo.NumberOfAssets = 0x84 // int32_t (Size: 0x4)
PrimitiveComponent.MinDrawDistance = 0x240 // float (Size: 0x4)
PrimitiveComponent.LDMaxDrawDistance = 0x244 // float (Size: 0x4)
PrimitiveComponent.CachedMaxDrawDistance = 0x248 // float (Size: 0x4)
PrimitiveComponent.DepthPriorityGroup = 0x24c // uint8_t (Size: 0x1)
PrimitiveComponent.ViewOwnerDepthPriorityGroup = 0x24d // uint8_t (Size: 0x1)
PrimitiveComponent.IndirectLightingCacheQuality = 0x24e // uint8_t (Size: 0x1)
PrimitiveComponent.LightmapType = 0x24f // EELightmapType (Size: 0x1)
PrimitiveComponent.VolumetricLightmapSampleType = 0x250 // EEVolumetricLightmapSampleType (Size: 0x1)
PrimitiveComponent.VolumetricOcclusionMode = 0x251 // EEVolumetricOcclusionMode (Size: 0x1)
PrimitiveComponent.bReceiveDynamicLight = 0x252 // bool (Size: 0x1)
PrimitiveComponent.bUseMaxLODAsImposter = 0x253 // uint8_t (Size: 0x1)
PrimitiveComponent.bBatchImpostersAsInstances = 0x253 // uint8_t (Size: 0x1)
PrimitiveComponent.bNeverDistanceCull = 0x253 // uint8_t (Size: 0x1)
PrimitiveComponent.bSkipOcclusionQuery = 0x253 // uint8_t (Size: 0x1)
PrimitiveComponent.bAlwaysCreatePhysicsState = 0x254 // uint8_t (Size: 0x1)
PrimitiveComponent.bGenerateOverlapEvents = 0x254 // uint8_t (Size: 0x1)
PrimitiveComponent.CachedMoveOverlapsShapes = 0x268 // FPrimitivePhysicsShapes (Size: 0xb0)
PrimitiveComponent.bForceSweepIgnoreOverlaps = 0x350 // uint8_t (Size: 0x1)
PrimitiveComponent.CacheVolumeQuerySphereRadius = 0x354 // float (Size: 0x4)
PrimitiveComponent.bSweepFindInitialOverlaps = 0x358 // bool (Size: 0x1)
PrimitiveComponent.bUseVolumeCache = 0x370 // uint8_t (Size: 0x1)
PrimitiveComponent.bMultiBodyOverlap = 0x370 // uint8_t (Size: 0x1)
PrimitiveComponent.bReturnOverlapShapes = 0x370 // uint8_t (Size: 0x1)
PrimitiveComponent.bTraceComplexOnMove = 0x370 // uint8_t (Size: 0x1)
PrimitiveComponent.bReturnMaterialOnMove = 0x370 // uint8_t (Size: 0x1)
PrimitiveComponent.bEnableBiDirectionTraceForMovement = 0x371 // bool (Size: 0x1)
PrimitiveComponent.bUseViewOwnerDepthPriorityGroup = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bAllowCullDistanceVolume = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bHasMotionBlurVelocityMeshes = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bVisibleInReflectionCaptures = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bVisibleInRealTimeSkyCaptures = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bVisibleInRayTracing = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bVisibleInSceneCaptureOnly = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bHiddenInSceneCapture = 0x372 // uint8_t (Size: 0x1)
PrimitiveComponent.bRayTracingFarField = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bForceVisibleInReceivesSubMeshDecal = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bRenderInMainPass = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bRenderInDepthPass = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bReceivesDecals = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bForceDynamicWhenReceivesSubMeshDecals = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bRenderInFront = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bOwnerNoSee = 0x373 // uint8_t (Size: 0x1)
PrimitiveComponent.bOnlyOwnerSee = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bOnlyRenderInSpecialScopeView = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bOnlyRenderOutOfSpecialScopeView = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bTreatAsBackgroundForOcclusion = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bUseAsOccluder = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bSelectable = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bForceMipStreaming = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.bHasPerInstanceHitProxies = 0x374 // uint8_t (Size: 0x1)
PrimitiveComponent.CastShadow = 0x375 // uint8_t (Size: 0x1)
PrimitiveComponent.bAffectDynamicIndirectLighting = 0x375 // uint8_t (Size: 0x1)
PrimitiveComponent.bAffectDistanceFieldLighting = 0x375 // uint8_t (Size: 0x1)
PrimitiveComponent.CADistanceFieldOptimization = 0x376 // EECADistanceFieldOptimizeType (Size: 0x1)
PrimitiveComponent.DistanceFieldStreamingForceNumMips = 0x378 // int32_t (Size: 0x4)
PrimitiveComponent.bCastDynamicShadow = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastDynamicShadowForDirectionalLight = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastDynamicShadowForLocalLight = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastStaticShadow = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastVolumetricTranslucentShadow = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastContactShadow = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bSelfShadowOnly = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastFarShadow = 0x37c // uint8_t (Size: 0x1)
PrimitiveComponent.bCastInsetShadow = 0x37d // uint8_t (Size: 0x1)
PrimitiveComponent.bCastCinematicShadow = 0x37d // uint8_t (Size: 0x1)
PrimitiveComponent.bCastHiddenShadow = 0x37d // uint8_t (Size: 0x1)
PrimitiveComponent.bHiddenShadowOnShadowCapture = 0x37d // uint8_t (Size: 0x1)
PrimitiveComponent.ShadowCaptureLayer = 0x37e // EEShadowCaptureLayer (Size: 0x1)
PrimitiveComponent.PlayerPrimitiveType = 0x37f // EECAPlayerPrimitiveType (Size: 0x1)
PrimitiveComponent.BuildingPrimitiveType = 0x380 // EECABuildingPrimitiveType (Size: 0x1)
PrimitiveComponent.bCastShadowAsTwoSided = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bCastDFShadow = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bLightAsIfStatic = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bLightAttachmentsAsGroup = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bExcludeFromLightAttachmentGroup = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bCSMCacheForceEnable = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bCSMCacheEnableRemoveFix = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bReceiveMobileCSMShadows = 0x381 // uint8_t (Size: 0x1)
PrimitiveComponent.bSingleSampleShadowFromStationaryLights = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bIgnoreRadialImpulse = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bIgnoreRadialForce = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bApplyImpulseOnDamage = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bReplicatePhysicsToAutonomousProxy = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bFillCollisionUnderneathForNavmesh = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.AlwaysLoadOnClient = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.AlwaysLoadOnServer = 0x382 // uint8_t (Size: 0x1)
PrimitiveComponent.bUseEditorCompositing = 0x383 // uint8_t (Size: 0x1)
PrimitiveComponent.bRenderCustomDepth = 0x383 // uint8_t (Size: 0x1)
PrimitiveComponent.MpeMoveableType = 0x384 // EEMpeMoveableType (Size: 0x1)
PrimitiveComponent.bReMergeInstancing = 0x385 // uint8_t (Size: 0x1)
PrimitiveComponent.CachedLastLODIndex = 0x386 // int8_t (Size: 0x1)
PrimitiveComponent.bIsHLOD = 0x387 // uint8_t (Size: 0x1)
PrimitiveComponent.bForcedIntoViewAsFallback = 0x387 // uint8_t (Size: 0x1)
PrimitiveComponent.bHasCustomNavigableGeometry = 0x388 // uint8_t (Size: 0x1)
PrimitiveComponent.CanCharacterStepUpOn = 0x38a // uint8_t (Size: 0x1)
PrimitiveComponent.LightingChannels = 0x38b // FLightingChannels (Size: 0x1)
PrimitiveComponent.CustomDepthStencilWriteMask = 0x38c // EERendererStencilMask (Size: 0x1)
PrimitiveComponent.CustomDepthStencilValue = 0x390 // int32_t (Size: 0x4)
PrimitiveComponent.bForceUseSkyReflectionCaptureOnly = 0x394 // uint8_t (Size: 0x1)
PrimitiveComponent.bForceDisableShadowReduceSpecularAO = 0x394 // uint8_t (Size: 0x1)
PrimitiveComponent.bApplyMaterialTranslucencySortOffset = 0x394 // uint8_t (Size: 0x1)
PrimitiveComponent.CustomRenderMatrixComponent = 0x398 // CustomRenderMatrixComponent* (Size: 0x8)
PrimitiveComponent.CustomPrimitiveData = 0x3a0 // FCustomPrimitiveData (Size: 0x10)
PrimitiveComponent.CustomPrimitiveDataInternal = 0x3b0 // FCustomPrimitiveData (Size: 0x10)
PrimitiveComponent.TranslucencySortPriority = 0x3c8 // int32_t (Size: 0x4)
PrimitiveComponent.VisibilityId = 0x3cc // int32_t (Size: 0x4)
PrimitiveComponent.RuntimeVirtualTextures = 0x3d0 // TArray<RuntimeVirtualTexture*> (Size: 0x10)
PrimitiveComponent.VirtualTextureLodBias = 0x3e0 // int8_t (Size: 0x1)
PrimitiveComponent.VirtualTextureCullMips = 0x3e1 // int8_t (Size: 0x1)
PrimitiveComponent.VirtualTextureMinCoverage = 0x3e2 // int8_t (Size: 0x1)
PrimitiveComponent.VirtualTextureRenderPassType = 0x3e3 // EERuntimeVirtualTextureMainPassType (Size: 0x1)
PrimitiveComponent.VirtualTextureFlushStreamingLod = 0x3e4 // int8_t (Size: 0x1)
PrimitiveComponent.LpvBiasMultiplier = 0x3ec // float (Size: 0x4)
PrimitiveComponent.BoundsScale = 0x3f8 // float (Size: 0x4)
PrimitiveComponent.MoveIgnoreActors = 0x408 // TArray<Actor*> (Size: 0x10)
PrimitiveComponent.MoveIgnoreComponents = 0x418 // TArray<PrimitiveComponent*> (Size: 0x10)
PrimitiveComponent.BodyInstance = 0x438 // FBodyInstance (Size: 0x158)
PrimitiveComponent.OnComponentHit = 0x590 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnComponentBeginOverlap = 0x591 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnComponentEndOverlap = 0x592 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnComponentUpdateOverlap = 0x593 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnComponentWake = 0x594 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnComponentSleep = 0x595 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnBeginCursorOver = 0x597 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnEndCursorOver = 0x598 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnClicked = 0x599 // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnReleased = 0x59a // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnInputTouchBegin = 0x59b // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnInputTouchEnd = 0x59c // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnInputTouchEnter = 0x59d // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.OnInputTouchLeave = 0x59e // FMulticastSparseDelegate (Size: 0x1)
PrimitiveComponent.LODParentPrimitive = 0x5b8 // PrimitiveComponent* (Size: 0x8)
PrimitiveComponent.bSupportRayQueryMaterial = 0x5c0 // uint8_t (Size: 0x1)
PrimitiveComponent.bReceiveRayQueryReflection = 0x5c0 // uint8_t (Size: 0x1)
PrimitiveComponent.bCastRayQuerySelectiveSunShadow = 0x5c0 // uint8_t (Size: 0x1)
PrimitiveComponent.bNeverCullByView = 0x5c0 // uint8_t (Size: 0x1)
PrimitiveComponent.CullDistanceScale = 0x5c4 // float (Size: 0x4)
PrimitiveComponentInstanceData.ComponentTransform = 0xc0 // FTransform (Size: 0x30)
PrimitiveComponentInstanceData.VisibilityId = 0xf0 // int32_t (Size: 0x4)
PrimitiveComponentInstanceData.LODParent = 0xf8 // PrimitiveComponent* (Size: 0x8)
PrimitiveMaterialRef.Primitive = 0x0 // PrimitiveComponent* (Size: 0x8)
PrimitiveMaterialRef.Decal = 0x8 // DecalComponent* (Size: 0x8)
PrimitiveMaterialRef.ElementIndex = 0x10 // int32_t (Size: 0x4)
PrimitivePhysicsShapes.BlockShapes = 0x0 // TMap<...> (Size: 0x50)
PrimitivePhysicsShapes.TouchShapes = 0x50 // TMap<...> (Size: 0x50)
ProjectileMovementComponent.InitialSpeed = 0x138 // float (Size: 0x4)
ProjectileMovementComponent.MaxSpeed = 0x13c // float (Size: 0x4)
ProjectileMovementComponent.bRotationFollowsVelocity = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bRotationRemainsVertical = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bShouldBounce = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bInitialVelocityInLocalSpace = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bForceSubStepping = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bSimulationEnabled = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bSweepCollision = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bIsHomingProjectile = 0x140 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bBounceAngleAffectsFriction = 0x141 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bIsSliding = 0x141 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bInterpMovement = 0x141 // uint8_t (Size: 0x1)
ProjectileMovementComponent.bInterpRotation = 0x141 // uint8_t (Size: 0x1)
ProjectileMovementComponent.PreviousHitTime = 0x144 // float (Size: 0x4)
ProjectileMovementComponent.PreviousHitNormal = 0x148 // FVector (Size: 0xc)
ProjectileMovementComponent.ProjectileGravityScale = 0x154 // float (Size: 0x4)
ProjectileMovementComponent.Buoyancy = 0x158 // float (Size: 0x4)
ProjectileMovementComponent.Bounciness = 0x15c // float (Size: 0x4)
ProjectileMovementComponent.Friction = 0x160 // float (Size: 0x4)
ProjectileMovementComponent.BounceVelocityStopSimulatingThreshold = 0x164 // float (Size: 0x4)
ProjectileMovementComponent.MinFrictionFraction = 0x168 // float (Size: 0x4)
ProjectileMovementComponent.OnProjectileBounce = 0x170 // FMulticastInlineDelegate (Size: 0x10)
ProjectileMovementComponent.OnProjectileStop = 0x180 // FMulticastInlineDelegate (Size: 0x10)
ProjectileMovementComponent.OnProjectileStick = 0x190 // FMulticastInlineDelegate (Size: 0x10)
ProjectileMovementComponent.bCheckStick = 0x1a0 // bool (Size: 0x1)
ProjectileMovementComponent.HomingAccelerationMagnitude = 0x1a4 // float (Size: 0x4)
ProjectileMovementComponent.HomingTargetComponent = 0x1a8 // TWeakObjectPtr<UObject> (Size: 0x8)
ProjectileMovementComponent.MaxSimulationTimeStep = 0x1b0 // float (Size: 0x4)
ProjectileMovementComponent.MaxSimulationIterations = 0x1b4 // int32_t (Size: 0x4)
ProjectileMovementComponent.BounceAdditionalIterations = 0x1b8 // int32_t (Size: 0x4)
ProjectileMovementComponent.InterpLocationTime = 0x1bc // float (Size: 0x4)
ProjectileMovementComponent.InterpRotationTime = 0x1c0 // float (Size: 0x4)
ProjectileMovementComponent.InterpLocationMaxLagDistance = 0x1c4 // float (Size: 0x4)
ProjectileMovementComponent.InterpLocationSnapToTargetDistance = 0x1c8 // float (Size: 0x4)
ProxyLODMeshSimplificationSettings.ProxyLODMeshReductionModuleName = 0x38 // FName (Size: 0x8)
PurchaseInfo.Identifier = 0x0 // FString (Size: 0x10)
PurchaseInfo.DisplayName = 0x10 // FString (Size: 0x10)
PurchaseInfo.DisplayDescription = 0x20 // FString (Size: 0x10)
PurchaseInfo.DisplayPrice = 0x30 // FString (Size: 0x10)
QuartzClockSettings.TimeSignature = 0x0 // FQuartzTimeSignature (Size: 0x18)
QuartzClockSettings.bIgnoreLevelChange = 0x18 // bool (Size: 0x1)
QuartzPulseOverrideStep.NumberOfPulses = 0x0 // int32_t (Size: 0x4)
QuartzPulseOverrideStep.PulseDuration = 0x4 // EEQuartzCommandQuantization (Size: 0x1)
QuartzQuantizationBoundary.Quantization = 0x0 // EEQuartzCommandQuantization (Size: 0x1)
QuartzQuantizationBoundary.Multiplier = 0x4 // float (Size: 0x4)
QuartzQuantizationBoundary.CountingReferencePoint = 0x8 // EEQuarztQuantizationReference (Size: 0x1)
QuartzTimeSignature.NumBeats = 0x0 // int32_t (Size: 0x4)
QuartzTimeSignature.BeatType = 0x4 // EEQuartzTimeSignatureQuantization (Size: 0x1)
QuartzTimeSignature.OptionalPulseOverride = 0x8 // TArray<FQuartzPulseOverrideStep> (Size: 0x10)
QueuedDrawDebugItem.ItemType = 0x0 // uint8_t (Size: 0x1)
QueuedDrawDebugItem.StartLoc = 0x4 // FVector (Size: 0xc)
QueuedDrawDebugItem.EndLoc = 0x10 // FVector (Size: 0xc)
QueuedDrawDebugItem.Center = 0x1c // FVector (Size: 0xc)
QueuedDrawDebugItem.Rotation = 0x28 // FRotator (Size: 0xc)
QueuedDrawDebugItem.Radius = 0x34 // float (Size: 0x4)
QueuedDrawDebugItem.Size = 0x38 // float (Size: 0x4)
QueuedDrawDebugItem.Segments = 0x3c // int32_t (Size: 0x4)
QueuedDrawDebugItem.Color = 0x40 // FColor (Size: 0x4)
QueuedDrawDebugItem.bPersistentLines = 0x44 // bool (Size: 0x1)
QueuedDrawDebugItem.LifeTime = 0x48 // float (Size: 0x4)
QueuedDrawDebugItem.Thickness = 0x4c // float (Size: 0x4)
QueuedDrawDebugItem.Message = 0x50 // FString (Size: 0x10)
QueuedDrawDebugItem.TextScale = 0x60 // FVector2D (Size: 0x8)
ROscillator.Pitch = 0x0 // FFOscillator (Size: 0xc)
ROscillator.Yaw = 0xc // FFOscillator (Size: 0xc)
ROscillator.Roll = 0x18 // FFOscillator (Size: 0xc)
RPCMonitorStruct.BeginTime = 0x0 // double (Size: 0x8)
RPCMonitorStruct.Objs = 0x8 // TArray<Object*> (Size: 0x10)
RPCMonitorStruct.RPCNum = 0x18 // int32_t (Size: 0x4)
RPCMonitorStruct.RPCMap = 0x20 // TMap<...> (Size: 0x50)
RadialDamageEvent.Params = 0x10 // FRadialDamageParams (Size: 0x14)
RadialDamageEvent.Origin = 0x24 // FVector (Size: 0xc)
RadialDamageEvent.ComponentHits = 0x30 // TArray<FHitResult> (Size: 0x10)
RadialDamageParams.BaseDamage = 0x0 // float (Size: 0x4)
RadialDamageParams.MinimumDamage = 0x4 // float (Size: 0x4)
RadialDamageParams.InnerRadius = 0x8 // float (Size: 0x4)
RadialDamageParams.OuterRadius = 0xc // float (Size: 0x4)
RadialDamageParams.DamageFalloff = 0x10 // float (Size: 0x4)
RadialForceActor.ForceComponent = 0x310 // RadialForceComponent* (Size: 0x8)
RadialForceComponent.Radius = 0x238 // float (Size: 0x4)
RadialForceComponent.Falloff = 0x23c // uint8_t (Size: 0x1)
RadialForceComponent.ImpulseStrength = 0x240 // float (Size: 0x4)
RadialForceComponent.bImpulseVelChange = 0x244 // uint8_t (Size: 0x1)
RadialForceComponent.bIgnoreOwningActor = 0x244 // uint8_t (Size: 0x1)
RadialForceComponent.ForceStrength = 0x248 // float (Size: 0x4)
RadialForceComponent.DestructibleDamage = 0x24c // float (Size: 0x4)
RadialForceComponent.ObjectTypesToAffect = 0x250 // TArray<uint8_t> (Size: 0x10)
RawAnimSequenceTrack.PosKeys = 0x0 // TArray<FVector> (Size: 0x10)
RawAnimSequenceTrack.RotKeys = 0x10 // TArray<FQuat> (Size: 0x10)
RawAnimSequenceTrack.ScaleKeys = 0x20 // TArray<FVector> (Size: 0x10)
RawCurveTracks.FloatCurves = 0x0 // TArray<FFloatCurve> (Size: 0x10)
RawDistribution.Table = 0x0 // FDistributionLookupTable (Size: 0x20)
RawDistributionFloat.MinValue = 0x20 // float (Size: 0x4)
RawDistributionFloat.MaxValue = 0x24 // float (Size: 0x4)
RawDistributionFloat.Distribution = 0x28 // DistributionFloat* (Size: 0x8)
RawDistributionVector.MinValue = 0x20 // float (Size: 0x4)
RawDistributionVector.MaxValue = 0x24 // float (Size: 0x4)
RawDistributionVector.MinValueVec = 0x28 // FVector (Size: 0xc)
RawDistributionVector.MaxValueVec = 0x34 // FVector (Size: 0xc)
RawDistributionVector.Distribution = 0x40 // DistributionVector* (Size: 0x8)
RealCurve.DefaultValue = 0x68 // float (Size: 0x4)
RealCurve.PreInfinityExtrap = 0x6c // uint8_t (Size: 0x1)
RealCurve.PostInfinityExtrap = 0x6d // uint8_t (Size: 0x1)
RectLight.RectLightComponent = 0x320 // RectLightComponent* (Size: 0x8)
RectLightComponent.SourceWidth = 0x3f8 // float (Size: 0x4)
RectLightComponent.SourceHeight = 0x3fc // float (Size: 0x4)
RectLightComponent.BarnDoorAngle = 0x400 // float (Size: 0x4)
RectLightComponent.BarnDoorLength = 0x404 // float (Size: 0x4)
RectLightComponent.SourceTexture = 0x408 // Texture* (Size: 0x8)
Redirector.OldName = 0x0 // FName (Size: 0x8)
Redirector.NewName = 0x8 // FName (Size: 0x8)
ReferencePose.PoseName = 0x0 // FName (Size: 0x8)
ReferencePose.ReferencePose = 0x8 // TArray<FTransform> (Size: 0x10)
ReflectionCapture.CaptureComponent = 0x310 // ReflectionCaptureComponent* (Size: 0x8)
ReflectionCaptureComponent.CaptureOffsetComponent = 0x238 // BillboardComponent* (Size: 0x8)
ReflectionCaptureComponent.ReflectionSourceType = 0x240 // EEReflectionSourceType (Size: 0x1)
ReflectionCaptureComponent.MobileReflectionCompression = 0x241 // EEMobileReflectionCompression (Size: 0x1)
ReflectionCaptureComponent.Cubemap = 0x248 // TextureCube* (Size: 0x8)
ReflectionCaptureComponent.ReflectionCaptureIndirectLightScale = 0x250 // float (Size: 0x4)
ReflectionCaptureComponent.bInterior = 0x254 // bool (Size: 0x1)
ReflectionCaptureComponent.bEnableTODLight = 0x255 // bool (Size: 0x1)
ReflectionCaptureComponent.PrecomputedData = 0x258 // IBLPrecomputedDataAsset* (Size: 0x8)
ReflectionCaptureComponent.SourceCubemapAngle = 0x260 // float (Size: 0x4)
ReflectionCaptureComponent.Brightness = 0x264 // float (Size: 0x4)
ReflectionCaptureComponent.bModifyMaxValueRGBM = 0x268 // bool (Size: 0x1)
ReflectionCaptureComponent.MaxValueRGBM = 0x26c // float (Size: 0x4)
ReflectionCaptureComponent.CaptureOffset = 0x270 // FVector (Size: 0xc)
ReflectionCaptureComponent.MapBuildDataId = 0x27c // FGuid (Size: 0x10)
ReflectionCaptureComponent.VoxelReflectionID = 0x28c // int32_t (Size: 0x4)
ReflectionCaptureComponent.bNeverStream = 0x290 // bool (Size: 0x1)
ReflectionCaptureComponent.MigrationID = 0x294 // int32_t (Size: 0x4)
ReflectionCaptureComponent.BackgroundCapture = 0x298 // TLazyObjectPtr<UObject> (Size: 0x1c)
ReflectionCaptureComponent.CachedEncodedHDRCubemap = 0x2c8 // TextureCube* (Size: 0x8)
RendererOverrideSettings.bSupportAllShaderPermutations = 0x38 // uint8_t (Size: 0x1)
RendererOverrideSettings.bForceRecomputeTangents = 0x38 // uint8_t (Size: 0x1)
RendererSettings.bMobileDisableVertexFog = 0x38 // uint8_t (Size: 0x1)
RendererSettings.MaxMobileCascades = 0x3c // int32_t (Size: 0x4)
RendererSettings.MobileMSAASampleCount = 0x40 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowDitheredLODTransition = 0x44 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowSoftwareOcclusionCulling = 0x44 // uint8_t (Size: 0x1)
RendererSettings.bMobileVirtualTextures = 0x44 // uint8_t (Size: 0x1)
RendererSettings.bDiscardUnusedQualityLevels = 0x44 // uint8_t (Size: 0x1)
RendererSettings.bOcclusionCulling = 0x44 // uint8_t (Size: 0x1)
RendererSettings.MinScreenRadiusForLights = 0x48 // float (Size: 0x4)
RendererSettings.MinScreenRadiusForEarlyZPass = 0x4c // float (Size: 0x4)
RendererSettings.MinScreenRadiusForCSMdepth = 0x50 // float (Size: 0x4)
RendererSettings.bPrecomputedVisibilityWarning = 0x54 // uint8_t (Size: 0x1)
RendererSettings.bTextureStreaming = 0x54 // uint8_t (Size: 0x1)
RendererSettings.bUseDXT5NormalMaps = 0x54 // uint8_t (Size: 0x1)
RendererSettings.bVirtualTextures = 0x54 // uint8_t (Size: 0x1)
RendererSettings.bVirtualTexturedLightmaps = 0x54 // uint8_t (Size: 0x1)
RendererSettings.VirtualTextureTileSize = 0x58 // uint32_t (Size: 0x4)
RendererSettings.VirtualTextureTileBorderSize = 0x5c // uint32_t (Size: 0x4)
RendererSettings.VirtualTextureFeedbackFactor = 0x60 // uint32_t (Size: 0x4)
RendererSettings.bVirtualTextureEnableCompressZlib = 0x64 // uint8_t (Size: 0x1)
RendererSettings.bVirtualTextureEnableCompressCrunch = 0x64 // uint8_t (Size: 0x1)
RendererSettings.bClearCoatEnableSecondNormal = 0x64 // uint8_t (Size: 0x1)
RendererSettings.ReflectionCaptureResolution = 0x68 // int32_t (Size: 0x4)
RendererSettings.bReflectionCaptureCompression = 0x6c // uint8_t (Size: 0x1)
RendererSettings.ReflectionEnvironmentLightmapMixBasedOnRoughness = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bForwardShading = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bVertexFoggingForOpaque = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bAllowStaticLighting = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bUseNormalMapsForStaticLighting = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bGenerateMeshDistanceFields = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bEightBitMeshDistanceFields = 0x6c // uint8_t (Size: 0x1)
RendererSettings.bCompressMeshDistanceFields = 0x6d // uint8_t (Size: 0x1)
RendererSettings.TessellationAdaptivePixelsPerTriangle = 0x70 // float (Size: 0x4)
RendererSettings.bSeparateTranslucency = 0x74 // uint8_t (Size: 0x1)
RendererSettings.TranslucentSortPolicy = 0x78 // uint8_t (Size: 0x1)
RendererSettings.TranslucentSortAxis = 0x7c // FVector (Size: 0xc)
RendererSettings.CustomDepthStencil = 0x88 // uint8_t (Size: 0x1)
RendererSettings.bCustomDepthTaaJitter = 0x8c // uint8_t (Size: 0x1)
RendererSettings.bEnableAlphaChannelInPostProcessing = 0x90 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureBloom = 0x94 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureAmbientOcclusion = 0x94 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureAmbientOcclusionStaticFraction = 0x94 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureAutoExposure = 0x94 // uint8_t (Size: 0x1)
RendererSettings.DefaultFeatureAutoExposure = 0x98 // uint8_t (Size: 0x1)
RendererSettings.DefaultFeatureAutoExposureBias = 0x9c // float (Size: 0x4)
RendererSettings.bExtendDefaultLuminanceRangeInAutoExposureSettings = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bUsePreExposure = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bEnablePreExposureOnlyInTheEditor = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureLocalTonemapping = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureMotionBlur = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bDefaultFeatureLensFlare = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bTemporalUpsampling = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.bSSGI = 0xa0 // uint8_t (Size: 0x1)
RendererSettings.DefaultFeatureAntiAliasing = 0xa4 // uint8_t (Size: 0x1)
RendererSettings.DefaultLightUnits = 0xa5 // EELightUnits (Size: 0x1)
RendererSettings.DefaultBackBufferPixelFormat = 0xa6 // uint8_t (Size: 0x1)
RendererSettings.bRenderUnbuiltPreviewShadowsInGame = 0xa8 // uint8_t (Size: 0x1)
RendererSettings.bStencilForLODDither = 0xa8 // uint8_t (Size: 0x1)
RendererSettings.EarlyZPass = 0xac // uint8_t (Size: 0x1)
RendererSettings.bEarlyZPassOnlyMaterialMasking = 0xb0 // uint8_t (Size: 0x1)
RendererSettings.bDBuffer = 0xb0 // uint8_t (Size: 0x1)
RendererSettings.bFoliageEnableDBufferInput = 0xb0 // uint8_t (Size: 0x1)
RendererSettings.ClearSceneMethod = 0xb4 // uint8_t (Size: 0x1)
RendererSettings.bBasePassOutputsVelocity = 0xb8 // uint8_t (Size: 0x1)
RendererSettings.bVertexDeformationOutputsVelocity = 0xb8 // uint8_t (Size: 0x1)
RendererSettings.bSelectiveBasePassOutputs = 0xb8 // uint8_t (Size: 0x1)
RendererSettings.bDefaultParticleCutouts = 0xb8 // uint8_t (Size: 0x1)
RendererSettings.GPUSimulationTextureSizeX = 0xbc // int32_t (Size: 0x4)
RendererSettings.GPUSimulationTextureSizeY = 0xc0 // int32_t (Size: 0x4)
RendererSettings.bGlobalClipPlane = 0xc4 // uint8_t (Size: 0x1)
RendererSettings.GBufferFormat = 0xc8 // uint8_t (Size: 0x1)
RendererSettings.bUseGPUMorphTargets = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bNvidiaAftermathEnabled = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bMultiView = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bMobilePostProcessing = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bMobileMultiView = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bMobileUseHWsRGBEncoding = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bRoundRobinOcclusion = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bODSCapture = 0xcc // uint8_t (Size: 0x1)
RendererSettings.bMeshStreaming = 0xcd // uint8_t (Size: 0x1)
RendererSettings.WireframeCullThreshold = 0xd0 // float (Size: 0x4)
RendererSettings.bEnableRayTracing = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bEnableRayTracingTextureLOD = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bEnableBindless = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportStationarySkylight = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportLowQualityLightmaps = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportPointLightWholeSceneShadows = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportAtmosphericFog = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportSkyAtmosphere = 0xd4 // uint8_t (Size: 0x1)
RendererSettings.bSupportSkyAtmosphereAffectsHeightFog = 0xd5 // uint8_t (Size: 0x1)
RendererSettings.bSupportSkinCacheShaders = 0xd5 // uint8_t (Size: 0x1)
RendererSettings.DefaultSkinCacheBehavior = 0xd8 // EESkinCacheDefaultBehavior (Size: 0x1)
RendererSettings.SkinCacheSceneMemoryLimitInMB = 0xdc // float (Size: 0x4)
RendererSettings.bMobileEnableStaticAndCSMShadowReceivers = 0xe0 // uint8_t (Size: 0x1)
RendererSettings.bMobileEnableMovableLightCSMShaderCulling = 0xe0 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowDistanceFieldShadows = 0xe0 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowMovableDirectionalLights = 0xe0 // uint8_t (Size: 0x1)
RendererSettings.MobileNumDynamicPointLights = 0xe4 // uint32_t (Size: 0x4)
RendererSettings.bMobileDynamicPointLightsUseStaticBranch = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowMovableSpotlights = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bMobileAllowMovableSpotlightShadows = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bSupport16BitBoneIndex = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bGPUSkinLimit2BoneInfluences = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bSupportDepthOnlyIndexBuffers = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bSupportReversedIndexBuffers = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bLPV = 0xe8 // uint8_t (Size: 0x1)
RendererSettings.bMobileAmbientOcclusion = 0xe9 // uint8_t (Size: 0x1)
RendererSettings.bUseUnlimitedBoneInfluences = 0xe9 // uint8_t (Size: 0x1)
RendererSettings.UnlimitedBonInfluencesThreshold = 0xec // int32_t (Size: 0x4)
RendererSettings.MobilePlanarReflectionMode = 0xf0 // uint8_t (Size: 0x1)
RendererSettings.bStreamSkeletalMeshLODs = 0xf1 // FPerPlatformBool (Size: 0x1)
RendererSettings.bDiscardSkeletalMeshOptionalLODs = 0xf2 // FPerPlatformBool (Size: 0x1)
RendererSettings.VisualizeCalibrationColorMaterialPath = 0xf8 // FSoftObjectPath (Size: 0x18)
RendererSettings.VisualizeCalibrationCustomMaterialPath = 0x110 // FSoftObjectPath (Size: 0x18)
RendererSettings.VisualizeCalibrationGrayscaleMaterialPath = 0x128 // FSoftObjectPath (Size: 0x18)
RendererSettings.bMobileCustomCSM = 0x140 // uint8_t (Size: 0x1)
RendererSettings.MobileCustomCSMDirectionalLightShadowBiasMethod = 0x144 // uint8_t (Size: 0x1)
RendererSettings.bMobileCustomIBL = 0x148 // uint8_t (Size: 0x1)
RendererSettings.MobileCustomIBLSkyNormalizationMethod = 0x14c // uint8_t (Size: 0x1)
RendererSettings.bSupportCloudShadowOnForwardLitTranslucent = 0x150 // uint8_t (Size: 0x1)
RendererSettings.bSupportCloudShadowOnSingleLayerWater = 0x150 // uint8_t (Size: 0x1)
RendererSettings.bOITSortedPixels = 0x150 // uint8_t (Size: 0x1)
RendererSettings.bOITSortedTriangles = 0x150 // uint8_t (Size: 0x1)
RepAttachment.AttachParent = 0x0 // Actor* (Size: 0x8)
RepAttachment.LocationOffset = 0x8 // FVector_NetQuantize100 (Size: 0xc)
RepAttachment.RelativeScale3D = 0x14 // FVector_NetQuantize100 (Size: 0xc)
RepAttachment.RotationOffset = 0x20 // FRotator (Size: 0xc)
RepAttachment.AttachSocket = 0x2c // FName (Size: 0x8)
RepAttachment.AttachComponent = 0x38 // SceneComponent* (Size: 0x8)
RepMovement.LinearVelocity = 0x0 // FVector (Size: 0xc)
RepMovement.AngularVelocity = 0xc // FVector (Size: 0xc)
RepMovement.Location = 0x18 // FVector (Size: 0xc)
RepMovement.Rotation = 0x24 // FRotator (Size: 0xc)
RepMovement.bSimulatedPhysicSleep = 0x30 // uint8_t (Size: 0x1)
RepMovement.bRepPhysics = 0x30 // uint8_t (Size: 0x1)
RepMovement.LocationQuantizationLevel = 0x31 // EEVectorQuantization (Size: 0x1)
RepMovement.VelocityQuantizationLevel = 0x32 // EEVectorQuantization (Size: 0x1)
RepMovement.RotationQuantizationLevel = 0x33 // EERotatorQuantization (Size: 0x1)
RepRootMotionMontage.bIsActive = 0x0 // bool (Size: 0x1)
RepRootMotionMontage.AnimMontage = 0x8 // AnimMontage* (Size: 0x8)
RepRootMotionMontage.position = 0x10 // float (Size: 0x4)
RepRootMotionMontage.Location = 0x14 // FVector_NetQuantize100 (Size: 0xc)
RepRootMotionMontage.Rotation = 0x20 // FRotator (Size: 0xc)
RepRootMotionMontage.MovementBase = 0x30 // PrimitiveComponent* (Size: 0x8)
RepRootMotionMontage.MovementBaseBoneName = 0x38 // FName (Size: 0x8)
RepRootMotionMontage.bRelativePosition = 0x40 // bool (Size: 0x1)
RepRootMotionMontage.bRelativeRotation = 0x41 // bool (Size: 0x1)
RepRootMotionMontage.AuthoritativeRootMotion = 0x48 // FRootMotionSourceGroup (Size: 0x38)
RepRootMotionMontage.Acceleration = 0x80 // FVector_NetQuantize10 (Size: 0xc)
RepRootMotionMontage.LinearVelocity = 0x8c // FVector_NetQuantize10 (Size: 0xc)
ReplicatedStaticActorDestructionInfo.ObjClass = 0x30 // ClassProperty (Size: 0x8)
ResponseChannel.Channel = 0x0 // FName (Size: 0x8)
ResponseChannel.Response = 0x8 // uint8_t (Size: 0x1)
ReverbEffect.bBypassEarlyReflections = 0x28 // bool (Size: 0x1)
ReverbEffect.ReflectionsDelay = 0x2c // float (Size: 0x4)
ReverbEffect.GainHF = 0x30 // float (Size: 0x4)
ReverbEffect.ReflectionsGain = 0x34 // float (Size: 0x4)
ReverbEffect.bBypassLateReflections = 0x38 // bool (Size: 0x1)
ReverbEffect.LateDelay = 0x3c // float (Size: 0x4)
ReverbEffect.DecayTime = 0x40 // float (Size: 0x4)
ReverbEffect.Density = 0x44 // float (Size: 0x4)
ReverbEffect.Diffusion = 0x48 // float (Size: 0x4)
ReverbEffect.AirAbsorptionGainHF = 0x4c // float (Size: 0x4)
ReverbEffect.DecayHFRatio = 0x50 // float (Size: 0x4)
ReverbEffect.LateGain = 0x54 // float (Size: 0x4)
ReverbEffect.Gain = 0x58 // float (Size: 0x4)
ReverbEffect.RoomRolloffFactor = 0x5c // float (Size: 0x4)
ReverbSettings.bApplyReverb = 0x0 // bool (Size: 0x1)
ReverbSettings.ReverbEffect = 0x8 // ReverbEffect* (Size: 0x8)
ReverbSettings.ReverbPluginEffect = 0x10 // SoundEffectSubmixPreset* (Size: 0x8)
ReverbSettings.Volume = 0x18 // float (Size: 0x4)
ReverbSettings.FadeTime = 0x1c // float (Size: 0x4)
RichCurve.Keys = 0x70 // TArray<FRichCurveKey> (Size: 0x10)
RichCurveKey.InterpMode = 0x0 // uint8_t (Size: 0x1)
RichCurveKey.TangentMode = 0x1 // uint8_t (Size: 0x1)
RichCurveKey.TangentWeightMode = 0x2 // uint8_t (Size: 0x1)
RichCurveKey.Time = 0x4 // float (Size: 0x4)
RichCurveKey.Value = 0x8 // float (Size: 0x4)
RichCurveKey.ArriveTangent = 0xc // float (Size: 0x4)
RichCurveKey.ArriveTangentWeight = 0x10 // float (Size: 0x4)
RichCurveKey.LeaveTangent = 0x14 // float (Size: 0x4)
RichCurveKey.LeaveTangentWeight = 0x18 // float (Size: 0x4)
Rig.TransformBases = 0x30 // TArray<FTransformBase> (Size: 0x10)
Rig.Nodes = 0x40 // TArray<FNode> (Size: 0x10)
RigConfiguration.Rig = 0x0 // Rig* (Size: 0x8)
RigConfiguration.BoneMappingTable = 0x8 // TArray<FNameMapping> (Size: 0x10)
RigTransformConstraint.TranformType = 0x0 // uint8_t (Size: 0x1)
RigTransformConstraint.ParentSpace = 0x4 // FName (Size: 0x8)
RigTransformConstraint.Weight = 0xc // float (Size: 0x4)
RigidBodyContactInfo.ContactPosition = 0x0 // FVector (Size: 0xc)
RigidBodyContactInfo.ContactNormal = 0xc // FVector (Size: 0xc)
RigidBodyContactInfo.ContactPenetration = 0x18 // float (Size: 0x4)
RigidBodyContactInfo.PhysMaterial = 0x20 // PhysicalMaterial* (Size: 0x8)
RigidBodyErrorCorrection.PingExtrapolation = 0x0 // float (Size: 0x4)
RigidBodyErrorCorrection.PingLimit = 0x4 // float (Size: 0x4)
RigidBodyErrorCorrection.ErrorPerLinearDifference = 0x8 // float (Size: 0x4)
RigidBodyErrorCorrection.ErrorPerAngularDifference = 0xc // float (Size: 0x4)
RigidBodyErrorCorrection.MaxRestoredStateError = 0x10 // float (Size: 0x4)
RigidBodyErrorCorrection.MaxLinearHardSnapDistance = 0x14 // float (Size: 0x4)
RigidBodyErrorCorrection.PositionLerp = 0x18 // float (Size: 0x4)
RigidBodyErrorCorrection.AngleLerp = 0x1c // float (Size: 0x4)
RigidBodyErrorCorrection.LinearVelocityCoefficient = 0x20 // float (Size: 0x4)
RigidBodyErrorCorrection.AngularVelocityCoefficient = 0x24 // float (Size: 0x4)
RigidBodyErrorCorrection.ErrorAccumulationSeconds = 0x28 // float (Size: 0x4)
RigidBodyErrorCorrection.ErrorAccumulationDistanceSq = 0x2c // float (Size: 0x4)
RigidBodyErrorCorrection.ErrorAccumulationSimilarity = 0x30 // float (Size: 0x4)
RigidBodyState.position = 0x0 // FVector_NetQuantize100 (Size: 0xc)
RigidBodyState.Quaternion = 0x10 // FQuat (Size: 0x10)
RigidBodyState.LinVel = 0x20 // FVector_NetQuantize100 (Size: 0xc)
RigidBodyState.AngVel = 0x2c // FVector_NetQuantize100 (Size: 0xc)
RigidBodyState.Flags = 0x38 // uint8_t (Size: 0x1)
RigidBodyState.Timestamp = 0x3c // float (Size: 0x4)
RollbackNetStartupActorInfo.Archetype = 0x8 // Object* (Size: 0x8)
RollbackNetStartupActorInfo.Level = 0x38 // Level* (Size: 0x8)
RollbackNetStartupActorInfo.ObjReferences = 0xa0 // TArray<Object*> (Size: 0x10)
RootMotionExtractionStep.AnimSequence = 0x0 // AnimSequence* (Size: 0x8)
RootMotionExtractionStep.StartPosition = 0x8 // float (Size: 0x4)
RootMotionExtractionStep.EndPosition = 0xc // float (Size: 0x4)
RootMotionFinishVelocitySettings.Mode = 0x0 // EERootMotionFinishVelocityMode (Size: 0x1)
RootMotionFinishVelocitySettings.SetVelocity = 0x4 // FVector (Size: 0xc)
RootMotionFinishVelocitySettings.ClampVelocity = 0x10 // float (Size: 0x4)
RootMotionMovementParams.bHasRootMotion = 0x0 // bool (Size: 0x1)
RootMotionMovementParams.BlendWeight = 0x4 // float (Size: 0x4)
RootMotionMovementParams.RootMotionTransform = 0x10 // FTransform (Size: 0x30)
RootMotionSource.Priority = 0x10 // uint16_t (Size: 0x2)
RootMotionSource.LocalID = 0x12 // uint16_t (Size: 0x2)
RootMotionSource.AccumulateMode = 0x14 // EERootMotionAccumulateMode (Size: 0x1)
RootMotionSource.InstanceName = 0x18 // FName (Size: 0x8)
RootMotionSource.StartTime = 0x20 // float (Size: 0x4)
RootMotionSource.CurrentTime = 0x24 // float (Size: 0x4)
RootMotionSource.PreviousTime = 0x28 // float (Size: 0x4)
RootMotionSource.Duration = 0x2c // float (Size: 0x4)
RootMotionSource.status = 0x30 // FRootMotionSourceStatus (Size: 0x1)
RootMotionSource.Settings = 0x31 // FRootMotionSourceSettings (Size: 0x1)
RootMotionSource.bInLocalSpace = 0x32 // bool (Size: 0x1)
RootMotionSource.RootMotionParams = 0x40 // FRootMotionMovementParams (Size: 0x40)
RootMotionSource.FinishVelocityParams = 0x80 // FRootMotionFinishVelocitySettings (Size: 0x14)
RootMotionSourceGroup.bHasAdditiveSources = 0x28 // uint8_t (Size: 0x1)
RootMotionSourceGroup.bHasOverrideSources = 0x28 // uint8_t (Size: 0x1)
RootMotionSourceGroup.bHasOverrideSourcesWithIgnoreZAccumulate = 0x28 // uint8_t (Size: 0x1)
RootMotionSourceGroup.bIsAdditiveVelocityApplied = 0x28 // uint8_t (Size: 0x1)
RootMotionSourceGroup.LastAccumulatedSettings = 0x29 // FRootMotionSourceSettings (Size: 0x1)
RootMotionSourceGroup.LastPreAdditiveVelocity = 0x2c // FVector_NetQuantize10 (Size: 0xc)
RootMotionSourceSettings.Flags = 0x0 // uint8_t (Size: 0x1)
RootMotionSourceStatus.Flags = 0x0 // uint8_t (Size: 0x1)
RootMotionSource_ConstantForce.Force = 0x98 // FVector (Size: 0xc)
RootMotionSource_ConstantForce.StrengthOverTime = 0xa8 // CurveFloat* (Size: 0x8)
RootMotionSource_JumpForce.Rotation = 0x98 // FRotator (Size: 0xc)
RootMotionSource_JumpForce.Distance = 0xa4 // float (Size: 0x4)
RootMotionSource_JumpForce.Height = 0xa8 // float (Size: 0x4)
RootMotionSource_JumpForce.bDisableTimeout = 0xac // bool (Size: 0x1)
RootMotionSource_JumpForce.PathOffsetCurve = 0xb0 // CurveVector* (Size: 0x8)
RootMotionSource_JumpForce.TimeMappingCurve = 0xb8 // CurveFloat* (Size: 0x8)
RootMotionSource_MoveToDynamicForce.StartLocation = 0x98 // FVector (Size: 0xc)
RootMotionSource_MoveToDynamicForce.InitialTargetLocation = 0xa4 // FVector (Size: 0xc)
RootMotionSource_MoveToDynamicForce.TargetLocation = 0xb0 // FVector (Size: 0xc)
RootMotionSource_MoveToDynamicForce.bRestrictSpeedToExpected = 0xbc // bool (Size: 0x1)
RootMotionSource_MoveToDynamicForce.PathOffsetCurve = 0xc0 // CurveVector* (Size: 0x8)
RootMotionSource_MoveToDynamicForce.TimeMappingCurve = 0xc8 // CurveFloat* (Size: 0x8)
RootMotionSource_MoveToForce.StartLocation = 0x98 // FVector (Size: 0xc)
RootMotionSource_MoveToForce.TargetLocation = 0xa4 // FVector (Size: 0xc)
RootMotionSource_MoveToForce.bRestrictSpeedToExpected = 0xb0 // bool (Size: 0x1)
RootMotionSource_MoveToForce.PathOffsetCurve = 0xb8 // CurveVector* (Size: 0x8)
RootMotionSource_RadialForce.Location = 0x98 // FVector (Size: 0xc)
RootMotionSource_RadialForce.LocationActor = 0xa8 // Actor* (Size: 0x8)
RootMotionSource_RadialForce.Radius = 0xb0 // float (Size: 0x4)
RootMotionSource_RadialForce.Strength = 0xb4 // float (Size: 0x4)
RootMotionSource_RadialForce.bIsPush = 0xb8 // bool (Size: 0x1)
RootMotionSource_RadialForce.bNoZForce = 0xb9 // bool (Size: 0x1)
RootMotionSource_RadialForce.StrengthDistanceFalloff = 0xc0 // CurveFloat* (Size: 0x8)
RootMotionSource_RadialForce.StrengthOverTime = 0xc8 // CurveFloat* (Size: 0x8)
RootMotionSource_RadialForce.bUseFixedWorldDirection = 0xd0 // bool (Size: 0x1)
RootMotionSource_RadialForce.FixedWorldDirection = 0xd4 // FRotator (Size: 0xc)
RotatingMovementComponent.RotationRate = 0x138 // FRotator (Size: 0xc)
RotatingMovementComponent.PivotTranslation = 0x144 // FVector (Size: 0xc)
RotatingMovementComponent.bRotationInLocalSpace = 0x150 // uint8_t (Size: 0x1)
RotationTrack.RotKeys = 0x0 // TArray<FQuat> (Size: 0x10)
RotationTrack.Times = 0x10 // TArray<float> (Size: 0x10)
RuntimeCurveLinearColor.ColorCurves = 0x0 // FRichCurve (Size: 0x80)
RuntimeCurveLinearColor.ExternalCurve = 0x200 // CurveLinearColor* (Size: 0x8)
RuntimeFloatCurve.EditorCurveData = 0x0 // FRichCurve (Size: 0x80)
RuntimeFloatCurve.ExternalCurve = 0x80 // CurveFloat* (Size: 0x8)
RuntimeVirtualTexture.TileCount = 0x28 // int32_t (Size: 0x4)
RuntimeVirtualTexture.TileSize = 0x2c // int32_t (Size: 0x4)
RuntimeVirtualTexture.TileBorderSize = 0x30 // int32_t (Size: 0x4)
RuntimeVirtualTexture.TexturePoolSize = 0x34 // int32_t (Size: 0x4)
RuntimeVirtualTexture.WorldHeightLayerScale = 0x38 // float (Size: 0x4)
RuntimeVirtualTexture.MaterialType = 0x3c // EERuntimeVirtualTextureMaterialType (Size: 0x1)
RuntimeVirtualTexture.bCompressTextures = 0x3d // bool (Size: 0x1)
RuntimeVirtualTexture.bClearTextures = 0x3e // bool (Size: 0x1)
RuntimeVirtualTexture.bSinglePhysicalSpace = 0x3f // bool (Size: 0x1)
RuntimeVirtualTexture.bPrivateSpace = 0x40 // bool (Size: 0x1)
RuntimeVirtualTexture.bAdaptive = 0x41 // bool (Size: 0x1)
RuntimeVirtualTexture.bContinuousUpdate = 0x42 // bool (Size: 0x1)
RuntimeVirtualTexture.RemoveLowMips = 0x44 // int32_t (Size: 0x4)
RuntimeVirtualTexture.LODGroup = 0x48 // uint8_t (Size: 0x1)
RuntimeVirtualTexture.Size = 0x4c // int32_t (Size: 0x4)
RuntimeVirtualTexture.StreamingTexture = 0x50 // RuntimeVirtualTextureStreamingProxy* (Size: 0x8)
RuntimeVirtualTextureComponent.BoundsAlignActor = 0x238 // TSoftObjectPtr<UObject> (Size: 0x28)
RuntimeVirtualTextureComponent.bSetBoundsButton = 0x260 // bool (Size: 0x1)
RuntimeVirtualTextureComponent.bSnapBoundsToLandscape = 0x261 // bool (Size: 0x1)
RuntimeVirtualTextureComponent.VirtualTexture = 0x268 // RuntimeVirtualTexture* (Size: 0x8)
RuntimeVirtualTextureComponent.bEnableScalability = 0x270 // bool (Size: 0x1)
RuntimeVirtualTextureComponent.ScalabilityGroup = 0x274 // uint32_t (Size: 0x4)
RuntimeVirtualTextureComponent.bHidePrimitives = 0x278 // bool (Size: 0x1)
RuntimeVirtualTextureComponent.StreamingTexture = 0x280 // VirtualTextureBuilder* (Size: 0x8)
RuntimeVirtualTextureComponent.StreamLowMips = 0x288 // int32_t (Size: 0x4)
RuntimeVirtualTextureComponent.bBuildStreamingMipsButton = 0x28c // bool (Size: 0x1)
RuntimeVirtualTextureComponent.bEnableCompressCrunch = 0x28d // bool (Size: 0x1)
RuntimeVirtualTextureComponent.bUseStreamingLowMipsInEditor = 0x28e // bool (Size: 0x1)
RuntimeVirtualTextureComponent.bBuildDebugStreamingMips = 0x28f // bool (Size: 0x1)
RuntimeVirtualTextureParameterValue.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
RuntimeVirtualTextureParameterValue.ParameterValue = 0x10 // RuntimeVirtualTexture* (Size: 0x8)
RuntimeVirtualTextureParameterValue.ExpressionGUID = 0x18 // FGuid (Size: 0x10)
RuntimeVirtualTextureVolume.VirtualTextureComponent = 0x310 // RuntimeVirtualTextureComponent* (Size: 0x8)
SCS_Node.ComponentClass = 0x28 // ClassProperty (Size: 0x8)
SCS_Node.ComponentTemplate = 0x30 // ActorComponent* (Size: 0x8)
SCS_Node.CookedComponentInstancingData = 0x38 // FBlueprintCookedComponentInstancingData (Size: 0x48)
SCS_Node.AttachToName = 0x80 // FName (Size: 0x8)
SCS_Node.ParentComponentOrVariableName = 0x88 // FName (Size: 0x8)
SCS_Node.ParentComponentOwnerClassName = 0x90 // FName (Size: 0x8)
SCS_Node.bIsParentComponentNative = 0x98 // bool (Size: 0x1)
SCS_Node.ChildNodes = 0xa0 // TArray<SCS_Node*> (Size: 0x10)
SCS_Node.MetaDataArray = 0xb0 // TArray<FBPVariableMetaDataEntry> (Size: 0x10)
SCS_Node.VariableGuid = 0xc0 // FGuid (Size: 0x10)
SCS_Node.InternalVariableName = 0xd0 // FName (Size: 0x8)
ScalarParameterAtlasInstanceData.bIsUsedAsAtlasPosition = 0x0 // bool (Size: 0x1)
ScalarParameterAtlasInstanceData.Curve = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
ScalarParameterAtlasInstanceData.Atlas = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
ScalarParameterValue.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
ScalarParameterValue.ParameterValue = 0x10 // float (Size: 0x4)
ScalarParameterValue.ExpressionGUID = 0x14 // FGuid (Size: 0x10)
ScaleTrack.ScaleKeys = 0x0 // TArray<FVector> (Size: 0x10)
ScaleTrack.Times = 0x10 // TArray<float> (Size: 0x10)
SceneCapture.MeshComp = 0x310 // StaticMeshComponent* (Size: 0x8)
SceneCapture.SceneComponent = 0x318 // SceneComponent* (Size: 0x8)
SceneCapture2D.CaptureComponent2D = 0x320 // SceneCaptureComponent2D* (Size: 0x8)
SceneCaptureComponent.PrimitiveRenderMode = 0x238 // EESceneCapturePrimitiveRenderMode (Size: 0x1)
SceneCaptureComponent.CaptureSource = 0x239 // uint8_t (Size: 0x1)
SceneCaptureComponent.bCaptureEveryFrame = 0x23a // uint8_t (Size: 0x1)
SceneCaptureComponent.bEnableFXAA = 0x23a // uint8_t (Size: 0x1)
SceneCaptureComponent.bEnableSSAA = 0x23a // uint8_t (Size: 0x1)
SceneCaptureComponent.bEnableTAA = 0x23a // uint8_t (Size: 0x1)
SceneCaptureComponent.bCaptureOnMovement = 0x23a // uint8_t (Size: 0x1)
SceneCaptureComponent.bAlwaysPersistRenderingState = 0x23b // bool (Size: 0x1)
SceneCaptureComponent.SkyLightComponent = 0x240 // SkyLightComponent* (Size: 0x8)
SceneCaptureComponent.bIsSpecialScopeView = 0x248 // uint8_t (Size: 0x1)
SceneCaptureComponent.bForceNoDistanceField = 0x248 // uint8_t (Size: 0x1)
SceneCaptureComponent.HiddenComponents = 0x250 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SceneCaptureComponent.HiddenActors = 0x260 // TArray<Actor*> (Size: 0x10)
SceneCaptureComponent.ShowOnlyComponents = 0x270 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SceneCaptureComponent.ShowOnlyActors = 0x280 // TArray<Actor*> (Size: 0x10)
SceneCaptureComponent.LODDistanceFactor = 0x290 // float (Size: 0x4)
SceneCaptureComponent.MaxViewDistanceOverride = 0x294 // float (Size: 0x4)
SceneCaptureComponent.CaptureSortPriority = 0x298 // int32_t (Size: 0x4)
SceneCaptureComponent.bUseRayTracingIfEnabled = 0x29c // bool (Size: 0x1)
SceneCaptureComponent.bEnableDirectionalLights = 0x29d // bool (Size: 0x1)
SceneCaptureComponent.ShowFlagSettings = 0x2a0 // TArray<FEngineShowFlagsSetting> (Size: 0x10)
SceneCaptureComponent.ProfilingEventName = 0x2f8 // FString (Size: 0x10)
SceneCaptureComponent2D.ProjectionType = 0x318 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.FOVAngle = 0x31c // float (Size: 0x4)
SceneCaptureComponent2D.OrthoWidth = 0x320 // float (Size: 0x4)
SceneCaptureComponent2D.TextureTarget = 0x328 // TextureRenderTarget2D* (Size: 0x8)
SceneCaptureComponent2D.CompositeMode = 0x330 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.PostProcessSettings = 0x340 // FPostProcessSettings (Size: 0x690)
SceneCaptureComponent2D.bPostProcessSettingsBlendWithWorldPPV = 0x9d0 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.PostProcessBlendWeight = 0x9d4 // float (Size: 0x4)
SceneCaptureComponent2D.bOverride_CustomNearClippingPlane = 0x9d8 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.CustomNearClippingPlane = 0x9dc // float (Size: 0x4)
SceneCaptureComponent2D.bUseCustomProjectionMatrix = 0x9e0 // bool (Size: 0x1)
SceneCaptureComponent2D.CustomProjectionMatrix = 0x9f0 // FMatrix (Size: 0x40)
SceneCaptureComponent2D.bEnableClipPlane = 0xa30 // bool (Size: 0x1)
SceneCaptureComponent2D.ClipPlaneBase = 0xa34 // FVector (Size: 0xc)
SceneCaptureComponent2D.ClipPlaneNormal = 0xa40 // FVector (Size: 0xc)
SceneCaptureComponent2D.bForceDisableMobileMSAA = 0xa4c // bool (Size: 0x1)
SceneCaptureComponent2D.bCameraCutThisFrame = 0xa50 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.bConsiderUnrenderedOpaquePixelAsFullyTranslucent = 0xa50 // uint8_t (Size: 0x1)
SceneCaptureComponent2D.bDisableFlipCopyGLES = 0xa54 // bool (Size: 0x1)
SceneCaptureComponentCube.TextureTarget = 0x318 // TextureRenderTargetCube* (Size: 0x8)
SceneCaptureComponentCube.bCaptureRotation = 0x320 // bool (Size: 0x1)
SceneCaptureComponentCube.TextureTargetLeft = 0x328 // TextureRenderTargetCube* (Size: 0x8)
SceneCaptureComponentCube.TextureTargetRight = 0x330 // TextureRenderTargetCube* (Size: 0x8)
SceneCaptureComponentCube.TextureTargetODS = 0x338 // TextureRenderTarget2D* (Size: 0x8)
SceneCaptureComponentCube.IPD = 0x340 // float (Size: 0x4)
SceneCaptureCube.CaptureComponentCube = 0x320 // SceneCaptureComponentCube* (Size: 0x8)
SceneComponent.PhysicsVolume = 0x100 // TWeakObjectPtr<UObject> (Size: 0x8)
SceneComponent.AttachParent = 0x108 // SceneComponent* (Size: 0x8)
SceneComponent.AttachSocketName = 0x110 // FName (Size: 0x8)
SceneComponent.AttachChildren = 0x118 // TArray<SceneComponent*> (Size: 0x10)
SceneComponent.ClientAttachedChildren = 0x128 // TArray<SceneComponent*> (Size: 0x10)
SceneComponent.RelativeLocation = 0x16c // FVector (Size: 0xc)
SceneComponent.RelativeRotation = 0x178 // FRotator (Size: 0xc)
SceneComponent.RelativeScale3D = 0x184 // FVector (Size: 0xc)
SceneComponent.ComponentVelocity = 0x190 // FVector (Size: 0xc)
SceneComponent.bComponentToWorldUpdated = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bAbsoluteLocation = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bAbsoluteRotation = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bAbsoluteScale = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bVisible = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bShouldBeAttached = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bShouldSnapLocationWhenAttached = 0x19c // uint8_t (Size: 0x1)
SceneComponent.bShouldSnapRotationWhenAttached = 0x19d // uint8_t (Size: 0x1)
SceneComponent.bShouldUpdatePhysicsVolume = 0x19d // uint8_t (Size: 0x1)
SceneComponent.bHiddenInGame = 0x19d // uint8_t (Size: 0x1)
SceneComponent.bBoundsChangeTriggersStreamingDataRebuild = 0x19d // uint8_t (Size: 0x1)
SceneComponent.bUseAttachParentBound = 0x19d // uint8_t (Size: 0x1)
SceneComponent.Mobility = 0x19f // uint8_t (Size: 0x1)
SceneComponent.DetailMode = 0x1a0 // uint8_t (Size: 0x1)
SceneComponent.PhysicsVolumeChangedDelegate = 0x1a1 // FMulticastSparseDelegate (Size: 0x1)
SceneComponent.bEnableCompDeferUpdateOverlapWhenEndScopeMove = 0x234 // uint8_t (Size: 0x1)
SceneComponentInstanceData.AttachedInstanceComponents = 0x68 // TMap<...> (Size: 0x50)
SceneSOCSettings.bUseLandscapeAsOccluder = 0x0 // bool (Size: 0x1)
SceneSOCSettings.bUseMeshAsOccluder = 0x1 // bool (Size: 0x1)
SceneSOCVolume.Settings = 0x348 // FSceneSOCSettings (Size: 0x2)
ScreenMessageString.Key = 0x0 // uint64_t (Size: 0x8)
ScreenMessageString.ScreenMessage = 0x8 // FString (Size: 0x10)
ScreenMessageString.DisplayColor = 0x18 // FColor (Size: 0x4)
ScreenMessageString.TimeToDisplay = 0x1c // float (Size: 0x4)
ScreenMessageString.CurrentTimeDisplayed = 0x20 // float (Size: 0x4)
ScreenMessageString.TextScale = 0x24 // FVector2D (Size: 0x8)
ServerStatReplicator.bUpdateStatNet = 0x310 // bool (Size: 0x1)
ServerStatReplicator.bOverwriteClientStats = 0x311 // bool (Size: 0x1)
ServerStatReplicator.Channels = 0x314 // uint32_t (Size: 0x4)
ServerStatReplicator.InRate = 0x318 // uint32_t (Size: 0x4)
ServerStatReplicator.OutRate = 0x31c // uint32_t (Size: 0x4)
ServerStatReplicator.MaxPacketOverhead = 0x324 // uint32_t (Size: 0x4)
ServerStatReplicator.InRateClientMax = 0x328 // uint32_t (Size: 0x4)
ServerStatReplicator.InRateClientMin = 0x32c // uint32_t (Size: 0x4)
ServerStatReplicator.InRateClientAvg = 0x330 // uint32_t (Size: 0x4)
ServerStatReplicator.InPacketsClientMax = 0x334 // uint32_t (Size: 0x4)
ServerStatReplicator.InPacketsClientMin = 0x338 // uint32_t (Size: 0x4)
ServerStatReplicator.InPacketsClientAvg = 0x33c // uint32_t (Size: 0x4)
ServerStatReplicator.OutRateClientMax = 0x340 // uint32_t (Size: 0x4)
ServerStatReplicator.OutRateClientMin = 0x344 // uint32_t (Size: 0x4)
ServerStatReplicator.OutRateClientAvg = 0x348 // uint32_t (Size: 0x4)
ServerStatReplicator.OutPacketsClientMax = 0x34c // uint32_t (Size: 0x4)
ServerStatReplicator.OutPacketsClientMin = 0x350 // uint32_t (Size: 0x4)
ServerStatReplicator.OutPacketsClientAvg = 0x354 // uint32_t (Size: 0x4)
ServerStatReplicator.NetNumClients = 0x358 // uint32_t (Size: 0x4)
ServerStatReplicator.InPackets = 0x35c // uint32_t (Size: 0x4)
ServerStatReplicator.OutPackets = 0x360 // uint32_t (Size: 0x4)
ServerStatReplicator.InBunches = 0x364 // uint32_t (Size: 0x4)
ServerStatReplicator.OutBunches = 0x368 // uint32_t (Size: 0x4)
ServerStatReplicator.OutLoss = 0x36c // uint32_t (Size: 0x4)
ServerStatReplicator.InLoss = 0x370 // uint32_t (Size: 0x4)
ServerStatReplicator.VoiceBytesSent = 0x374 // uint32_t (Size: 0x4)
ServerStatReplicator.VoiceBytesRecv = 0x378 // uint32_t (Size: 0x4)
ServerStatReplicator.VoicePacketsSent = 0x37c // uint32_t (Size: 0x4)
ServerStatReplicator.VoicePacketsRecv = 0x380 // uint32_t (Size: 0x4)
ServerStatReplicator.PercentInVoice = 0x384 // uint32_t (Size: 0x4)
ServerStatReplicator.PercentOutVoice = 0x388 // uint32_t (Size: 0x4)
ServerStatReplicator.NumActorChannels = 0x38c // uint32_t (Size: 0x4)
ServerStatReplicator.NumConsideredActors = 0x390 // uint32_t (Size: 0x4)
ServerStatReplicator.PrioritizedActors = 0x394 // uint32_t (Size: 0x4)
ServerStatReplicator.NumRelevantActors = 0x398 // uint32_t (Size: 0x4)
ServerStatReplicator.NumRelevantDeletedActors = 0x39c // uint32_t (Size: 0x4)
ServerStatReplicator.NumReplicatedActorAttempts = 0x3a0 // uint32_t (Size: 0x4)
ServerStatReplicator.NumReplicatedActors = 0x3a4 // uint32_t (Size: 0x4)
ServerStatReplicator.NumActors = 0x3a8 // uint32_t (Size: 0x4)
ServerStatReplicator.NumNetActors = 0x3ac // uint32_t (Size: 0x4)
ServerStatReplicator.NumDormantActors = 0x3b0 // uint32_t (Size: 0x4)
ServerStatReplicator.NumInitiallyDormantActors = 0x3b4 // uint32_t (Size: 0x4)
ServerStatReplicator.NumNetGUIDsAckd = 0x3b8 // uint32_t (Size: 0x4)
ServerStatReplicator.NumNetGUIDsPending = 0x3bc // uint32_t (Size: 0x4)
ServerStatReplicator.NumNetGUIDsUnAckd = 0x3c0 // uint32_t (Size: 0x4)
ServerStatReplicator.ObjPathBytes = 0x3c4 // uint32_t (Size: 0x4)
ServerStatReplicator.NetGUIDOutRate = 0x3c8 // uint32_t (Size: 0x4)
ServerStatReplicator.NetGUIDInRate = 0x3cc // uint32_t (Size: 0x4)
ServerStatReplicator.NetSaturated = 0x3d0 // uint32_t (Size: 0x4)
ShadowCapture.Component = 0x310 // ShadowCaptureComponent* (Size: 0x8)
ShadowCaptureComponent.CaptureLayerMask = 0x238 // uint32_t (Size: 0x4)
ShadowCaptureComponent.RenderTarget = 0x240 // TextureRenderTargetDepth* (Size: 0x8)
ShadowCaptureComponent.bCaptureEveryFrame = 0x248 // bool (Size: 0x1)
ShadowCaptureComponent.bStaticOnly = 0x249 // bool (Size: 0x1)
ShadowCaptureComponent.bUsePreFilter = 0x24a // bool (Size: 0x1)
ShadowCaptureComponent.PreFilterBlur = 0x24c // float (Size: 0x4)
ShadowCaptureComponent.CaptureExtent = 0x250 // float (Size: 0x4)
ShadowCaptureComponent.CaptureMaxDepth = 0x254 // float (Size: 0x4)
ShadowCaptureComponent.ShadowBias = 0x258 // float (Size: 0x4)
ShadowCaptureComponent.bCaptureBehind = 0x25c // bool (Size: 0x1)
ShadowCaptureComponent.bEnableCaching = 0x25d // bool (Size: 0x1)
ShadowCaptureComponent.RefreshAreaThreshold = 0x260 // float (Size: 0x4)
ShadowCaptureComponent.RefreshFramesThreshold = 0x264 // int32_t (Size: 0x4)
ShadowCaptureComponent.WorldToShadowMatrix = 0x270 // FMatrix (Size: 0x40)
ShadowCaptureComponent.PreShadowTranslation = 0x2b0 // FVector (Size: 0xc)
ShadowCaptureComponent.TranslatedLightToWorld = 0x2c0 // FMatrix (Size: 0x40)
ShadowCaptureComponent.ForceRefreshFramesCountdown = 0x300 // uint16_t (Size: 0x2)
ShadowCaptureComponent.OnShadowCaptureMatrixUpdated_Dynamic = 0x308 // FMulticastInlineDelegate (Size: 0x10)
ShadowCaptureLayerProfile.LayerNames = 0x38 // TArray<FName> (Size: 0x10)
ShadowMapTexture2D.ShadowmapFlags = 0x118 // uint8_t (Size: 0x1)
ShapeComponent.ShapeBodySetup = 0x5c8 // BodySetup* (Size: 0x8)
ShapeComponent.AreaClass = 0x5d0 // ClassProperty (Size: 0x8)
ShapeComponent.ShapeColor = 0x5d8 // FColor (Size: 0x4)
ShapeComponent.bDrawOnlyIfSelected = 0x5dc // uint8_t (Size: 0x1)
ShapeComponent.bShouldCollideWhenPlacing = 0x5dc // uint8_t (Size: 0x1)
ShapeComponent.bDynamicObstacle = 0x5dc // uint8_t (Size: 0x1)
SimpleConstructionScript.RootNodes = 0x28 // TArray<SCS_Node*> (Size: 0x10)
SimpleConstructionScript.AllNodes = 0x38 // TArray<SCS_Node*> (Size: 0x10)
SimpleConstructionScript.DefaultSceneRootNode = 0x48 // SCS_Node* (Size: 0x8)
SimpleCurve.InterpMode = 0x70 // uint8_t (Size: 0x1)
SimpleCurve.Keys = 0x78 // TArray<FSimpleCurveKey> (Size: 0x10)
SimpleCurveKey.Time = 0x0 // float (Size: 0x4)
SimpleCurveKey.Value = 0x4 // float (Size: 0x4)
SimpleMemberReference.MemberParent = 0x0 // Object* (Size: 0x8)
SimpleMemberReference.MemberName = 0x8 // FName (Size: 0x8)
SimpleMemberReference.MemberGuid = 0x10 // FGuid (Size: 0x10)
SimulatedRootMotionReplicatedMove.Time = 0x0 // float (Size: 0x4)
SimulatedRootMotionReplicatedMove.RootMotion = 0x8 // FRepRootMotionMontage (Size: 0x98)
SingleAnimationPlayData.AnimToPlay = 0x0 // AnimationAsset* (Size: 0x8)
SingleAnimationPlayData.bSavedLooping = 0x8 // uint8_t (Size: 0x1)
SingleAnimationPlayData.bSavedPlaying = 0x8 // uint8_t (Size: 0x1)
SingleAnimationPlayData.SavedPosition = 0xc // float (Size: 0x4)
SingleAnimationPlayData.SavedPlayRate = 0x10 // float (Size: 0x4)
SkelMeshComponentLODInfo.HiddenMaterials = 0x0 // TArray<bool> (Size: 0x10)
SkelMeshSkinWeightInfo.Bones = 0x0 // int32_t (Size: 0x4)
SkelMeshSkinWeightInfo.Weights = 0x30 // uint8_t (Size: 0x1)
SkeletalBodySetup.bSkipScaleFromAnimation = 0x2b8 // bool (Size: 0x1)
SkeletalBodySetup.PhysicalAnimationData = 0x2c0 // TArray<FPhysicalAnimationProfile> (Size: 0x10)
SkeletalMaterial.MaterialInterface = 0x0 // MaterialInterface* (Size: 0x8)
SkeletalMaterial.MaterialSlotName = 0x8 // FName (Size: 0x8)
SkeletalMaterial.UVChannelData = 0x10 // FMeshUVChannelInfo (Size: 0x14)
SkeletalMesh.Skeleton = 0x90 // Skeleton* (Size: 0x8)
SkeletalMesh.ImportedBounds = 0x98 // FBoxSphereBounds (Size: 0x1c)
SkeletalMesh.ExtendedBounds = 0xb4 // FBoxSphereBounds (Size: 0x1c)
SkeletalMesh.PositiveBoundsExtension = 0xd0 // FVector (Size: 0xc)
SkeletalMesh.NegativeBoundsExtension = 0xdc // FVector (Size: 0xc)
SkeletalMesh.Materials = 0xe8 // TArray<FSkeletalMaterial> (Size: 0x10)
SkeletalMesh.SkelMirrorTable = 0xf8 // TArray<FBoneMirrorInfo> (Size: 0x10)
SkeletalMesh.LODInfo = 0x108 // TArray<FSkeletalMeshLODInfo> (Size: 0x10)
SkeletalMesh.MinLOD = 0x168 // FPerPlatformInt (Size: 0x8)
SkeletalMesh.DisableBelowMinLodStripping = 0x170 // FPerPlatformBool (Size: 0x1)
SkeletalMesh.SkelMirrorAxis = 0x171 // uint8_t (Size: 0x1)
SkeletalMesh.SkelMirrorFlipAxis = 0x172 // uint8_t (Size: 0x1)
SkeletalMesh.bUseFullPrecisionUVs = 0x173 // uint8_t (Size: 0x1)
SkeletalMesh.bUseHighPrecisionTangentBasis = 0x173 // uint8_t (Size: 0x1)
SkeletalMesh.bHasBeenSimplified = 0x173 // uint8_t (Size: 0x1)
SkeletalMesh.bHasVertexColors = 0x173 // uint8_t (Size: 0x1)
SkeletalMesh.bEnablePerPolyCollision = 0x173 // uint8_t (Size: 0x1)
SkeletalMesh.BodySetup = 0x178 // BodySetup* (Size: 0x8)
SkeletalMesh.PhysicsAsset = 0x180 // PhysicsAsset* (Size: 0x8)
SkeletalMesh.ShadowPhysicsAsset = 0x188 // PhysicsAsset* (Size: 0x8)
SkeletalMesh.NodeMappingData = 0x190 // TArray<NodeMappingContainer*> (Size: 0x10)
SkeletalMesh.bForceUseCPUMorphTargets = 0x1a0 // bool (Size: 0x1)
SkeletalMesh.OctNormalUVIndex = 0x1a4 // int32_t (Size: 0x4)
SkeletalMesh.MorphTargets = 0x1a8 // TArray<MorphTarget*> (Size: 0x10)
SkeletalMesh.PostProcessAnimBlueprint = 0x330 // ClassProperty (Size: 0x8)
SkeletalMesh.MeshClothingAssets = 0x338 // TArray<ClothingAssetBase*> (Size: 0x10)
SkeletalMesh.SamplingInfo = 0x348 // FSkeletalMeshSamplingInfo (Size: 0x30)
SkeletalMesh.AssetUserData = 0x378 // TArray<AssetUserData*> (Size: 0x10)
SkeletalMesh.Sockets = 0x388 // TArray<SkeletalMeshSocket*> (Size: 0x10)
SkeletalMesh.DisableLowestDetailLevelShadow = 0x3a8 // bool (Size: 0x1)
SkeletalMesh.SkinWeightProfiles = 0x3b0 // TArray<FSkinWeightProfileInfo> (Size: 0x10)
SkeletalMeshActor.bShouldDoAnimNotifies = 0x318 // uint8_t (Size: 0x1)
SkeletalMeshActor.bWakeOnLevelStart = 0x318 // uint8_t (Size: 0x1)
SkeletalMeshActor.SkeletalMeshComponent = 0x320 // SkeletalMeshComponent* (Size: 0x8)
SkeletalMeshActor.ReplicatedMesh = 0x328 // SkeletalMesh* (Size: 0x8)
SkeletalMeshActor.ReplicatedPhysAsset = 0x330 // PhysicsAsset* (Size: 0x8)
SkeletalMeshActor.ReplicatedMaterial0 = 0x338 // MaterialInterface* (Size: 0x8)
SkeletalMeshActor.ReplicatedMaterial1 = 0x340 // MaterialInterface* (Size: 0x8)
SkeletalMeshBuildSettings.bRecomputeNormals = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bRecomputeTangents = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bUseMikkTSpace = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bComputeWeightedNormals = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bRemoveDegenerates = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bUseHighPrecisionTangentBasis = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bUseFullPrecisionUVs = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.bBuildAdjacencyBuffer = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshBuildSettings.ThresholdPosition = 0x4 // float (Size: 0x4)
SkeletalMeshBuildSettings.ThresholdTangentNormal = 0x8 // float (Size: 0x4)
SkeletalMeshBuildSettings.ThresholdUV = 0xc // float (Size: 0x4)
SkeletalMeshBuildSettings.MorphThresholdPosition = 0x10 // float (Size: 0x4)
SkeletalMeshClothBuildParams.TargetAsset = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
SkeletalMeshClothBuildParams.TargetLod = 0x8 // int32_t (Size: 0x4)
SkeletalMeshClothBuildParams.bRemapParameters = 0xc // bool (Size: 0x1)
SkeletalMeshClothBuildParams.AssetName = 0x10 // FString (Size: 0x10)
SkeletalMeshClothBuildParams.LODIndex = 0x20 // int32_t (Size: 0x4)
SkeletalMeshClothBuildParams.SourceSection = 0x24 // int32_t (Size: 0x4)
SkeletalMeshClothBuildParams.bRemoveFromMesh = 0x28 // bool (Size: 0x1)
SkeletalMeshClothBuildParams.PhysicsAsset = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
SkeletalMeshComponent.AnimBlueprintGeneratedClass = 0x848 // ClassProperty (Size: 0x8)
SkeletalMeshComponent.AnimClass = 0x850 // ClassProperty (Size: 0x8)
SkeletalMeshComponent.AnimScriptInstance = 0x858 // AnimInstance* (Size: 0x8)
SkeletalMeshComponent.PostProcessAnimInstance = 0x860 // AnimInstance* (Size: 0x8)
SkeletalMeshComponent.AnimationData = 0x868 // FSingleAnimationPlayData (Size: 0x18)
SkeletalMeshComponent.RootBoneTranslation = 0x890 // FVector (Size: 0xc)
SkeletalMeshComponent.LineCheckBoundsScale = 0x89c // FVector (Size: 0xc)
SkeletalMeshComponent.LinkedInstances = 0x8d8 // TArray<AnimInstance*> (Size: 0x10)
SkeletalMeshComponent.CachedBoneSpaceTransforms = 0x8e8 // TArray<FTransform> (Size: 0x10)
SkeletalMeshComponent.CachedComponentSpaceTransforms = 0x8f8 // TArray<FTransform> (Size: 0x10)
SkeletalMeshComponent.GlobalAnimRateScale = 0xa58 // float (Size: 0x4)
SkeletalMeshComponent.KinematicBonesUpdateType = 0xa5c // uint8_t (Size: 0x1)
SkeletalMeshComponent.PhysicsTransformUpdateMode = 0xa5d // uint8_t (Size: 0x1)
SkeletalMeshComponent.AnimationMode = 0xa5f // uint8_t (Size: 0x1)
SkeletalMeshComponent.bDisablePostProcessBlueprint = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUpdateOverlapsOnAnimationFinalize = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bHasValidBodies = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bBlendPhysics = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bEnablePhysicsOnDedicatedServer = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUpdateMeshWhenKinematic = 0xa61 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUpdateJointsFromAnimation = 0xa62 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bDisableClothSimulation = 0xa62 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bDisableRigidBodyAnimNode = 0xa68 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bAllowAnimCurveEvaluation = 0xa68 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bDisableAnimCurves = 0xa68 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bCollideWithEnvironment = 0xa68 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bCollideWithAttachedChildren = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bLocalSpaceSimulation = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bResetAfterTeleport = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bDeferKinematicBoneUpdate = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bNoSkeletonUpdate = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bPauseAnims = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseRefPoseOnInitAnim = 0xa69 // uint8_t (Size: 0x1)
SkeletalMeshComponent.bEnablePerPolyCollision = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bForceRefpose = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bOnlyAllowAutonomousTickPose = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bIsAutonomousTickPose = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bOldForceRefPose = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bShowPrePhysBones = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bRequiredBonesUpToDate = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bAnimTreeInitialised = 0xa6a // uint8_t (Size: 0x1)
SkeletalMeshComponent.bIncludeComponentLocationIntoBounds = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bEnableLineCheckWithBounds = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseBendingElements = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseTetrahedralConstraints = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseThinShellVolumeConstraints = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseSelfCollisions = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bUseContinuousCollisionDetection = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bPropagateCurvesToSlaves = 0xa6b // uint8_t (Size: 0x1)
SkeletalMeshComponent.bSkipKinematicUpdateWhenInterpolating = 0xa6c // uint8_t (Size: 0x1)
SkeletalMeshComponent.bSkipBoundsUpdateWhenInterpolating = 0xa6c // uint8_t (Size: 0x1)
SkeletalMeshComponent.bNeedsQueuedAnimEventsDispatched = 0xa6c // uint8_t (Size: 0x1)
SkeletalMeshComponent.CachedAnimCurveUidVersion = 0xa6e // uint16_t (Size: 0x2)
SkeletalMeshComponent.MassMode = 0xa70 // EEClothMassMode (Size: 0x1)
SkeletalMeshComponent.UniformMass = 0xa74 // float (Size: 0x4)
SkeletalMeshComponent.TotalMass = 0xa78 // float (Size: 0x4)
SkeletalMeshComponent.Density = 0xa7c // float (Size: 0x4)
SkeletalMeshComponent.MinPerParticleMass = 0xa80 // float (Size: 0x4)
SkeletalMeshComponent.ClothBlendWeight = 0xa84 // float (Size: 0x4)
SkeletalMeshComponent.EdgeStiffness = 0xa88 // float (Size: 0x4)
SkeletalMeshComponent.BendingStiffness = 0xa8c // float (Size: 0x4)
SkeletalMeshComponent.AreaStiffness = 0xa90 // float (Size: 0x4)
SkeletalMeshComponent.VolumeStiffness = 0xa94 // float (Size: 0x4)
SkeletalMeshComponent.StrainLimitingStiffness = 0xa98 // float (Size: 0x4)
SkeletalMeshComponent.ShapeTargetStiffness = 0xa9c // float (Size: 0x4)
SkeletalMeshComponent.bWaitForParallelClothTask = 0xaa0 // bool (Size: 0x1)
SkeletalMeshComponent.DisallowedAnimCurves = 0xaa8 // TArray<FName> (Size: 0x10)
SkeletalMeshComponent.BodySetup = 0xab8 // BodySetup* (Size: 0x8)
SkeletalMeshComponent.OnConstraintBroken = 0xac8 // FMulticastInlineDelegate (Size: 0x10)
SkeletalMeshComponent.ClothingSimulationFactory = 0xad8 // ClassProperty (Size: 0x8)
SkeletalMeshComponent.TeleportDistanceThreShold = 0xbc8 // float (Size: 0x4)
SkeletalMeshComponent.TeleportRotationThreShold = 0xbcc // float (Size: 0x4)
SkeletalMeshComponent.LastPoseTickFrame = 0xbd8 // uint32_t (Size: 0x4)
SkeletalMeshComponent.ClothingInteractor = 0xc30 // ClothingSimulationInteractor* (Size: 0x8)
SkeletalMeshComponent.OnAnimInitialized = 0xd00 // FMulticastInlineDelegate (Size: 0x10)
SkeletalMeshComponent.bEnablePhysicsConstraintDeferredCreate = 0xf60 // bool (Size: 0x1)
SkeletalMeshComponent.bReceiveNotifiesFromMontageInstances = 0xf61 // bool (Size: 0x1)
SkeletalMeshComponent.bEnableUpdateChildTransformsOptimization = 0x10b8 // uint8_t (Size: 0x1)
SkeletalMeshComponent.BoundsChangeThresholdToUpdateChildTransforms = 0x10c0 // float (Size: 0x4)
SkeletalMeshComponent.bEnableTickAnimationOnSkeletalMeshInit = 0x10e4 // bool (Size: 0x1)
SkeletalMeshLODGroupSettings.ScreenSize = 0x0 // FPerPlatformFloat (Size: 0x4)
SkeletalMeshLODGroupSettings.LODHysteresis = 0x4 // float (Size: 0x4)
SkeletalMeshLODGroupSettings.BoneFilterActionOption = 0x8 // EEBoneFilterActionOption (Size: 0x1)
SkeletalMeshLODGroupSettings.BoneList = 0x10 // TArray<FBoneFilter> (Size: 0x10)
SkeletalMeshLODGroupSettings.BonesToPrioritize = 0x20 // TArray<FName> (Size: 0x10)
SkeletalMeshLODGroupSettings.WeightOfPrioritization = 0x30 // float (Size: 0x4)
SkeletalMeshLODGroupSettings.BakePose = 0x38 // AnimSequence* (Size: 0x8)
SkeletalMeshLODGroupSettings.ReductionSettings = 0x40 // FSkeletalMeshOptimizationSettings (Size: 0x3c)
SkeletalMeshLODInfo.ScreenSize = 0x0 // FPerPlatformFloat (Size: 0x4)
SkeletalMeshLODInfo.LODHysteresis = 0x4 // float (Size: 0x4)
SkeletalMeshLODInfo.LODMaterialMap = 0x8 // TArray<int32_t> (Size: 0x10)
SkeletalMeshLODInfo.BuildSettings = 0x18 // FSkeletalMeshBuildSettings (Size: 0x14)
SkeletalMeshLODInfo.ReductionSettings = 0x2c // FSkeletalMeshOptimizationSettings (Size: 0x3c)
SkeletalMeshLODInfo.BonesToRemove = 0x68 // TArray<FBoneReference> (Size: 0x10)
SkeletalMeshLODInfo.BonesToPrioritize = 0x78 // TArray<FBoneReference> (Size: 0x10)
SkeletalMeshLODInfo.WeightOfPrioritization = 0x88 // float (Size: 0x4)
SkeletalMeshLODInfo.BakePose = 0x90 // AnimSequence* (Size: 0x8)
SkeletalMeshLODInfo.BakePoseOverride = 0x98 // AnimSequence* (Size: 0x8)
SkeletalMeshLODInfo.SourceImportFilename = 0xa0 // FString (Size: 0x10)
SkeletalMeshLODInfo.SkinCacheUsage = 0xb0 // EESkinCacheUsage (Size: 0x1)
SkeletalMeshLODInfo.bHasBeenSimplified = 0xb1 // uint8_t (Size: 0x1)
SkeletalMeshLODInfo.bHasPerLODVertexColors = 0xb1 // uint8_t (Size: 0x1)
SkeletalMeshLODInfo.bAllowCPUAccess = 0xb1 // uint8_t (Size: 0x1)
SkeletalMeshLODInfo.bSupportUniformlyDistributedSampling = 0xb1 // uint8_t (Size: 0x1)
SkeletalMeshLODSettings.MinLOD = 0x30 // FPerPlatformInt (Size: 0x8)
SkeletalMeshLODSettings.DisableBelowMinLodStripping = 0x38 // FPerPlatformBool (Size: 0x1)
SkeletalMeshLODSettings.bOverrideLODStreamingSettings = 0x39 // bool (Size: 0x1)
SkeletalMeshLODSettings.bSupportLODStreaming = 0x3a // FPerPlatformBool (Size: 0x1)
SkeletalMeshLODSettings.MaxNumStreamedLODs = 0x3c // FPerPlatformInt (Size: 0x8)
SkeletalMeshLODSettings.MaxNumOptionalLODs = 0x44 // FPerPlatformInt (Size: 0x8)
SkeletalMeshLODSettings.LODGroups = 0x50 // TArray<FSkeletalMeshLODGroupSettings> (Size: 0x10)
SkeletalMeshOptimizationSettings.TerminationCriterion = 0x0 // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.NumOfTrianglesPercentage = 0x4 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.NumOfVertPercentage = 0x8 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.MaxNumOfTriangles = 0xc // uint32_t (Size: 0x4)
SkeletalMeshOptimizationSettings.MaxNumOfVerts = 0x10 // uint32_t (Size: 0x4)
SkeletalMeshOptimizationSettings.MaxDeviationPercentage = 0x14 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.ReductionMethod = 0x18 // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.SilhouetteImportance = 0x19 // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.TextureImportance = 0x1a // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.ShadingImportance = 0x1b // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.SkinningImportance = 0x1c // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.bRemapMorphTargets = 0x1d // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.bRecalcNormals = 0x1d // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.WeldingThreshold = 0x20 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.NormalsThreshold = 0x24 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.MaxBonesPerVertex = 0x28 // int32_t (Size: 0x4)
SkeletalMeshOptimizationSettings.bEnforceBoneBoundaries = 0x2c // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.VolumeImportance = 0x30 // float (Size: 0x4)
SkeletalMeshOptimizationSettings.bLockEdges = 0x34 // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.bLockColorBounaries = 0x34 // uint8_t (Size: 0x1)
SkeletalMeshOptimizationSettings.BaseLOD = 0x38 // int32_t (Size: 0x4)
SkeletalMeshSamplingBuiltData.WholeMeshBuiltData = 0x0 // TArray<FSkeletalMeshSamplingLODBuiltData> (Size: 0x10)
SkeletalMeshSamplingBuiltData.RegionBuiltData = 0x10 // TArray<FSkeletalMeshSamplingRegionBuiltData> (Size: 0x10)
SkeletalMeshSamplingInfo.Regions = 0x0 // TArray<FSkeletalMeshSamplingRegion> (Size: 0x10)
SkeletalMeshSamplingInfo.BuiltData = 0x10 // FSkeletalMeshSamplingBuiltData (Size: 0x20)
SkeletalMeshSamplingRegion.Name = 0x0 // FName (Size: 0x8)
SkeletalMeshSamplingRegion.LODIndex = 0x8 // int32_t (Size: 0x4)
SkeletalMeshSamplingRegion.bSupportUniformlyDistributedSampling = 0xc // uint8_t (Size: 0x1)
SkeletalMeshSamplingRegion.MaterialFilters = 0x10 // TArray<FSkeletalMeshSamplingRegionMaterialFilter> (Size: 0x10)
SkeletalMeshSamplingRegion.BoneFilters = 0x20 // TArray<FSkeletalMeshSamplingRegionBoneFilter> (Size: 0x10)
SkeletalMeshSamplingRegionBoneFilter.BoneName = 0x0 // FName (Size: 0x8)
SkeletalMeshSamplingRegionBoneFilter.bIncludeOrExclude = 0x8 // uint8_t (Size: 0x1)
SkeletalMeshSamplingRegionBoneFilter.bApplyToChildren = 0x8 // uint8_t (Size: 0x1)
SkeletalMeshSamplingRegionMaterialFilter.MaterialName = 0x0 // FName (Size: 0x8)
SkeletalMeshSimplificationSettings.SkeletalMeshReductionModuleName = 0x38 // FName (Size: 0x8)
SkeletalMeshSocket.SocketName = 0x28 // FName (Size: 0x8)
SkeletalMeshSocket.BoneName = 0x30 // FName (Size: 0x8)
SkeletalMeshSocket.RelativeLocation = 0x38 // FVector (Size: 0xc)
SkeletalMeshSocket.RelativeRotation = 0x44 // FRotator (Size: 0xc)
SkeletalMeshSocket.RelativeScale = 0x50 // FVector (Size: 0xc)
SkeletalMeshSocket.bForceAlwaysAnimated = 0x5c // bool (Size: 0x1)
Skeleton.BoneTree = 0x38 // TArray<FBoneNode> (Size: 0x10)
Skeleton.RefLocalPoses = 0x48 // TArray<FTransform> (Size: 0x10)
Skeleton.VirtualBoneGuid = 0x170 // FGuid (Size: 0x10)
Skeleton.VirtualBones = 0x180 // TArray<FVirtualBone> (Size: 0x10)
Skeleton.Sockets = 0x190 // TArray<SkeletalMeshSocket*> (Size: 0x10)
Skeleton.SmartNames = 0x1f0 // FSmartNameContainer (Size: 0x50)
Skeleton.BlendProfiles = 0x270 // TArray<BlendProfile*> (Size: 0x10)
Skeleton.SlotGroups = 0x280 // TArray<FAnimSlotGroup> (Size: 0x10)
Skeleton.AssetUserData = 0x358 // TArray<AssetUserData*> (Size: 0x10)
SkeletonToMeshLinkup.SkeletonToMeshTable = 0x0 // TArray<int32_t> (Size: 0x10)
SkeletonToMeshLinkup.MeshToSkeletonTable = 0x10 // TArray<int32_t> (Size: 0x10)
SkinWeightProfileInfo.Name = 0x0 // FName (Size: 0x8)
SkinWeightProfileInfo.DefaultProfile = 0x8 // FPerPlatformBool (Size: 0x1)
SkinWeightProfileInfo.DefaultProfileFromLODIndex = 0xc // FPerPlatformInt (Size: 0x8)
SkinnedMeshComponent.SkeletalMesh = 0x608 // SkeletalMesh* (Size: 0x8)
SkinnedMeshComponent.MasterPoseComponent = 0x610 // TWeakObjectPtr<UObject> (Size: 0x8)
SkinnedMeshComponent.SkinCacheUsage = 0x618 // TArray<EESkinCacheUsage> (Size: 0x10)
SkinnedMeshComponent.VertexOffsetUsage = 0x628 // TArray<FVertexOffsetUsage> (Size: 0x10)
SkinnedMeshComponent.PhysicsAssetOverride = 0x730 // PhysicsAsset* (Size: 0x8)
SkinnedMeshComponent.ForcedLodModel = 0x738 // int32_t (Size: 0x4)
SkinnedMeshComponent.MinLodModel = 0x73c // int32_t (Size: 0x4)
SkinnedMeshComponent.StreamingDistanceMultiplier = 0x748 // float (Size: 0x4)
SkinnedMeshComponent.LODInfo = 0x758 // TArray<FSkelMeshComponentLODInfo> (Size: 0x10)
SkinnedMeshComponent.VisibilityBasedAnimTickOption = 0x78c // EEVisibilityBasedAnimTickOption (Size: 0x1)
SkinnedMeshComponent.bOverrideMinLod = 0x79a // uint8_t (Size: 0x1)
SkinnedMeshComponent.bUseBoundsFromMasterPoseComponent = 0x79a // uint8_t (Size: 0x1)
SkinnedMeshComponent.bForceWireframe = 0x79a // uint8_t (Size: 0x1)
SkinnedMeshComponent.bDisplayBones = 0x79a // uint8_t (Size: 0x1)
SkinnedMeshComponent.bDisableMorphTarget = 0x79a // uint8_t (Size: 0x1)
SkinnedMeshComponent.bHideSkin = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bPerBoneMotionBlur = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bComponentUseFixedSkelBounds = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bComponentConsiderChildMeshBounds = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bConsiderAllBodiesForBounds = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bSyncAttachParentLOD = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bCanHighlightSelectedSections = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bRecentlyRendered = 0x79b // uint8_t (Size: 0x1)
SkinnedMeshComponent.bRecentlyRenderedConsiderChildren = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bCastCapsuleDirectShadow = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bCastCapsuleIndirectShadow = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bCPUSkinning = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bEnableUpdateRateOptimizations = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bDisplayDebugUpdateRateOptimizations = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bRenderStatic = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bIgnoreMasterPoseComponentLOD = 0x79c // uint8_t (Size: 0x1)
SkinnedMeshComponent.bCachedLocalBoundsUpToDate = 0x79d // uint8_t (Size: 0x1)
SkinnedMeshComponent.bForceMeshObjectUpdate = 0x79d // uint8_t (Size: 0x1)
SkinnedMeshComponent.CapsuleIndirectShadowMinVisibility = 0x7a0 // float (Size: 0x4)
SkinnedMeshComponent.bForceLODDirty = 0x7b8 // bool (Size: 0x1)
SkinnedMeshComponent.CachedWorldSpaceBounds = 0x7bc // FBoxSphereBounds (Size: 0x1c)
SkinnedMeshComponent.CachedWorldToLocalTransform = 0x7e0 // FMatrix (Size: 0x40)
SkyAtmosphere.SkyAtmosphereComponent = 0x310 // SkyAtmosphereComponent* (Size: 0x8)
SkyAtmosphereComponent.TransformMode = 0x238 // EESkyAtmosphereTransformMode (Size: 0x1)
SkyAtmosphereComponent.BottomRadius = 0x23c // float (Size: 0x4)
SkyAtmosphereComponent.GroundAlbedo = 0x240 // FColor (Size: 0x4)
SkyAtmosphereComponent.GroundAlbedoMultiplier = 0x244 // float (Size: 0x4)
SkyAtmosphereComponent.AtmosphereHeight = 0x248 // float (Size: 0x4)
SkyAtmosphereComponent.MultiScatteringFactor = 0x24c // float (Size: 0x4)
SkyAtmosphereComponent.TraceSampleCountScale = 0x250 // float (Size: 0x4)
SkyAtmosphereComponent.RayleighScatteringScale = 0x254 // float (Size: 0x4)
SkyAtmosphereComponent.RayleighScattering = 0x258 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.RayleighExponentialDistribution = 0x268 // float (Size: 0x4)
SkyAtmosphereComponent.MieScatteringScale = 0x26c // float (Size: 0x4)
SkyAtmosphereComponent.MieScattering = 0x270 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.MieAbsorptionScale = 0x280 // float (Size: 0x4)
SkyAtmosphereComponent.MieAbsorption = 0x284 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.MieAnisotropy = 0x294 // float (Size: 0x4)
SkyAtmosphereComponent.MieExponentialDistribution = 0x298 // float (Size: 0x4)
SkyAtmosphereComponent.FineMieScatteringScale = 0x29c // float (Size: 0x4)
SkyAtmosphereComponent.FineMieScattering = 0x2a0 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.FineMieAnisotropy = 0x2b0 // float (Size: 0x4)
SkyAtmosphereComponent.FineMieTentDistribution = 0x2b4 // FTentDistribution (Size: 0xc)
SkyAtmosphereComponent.OtherAbsorptionScale = 0x2c0 // float (Size: 0x4)
SkyAtmosphereComponent.OtherAbsorption = 0x2c4 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.OtherTentDistribution = 0x2d4 // FTentDistribution (Size: 0xc)
SkyAtmosphereComponent.ExtraSceneLightTransmittance = 0x2e0 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.bColorAsOuterSpaceIlluminance = 0x2f0 // bool (Size: 0x1)
SkyAtmosphereComponent.SkyLuminanceFactor = 0x2f4 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.AerialPespectiveViewDistanceScale = 0x304 // float (Size: 0x4)
SkyAtmosphereComponent.AerialPerspectiveTint = 0x308 // FLinearColor (Size: 0x10)
SkyAtmosphereComponent.AerialPerspectivePhase = 0x318 // float (Size: 0x4)
SkyAtmosphereComponent.HeightFogContribution = 0x31c // float (Size: 0x4)
SkyAtmosphereComponent.TransmittanceMinLightElevationAngle = 0x320 // float (Size: 0x4)
SkyAtmosphereComponent.AerialPerspectiveStartDepth = 0x324 // float (Size: 0x4)
SkyAtmosphereComponent.bStaticLightingBuiltGUID = 0x34c // FGuid (Size: 0x10)
SkyLight.LightComponent = 0x310 // SkyLightComponent* (Size: 0x8)
SkyLight.bEnabled = 0x318 // uint8_t (Size: 0x1)
SkyLightComponent.bRealTimeCapture = 0x278 // bool (Size: 0x1)
SkyLightComponent.SourceType = 0x279 // uint8_t (Size: 0x1)
SkyLightComponent.Cubemap = 0x280 // TextureCube* (Size: 0x8)
SkyLightComponent.PrecomputedData = 0x288 // IBLPrecomputedDataAsset* (Size: 0x8)
SkyLightComponent.SourceCubemapAngle = 0x290 // float (Size: 0x4)
SkyLightComponent.CubemapResolution = 0x294 // int32_t (Size: 0x4)
SkyLightComponent.SkyDistanceThreshold = 0x298 // float (Size: 0x4)
SkyLightComponent.bCaptureEmissiveOnly = 0x29c // bool (Size: 0x1)
SkyLightComponent.bLowerHemisphereIsBlack = 0x29d // bool (Size: 0x1)
SkyLightComponent.LowerHemisphereColor = 0x2a0 // FLinearColor (Size: 0x10)
SkyLightComponent.bProvideDefaultIrradiance = 0x2b0 // bool (Size: 0x1)
SkyLightComponent.OcclusionMaxDistance = 0x2b4 // float (Size: 0x4)
SkyLightComponent.Contrast = 0x2b8 // float (Size: 0x4)
SkyLightComponent.OcclusionExponent = 0x2bc // float (Size: 0x4)
SkyLightComponent.MinOcclusion = 0x2c0 // float (Size: 0x4)
SkyLightComponent.OcclusionTint = 0x2c4 // FColor (Size: 0x4)
SkyLightComponent.StaticIndirectShadowConeAngle = 0x2c8 // float (Size: 0x4)
SkyLightComponent.SkyIndirectShadowMaxConeAngle = 0x2cc // float (Size: 0x4)
SkyLightComponent.SkyIndirectShadowMinConeAngle = 0x2d0 // float (Size: 0x4)
SkyLightComponent.bCloudAmbientOcclusion = 0x2d4 // uint8_t (Size: 0x1)
SkyLightComponent.CloudAmbientOcclusionStrength = 0x2d8 // float (Size: 0x4)
SkyLightComponent.CloudAmbientOcclusionExtent = 0x2dc // float (Size: 0x4)
SkyLightComponent.CloudAmbientOcclusionMapResolutionScale = 0x2e0 // float (Size: 0x4)
SkyLightComponent.CloudAmbientOcclusionApertureScale = 0x2e4 // float (Size: 0x4)
SkyLightComponent.OcclusionCombineMode = 0x2e8 // uint8_t (Size: 0x1)
SkyLightComponent.bUsedForSceneCapture = 0x2e9 // bool (Size: 0x1)
SkyLightComponent.BlendDestinationCubemap = 0x3a8 // TextureCube* (Size: 0x8)
SlateBrushAsset.Brush = 0x28 // FSlateBrush (Size: 0x90)
SlotAnimationTrack.SlotName = 0x0 // FName (Size: 0x8)
SlotAnimationTrack.AnimTrack = 0x8 // FAnimTrack (Size: 0x10)
SlotEvaluationPose.AdditiveType = 0x0 // uint8_t (Size: 0x1)
SlotEvaluationPose.Weight = 0x4 // float (Size: 0x4)
SmartName.DisplayName = 0x0 // FName (Size: 0x8)
SolverIterations.FixedTimeStep = 0x0 // float (Size: 0x4)
SolverIterations.SolverIterations = 0x4 // int32_t (Size: 0x4)
SolverIterations.JointIterations = 0x8 // int32_t (Size: 0x4)
SolverIterations.CollisionIterations = 0xc // int32_t (Size: 0x4)
SolverIterations.SolverPushOutIterations = 0x10 // int32_t (Size: 0x4)
SolverIterations.JointPushOutIterations = 0x14 // int32_t (Size: 0x4)
SolverIterations.CollisionPushOutIterations = 0x18 // int32_t (Size: 0x4)
SoundAttenuation.Attenuation = 0x28 // FSoundAttenuationSettings (Size: 0x3a0)
SoundAttenuationPluginSettings.SpatializationPluginSettingsArray = 0x0 // TArray<SpatializationPluginSourceSettingsBase*> (Size: 0x10)
SoundAttenuationPluginSettings.OcclusionPluginSettingsArray = 0x10 // TArray<OcclusionPluginSourceSettingsBase*> (Size: 0x10)
SoundAttenuationPluginSettings.ReverbPluginSettingsArray = 0x20 // TArray<ReverbPluginSourceSettingsBase*> (Size: 0x10)
SoundAttenuationSettings.bAttenuate = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bSpatialize = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bAttenuateWithLPF = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableListenerFocus = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableFocusInterpolation = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableOcclusion = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bUseComplexCollisionForOcclusion = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableReverbSend = 0xb0 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnablePriorityAttenuation = 0xb1 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bApplyNormalizationToStereoSounds = 0xb1 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableLogFrequencyScaling = 0xb1 // uint8_t (Size: 0x1)
SoundAttenuationSettings.bEnableSubmixSends = 0xb1 // uint8_t (Size: 0x1)
SoundAttenuationSettings.SpatializationAlgorithm = 0xb2 // uint8_t (Size: 0x1)
SoundAttenuationSettings.BinauralRadius = 0xb4 // float (Size: 0x4)
SoundAttenuationSettings.AbsorptionMethod = 0xb8 // EEAirAbsorptionMethod (Size: 0x1)
SoundAttenuationSettings.OcclusionTraceChannel = 0xb9 // uint8_t (Size: 0x1)
SoundAttenuationSettings.ReverbSendMethod = 0xba // EEReverbSendMethod (Size: 0x1)
SoundAttenuationSettings.PriorityAttenuationMethod = 0xbb // EEPriorityAttenuationMethod (Size: 0x1)
SoundAttenuationSettings.OmniRadius = 0xbc // float (Size: 0x4)
SoundAttenuationSettings.StereoSpread = 0xc0 // float (Size: 0x4)
SoundAttenuationSettings.LPFRadiusMin = 0xc4 // float (Size: 0x4)
SoundAttenuationSettings.LPFRadiusMax = 0xc8 // float (Size: 0x4)
SoundAttenuationSettings.CustomLowpassAirAbsorptionCurve = 0xd0 // FRuntimeFloatCurve (Size: 0x88)
SoundAttenuationSettings.CustomHighpassAirAbsorptionCurve = 0x158 // FRuntimeFloatCurve (Size: 0x88)
SoundAttenuationSettings.LPFFrequencyAtMin = 0x1e0 // float (Size: 0x4)
SoundAttenuationSettings.LPFFrequencyAtMax = 0x1e4 // float (Size: 0x4)
SoundAttenuationSettings.HPFFrequencyAtMin = 0x1e8 // float (Size: 0x4)
SoundAttenuationSettings.HPFFrequencyAtMax = 0x1ec // float (Size: 0x4)
SoundAttenuationSettings.FocusAzimuth = 0x1f0 // float (Size: 0x4)
SoundAttenuationSettings.NonFocusAzimuth = 0x1f4 // float (Size: 0x4)
SoundAttenuationSettings.FocusDistanceScale = 0x1f8 // float (Size: 0x4)
SoundAttenuationSettings.NonFocusDistanceScale = 0x1fc // float (Size: 0x4)
SoundAttenuationSettings.FocusPriorityScale = 0x200 // float (Size: 0x4)
SoundAttenuationSettings.NonFocusPriorityScale = 0x204 // float (Size: 0x4)
SoundAttenuationSettings.FocusVolumeAttenuation = 0x208 // float (Size: 0x4)
SoundAttenuationSettings.NonFocusVolumeAttenuation = 0x20c // float (Size: 0x4)
SoundAttenuationSettings.FocusAttackInterpSpeed = 0x210 // float (Size: 0x4)
SoundAttenuationSettings.FocusReleaseInterpSpeed = 0x214 // float (Size: 0x4)
SoundAttenuationSettings.OcclusionLowPassFilterFrequency = 0x218 // float (Size: 0x4)
SoundAttenuationSettings.OcclusionVolumeAttenuation = 0x21c // float (Size: 0x4)
SoundAttenuationSettings.OcclusionInterpolationTime = 0x220 // float (Size: 0x4)
SoundAttenuationSettings.ReverbWetLevelMin = 0x224 // float (Size: 0x4)
SoundAttenuationSettings.ReverbWetLevelMax = 0x228 // float (Size: 0x4)
SoundAttenuationSettings.ReverbDistanceMin = 0x22c // float (Size: 0x4)
SoundAttenuationSettings.ReverbDistanceMax = 0x230 // float (Size: 0x4)
SoundAttenuationSettings.ManualReverbSendLevel = 0x234 // float (Size: 0x4)
SoundAttenuationSettings.CustomReverbSendCurve = 0x238 // FRuntimeFloatCurve (Size: 0x88)
SoundAttenuationSettings.SubmixSendSettings = 0x2c0 // TArray<FAttenuationSubmixSendSettings> (Size: 0x10)
SoundAttenuationSettings.PriorityAttenuationMin = 0x2d0 // float (Size: 0x4)
SoundAttenuationSettings.PriorityAttenuationMax = 0x2d4 // float (Size: 0x4)
SoundAttenuationSettings.PriorityAttenuationDistanceMin = 0x2d8 // float (Size: 0x4)
SoundAttenuationSettings.PriorityAttenuationDistanceMax = 0x2dc // float (Size: 0x4)
SoundAttenuationSettings.ManualPriorityAttenuation = 0x2e0 // float (Size: 0x4)
SoundAttenuationSettings.CustomPriorityAttenuationCurve = 0x2e8 // FRuntimeFloatCurve (Size: 0x88)
SoundAttenuationSettings.PluginSettings = 0x370 // FSoundAttenuationPluginSettings (Size: 0x30)
SoundBase.SoundClassObject = 0x30 // SoundClass* (Size: 0x8)
SoundBase.bDebug = 0x38 // uint8_t (Size: 0x1)
SoundBase.bOverrideConcurrency = 0x38 // uint8_t (Size: 0x1)
SoundBase.bOutputToBusOnly = 0x38 // uint8_t (Size: 0x1)
SoundBase.bHasDelayNode = 0x38 // uint8_t (Size: 0x1)
SoundBase.bHasConcatenatorNode = 0x38 // uint8_t (Size: 0x1)
SoundBase.bBypassVolumeScaleForPriority = 0x38 // uint8_t (Size: 0x1)
SoundBase.VirtualizationMode = 0x39 // EEVirtualizationMode (Size: 0x1)
SoundBase.ConcurrencySet = 0x90 // TSet<...> (Size: 0x50)
SoundBase.ConcurrencyOverrides = 0xe0 // FSoundConcurrencySettings (Size: 0x28)
SoundBase.Duration = 0x108 // float (Size: 0x4)
SoundBase.MaxDistance = 0x10c // float (Size: 0x4)
SoundBase.TotalSamples = 0x110 // float (Size: 0x4)
SoundBase.Priority = 0x114 // float (Size: 0x4)
SoundBase.AttenuationSettings = 0x118 // SoundAttenuation* (Size: 0x8)
SoundBase.ModulationSettings = 0x120 // FSoundModulationDefaultRoutingSettings (Size: 0x48)
SoundBase.SoundSubmixObject = 0x168 // SoundSubmixBase* (Size: 0x8)
SoundBase.SoundSubmixSends = 0x170 // TArray<FSoundSubmixSendInfo> (Size: 0x10)
SoundBase.SourceEffectChain = 0x180 // SoundEffectSourcePresetChain* (Size: 0x8)
SoundBase.BusSends = 0x188 // TArray<FSoundSourceBusSendInfo> (Size: 0x10)
SoundBase.PreEffectBusSends = 0x198 // TArray<FSoundSourceBusSendInfo> (Size: 0x10)
SoundBase.AssetUserData = 0x1a8 // TArray<AssetUserData*> (Size: 0x10)
SoundClass.Properties = 0x28 // FSoundClassProperties (Size: 0x80)
SoundClass.ChildClasses = 0xa8 // TArray<SoundClass*> (Size: 0x10)
SoundClass.PassiveSoundMixModifiers = 0xb8 // TArray<FPassiveSoundMixModifier> (Size: 0x10)
SoundClass.ParentClass = 0xc8 // SoundClass* (Size: 0x8)
SoundClassAdjuster.SoundClassObject = 0x0 // SoundClass* (Size: 0x8)
SoundClassAdjuster.VolumeAdjuster = 0x8 // float (Size: 0x4)
SoundClassAdjuster.PitchAdjuster = 0xc // float (Size: 0x4)
SoundClassAdjuster.LowPassFilterFrequency = 0x10 // float (Size: 0x4)
SoundClassAdjuster.bApplyToChildren = 0x14 // uint8_t (Size: 0x1)
SoundClassAdjuster.VoiceCenterChannelVolumeAdjuster = 0x18 // float (Size: 0x4)
SoundClassProperties.Volume = 0x0 // float (Size: 0x4)
SoundClassProperties.Pitch = 0x4 // float (Size: 0x4)
SoundClassProperties.LowPassFilterFrequency = 0x8 // float (Size: 0x4)
SoundClassProperties.AttenuationDistanceScale = 0xc // float (Size: 0x4)
SoundClassProperties.StereoBleed = 0x10 // float (Size: 0x4)
SoundClassProperties.LFEBleed = 0x14 // float (Size: 0x4)
SoundClassProperties.VoiceCenterChannelVolume = 0x18 // float (Size: 0x4)
SoundClassProperties.RadioFilterVolume = 0x1c // float (Size: 0x4)
SoundClassProperties.RadioFilterVolumeThreshold = 0x20 // float (Size: 0x4)
SoundClassProperties.bApplyEffects = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bAlwaysPlay = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bIsUISound = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bIsMusic = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bCenterChannelOnly = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bApplyAmbientVolumes = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.bReverb = 0x24 // uint8_t (Size: 0x1)
SoundClassProperties.Default2DReverbSendAmount = 0x28 // float (Size: 0x4)
SoundClassProperties.ModulationSettings = 0x30 // FSoundModulationDefaultSettings (Size: 0x40)
SoundClassProperties.OutputTarget = 0x70 // uint8_t (Size: 0x1)
SoundClassProperties.LoadingBehavior = 0x71 // EESoundWaveLoadingBehavior (Size: 0x1)
SoundClassProperties.DefaultSubmix = 0x78 // SoundSubmix* (Size: 0x8)
SoundConcurrency.Concurrency = 0x28 // FSoundConcurrencySettings (Size: 0x28)
SoundConcurrencySettings.MaxCount = 0x0 // int32_t (Size: 0x4)
SoundConcurrencySettings.bLimitToOwner = 0x4 // uint8_t (Size: 0x1)
SoundConcurrencySettings.ResolutionRule = 0x8 // uint8_t (Size: 0x1)
SoundConcurrencySettings.RetriggerTime = 0xc // float (Size: 0x4)
SoundConcurrencySettings.VolumeScale = 0x10 // float (Size: 0x4)
SoundConcurrencySettings.VolumeScaleMode = 0x14 // EEConcurrencyVolumeScaleMode (Size: 0x4)
SoundConcurrencySettings.VolumeScaleAttackTime = 0x18 // float (Size: 0x4)
SoundConcurrencySettings.bVolumeScaleCanRelease = 0x1c // uint8_t (Size: 0x1)
SoundConcurrencySettings.VolumeScaleReleaseTime = 0x20 // float (Size: 0x4)
SoundConcurrencySettings.VoiceStealReleaseTime = 0x24 // float (Size: 0x4)
SoundCue.bPrimeOnLoad = 0x1b8 // uint8_t (Size: 0x1)
SoundCue.FirstNode = 0x1c0 // SoundNode* (Size: 0x8)
SoundCue.VolumeMultiplier = 0x1c8 // float (Size: 0x4)
SoundCue.PitchMultiplier = 0x1cc // float (Size: 0x4)
SoundCue.AttenuationOverrides = 0x1d0 // FSoundAttenuationSettings (Size: 0x3a0)
SoundCue.SubtitlePriority = 0x570 // float (Size: 0x4)
SoundCue.bOverrideAttenuation = 0x578 // uint8_t (Size: 0x1)
SoundCue.bExcludeFromRandomNodeBranchCulling = 0x578 // uint8_t (Size: 0x1)
SoundCue.CookedQualityIndex = 0x57c // int32_t (Size: 0x4)
SoundCue.bHasPlayWhenSilent = 0x580 // uint8_t (Size: 0x1)
SoundEffectSourcePresetChain.Chain = 0x28 // TArray<FSourceEffectChainEntry> (Size: 0x10)
SoundEffectSourcePresetChain.bPlayEffectChainTails = 0x38 // uint8_t (Size: 0x1)
SoundGroup.SoundGroup = 0x0 // uint8_t (Size: 0x1)
SoundGroup.DisplayName = 0x8 // FString (Size: 0x10)
SoundGroup.bAlwaysDecompressOnLoad = 0x18 // uint8_t (Size: 0x1)
SoundGroup.DecompressedDuration = 0x1c // float (Size: 0x4)
SoundGroups.SoundGroupProfiles = 0x28 // TArray<FSoundGroup> (Size: 0x10)
SoundMix.bApplyEQ = 0x28 // uint8_t (Size: 0x1)
SoundMix.EQPriority = 0x2c // float (Size: 0x4)
SoundMix.EQSettings = 0x30 // FAudioEQEffect (Size: 0x40)
SoundMix.SoundClassEffects = 0x70 // TArray<FSoundClassAdjuster> (Size: 0x10)
SoundMix.InitialDelay = 0x80 // float (Size: 0x4)
SoundMix.FadeInTime = 0x84 // float (Size: 0x4)
SoundMix.Duration = 0x88 // float (Size: 0x4)
SoundMix.FadeOutTime = 0x8c // float (Size: 0x4)
SoundModulationDefaultRoutingSettings.VolumeRouting = 0x40 // EEModulationRouting (Size: 0x1)
SoundModulationDefaultRoutingSettings.PitchRouting = 0x41 // EEModulationRouting (Size: 0x1)
SoundModulationDefaultRoutingSettings.HighpassRouting = 0x42 // EEModulationRouting (Size: 0x1)
SoundModulationDefaultRoutingSettings.LowpassRouting = 0x43 // EEModulationRouting (Size: 0x1)
SoundModulationDefaultSettings.VolumeModulationDestination = 0x0 // FSoundModulationDestinationSettings (Size: 0x10)
SoundModulationDefaultSettings.PitchModulationDestination = 0x10 // FSoundModulationDestinationSettings (Size: 0x10)
SoundModulationDefaultSettings.HighpassModulationDestination = 0x20 // FSoundModulationDestinationSettings (Size: 0x10)
SoundModulationDefaultSettings.LowpassModulationDestination = 0x30 // FSoundModulationDestinationSettings (Size: 0x10)
SoundModulationDestinationSettings.Value = 0x0 // float (Size: 0x4)
SoundModulationDestinationSettings.Modulator = 0x8 // SoundModulatorBase* (Size: 0x8)
SoundNode.ChildNodes = 0x28 // TArray<SoundNode*> (Size: 0x10)
SoundNodeAttenuation.AttenuationSettings = 0x48 // SoundAttenuation* (Size: 0x8)
SoundNodeAttenuation.AttenuationOverrides = 0x50 // FSoundAttenuationSettings (Size: 0x3a0)
SoundNodeAttenuation.bOverrideAttenuation = 0x3f0 // uint8_t (Size: 0x1)
SoundNodeBranch.BoolParameterName = 0x48 // FName (Size: 0x8)
SoundNodeConcatenator.InputVolume = 0x48 // TArray<float> (Size: 0x10)
SoundNodeDelay.DelayMin = 0x48 // float (Size: 0x4)
SoundNodeDelay.DelayMax = 0x4c // float (Size: 0x4)
SoundNodeDialoguePlayer.DialogueWaveParameter = 0x48 // FDialogueWaveParameter (Size: 0x20)
SoundNodeDialoguePlayer.bLooping = 0x68 // uint8_t (Size: 0x1)
SoundNodeDistanceCrossFade.CrossFadeInput = 0x48 // TArray<FDistanceDatum> (Size: 0x10)
SoundNodeDoppler.DopplerIntensity = 0x48 // float (Size: 0x4)
SoundNodeDoppler.bUseSmoothing = 0x4c // bool (Size: 0x1)
SoundNodeDoppler.SmoothingInterpSpeed = 0x50 // float (Size: 0x4)
SoundNodeEnveloper.LoopStart = 0x48 // float (Size: 0x4)
SoundNodeEnveloper.LoopEnd = 0x4c // float (Size: 0x4)
SoundNodeEnveloper.DurationAfterLoop = 0x50 // float (Size: 0x4)
SoundNodeEnveloper.LoopCount = 0x54 // int32_t (Size: 0x4)
SoundNodeEnveloper.bLoopIndefinitely = 0x58 // uint8_t (Size: 0x1)
SoundNodeEnveloper.bLoop = 0x58 // uint8_t (Size: 0x1)
SoundNodeEnveloper.VolumeInterpCurve = 0x60 // DistributionFloatConstantCurve* (Size: 0x8)
SoundNodeEnveloper.PitchInterpCurve = 0x68 // DistributionFloatConstantCurve* (Size: 0x8)
SoundNodeEnveloper.VolumeCurve = 0x70 // FRuntimeFloatCurve (Size: 0x88)
SoundNodeEnveloper.PitchCurve = 0xf8 // FRuntimeFloatCurve (Size: 0x88)
SoundNodeEnveloper.PitchMin = 0x180 // float (Size: 0x4)
SoundNodeEnveloper.PitchMax = 0x184 // float (Size: 0x4)
SoundNodeEnveloper.VolumeMin = 0x188 // float (Size: 0x4)
SoundNodeEnveloper.VolumeMax = 0x18c // float (Size: 0x4)
SoundNodeGroupControl.GroupSizes = 0x48 // TArray<int32_t> (Size: 0x10)
SoundNodeLooping.LoopCount = 0x48 // int32_t (Size: 0x4)
SoundNodeLooping.bLoopIndefinitely = 0x4c // uint8_t (Size: 0x1)
SoundNodeMixer.InputVolume = 0x48 // TArray<float> (Size: 0x10)
SoundNodeModulator.PitchMin = 0x48 // float (Size: 0x4)
SoundNodeModulator.PitchMax = 0x4c // float (Size: 0x4)
SoundNodeModulator.VolumeMin = 0x50 // float (Size: 0x4)
SoundNodeModulator.VolumeMax = 0x54 // float (Size: 0x4)
SoundNodeModulatorContinuous.PitchModulationParams = 0x48 // FModulatorContinuousParams (Size: 0x20)
SoundNodeModulatorContinuous.VolumeModulationParams = 0x68 // FModulatorContinuousParams (Size: 0x20)
SoundNodeOscillator.bModulateVolume = 0x48 // uint8_t (Size: 0x1)
SoundNodeOscillator.bModulatePitch = 0x48 // uint8_t (Size: 0x1)
SoundNodeOscillator.AmplitudeMin = 0x4c // float (Size: 0x4)
SoundNodeOscillator.AmplitudeMax = 0x50 // float (Size: 0x4)
SoundNodeOscillator.FrequencyMin = 0x54 // float (Size: 0x4)
SoundNodeOscillator.FrequencyMax = 0x58 // float (Size: 0x4)
SoundNodeOscillator.OffsetMin = 0x5c // float (Size: 0x4)
SoundNodeOscillator.OffsetMax = 0x60 // float (Size: 0x4)
SoundNodeOscillator.CenterMin = 0x64 // float (Size: 0x4)
SoundNodeOscillator.CenterMax = 0x68 // float (Size: 0x4)
SoundNodeParamCrossFade.ParamName = 0x58 // FName (Size: 0x8)
SoundNodeQualityLevel.CookedQualityLevelIndex = 0x48 // int32_t (Size: 0x4)
SoundNodeRandom.Weights = 0x48 // TArray<float> (Size: 0x10)
SoundNodeRandom.HasBeenUsed = 0x58 // TArray<bool> (Size: 0x10)
SoundNodeRandom.NumRandomUsed = 0x68 // int32_t (Size: 0x4)
SoundNodeRandom.PreselectAtLevelLoad = 0x6c // int32_t (Size: 0x4)
SoundNodeRandom.bShouldExcludeFromBranchCulling = 0x70 // uint8_t (Size: 0x1)
SoundNodeRandom.bSoundCueExcludedFromBranchCulling = 0x70 // uint8_t (Size: 0x1)
SoundNodeRandom.bRandomizeWithoutReplacement = 0x70 // uint8_t (Size: 0x1)
SoundNodeSoundClass.SoundClassOverride = 0x48 // SoundClass* (Size: 0x8)
SoundNodeSwitch.IntParameterName = 0x48 // FName (Size: 0x8)
SoundNodeWaveParam.WaveParameterName = 0x48 // FName (Size: 0x8)
SoundNodeWavePlayer.SoundWaveAssetPtr = 0x48 // TSoftObjectPtr<UObject> (Size: 0x28)
SoundNodeWavePlayer.SoundWave = 0x70 // SoundWave* (Size: 0x8)
SoundNodeWavePlayer.bLooping = 0x80 // uint8_t (Size: 0x1)
SoundSourceBus.SourceBusChannels = 0x370 // EESourceBusChannels (Size: 0x1)
SoundSourceBus.SourceBusDuration = 0x374 // float (Size: 0x4)
SoundSourceBus.AudioBus = 0x378 // AudioBus* (Size: 0x8)
SoundSourceBus.bAutoDeactivateWhenSilent = 0x380 // uint8_t (Size: 0x1)
SoundSourceBusSendInfo.SourceBusSendLevelControlMethod = 0x0 // EESourceBusSendLevelControlMethod (Size: 0x1)
SoundSourceBusSendInfo.SoundSourceBus = 0x8 // SoundSourceBus* (Size: 0x8)
SoundSourceBusSendInfo.AudioBus = 0x10 // AudioBus* (Size: 0x8)
SoundSourceBusSendInfo.SendLevel = 0x18 // float (Size: 0x4)
SoundSourceBusSendInfo.MinSendLevel = 0x1c // float (Size: 0x4)
SoundSourceBusSendInfo.MaxSendLevel = 0x20 // float (Size: 0x4)
SoundSourceBusSendInfo.MinSendDistance = 0x24 // float (Size: 0x4)
SoundSourceBusSendInfo.MaxSendDistance = 0x28 // float (Size: 0x4)
SoundSourceBusSendInfo.CustomSendLevelCurve = 0x30 // FRuntimeFloatCurve (Size: 0x88)
SoundSubmix.bMuteWhenBackgrounded = 0x40 // uint8_t (Size: 0x1)
SoundSubmix.SubmixEffectChain = 0x48 // TArray<SoundEffectSubmixPreset*> (Size: 0x10)
SoundSubmix.AmbisonicsPluginSettings = 0x58 // SoundfieldEncodingSettingsBase* (Size: 0x8)
SoundSubmix.EnvelopeFollowerAttackTime = 0x60 // int32_t (Size: 0x4)
SoundSubmix.EnvelopeFollowerReleaseTime = 0x64 // int32_t (Size: 0x4)
SoundSubmix.GainMode = 0x68 // EEGainParamMode (Size: 0x1)
SoundSubmix.OutputVolume = 0x6c // float (Size: 0x4)
SoundSubmix.WetLevel = 0x70 // float (Size: 0x4)
SoundSubmix.DryLevel = 0x74 // float (Size: 0x4)
SoundSubmix.OnSubmixRecordedFileDone = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SoundSubmixBase.ChildSubmixes = 0x28 // TArray<SoundSubmixBase*> (Size: 0x10)
SoundSubmixSendInfo.SendLevelControlMethod = 0x0 // EESendLevelControlMethod (Size: 0x1)
SoundSubmixSendInfo.SendStage = 0x1 // EESubmixSendStage (Size: 0x1)
SoundSubmixSendInfo.SoundSubmix = 0x8 // SoundSubmixBase* (Size: 0x8)
SoundSubmixSendInfo.SendLevel = 0x10 // float (Size: 0x4)
SoundSubmixSendInfo.MinSendLevel = 0x14 // float (Size: 0x4)
SoundSubmixSendInfo.MaxSendLevel = 0x18 // float (Size: 0x4)
SoundSubmixSendInfo.MinSendDistance = 0x1c // float (Size: 0x4)
SoundSubmixSendInfo.MaxSendDistance = 0x20 // float (Size: 0x4)
SoundSubmixSendInfo.CustomSendLevelCurve = 0x28 // FRuntimeFloatCurve (Size: 0x88)
SoundSubmixSpectralAnalysisBandSettings.BandFrequency = 0x0 // float (Size: 0x4)
SoundSubmixSpectralAnalysisBandSettings.AttackTimeMsec = 0x4 // int32_t (Size: 0x4)
SoundSubmixSpectralAnalysisBandSettings.ReleaseTimeMsec = 0x8 // int32_t (Size: 0x4)
SoundSubmixSpectralAnalysisBandSettings.QFactor = 0xc // float (Size: 0x4)
SoundSubmixWithParentBase.ParentSubmix = 0x38 // SoundSubmixBase* (Size: 0x8)
SoundTrackKey.Time = 0x0 // float (Size: 0x4)
SoundTrackKey.Volume = 0x4 // float (Size: 0x4)
SoundTrackKey.Pitch = 0x8 // float (Size: 0x4)
SoundTrackKey.Sound = 0x10 // SoundBase* (Size: 0x8)
SoundWave.CompressionQuality = 0x1b8 // int32_t (Size: 0x4)
SoundWave.StreamingPriority = 0x1bc // int32_t (Size: 0x4)
SoundWave.SampleRateQuality = 0x1c0 // EESoundwaveSampleRateSettings (Size: 0x1)
SoundWave.SoundGroup = 0x1c2 // uint8_t (Size: 0x1)
SoundWave.bLooping = 0x1c3 // uint8_t (Size: 0x1)
SoundWave.bStreaming = 0x1c3 // uint8_t (Size: 0x1)
SoundWave.bSeekableStreaming = 0x1c3 // uint8_t (Size: 0x1)
SoundWave.LoadingBehavior = 0x1c4 // EESoundWaveLoadingBehavior (Size: 0x1)
SoundWave.bMature = 0x1c5 // uint8_t (Size: 0x1)
SoundWave.bManualWordWrap = 0x1c5 // uint8_t (Size: 0x1)
SoundWave.bSingleLine = 0x1c6 // uint8_t (Size: 0x1)
SoundWave.bIsAmbisonics = 0x1c6 // uint8_t (Size: 0x1)
SoundWave.FrequenciesToAnalyze = 0x1c8 // TArray<float> (Size: 0x10)
SoundWave.CookedSpectralTimeData = 0x1d8 // TArray<FSoundWaveSpectralTimeData> (Size: 0x10)
SoundWave.CookedEnvelopeTimeData = 0x1e8 // TArray<FSoundWaveEnvelopeTimeData> (Size: 0x10)
SoundWave.InitialChunkSize = 0x1f8 // int32_t (Size: 0x4)
SoundWave.SpokenText = 0x240 // FString (Size: 0x10)
SoundWave.SubtitlePriority = 0x250 // float (Size: 0x4)
SoundWave.Volume = 0x254 // float (Size: 0x4)
SoundWave.Pitch = 0x258 // float (Size: 0x4)
SoundWave.NumChannels = 0x25c // int32_t (Size: 0x4)
SoundWave.SampleRate = 0x260 // int32_t (Size: 0x4)
SoundWave.Subtitles = 0x270 // TArray<FSubtitleCue> (Size: 0x10)
SoundWave.Curves = 0x280 // CurveTable* (Size: 0x8)
SoundWave.InternalCurves = 0x288 // CurveTable* (Size: 0x8)
SoundWaveEnvelopeDataPerSound.Envelope = 0x0 // float (Size: 0x4)
SoundWaveEnvelopeDataPerSound.PlaybackTime = 0x4 // float (Size: 0x4)
SoundWaveEnvelopeDataPerSound.SoundWave = 0x8 // SoundWave* (Size: 0x8)
SoundWaveEnvelopeTimeData.Amplitude = 0x0 // float (Size: 0x4)
SoundWaveEnvelopeTimeData.TimeSec = 0x4 // float (Size: 0x4)
SoundWaveSpectralData.FrequencyHz = 0x0 // float (Size: 0x4)
SoundWaveSpectralData.Magnitude = 0x4 // float (Size: 0x4)
SoundWaveSpectralData.NormalizedMagnitude = 0x8 // float (Size: 0x4)
SoundWaveSpectralDataEntry.Magnitude = 0x0 // float (Size: 0x4)
SoundWaveSpectralDataEntry.NormalizedMagnitude = 0x4 // float (Size: 0x4)
SoundWaveSpectralDataPerSound.SpectralData = 0x0 // TArray<FSoundWaveSpectralData> (Size: 0x10)
SoundWaveSpectralDataPerSound.PlaybackTime = 0x10 // float (Size: 0x4)
SoundWaveSpectralDataPerSound.SoundWave = 0x18 // SoundWave* (Size: 0x8)
SoundWaveSpectralTimeData.Data = 0x0 // TArray<FSoundWaveSpectralDataEntry> (Size: 0x10)
SoundWaveSpectralTimeData.TimeSec = 0x10 // float (Size: 0x4)
SoundfieldEndpointSubmix.SoundfieldEndpointType = 0x38 // FName (Size: 0x8)
SoundfieldEndpointSubmix.EndpointSettingsClass = 0x40 // ClassProperty (Size: 0x8)
SoundfieldEndpointSubmix.EndpointSettings = 0x48 // SoundfieldEndpointSettingsBase* (Size: 0x8)
SoundfieldEndpointSubmix.EncodingSettingsClass = 0x50 // ClassProperty (Size: 0x8)
SoundfieldEndpointSubmix.EncodingSettings = 0x58 // SoundfieldEncodingSettingsBase* (Size: 0x8)
SoundfieldEndpointSubmix.SoundfieldEffectChain = 0x60 // TArray<SoundfieldEffectBase*> (Size: 0x10)
SoundfieldSubmix.SoundfieldEncodingFormat = 0x40 // FName (Size: 0x8)
SoundfieldSubmix.EncodingSettings = 0x48 // SoundfieldEncodingSettingsBase* (Size: 0x8)
SoundfieldSubmix.SoundfieldEffectChain = 0x50 // TArray<SoundfieldEffectBase*> (Size: 0x10)
SoundfieldSubmix.EncodingSettingsClass = 0x60 // ClassProperty (Size: 0x8)
SourceEffectChainEntry.Preset = 0x0 // SoundEffectSourcePreset* (Size: 0x8)
SourceEffectChainEntry.bBypass = 0x8 // uint8_t (Size: 0x1)
SpectatorPawnMovement.bIgnoreTimeDilation = 0x198 // uint8_t (Size: 0x1)
SphereComponent.SphereRadius = 0x5e0 // float (Size: 0x4)
SphereReflectionCapture.DrawCaptureRadius = 0x318 // DrawSphereComponent* (Size: 0x8)
SphereReflectionCaptureComponent.InfluenceRadius = 0x2e8 // float (Size: 0x4)
SphereReflectionCaptureComponent.CaptureDistanceScale = 0x2ec // float (Size: 0x4)
SphereReflectionCaptureComponent.PreviewInfluenceRadius = 0x2f0 // DrawSphereComponent* (Size: 0x8)
SplineComponent.SplineCurves = 0x5c8 // FSplineCurves (Size: 0x70)
SplineComponent.SplineInfo = 0x638 // FInterpCurveVector (Size: 0x18)
SplineComponent.SplineRotInfo = 0x650 // FInterpCurveQuat (Size: 0x18)
SplineComponent.SplineScaleInfo = 0x668 // FInterpCurveVector (Size: 0x18)
SplineComponent.SplineReparamTable = 0x680 // FInterpCurveFloat (Size: 0x18)
SplineComponent.bAllowSplineEditingPerInstance = 0x698 // bool (Size: 0x1)
SplineComponent.ReparamStepsPerSegment = 0x69c // int32_t (Size: 0x4)
SplineComponent.Duration = 0x6a0 // float (Size: 0x4)
SplineComponent.bStationaryEndpoints = 0x6a4 // bool (Size: 0x1)
SplineComponent.bSplineHasBeenEdited = 0x6a5 // bool (Size: 0x1)
SplineComponent.bModifiedByConstructionScript = 0x6a6 // bool (Size: 0x1)
SplineComponent.bInputSplinePointsToConstructionScript = 0x6a7 // bool (Size: 0x1)
SplineComponent.bDrawDebug = 0x6a8 // bool (Size: 0x1)
SplineComponent.bClosedLoop = 0x6a9 // bool (Size: 0x1)
SplineComponent.bLoopPositionOverride = 0x6aa // bool (Size: 0x1)
SplineComponent.LoopPosition = 0x6ac // float (Size: 0x4)
SplineComponent.DefaultUpVector = 0x6b0 // FVector (Size: 0xc)
SplineCurves.position = 0x0 // FInterpCurveVector (Size: 0x18)
SplineCurves.Rotation = 0x18 // FInterpCurveQuat (Size: 0x18)
SplineCurves.Scale = 0x30 // FInterpCurveVector (Size: 0x18)
SplineCurves.ReparamTable = 0x48 // FInterpCurveFloat (Size: 0x18)
SplineCurves.MetaData = 0x60 // SplineMetadata* (Size: 0x8)
SplineCurves.Version = 0x68 // uint32_t (Size: 0x4)
SplineInstanceData.bSplineHasBeenEdited = 0xb8 // bool (Size: 0x1)
SplineInstanceData.SplineCurves = 0xc0 // FSplineCurves (Size: 0x70)
SplineInstanceData.SplineCurvesPreUCS = 0x130 // FSplineCurves (Size: 0x70)
SplineMeshActor.SplineMeshComponent = 0x310 // SplineMeshComponent* (Size: 0x8)
SplineMeshComponent.SplineParams = 0x678 // FSplineMeshParams (Size: 0x58)
SplineMeshComponent.SplineUpDir = 0x6d0 // FVector (Size: 0xc)
SplineMeshComponent.SplineBoundaryMin = 0x6dc // float (Size: 0x4)
SplineMeshComponent.CachedMeshBodySetupGuid = 0x6e0 // FGuid (Size: 0x10)
SplineMeshComponent.BodySetup = 0x6f0 // BodySetup* (Size: 0x8)
SplineMeshComponent.SplineBoundaryMax = 0x6f8 // float (Size: 0x4)
SplineMeshComponent.bAllowSplineEditingPerInstance = 0x6fc // uint8_t (Size: 0x1)
SplineMeshComponent.bSmoothInterpRollScale = 0x6fc // uint8_t (Size: 0x1)
SplineMeshComponent.bMeshDirty = 0x6fc // uint8_t (Size: 0x1)
SplineMeshComponent.ForwardAxis = 0x6fd // uint8_t (Size: 0x1)
SplineMeshComponent.VirtualTextureMainPassMaxDrawDistance = 0x700 // float (Size: 0x4)
SplineMeshInstanceData.StartPos = 0xb8 // FVector (Size: 0xc)
SplineMeshInstanceData.EndPos = 0xc4 // FVector (Size: 0xc)
SplineMeshInstanceData.StartTangent = 0xd0 // FVector (Size: 0xc)
SplineMeshInstanceData.EndTangent = 0xdc // FVector (Size: 0xc)
SplineMeshParams.StartPos = 0x0 // FVector (Size: 0xc)
SplineMeshParams.StartTangent = 0xc // FVector (Size: 0xc)
SplineMeshParams.StartScale = 0x18 // FVector2D (Size: 0x8)
SplineMeshParams.StartRoll = 0x20 // float (Size: 0x4)
SplineMeshParams.StartOffset = 0x24 // FVector2D (Size: 0x8)
SplineMeshParams.EndPos = 0x2c // FVector (Size: 0xc)
SplineMeshParams.EndScale = 0x38 // FVector2D (Size: 0x8)
SplineMeshParams.EndTangent = 0x40 // FVector (Size: 0xc)
SplineMeshParams.EndRoll = 0x4c // float (Size: 0x4)
SplineMeshParams.EndOffset = 0x50 // FVector2D (Size: 0x8)
SplinePoint.InputKey = 0x0 // float (Size: 0x4)
SplinePoint.position = 0x4 // FVector (Size: 0xc)
SplinePoint.ArriveTangent = 0x10 // FVector (Size: 0xc)
SplinePoint.LeaveTangent = 0x1c // FVector (Size: 0xc)
SplinePoint.Rotation = 0x28 // FRotator (Size: 0xc)
SplinePoint.Scale = 0x34 // FVector (Size: 0xc)
SplinePoint.Type = 0x40 // uint8_t (Size: 0x1)
SpotLight.SpotLightComponent = 0x320 // SpotLightComponent* (Size: 0x8)
SpotLightComponent.InnerConeAngle = 0x410 // float (Size: 0x4)
SpotLightComponent.OuterConeAngle = 0x414 // float (Size: 0x4)
SpotLightComponent.MobileSpotLightAnglesFalloffExponent = 0x418 // float (Size: 0x4)
SpotLightComponent.bIsFlashLight = 0x41c // bool (Size: 0x1)
SpotLightComponent.bDebugShowShadowCaster = 0x420 // int32_t (Size: 0x4)
SpringArmComponent.TargetArmLength = 0x238 // float (Size: 0x4)
SpringArmComponent.SocketOffset = 0x23c // FVector (Size: 0xc)
SpringArmComponent.TargetOffset = 0x248 // FVector (Size: 0xc)
SpringArmComponent.ProbeSize = 0x254 // float (Size: 0x4)
SpringArmComponent.ProbeChannel = 0x258 // uint8_t (Size: 0x1)
SpringArmComponent.bDoCollisionTest = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bUsePawnControlRotation = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bInheritPitch = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bInheritYaw = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bInheritRoll = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bEnableCameraLag = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bEnableCameraRotationLag = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bUseCameraLagSubstepping = 0x25c // uint8_t (Size: 0x1)
SpringArmComponent.bDrawDebugLagMarkers = 0x25d // uint8_t (Size: 0x1)
SpringArmComponent.CameraLagSpeed = 0x260 // float (Size: 0x4)
SpringArmComponent.CameraRotationLagSpeed = 0x264 // float (Size: 0x4)
SpringArmComponent.CameraLagMaxTimeStep = 0x268 // float (Size: 0x4)
SpringArmComponent.CameraLagMaxDistance = 0x26c // float (Size: 0x4)
SpriteCategoryInfo.Category = 0x0 // FName (Size: 0x8)
SpriteCategoryInfo.DisplayName = 0x8 // FText (Size: 0x18)
SpriteCategoryInfo.Description = 0x20 // FText (Size: 0x18)
StatColorMapEntry.In = 0x0 // float (Size: 0x4)
StatColorMapEntry.Out = 0x4 // FColor (Size: 0x4)
StatColorMapping.StatName = 0x0 // FString (Size: 0x10)
StatColorMapping.ColorMap = 0x10 // TArray<FStatColorMapEntry> (Size: 0x10)
StatColorMapping.DisableBlend = 0x20 // uint8_t (Size: 0x1)
StaticComponentMaskParameter.R = 0x24 // bool (Size: 0x1)
StaticComponentMaskParameter.G = 0x25 // bool (Size: 0x1)
StaticComponentMaskParameter.B = 0x26 // bool (Size: 0x1)
StaticComponentMaskParameter.A = 0x27 // bool (Size: 0x1)
StaticComponentMaskValue.R = 0x0 // bool (Size: 0x1)
StaticComponentMaskValue.G = 0x1 // bool (Size: 0x1)
StaticComponentMaskValue.B = 0x2 // bool (Size: 0x1)
StaticComponentMaskValue.A = 0x3 // bool (Size: 0x1)
StaticMaterial.MaterialInterface = 0x0 // MaterialInterface* (Size: 0x8)
StaticMaterial.MaterialSlotName = 0x8 // FName (Size: 0x8)
StaticMaterial.ImportedMaterialSlotName = 0x10 // FName (Size: 0x8)
StaticMaterial.UVChannelData = 0x18 // FMeshUVChannelInfo (Size: 0x14)
StaticMaterialLayersParameter.Value = 0x28 // FMaterialLayersFunctions (Size: 0x40)
StaticMesh.MinLOD = 0x90 // FPerPlatformInt (Size: 0x8)
StaticMesh.MinLODLowQuality = 0x98 // uint8_t (Size: 0x1)
StaticMesh.LpvBiasMultiplier = 0x9c // float (Size: 0x4)
StaticMesh.StaticMaterials = 0xa0 // TArray<FStaticMaterial> (Size: 0x10)
StaticMesh.LightmapUVDensity = 0xb0 // float (Size: 0x4)
StaticMesh.LightMapResolution = 0xb4 // int32_t (Size: 0x4)
StaticMesh.LightMapCoordinateIndex = 0xb8 // int32_t (Size: 0x4)
StaticMesh.DistanceFieldSelfShadowBias = 0xbc // float (Size: 0x4)
StaticMesh.BodySetup = 0xc0 // BodySetup* (Size: 0x8)
StaticMesh.LODForCollision = 0xc8 // int32_t (Size: 0x4)
StaticMesh.bCAFuzzyShadow = 0xcc // uint8_t (Size: 0x1)
StaticMesh.MinShadowLOD = 0xcd // uint8_t (Size: 0x1)
StaticMesh.bGenerateMeshDistanceField = 0xce // uint8_t (Size: 0x1)
StaticMesh.bStripComplexCollisionForConsole = 0xce // uint8_t (Size: 0x1)
StaticMesh.bHasNavigationData = 0xce // uint8_t (Size: 0x1)
StaticMesh.bSupportUniformlyDistributedSampling = 0xce // uint8_t (Size: 0x1)
StaticMesh.bSupportPhysicalMaterialMasks = 0xce // uint8_t (Size: 0x1)
StaticMesh.bIsBuiltAtRuntime = 0xce // uint8_t (Size: 0x1)
StaticMesh.bAllowCPUAccess = 0xce // uint8_t (Size: 0x1)
StaticMesh.bSupportGpuUniformlyDistributedSampling = 0xcf // uint8_t (Size: 0x1)
StaticMesh.LODShareLightmapType = 0xe0 // EELODShareLightmapType (Size: 0x1)
StaticMesh.bPriorityOccluder = 0xe1 // bool (Size: 0x1)
StaticMesh.Sockets = 0xf8 // TArray<StaticMeshSocket*> (Size: 0x10)
StaticMesh.PositiveBoundsExtension = 0x118 // FVector (Size: 0xc)
StaticMesh.NegativeBoundsExtension = 0x124 // FVector (Size: 0xc)
StaticMesh.ExtendedBounds = 0x130 // FBoxSphereBounds (Size: 0x1c)
StaticMesh.DistanceFieldForceNumMips = 0x14c // int32_t (Size: 0x4)
StaticMesh.OctNormalUVIndex = 0x150 // int32_t (Size: 0x4)
StaticMesh.ElementToIgnoreForTexFactor = 0x154 // int32_t (Size: 0x4)
StaticMesh.AssetUserData = 0x158 // TArray<AssetUserData*> (Size: 0x10)
StaticMesh.EditableMesh = 0x168 // Object* (Size: 0x8)
StaticMesh.NavCollision = 0x170 // NavCollisionBase* (Size: 0x8)
StaticMesh.MFGeometrySettings = 0x178 // FMFGpuDrivenMeshSettings (Size: 0x1)
StaticMeshActor.StaticMeshComponent = 0x310 // StaticMeshComponent* (Size: 0x8)
StaticMeshActor.bStaticMeshReplicateMovement = 0x318 // bool (Size: 0x1)
StaticMeshActor.NavigationGeometryGatheringMode = 0x319 // EENavDataGatheringMode (Size: 0x1)
StaticMeshComponent.ForcedLodModel = 0x600 // int32_t (Size: 0x4)
StaticMeshComponent.PreviousLODLevel = 0x604 // int32_t (Size: 0x4)
StaticMeshComponent.MinLOD = 0x608 // int32_t (Size: 0x4)
StaticMeshComponent.SubDivisionStepSize = 0x60c // int32_t (Size: 0x4)
StaticMeshComponent.StaticMesh = 0x610 // StaticMesh* (Size: 0x8)
StaticMeshComponent.WireframeColorOverride = 0x618 // FColor (Size: 0x4)
StaticMeshComponent.bEvaluateWorldPositionOffset = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bOverrideWireframeColor = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bOverrideMinLod = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bOverrideNavigationExport = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bForceNavigationObstacle = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bDisallowMeshPaintPerInstance = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bIgnoreInstanceForTextureStreaming = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bIgnoreInstanceForMeshStreaming = 0x61c // uint8_t (Size: 0x1)
StaticMeshComponent.bOverrideLightmapRes = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bCastDistanceFieldIndirectShadow = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bOverrideDistanceFieldSelfShadowBias = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bUseSubDivisions = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bUseDefaultCollision = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bSortTriangles = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.bReverseCulling = 0x61d // uint8_t (Size: 0x1)
StaticMeshComponent.OverriddenLightMapRes = 0x620 // int32_t (Size: 0x4)
StaticMeshComponent.DistanceFieldIndirectShadowMinVisibility = 0x624 // float (Size: 0x4)
StaticMeshComponent.DistanceFieldSelfShadowBias = 0x628 // float (Size: 0x4)
StaticMeshComponent.bStaticShadowMaskOnly = 0x62c // uint8_t (Size: 0x1)
StaticMeshComponent.bForceUseSkyLightAsDiffuseGI = 0x62c // uint8_t (Size: 0x1)
StaticMeshComponent.bSkipWorldCollisionManagerControl = 0x62c // uint8_t (Size: 0x1)
StaticMeshComponent.StreamingDistanceMultiplier = 0x630 // float (Size: 0x4)
StaticMeshComponent.LODData = 0x638 // TArray<FStaticMeshComponentLODInfo> (Size: 0x10)
StaticMeshComponent.StreamingTextureData = 0x648 // TArray<FStreamingTextureBuildInfo> (Size: 0x10)
StaticMeshComponent.LightmassSettings = 0x658 // FLightmassPrimitiveSettings (Size: 0x18)
StaticMeshComponentInstanceData.StaticMesh = 0x100 // StaticMesh* (Size: 0x8)
StaticMeshComponentInstanceData.VertexColorLODs = 0x108 // TArray<FStaticMeshVertexColorLODData> (Size: 0x10)
StaticMeshComponentInstanceData.CachedStaticLighting = 0x118 // TArray<FGuid> (Size: 0x10)
StaticMeshComponentInstanceData.StreamingTextureData = 0x128 // TArray<FStreamingTextureBuildInfo> (Size: 0x10)
StaticMeshOptimizationSettings.ReductionMethod = 0x0 // uint8_t (Size: 0x1)
StaticMeshOptimizationSettings.NumOfTrianglesPercentage = 0x4 // float (Size: 0x4)
StaticMeshOptimizationSettings.MaxDeviationPercentage = 0x8 // float (Size: 0x4)
StaticMeshOptimizationSettings.WeldingThreshold = 0xc // float (Size: 0x4)
StaticMeshOptimizationSettings.bRecalcNormals = 0x10 // bool (Size: 0x1)
StaticMeshOptimizationSettings.NormalsThreshold = 0x14 // float (Size: 0x4)
StaticMeshOptimizationSettings.SilhouetteImportance = 0x18 // uint8_t (Size: 0x1)
StaticMeshOptimizationSettings.TextureImportance = 0x19 // uint8_t (Size: 0x1)
StaticMeshOptimizationSettings.ShadingImportance = 0x1a // uint8_t (Size: 0x1)
StaticMeshSocket.SocketName = 0x28 // FName (Size: 0x8)
StaticMeshSocket.RelativeLocation = 0x30 // FVector (Size: 0xc)
StaticMeshSocket.RelativeRotation = 0x3c // FRotator (Size: 0xc)
StaticMeshSocket.RelativeScale = 0x48 // FVector (Size: 0xc)
StaticMeshSocket.Tag = 0x58 // FString (Size: 0x10)
StaticMeshSourceModel.BuildSettings = 0x0 // FMeshBuildSettings (Size: 0x50)
StaticMeshSourceModel.ReductionSettings = 0x50 // FMeshReductionSettings (Size: 0x2c)
StaticMeshSourceModel.LODDistance = 0x7c // float (Size: 0x4)
StaticMeshSourceModel.ScreenSize = 0x80 // FPerPlatformFloat (Size: 0x4)
StaticMeshSourceModel.SourceImportFilename = 0x88 // FString (Size: 0x10)
StaticMeshVertexColorLODData.PaintedVertices = 0x0 // TArray<FPaintedVertex> (Size: 0x10)
StaticMeshVertexColorLODData.VertexBufferColors = 0x10 // TArray<FColor> (Size: 0x10)
StaticMeshVertexColorLODData.LODIndex = 0x20 // uint32_t (Size: 0x4)
StaticParameterBase.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
StaticParameterBase.bOverride = 0x10 // bool (Size: 0x1)
StaticParameterBase.ExpressionGUID = 0x14 // FGuid (Size: 0x10)
StaticParameterSet.StaticSwitchParameters = 0x0 // TArray<FStaticSwitchParameter> (Size: 0x10)
StaticParameterSet.StaticComponentMaskParameters = 0x10 // TArray<FStaticComponentMaskParameter> (Size: 0x10)
StaticParameterSet.TerrainLayerWeightParameters = 0x20 // TArray<FStaticTerrainLayerWeightParameter> (Size: 0x10)
StaticParameterSet.MaterialLayersParameters = 0x30 // TArray<FStaticMaterialLayersParameter> (Size: 0x10)
StaticSwitchParameter.Value = 0x24 // bool (Size: 0x1)
StaticTerrainLayerWeightParameter.WeightmapIndex = 0x24 // int32_t (Size: 0x4)
StaticTerrainLayerWeightParameter.bWeightBasedBlend = 0x28 // bool (Size: 0x1)
StereoLayerComponent.bLiveTexture = 0x238 // uint8_t (Size: 0x1)
StereoLayerComponent.bSupportsDepth = 0x238 // uint8_t (Size: 0x1)
StereoLayerComponent.bNoAlphaChannel = 0x238 // uint8_t (Size: 0x1)
StereoLayerComponent.Texture = 0x240 // Texture* (Size: 0x8)
StereoLayerComponent.LeftTexture = 0x248 // Texture* (Size: 0x8)
StereoLayerComponent.bQuadPreserveTextureRatio = 0x250 // uint8_t (Size: 0x1)
StereoLayerComponent.QuadSize = 0x254 // FVector2D (Size: 0x8)
StereoLayerComponent.UVRect = 0x25c // FBox2D (Size: 0x14)
StereoLayerComponent.CylinderRadius = 0x270 // float (Size: 0x4)
StereoLayerComponent.CylinderOverlayArc = 0x274 // float (Size: 0x4)
StereoLayerComponent.CylinderHeight = 0x278 // int32_t (Size: 0x4)
StereoLayerComponent.EquirectProps = 0x27c // FEquirectProps (Size: 0x48)
StereoLayerComponent.StereoLayerType = 0x2c4 // uint8_t (Size: 0x1)
StereoLayerComponent.StereoLayerShape = 0x2c5 // uint8_t (Size: 0x1)
StereoLayerComponent.Shape = 0x2c8 // StereoLayerShape* (Size: 0x8)
StereoLayerComponent.Priority = 0x2d0 // int32_t (Size: 0x4)
StereoLayerShapeCylinder.Radius = 0x28 // float (Size: 0x4)
StereoLayerShapeCylinder.OverlayArc = 0x2c // float (Size: 0x4)
StereoLayerShapeCylinder.Height = 0x30 // int32_t (Size: 0x4)
StereoLayerShapeEquirect.LeftUVRect = 0x28 // FBox2D (Size: 0x14)
StereoLayerShapeEquirect.RightUVRect = 0x3c // FBox2D (Size: 0x14)
StereoLayerShapeEquirect.LeftScale = 0x50 // FVector2D (Size: 0x8)
StereoLayerShapeEquirect.RightScale = 0x58 // FVector2D (Size: 0x8)
StereoLayerShapeEquirect.LeftBias = 0x60 // FVector2D (Size: 0x8)
StereoLayerShapeEquirect.RightBias = 0x68 // FVector2D (Size: 0x8)
StreamableRenderAsset.ForceMipLevelsToBeResidentTimestamp = 0x50 // double (Size: 0x8)
StreamableRenderAsset.NumCinematicMipLevels = 0x58 // int32_t (Size: 0x4)
StreamableRenderAsset.StreamingIndex = 0x5c // int32_t (Size: 0x4)
StreamableRenderAsset.CachedCombinedLODBias = 0x60 // int32_t (Size: 0x4)
StreamableRenderAsset.CustomVisibleWantedMips = 0x64 // uint8_t (Size: 0x1)
StreamableRenderAsset.NeverStream = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bGlobalForceMipLevelsToBeResident = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bHasStreamingUpdatePending = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bForceMiplevelsToBeResident = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bIgnoreStreamingMipBias = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bIs1P = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bForceToIgnoreStreamingMipBias = 0x65 // uint8_t (Size: 0x1)
StreamableRenderAsset.bUseCinematicMipLevels = 0x65 // uint8_t (Size: 0x1)
StreamingLevelsToConsider.StreamingLevels = 0x0 // TArray<LevelStreaming*> (Size: 0x10)
StreamingRenderAssetPrimitiveInfo.RenderAsset = 0x0 // StreamableRenderAsset* (Size: 0x8)
StreamingRenderAssetPrimitiveInfo.Bounds = 0x8 // FBoxSphereBounds (Size: 0x1c)
StreamingRenderAssetPrimitiveInfo.TexelFactor = 0x24 // float (Size: 0x4)
StreamingRenderAssetPrimitiveInfo.PackedRelativeBox = 0x28 // uint32_t (Size: 0x4)
StreamingRenderAssetPrimitiveInfo.bAllowInvalidTexelFactorWhenUnregistered = 0x2c // uint8_t (Size: 0x1)
StreamingSettings.AsyncLoadingThreadEnabled = 0x38 // uint8_t (Size: 0x1)
StreamingSettings.WarnIfTimeLimitExceeded = 0x38 // uint8_t (Size: 0x1)
StreamingSettings.TimeLimitExceededMultiplier = 0x3c // float (Size: 0x4)
StreamingSettings.TimeLimitExceededMinTime = 0x40 // float (Size: 0x4)
StreamingSettings.MinBulkDataSizeForAsyncLoading = 0x44 // int32_t (Size: 0x4)
StreamingSettings.UseBackgroundLevelStreaming = 0x48 // uint8_t (Size: 0x1)
StreamingSettings.AsyncLoadingUseFullTimeLimit = 0x48 // uint8_t (Size: 0x1)
StreamingSettings.AsyncLoadingTimeLimit = 0x4c // float (Size: 0x4)
StreamingSettings.PriorityAsyncLoadingExtraTime = 0x50 // float (Size: 0x4)
StreamingSettings.LevelStreamingActorsUpdateTimeLimit = 0x54 // float (Size: 0x4)
StreamingSettings.PriorityLevelStreamingActorsUpdateExtraTime = 0x58 // float (Size: 0x4)
StreamingSettings.LevelStreamingComponentsRegistrationGranularity = 0x5c // int32_t (Size: 0x4)
StreamingSettings.LevelStreamingUnregisterComponentsTimeLimit = 0x60 // float (Size: 0x4)
StreamingSettings.LevelStreamingComponentsUnregistrationGranularity = 0x64 // int32_t (Size: 0x4)
StreamingSettings.FlushStreamingOnExit = 0x68 // uint8_t (Size: 0x1)
StreamingSettings.EventDrivenLoaderEnabled = 0x68 // uint8_t (Size: 0x1)
StreamingTextureBuildInfo.PackedRelativeBox = 0x0 // uint32_t (Size: 0x4)
StreamingTextureBuildInfo.TextureLevelIndex = 0x4 // int32_t (Size: 0x4)
StreamingTextureBuildInfo.TexelFactor = 0x8 // float (Size: 0x4)
StringCurve.DefaultValue = 0x68 // FString (Size: 0x10)
StringCurve.Keys = 0x78 // TArray<FStringCurveKey> (Size: 0x10)
StringCurveKey.Time = 0x0 // float (Size: 0x4)
StringCurveKey.Value = 0x8 // FString (Size: 0x10)
StructRedirect.OldStructName = 0x0 // FName (Size: 0x8)
StructRedirect.NewStructName = 0x8 // FName (Size: 0x8)
SubTrackGroup.GroupName = 0x0 // FString (Size: 0x10)
SubTrackGroup.TrackIndices = 0x10 // TArray<int32_t> (Size: 0x10)
SubTrackGroup.bIsCollapsed = 0x20 // uint8_t (Size: 0x1)
SubTrackGroup.bIsSelected = 0x20 // uint8_t (Size: 0x1)
SubUVAnimation.SubUVTexture = 0x28 // Texture2D* (Size: 0x8)
SubUVAnimation.SubImages_Horizontal = 0x30 // int32_t (Size: 0x4)
SubUVAnimation.SubImages_Vertical = 0x34 // int32_t (Size: 0x4)
SubUVAnimation.BoundingMode = 0x38 // uint8_t (Size: 0x1)
SubUVAnimation.OpacitySourceMode = 0x39 // uint8_t (Size: 0x1)
SubUVAnimation.AlphaThreshold = 0x3c // float (Size: 0x4)
SubsurfaceProfile.Settings = 0x28 // FSubsurfaceProfileStruct (Size: 0x8c)
SubsurfaceProfileStruct.SurfaceAlbedo = 0x0 // FLinearColor (Size: 0x10)
SubsurfaceProfileStruct.MeanFreePathColor = 0x10 // FLinearColor (Size: 0x10)
SubsurfaceProfileStruct.MeanFreePathDistance = 0x20 // float (Size: 0x4)
SubsurfaceProfileStruct.WorldUnitScale = 0x24 // float (Size: 0x4)
SubsurfaceProfileStruct.bEnableBurley = 0x28 // bool (Size: 0x1)
SubsurfaceProfileStruct.ScatterRadius = 0x2c // float (Size: 0x4)
SubsurfaceProfileStruct.SubsurfaceColor = 0x30 // FLinearColor (Size: 0x10)
SubsurfaceProfileStruct.FalloffColor = 0x40 // FLinearColor (Size: 0x10)
SubsurfaceProfileStruct.BoundaryColorBleed = 0x50 // FLinearColor (Size: 0x10)
SubsurfaceProfileStruct.ExtinctionScale = 0x60 // float (Size: 0x4)
SubsurfaceProfileStruct.NormalScale = 0x64 // float (Size: 0x4)
SubsurfaceProfileStruct.ScatteringDistribution = 0x68 // float (Size: 0x4)
SubsurfaceProfileStruct.IOR = 0x6c // float (Size: 0x4)
SubsurfaceProfileStruct.Roughness0 = 0x70 // float (Size: 0x4)
SubsurfaceProfileStruct.Roughness1 = 0x74 // float (Size: 0x4)
SubsurfaceProfileStruct.LobeMix = 0x78 // float (Size: 0x4)
SubsurfaceProfileStruct.TransmissionTintColor = 0x7c // FLinearColor (Size: 0x10)
SubtitleCue.Text = 0x0 // FText (Size: 0x18)
SubtitleCue.Time = 0x18 // float (Size: 0x4)
SupportedSubTrackInfo.SupportedClass = 0x0 // ClassProperty (Size: 0x8)
SupportedSubTrackInfo.SubTrackName = 0x8 // FString (Size: 0x10)
SupportedSubTrackInfo.GroupIndex = 0x18 // int32_t (Size: 0x4)
SwarmDebugOptions.bDistributionEnabled = 0x0 // uint8_t (Size: 0x1)
SwarmDebugOptions.bForceContentExport = 0x0 // uint8_t (Size: 0x1)
SwarmDebugOptions.bInitialized = 0x0 // uint8_t (Size: 0x1)
SystemTimeTimecodeProvider.FrameRate = 0x30 // FFrameRate (Size: 0x8)
SystemTimeTimecodeProvider.bGenerateFullFrame = 0x38 // bool (Size: 0x1)
SystemTimeTimecodeProvider.bUseHighPerformanceClock = 0x39 // bool (Size: 0x1)
TTEventTrack.FunctionName = 0x18 // FName (Size: 0x8)
TTEventTrack.CurveKeys = 0x20 // CurveFloat* (Size: 0x8)
TTFloatTrack.CurveFloat = 0x20 // CurveFloat* (Size: 0x8)
TTLinearColorTrack.CurveLinearColor = 0x20 // CurveLinearColor* (Size: 0x8)
TTPropertyTrack.PropertyName = 0x18 // FName (Size: 0x8)
TTTrackBase.TrackName = 0x8 // FName (Size: 0x8)
TTTrackBase.bIsExternalCurve = 0x10 // bool (Size: 0x1)
TTTrackId.TrackType = 0x0 // int32_t (Size: 0x4)
TTTrackId.TrackIndex = 0x4 // int32_t (Size: 0x4)
TTVectorTrack.CurveVector = 0x20 // CurveVector* (Size: 0x8)
TViewTarget.Target = 0x0 // Actor* (Size: 0x8)
TViewTarget.POV = 0x10 // FMinimalViewInfo (Size: 0x720)
TViewTarget.PlayerState = 0x730 // PlayerState* (Size: 0x8)
TentDistribution.TipAltitude = 0x0 // float (Size: 0x4)
TentDistribution.TipValue = 0x4 // float (Size: 0x4)
TentDistribution.Width = 0x8 // float (Size: 0x4)
TextPropertyTestObject.DefaultedText = 0x28 // FText (Size: 0x18)
TextPropertyTestObject.UndefaultedText = 0x40 // FText (Size: 0x18)
TextPropertyTestObject.TransientText = 0x58 // FText (Size: 0x18)
TextRenderActor.TextRender = 0x310 // TextRenderComponent* (Size: 0x8)
TextRenderComponent.Text = 0x5c8 // FText (Size: 0x18)
TextRenderComponent.TextMaterial = 0x5e0 // MaterialInterface* (Size: 0x8)
TextRenderComponent.Font = 0x5e8 // Font* (Size: 0x8)
TextRenderComponent.HorizontalAlignment = 0x5f0 // uint8_t (Size: 0x1)
TextRenderComponent.VerticalAlignment = 0x5f1 // uint8_t (Size: 0x1)
TextRenderComponent.TextRenderColor = 0x5f4 // FColor (Size: 0x4)
TextRenderComponent.XScale = 0x5f8 // float (Size: 0x4)
TextRenderComponent.YScale = 0x5fc // float (Size: 0x4)
TextRenderComponent.WorldSize = 0x600 // float (Size: 0x4)
TextRenderComponent.InvDefaultSize = 0x604 // float (Size: 0x4)
TextRenderComponent.HorizSpacingAdjust = 0x608 // float (Size: 0x4)
TextRenderComponent.VertSpacingAdjust = 0x60c // float (Size: 0x4)
TextRenderComponent.bAlwaysRenderAsText = 0x610 // uint8_t (Size: 0x1)
TextSizingParameters.DrawX = 0x0 // float (Size: 0x4)
TextSizingParameters.DrawY = 0x4 // float (Size: 0x4)
TextSizingParameters.DrawXL = 0x8 // float (Size: 0x4)
TextSizingParameters.DrawYL = 0xc // float (Size: 0x4)
TextSizingParameters.Scaling = 0x10 // FVector2D (Size: 0x8)
TextSizingParameters.DrawFont = 0x18 // Font* (Size: 0x8)
TextSizingParameters.SpacingAdjust = 0x20 // FVector2D (Size: 0x8)
Texture.LightingGuid = 0x78 // FGuid (Size: 0x10)
Texture.LODBias = 0x88 // int32_t (Size: 0x4)
Texture.MinMipSize = 0x8c // int32_t (Size: 0x4)
Texture.CompressionSettings = 0x90 // uint8_t (Size: 0x1)
Texture.NormalXYChannels = 0x91 // uint8_t (Size: 0x1)
Texture.Filter = 0x92 // uint8_t (Size: 0x1)
Texture.GroupLODBiasLevel = 0x93 // uint8_t (Size: 0x1)
Texture.MipLoadOptions = 0x94 // EETextureMipLoadOptions (Size: 0x1)
Texture.LODGroup = 0x95 // uint8_t (Size: 0x1)
Texture.Downscale = 0x98 // FPerPlatformFloat (Size: 0x4)
Texture.DownscaleOptions = 0x9c // EETextureDownscaleOptions (Size: 0x1)
Texture.SRGB = 0x9d // uint8_t (Size: 0x1)
Texture.bNoTiling = 0x9d // uint8_t (Size: 0x1)
Texture.VirtualTextureStreaming = 0x9d // uint8_t (Size: 0x1)
Texture.CompressionYCoCg = 0x9d // uint8_t (Size: 0x1)
Texture.bNotOfflineProcessed = 0x9d // uint8_t (Size: 0x1)
Texture.bAsyncResourceReleaseHasBeenStarted = 0x9d // uint8_t (Size: 0x1)
Texture.AssetUserData = 0xa0 // TArray<AssetUserData*> (Size: 0x10)
Texture2D.LevelIndex = 0xf0 // int32_t (Size: 0x4)
Texture2D.FirstResourceMemMip = 0xf4 // int32_t (Size: 0x4)
Texture2D.bTemporarilyDisableStreaming = 0xf8 // uint8_t (Size: 0x1)
Texture2D.AddressX = 0xf9 // uint8_t (Size: 0x1)
Texture2D.AddressY = 0xfa // uint8_t (Size: 0x1)
Texture2D.ImportedSize = 0xfc // FIntPoint (Size: 0x8)
Texture2DArray.AddressX = 0x148 // uint8_t (Size: 0x1)
Texture2DArray.AddressY = 0x149 // uint8_t (Size: 0x1)
Texture2DArray.AddressZ = 0x14a // uint8_t (Size: 0x1)
Texture2DDynamic.Format = 0xf8 // uint8_t (Size: 0x1)
TextureFormatSettings.CompressionSettings = 0x0 // uint8_t (Size: 0x1)
TextureFormatSettings.CompressionNoAlpha = 0x1 // uint8_t (Size: 0x1)
TextureFormatSettings.CompressionNone = 0x1 // uint8_t (Size: 0x1)
TextureFormatSettings.CompressionYCoCg = 0x1 // uint8_t (Size: 0x1)
TextureFormatSettings.SRGB = 0x1 // uint8_t (Size: 0x1)
TextureLODGroup.Group = 0x0 // uint8_t (Size: 0x1)
TextureLODGroup.ASTCSizeExpected = 0xc // int32_t (Size: 0x4)
TextureLODGroup.LODBias = 0x10 // int32_t (Size: 0x4)
TextureLODGroup.LODBias_Smaller = 0x14 // int32_t (Size: 0x4)
TextureLODGroup.LODBias_Smallest = 0x18 // int32_t (Size: 0x4)
TextureLODGroup.NumStreamedMips = 0x20 // int32_t (Size: 0x4)
TextureLODGroup.MipGenSettings = 0x24 // uint8_t (Size: 0x1)
TextureLODGroup.MinLODSize = 0x28 // int32_t (Size: 0x4)
TextureLODGroup.MaxLODSize = 0x2c // int32_t (Size: 0x4)
TextureLODGroup.MaxLODSize_Smaller = 0x30 // int32_t (Size: 0x4)
TextureLODGroup.MaxLODSize_Smallest = 0x34 // int32_t (Size: 0x4)
TextureLODGroup.OptionalLODBias = 0x38 // int32_t (Size: 0x4)
TextureLODGroup.OptionalMaxLODSize = 0x3c // int32_t (Size: 0x4)
TextureLODGroup.NoStreamMipCount = 0x44 // int32_t (Size: 0x4)
TextureLODGroup.MinMagFilter = 0x48 // FName (Size: 0x8)
TextureLODGroup.MipFilter = 0x50 // FName (Size: 0x8)
TextureLODGroup.MipLoadOptions = 0x58 // EETextureMipLoadOptions (Size: 0x1)
TextureLODGroup.DuplicateNonOptionalMips = 0x59 // bool (Size: 0x1)
TextureLODGroup.ArrayLODBiasValues = 0x60 // TArray<FTextureLODGroupUseScene> (Size: 0x10)
TextureLODGroup.ExtraBoost = 0x70 // float (Size: 0x4)
TextureLODGroup.Downscale = 0x74 // float (Size: 0x4)
TextureLODGroup.DownscaleOptions = 0x78 // EETextureDownscaleOptions (Size: 0x1)
TextureLODGroup.VirtualTextureTileCountBias = 0x7c // int32_t (Size: 0x4)
TextureLODGroup.VirtualTextureTileSizeBias = 0x80 // int32_t (Size: 0x4)
TextureLODGroupUseScene.ArrayBiasValue = 0x0 // TArray<uint8_t> (Size: 0x10)
TextureLODSettings.TextureLODGroups = 0x28 // TArray<FTextureLODGroup> (Size: 0x10)
TextureLightProfile.Brightness = 0x118 // float (Size: 0x4)
TextureLightProfile.TextureMultiplier = 0x11c // float (Size: 0x4)
TextureParameterValue.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
TextureParameterValue.ParameterValue = 0x10 // Texture* (Size: 0x8)
TextureParameterValue.ExpressionGUID = 0x18 // FGuid (Size: 0x10)
TextureRenderTarget.TargetGamma = 0xf0 // float (Size: 0x4)
TextureRenderTarget2D.SizeX = 0xf8 // int32_t (Size: 0x4)
TextureRenderTarget2D.SizeY = 0xfc // int32_t (Size: 0x4)
TextureRenderTarget2D.ClearColor = 0x100 // FLinearColor (Size: 0x10)
TextureRenderTarget2D.AddressX = 0x110 // uint8_t (Size: 0x1)
TextureRenderTarget2D.AddressY = 0x111 // uint8_t (Size: 0x1)
TextureRenderTarget2D.bForceLinearGamma = 0x112 // uint8_t (Size: 0x1)
TextureRenderTarget2D.bHDR = 0x112 // uint8_t (Size: 0x1)
TextureRenderTarget2D.bGPUSharedFlag = 0x112 // uint8_t (Size: 0x1)
TextureRenderTarget2D.RenderTargetFormat = 0x113 // uint8_t (Size: 0x1)
TextureRenderTarget2D.bAutoGenerateMips = 0x114 // uint8_t (Size: 0x1)
TextureRenderTarget2D.MipsSamplerFilter = 0x115 // uint8_t (Size: 0x1)
TextureRenderTarget2D.MipsAddressU = 0x116 // uint8_t (Size: 0x1)
TextureRenderTarget2D.MipsAddressV = 0x117 // uint8_t (Size: 0x1)
TextureRenderTarget2D.OverrideFormat = 0x118 // uint8_t (Size: 0x1)
TextureRenderTarget2DArray.SizeX = 0xf8 // int32_t (Size: 0x4)
TextureRenderTarget2DArray.SizeY = 0xfc // int32_t (Size: 0x4)
TextureRenderTarget2DArray.Slices = 0x100 // int32_t (Size: 0x4)
TextureRenderTarget2DArray.ClearColor = 0x104 // FLinearColor (Size: 0x10)
TextureRenderTarget2DArray.OverrideFormat = 0x114 // uint8_t (Size: 0x1)
TextureRenderTarget2DArray.bHDR = 0x115 // uint8_t (Size: 0x1)
TextureRenderTarget2DArray.bForceLinearGamma = 0x115 // uint8_t (Size: 0x1)
TextureRenderTargetCube.SizeX = 0xf8 // int32_t (Size: 0x4)
TextureRenderTargetCube.ClearColor = 0xfc // FLinearColor (Size: 0x10)
TextureRenderTargetCube.OverrideFormat = 0x10c // uint8_t (Size: 0x1)
TextureRenderTargetCube.bHDR = 0x10d // uint8_t (Size: 0x1)
TextureRenderTargetCube.bForceLinearGamma = 0x10d // uint8_t (Size: 0x1)
TextureRenderTargetDepth.SizeX = 0xf8 // int32_t (Size: 0x4)
TextureRenderTargetDepth.SizeY = 0xfc // int32_t (Size: 0x4)
TextureRenderTargetDepth.ClearDepth = 0x100 // float (Size: 0x4)
TextureRenderTargetDepth.AddressX = 0x104 // uint8_t (Size: 0x1)
TextureRenderTargetDepth.AddressY = 0x105 // uint8_t (Size: 0x1)
TextureRenderTargetDepth.bGPUSharedFlag = 0x106 // uint8_t (Size: 0x1)
TextureRenderTargetVolume.SizeX = 0xf8 // int32_t (Size: 0x4)
TextureRenderTargetVolume.SizeY = 0xfc // int32_t (Size: 0x4)
TextureRenderTargetVolume.SizeZ = 0x100 // int32_t (Size: 0x4)
TextureRenderTargetVolume.ClearColor = 0x104 // FLinearColor (Size: 0x10)
TextureRenderTargetVolume.OverrideFormat = 0x114 // uint8_t (Size: 0x1)
TextureRenderTargetVolume.bHDR = 0x115 // uint8_t (Size: 0x1)
TextureRenderTargetVolume.bForceLinearGamma = 0x115 // uint8_t (Size: 0x1)
TextureSourceBlock.BlockX = 0x0 // int32_t (Size: 0x4)
TextureSourceBlock.BlockY = 0x4 // int32_t (Size: 0x4)
TextureSourceBlock.SizeX = 0x8 // int32_t (Size: 0x4)
TextureSourceBlock.SizeY = 0xc // int32_t (Size: 0x4)
TextureSourceBlock.NumSlices = 0x10 // int32_t (Size: 0x4)
TextureSourceBlock.NumMips = 0x14 // int32_t (Size: 0x4)
TickFunction.TickGroup = 0x8 // uint8_t (Size: 0x1)
TickFunction.EndTickGroup = 0x9 // uint8_t (Size: 0x1)
TickFunction.TickMode = 0x14 // EESkippableTickMode (Size: 0x1)
TickFunction.bTickEvenWhenPaused = 0x15 // uint8_t (Size: 0x1)
TickFunction.bCanEverTick = 0x15 // uint8_t (Size: 0x1)
TickFunction.bEnableTickOpt = 0x15 // uint8_t (Size: 0x1)
TickFunction.bStartWithTickEnabled = 0x15 // uint8_t (Size: 0x1)
TickFunction.bAllowTickOnDedicatedServer = 0x15 // uint8_t (Size: 0x1)
TickFunction.TickInterval = 0x18 // float (Size: 0x4)
TimeStretchCurve.SamplingRate = 0x0 // float (Size: 0x4)
TimeStretchCurve.CurveValueMinPrecision = 0x4 // float (Size: 0x4)
TimeStretchCurve.Markers = 0x8 // TArray<FTimeStretchCurveMarker> (Size: 0x10)
TimeStretchCurve.Sum_dT_i_by_C_i = 0x18 // float (Size: 0x4)
TimeStretchCurveInstance.bHasValidData = 0x0 // bool (Size: 0x1)
TimeStretchCurveMarker.Time = 0x0 // float (Size: 0x4)
TimeStretchCurveMarker.Alpha = 0xc // float (Size: 0x4)
TimecodeProvider.FrameDelay = 0x28 // float (Size: 0x4)
Timeline.LengthMode = 0x0 // uint8_t (Size: 0x1)
Timeline.bLooping = 0x1 // uint8_t (Size: 0x1)
Timeline.bReversePlayback = 0x1 // uint8_t (Size: 0x1)
Timeline.bPlaying = 0x1 // uint8_t (Size: 0x1)
Timeline.Length = 0x4 // float (Size: 0x4)
Timeline.PlayRate = 0x8 // float (Size: 0x4)
Timeline.position = 0xc // float (Size: 0x4)
Timeline.Events = 0x10 // TArray<FTimelineEventEntry> (Size: 0x10)
Timeline.InterpVectors = 0x20 // TArray<FTimelineVectorTrack> (Size: 0x10)
Timeline.InterpFloats = 0x30 // TArray<FTimelineFloatTrack> (Size: 0x10)
Timeline.InterpLinearColors = 0x40 // TArray<FTimelineLinearColorTrack> (Size: 0x10)
Timeline.TimelinePostUpdateFunc = 0x50 // FDelegate (Size: 0x10)
Timeline.TimelineFinishedFunc = 0x60 // FDelegate (Size: 0x10)
Timeline.PropertySetObject = 0x70 // TWeakObjectPtr<UObject> (Size: 0x8)
Timeline.DirectionPropertyName = 0x78 // FName (Size: 0x8)
TimelineComponent.TheTimeline = 0xf8 // FTimeline (Size: 0x98)
TimelineComponent.bIgnoreTimeDilation = 0x190 // uint8_t (Size: 0x1)
TimelineEventEntry.Time = 0x0 // float (Size: 0x4)
TimelineEventEntry.EventFunc = 0x4 // FDelegate (Size: 0x10)
TimelineFloatTrack.FloatCurve = 0x0 // CurveFloat* (Size: 0x8)
TimelineFloatTrack.InterpFunc = 0x8 // FDelegate (Size: 0x10)
TimelineFloatTrack.TrackName = 0x18 // FName (Size: 0x8)
TimelineFloatTrack.FloatPropertyName = 0x20 // FName (Size: 0x8)
TimelineLinearColorTrack.LinearColorCurve = 0x0 // CurveLinearColor* (Size: 0x8)
TimelineLinearColorTrack.InterpFunc = 0x8 // FDelegate (Size: 0x10)
TimelineLinearColorTrack.TrackName = 0x18 // FName (Size: 0x8)
TimelineLinearColorTrack.LinearColorPropertyName = 0x20 // FName (Size: 0x8)
TimelineTemplate.TimelineLength = 0x28 // float (Size: 0x4)
TimelineTemplate.LengthMode = 0x2c // uint8_t (Size: 0x1)
TimelineTemplate.bAutoPlay = 0x2d // uint8_t (Size: 0x1)
TimelineTemplate.bLoop = 0x2d // uint8_t (Size: 0x1)
TimelineTemplate.bReplicated = 0x2d // uint8_t (Size: 0x1)
TimelineTemplate.bIgnoreTimeDilation = 0x2d // uint8_t (Size: 0x1)
TimelineTemplate.EventTracks = 0x30 // TArray<FTTEventTrack> (Size: 0x10)
TimelineTemplate.FloatTracks = 0x40 // TArray<FTTFloatTrack> (Size: 0x10)
TimelineTemplate.VectorTracks = 0x50 // TArray<FTTVectorTrack> (Size: 0x10)
TimelineTemplate.LinearColorTracks = 0x60 // TArray<FTTLinearColorTrack> (Size: 0x10)
TimelineTemplate.MetaDataArray = 0x70 // TArray<FBPVariableMetaDataEntry> (Size: 0x10)
TimelineTemplate.TimelineGuid = 0x80 // FGuid (Size: 0x10)
TimelineTemplate.VariableName = 0x90 // FName (Size: 0x8)
TimelineTemplate.DirectionPropertyName = 0x98 // FName (Size: 0x8)
TimelineTemplate.UpdateFunctionName = 0xa0 // FName (Size: 0x8)
TimelineTemplate.FinishedFunctionName = 0xa8 // FName (Size: 0x8)
TimelineVectorTrack.VectorCurve = 0x0 // CurveVector* (Size: 0x8)
TimelineVectorTrack.InterpFunc = 0x8 // FDelegate (Size: 0x10)
TimelineVectorTrack.TrackName = 0x18 // FName (Size: 0x8)
TimelineVectorTrack.VectorPropertyName = 0x20 // FName (Size: 0x8)
TimerHandle.Handle = 0x0 // uint64_t (Size: 0x8)
TireType.FrictionScale = 0x30 // float (Size: 0x4)
ToggleTrackKey.Time = 0x0 // float (Size: 0x4)
ToggleTrackKey.ToggleAction = 0x4 // uint8_t (Size: 0x1)
TouchInputControl.Image1 = 0x0 // Texture2D* (Size: 0x8)
TouchInputControl.Image2 = 0x8 // Texture2D* (Size: 0x8)
TouchInputControl.Center = 0x10 // FVector2D (Size: 0x8)
TouchInputControl.VisualSize = 0x18 // FVector2D (Size: 0x8)
TouchInputControl.ThumbSize = 0x20 // FVector2D (Size: 0x8)
TouchInputControl.InteractionSize = 0x28 // FVector2D (Size: 0x8)
TouchInputControl.InputScale = 0x30 // FVector2D (Size: 0x8)
TouchInputControl.MainInputKey = 0x38 // FKey (Size: 0x18)
TouchInputControl.AltInputKey = 0x50 // FKey (Size: 0x18)
TouchInterface.Controls = 0x28 // TArray<FTouchInputControl> (Size: 0x10)
TouchInterface.ActiveOpacity = 0x38 // float (Size: 0x4)
TouchInterface.InactiveOpacity = 0x3c // float (Size: 0x4)
TouchInterface.TimeUntilDeactive = 0x40 // float (Size: 0x4)
TouchInterface.TimeUntilReset = 0x44 // float (Size: 0x4)
TouchInterface.ActivationDelay = 0x48 // float (Size: 0x4)
TouchInterface.bPreventRecenter = 0x4c // bool (Size: 0x1)
TouchInterface.StartupDelay = 0x50 // float (Size: 0x4)
TrackToSkeletonMap.BoneTreeIndex = 0x0 // int32_t (Size: 0x4)
TransformBase.Node = 0x0 // FName (Size: 0x8)
TransformBase.Constraints = 0x8 // FTransformBaseConstraint (Size: 0x10)
TransformBaseConstraint.TransformConstraints = 0x0 // TArray<FRigTransformConstraint> (Size: 0x10)
TransformCurve.TranslationCurve = 0x18 // FVectorCurve (Size: 0x198)
TransformCurve.RotationCurve = 0x1b0 // FVectorCurve (Size: 0x198)
TransformCurve.ScaleCurve = 0x348 // FVectorCurve (Size: 0x198)
TranslationTrack.PosKeys = 0x0 // TArray<FVector> (Size: 0x10)
TranslationTrack.Times = 0x10 // TArray<float> (Size: 0x10)
TriggerBase.CollisionComponent = 0x310 // ShapeComponent* (Size: 0x8)
TwistConstraint.TwistLimitDegrees = 0x14 // float (Size: 0x4)
TwistConstraint.TwistMotion = 0x18 // uint8_t (Size: 0x1)
URL.Protocol = 0x0 // FString (Size: 0x10)
URL.Host = 0x10 // FString (Size: 0x10)
URL.Port = 0x20 // int32_t (Size: 0x4)
URL.Valid = 0x24 // int32_t (Size: 0x4)
URL.Map = 0x28 // FString (Size: 0x10)
URL.RedirectURL = 0x38 // FString (Size: 0x10)
URL.Op = 0x48 // TArray<FString> (Size: 0x10)
URL.Portal = 0x58 // FString (Size: 0x10)
UniqueNetIdRepl.ReplicationBytes = 0x18 // TArray<uint8_t> (Size: 0x10)
UpdateLevelStreamingLevelStatus.PackageName = 0x0 // FName (Size: 0x8)
UpdateLevelStreamingLevelStatus.LODIndex = 0x8 // int32_t (Size: 0x4)
UpdateLevelStreamingLevelStatus.bNewShouldBeLoaded = 0xc // uint8_t (Size: 0x1)
UpdateLevelStreamingLevelStatus.bNewShouldBeVisible = 0xc // uint8_t (Size: 0x1)
UpdateLevelStreamingLevelStatus.bNewShouldBlockOnLoad = 0xc // uint8_t (Size: 0x1)
UpdateLevelVisibilityLevelInfo.PackageName = 0x0 // FName (Size: 0x8)
UpdateLevelVisibilityLevelInfo.Filename = 0x8 // FName (Size: 0x8)
UpdateLevelVisibilityLevelInfo.bIsVisible = 0x10 // uint8_t (Size: 0x1)
UserActivity.ActionName = 0x0 // FString (Size: 0x10)
UserDefinedEnum.DisplayNameMap = 0x60 // TMap<...> (Size: 0x50)
UserDefinedStruct.status = 0xc0 // uint8_t (Size: 0x1)
UserDefinedStruct.Guid = 0xc4 // FGuid (Size: 0x10)
UserInterfaceSettings.RenderFocusRule = 0x38 // EERenderFocusRule (Size: 0x1)
UserInterfaceSettings.HardwareCursors = 0x40 // TMap<...> (Size: 0x50)
UserInterfaceSettings.SoftwareCursors = 0x90 // TMap<...> (Size: 0x50)
UserInterfaceSettings.DefaultCursor = 0xe0 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.TextEditBeamCursor = 0xf8 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.CrosshairsCursor = 0x110 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.HandCursor = 0x128 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.GrabHandCursor = 0x140 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.GrabHandClosedCursor = 0x158 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.SlashedCircleCursor = 0x170 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.ApplicationScale = 0x188 // float (Size: 0x4)
UserInterfaceSettings.UIScaleRule = 0x18c // EEUIScalingRule (Size: 0x1)
UserInterfaceSettings.CustomScalingRuleClass = 0x190 // FSoftClassPath (Size: 0x18)
UserInterfaceSettings.UIScaleCurve = 0x1a8 // FRuntimeFloatCurve (Size: 0x88)
UserInterfaceSettings.bAllowHighDPIInGameMode = 0x230 // bool (Size: 0x1)
UserInterfaceSettings.DesignScreenSize = 0x234 // FIntPoint (Size: 0x8)
UserInterfaceSettings.bLoadWidgetsOnDedicatedServer = 0x23c // bool (Size: 0x1)
UserInterfaceSettings.CursorClasses = 0x240 // TArray<Object*> (Size: 0x10)
UserInterfaceSettings.CustomScalingRuleClassInstance = 0x250 // ClassProperty (Size: 0x8)
UserInterfaceSettings.CustomScalingRule = 0x258 // DPICustomScalingRule* (Size: 0x8)
VOIPTalker.Settings = 0xf8 // FVoiceSettings (Size: 0x18)
VOscillator.X = 0x0 // FFOscillator (Size: 0xc)
VOscillator.Y = 0xc // FFOscillator (Size: 0xc)
VOscillator.Z = 0x18 // FFOscillator (Size: 0xc)
Vector4Distribution.Table = 0x0 // FDistributionLookupTable (Size: 0x20)
VectorCurve.FloatCurves = 0x18 // FRichCurve (Size: 0x80)
VectorDistribution.Table = 0x0 // FDistributionLookupTable (Size: 0x20)
VectorField.Bounds = 0x28 // FBox (Size: 0x1c)
VectorField.Intensity = 0x44 // float (Size: 0x4)
VectorFieldAnimated.Texture = 0x48 // Texture2D* (Size: 0x8)
VectorFieldAnimated.ConstructionOp = 0x50 // uint8_t (Size: 0x1)
VectorFieldAnimated.VolumeSizeX = 0x54 // int32_t (Size: 0x4)
VectorFieldAnimated.VolumeSizeY = 0x58 // int32_t (Size: 0x4)
VectorFieldAnimated.VolumeSizeZ = 0x5c // int32_t (Size: 0x4)
VectorFieldAnimated.SubImagesX = 0x60 // int32_t (Size: 0x4)
VectorFieldAnimated.SubImagesY = 0x64 // int32_t (Size: 0x4)
VectorFieldAnimated.FrameCount = 0x68 // int32_t (Size: 0x4)
VectorFieldAnimated.FramesPerSecond = 0x6c // float (Size: 0x4)
VectorFieldAnimated.bLoop = 0x70 // uint8_t (Size: 0x1)
VectorFieldAnimated.NoiseField = 0x78 // VectorFieldStatic* (Size: 0x8)
VectorFieldAnimated.NoiseScale = 0x80 // float (Size: 0x4)
VectorFieldAnimated.NoiseMax = 0x84 // float (Size: 0x4)
VectorFieldComponent.VectorField = 0x5c8 // VectorField* (Size: 0x8)
VectorFieldComponent.Intensity = 0x5d0 // float (Size: 0x4)
VectorFieldComponent.Tightness = 0x5d4 // float (Size: 0x4)
VectorFieldComponent.bPreviewVectorField = 0x5d8 // uint8_t (Size: 0x1)
VectorFieldStatic.SizeX = 0x48 // int32_t (Size: 0x4)
VectorFieldStatic.SizeY = 0x4c // int32_t (Size: 0x4)
VectorFieldStatic.SizeZ = 0x50 // int32_t (Size: 0x4)
VectorFieldStatic.bAllowCPUAccess = 0x54 // bool (Size: 0x1)
VectorFieldVolume.VectorFieldComponent = 0x310 // VectorFieldComponent* (Size: 0x8)
VectorParameterValue.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
VectorParameterValue.ParameterValue = 0x10 // FLinearColor (Size: 0x10)
VectorParameterValue.ExpressionGUID = 0x20 // FGuid (Size: 0x10)
VectorRK4SpringInterpolator.StiffnessConstant = 0x0 // float (Size: 0x4)
VectorRK4SpringInterpolator.DampeningRatio = 0x4 // float (Size: 0x4)
VertexOffsetUsage.Usage = 0x0 // int32_t (Size: 0x4)
ViewTargetTransitionParams.BlendTime = 0x0 // float (Size: 0x4)
ViewTargetTransitionParams.BlendFunction = 0x4 // uint8_t (Size: 0x1)
ViewTargetTransitionParams.BlendExp = 0x8 // float (Size: 0x4)
ViewTargetTransitionParams.bLockOutgoing = 0xc // uint8_t (Size: 0x1)
VirtualBone.SourceBoneName = 0x0 // FName (Size: 0x8)
VirtualBone.TargetBoneName = 0x8 // FName (Size: 0x8)
VirtualBone.VirtualBoneName = 0x10 // FName (Size: 0x8)
VirtualTexture2D.Settings = 0x118 // FVirtualTextureBuildSettings (Size: 0xc)
VirtualTexture2D.bContinuousUpdate = 0x124 // bool (Size: 0x1)
VirtualTexture2D.bSinglePhysicalSpace = 0x125 // bool (Size: 0x1)
VirtualTextureBuildSettings.TileSize = 0x0 // int32_t (Size: 0x4)
VirtualTextureBuildSettings.TileBorderSize = 0x4 // int32_t (Size: 0x4)
VirtualTextureBuildSettings.bEnableCompressCrunch = 0x8 // bool (Size: 0x1)
VirtualTextureBuildSettings.bEnableCompressZlib = 0x9 // bool (Size: 0x1)
VirtualTextureBuilder.Texture = 0x28 // VirtualTexture2D* (Size: 0x8)
VirtualTextureBuilder.BuildHash = 0x30 // uint64_t (Size: 0x8)
VirtualTexturePoolConfig.DefaultSizeInMegabyte = 0x28 // int32_t (Size: 0x4)
VirtualTexturePoolConfig.Pools = 0x30 // TArray<FVirtualTextureSpacePoolConfig> (Size: 0x10)
VirtualTextureSpacePoolConfig.MinTileSize = 0x0 // int32_t (Size: 0x4)
VirtualTextureSpacePoolConfig.MaxTileSize = 0x4 // int32_t (Size: 0x4)
VirtualTextureSpacePoolConfig.Formats = 0x8 // TArray<uint8_t> (Size: 0x10)
VirtualTextureSpacePoolConfig.SizeInMegabyte = 0x18 // int32_t (Size: 0x4)
VirtualTextureSpacePoolConfig.bAllowSizeScale = 0x1c // bool (Size: 0x1)
VirtualTextureSpacePoolConfig.ScalabilityGroup = 0x20 // uint32_t (Size: 0x4)
VirtualTextureSpacePoolConfig.SizeScales = 0x28 // TArray<float> (Size: 0x10)
VisibilityTrackKey.Time = 0x0 // float (Size: 0x4)
VisibilityTrackKey.Action = 0x4 // uint8_t (Size: 0x1)
VisibilityTrackKey.ActiveCondition = 0x5 // uint8_t (Size: 0x1)
VoiceSettings.ComponentToAttachTo = 0x0 // SceneComponent* (Size: 0x8)
VoiceSettings.AttenuationSettings = 0x8 // SoundAttenuation* (Size: 0x8)
VoiceSettings.SourceEffectChain = 0x10 // SoundEffectSourcePresetChain* (Size: 0x8)
VolumetricCloud.VolumetricCloudComponent = 0x310 // VolumetricCloudComponent* (Size: 0x8)
VolumetricCloudComponent.LayerBottomAltitude = 0x238 // float (Size: 0x4)
VolumetricCloudComponent.LayerHeight = 0x23c // float (Size: 0x4)
VolumetricCloudComponent.TracingStartMaxDistance = 0x240 // float (Size: 0x4)
VolumetricCloudComponent.TracingMaxDistance = 0x244 // float (Size: 0x4)
VolumetricCloudComponent.PlanetRadius = 0x248 // float (Size: 0x4)
VolumetricCloudComponent.GroundAlbedo = 0x24c // FColor (Size: 0x4)
VolumetricCloudComponent.Material = 0x250 // MaterialInterface* (Size: 0x8)
VolumetricCloudComponent.bUsePerSampleAtmosphericLightTransmittance = 0x258 // uint8_t (Size: 0x1)
VolumetricCloudComponent.SkyLightCloudBottomOcclusion = 0x25c // float (Size: 0x4)
VolumetricCloudComponent.ViewSampleCountScale = 0x260 // float (Size: 0x4)
VolumetricCloudComponent.ReflectionSampleCountScale = 0x264 // float (Size: 0x4)
VolumetricCloudComponent.ShadowViewSampleCountScale = 0x268 // float (Size: 0x4)
VolumetricCloudComponent.ShadowReflectionSampleCountScale = 0x26c // float (Size: 0x4)
VolumetricCloudComponent.ShadowTracingDistance = 0x270 // float (Size: 0x4)
VolumetricLightmapDensityVolume.AllowedMipLevelRange = 0x348 // FInt32Interval (Size: 0x8)
WalkableSlopeOverride.WalkableSlopeBehavior = 0x0 // uint8_t (Size: 0x1)
WalkableSlopeOverride.WalkableSlopeAngle = 0x4 // float (Size: 0x4)
WeightedBlendable.Weight = 0x0 // float (Size: 0x4)
WeightedBlendable.Object = 0x8 // Object* (Size: 0x8)
WeightedBlendables.Array = 0x0 // TArray<FWeightedBlendable> (Size: 0x10)
WindDirectionalSource.Component = 0x310 // WindDirectionalSourceComponent* (Size: 0x8)
WindDirectionalSourceComponent.Strength = 0x238 // float (Size: 0x4)
WindDirectionalSourceComponent.Speed = 0x23c // float (Size: 0x4)
WindDirectionalSourceComponent.MinGustAmount = 0x240 // float (Size: 0x4)
WindDirectionalSourceComponent.MaxGustAmount = 0x244 // float (Size: 0x4)
WindDirectionalSourceComponent.Radius = 0x248 // float (Size: 0x4)
WindDirectionalSourceComponent.bPointWind = 0x24c // uint8_t (Size: 0x1)
World.PersistentLevel = 0x30 // Level* (Size: 0x8)
World.NetDriver = 0x38 // NetDriver* (Size: 0x8)
World.LineBatcher = 0x40 // LineBatchComponent* (Size: 0x8)
World.PersistentLineBatcher = 0x48 // LineBatchComponent* (Size: 0x8)
World.ForegroundLineBatcher = 0x50 // LineBatchComponent* (Size: 0x8)
World.NetworkManager = 0x58 // GameNetworkManager* (Size: 0x8)
World.PhysicsCollisionHandler = 0x60 // PhysicsCollisionHandler* (Size: 0x8)
World.ExtraReferencedObjects = 0x68 // TArray<Object*> (Size: 0x10)
World.PerModuleDataObjects = 0x78 // TArray<Object*> (Size: 0x10)
World.StreamingLevels = 0x88 // TArray<LevelStreaming*> (Size: 0x10)
World.StreamingLevelsToConsider = 0x98 // FStreamingLevelsToConsider (Size: 0x28)
World.StreamingLevelsPrefix = 0xc0 // FString (Size: 0x10)
World.CurrentLevelPendingVisibility = 0xd0 // Level* (Size: 0x8)
World.CurrentLevelPendingInvisibility = 0xd8 // Level* (Size: 0x8)
World.DemoNetDriver = 0xe0 // DemoNetDriver* (Size: 0x8)
World.MyParticleEventManager = 0xe8 // ParticleEventManager* (Size: 0x8)
World.DefaultPhysicsVolume = 0xf0 // PhysicsVolume* (Size: 0x8)
World.bAreConstraintsDirty = 0x10e // uint8_t (Size: 0x1)
World.NavigationSystem = 0x110 // NavigationSystemBase* (Size: 0x8)
World.AuthorityGameMode = 0x118 // GameModeBase* (Size: 0x8)
World.GameState = 0x120 // GameStateBase* (Size: 0x8)
World.AISystem = 0x128 // AISystemBase* (Size: 0x8)
World.AvoidanceManager = 0x130 // AvoidanceManager* (Size: 0x8)
World.Levels = 0x138 // TArray<Level*> (Size: 0x10)
World.LevelCollections = 0x148 // TArray<FLevelCollection> (Size: 0x10)
World.OwningGameInstance = 0x180 // GameInstance* (Size: 0x8)
World.ParameterCollectionInstances = 0x188 // TArray<MaterialParameterCollectionInstance*> (Size: 0x10)
World.CanvasForRenderingToTarget = 0x198 // Canvas* (Size: 0x8)
World.CanvasForDrawMaterialToRenderTarget = 0x1a0 // Canvas* (Size: 0x8)
World.VolumeCacheComponents = 0x1f8 // TArray<PrimitiveComponent*> (Size: 0x10)
World.ComponentsThatNeedPreEndOfFrameSync = 0x208 // TSet<...> (Size: 0x50)
World.ComponentsThatNeedEndOfFrameUpdate = 0x258 // TArray<ActorComponent*> (Size: 0x10)
World.ComponentsThatNeedEndOfFrameUpdate_OnGameThread = 0x268 // TArray<ActorComponent*> (Size: 0x10)
World.WorldComposition = 0x688 // WorldComposition* (Size: 0x8)
World.PSCPool = 0x730 // FWorldPSCPool (Size: 0x58)
WorldCollisionGridManagerSubsystem.bInitialized = 0x34b // bool (Size: 0x1)
WorldCollisionGridManagerSubsystem.World = 0x350 // World* (Size: 0x8)
WorldCollisionGridManagerSubsystem.AllowedMaps = 0x358 // TArray<FString> (Size: 0x10)
WorldCollisionGridManagerSubsystem.OverrideGridSizes = 0x368 // TArray<FWorldCollisionOverrideConfig> (Size: 0x10)
WorldCollisionGridManagerSubsystem.OverrideAlwaysCollisionDistances = 0x378 // TArray<FWorldCollisionOverrideConfig> (Size: 0x10)
WorldCollisionGridManagerSubsystem.OverrideShouldConsiderVisibleDistances = 0x388 // TArray<FWorldCollisionOverrideConfig> (Size: 0x10)
WorldCollisionOverrideConfig.Map = 0x0 // FString (Size: 0x10)
WorldCollisionOverrideConfig.Value = 0x10 // int32_t (Size: 0x4)
WorldComposition.TilesStreaming = 0x48 // TArray<LevelStreaming*> (Size: 0x10)
WorldComposition.TilesStreamingTimeThreshold = 0x58 // double (Size: 0x8)
WorldComposition.bLoadAllTilesDuringCinematic = 0x60 // bool (Size: 0x1)
WorldComposition.bRebaseOriginIn3DSpace = 0x61 // bool (Size: 0x1)
WorldComposition.RebaseOriginDistance = 0x64 // float (Size: 0x4)
WorldComposition.bIgnoreRootTiles = 0x68 // bool (Size: 0x1)
WorldContext.LastURL = 0xd0 // FURL (Size: 0x68)
WorldContext.LastRemoteURL = 0x138 // FURL (Size: 0x68)
WorldContext.PendingNetGame = 0x1a0 // PendingNetGame* (Size: 0x8)
WorldContext.PackagesToFullyLoad = 0x1a8 // TArray<FFullyLoadedPackagesInfo> (Size: 0x10)
WorldContext.LoadedLevelsForPendingMapChange = 0x1c8 // TArray<Level*> (Size: 0x10)
WorldContext.ObjectReferencers = 0x1f0 // TArray<ObjectReferencer*> (Size: 0x10)
WorldContext.PendingLevelStreamingStatusUpdates = 0x200 // TArray<FLevelStreamingStatus> (Size: 0x10)
WorldContext.GameViewport = 0x210 // GameViewportClient* (Size: 0x8)
WorldContext.OwningGameInstance = 0x218 // GameInstance* (Size: 0x8)
WorldContext.ActiveNetDrivers = 0x220 // TArray<FNamedNetDriver> (Size: 0x10)
WorldPSCPool.WorldParticleSystemPools = 0x0 // TMap<...> (Size: 0x50)
WorldSettings.VisibilityCellSize = 0x318 // int32_t (Size: 0x4)
WorldSettings.bPHOCUseWorldSettings = 0x31c // bool (Size: 0x1)
WorldSettings.PHOCBucketSize = 0x320 // float (Size: 0x4)
WorldSettings.PHOCCellNumPerBucket = 0x324 // int32_t (Size: 0x4)
WorldSettings.PHOCSubLevelSize = 0x328 // float (Size: 0x4)
WorldSettings.PHOCCellOffset = 0x32c // FVector (Size: 0xc)
WorldSettings.PVSLevelExtendDistance = 0x338 // float (Size: 0x4)
WorldSettings.CellVisibilityBakeExtendDistance = 0x33c // float (Size: 0x4)
WorldSettings.VisibilityAggressiveness = 0x340 // uint8_t (Size: 0x1)
WorldSettings.bPrecomputeVisibility = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bPlaceCellsOnlyAlongCameraTracks = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bEnableWorldBoundsChecks = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bEnableNavigationSystem = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bEnableAISystem = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bEnableWorldComposition = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bEnableDistanceLevelStreaming = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bUseClientSideLevelStreamingVolumes = 0x341 // uint8_t (Size: 0x1)
WorldSettings.bUseStandaloneLevelStreamingVolumes = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bEnableWorldOriginRebasing = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bWorldGravitySet = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bGlobalGravitySet = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bMinimizeBSPSections = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bForceNoPrecomputedLighting = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bHighPriorityLoading = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bHighPriorityLoadingLocal = 0x342 // uint8_t (Size: 0x1)
WorldSettings.bOverrideDefaultBroadphaseSettings = 0x343 // uint8_t (Size: 0x1)
WorldSettings.NavigationSystemConfig = 0x348 // NavigationSystemConfig* (Size: 0x8)
WorldSettings.NavigationSystemConfigOverride = 0x350 // NavigationSystemConfig* (Size: 0x8)
WorldSettings.WorldToMeters = 0x358 // float (Size: 0x4)
WorldSettings.KillZ = 0x35c // float (Size: 0x4)
WorldSettings.KillZDamageType = 0x360 // ClassProperty (Size: 0x8)
WorldSettings.bForceLODsShareStaticLighting = 0x368 // uint8_t (Size: 0x1)
WorldSettings.WorldGravityZ = 0x36c // float (Size: 0x4)
WorldSettings.bEnablePRT = 0x370 // uint8_t (Size: 0x1)
WorldSettings.bVolumeZeroPositionStart = 0x370 // uint8_t (Size: 0x1)
WorldSettings.BakedAORemap = 0x374 // FVector (Size: 0xc)
WorldSettings.GlobalGravityZ = 0x380 // float (Size: 0x4)
WorldSettings.DefaultPhysicsVolumeClass = 0x388 // ClassProperty (Size: 0x8)
WorldSettings.PhysicsCollisionHandlerClass = 0x390 // ClassProperty (Size: 0x8)
WorldSettings.DefaultGameMode = 0x398 // ClassProperty (Size: 0x8)
WorldSettings.GameNetworkManagerClass = 0x3a0 // ClassProperty (Size: 0x8)
WorldSettings.PackedLightAndShadowMapTextureSize = 0x3a8 // int32_t (Size: 0x4)
WorldSettings.DefaultColorScale = 0x3ac // FVector (Size: 0xc)
WorldSettings.DefaultMaxDistanceFieldOcclusionDistance = 0x3b8 // float (Size: 0x4)
WorldSettings.GlobalDistanceFieldViewDistance = 0x3bc // float (Size: 0x4)
WorldSettings.FarGlobalDistanceFieldDistance = 0x3c0 // float (Size: 0x4)
WorldSettings.bDisableDistanceFields = 0x3c4 // bool (Size: 0x1)
WorldSettings.DynamicIndirectShadowsSelfShadowingIntensity = 0x3c8 // float (Size: 0x4)
WorldSettings.HQAdditiveReflectionCubemap = 0x3d0 // IBLPrecomputedDataAsset* (Size: 0x8)
WorldSettings.AdditiveWeight = 0x3d8 // float (Size: 0x4)
WorldSettings.TotalWeight = 0x3dc // float (Size: 0x4)
WorldSettings.DefaultReverbSettings = 0x3e0 // FReverbSettings (Size: 0x20)
WorldSettings.DefaultAmbientZoneSettings = 0x400 // FInteriorSettings (Size: 0x24)
WorldSettings.MonoCullingDistance = 0x424 // float (Size: 0x4)
WorldSettings.DefaultBaseSoundMix = 0x428 // SoundMix* (Size: 0x8)
WorldSettings.TimeDilation = 0x430 // float (Size: 0x4)
WorldSettings.MatineeTimeDilation = 0x434 // float (Size: 0x4)
WorldSettings.DemoPlayTimeDilation = 0x438 // float (Size: 0x4)
WorldSettings.MinGlobalTimeDilation = 0x43c // float (Size: 0x4)
WorldSettings.MaxGlobalTimeDilation = 0x440 // float (Size: 0x4)
WorldSettings.MinUndilatedFrameTime = 0x444 // float (Size: 0x4)
WorldSettings.MaxUndilatedFrameTime = 0x448 // float (Size: 0x4)
WorldSettings.BroadphaseSettings = 0x44c // FBroadphaseSettings (Size: 0x40)
WorldSettings.Pauser = 0x490 // PlayerState* (Size: 0x8)
WorldSettings.ReplicationViewers = 0x498 // TArray<FNetViewer> (Size: 0x10)
WorldSettings.AssetUserData = 0x4a8 // TArray<AssetUserData*> (Size: 0x10)
WorldSettings.PauserPlayerState = 0x4b8 // PlayerState* (Size: 0x8)
WorldSettings.MaxNumberOfBookmarks = 0x4c0 // int32_t (Size: 0x4)
WorldSettings.DefaultBookmarkClass = 0x4c8 // ClassProperty (Size: 0x8)
WorldSettings.BookmarkArray = 0x4d0 // TArray<BookmarkBase*> (Size: 0x10)
WorldSettings.LastBookmarkClass = 0x4e0 // ClassProperty (Size: 0x8)
WrappedStringElement.Value = 0x0 // FString (Size: 0x10)
WrappedStringElement.LineExtent = 0x10 // FVector2D (Size: 0x8)
EngineServiceAuthDeny.userName = 0x0 // FString (Size: 0x10)
EngineServiceAuthDeny.UserToDeny = 0x10 // FString (Size: 0x10)
EngineServiceAuthGrant.userName = 0x0 // FString (Size: 0x10)
EngineServiceAuthGrant.UserToGrant = 0x10 // FString (Size: 0x10)
EngineServiceExecuteCommand.Command = 0x0 // FString (Size: 0x10)
EngineServiceExecuteCommand.userName = 0x10 // FString (Size: 0x10)
EngineServiceNotification.Text = 0x0 // FString (Size: 0x10)
EngineServiceNotification.TimeSeconds = 0x10 // double (Size: 0x8)
EngineServicePong.CurrentLevel = 0x0 // FString (Size: 0x10)
EngineServicePong.EngineVersion = 0x10 // int32_t (Size: 0x4)
EngineServicePong.HasBegunPlay = 0x14 // bool (Size: 0x1)
EngineServicePong.InstanceId = 0x18 // FGuid (Size: 0x10)
EngineServicePong.InstanceType = 0x28 // FString (Size: 0x10)
EngineServicePong.SessionId = 0x38 // FGuid (Size: 0x10)
EngineServicePong.WorldTimeSeconds = 0x48 // float (Size: 0x4)
EngineServiceTerminate.userName = 0x0 // FString (Size: 0x10)
AutoCompleteCommand.Command = 0x0 // FString (Size: 0x10)
AutoCompleteCommand.desc = 0x10 // FString (Size: 0x10)
ConsoleSettings.MaxScrollbackSize = 0x28 // int32_t (Size: 0x4)
ConsoleSettings.ManualAutoCompleteList = 0x30 // TArray<FAutoCompleteCommand> (Size: 0x10)
ConsoleSettings.AutoCompleteMapPaths = 0x40 // TArray<FString> (Size: 0x10)
ConsoleSettings.BackgroundOpacityPercentage = 0x50 // float (Size: 0x4)
ConsoleSettings.bOrderTopToBottom = 0x54 // bool (Size: 0x1)
ConsoleSettings.bDisplayHelpInAutoComplete = 0x55 // bool (Size: 0x1)
ConsoleSettings.InputColor = 0x58 // FColor (Size: 0x4)
ConsoleSettings.HistoryColor = 0x5c // FColor (Size: 0x4)
ConsoleSettings.AutoCompleteCommandColor = 0x60 // FColor (Size: 0x4)
ConsoleSettings.AutoCompleteCVarColor = 0x64 // FColor (Size: 0x4)
ConsoleSettings.AutoCompleteFadedColor = 0x68 // FColor (Size: 0x4)
GameMapsSettings.LocalMapOptions = 0x28 // FString (Size: 0x10)
GameMapsSettings.TransitionMap = 0x38 // FSoftObjectPath (Size: 0x18)
GameMapsSettings.bUseSplitscreen = 0x50 // bool (Size: 0x1)
GameMapsSettings.TwoPlayerSplitscreenLayout = 0x51 // uint8_t (Size: 0x1)
GameMapsSettings.ThreePlayerSplitscreenLayout = 0x52 // uint8_t (Size: 0x1)
GameMapsSettings.FourPlayerSplitscreenLayout = 0x53 // EEFourPlayerSplitScreenType (Size: 0x1)
GameMapsSettings.bOffsetPlayerGamepadIds = 0x54 // bool (Size: 0x1)
GameMapsSettings.GameInstanceClass = 0x58 // FSoftClassPath (Size: 0x18)
GameMapsSettings.GameDefaultMap = 0x70 // FSoftObjectPath (Size: 0x18)
GameMapsSettings.ServerDefaultMap = 0x88 // FSoftObjectPath (Size: 0x18)
GameMapsSettings.GlobalDefaultGameMode = 0xa0 // FSoftClassPath (Size: 0x18)
GameMapsSettings.GlobalDefaultServerGameMode = 0xb8 // FSoftClassPath (Size: 0x18)
GameMapsSettings.GameModeMapPrefixes = 0xd0 // TArray<FGameModeName> (Size: 0x10)
GameMapsSettings.GameModeClassAliases = 0xe0 // TArray<FGameModeName> (Size: 0x10)
GameModeName.Name = 0x0 // FString (Size: 0x10)
GameModeName.GameMode = 0x10 // FSoftClassPath (Size: 0x18)
GameNetworkManagerSettings.MinDynamicBandwidth = 0x28 // int32_t (Size: 0x4)
GameNetworkManagerSettings.MaxDynamicBandwidth = 0x2c // int32_t (Size: 0x4)
GameNetworkManagerSettings.TotalNetBandwidth = 0x30 // int32_t (Size: 0x4)
GameNetworkManagerSettings.BadPingThreshold = 0x34 // int32_t (Size: 0x4)
GameNetworkManagerSettings.bIsStandbyCheckingEnabled = 0x38 // uint8_t (Size: 0x1)
GameNetworkManagerSettings.StandbyRxCheatTime = 0x3c // float (Size: 0x4)
GameNetworkManagerSettings.StandbyTxCheatTime = 0x40 // float (Size: 0x4)
GameNetworkManagerSettings.PercentMissingForRxStandby = 0x44 // float (Size: 0x4)
GameNetworkManagerSettings.PercentMissingForTxStandby = 0x48 // float (Size: 0x4)
GameNetworkManagerSettings.PercentForBadPing = 0x4c // float (Size: 0x4)
GameNetworkManagerSettings.JoinInProgressStandbyWaitTime = 0x50 // float (Size: 0x4)
GameSessionSettings.MaxSpectators = 0x28 // int32_t (Size: 0x4)
GameSessionSettings.MaxPlayers = 0x2c // int32_t (Size: 0x4)
GameSessionSettings.bRequiresPushToTalk = 0x30 // uint8_t (Size: 0x1)
GeneralProjectSettings.CompanyName = 0x28 // FString (Size: 0x10)
GeneralProjectSettings.CompanyDistinguishedName = 0x38 // FString (Size: 0x10)
GeneralProjectSettings.CopyrightNotice = 0x48 // FString (Size: 0x10)
GeneralProjectSettings.Description = 0x58 // FString (Size: 0x10)
GeneralProjectSettings.Homepage = 0x68 // FString (Size: 0x10)
GeneralProjectSettings.LicensingTerms = 0x78 // FString (Size: 0x10)
GeneralProjectSettings.PrivacyPolicy = 0x88 // FString (Size: 0x10)
GeneralProjectSettings.ProjectID = 0x98 // FGuid (Size: 0x10)
GeneralProjectSettings.ProjectName = 0xa8 // FString (Size: 0x10)
GeneralProjectSettings.ProjectVersion = 0xb8 // FString (Size: 0x10)
GeneralProjectSettings.SupportContact = 0xc8 // FString (Size: 0x10)
GeneralProjectSettings.ProjectDisplayedTitle = 0xd8 // FText (Size: 0x18)
GeneralProjectSettings.ProjectDebugTitleInfo = 0xf0 // FText (Size: 0x18)
GeneralProjectSettings.bShouldWindowPreserveAspectRatio = 0x108 // bool (Size: 0x1)
GeneralProjectSettings.bUseBorderlessWindow = 0x109 // bool (Size: 0x1)
GeneralProjectSettings.bStartInVR = 0x10a // bool (Size: 0x1)
GeneralProjectSettings.bAllowWindowResize = 0x10b // bool (Size: 0x1)
GeneralProjectSettings.bAllowClose = 0x10c // bool (Size: 0x1)
GeneralProjectSettings.bAllowMaximize = 0x10d // bool (Size: 0x1)
GeneralProjectSettings.bAllowMinimize = 0x10e // bool (Size: 0x1)
HudSettings.bShowHUD = 0x28 // uint8_t (Size: 0x1)
HudSettings.DebugDisplay = 0x30 // TArray<FName> (Size: 0x10)
EyeTrackerGazeData.GazeOrigin = 0x0 // FVector (Size: 0xc)
EyeTrackerGazeData.GazeDirection = 0xc // FVector (Size: 0xc)
EyeTrackerGazeData.FixationPoint = 0x18 // FVector (Size: 0xc)
EyeTrackerGazeData.ConfidenceValue = 0x24 // float (Size: 0x4)
EyeTrackerStereoGazeData.LeftEyeOrigin = 0x0 // FVector (Size: 0xc)
EyeTrackerStereoGazeData.LeftEyeDirection = 0xc // FVector (Size: 0xc)
EyeTrackerStereoGazeData.RightEyeOrigin = 0x18 // FVector (Size: 0xc)
EyeTrackerStereoGazeData.RightEyeDirection = 0x24 // FVector (Size: 0xc)
EyeTrackerStereoGazeData.FixationPoint = 0x30 // FVector (Size: 0xc)
EyeTrackerStereoGazeData.ConfidenceValue = 0x3c // float (Size: 0x4)
FFXFSR3Settings.bEnabled = 0x38 // bool (Size: 0x1)
FFXFSR3Settings.bAutoExposure = 0x39 // bool (Size: 0x1)
FFXFSR3Settings.bEnabledInEditorViewport = 0x3a // bool (Size: 0x1)
FFXFSR3Settings.bUseSSRExperimentalDenoiser = 0x3b // bool (Size: 0x1)
FFXFSR3Settings.bRHIBackend = 0x3c // bool (Size: 0x1)
FFXFSR3Settings.bD3D12Backend = 0x40 // int32_t (Size: 0x4)
FFXFSR3Settings.bFrameGenEnabled = 0x44 // bool (Size: 0x1)
FFXFSR3Settings.bCustomPresent = 0x45 // bool (Size: 0x1)
FFXFSR3Settings.bCaptureDebugUI = 0x46 // bool (Size: 0x1)
FFXFSR3Settings.bUpdateGlobalFrameTime = 0x47 // bool (Size: 0x1)
FFXFSR3Settings.bModifySlateDeltaTime = 0x48 // bool (Size: 0x1)
FFXFSR3Settings.UIMode = 0x4c // EEFFXFSR3FrameGenUIMode (Size: 0x4)
FFXFSR3Settings.bUseDistortionTexture = 0x50 // bool (Size: 0x1)
FFXFSR3Settings.bD3D12AsyncInterpolation = 0x51 // bool (Size: 0x1)
FFXFSR3Settings.bD3D12AsyncPresent = 0x52 // bool (Size: 0x1)
FFXFSR3Settings.PaceMode = 0x54 // EEFFXFSR3PaceRHIFrameMode (Size: 0x4)
FFXFSR3Settings.QualityMode = 0x58 // EEFFXFSR3QualityMode (Size: 0x4)
FFXFSR3Settings.HistoryFormat = 0x5c // EEFFXFSR3HistoryFormat (Size: 0x4)
FFXFSR3Settings.DeDither = 0x60 // EEFFXFSR3DeDitherMode (Size: 0x4)
FFXFSR3Settings.Sharpness = 0x64 // float (Size: 0x4)
FFXFSR3Settings.bAdjustMipBias = 0x68 // bool (Size: 0x1)
FFXFSR3Settings.bForceVertexDeformationOutputsVelocity = 0x69 // bool (Size: 0x1)
FFXFSR3Settings.ForceLandscapeHISMMobility = 0x6c // EEFFXFSR3LandscapeHISMMode (Size: 0x4)
FFXFSR3Settings.VelocityFactor = 0x70 // float (Size: 0x4)
FFXFSR3Settings.bReactiveMask = 0x74 // bool (Size: 0x1)
FFXFSR3Settings.ReflectionScale = 0x78 // float (Size: 0x4)
FFXFSR3Settings.ReflectionLuminanceBias = 0x7c // float (Size: 0x4)
FFXFSR3Settings.RoughnessScale = 0x80 // float (Size: 0x4)
FFXFSR3Settings.RoughnessBias = 0x84 // float (Size: 0x4)
FFXFSR3Settings.RoughnessMaxDistance = 0x88 // float (Size: 0x4)
FFXFSR3Settings.bReactiveMaskRoughnessForceMaxDistance = 0x8c // bool (Size: 0x1)
FFXFSR3Settings.TranslucencyBias = 0x90 // float (Size: 0x4)
FFXFSR3Settings.TranslucencyLuminanceBias = 0x94 // float (Size: 0x4)
FFXFSR3Settings.TranslucencyMaxDistance = 0x98 // float (Size: 0x4)
FFXFSR3Settings.ReactiveShadingModelID = 0x9c // uint8_t (Size: 0x1)
FFXFSR3Settings.ForceReactiveMaterialValue = 0xa0 // float (Size: 0x4)
FFXFSR3Settings.ReactiveHistoryTranslucencyBias = 0xa4 // float (Size: 0x4)
FFXFSR3Settings.ReactiveHistoryTranslucencyLumaBias = 0xa8 // float (Size: 0x4)
FFXFSR3Settings.PreDOFTranslucencyScale = 0xac // float (Size: 0x4)
FFXFSR3Settings.bPreDOFTranslucencyMax = 0xb0 // bool (Size: 0x1)
FFXFSR3Settings.ReactiveMaskDeferredDecalScale = 0xb4 // float (Size: 0x4)
FFXFSR3Settings.ReactiveHistoryDeferredDecalScale = 0xb8 // float (Size: 0x4)
FFXFSR3Settings.ReactiveMaskTAAResponsiveValue = 0xbc // float (Size: 0x4)
FFXFSR3Settings.ReactiveHistoryTAAResponsiveValue = 0xc0 // float (Size: 0x4)
FFXFSR3Settings.ReactiveMaskCustomStencilScale = 0xc4 // float (Size: 0x4)
FFXFSR3Settings.ReactiveHistoryCustomStencilScale = 0xc8 // float (Size: 0x4)
FFXFSR3Settings.CustomStencilMask = 0xcc // int32_t (Size: 0x4)
FFXFSR3Settings.CustomStencilShift = 0xd0 // int32_t (Size: 0x4)
FSR2Settings.bEnabled = 0x38 // bool (Size: 0x1)
FSR2Settings.AutoExposure = 0x39 // bool (Size: 0x1)
FSR2Settings.EnabledInEditorViewport = 0x3a // bool (Size: 0x1)
FSR2Settings.UseSSRExperimentalDenoiser = 0x3b // bool (Size: 0x1)
FSR2Settings.UseNativeDX12 = 0x3c // bool (Size: 0x1)
FSR2Settings.UseNativeVulkan = 0x3d // bool (Size: 0x1)
FSR2Settings.QualityMode = 0x40 // EEFSR2QualityMode (Size: 0x4)
FSR2Settings.HistoryFormat = 0x44 // EEFSR2HistoryFormat (Size: 0x4)
FSR2Settings.Sharpness = 0x48 // float (Size: 0x4)
FSR2Settings.AdjustMipBias = 0x4c // bool (Size: 0x1)
FSR2Settings.ReactiveMask = 0x4d // bool (Size: 0x1)
FSR2Settings.ForceVertexDeformationOutputsVelocity = 0x4e // bool (Size: 0x1)
FSR2Settings.ReflectionScale = 0x50 // float (Size: 0x4)
FSR2Settings.ReflectionLuminanceBias = 0x54 // float (Size: 0x4)
FSR2Settings.RoughnessScale = 0x58 // float (Size: 0x4)
FSR2Settings.RoughnessBias = 0x5c // float (Size: 0x4)
FSR2Settings.RoughnessMaxDistance = 0x60 // float (Size: 0x4)
FSR2Settings.ReactiveMaskRoughnessForceMaxDistance = 0x64 // bool (Size: 0x1)
FSR2Settings.TranslucencyBias = 0x68 // float (Size: 0x4)
FSR2Settings.TranslucencyLuminanceBias = 0x6c // float (Size: 0x4)
FSR2Settings.TranslucencyMaxDistance = 0x70 // float (Size: 0x4)
FSR2Settings.PreDOFTranslucencyScale = 0x74 // float (Size: 0x4)
FSR2Settings.PreDOFTranslucencyMax = 0x78 // bool (Size: 0x1)
AnimNode_FacialAction.SourcePose = 0x10 // FPoseLink (Size: 0x10)
AnimNode_FacialAction.AuCurves = 0x20 // FacialAnimationCurves* (Size: 0x8)
BlinkCurveConfig.MinIntervalTime = 0x0 // float (Size: 0x4)
BlinkCurveConfig.MaxIntervalTime = 0x4 // float (Size: 0x4)
BlinkCurveConfig.FadeInTime = 0x8 // float (Size: 0x4)
BlinkCurveConfig.FadeOutTime = 0xc // float (Size: 0x4)
BlinkCurveConfig.MaxWeight = 0x10 // float (Size: 0x4)
BlinkCurveConfig.AlwaysBlink = 0x14 // bool (Size: 0x1)
FacialActionConfig.ImportPhoneme = 0x28 // bool (Size: 0x1)
FacialActionConfig.ImportAudioSlice = 0x29 // bool (Size: 0x1)
FacialActionConfig.ImportEmotionTag = 0x2a // bool (Size: 0x1)
FacialActionConfig.ImportHeadMovement = 0x2b // bool (Size: 0x1)
FacialActionConfig.DefaultModelConfig = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
FacialAnimMetaData.EyeSize = 0x28 // float (Size: 0x4)
FacialAnimationData.HeadMovementScale = 0x30 // float (Size: 0x4)
FacialAnimationData.BrowMovementScale = 0x34 // float (Size: 0x4)
FacialAnimationData.GenerateBlink = 0x38 // bool (Size: 0x1)
FacialAnimationData.DefaultTag = 0x3c // FName (Size: 0x8)
FacialAnimationData.DefaultTagTagWeight = 0x44 // float (Size: 0x4)
FacialAnimationData.Phonemes = 0x48 // TArray<FFacialPhonemeItem> (Size: 0x10)
FacialAnimationData.Slices = 0x58 // TArray<FFacialAudioSlice> (Size: 0x10)
FacialAnimationData.HeadMovements = 0x68 // TArray<FFacialHeadMovementPoint> (Size: 0x10)
FacialAnimationData.OriginTags = 0x78 // TArray<FFacialEmotionTag> (Size: 0x10)
FacialAnimationData.EmotionTags = 0x88 // TArray<FFacialEmotionTag> (Size: 0x10)
FacialAnimationData.SoundName = 0x98 // FString (Size: 0x10)
FacialAudioSlice.StartTime = 0x0 // float (Size: 0x4)
FacialAudioSlice.EndTime = 0x4 // float (Size: 0x4)
FacialBakeOption.FacialBakeType = 0x28 // EEFacialBakeType (Size: 0x1)
FacialBakeOption.Config = 0x30 // FFacialGeneratorConfig (Size: 0x18)
FacialControllerAttributeItem.pose = 0x0 // FName (Size: 0x8)
FacialControllerAttributeItem.Weight = 0x8 // float (Size: 0x4)
FacialControllerAttributeItem.jawOpen = 0xc // float (Size: 0x4)
FacialControllerAttributeItem.blinkScale = 0x10 // float (Size: 0x4)
FacialControllerItem.auGroup = 0x0 // FName (Size: 0x8)
FacialControllerItem.auGroupNeg = 0x8 // FName (Size: 0x8)
FacialControllerItem.Attributes = 0x10 // TArray<FFacialControllerAttributeItem> (Size: 0x10)
FacialEmotionPADItem.Weights = 0x0 // TMap<...> (Size: 0x50)
FacialEmotionTag.StartTime = 0x0 // float (Size: 0x4)
FacialEmotionTag.EndTime = 0x4 // float (Size: 0x4)
FacialEmotionTag.Name = 0x8 // FName (Size: 0x8)
FacialEmotionTag.Weight = 0x10 // float (Size: 0x4)
FacialEmotionWeightItem.emotionName = 0x0 // FName (Size: 0x8)
FacialEmotionWeightItem.Weight = 0x8 // float (Size: 0x4)
FacialGeneratorConfig.modelConfig = 0x0 // FacialModelConfig* (Size: 0x8)
FacialGeneratorConfig.subModelConfig = 0x8 // FacialSubModelConfig* (Size: 0x8)
FacialGeneratorConfig.generateHeadCurves = 0x10 // bool (Size: 0x1)
FacialGeneratorConfig.generateBlinkCurves = 0x11 // bool (Size: 0x1)
FacialHeadMovementPoint.Time = 0x0 // float (Size: 0x4)
FacialHeadMovementPoint.HeadPitch = 0x4 // float (Size: 0x4)
FacialHeadMovementPoint.HeadYaw = 0x8 // float (Size: 0x4)
FacialHeadMovementPoint.HeadRoll = 0xc // float (Size: 0x4)
FacialHeadMovementPoint.BrowUp = 0x10 // float (Size: 0x4)
FacialModelConfig.paramsConfig = 0x30 // FFacialModelParamsConfig (Size: 0xf8)
FacialModelConfig.speedConfig = 0x128 // TMap<...> (Size: 0x50)
FacialModelConfig.toleranceConfig = 0x178 // TMap<...> (Size: 0x50)
FacialModelConfig.phonemeToVisemeMapping = 0x1c8 // TMap<...> (Size: 0x50)
FacialModelConfig.visemeRemapping = 0x218 // TMap<...> (Size: 0x50)
FacialModelConfig.tagToEmotionTable = 0x268 // TMap<...> (Size: 0x50)
FacialModelConfig.emotionPADTable = 0x2b8 // TMap<...> (Size: 0x50)
FacialModelParamsConfig.AUChangeSpeedScale = 0x0 // float (Size: 0x4)
FacialModelParamsConfig.LazyIteration = 0x4 // int32_t (Size: 0x4)
FacialModelParamsConfig.SpeedLimitIteration = 0x8 // int32_t (Size: 0x4)
FacialModelParamsConfig.TrembleIteration = 0xc // int32_t (Size: 0x4)
FacialModelParamsConfig.SmoothLerpPosition = 0x10 // float (Size: 0x4)
FacialModelParamsConfig.AUJawOpen = 0x14 // FName (Size: 0x8)
FacialModelParamsConfig.JawOpenValue = 0x1c // float (Size: 0x4)
FacialModelParamsConfig.AUJawOpen2 = 0x20 // FName (Size: 0x8)
FacialModelParamsConfig.JawOpenValue2 = 0x28 // float (Size: 0x4)
FacialModelParamsConfig.BreathTime = 0x2c // float (Size: 0x4)
FacialModelParamsConfig.BreathValue = 0x30 // float (Size: 0x4)
FacialModelParamsConfig.MaxVisemeDensity = 0x34 // float (Size: 0x4)
FacialModelParamsConfig.FadeOutCurvePower = 0x38 // float (Size: 0x4)
FacialModelParamsConfig.FadeInCurvePower = 0x3c // float (Size: 0x4)
FacialModelParamsConfig.AUFadeOutTimeScale = 0x40 // float (Size: 0x4)
FacialModelParamsConfig.TimeOffset = 0x44 // float (Size: 0x4)
FacialModelParamsConfig.AUChangeSpeed = 0x48 // TMap<...> (Size: 0x50)
FacialModelParamsConfig.AUFadeOutTime = 0x98 // TMap<...> (Size: 0x50)
FacialModelParamsConfig.DominantVisemes = 0xe8 // TArray<FName> (Size: 0x10)
FacialPhonemeItem.Name = 0x0 // FName (Size: 0x8)
FacialPhonemeItem.StartTime = 0x8 // float (Size: 0x4)
FacialPhonemeItem.EndTime = 0xc // float (Size: 0x4)
FacialSpeedConfigItem.changeSpeed = 0x0 // float (Size: 0x4)
FacialSpeedConfigItem.FadeOutTime = 0x4 // float (Size: 0x4)
FacialSubModelConfig.controllerConfig = 0x30 // TMap<...> (Size: 0x50)
FacialSubModelConfig.lipWeightTable = 0x80 // TMap<...> (Size: 0x50)
FacialSubModelConfig.emotionWeightTable = 0xd0 // TMap<...> (Size: 0x50)
FacialTagToEmotionItem.emotions = 0x0 // TArray<FFacialEmotionWeightItem> (Size: 0x10)
FacialTagToEmotionItem.FadeInTime = 0x10 // float (Size: 0x4)
FacialTagToEmotionItem.FadeOutTime = 0x14 // float (Size: 0x4)
FacialToleranceConfigItem.toleranceValues = 0x0 // TMap<...> (Size: 0x50)
FacialVisemeMappingItems.visemes = 0x0 // TArray<FName> (Size: 0x10)
FacialWeightConfigItem.weightValues = 0x0 // TMap<...> (Size: 0x50)
FalconISMBatchingKey.StaticMesh = 0x0 // StaticMesh* (Size: 0x8)
FalconISMBatchingKey.Materials = 0x8 // TArray<MaterialInterface*> (Size: 0x10)
FalconISMBatchingKey.Level = 0x18 // Level* (Size: 0x8)
FalconISMBatchingKey.CollisionProfile = 0x20 // FName (Size: 0x8)
FalconISMBatchingKey.bNegativeDeterminant = 0x28 // bool (Size: 0x1)
FalconISMBatchingKey.bCastShadow = 0x29 // bool (Size: 0x1)
FalconISMBatchingKey.DetailMode = 0x2a // uint8_t (Size: 0x1)
FalconISMBatchingKey.bOverrideLightmapRes = 0x2b // bool (Size: 0x1)
FalconISMBatchingKey.OverrideLightmapRes = 0x2c // int32_t (Size: 0x4)
FalconISMBatchingKey.CenterPoint = 0x30 // FVector (Size: 0xc)
FalconISMBatchingKey.bHasCenterPoint = 0x3c // bool (Size: 0x1)
FalconISMBatchingKey.OriginalSMCPaths = 0x40 // TArray<FString> (Size: 0x10)
FalconISMBatchingKeyComponent.Key = 0x238 // FFalconISMBatchingKey (Size: 0x50)
FalconISMBatchingParam.bEnable = 0x0 // bool (Size: 0x1)
FalconISMBatchingParam.ExcludeStaticMeshPathRegex = 0x8 // FString (Size: 0x10)
FalconISMBatchingParam.MinInstancesCount = 0x18 // int32_t (Size: 0x4)
FalconISMBatchingParam.bSupportRuntimeBatchUnbatch = 0x1c // bool (Size: 0x1)
FalconISMBatchingParam.BatchCellSize = 0x20 // float (Size: 0x4)
FalconISMBatchingParam.BoundsMaxMultiplier = 0x24 // float (Size: 0x4)
FalconISMBatchingParam.BoundsSphereMaxRadius = 0x28 // float (Size: 0x4)
FalconISMBatchingSMHideMeta.bCastShadow = 0x0 // bool (Size: 0x1)
FalconISMBatchingSMHideMetaComponent.Meta = 0x238 // FFalconISMBatchingSMHideMeta (Size: 0x1)
FalconISMBatchingSettings.MapBatchingParams = 0x38 // TMap<...> (Size: 0x50)
FalconISMBatchingStrategyTK.BatchCellSize = 0x28 // float (Size: 0x4)
FalconISMBatchingStrategyTK.BoundsMaxMultiplier = 0x2c // float (Size: 0x4)
FalconISMBatchingStrategyTK.BoundsSphereMaxRadius = 0x30 // float (Size: 0x4)
FalconPlacementToolPolygonRigidbody.Location = 0x0 // FVector (Size: 0xc)
FalconPlacementToolPolygonRigidbody.Rotation = 0xc // FRotator (Size: 0xc)
FalconPlacementToolPolygonRigidbody.Velocity = 0x18 // FVector (Size: 0xc)
FalconPlacementToolPolygonRigidbody.AngularVelocity = 0x24 // FVector (Size: 0xc)
FalconPlacementToolPolygonRigidbody.BoundMin = 0x30 // FVector (Size: 0xc)
FalconPlacementToolPolygonRigidbody.BoundMax = 0x3c // FVector (Size: 0xc)
FalconPlacementToolPolygonRigidbody.SDFTexture = 0x48 // VolumeTexture* (Size: 0x8)
FalconPlacementToolPolygonRigidbody.SMActor = 0x50 // TWeakObjectPtr<UObject> (Size: 0x8)
FalconPlacementToolSimulationUtil.WorldScale = 0x70 // FVector (Size: 0xc)
FalconPlacementToolSimulationUtil.GridSize = 0x7c // int32_t (Size: 0x4)
FalconPlacementToolSimulationUtil.ManualTime = 0x80 // float (Size: 0x4)
FalconPlacementToolSimulationUtil.MinCFLTime = 0x84 // float (Size: 0x4)
FalconPlacementToolSimulationUtil.DebugMipmaps = 0x88 // int32_t (Size: 0x4)
FalconPlacementToolSimulationUtil.OutputMaskRT = 0x8c // TWeakObjectPtr<UObject> (Size: 0x8)
FalconPlacementToolSimulationUtil.OutputHeightRT = 0x94 // TWeakObjectPtr<UObject> (Size: 0x8)
FalconPlacementToolSimulationUtil.bDebug = 0x9c // bool (Size: 0x1)
FalconPlacementToolSimulationUtil.DebugGridRT = 0xa0 // TextureRenderTarget2D* (Size: 0x8)
FalconPlacementToolSimulationUtil.DebugInitHeightField = 0xa8 // TextureRenderTarget2D* (Size: 0x8)
FalconPlacementToolSimulationUtil.DebugVelocity = 0xb0 // TextureRenderTarget2D* (Size: 0x8)
FalconPlacementToolSimulationUtil.DebugCFLLimit = 0xb8 // TextureRenderTarget2D* (Size: 0x8)
FalconPlacementToolSimulationUtil.LandscapeHeightField = 0xc0 // TWeakObjectPtr<UObject> (Size: 0x8)
FalconPlacementToolSimulationUtil.ThicknessField = 0xc8 // TWeakObjectPtr<UObject> (Size: 0x8)
FalconPlacementToolSimulationUtil.SphereRigidbodies = 0xd0 // TArray<FFalconPlacementToolSphereRigidbody> (Size: 0x10)
FalconPlacementToolSimulationUtil.PolygonRigidbodies = 0xe0 // TArray<FFalconPlacementToolPolygonRigidbody> (Size: 0x10)
FalconPlacementToolSimulationUtil.FrictionAngle = 0xf0 // float (Size: 0x4)
FalconPlacementToolSimulationUtil.DragForce = 0xf4 // float (Size: 0x4)
FalconPlacementToolSimulationUtil.OutputMaskDatas = 0xf8 // TArray<float> (Size: 0x10)
FalconPlacementToolSimulationUtil.Thickness = 0x108 // float (Size: 0x4)
FalconPlacementToolSphereRigidbody.Location = 0x0 // FVector (Size: 0xc)
FalconPlacementToolSphereRigidbody.Velocity = 0xc // FVector (Size: 0xc)
FalconPlacementToolSphereRigidbody.AngularVelocity = 0x18 // FVector (Size: 0xc)
FalconPlacementToolSphereRigidbody.Radius = 0x24 // float (Size: 0x4)
FalconRTAllocation.Texture = 0x0 // TextureRenderTarget2D* (Size: 0x8)
FalconRTAllocation.BasePoint = 0x8 // FIntPoint (Size: 0x8)
FalconRingVertex.position = 0x0 // FVector (Size: 0xc)
FalconSparseRTMask.BaseValue = 0x28 // uint8_t (Size: 0x1)
FalconSparseRTMask.BlockSize = 0x2c // int32_t (Size: 0x4)
FalconSparseRTMask.XYtoAllocationMap = 0x30 // TMap<...> (Size: 0x50)
Scatter3DPattern.PointCloud = 0x0 // TArray<FVector> (Size: 0x10)
Scatter3DPattern.Size = 0x10 // FVector (Size: 0xc)
FalconMapRunnerAsset.Body = 0x28 // FFalconMapRunnerBody (Size: 0x30)
FalconMapRunnerBody.Points = 0x0 // TArray<FVector> (Size: 0x10)
FalconMapRunnerBody.Quats = 0x10 // TArray<FQuat> (Size: 0x10)
FalconMapRunnerBody.Times = 0x20 // TArray<float> (Size: 0x10)
FalconMapRunnerContext.bPIE = 0x0 // bool (Size: 0x1)
FalconMapRunnerContext.DebugCameraController = 0x4 // TWeakObjectPtr<UObject> (Size: 0x8)
FalconMapRunnerContext.PlayerController = 0xc // TWeakObjectPtr<UObject> (Size: 0x8)
FalconMapRunnerContext.status = 0x14 // EEFalconMapRunnerStatus (Size: 0x1)
FalconMapRunnerContext.Asset = 0x18 // FalconMapRunnerAsset* (Size: 0x8)
FalconMapRunnerContext.I0 = 0x20 // int32_t (Size: 0x4)
FalconMapRunnerContext.RecordDistance = 0x24 // int32_t (Size: 0x4)
FalconMapRunnerContext.RecordInterval = 0x28 // int32_t (Size: 0x4)
FalconMapRunnerContext.RecordTimeCurr = 0x2c // float (Size: 0x4)
FalconMapRunnerContext.ServiceStats = 0x30 // TArray<FString> (Size: 0x10)
FalconMapRunnerContext.DumpPath = 0x40 // FString (Size: 0x10)
FalconMapRunnerScreenshot.Data = 0x0 // TArray<FColor> (Size: 0x10)
FalconMapRunnerScreenshot.Filename = 0x10 // FString (Size: 0x10)
FalconMapRunnerSettings.RecordName = 0x28 // FName (Size: 0x8)
FalconMapRunnerSettings.Record = 0x30 // bool (Size: 0x1)
FalconMapRunnerSettings.Run = 0x31 // bool (Size: 0x1)
FalconMapRunnerSettings.Debug = 0x32 // bool (Size: 0x1)
FalconMapRunnerSubsystem.OpMode = 0x30 // EEFalconMapRunnerOpMode (Size: 0x1)
FalconMapRunnerSubsystem.AssetMap = 0x38 // TMap<...> (Size: 0x50)
FalconMapRunnerSubsystem.Context = 0x88 // FFalconMapRunnerContext (Size: 0x68)
FalconMapRunnerSubsystem.Service = 0xf0 // FalconMapRunnerServiceBase* (Size: 0x8)
FalconPrefabActor.FalconPrefabComponent = 0x310 // FalconPrefabComponent* (Size: 0x8)
FalconPrefabActor.bUnlinkChild = 0x318 // bool (Size: 0x1)
FalconPrefabActor.bSupportVertexColor = 0x319 // bool (Size: 0x1)
FalconPrefabActor.ExportLevel = 0x320 // TSoftObjectPtr<UObject> (Size: 0x28)
FalconPrefabActor.SnapTargetActor = 0x348 // TLazyObjectPtr<UObject> (Size: 0x1c)
FalconPrefabActor.BoundMax = 0x364 // FVector (Size: 0xc)
FalconPrefabActor.BoundMin = 0x370 // FVector (Size: 0xc)
FalconPrefabActor.bShowDir = 0x37c // bool (Size: 0x1)
FalconPrefabActor.ArrowLoc = 0x380 // FVector (Size: 0xc)
FalconPrefabActor.ArrowDir = 0x38c // FVector (Size: 0xc)
FalconPrefabActor.ArrowLength = 0x398 // float (Size: 0x4)
FalconPrefabActor.LastUpdateID = 0x39c // FGuid (Size: 0x10)
FalconPrefabActor.Seed = 0x3ac // int32_t (Size: 0x4)
FalconPrefabActor.bDirty = 0x3b0 // bool (Size: 0x1)
FalconPrefabActor.ChildrenActors = 0x3b8 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
FalconPrefabComponent.PrefabAssetInterface = 0x5f0 // TSoftObjectPtr<UObject> (Size: 0x28)
BoxFalloff.Magnitude = 0xf8 // float (Size: 0x4)
BoxFalloff.MinRange = 0xfc // float (Size: 0x4)
BoxFalloff.MaxRange = 0x100 // float (Size: 0x4)
BoxFalloff.Default = 0x104 // float (Size: 0x4)
BoxFalloff.Transform = 0x110 // FTransform (Size: 0x30)
BoxFalloff.Falloff = 0x140 // uint8_t (Size: 0x1)
CullingField.Culling = 0xf8 // FieldNodeBase* (Size: 0x8)
CullingField.Field = 0x100 // FieldNodeBase* (Size: 0x8)
CullingField.Operation = 0x108 // uint8_t (Size: 0x1)
FieldSystemActor.FieldSystemComponent = 0x310 // FieldSystemComponent* (Size: 0x8)
FieldSystemComponent.FieldSystem = 0x5c8 // FieldSystem* (Size: 0x8)
FieldSystemComponent.SupportedSolvers = 0x5e0 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
FieldSystemMetaDataIteration.Iterations = 0xf8 // int32_t (Size: 0x4)
FieldSystemMetaDataProcessingResolution.ResolutionType = 0xf8 // uint8_t (Size: 0x1)
NoiseField.MinRange = 0xf8 // float (Size: 0x4)
NoiseField.MaxRange = 0xfc // float (Size: 0x4)
NoiseField.Transform = 0x100 // FTransform (Size: 0x30)
OperatorField.Magnitude = 0xf8 // float (Size: 0x4)
OperatorField.RightField = 0x100 // FieldNodeBase* (Size: 0x8)
OperatorField.LeftField = 0x108 // FieldNodeBase* (Size: 0x8)
OperatorField.Operation = 0x110 // uint8_t (Size: 0x1)
PlaneFalloff.Magnitude = 0xf8 // float (Size: 0x4)
PlaneFalloff.MinRange = 0xfc // float (Size: 0x4)
PlaneFalloff.MaxRange = 0x100 // float (Size: 0x4)
PlaneFalloff.Default = 0x104 // float (Size: 0x4)
PlaneFalloff.Distance = 0x108 // float (Size: 0x4)
PlaneFalloff.position = 0x10c // FVector (Size: 0xc)
PlaneFalloff.Normal = 0x118 // FVector (Size: 0xc)
PlaneFalloff.Falloff = 0x124 // uint8_t (Size: 0x1)
RadialFalloff.Magnitude = 0xf8 // float (Size: 0x4)
RadialFalloff.MinRange = 0xfc // float (Size: 0x4)
RadialFalloff.MaxRange = 0x100 // float (Size: 0x4)
RadialFalloff.Default = 0x104 // float (Size: 0x4)
RadialFalloff.Radius = 0x108 // float (Size: 0x4)
RadialFalloff.position = 0x10c // FVector (Size: 0xc)
RadialFalloff.Falloff = 0x118 // uint8_t (Size: 0x1)
RadialIntMask.Radius = 0xf8 // float (Size: 0x4)
RadialIntMask.position = 0xfc // FVector (Size: 0xc)
RadialIntMask.InteriorValue = 0x108 // int32_t (Size: 0x4)
RadialIntMask.ExteriorValue = 0x10c // int32_t (Size: 0x4)
RadialIntMask.SetMaskCondition = 0x110 // uint8_t (Size: 0x1)
RadialVector.Magnitude = 0xf8 // float (Size: 0x4)
RadialVector.position = 0xfc // FVector (Size: 0xc)
RandomVector.Magnitude = 0xf8 // float (Size: 0x4)
ToFloatField.IntField = 0xf8 // FieldNodeInt* (Size: 0x8)
ToIntegerField.FloatField = 0xf8 // FieldNodeFloat* (Size: 0x8)
UniformInteger.Magnitude = 0xf8 // int32_t (Size: 0x4)
UniformScalar.Magnitude = 0xf8 // float (Size: 0x4)
UniformVector.Magnitude = 0xf8 // float (Size: 0x4)
UniformVector.Direction = 0xfc // FVector (Size: 0xc)
FoliageInstancedStaticMeshComponent.OnInstanceTakePointDamage = 0x840 // FMulticastInlineDelegate (Size: 0x10)
FoliageInstancedStaticMeshComponent.OnInstanceTakeRadialDamage = 0x850 // FMulticastInlineDelegate (Size: 0x10)
FoliageInstancedStaticMeshComponent.GenerationGuid = 0x860 // FGuid (Size: 0x10)
FoliageType.UpdateGuid = 0x28 // FGuid (Size: 0x10)
FoliageType.Density = 0x38 // float (Size: 0x4)
FoliageType.DensityAdjustmentFactor = 0x3c // float (Size: 0x4)
FoliageType.Radius = 0x40 // float (Size: 0x4)
FoliageType.bSingleInstanceModeOverrideRadius = 0x44 // bool (Size: 0x1)
FoliageType.SingleInstanceModeRadius = 0x48 // float (Size: 0x4)
FoliageType.Scaling = 0x4c // EEFoliageScaling (Size: 0x1)
FoliageType.ScaleX = 0x50 // FFloatInterval (Size: 0x8)
FoliageType.ScaleY = 0x58 // FFloatInterval (Size: 0x8)
FoliageType.ScaleZ = 0x60 // FFloatInterval (Size: 0x8)
FoliageType.VertexColorMaskByChannel = 0x68 // FFoliageVertexColorChannelMask (Size: 0xc)
FoliageType.VertexColorMask = 0x98 // uint8_t (Size: 0x1)
FoliageType.VertexColorMaskThreshold = 0x9c // float (Size: 0x4)
FoliageType.VertexColorMaskInvert = 0xa0 // uint8_t (Size: 0x1)
FoliageType.ZOffset = 0xa4 // FFloatInterval (Size: 0x8)
FoliageType.AlignToNormal = 0xac // uint8_t (Size: 0x1)
FoliageType.AlignMaxAngle = 0xb0 // float (Size: 0x4)
FoliageType.RandomYaw = 0xb4 // uint8_t (Size: 0x1)
FoliageType.RandomPitchAngle = 0xb8 // float (Size: 0x4)
FoliageType.GroundSlopeAngle = 0xbc // FFloatInterval (Size: 0x8)
FoliageType.Height = 0xc4 // FFloatInterval (Size: 0x8)
FoliageType.LandscapeLayers = 0xd0 // TArray<FName> (Size: 0x10)
FoliageType.MinimumLayerWeight = 0xe0 // float (Size: 0x4)
FoliageType.ExclusionLandscapeLayers = 0xe8 // TArray<FName> (Size: 0x10)
FoliageType.MinimumExclusionLayerWeight = 0xf8 // float (Size: 0x4)
FoliageType.LandscapeLayer = 0xfc // FName (Size: 0x8)
FoliageType.CollisionWithWorld = 0x104 // uint8_t (Size: 0x1)
FoliageType.CollisionScale = 0x108 // FVector (Size: 0xc)
FoliageType.MeshBounds = 0x114 // FBoxSphereBounds (Size: 0x1c)
FoliageType.LowBoundOriginRadius = 0x130 // FVector (Size: 0xc)
FoliageType.bReMergeInstancing = 0x13c // uint8_t (Size: 0x1)
FoliageType.ShadowCaptureLayer = 0x140 // EEShadowCaptureLayer (Size: 0x1)
FoliageType.bHiddenShadowOnShadowCapture = 0x141 // uint8_t (Size: 0x1)
FoliageType.Mobility = 0x142 // uint8_t (Size: 0x1)
FoliageType.CullDistance = 0x144 // FInt32Interval (Size: 0x8)
FoliageType.bEnableStaticLighting = 0x14c // uint8_t (Size: 0x1)
FoliageType.CastShadow = 0x14c // uint8_t (Size: 0x1)
FoliageType.bAffectDynamicIndirectLighting = 0x14c // uint8_t (Size: 0x1)
FoliageType.bAffectDistanceFieldLighting = 0x14c // uint8_t (Size: 0x1)
FoliageType.bCastDynamicShadow = 0x14c // uint8_t (Size: 0x1)
FoliageType.bCastStaticShadow = 0x14c // uint8_t (Size: 0x1)
FoliageType.bCastShadowAsTwoSided = 0x14c // uint8_t (Size: 0x1)
FoliageType.bCastDFShadow = 0x14c // uint8_t (Size: 0x1)
FoliageType.bCSMCacheForceEnable = 0x150 // uint8_t (Size: 0x1)
FoliageType.bReceivesDecals = 0x154 // uint8_t (Size: 0x1)
FoliageType.bOverrideLightmapRes = 0x154 // uint8_t (Size: 0x1)
FoliageType.OverriddenLightMapRes = 0x158 // int32_t (Size: 0x4)
FoliageType.LightmapType = 0x15c // EELightmapType (Size: 0x1)
FoliageType.IndirectLightingCacheQuality = 0x15d // uint8_t (Size: 0x1)
FoliageType.bForceUseSkyLightAsDiffuseGI = 0x160 // uint8_t (Size: 0x1)
FoliageType.bUseAsOccluder = 0x160 // uint8_t (Size: 0x1)
FoliageType.BodyInstance = 0x168 // FBodyInstance (Size: 0x158)
FoliageType.CustomNavigableGeometry = 0x2c0 // uint8_t (Size: 0x1)
FoliageType.LightingChannels = 0x2c1 // FLightingChannels (Size: 0x1)
FoliageType.bRenderCustomDepth = 0x2c4 // uint8_t (Size: 0x1)
FoliageType.CustomDepthStencilWriteMask = 0x2c8 // EERendererStencilMask (Size: 0x1)
FoliageType.CustomDepthStencilValue = 0x2cc // int32_t (Size: 0x4)
FoliageType.TranslucencySortPriority = 0x2d0 // int32_t (Size: 0x4)
FoliageType.CollisionRadius = 0x2d4 // float (Size: 0x4)
FoliageType.ShadeRadius = 0x2d8 // float (Size: 0x4)
FoliageType.NumSteps = 0x2dc // int32_t (Size: 0x4)
FoliageType.InitialSeedDensity = 0x2e0 // float (Size: 0x4)
FoliageType.AverageSpreadDistance = 0x2e4 // float (Size: 0x4)
FoliageType.SpreadVariance = 0x2e8 // float (Size: 0x4)
FoliageType.SeedsPerStep = 0x2ec // int32_t (Size: 0x4)
FoliageType.DistributionSeed = 0x2f0 // int32_t (Size: 0x4)
FoliageType.MaxInitialSeedOffset = 0x2f4 // float (Size: 0x4)
FoliageType.bCanGrowInShade = 0x2f8 // bool (Size: 0x1)
FoliageType.bSpawnsInShade = 0x2f9 // bool (Size: 0x1)
FoliageType.MaxInitialAge = 0x2fc // float (Size: 0x4)
FoliageType.MaxAge = 0x300 // float (Size: 0x4)
FoliageType.OverlapPriority = 0x304 // float (Size: 0x4)
FoliageType.ProceduralScale = 0x308 // FFloatInterval (Size: 0x8)
FoliageType.ScaleCurve = 0x310 // FRuntimeFloatCurve (Size: 0x88)
FoliageType.ChangeCount = 0x398 // int32_t (Size: 0x4)
FoliageType.ReapplyDensity = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyRadius = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyAlignToNormal = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyRandomYaw = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyScaling = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyScaleX = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyScaleY = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyScaleZ = 0x39c // uint8_t (Size: 0x1)
FoliageType.ReapplyRandomPitchAngle = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyGroundSlope = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyHeight = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyLandscapeLayers = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyZOffset = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyCollisionWithWorld = 0x39d // uint8_t (Size: 0x1)
FoliageType.ReapplyVertexColorMask = 0x39d // uint8_t (Size: 0x1)
FoliageType.bEnableDensityScaling = 0x39d // uint8_t (Size: 0x1)
FoliageType.bEnableDiscardOnLoad = 0x39e // uint8_t (Size: 0x1)
FoliageType.RuntimeVirtualTextures = 0x3a0 // TArray<RuntimeVirtualTexture*> (Size: 0x10)
FoliageType.VirtualTextureCullMips = 0x3b0 // int32_t (Size: 0x4)
FoliageType.VirtualTextureRenderPassType = 0x3b4 // EERuntimeVirtualTextureMainPassType (Size: 0x1)
FoliageTypeObject.FoliageTypeObject = 0x0 // Object* (Size: 0x8)
FoliageTypeObject.TypeInstance = 0x8 // FoliageType* (Size: 0x8)
FoliageTypeObject.bIsAsset = 0x10 // bool (Size: 0x1)
FoliageTypeObject.Type = 0x18 // ClassProperty (Size: 0x8)
FoliageType_Actor.ActorClass = 0x3b8 // ClassProperty (Size: 0x8)
FoliageType_Actor.bShouldAttachToBaseComponent = 0x3c0 // bool (Size: 0x1)
FoliageType_InstancedStaticMesh.Mesh = 0x3b8 // StaticMesh* (Size: 0x8)
FoliageType_InstancedStaticMesh.OverrideMaterials = 0x3c0 // TArray<MaterialInterface*> (Size: 0x10)
FoliageType_InstancedStaticMesh.ComponentClass = 0x3d0 // ClassProperty (Size: 0x8)
FoliageVertexColorChannelMask.UseMask = 0x0 // uint8_t (Size: 0x1)
FoliageVertexColorChannelMask.MaskThreshold = 0x4 // float (Size: 0x4)
FoliageVertexColorChannelMask.InvertMask = 0x8 // uint8_t (Size: 0x1)
InteractiveFoliageActor.CapsuleComponent = 0x320 // CapsuleComponent* (Size: 0x8)
InteractiveFoliageActor.TouchingActorEntryPosition = 0x328 // FVector (Size: 0xc)
InteractiveFoliageActor.FoliageVelocity = 0x334 // FVector (Size: 0xc)
InteractiveFoliageActor.FoliageForce = 0x340 // FVector (Size: 0xc)
InteractiveFoliageActor.FoliagePosition = 0x34c // FVector (Size: 0xc)
InteractiveFoliageActor.FoliageDamageImpulseScale = 0x358 // float (Size: 0x4)
InteractiveFoliageActor.FoliageTouchImpulseScale = 0x35c // float (Size: 0x4)
InteractiveFoliageActor.FoliageStiffness = 0x360 // float (Size: 0x4)
InteractiveFoliageActor.FoliageStiffnessQuadratic = 0x364 // float (Size: 0x4)
InteractiveFoliageActor.FoliageDamping = 0x368 // float (Size: 0x4)
InteractiveFoliageActor.MaxDamageImpulse = 0x36c // float (Size: 0x4)
InteractiveFoliageActor.MaxTouchImpulse = 0x370 // float (Size: 0x4)
InteractiveFoliageActor.MaxForce = 0x374 // float (Size: 0x4)
InteractiveFoliageActor.Mass = 0x378 // float (Size: 0x4)
ProceduralFoliageBlockingVolume.ProceduralFoliageVolume = 0x348 // ProceduralFoliageVolume* (Size: 0x8)
ProceduralFoliageComponent.FoliageSpawner = 0xf8 // ProceduralFoliageSpawner* (Size: 0x8)
ProceduralFoliageComponent.TileOverlap = 0x100 // float (Size: 0x4)
ProceduralFoliageComponent.SpawningVolume = 0x108 // Volume* (Size: 0x8)
ProceduralFoliageComponent.ProceduralGuid = 0x110 // FGuid (Size: 0x10)
ProceduralFoliageInstance.Rotation = 0x0 // FQuat (Size: 0x10)
ProceduralFoliageInstance.Location = 0x10 // FVector (Size: 0xc)
ProceduralFoliageInstance.Age = 0x1c // float (Size: 0x4)
ProceduralFoliageInstance.Normal = 0x20 // FVector (Size: 0xc)
ProceduralFoliageInstance.Scale = 0x2c // float (Size: 0x4)
ProceduralFoliageInstance.Type = 0x30 // FoliageType* (Size: 0x8)
ProceduralFoliageSpawner.RandomSeed = 0x28 // int32_t (Size: 0x4)
ProceduralFoliageSpawner.TileSize = 0x2c // float (Size: 0x4)
ProceduralFoliageSpawner.NumUniqueTiles = 0x30 // int32_t (Size: 0x4)
ProceduralFoliageSpawner.MinimumQuadTreeSize = 0x34 // float (Size: 0x4)
ProceduralFoliageSpawner.FoliageTypes = 0x40 // TArray<FFoliageTypeObject> (Size: 0x10)
ProceduralFoliageTile.FoliageSpawner = 0x28 // ProceduralFoliageSpawner* (Size: 0x8)
ProceduralFoliageTile.InstancesArray = 0xd0 // TArray<FProceduralFoliageInstance> (Size: 0x10)
ProceduralFoliageVolume.ProceduralComponent = 0x348 // ProceduralFoliageComponent* (Size: 0x8)
AnimNode_FollicleBoneDriver.TargetBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_FollicleBoneDriver.ExcludedBones = 0xe0 // TArray<FBoneReference> (Size: 0x10)
AnimNode_FollicleBoneDriver.bUseAttachedParent = 0xf0 // bool (Size: 0x1)
AnimNode_FollicleBoneDriver.bUseSelfMesh = 0xf1 // bool (Size: 0x1)
AnimNode_FollicleBoneDriver.TargetSectionIndex = 0xf4 // int32_t (Size: 0x4)
BoneWeightData.BoneIndex = 0x0 // int32_t (Size: 0x4)
BoneWeightData.Weight = 0x4 // float (Size: 0x4)
BoneWeightData.BindPose = 0x10 // FTransform (Size: 0x30)
FollicleAnimInstance.RootBoneName = 0x2b8 // FName (Size: 0x8)
FollicleAnimInstance.bDebugDraw = 0x2c0 // bool (Size: 0x1)
FollicleAnimInstance.OutBoneRelativeLocation = 0x2c4 // FVector (Size: 0xc)
FollicleAnimInstance.OutBoneRelativeRotation = 0x2d0 // FRotator (Size: 0xc)
G6LuaScriptManager.bIsGCLock = 0x28 // bool (Size: 0x1)
DebugConsole.OnCustomConsoleCommandCommit = 0x38 // FMulticastInlineDelegate (Size: 0x10)
DebugConsole.OnErrorMessageReceived = 0x48 // FMulticastInlineDelegate (Size: 0x10)
DebugConsole.OnNewMessageReceived = 0x58 // FMulticastInlineDelegate (Size: 0x10)
G6LogicStepProcessor.m_Cur_Running_LogicStep = 0x38 // G6LogicStep* (Size: 0x8)
G6PlatformGameInstance.DebugConsole = 0x28 // DebugConsole* (Size: 0x8)
G6PlatformGameInstance.Profiler = 0x30 // G6CustomScriptStatProfiler* (Size: 0x8)
G6PlatformGameInstance.bUseG6OnlineSession = 0x50 // bool (Size: 0x1)
G6PlatformGameInstance.LogicStepProcessor = 0x70 // G6LogicStepProcessor* (Size: 0x8)
G6PlatformGameInstanceManager.mContainer = 0x28 // TMap<...> (Size: 0x50)
GLTFCameraActor.Mode = 0x9d0 // EEGLTFCameraControlMode (Size: 0x1)
GLTFCameraActor.Target = 0x9d8 // Actor* (Size: 0x8)
GLTFCameraActor.PitchAngleMin = 0x9e0 // float (Size: 0x4)
GLTFCameraActor.PitchAngleMax = 0x9e4 // float (Size: 0x4)
GLTFCameraActor.YawAngleMin = 0x9e8 // float (Size: 0x4)
GLTFCameraActor.YawAngleMax = 0x9ec // float (Size: 0x4)
GLTFCameraActor.DistanceMin = 0x9f0 // float (Size: 0x4)
GLTFCameraActor.DistanceMax = 0x9f4 // float (Size: 0x4)
GLTFCameraActor.DollyDuration = 0x9f8 // float (Size: 0x4)
GLTFCameraActor.DollySensitivity = 0x9fc // float (Size: 0x4)
GLTFCameraActor.RotationInertia = 0xa00 // float (Size: 0x4)
GLTFCameraActor.RotationSensitivity = 0xa04 // float (Size: 0x4)
GLTFHotspotActor.SkeletalMeshActor = 0x310 // SkeletalMeshActor* (Size: 0x8)
GLTFHotspotActor.AnimationSequence = 0x318 // AnimSequence* (Size: 0x8)
GLTFHotspotActor.LevelSequence = 0x320 // LevelSequence* (Size: 0x8)
GLTFHotspotActor.Image = 0x328 // Texture2D* (Size: 0x8)
GLTFHotspotActor.HoveredImage = 0x330 // Texture2D* (Size: 0x8)
GLTFHotspotActor.ToggledImage = 0x338 // Texture2D* (Size: 0x8)
GLTFHotspotActor.ToggledHoveredImage = 0x340 // Texture2D* (Size: 0x8)
GLTFHotspotActor.BillboardComponent = 0x348 // MaterialBillboardComponent* (Size: 0x8)
GLTFHotspotActor.SphereComponent = 0x350 // SphereComponent* (Size: 0x8)
GLTFHotspotActor.DefaultMaterial = 0x358 // MaterialInterface* (Size: 0x8)
GLTFHotspotActor.DefaultImage = 0x360 // Texture2D* (Size: 0x8)
GLTFHotspotActor.DefaultHoveredImage = 0x368 // Texture2D* (Size: 0x8)
GLTFHotspotActor.DefaultToggledImage = 0x370 // Texture2D* (Size: 0x8)
GLTFHotspotActor.DefaultToggledHoveredImage = 0x378 // Texture2D* (Size: 0x8)
GLTFHotspotActor.DefaultIconMaterial = 0x380 // MaterialInterface* (Size: 0x8)
GLTFHotspotActor.ActiveImage = 0x388 // Texture* (Size: 0x8)
GLTFHotspotActor.LevelSequencePlayer = 0x390 // LevelSequencePlayer* (Size: 0x8)
GLTFMaterialExportOptions.Default = 0x28 // FGLTFOverrideMaterialBakeSettings (Size: 0x6)
GLTFMaterialExportOptions.Inputs = 0x30 // TMap<...> (Size: 0x50)
GLTFOverrideMaterialBakeSettings.bOverrideSize = 0x0 // bool (Size: 0x1)
GLTFOverrideMaterialBakeSettings.Size = 0x1 // EEGLTFMaterialBakeSizePOT (Size: 0x1)
GLTFOverrideMaterialBakeSettings.bOverrideFilter = 0x2 // bool (Size: 0x1)
GLTFOverrideMaterialBakeSettings.Filter = 0x3 // uint8_t (Size: 0x1)
GLTFOverrideMaterialBakeSettings.bOverrideTiling = 0x4 // bool (Size: 0x1)
GLTFOverrideMaterialBakeSettings.Tiling = 0x5 // uint8_t (Size: 0x1)
BP_GameJoyPluginLibrary.onGameJoyEvent = 0x38 // FMulticastInlineDelegate (Size: 0x10)
INTLFrameInfo.Path = 0x0 // FString (Size: 0x10)
INTLFrameInfo.Md5 = 0x10 // FString (Size: 0x10)
INTLFrameInfo.Size = 0x20 // int32_t (Size: 0x4)
INTLUserData.GameId = 0x0 // int32_t (Size: 0x4)
INTLUserData.ChannelID = 0x8 // FString (Size: 0x10)
INTLUserData.Openid = 0x18 // FString (Size: 0x10)
INTLUserData.Token = 0x28 // FString (Size: 0x10)
INTLUserData.RoleId = 0x38 // FString (Size: 0x10)
INTLUserData.Region = 0x48 // FString (Size: 0x10)
INTLUserData.AreaID = 0x58 // int32_t (Size: 0x4)
INTLUserData.ZoneId = 0x5c // int32_t (Size: 0x4)
INTLUserData.Os = 0x60 // int32_t (Size: 0x4)
INTLUserData.LangType = 0x68 // FString (Size: 0x10)
INTLUserData.DefLangType = 0x78 // FString (Size: 0x10)
INTLUserData.RoleName = 0x88 // FString (Size: 0x10)
INTLUserData.PayToken = 0x98 // FString (Size: 0x10)
INTLUserData.HeadUrl = 0xa8 // FString (Size: 0x10)
INTLUserData.PlayerLevel = 0xb8 // FString (Size: 0x10)
INTLUserData.AppVersion = 0xc8 // FString (Size: 0x10)
INTLUserData.extraJson = 0xd8 // FString (Size: 0x10)
GameletMatBrush.MatInstance = 0x38 // MaterialInstanceDynamic* (Size: 0x8)
GameletPuertsEnvMgr.OnPostMessage = 0x28 // FMulticastInlineDelegate (Size: 0x10)
GameletSettings.OnSDKMessage = 0x28 // FDelegate (Size: 0x10)
GameletSettings.OnRefreshUserdata = 0x38 // FDelegate (Size: 0x10)
GameletSettings.OnViewCreated = 0x48 // FDelegate (Size: 0x10)
GameletSettings.OnViewAboutToDestroy = 0x58 // FDelegate (Size: 0x10)
GameletSettings.OnReportData = 0x68 // FDelegate (Size: 0x10)
GameletSettings.OnProfileJSSDKMessage = 0x78 // FDelegate (Size: 0x10)
GameletSettings.DisableJsErrReport = 0x88 // bool (Size: 0x1)
GameletSettings.DisableGetBackTrace = 0x89 // bool (Size: 0x1)
GameletSettings.DelayWndCallMsg = 0x8a // bool (Size: 0x1)
GameletSettings.SupportUseEngineFont = 0x8b // bool (Size: 0x1)
GameletSettings.UseSRGB = 0x8c // bool (Size: 0x1)
GameletTypeScriptGeneratedClass.HasConstructor = 0x3c1 // bool (Size: 0x1)
AbilityEndedData.AbilityThatEnded = 0x0 // GameplayAbility* (Size: 0x8)
AbilityEndedData.AbilitySpecHandle = 0x8 // FGameplayAbilitySpecHandle (Size: 0x4)
AbilityEndedData.bReplicateEndAbility = 0xc // bool (Size: 0x1)
AbilityEndedData.bWasCancelled = 0xd // bool (Size: 0x1)
AbilitySystemComponent.DefaultStartingData = 0x178 // TArray<FAttributeDefaults> (Size: 0x10)
AbilitySystemComponent.SpawnedAttributes = 0x188 // TArray<AttributeSet*> (Size: 0x10)
AbilitySystemComponent.AffectedAnimInstanceTag = 0x198 // FName (Size: 0x8)
AbilitySystemComponent.OutgoingDuration = 0x338 // float (Size: 0x4)
AbilitySystemComponent.IncomingDuration = 0x33c // float (Size: 0x4)
AbilitySystemComponent.ClientDebugStrings = 0x360 // TArray<FString> (Size: 0x10)
AbilitySystemComponent.ServerDebugStrings = 0x370 // TArray<FString> (Size: 0x10)
AbilitySystemComponent.UserAbilityActivationInhibited = 0x3d8 // bool (Size: 0x1)
AbilitySystemComponent.ReplicationProxyEnabled = 0x3d9 // bool (Size: 0x1)
AbilitySystemComponent.bSuppressGrantAbility = 0x3da // bool (Size: 0x1)
AbilitySystemComponent.bSuppressGameplayCues = 0x3db // bool (Size: 0x1)
AbilitySystemComponent.SpawnedTargetActors = 0x3e0 // TArray<GameplayAbilityTargetActor*> (Size: 0x10)
AbilitySystemComponent.OwnerActor = 0x418 // Actor* (Size: 0x8)
AbilitySystemComponent.AvatarActor = 0x420 // Actor* (Size: 0x8)
AbilitySystemComponent.ActivatableAbilities = 0x438 // FGameplayAbilitySpecContainer (Size: 0x128)
AbilitySystemComponent.AllReplicatedInstancedAbilities = 0x590 // TArray<GameplayAbility*> (Size: 0x10)
AbilitySystemComponent.RepAnimMontageInfo = 0x7b0 // FGameplayAbilityRepAnimMontage (Size: 0x58)
AbilitySystemComponent.bCachedIsNetSimulated = 0x808 // bool (Size: 0x1)
AbilitySystemComponent.bPendingMontageRep = 0x809 // bool (Size: 0x1)
AbilitySystemComponent.LocalAnimMontageInfo = 0x810 // FGameplayAbilityLocalAnimMontage (Size: 0x28)
AbilitySystemComponent.ActiveGameplayEffects = 0x8d8 // FActiveGameplayEffectsContainer (Size: 0x4d0)
AbilitySystemComponent.ActiveGameplayCues = 0xda8 // FActiveGameplayCueContainer (Size: 0x130)
AbilitySystemComponent.MinimalReplicationGameplayCues = 0xed8 // FActiveGameplayCueContainer (Size: 0x130)
AbilitySystemComponent.BlockedAbilityBindings = 0x1180 // TArray<uint8_t> (Size: 0x10)
AbilitySystemComponent.MinimalReplicationTags = 0x1308 // FMinimalReplicationTagCountMap (Size: 0x60)
AbilitySystemComponent.ReplicatedPredictionKeyMap = 0x1380 // FReplicatedPredictionKeyMap (Size: 0x128)
AbilitySystemGlobals.AbilitySystemGlobalsClassName = 0x28 // FSoftClassPath (Size: 0x18)
AbilitySystemGlobals.ActivateFailIsDeadTag = 0x68 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailIsDeadName = 0x70 // FName (Size: 0x8)
AbilitySystemGlobals.ActivateFailCooldownTag = 0x78 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailCooldownName = 0x80 // FName (Size: 0x8)
AbilitySystemGlobals.ActivateFailCostTag = 0x88 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailCostName = 0x90 // FName (Size: 0x8)
AbilitySystemGlobals.ActivateFailTagsBlockedTag = 0x98 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailTagsBlockedName = 0xa0 // FName (Size: 0x8)
AbilitySystemGlobals.ActivateFailTagsMissingTag = 0xa8 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailTagsMissingName = 0xb0 // FName (Size: 0x8)
AbilitySystemGlobals.ActivateFailNetworkingTag = 0xb8 // FGameplayTag (Size: 0x8)
AbilitySystemGlobals.ActivateFailNetworkingName = 0xc0 // FName (Size: 0x8)
AbilitySystemGlobals.MinimalReplicationTagCountBits = 0xc8 // int32_t (Size: 0x4)
AbilitySystemGlobals.TargetDataStructCache = 0xd0 // FNetSerializeScriptStructCache (Size: 0x10)
AbilitySystemGlobals.bAllowGameplayModEvaluationChannels = 0xe0 // bool (Size: 0x1)
AbilitySystemGlobals.DefaultGameplayModEvaluationChannel = 0xe1 // EEGameplayModEvaluationChannel (Size: 0x1)
AbilitySystemGlobals.GameplayModEvaluationChannelAliases = 0xe4 // FName (Size: 0x8)
AbilitySystemGlobals.GlobalCurveTableName = 0x138 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GlobalCurveTable = 0x150 // CurveTable* (Size: 0x8)
AbilitySystemGlobals.GlobalAttributeMetaDataTableName = 0x158 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GlobalAttributeMetaDataTable = 0x170 // DataTable* (Size: 0x8)
AbilitySystemGlobals.GlobalAttributeSetDefaultsTableName = 0x178 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GlobalAttributeSetDefaultsTableNames = 0x190 // TArray<FSoftObjectPath> (Size: 0x10)
AbilitySystemGlobals.GlobalAttributeDefaultsTables = 0x1a0 // TArray<CurveTable*> (Size: 0x10)
AbilitySystemGlobals.GlobalGameplayCueManagerClass = 0x1b0 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GlobalGameplayCueManagerName = 0x1c8 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GameplayCueNotifyPaths = 0x1e0 // TArray<FString> (Size: 0x10)
AbilitySystemGlobals.GameplayTagResponseTableName = 0x1f0 // FSoftObjectPath (Size: 0x18)
AbilitySystemGlobals.GameplayTagResponseTable = 0x208 // GameplayTagReponseTable* (Size: 0x8)
AbilitySystemGlobals.PredictTargetGameplayEffects = 0x210 // bool (Size: 0x1)
AbilitySystemGlobals.GlobalGameplayCueManager = 0x218 // GameplayCueManager* (Size: 0x8)
AbilitySystemTestAttributeSet.MaxHealth = 0x48 // float (Size: 0x4)
AbilitySystemTestAttributeSet.Health = 0x4c // float (Size: 0x4)
AbilitySystemTestAttributeSet.Mana = 0x50 // float (Size: 0x4)
AbilitySystemTestAttributeSet.MaxMana = 0x54 // float (Size: 0x4)
AbilitySystemTestAttributeSet.Damage = 0x58 // float (Size: 0x4)
AbilitySystemTestAttributeSet.SpellDamage = 0x5c // float (Size: 0x4)
AbilitySystemTestAttributeSet.PhysicalDamage = 0x60 // float (Size: 0x4)
AbilitySystemTestAttributeSet.CritChance = 0x64 // float (Size: 0x4)
AbilitySystemTestAttributeSet.CritMultiplier = 0x68 // float (Size: 0x4)
AbilitySystemTestAttributeSet.ArmorDamageReduction = 0x6c // float (Size: 0x4)
AbilitySystemTestAttributeSet.DodgeChance = 0x70 // float (Size: 0x4)
AbilitySystemTestAttributeSet.LifeSteal = 0x74 // float (Size: 0x4)
AbilitySystemTestAttributeSet.Strength = 0x78 // float (Size: 0x4)
AbilitySystemTestAttributeSet.StackingAttribute1 = 0x7c // float (Size: 0x4)
AbilitySystemTestAttributeSet.StackingAttribute2 = 0x80 // float (Size: 0x4)
AbilitySystemTestAttributeSet.NoStackAttribute = 0x84 // float (Size: 0x4)
AbilitySystemTestPawn.AbilitySystemComponent = 0x3c0 // AbilitySystemComponent* (Size: 0x8)
AbilityTask.Ability = 0x68 // GameplayAbility* (Size: 0x8)
AbilityTask.AbilitySystemComponent = 0x70 // AbilitySystemComponent* (Size: 0x8)
AbilityTaskDebugMessage.FromTask = 0x0 // GameplayTask* (Size: 0x8)
AbilityTaskDebugMessage.Message = 0x8 // FString (Size: 0x10)
AbilityTask_ApplyRootMotionConstantForce.OnFinish = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionConstantForce.WorldDirection = 0xc8 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionConstantForce.Strength = 0xd4 // float (Size: 0x4)
AbilityTask_ApplyRootMotionConstantForce.Duration = 0xd8 // float (Size: 0x4)
AbilityTask_ApplyRootMotionConstantForce.bIsAdditive = 0xdc // bool (Size: 0x1)
AbilityTask_ApplyRootMotionConstantForce.StrengthOverTime = 0xe0 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionConstantForce.bEnableGravity = 0xe8 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionJumpForce.OnFinish = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionJumpForce.OnLanded = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionJumpForce.Rotation = 0xd8 // FRotator (Size: 0xc)
AbilityTask_ApplyRootMotionJumpForce.Distance = 0xe4 // float (Size: 0x4)
AbilityTask_ApplyRootMotionJumpForce.Height = 0xe8 // float (Size: 0x4)
AbilityTask_ApplyRootMotionJumpForce.Duration = 0xec // float (Size: 0x4)
AbilityTask_ApplyRootMotionJumpForce.MinimumLandedTriggerTime = 0xf0 // float (Size: 0x4)
AbilityTask_ApplyRootMotionJumpForce.bFinishOnLanded = 0xf4 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionJumpForce.PathOffsetCurve = 0xf8 // CurveVector* (Size: 0x8)
AbilityTask_ApplyRootMotionJumpForce.TimeMappingCurve = 0x100 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToActorForce.OnFinished = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionMoveToActorForce.StartLocation = 0xd0 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionMoveToActorForce.TargetLocation = 0xdc // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionMoveToActorForce.TargetActor = 0xe8 // Actor* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToActorForce.TargetLocationOffset = 0xf0 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionMoveToActorForce.OffsetAlignment = 0xfc // EERootMotionMoveToActorTargetOffsetType (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToActorForce.Duration = 0x100 // float (Size: 0x4)
AbilityTask_ApplyRootMotionMoveToActorForce.bDisableDestinationReachedInterrupt = 0x104 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToActorForce.bSetNewMovementMode = 0x105 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToActorForce.NewMovementMode = 0x106 // uint8_t (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToActorForce.bRestrictSpeedToExpected = 0x107 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToActorForce.PathOffsetCurve = 0x108 // CurveVector* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToActorForce.TimeMappingCurve = 0x110 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToActorForce.TargetLerpSpeedHorizontalCurve = 0x118 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToActorForce.TargetLerpSpeedVerticalCurve = 0x120 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionMoveToForce.OnTimedOut = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionMoveToForce.OnTimedOutAndDestinationReached = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionMoveToForce.StartLocation = 0xd8 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionMoveToForce.TargetLocation = 0xe4 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionMoveToForce.Duration = 0xf0 // float (Size: 0x4)
AbilityTask_ApplyRootMotionMoveToForce.bSetNewMovementMode = 0xf4 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToForce.NewMovementMode = 0xf5 // uint8_t (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToForce.bRestrictSpeedToExpected = 0xf6 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionMoveToForce.PathOffsetCurve = 0xf8 // CurveVector* (Size: 0x8)
AbilityTask_ApplyRootMotionRadialForce.OnFinish = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_ApplyRootMotionRadialForce.Location = 0xc8 // FVector (Size: 0xc)
AbilityTask_ApplyRootMotionRadialForce.LocationActor = 0xd8 // Actor* (Size: 0x8)
AbilityTask_ApplyRootMotionRadialForce.Strength = 0xe0 // float (Size: 0x4)
AbilityTask_ApplyRootMotionRadialForce.Duration = 0xe4 // float (Size: 0x4)
AbilityTask_ApplyRootMotionRadialForce.Radius = 0xe8 // float (Size: 0x4)
AbilityTask_ApplyRootMotionRadialForce.bIsPush = 0xec // bool (Size: 0x1)
AbilityTask_ApplyRootMotionRadialForce.bIsAdditive = 0xed // bool (Size: 0x1)
AbilityTask_ApplyRootMotionRadialForce.bNoZForce = 0xee // bool (Size: 0x1)
AbilityTask_ApplyRootMotionRadialForce.StrengthDistanceFalloff = 0xf0 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionRadialForce.StrengthOverTime = 0xf8 // CurveFloat* (Size: 0x8)
AbilityTask_ApplyRootMotionRadialForce.bUseFixedWorldDirection = 0x100 // bool (Size: 0x1)
AbilityTask_ApplyRootMotionRadialForce.FixedWorldDirection = 0x104 // FRotator (Size: 0xc)
AbilityTask_ApplyRootMotion_Base.ForceName = 0x80 // FName (Size: 0x8)
AbilityTask_ApplyRootMotion_Base.FinishVelocityMode = 0x88 // EERootMotionFinishVelocityMode (Size: 0x1)
AbilityTask_ApplyRootMotion_Base.FinishSetVelocity = 0x8c // FVector (Size: 0xc)
AbilityTask_ApplyRootMotion_Base.FinishClampVelocity = 0x98 // float (Size: 0x4)
AbilityTask_ApplyRootMotion_Base.MovementComponent = 0xa0 // CharacterMovementComponent* (Size: 0x8)
AbilityTask_MoveToLocation.OnTargetLocationReached = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_MoveToLocation.StartLocation = 0x94 // FVector (Size: 0xc)
AbilityTask_MoveToLocation.TargetLocation = 0xa0 // FVector (Size: 0xc)
AbilityTask_MoveToLocation.DurationOfMovement = 0xac // float (Size: 0x4)
AbilityTask_MoveToLocation.LerpCurve = 0xb8 // CurveFloat* (Size: 0x8)
AbilityTask_MoveToLocation.LerpCurveVector = 0xc0 // CurveVector* (Size: 0x8)
AbilityTask_NetworkSyncPoint.OnSync = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_PlayMontageAndWait.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_PlayMontageAndWait.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_PlayMontageAndWait.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_PlayMontageAndWait.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_PlayMontageAndWait.MontageToPlay = 0xe8 // AnimMontage* (Size: 0x8)
AbilityTask_PlayMontageAndWait.Rate = 0xf0 // float (Size: 0x4)
AbilityTask_PlayMontageAndWait.StartSection = 0xf4 // FName (Size: 0x8)
AbilityTask_PlayMontageAndWait.AnimRootMotionTranslationScale = 0xfc // float (Size: 0x4)
AbilityTask_PlayMontageAndWait.StartTimeSeconds = 0x100 // float (Size: 0x4)
AbilityTask_PlayMontageAndWait.bStopWhenAbilityEnds = 0x104 // bool (Size: 0x1)
AbilityTask_PlayMontageAndWait.bStopAllMontages = 0x105 // bool (Size: 0x1)
AbilityTask_PlayMontageAndWait.bDisableInterruptBlendOutTime = 0x106 // bool (Size: 0x1)
AbilityTask_Repeat.OnPerformAction = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_Repeat.OnFinished = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_SpawnActor.Success = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_SpawnActor.DidNotSpawn = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_StartAbilityState.OnStateEnded = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_StartAbilityState.OnStateInterrupted = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_VisualizeTargeting.TimeElapsed = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAbilityActivate.OnActivate = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAbilityCommit.OnCommit = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAttributeChange.OnChange = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAttributeChange.ExternalOwner = 0xf0 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitAttributeChangeRatioThreshold.OnChange = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAttributeChangeRatioThreshold.ExternalOwner = 0x138 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitAttributeChangeThreshold.OnChange = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitAttributeChangeThreshold.ExternalOwner = 0xe8 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitCancel.OnCancel = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitConfirm.OnConfirm = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitConfirmCancel.OnConfirm = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitConfirmCancel.OnCancel = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitDelay.OnFinish = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectApplied.ExternalOwner = 0x1a8 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitGameplayEffectApplied_Self.OnApplied = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectApplied_Target.OnApplied = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectBlockedImmunity.bLocked = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectBlockedImmunity.ExternalOwner = 0x118 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitGameplayEffectRemoved.OnRemoved = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectRemoved.InvalidHandle = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectStackChange.OnChange = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEffectStackChange.InvalidHandle = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEvent.EventReceived = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayEvent.OptionalExternalTarget = 0x98 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitGameplayTag.OptionalExternalTarget = 0x90 // AbilitySystemComponent* (Size: 0x8)
AbilityTask_WaitGameplayTagAdded.Added = 0xa8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitGameplayTagRemoved.Removed = 0xa8 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitInputPress.OnPress = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitInputRelease.OnRelease = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitMovementModeChange.OnChange = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitOverlap.OnOverlap = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitTargetData.ValidData = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitTargetData.Cancelled = 0x90 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitTargetData.TargetClass = 0xa0 // ClassProperty (Size: 0x8)
AbilityTask_WaitTargetData.TargetActor = 0xa8 // GameplayAbilityTargetActor* (Size: 0x8)
AbilityTask_WaitVelocityChange.OnVelocityChage = 0x80 // FMulticastInlineDelegate (Size: 0x10)
AbilityTask_WaitVelocityChange.CachedMovementComponent = 0x90 // MovementComponent* (Size: 0x8)
AbilityTriggerData.TriggerTag = 0x0 // FGameplayTag (Size: 0x8)
AbilityTriggerData.TriggerSource = 0x8 // uint8_t (Size: 0x1)
ActiveGameplayCue.GameplayCueTag = 0xc // FGameplayTag (Size: 0x8)
ActiveGameplayCue.PredictionKey = 0x18 // FPredictionKey (Size: 0x10)
ActiveGameplayCue.Parameters = 0x28 // FGameplayCueParameters (Size: 0xb8)
ActiveGameplayCue.bPredictivelyRemoved = 0xe0 // bool (Size: 0x1)
ActiveGameplayCueContainer.GameplayCues = 0x110 // TArray<FActiveGameplayCue> (Size: 0x10)
ActiveGameplayCueContainer.Owner = 0x128 // AbilitySystemComponent* (Size: 0x8)
ActiveGameplayEffect.Spec = 0x18 // FGameplayEffectSpec (Size: 0x298)
ActiveGameplayEffect.PredictionKey = 0x2b0 // FPredictionKey (Size: 0x10)
ActiveGameplayEffect.StartServerWorldTime = 0x2c0 // float (Size: 0x4)
ActiveGameplayEffect.CachedStartServerWorldTime = 0x2c4 // float (Size: 0x4)
ActiveGameplayEffect.StartWorldTime = 0x2c8 // float (Size: 0x4)
ActiveGameplayEffect.bIsInhibited = 0x2cc // bool (Size: 0x1)
ActiveGameplayEffectHandle.Handle = 0x0 // int32_t (Size: 0x4)
ActiveGameplayEffectHandle.bPassedFiltersAndWasExecuted = 0x4 // bool (Size: 0x1)
ActiveGameplayEffectsContainer.GameplayEffects_Internal = 0x138 // TArray<FActiveGameplayEffect> (Size: 0x10)
ActiveGameplayEffectsContainer.ApplicationImmunityQueryEffects = 0x4a8 // TArray<GameplayEffect*> (Size: 0x10)
AttributeBasedFloat.Coefficient = 0x0 // FScalableFloat (Size: 0x20)
AttributeBasedFloat.PreMultiplyAdditiveValue = 0x20 // FScalableFloat (Size: 0x20)
AttributeBasedFloat.PostMultiplyAdditiveValue = 0x40 // FScalableFloat (Size: 0x20)
AttributeBasedFloat.BackingAttribute = 0x60 // FGameplayEffectAttributeCaptureDefinition (Size: 0x40)
AttributeBasedFloat.AttributeCurve = 0xa0 // FCurveTableRowHandle (Size: 0x10)
AttributeBasedFloat.AttributeCalculationType = 0xb0 // EEAttributeBasedFloatCalculationType (Size: 0x1)
AttributeBasedFloat.FinalChannel = 0xb1 // EEGameplayModEvaluationChannel (Size: 0x1)
AttributeBasedFloat.SourceTagFilter = 0xb8 // FGameplayTagContainer (Size: 0x20)
AttributeBasedFloat.TargetTagFilter = 0xd8 // FGameplayTagContainer (Size: 0x20)
AttributeDefaults.Attributes = 0x0 // ClassProperty (Size: 0x8)
AttributeDefaults.DefaultStartingTable = 0x8 // DataTable* (Size: 0x8)
AttributeMetaData.BaseValue = 0x8 // float (Size: 0x4)
AttributeMetaData.MinValue = 0xc // float (Size: 0x4)
AttributeMetaData.MaxValue = 0x10 // float (Size: 0x4)
AttributeMetaData.DerivedAttributeInfo = 0x18 // FString (Size: 0x10)
AttributeMetaData.bCanStack = 0x28 // bool (Size: 0x1)
ConditionalGameplayEffect.EffectClass = 0x0 // ClassProperty (Size: 0x8)
ConditionalGameplayEffect.RequiredSourceTags = 0x8 // FGameplayTagContainer (Size: 0x20)
CustomCalculationBasedFloat.CalculationClassMagnitude = 0x0 // ClassProperty (Size: 0x8)
CustomCalculationBasedFloat.Coefficient = 0x8 // FScalableFloat (Size: 0x20)
CustomCalculationBasedFloat.PreMultiplyAdditiveValue = 0x28 // FScalableFloat (Size: 0x20)
CustomCalculationBasedFloat.PostMultiplyAdditiveValue = 0x48 // FScalableFloat (Size: 0x20)
CustomCalculationBasedFloat.FinalLookupCurve = 0x68 // FCurveTableRowHandle (Size: 0x10)
GameplayAbility.AbilityTags = 0xa8 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.bReplicateInputDirectly = 0xc8 // bool (Size: 0x1)
GameplayAbility.RemoteInstanceEnded = 0xc9 // bool (Size: 0x1)
GameplayAbility.ReplicationPolicy = 0xce // uint8_t (Size: 0x1)
GameplayAbility.InstancingPolicy = 0xcf // uint8_t (Size: 0x1)
GameplayAbility.bServerRespectsRemoteAbilityCancellation = 0xd0 // bool (Size: 0x1)
GameplayAbility.bRetriggerInstancedAbility = 0xd1 // bool (Size: 0x1)
GameplayAbility.CurrentActivationInfo = 0xd8 // FGameplayAbilityActivationInfo (Size: 0x18)
GameplayAbility.CurrentEventData = 0xf0 // FGameplayEventData (Size: 0xb0)
GameplayAbility.NetExecutionPolicy = 0x1a0 // uint8_t (Size: 0x1)
GameplayAbility.bFlushServerMovesPreActivation = 0x1a1 // bool (Size: 0x1)
GameplayAbility.NetSecurityPolicy = 0x1a2 // uint8_t (Size: 0x1)
GameplayAbility.NetSecurityAdvancedPolicy = 0x1a3 // uint8_t (Size: 0x1)
GameplayAbility.CostGameplayEffectClass = 0x1a8 // ClassProperty (Size: 0x8)
GameplayAbility.AbilityTriggers = 0x1b0 // TArray<FAbilityTriggerData> (Size: 0x10)
GameplayAbility.CooldownGameplayEffectClass = 0x1c0 // ClassProperty (Size: 0x8)
GameplayAbility.CancelAbilitiesWithTag = 0x1c8 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.BlockAbilitiesWithTag = 0x1e8 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.ActivationOwnedTags = 0x208 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.ActivationRequiredTags = 0x228 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.ActivationBlockedTags = 0x248 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.SourceRequiredTags = 0x268 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.SourceBlockedTags = 0x288 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.TargetRequiredTags = 0x2a8 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.TargetBlockedTags = 0x2c8 // FGameplayTagContainer (Size: 0x20)
GameplayAbility.ActiveTasks = 0x308 // TArray<GameplayTask*> (Size: 0x10)
GameplayAbility.CurrentMontage = 0x328 // AnimMontage* (Size: 0x8)
GameplayAbility.bIsActive = 0x390 // bool (Size: 0x1)
GameplayAbility.bIsCancelable = 0x391 // bool (Size: 0x1)
GameplayAbility.bIsBlockingOtherAbilities = 0x392 // bool (Size: 0x1)
GameplayAbility.bMarkPendingKillOnAbilityEnd = 0x3a8 // bool (Size: 0x1)
GameplayAbilityActivationInfo.ActivationMode = 0x0 // uint8_t (Size: 0x1)
GameplayAbilityActivationInfo.bCanBeEndedByOtherInstance = 0x1 // uint8_t (Size: 0x1)
GameplayAbilityActivationInfo.PredictionKeyWhenActivated = 0x8 // FPredictionKey (Size: 0x10)
GameplayAbilityActorInfo.OwnerActor = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.AvatarActor = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.PlayerController = 0x18 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.AbilitySystemComponent = 0x20 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.SkeletalMeshComponent = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.AnimInstance = 0x30 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.MovementComponent = 0x38 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayAbilityActorInfo.AffectedAnimInstanceTag = 0x40 // FName (Size: 0x8)
GameplayAbilityBindInfo.Command = 0x0 // uint8_t (Size: 0x1)
GameplayAbilityBindInfo.GameplayAbilityClass = 0x8 // ClassProperty (Size: 0x8)
GameplayAbilityLocalAnimMontage.AnimMontage = 0x0 // AnimMontage* (Size: 0x8)
GameplayAbilityLocalAnimMontage.PlayBit = 0x8 // bool (Size: 0x1)
GameplayAbilityLocalAnimMontage.PredictionKey = 0x10 // FPredictionKey (Size: 0x10)
GameplayAbilityLocalAnimMontage.AnimatingAbility = 0x20 // GameplayAbility* (Size: 0x8)
GameplayAbilityRepAnimMontage.AnimMontage = 0x0 // AnimMontage* (Size: 0x8)
GameplayAbilityRepAnimMontage.PlayRate = 0x8 // float (Size: 0x4)
GameplayAbilityRepAnimMontage.position = 0xc // float (Size: 0x4)
GameplayAbilityRepAnimMontage.BlendTime = 0x10 // float (Size: 0x4)
GameplayAbilityRepAnimMontage.NextSectionID = 0x14 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.bRepPosition = 0x15 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.IsStopped = 0x15 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.ForcePlayBit = 0x15 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.SkipPositionCorrection = 0x15 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.bSkipPlayRate = 0x15 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.PredictionKey = 0x18 // FPredictionKey (Size: 0x10)
GameplayAbilityRepAnimMontage.SectionIdToPlay = 0x28 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.bStopAllMontages = 0x29 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.SectionLoopCountKeys = 0x30 // TArray<FName> (Size: 0x10)
GameplayAbilityRepAnimMontage.SectionLoopCountValues = 0x40 // TArray<int32_t> (Size: 0x10)
GameplayAbilityRepAnimMontage.bRepStop = 0x50 // uint8_t (Size: 0x1)
GameplayAbilityRepAnimMontage.bRepPendingForWeapon = 0x50 // uint8_t (Size: 0x1)
GameplayAbilitySet.Abilities = 0x30 // TArray<FGameplayAbilityBindInfo> (Size: 0x10)
GameplayAbilitySpec.Handle = 0xc // FGameplayAbilitySpecHandle (Size: 0x4)
GameplayAbilitySpec.Ability = 0x10 // GameplayAbility* (Size: 0x8)
GameplayAbilitySpec.Level = 0x18 // int32_t (Size: 0x4)
GameplayAbilitySpec.InputID = 0x1c // int32_t (Size: 0x4)
GameplayAbilitySpec.SourceObject = 0x20 // Object* (Size: 0x8)
GameplayAbilitySpec.ActiveCount = 0x28 // uint8_t (Size: 0x1)
GameplayAbilitySpec.InputPressed = 0x29 // uint8_t (Size: 0x1)
GameplayAbilitySpec.RemoveAfterActivation = 0x29 // uint8_t (Size: 0x1)
GameplayAbilitySpec.PendingRemove = 0x29 // uint8_t (Size: 0x1)
GameplayAbilitySpec.bActivateOnce = 0x29 // uint8_t (Size: 0x1)
GameplayAbilitySpec.ActivationInfo = 0x30 // FGameplayAbilityActivationInfo (Size: 0x18)
GameplayAbilitySpec.DynamicAbilityTags = 0x48 // FGameplayTagContainer (Size: 0x20)
GameplayAbilitySpec.NonReplicatedInstances = 0x68 // TArray<GameplayAbility*> (Size: 0x10)
GameplayAbilitySpec.ReplicatedInstances = 0x78 // TArray<GameplayAbility*> (Size: 0x10)
GameplayAbilitySpec.GameplayEffectHandle = 0x88 // FActiveGameplayEffectHandle (Size: 0x8)
GameplayAbilitySpec.RequestCount = 0xe0 // uint8_t (Size: 0x1)
GameplayAbilitySpec.MaxRequestCount = 0xe1 // uint8_t (Size: 0x1)
GameplayAbilitySpecContainer.Items = 0x110 // TArray<FGameplayAbilitySpec> (Size: 0x10)
GameplayAbilitySpecContainer.Owner = 0x120 // AbilitySystemComponent* (Size: 0x8)
GameplayAbilitySpecDef.Ability = 0x0 // ClassProperty (Size: 0x8)
GameplayAbilitySpecDef.LevelScalableFloat = 0x8 // FScalableFloat (Size: 0x20)
GameplayAbilitySpecDef.InputID = 0x28 // int32_t (Size: 0x4)
GameplayAbilitySpecDef.RemovalPolicy = 0x2c // EEGameplayEffectGrantedAbilityRemovePolicy (Size: 0x1)
GameplayAbilitySpecDef.SourceObject = 0x30 // Object* (Size: 0x8)
GameplayAbilitySpecDef.AssignedHandle = 0x88 // FGameplayAbilitySpecHandle (Size: 0x4)
GameplayAbilitySpecHandle.Handle = 0x0 // int32_t (Size: 0x4)
GameplayAbilitySpecHandleAndPredictionKey.AbilityHandle = 0x0 // FGameplayAbilitySpecHandle (Size: 0x4)
GameplayAbilitySpecHandleAndPredictionKey.PredictionKeyAtCreation = 0x4 // int32_t (Size: 0x4)
GameplayAbilityTargetActor.ShouldProduceTargetDataOnServer = 0x310 // bool (Size: 0x1)
GameplayAbilityTargetActor.StartLocation = 0x320 // FGameplayAbilityTargetingLocationInfo (Size: 0x70)
GameplayAbilityTargetActor.MasterPC = 0x3c0 // PlayerController* (Size: 0x8)
GameplayAbilityTargetActor.OwningAbility = 0x3c8 // GameplayAbility* (Size: 0x8)
GameplayAbilityTargetActor.bDestroyOnConfirmation = 0x3d0 // bool (Size: 0x1)
GameplayAbilityTargetActor.SourceActor = 0x3d8 // Actor* (Size: 0x8)
GameplayAbilityTargetActor.ReticleParams = 0x3e0 // FWorldReticleParameters (Size: 0xc)
GameplayAbilityTargetActor.ReticleClass = 0x3f0 // ClassProperty (Size: 0x8)
GameplayAbilityTargetActor.Filter = 0x3f8 // FGameplayTargetDataFilterHandle (Size: 0x10)
GameplayAbilityTargetActor.bDebug = 0x408 // bool (Size: 0x1)
GameplayAbilityTargetActor.GenericDelegateBoundASC = 0x420 // AbilitySystemComponent* (Size: 0x8)
GameplayAbilityTargetActor_ActorPlacement.PlacedActorClass = 0x460 // ClassProperty (Size: 0x8)
GameplayAbilityTargetActor_ActorPlacement.PlacedActorMaterial = 0x468 // MaterialInterface* (Size: 0x8)
GameplayAbilityTargetActor_GroundTrace.CollisionRadius = 0x440 // float (Size: 0x4)
GameplayAbilityTargetActor_GroundTrace.CollisionHeight = 0x444 // float (Size: 0x4)
GameplayAbilityTargetActor_Radius.Radius = 0x428 // float (Size: 0x4)
GameplayAbilityTargetActor_Trace.MaxRange = 0x428 // float (Size: 0x4)
GameplayAbilityTargetActor_Trace.TraceProfile = 0x42c // FCollisionProfileName (Size: 0x8)
GameplayAbilityTargetActor_Trace.bTraceAffectsAimPitch = 0x434 // bool (Size: 0x1)
GameplayAbilityTargetData_ActorArray.SourceLocation = 0x10 // FGameplayAbilityTargetingLocationInfo (Size: 0x70)
GameplayAbilityTargetData_ActorArray.TargetActorArray = 0x80 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
GameplayAbilityTargetData_LocationInfo.SourceLocation = 0x10 // FGameplayAbilityTargetingLocationInfo (Size: 0x70)
GameplayAbilityTargetData_LocationInfo.TargetLocation = 0x80 // FGameplayAbilityTargetingLocationInfo (Size: 0x70)
GameplayAbilityTargetData_SingleTargetHit.HitResult = 0x8 // FHitResult (Size: 0x98)
GameplayAbilityTargetData_SingleTargetHit.bHitReplaced = 0xa0 // bool (Size: 0x1)
GameplayAbilityTargetingLocationInfo.LocationType = 0x10 // uint8_t (Size: 0x1)
GameplayAbilityTargetingLocationInfo.LiteralTransform = 0x20 // FTransform (Size: 0x30)
GameplayAbilityTargetingLocationInfo.SourceActor = 0x50 // Actor* (Size: 0x8)
GameplayAbilityTargetingLocationInfo.SourceComponent = 0x58 // MeshComponent* (Size: 0x8)
GameplayAbilityTargetingLocationInfo.SourceAbility = 0x60 // GameplayAbility* (Size: 0x8)
GameplayAbilityTargetingLocationInfo.SourceSocketName = 0x68 // FName (Size: 0x8)
GameplayAbilityWorldReticle.Parameters = 0x310 // FWorldReticleParameters (Size: 0xc)
GameplayAbilityWorldReticle.bFaceOwnerFlat = 0x31c // bool (Size: 0x1)
GameplayAbilityWorldReticle.bSnapToTargetedActor = 0x31d // bool (Size: 0x1)
GameplayAbilityWorldReticle.bIsTargetValid = 0x31e // bool (Size: 0x1)
GameplayAbilityWorldReticle.bIsTargetAnActor = 0x31f // bool (Size: 0x1)
GameplayAbilityWorldReticle.MasterPC = 0x320 // PlayerController* (Size: 0x8)
GameplayAbilityWorldReticle.TargetingActor = 0x328 // Actor* (Size: 0x8)
GameplayAbilityWorldReticle_ActorVisualization.CollisionComponent = 0x330 // CapsuleComponent* (Size: 0x8)
GameplayAbilityWorldReticle_ActorVisualization.VisualizationComponents = 0x338 // TArray<ActorComponent*> (Size: 0x10)
GameplayAbility_Montage.MontageToPlay = 0x3c8 // AnimMontage* (Size: 0x8)
GameplayAbility_Montage.PlayRate = 0x3d0 // float (Size: 0x4)
GameplayAbility_Montage.SectionName = 0x3d4 // FName (Size: 0x8)
GameplayAbility_Montage.GameplayEffectClassesWhileAnimating = 0x3e0 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Montage.GameplayEffectsWhileAnimating = 0x3f0 // TArray<GameplayEffect*> (Size: 0x10)
GameplayAttribute.AttributeName = 0x0 // FString (Size: 0x10)
GameplayAttribute.Attribute = 0x10 // FieldPathProperty (Size: 0x20)
GameplayAttribute.AttributeOwner = 0x30 // Struct* (Size: 0x8)
GameplayAttributeData.BaseValue = 0x8 // float (Size: 0x4)
GameplayAttributeData.CurrentValue = 0xc // float (Size: 0x4)
GameplayCueManager.RuntimeGameplayCueObjectLibrary = 0x48 // FGameplayCueObjectLibrary (Size: 0x50)
GameplayCueManager.EditorGameplayCueObjectLibrary = 0x98 // FGameplayCueObjectLibrary (Size: 0x50)
GameplayCueManager.LoadedGameplayCueNotifyClasses = 0x2b0 // TArray<ClassProperty> (Size: 0x10)
GameplayCueManager.GameplayCueClassesForPreallocation = 0x2c0 // TArray<ClassProperty> (Size: 0x10)
GameplayCueManager.PendingExecuteCues = 0x2d0 // TArray<FGameplayCuePendingExecute> (Size: 0x10)
GameplayCueManager.GameplayCueSendContextCount = 0x2e0 // int32_t (Size: 0x4)
GameplayCueManager.PreallocationInfoList_Internal = 0x2e8 // TArray<FPreallocationInfo> (Size: 0x10)
GameplayCueNotifyData.GameplayCueTag = 0x0 // FGameplayTag (Size: 0x8)
GameplayCueNotifyData.GameplayCueNotifyObj = 0x8 // FSoftObjectPath (Size: 0x18)
GameplayCueNotifyData.LoadedGameplayCueClass = 0x20 // ClassProperty (Size: 0x8)
GameplayCueNotify_Actor.bAutoDestroyOnRemove = 0x310 // bool (Size: 0x1)
GameplayCueNotify_Actor.AutoDestroyDelay = 0x314 // float (Size: 0x4)
GameplayCueNotify_Actor.WarnIfTimelineIsStillRunning = 0x318 // bool (Size: 0x1)
GameplayCueNotify_Actor.WarnIfLatentActionIsStillRunning = 0x319 // bool (Size: 0x1)
GameplayCueNotify_Actor.GameplayCueTag = 0x31c // FGameplayTag (Size: 0x8)
GameplayCueNotify_Actor.GameplayCueName = 0x324 // FName (Size: 0x8)
GameplayCueNotify_Actor.bAutoAttachToOwner = 0x32c // bool (Size: 0x1)
GameplayCueNotify_Actor.IsOverride = 0x32d // bool (Size: 0x1)
GameplayCueNotify_Actor.bUniqueInstancePerInstigator = 0x32e // bool (Size: 0x1)
GameplayCueNotify_Actor.bUniqueInstancePerSourceObject = 0x32f // bool (Size: 0x1)
GameplayCueNotify_Actor.bAllowMultipleOnActiveEvents = 0x330 // bool (Size: 0x1)
GameplayCueNotify_Actor.bAllowMultipleWhileActiveEvents = 0x331 // bool (Size: 0x1)
GameplayCueNotify_Actor.NumPreallocatedInstances = 0x334 // int32_t (Size: 0x4)
GameplayCueNotify_HitImpact.Sound = 0x40 // SoundBase* (Size: 0x8)
GameplayCueNotify_HitImpact.ParticleSystem = 0x48 // ParticleSystem* (Size: 0x8)
GameplayCueNotify_Static.GameplayCueTag = 0x28 // FGameplayTag (Size: 0x8)
GameplayCueNotify_Static.GameplayCueName = 0x30 // FName (Size: 0x8)
GameplayCueNotify_Static.IsOverride = 0x38 // bool (Size: 0x1)
GameplayCueObjectLibrary.Paths = 0x0 // TArray<FString> (Size: 0x10)
GameplayCueObjectLibrary.ActorObjectLibrary = 0x30 // ObjectLibrary* (Size: 0x8)
GameplayCueObjectLibrary.StaticObjectLibrary = 0x38 // ObjectLibrary* (Size: 0x8)
GameplayCueObjectLibrary.CueSet = 0x40 // GameplayCueSet* (Size: 0x8)
GameplayCueObjectLibrary.bShouldSyncScan = 0x4c // bool (Size: 0x1)
GameplayCueObjectLibrary.bShouldAsyncLoad = 0x4d // bool (Size: 0x1)
GameplayCueObjectLibrary.bShouldSyncLoad = 0x4e // bool (Size: 0x1)
GameplayCueObjectLibrary.bHasBeenInitialized = 0x4f // bool (Size: 0x1)
GameplayCueParameters.NormalizedMagnitude = 0x0 // float (Size: 0x4)
GameplayCueParameters.RawMagnitude = 0x4 // float (Size: 0x4)
GameplayCueParameters.EffectContext = 0x8 // FGameplayEffectContextHandle (Size: 0x18)
GameplayCueParameters.MatchedTagName = 0x20 // FGameplayTag (Size: 0x8)
GameplayCueParameters.OriginalTag = 0x28 // FGameplayTag (Size: 0x8)
GameplayCueParameters.AggregatedSourceTags = 0x30 // FGameplayTagContainer (Size: 0x20)
GameplayCueParameters.AggregatedTargetTags = 0x50 // FGameplayTagContainer (Size: 0x20)
GameplayCueParameters.Location = 0x70 // FVector_NetQuantize10 (Size: 0xc)
GameplayCueParameters.Normal = 0x7c // FVector_NetQuantizeNormal (Size: 0xc)
GameplayCueParameters.Instigator = 0x88 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayCueParameters.EffectCauser = 0x90 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayCueParameters.SourceObject = 0x98 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayCueParameters.PhysicalMaterial = 0xa0 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayCueParameters.GameplayEffectLevel = 0xa8 // int32_t (Size: 0x4)
GameplayCueParameters.AbilityLevel = 0xac // int32_t (Size: 0x4)
GameplayCueParameters.TargetAttachComponent = 0xb0 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayCuePendingExecute.PredictionKey = 0x18 // FPredictionKey (Size: 0x10)
GameplayCuePendingExecute.PayloadType = 0x28 // EEGameplayCuePayloadType (Size: 0x1)
GameplayCuePendingExecute.OwningComponent = 0x30 // AbilitySystemComponent* (Size: 0x8)
GameplayCuePendingExecute.FromSpec = 0x38 // FGameplayEffectSpecForRPC (Size: 0x78)
GameplayCuePendingExecute.CueParameters = 0xb0 // FGameplayCueParameters (Size: 0xb8)
GameplayCueSet.GameplayCueData = 0x30 // TArray<FGameplayCueNotifyData> (Size: 0x10)
GameplayCueTag.GameplayCueTag = 0x0 // FGameplayTag (Size: 0x8)
GameplayCueTranslationLink.RulesCDO = 0x0 // GameplayCueTranslator* (Size: 0x8)
GameplayCueTranslationManager.TranslationLUT = 0x0 // TArray<FGameplayCueTranslatorNode> (Size: 0x10)
GameplayCueTranslationManager.TranslationNameToIndexMap = 0x10 // TMap<...> (Size: 0x50)
GameplayCueTranslationManager.TagManager = 0x60 // GameplayTagsManager* (Size: 0x8)
GameplayCueTranslatorNode.Links = 0x0 // TArray<FGameplayCueTranslationLink> (Size: 0x10)
GameplayCueTranslatorNode.CachedIndex = 0x10 // FGameplayCueTranslatorNodeIndex (Size: 0x4)
GameplayCueTranslatorNode.CachedGameplayTag = 0x14 // FGameplayTag (Size: 0x8)
GameplayCueTranslatorNode.CachedGameplayTagName = 0x1c // FName (Size: 0x8)
GameplayCueTranslatorNodeIndex.Index = 0x0 // int32_t (Size: 0x4)
GameplayEffect.DurationPolicy = 0x30 // EEGameplayEffectDurationType (Size: 0x1)
GameplayEffect.DurationMagnitude = 0x38 // FGameplayEffectModifierMagnitude (Size: 0x1a8)
GameplayEffect.Period = 0x1e0 // FScalableFloat (Size: 0x20)
GameplayEffect.bExecutePeriodicEffectOnApplication = 0x200 // bool (Size: 0x1)
GameplayEffect.bProcessExecutionNoPeriod = 0x201 // bool (Size: 0x1)
GameplayEffect.PeriodicInhibitionPolicy = 0x202 // EEGameplayEffectPeriodInhibitionRemovedPolicy (Size: 0x1)
GameplayEffect.Modifiers = 0x208 // TArray<FGameplayModifierInfo> (Size: 0x10)
GameplayEffect.Executions = 0x218 // TArray<FGameplayEffectExecutionDefinition> (Size: 0x10)
GameplayEffect.ChanceToApplyToTarget = 0x228 // FScalableFloat (Size: 0x20)
GameplayEffect.ApplicationRequirements = 0x248 // TArray<ClassProperty> (Size: 0x10)
GameplayEffect.TargetEffectClasses = 0x258 // TArray<ClassProperty> (Size: 0x10)
GameplayEffect.ConditionalGameplayEffects = 0x268 // TArray<FConditionalGameplayEffect> (Size: 0x10)
GameplayEffect.OverflowEffects = 0x278 // TArray<ClassProperty> (Size: 0x10)
GameplayEffect.bDenyOverflowApplication = 0x288 // bool (Size: 0x1)
GameplayEffect.bClearStackOnOverflow = 0x289 // bool (Size: 0x1)
GameplayEffect.PrematureExpirationEffectClasses = 0x290 // TArray<ClassProperty> (Size: 0x10)
GameplayEffect.RoutineExpirationEffectClasses = 0x2a0 // TArray<ClassProperty> (Size: 0x10)
GameplayEffect.bRequireModifierSuccessToTriggerCues = 0x2b0 // bool (Size: 0x1)
GameplayEffect.bSuppressStackingCues = 0x2b1 // bool (Size: 0x1)
GameplayEffect.GameplayCues = 0x2b8 // TArray<FGameplayEffectCue> (Size: 0x10)
GameplayEffect.UIData = 0x2c8 // GameplayEffectUIData* (Size: 0x8)
GameplayEffect.bEnableAddGrantedTagsToMinimalTagMap = 0x2d0 // bool (Size: 0x1)
GameplayEffect.InheritableGameplayEffectTags = 0x2d8 // FInheritedTagContainer (Size: 0x60)
GameplayEffect.InheritableOwnedTagsContainer = 0x338 // FInheritedTagContainer (Size: 0x60)
GameplayEffect.OngoingTagRequirements = 0x398 // FGameplayTagRequirements (Size: 0x40)
GameplayEffect.ApplicationTagRequirements = 0x3d8 // FGameplayTagRequirements (Size: 0x40)
GameplayEffect.RemovalTagRequirements = 0x418 // FGameplayTagRequirements (Size: 0x40)
GameplayEffect.RemoveGameplayEffectsWithTags = 0x458 // FInheritedTagContainer (Size: 0x60)
GameplayEffect.GrantedApplicationImmunityTags = 0x4b8 // FGameplayTagRequirements (Size: 0x40)
GameplayEffect.GrantedApplicationImmunityQuery = 0x4f8 // FGameplayEffectQuery (Size: 0x150)
GameplayEffect.RemoveGameplayEffectQuery = 0x650 // FGameplayEffectQuery (Size: 0x150)
GameplayEffect.StackingType = 0x7a1 // EEGameplayEffectStackingType (Size: 0x1)
GameplayEffect.StackLimitCount = 0x7a4 // int32_t (Size: 0x4)
GameplayEffect.StackDurationRefreshPolicy = 0x7a8 // EEGameplayEffectStackingDurationPolicy (Size: 0x1)
GameplayEffect.StackPeriodResetPolicy = 0x7a9 // EEGameplayEffectStackingPeriodPolicy (Size: 0x1)
GameplayEffect.StackExpirationPolicy = 0x7aa // EEGameplayEffectStackingExpirationPolicy (Size: 0x1)
GameplayEffect.GrantedAbilities = 0x7b0 // TArray<FGameplayAbilitySpecDef> (Size: 0x10)
GameplayEffectAttributeCaptureDefinition.AttributeToCapture = 0x0 // FGameplayAttribute (Size: 0x38)
GameplayEffectAttributeCaptureDefinition.AttributeSource = 0x38 // EEGameplayEffectAttributeCaptureSource (Size: 0x1)
GameplayEffectAttributeCaptureDefinition.bSnapshot = 0x39 // bool (Size: 0x1)
GameplayEffectAttributeCaptureSpec.BackingDefinition = 0x0 // FGameplayEffectAttributeCaptureDefinition (Size: 0x40)
GameplayEffectAttributeCaptureSpecContainer.SourceAttributes = 0x0 // TArray<FGameplayEffectAttributeCaptureSpec> (Size: 0x10)
GameplayEffectAttributeCaptureSpecContainer.TargetAttributes = 0x10 // TArray<FGameplayEffectAttributeCaptureSpec> (Size: 0x10)
GameplayEffectAttributeCaptureSpecContainer.bHasNonSnapshottedAttributes = 0x20 // bool (Size: 0x1)
GameplayEffectCalculation.RelevantAttributesToCapture = 0x28 // TArray<FGameplayEffectAttributeCaptureDefinition> (Size: 0x10)
GameplayEffectContext.Instigator = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.EffectCauser = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.AbilityCDO = 0x18 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.AbilityInstanceNotReplicated = 0x20 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.AbilityLevel = 0x28 // int32_t (Size: 0x4)
GameplayEffectContext.SourceObject = 0x2c // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.InstigatorAbilitySystemComponent = 0x34 // TWeakObjectPtr<UObject> (Size: 0x8)
GameplayEffectContext.Actors = 0x40 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
GameplayEffectContext.WorldOrigin = 0x60 // FVector (Size: 0xc)
GameplayEffectContext.bHasWorldOrigin = 0x6c // uint8_t (Size: 0x1)
GameplayEffectContext.bReplicateSourceObject = 0x6c // uint8_t (Size: 0x1)
GameplayEffectCue.MagnitudeAttribute = 0x0 // FGameplayAttribute (Size: 0x38)
GameplayEffectCue.MinLevel = 0x38 // float (Size: 0x4)
GameplayEffectCue.MaxLevel = 0x3c // float (Size: 0x4)
GameplayEffectCue.GameplayCueTags = 0x40 // FGameplayTagContainer (Size: 0x20)
GameplayEffectCustomExecutionOutput.OutputModifiers = 0x0 // TArray<FGameplayModifierEvaluatedData> (Size: 0x10)
GameplayEffectCustomExecutionOutput.bTriggerConditionalGameplayEffects = 0x10 // uint8_t (Size: 0x1)
GameplayEffectCustomExecutionOutput.bHandledStackCountManually = 0x10 // uint8_t (Size: 0x1)
GameplayEffectCustomExecutionOutput.bHandledGameplayCuesManually = 0x10 // uint8_t (Size: 0x1)
GameplayEffectExecutionCalculation.bRequiresPassedInTags = 0x38 // bool (Size: 0x1)
GameplayEffectExecutionDefinition.CalculationClass = 0x0 // ClassProperty (Size: 0x8)
GameplayEffectExecutionDefinition.PassedInTags = 0x8 // FGameplayTagContainer (Size: 0x20)
GameplayEffectExecutionDefinition.CalculationModifiers = 0x28 // TArray<FGameplayEffectExecutionScopedModifierInfo> (Size: 0x10)
GameplayEffectExecutionDefinition.ConditionalGameplayEffectClasses = 0x38 // TArray<ClassProperty> (Size: 0x10)
GameplayEffectExecutionDefinition.ConditionalGameplayEffects = 0x48 // TArray<FConditionalGameplayEffect> (Size: 0x10)
GameplayEffectExecutionScopedModifierInfo.CapturedAttribute = 0x0 // FGameplayEffectAttributeCaptureDefinition (Size: 0x40)
GameplayEffectExecutionScopedModifierInfo.TransientAggregatorIdentifier = 0x40 // FGameplayTag (Size: 0x8)
GameplayEffectExecutionScopedModifierInfo.AggregatorType = 0x48 // EEGameplayEffectScopedModifierAggregatorType (Size: 0x1)
GameplayEffectExecutionScopedModifierInfo.ModifierOp = 0x49 // uint8_t (Size: 0x1)
GameplayEffectExecutionScopedModifierInfo.ModifiersSelector = 0x4a // uint8_t (Size: 0x1)
GameplayEffectExecutionScopedModifierInfo.Priority = 0x4b // uint8_t (Size: 0x1)
GameplayEffectExecutionScopedModifierInfo.ModifierMagnitude = 0x50 // FGameplayEffectModifierMagnitude (Size: 0x1a8)
GameplayEffectExecutionScopedModifierInfo.EvaluationChannelSettings = 0x1f8 // FGameplayModEvaluationChannelSettings (Size: 0x1)
GameplayEffectExecutionScopedModifierInfo.SourceTags = 0x200 // FGameplayTagRequirements (Size: 0x40)
GameplayEffectExecutionScopedModifierInfo.TargetTags = 0x240 // FGameplayTagRequirements (Size: 0x40)
GameplayEffectModifiedAttribute.Attribute = 0x0 // FGameplayAttribute (Size: 0x38)
GameplayEffectModifiedAttribute.TotalMagnitude = 0x38 // float (Size: 0x4)
GameplayEffectModifierMagnitude.MagnitudeCalculationType = 0x0 // EEGameplayEffectMagnitudeCalculation (Size: 0x1)
GameplayEffectModifierMagnitude.ScalableFloatMagnitude = 0x8 // FScalableFloat (Size: 0x20)
GameplayEffectModifierMagnitude.AttributeBasedMagnitude = 0x28 // FAttributeBasedFloat (Size: 0xf8)
GameplayEffectModifierMagnitude.CustomMagnitude = 0x120 // FCustomCalculationBasedFloat (Size: 0x78)
GameplayEffectModifierMagnitude.SetByCallerMagnitude = 0x198 // FSetByCallerFloat (Size: 0x10)
GameplayEffectQuery.CustomMatchDelegate_BP = 0x10 // FDelegate (Size: 0x10)
GameplayEffectQuery.OwningTagQuery = 0x20 // FGameplayTagQuery (Size: 0x48)
GameplayEffectQuery.EffectTagQuery = 0x68 // FGameplayTagQuery (Size: 0x48)
GameplayEffectQuery.SourceTagQuery = 0xb0 // FGameplayTagQuery (Size: 0x48)
GameplayEffectQuery.ModifyingAttribute = 0xf8 // FGameplayAttribute (Size: 0x38)
GameplayEffectQuery.EffectSource = 0x130 // Object* (Size: 0x8)
GameplayEffectQuery.EffectDefinition = 0x138 // ClassProperty (Size: 0x8)
GameplayEffectRemovalInfo.bPrematureRemoval = 0x0 // bool (Size: 0x1)
GameplayEffectRemovalInfo.StackCount = 0x4 // int32_t (Size: 0x4)
GameplayEffectRemovalInfo.EffectContext = 0x8 // FGameplayEffectContextHandle (Size: 0x18)
GameplayEffectSpec.Def = 0x0 // GameplayEffect* (Size: 0x8)
GameplayEffectSpec.ModifiedAttributes = 0x8 // TArray<FGameplayEffectModifiedAttribute> (Size: 0x10)
GameplayEffectSpec.CapturedRelevantAttributes = 0x18 // FGameplayEffectAttributeCaptureSpecContainer (Size: 0x28)
GameplayEffectSpec.Duration = 0x50 // float (Size: 0x4)
GameplayEffectSpec.Period = 0x54 // float (Size: 0x4)
GameplayEffectSpec.ChanceToApplyToTarget = 0x58 // float (Size: 0x4)
GameplayEffectSpec.CapturedSourceTags = 0x60 // FTagContainerAggregator (Size: 0x88)
GameplayEffectSpec.CapturedTargetTags = 0xe8 // FTagContainerAggregator (Size: 0x88)
GameplayEffectSpec.DynamicGrantedTags = 0x170 // FGameplayTagContainer (Size: 0x20)
GameplayEffectSpec.DynamicAssetTags = 0x190 // FGameplayTagContainer (Size: 0x20)
GameplayEffectSpec.Modifiers = 0x1b0 // TArray<FModifierSpec> (Size: 0x10)
GameplayEffectSpec.StackCount = 0x1c0 // int32_t (Size: 0x4)
GameplayEffectSpec.bCompletedSourceAttributeCapture = 0x1c4 // uint8_t (Size: 0x1)
GameplayEffectSpec.bCompletedTargetAttributeCapture = 0x1c4 // uint8_t (Size: 0x1)
GameplayEffectSpec.bDurationLocked = 0x1c4 // uint8_t (Size: 0x1)
GameplayEffectSpec.GrantedAbilitySpecs = 0x1c8 // TArray<FGameplayAbilitySpecDef> (Size: 0x10)
GameplayEffectSpec.EffectContext = 0x278 // FGameplayEffectContextHandle (Size: 0x18)
GameplayEffectSpec.Level = 0x290 // float (Size: 0x4)
GameplayEffectSpecForRPC.Def = 0x0 // GameplayEffect* (Size: 0x8)
GameplayEffectSpecForRPC.ModifiedAttributes = 0x8 // TArray<FGameplayEffectModifiedAttribute> (Size: 0x10)
GameplayEffectSpecForRPC.EffectContext = 0x18 // FGameplayEffectContextHandle (Size: 0x18)
GameplayEffectSpecForRPC.AggregatedSourceTags = 0x30 // FGameplayTagContainer (Size: 0x20)
GameplayEffectSpecForRPC.AggregatedTargetTags = 0x50 // FGameplayTagContainer (Size: 0x20)
GameplayEffectSpecForRPC.Level = 0x70 // float (Size: 0x4)
GameplayEffectSpecForRPC.AbilityLevel = 0x74 // float (Size: 0x4)
GameplayEffectUIData_TextOnly.Description = 0x28 // FText (Size: 0x18)
GameplayEventData.EventTag = 0x0 // FGameplayTag (Size: 0x8)
GameplayEventData.Instigator = 0x8 // Actor* (Size: 0x8)
GameplayEventData.Target = 0x10 // Actor* (Size: 0x8)
GameplayEventData.OptionalObject = 0x18 // Object* (Size: 0x8)
GameplayEventData.OptionalObject2 = 0x20 // Object* (Size: 0x8)
GameplayEventData.ContextHandle = 0x28 // FGameplayEffectContextHandle (Size: 0x18)
GameplayEventData.InstigatorTags = 0x40 // FGameplayTagContainer (Size: 0x20)
GameplayEventData.TargetTags = 0x60 // FGameplayTagContainer (Size: 0x20)
GameplayEventData.EventMagnitude = 0x80 // float (Size: 0x4)
GameplayEventData.TargetData = 0x88 // FGameplayAbilityTargetDataHandle (Size: 0x28)
GameplayModEvaluationChannelSettings.Channel = 0x0 // EEGameplayModEvaluationChannel (Size: 0x1)
GameplayModMagnitudeCalculation.bAllowNonNetAuthorityDependencyRegistration = 0x38 // bool (Size: 0x1)
GameplayModifierEvaluatedData.Attribute = 0x0 // FGameplayAttribute (Size: 0x38)
GameplayModifierEvaluatedData.ModifierOp = 0x38 // uint8_t (Size: 0x1)
GameplayModifierEvaluatedData.Magnitude = 0x3c // float (Size: 0x4)
GameplayModifierEvaluatedData.Priority = 0x40 // uint8_t (Size: 0x1)
GameplayModifierEvaluatedData.ModsSelector = 0x41 // uint8_t (Size: 0x1)
GameplayModifierEvaluatedData.ModsChannel = 0x42 // EEGameplayModEvaluationChannel (Size: 0x1)
GameplayModifierEvaluatedData.Handle = 0x58 // FActiveGameplayEffectHandle (Size: 0x8)
GameplayModifierEvaluatedData.IsValid = 0x60 // bool (Size: 0x1)
GameplayModifierInfo.Attribute = 0x0 // FGameplayAttribute (Size: 0x38)
GameplayModifierInfo.ModifierOp = 0x38 // uint8_t (Size: 0x1)
GameplayModifierInfo.ModifiersSelector = 0x39 // uint8_t (Size: 0x1)
GameplayModifierInfo.Priority = 0x3a // uint8_t (Size: 0x1)
GameplayModifierInfo.Magnitude = 0x40 // FScalableFloat (Size: 0x20)
GameplayModifierInfo.ModifierMagnitude = 0x60 // FGameplayEffectModifierMagnitude (Size: 0x1a8)
GameplayModifierInfo.EvaluationChannelSettings = 0x208 // FGameplayModEvaluationChannelSettings (Size: 0x1)
GameplayModifierInfo.SourceTags = 0x210 // FGameplayTagRequirements (Size: 0x40)
GameplayModifierInfo.TargetTags = 0x250 // FGameplayTagRequirements (Size: 0x40)
GameplayTagBlueprintPropertyMap.PropertyMappings = 0x10 // TArray<FGameplayTagBlueprintPropertyMapping> (Size: 0x10)
GameplayTagBlueprintPropertyMapping.TagToMap = 0x0 // FGameplayTag (Size: 0x8)
GameplayTagBlueprintPropertyMapping.PropertyToEdit = 0x8 // FieldPathProperty (Size: 0x20)
GameplayTagBlueprintPropertyMapping.PropertyName = 0x28 // FName (Size: 0x8)
GameplayTagBlueprintPropertyMapping.PropertyGuid = 0x30 // FGuid (Size: 0x10)
GameplayTagReponsePair.Tag = 0x0 // FGameplayTag (Size: 0x8)
GameplayTagReponsePair.ResponseGameplayEffect = 0x8 // ClassProperty (Size: 0x8)
GameplayTagReponsePair.ResponseGameplayEffects = 0x10 // TArray<ClassProperty> (Size: 0x10)
GameplayTagReponsePair.SoftCountCap = 0x20 // int32_t (Size: 0x4)
GameplayTagReponseTable.Entries = 0x30 // TArray<FGameplayTagResponseTableEntry> (Size: 0x10)
GameplayTagRequirements.RequireTags = 0x0 // FGameplayTagContainer (Size: 0x20)
GameplayTagRequirements.IgnoreTags = 0x20 // FGameplayTagContainer (Size: 0x20)
GameplayTagResponseTableEntry.Positive = 0x0 // FGameplayTagReponsePair (Size: 0x28)
GameplayTagResponseTableEntry.Negative = 0x28 // FGameplayTagReponsePair (Size: 0x28)
GameplayTargetDataFilter.SelfActor = 0x8 // Actor* (Size: 0x8)
GameplayTargetDataFilter.RequiredActorClass = 0x10 // ClassProperty (Size: 0x8)
GameplayTargetDataFilter.SelfFilter = 0x18 // uint8_t (Size: 0x1)
GameplayTargetDataFilter.bReverseFilter = 0x19 // bool (Size: 0x1)
InheritedTagContainer.CombinedTags = 0x0 // FGameplayTagContainer (Size: 0x20)
InheritedTagContainer.Added = 0x20 // FGameplayTagContainer (Size: 0x20)
InheritedTagContainer.Removed = 0x40 // FGameplayTagContainer (Size: 0x20)
MinimalGameplayCueReplicationProxy.Owner = 0x1b0 // AbilitySystemComponent* (Size: 0x8)
MinimalReplicationTagCountMap.Owner = 0x50 // AbilitySystemComponent* (Size: 0x8)
ModifierSpec.EvaluatedMagnitude = 0x0 // float (Size: 0x4)
ModifierSpec.Priority = 0x4 // uint8_t (Size: 0x1)
ModifierSpec.ModsSelector = 0x5 // uint8_t (Size: 0x1)
NetSerializeScriptStructCache.ScriptStructs = 0x0 // TArray<ScriptStruct*> (Size: 0x10)
PreallocationInfo.ClassesNeedingPreallocation = 0x50 // TArray<ClassProperty> (Size: 0x10)
PredictionKey.PredictiveConnection = 0x0 // PackageMap* (Size: 0x8)
PredictionKey.Current = 0x8 // int16_t (Size: 0x2)
PredictionKey.Base = 0xa // int16_t (Size: 0x2)
PredictionKey.bIsStale = 0xc // bool (Size: 0x1)
PredictionKey.bIsServerInitiated = 0xd // bool (Size: 0x1)
ReplicatedPredictionKeyItem.PredictionKey = 0x10 // FPredictionKey (Size: 0x10)
ReplicatedPredictionKeyMap.PredictionKeys = 0x118 // TArray<FReplicatedPredictionKeyItem> (Size: 0x10)
ScalableFloat.Value = 0x0 // float (Size: 0x4)
ScalableFloat.Curve = 0x8 // FCurveTableRowHandle (Size: 0x10)
ServerAbilityRPCBatch.AbilitySpecHandle = 0x0 // FGameplayAbilitySpecHandle (Size: 0x4)
ServerAbilityRPCBatch.PredictionKey = 0x8 // FPredictionKey (Size: 0x10)
ServerAbilityRPCBatch.TargetData = 0x18 // FGameplayAbilityTargetDataHandle (Size: 0x28)
ServerAbilityRPCBatch.InputPressed = 0x40 // bool (Size: 0x1)
ServerAbilityRPCBatch.Ended = 0x41 // bool (Size: 0x1)
ServerAbilityRPCBatch.Started = 0x42 // bool (Size: 0x1)
SetByCallerFloat.DataName = 0x0 // FName (Size: 0x8)
SetByCallerFloat.DataTag = 0x8 // FGameplayTag (Size: 0x8)
TagContainerAggregator.CapturedActorTags = 0x0 // FGameplayTagContainer (Size: 0x20)
TagContainerAggregator.CapturedSpecTags = 0x20 // FGameplayTagContainer (Size: 0x20)
TagContainerAggregator.ScopedTags = 0x40 // FGameplayTagContainer (Size: 0x20)
WorldReticleParameters.AOEScale = 0x0 // FVector (Size: 0xc)
EditableGameplayTagQuery.UserDescription = 0x28 // FString (Size: 0x10)
EditableGameplayTagQuery.RootExpression = 0x48 // EditableGameplayTagQueryExpression* (Size: 0x8)
EditableGameplayTagQuery.TagQueryExportText_Helper = 0x50 // FGameplayTagQuery (Size: 0x48)
EditableGameplayTagQueryExpression_AllExprMatch.Expressions = 0x28 // TArray<EditableGameplayTagQueryExpression*> (Size: 0x10)
EditableGameplayTagQueryExpression_AllTagsMatch.Tags = 0x28 // FGameplayTagContainer (Size: 0x20)
EditableGameplayTagQueryExpression_AnyExprMatch.Expressions = 0x28 // TArray<EditableGameplayTagQueryExpression*> (Size: 0x10)
EditableGameplayTagQueryExpression_AnyTagsMatch.Tags = 0x28 // FGameplayTagContainer (Size: 0x20)
EditableGameplayTagQueryExpression_NoExprMatch.Expressions = 0x28 // TArray<EditableGameplayTagQueryExpression*> (Size: 0x10)
EditableGameplayTagQueryExpression_NoTagsMatch.Tags = 0x28 // FGameplayTagContainer (Size: 0x20)
GameplayTag.TagName = 0x0 // FName (Size: 0x8)
GameplayTagCategoryRemap.BaseCategory = 0x0 // FString (Size: 0x10)
GameplayTagCategoryRemap.RemapCategories = 0x10 // TArray<FString> (Size: 0x10)
GameplayTagContainer.GameplayTags = 0x0 // TArray<FGameplayTag> (Size: 0x10)
GameplayTagContainer.ParentTags = 0x10 // TArray<FGameplayTag> (Size: 0x10)
GameplayTagQuery.TokenStreamVersion = 0x0 // int32_t (Size: 0x4)
GameplayTagQuery.TagDictionary = 0x8 // TArray<FGameplayTag> (Size: 0x10)
GameplayTagQuery.QueryTokenStream = 0x18 // TArray<uint8_t> (Size: 0x10)
GameplayTagQuery.UserDescription = 0x28 // FString (Size: 0x10)
GameplayTagQuery.AutoDescription = 0x38 // FString (Size: 0x10)
GameplayTagRedirect.OldTagName = 0x0 // FName (Size: 0x8)
GameplayTagRedirect.NewTagName = 0x8 // FName (Size: 0x8)
GameplayTagSource.SourceName = 0x0 // FName (Size: 0x8)
GameplayTagSource.SourceType = 0x8 // EEGameplayTagSourceType (Size: 0x1)
GameplayTagSource.SourceTagList = 0x10 // GameplayTagsList* (Size: 0x8)
GameplayTagSource.SourceRestrictedTagList = 0x18 // RestrictedGameplayTagsList* (Size: 0x8)
GameplayTagTableRow.Tag = 0x8 // FName (Size: 0x8)
GameplayTagTableRow.DevComment = 0x10 // FString (Size: 0x10)
GameplayTagsDeveloperSettings.DeveloperConfigName = 0x38 // FString (Size: 0x10)
GameplayTagsDeveloperSettings.FavoriteTagSource = 0x48 // FName (Size: 0x8)
GameplayTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
GameplayTagsList.GameplayTagList = 0x38 // TArray<FGameplayTagTableRow> (Size: 0x10)
GameplayTagsManager.TagSources = 0xc0 // TArray<FGameplayTagSource> (Size: 0x10)
GameplayTagsManager.GameplayTagTables = 0x1d8 // TArray<DataTable*> (Size: 0x10)
GameplayTagsSettings.ImportTagsFromConfig = 0x48 // bool (Size: 0x1)
GameplayTagsSettings.WarnOnInvalidTags = 0x49 // bool (Size: 0x1)
GameplayTagsSettings.FastReplication = 0x4a // bool (Size: 0x1)
GameplayTagsSettings.InvalidTagCharacters = 0x50 // FString (Size: 0x10)
GameplayTagsSettings.CategoryRemapping = 0x60 // TArray<FGameplayTagCategoryRemap> (Size: 0x10)
GameplayTagsSettings.GameplayTagTableList = 0x70 // TArray<FSoftObjectPath> (Size: 0x10)
GameplayTagsSettings.GameplayTagRedirects = 0x80 // TArray<FGameplayTagRedirect> (Size: 0x10)
GameplayTagsSettings.CommonlyReplicatedTags = 0x90 // TArray<FName> (Size: 0x10)
GameplayTagsSettings.NumBitsForContainerSize = 0xa0 // int32_t (Size: 0x4)
GameplayTagsSettings.NetIndexFirstBitSegment = 0xa4 // int32_t (Size: 0x4)
GameplayTagsSettings.RestrictedConfigFiles = 0xa8 // TArray<FRestrictedConfigInfo> (Size: 0x10)
RestrictedConfigInfo.RestrictedConfigName = 0x0 // FString (Size: 0x10)
RestrictedConfigInfo.Owners = 0x10 // TArray<FString> (Size: 0x10)
RestrictedGameplayTagTableRow.bAllowNonRestrictedChildren = 0x20 // bool (Size: 0x1)
RestrictedGameplayTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
RestrictedGameplayTagsList.RestrictedGameplayTagList = 0x38 // TArray<FRestrictedGameplayTagTableRow> (Size: 0x10)
GameplayTask.InstanceName = 0x30 // FName (Size: 0x8)
GameplayTask.ResourceOverlapPolicy = 0x3a // EETaskResourceOverlapPolicy (Size: 0x1)
GameplayTask.ChildTask = 0x60 // GameplayTask* (Size: 0x8)
GameplayTaskResource.ManualResourceID = 0x28 // int32_t (Size: 0x4)
GameplayTaskResource.AutoResourceID = 0x2c // int8_t (Size: 0x1)
GameplayTaskResource.bManuallySetID = 0x30 // uint8_t (Size: 0x1)
GameplayTask_SpawnActor.Success = 0x68 // FMulticastInlineDelegate (Size: 0x10)
GameplayTask_SpawnActor.DidNotSpawn = 0x78 // FMulticastInlineDelegate (Size: 0x10)
GameplayTask_SpawnActor.ClassToSpawn = 0xa0 // ClassProperty (Size: 0x8)
GameplayTask_TimeLimitedExecution.OnFinished = 0x68 // FMulticastInlineDelegate (Size: 0x10)
GameplayTask_TimeLimitedExecution.OnTimeExpired = 0x78 // FMulticastInlineDelegate (Size: 0x10)
GameplayTask_WaitDelay.OnFinish = 0x68 // FMulticastInlineDelegate (Size: 0x10)
GameplayTasksComponent.bIsNetDirty = 0x104 // uint8_t (Size: 0x1)
GameplayTasksComponent.SimulatedTasks = 0x108 // TArray<GameplayTask*> (Size: 0x10)
GameplayTasksComponent.TaskPriorityQueue = 0x118 // TArray<GameplayTask*> (Size: 0x10)
GameplayTasksComponent.TickingTasks = 0x138 // TArray<GameplayTask*> (Size: 0x10)
GameplayTasksComponent.KnownTasks = 0x148 // TArray<GameplayTask*> (Size: 0x10)
GameplayTasksComponent.OnClaimedResourcesChange = 0x158 // FMulticastInlineDelegate (Size: 0x10)
GeometryCache.Materials = 0x30 // TArray<MaterialInterface*> (Size: 0x10)
GeometryCache.Tracks = 0x40 // TArray<GeometryCacheTrack*> (Size: 0x10)
GeometryCache.StartFrame = 0x60 // int32_t (Size: 0x4)
GeometryCache.EndFrame = 0x64 // int32_t (Size: 0x4)
GeometryCacheActor.GeometryCacheComponent = 0x310 // GeometryCacheComponent* (Size: 0x8)
GeometryCacheCodecBase.TopologyRanges = 0x28 // TArray<int32_t> (Size: 0x10)
GeometryCacheCodecRaw.DummyProperty = 0x38 // int32_t (Size: 0x4)
GeometryCacheComponent.GeometryCache = 0x600 // GeometryCache* (Size: 0x8)
GeometryCacheComponent.bRunning = 0x608 // bool (Size: 0x1)
GeometryCacheComponent.bLooping = 0x609 // bool (Size: 0x1)
GeometryCacheComponent.StartTimeOffset = 0x60c // float (Size: 0x4)
GeometryCacheComponent.PlaybackSpeed = 0x610 // float (Size: 0x4)
GeometryCacheComponent.NumTracks = 0x614 // int32_t (Size: 0x4)
GeometryCacheComponent.ElapsedTime = 0x618 // float (Size: 0x4)
GeometryCacheComponent.Duration = 0x64c // float (Size: 0x4)
GeometryCacheComponent.bManualTick = 0x650 // bool (Size: 0x1)
GeometryCacheTrack.Duration = 0x28 // float (Size: 0x4)
GeometryCacheTrackStreamable.Codec = 0x58 // GeometryCacheCodecBase* (Size: 0x8)
GeometryCacheTrackStreamable.StartSampleTime = 0xc8 // float (Size: 0x4)
GeometryCacheTrack_FlipbookAnimation.NumMeshSamples = 0x58 // uint32_t (Size: 0x4)
MovieSceneGeometryCacheParams.GeometryCacheAsset = 0x0 // GeometryCache* (Size: 0x8)
MovieSceneGeometryCacheParams.FirstLoopStartFrameOffset = 0x8 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCacheParams.StartFrameOffset = 0xc // FFrameNumber (Size: 0x4)
MovieSceneGeometryCacheParams.EndFrameOffset = 0x10 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCacheParams.PlayRate = 0x14 // float (Size: 0x4)
MovieSceneGeometryCacheParams.bReverse = 0x18 // uint8_t (Size: 0x1)
MovieSceneGeometryCacheParams.StartOffset = 0x1c // float (Size: 0x4)
MovieSceneGeometryCacheParams.EndOffset = 0x20 // float (Size: 0x4)
MovieSceneGeometryCacheParams.GeometryCache = 0x28 // FSoftObjectPath (Size: 0x18)
MovieSceneGeometryCacheSection.Params = 0xe8 // FMovieSceneGeometryCacheParams (Size: 0x40)
MovieSceneGeometryCacheSectionTemplate.Params = 0x20 // FMovieSceneGeometryCacheSectionTemplateParameters (Size: 0x48)
MovieSceneGeometryCacheSectionTemplateParameters.SectionStartTime = 0x40 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCacheSectionTemplateParameters.SectionEndTime = 0x44 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCacheTrack.AnimationSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
ChaosBreakingEventData.Location = 0x0 // FVector (Size: 0xc)
ChaosBreakingEventData.Velocity = 0xc // FVector (Size: 0xc)
ChaosBreakingEventData.Mass = 0x18 // float (Size: 0x4)
ChaosBreakingEventRequestSettings.MaxNumberOfResults = 0x0 // int32_t (Size: 0x4)
ChaosBreakingEventRequestSettings.MinRadius = 0x4 // float (Size: 0x4)
ChaosBreakingEventRequestSettings.MinSpeed = 0x8 // float (Size: 0x4)
ChaosBreakingEventRequestSettings.MinMass = 0xc // float (Size: 0x4)
ChaosBreakingEventRequestSettings.MaxDistance = 0x10 // float (Size: 0x4)
ChaosBreakingEventRequestSettings.SortMethod = 0x14 // EEChaosBreakingSortMethod (Size: 0x1)
ChaosCollisionEventData.Location = 0x0 // FVector (Size: 0xc)
ChaosCollisionEventData.Normal = 0xc // FVector (Size: 0xc)
ChaosCollisionEventData.Velocity1 = 0x18 // FVector (Size: 0xc)
ChaosCollisionEventData.Velocity2 = 0x24 // FVector (Size: 0xc)
ChaosCollisionEventData.Mass1 = 0x30 // float (Size: 0x4)
ChaosCollisionEventData.Mass2 = 0x34 // float (Size: 0x4)
ChaosCollisionEventData.Impulse = 0x38 // FVector (Size: 0xc)
ChaosCollisionEventRequestSettings.MaxNumberResults = 0x0 // int32_t (Size: 0x4)
ChaosCollisionEventRequestSettings.MinMass = 0x4 // float (Size: 0x4)
ChaosCollisionEventRequestSettings.MinSpeed = 0x8 // float (Size: 0x4)
ChaosCollisionEventRequestSettings.MinImpulse = 0xc // float (Size: 0x4)
ChaosCollisionEventRequestSettings.MaxDistance = 0x10 // float (Size: 0x4)
ChaosCollisionEventRequestSettings.SortMethod = 0x14 // EEChaosCollisionSortMethod (Size: 0x1)
ChaosDestructionListener.bIsCollisionEventListeningEnabled = 0x238 // uint8_t (Size: 0x1)
ChaosDestructionListener.bIsBreakingEventListeningEnabled = 0x238 // uint8_t (Size: 0x1)
ChaosDestructionListener.bIsTrailingEventListeningEnabled = 0x238 // uint8_t (Size: 0x1)
ChaosDestructionListener.CollisionEventRequestSettings = 0x23c // FChaosCollisionEventRequestSettings (Size: 0x18)
ChaosDestructionListener.BreakingEventRequestSettings = 0x254 // FChaosBreakingEventRequestSettings (Size: 0x18)
ChaosDestructionListener.TrailingEventRequestSettings = 0x26c // FChaosTrailingEventRequestSettings (Size: 0x18)
ChaosDestructionListener.ChaosSolverActors = 0x288 // TSet<...> (Size: 0x50)
ChaosDestructionListener.GeometryCollectionActors = 0x2d8 // TSet<...> (Size: 0x50)
ChaosDestructionListener.OnCollisionEvents = 0x328 // FMulticastInlineDelegate (Size: 0x10)
ChaosDestructionListener.OnBreakingEvents = 0x338 // FMulticastInlineDelegate (Size: 0x10)
ChaosDestructionListener.OnTrailingEvents = 0x348 // FMulticastInlineDelegate (Size: 0x10)
ChaosTrailingEventData.Location = 0x0 // FVector (Size: 0xc)
ChaosTrailingEventData.Velocity = 0xc // FVector (Size: 0xc)
ChaosTrailingEventData.AngularVelocity = 0x18 // FVector (Size: 0xc)
ChaosTrailingEventData.Mass = 0x24 // float (Size: 0x4)
ChaosTrailingEventData.ParticleIndex = 0x28 // int32_t (Size: 0x4)
ChaosTrailingEventRequestSettings.MaxNumberOfResults = 0x0 // int32_t (Size: 0x4)
ChaosTrailingEventRequestSettings.MinMass = 0x4 // float (Size: 0x4)
ChaosTrailingEventRequestSettings.MinSpeed = 0x8 // float (Size: 0x4)
ChaosTrailingEventRequestSettings.MinAngularSpeed = 0xc // float (Size: 0x4)
ChaosTrailingEventRequestSettings.MaxDistance = 0x10 // float (Size: 0x4)
ChaosTrailingEventRequestSettings.SortMethod = 0x14 // EEChaosTrailingSortMethod (Size: 0x1)
GeomComponentCacheParameters.CacheMode = 0x0 // EEGeometryCollectionCacheType (Size: 0x1)
GeomComponentCacheParameters.TargetCache = 0x8 // GeometryCollectionCache* (Size: 0x8)
GeomComponentCacheParameters.ReverseCacheBeginTime = 0x10 // float (Size: 0x4)
GeomComponentCacheParameters.SaveCollisionData = 0x14 // bool (Size: 0x1)
GeomComponentCacheParameters.DoGenerateCollisionData = 0x15 // bool (Size: 0x1)
GeomComponentCacheParameters.CollisionDataSizeMax = 0x18 // int32_t (Size: 0x4)
GeomComponentCacheParameters.DoCollisionDataSpatialHash = 0x1c // bool (Size: 0x1)
GeomComponentCacheParameters.CollisionDataSpatialHashRadius = 0x20 // float (Size: 0x4)
GeomComponentCacheParameters.MaxCollisionPerCell = 0x24 // int32_t (Size: 0x4)
GeomComponentCacheParameters.SaveBreakingData = 0x28 // bool (Size: 0x1)
GeomComponentCacheParameters.DoGenerateBreakingData = 0x29 // bool (Size: 0x1)
GeomComponentCacheParameters.BreakingDataSizeMax = 0x2c // int32_t (Size: 0x4)
GeomComponentCacheParameters.DoBreakingDataSpatialHash = 0x30 // bool (Size: 0x1)
GeomComponentCacheParameters.BreakingDataSpatialHashRadius = 0x34 // float (Size: 0x4)
GeomComponentCacheParameters.MaxBreakingPerCell = 0x38 // int32_t (Size: 0x4)
GeomComponentCacheParameters.SaveTrailingData = 0x3c // bool (Size: 0x1)
GeomComponentCacheParameters.DoGenerateTrailingData = 0x3d // bool (Size: 0x1)
GeomComponentCacheParameters.TrailingDataSizeMax = 0x40 // int32_t (Size: 0x4)
GeomComponentCacheParameters.TrailingMinSpeedThreshold = 0x44 // float (Size: 0x4)
GeomComponentCacheParameters.TrailingMinVolumeThreshold = 0x48 // float (Size: 0x4)
GeometryCollection.GeometrySource = 0x30 // TArray<FGeometryCollectionSource> (Size: 0x10)
GeometryCollection.Materials = 0x40 // TArray<MaterialInterface*> (Size: 0x10)
GeometryCollection.CollisionType = 0x50 // EECollisionTypeEnum (Size: 0x1)
GeometryCollection.ImplicitType = 0x51 // EEImplicitTypeEnum (Size: 0x1)
GeometryCollection.MinLevelSetResolution = 0x54 // int32_t (Size: 0x4)
GeometryCollection.MaxLevelSetResolution = 0x58 // int32_t (Size: 0x4)
GeometryCollection.MinClusterLevelSetResolution = 0x5c // int32_t (Size: 0x4)
GeometryCollection.MaxClusterLevelSetResolution = 0x60 // int32_t (Size: 0x4)
GeometryCollection.CollisionObjectReductionPercentage = 0x64 // float (Size: 0x4)
GeometryCollection.bMassAsDensity = 0x68 // bool (Size: 0x1)
GeometryCollection.Mass = 0x6c // float (Size: 0x4)
GeometryCollection.MinimumMassClamp = 0x70 // float (Size: 0x4)
GeometryCollection.CollisionParticlesFraction = 0x74 // float (Size: 0x4)
GeometryCollection.MaximumCollisionParticles = 0x78 // int32_t (Size: 0x4)
GeometryCollection.SizeSpecificData = 0x80 // TArray<FGeometryCollectionSizeSpecificData> (Size: 0x10)
GeometryCollection.EnableRemovePiecesOnFracture = 0x90 // bool (Size: 0x1)
GeometryCollection.RemoveOnFractureMaterials = 0x98 // TArray<MaterialInterface*> (Size: 0x10)
GeometryCollection.PersistentGuid = 0xa8 // FGuid (Size: 0x10)
GeometryCollection.StateGuid = 0xb8 // FGuid (Size: 0x10)
GeometryCollection.BoneSelectedMaterialIndex = 0xc8 // int32_t (Size: 0x4)
GeometryCollectionActor.GeometryCollectionComponent = 0x310 // GeometryCollectionComponent* (Size: 0x8)
GeometryCollectionActor.GeometryCollectionDebugDrawComponent = 0x318 // GeometryCollectionDebugDrawComponent* (Size: 0x8)
GeometryCollectionCache.RecordedData = 0x28 // FRecordedTransformTrack (Size: 0x10)
GeometryCollectionCache.SupportedCollection = 0x38 // GeometryCollection* (Size: 0x8)
GeometryCollectionCache.CompatibleCollectionState = 0x40 // FGuid (Size: 0x10)
GeometryCollectionComponent.ChaosSolverActor = 0x608 // ChaosSolverActor* (Size: 0x8)
GeometryCollectionComponent.RestCollection = 0x6f0 // GeometryCollection* (Size: 0x8)
GeometryCollectionComponent.InitializationFields = 0x6f8 // TArray<FieldSystemActor*> (Size: 0x10)
GeometryCollectionComponent.Simulating = 0x708 // bool (Size: 0x1)
GeometryCollectionComponent.ObjectType = 0x710 // EEObjectStateTypeEnum (Size: 0x1)
GeometryCollectionComponent.EnableClustering = 0x711 // bool (Size: 0x1)
GeometryCollectionComponent.ClusterGroupIndex = 0x714 // int32_t (Size: 0x4)
GeometryCollectionComponent.MaxClusterLevel = 0x718 // int32_t (Size: 0x4)
GeometryCollectionComponent.DamageThreshold = 0x720 // TArray<float> (Size: 0x10)
GeometryCollectionComponent.ClusterConnectionType = 0x730 // EEClusterConnectionTypeEnum (Size: 0x1)
GeometryCollectionComponent.CollisionGroup = 0x734 // int32_t (Size: 0x4)
GeometryCollectionComponent.CollisionSampleFraction = 0x738 // float (Size: 0x4)
GeometryCollectionComponent.LinearEtherDrag = 0x73c // float (Size: 0x4)
GeometryCollectionComponent.AngularEtherDrag = 0x740 // float (Size: 0x4)
GeometryCollectionComponent.PhysicalMaterial = 0x748 // ChaosPhysicalMaterial* (Size: 0x8)
GeometryCollectionComponent.InitialVelocityType = 0x750 // EEInitialVelocityTypeEnum (Size: 0x1)
GeometryCollectionComponent.InitialLinearVelocity = 0x754 // FVector (Size: 0xc)
GeometryCollectionComponent.InitialAngularVelocity = 0x760 // FVector (Size: 0xc)
GeometryCollectionComponent.PhysicalMaterialOverride = 0x770 // PhysicalMaterial* (Size: 0x8)
GeometryCollectionComponent.CacheParameters = 0x778 // FGeomComponentCacheParameters (Size: 0x50)
GeometryCollectionComponent.NotifyGeometryCollectionPhysicsStateChange = 0x7c8 // FMulticastInlineDelegate (Size: 0x10)
GeometryCollectionComponent.NotifyGeometryCollectionPhysicsLoadingStateChange = 0x7d8 // FMulticastInlineDelegate (Size: 0x10)
GeometryCollectionComponent.OnChaosBreakEvent = 0x800 // FMulticastInlineDelegate (Size: 0x10)
GeometryCollectionComponent.DesiredCacheTime = 0x810 // float (Size: 0x4)
GeometryCollectionComponent.CachePlayback = 0x814 // bool (Size: 0x1)
GeometryCollectionComponent.OnChaosPhysicsCollision = 0x818 // FMulticastInlineDelegate (Size: 0x10)
GeometryCollectionComponent.bNotifyBreaks = 0x828 // bool (Size: 0x1)
GeometryCollectionComponent.bNotifyCollisions = 0x829 // bool (Size: 0x1)
GeometryCollectionComponent.bEnableReplication = 0x82a // bool (Size: 0x1)
GeometryCollectionComponent.bEnableAbandonAfterLevel = 0x82b // bool (Size: 0x1)
GeometryCollectionComponent.ReplicationAbandonClusterLevel = 0x82c // int32_t (Size: 0x4)
GeometryCollectionComponent.RepData = 0x830 // FGeometryCollectionRepData (Size: 0x18)
GeometryCollectionComponent.DummyBodySetup = 0xa60 // BodySetup* (Size: 0x8)
GeometryCollectionDebugDrawActor.WarningMessage = 0x310 // FGeometryCollectionDebugDrawWarningMessage (Size: 0x1)
GeometryCollectionDebugDrawActor.SelectedRigidBody = 0x318 // FGeometryCollectionDebugDrawActorSelectedRigidBody (Size: 0x18)
GeometryCollectionDebugDrawActor.bDebugDrawWholeCollection = 0x330 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bDebugDrawHierarchy = 0x331 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bDebugDrawClustering = 0x332 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.HideGeometry = 0x333 // EEGeometryCollectionDebugDrawActorHideGeometry (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyId = 0x334 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyCollision = 0x335 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bCollisionAtOrigin = 0x336 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyTransform = 0x337 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyInertia = 0x338 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyVelocity = 0x339 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyForce = 0x33a // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowRigidBodyInfos = 0x33b // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowTransformIndex = 0x33c // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowTransform = 0x33d // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowParent = 0x33e // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowLevel = 0x33f // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowConnectivityEdges = 0x340 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowGeometryIndex = 0x341 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowGeometryTransform = 0x342 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowBoundingBox = 0x343 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowFaces = 0x344 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowFaceIndices = 0x345 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowFaceNormals = 0x346 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowSingleFace = 0x347 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.SingleFaceIndex = 0x348 // int32_t (Size: 0x4)
GeometryCollectionDebugDrawActor.bShowVertices = 0x34c // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowVertexIndices = 0x34d // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bShowVertexNormals = 0x34e // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.bUseActiveVisualization = 0x34f // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.PointThickness = 0x350 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.LineThickness = 0x354 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.bTextShadow = 0x358 // bool (Size: 0x1)
GeometryCollectionDebugDrawActor.TextScale = 0x35c // float (Size: 0x4)
GeometryCollectionDebugDrawActor.NormalScale = 0x360 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.AxisScale = 0x364 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.ArrowScale = 0x368 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyIdColor = 0x36c // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyTransformScale = 0x370 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyCollisionColor = 0x374 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyInertiaColor = 0x378 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyVelocityColor = 0x37c // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyForceColor = 0x380 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.RigidBodyInfoColor = 0x384 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.TransformIndexColor = 0x388 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.TransformScale = 0x38c // float (Size: 0x4)
GeometryCollectionDebugDrawActor.LevelColor = 0x390 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.ParentColor = 0x394 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.ConnectivityEdgeThickness = 0x398 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.GeometryIndexColor = 0x39c // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.GeometryTransformScale = 0x3a0 // float (Size: 0x4)
GeometryCollectionDebugDrawActor.BoundingBoxColor = 0x3a4 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.FaceColor = 0x3a8 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.FaceIndexColor = 0x3ac // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.FaceNormalColor = 0x3b0 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.SingleFaceColor = 0x3b4 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.VertexColor = 0x3b8 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.VertexIndexColor = 0x3bc // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.VertexNormalColor = 0x3c0 // FColor (Size: 0x4)
GeometryCollectionDebugDrawActor.SpriteComponent = 0x3c8 // BillboardComponent* (Size: 0x8)
GeometryCollectionDebugDrawActorSelectedRigidBody.ID = 0x0 // int32_t (Size: 0x4)
GeometryCollectionDebugDrawActorSelectedRigidBody.Solver = 0x8 // ChaosSolverActor* (Size: 0x8)
GeometryCollectionDebugDrawActorSelectedRigidBody.GeometryCollection = 0x10 // GeometryCollectionActor* (Size: 0x8)
GeometryCollectionDebugDrawComponent.GeometryCollectionDebugDrawActor = 0xf8 // GeometryCollectionDebugDrawActor* (Size: 0x8)
GeometryCollectionDebugDrawComponent.GeometryCollectionRenderLevelSetActor = 0x100 // GeometryCollectionRenderLevelSetActor* (Size: 0x8)
GeometryCollectionRenderLevelSetActor.TargetVolumeTexture = 0x310 // VolumeTexture* (Size: 0x8)
GeometryCollectionRenderLevelSetActor.RayMarchMaterial = 0x318 // Material* (Size: 0x8)
GeometryCollectionRenderLevelSetActor.SurfaceTolerance = 0x320 // float (Size: 0x4)
GeometryCollectionRenderLevelSetActor.Isovalue = 0x324 // float (Size: 0x4)
GeometryCollectionRenderLevelSetActor.Enabled = 0x328 // bool (Size: 0x1)
GeometryCollectionRenderLevelSetActor.RenderVolumeBoundingBox = 0x329 // bool (Size: 0x1)
GeometryCollectionSizeSpecificData.MaxSize = 0x0 // float (Size: 0x4)
GeometryCollectionSizeSpecificData.CollisionType = 0x4 // EECollisionTypeEnum (Size: 0x1)
GeometryCollectionSizeSpecificData.ImplicitType = 0x5 // EEImplicitTypeEnum (Size: 0x1)
GeometryCollectionSizeSpecificData.MinLevelSetResolution = 0x8 // int32_t (Size: 0x4)
GeometryCollectionSizeSpecificData.MaxLevelSetResolution = 0xc // int32_t (Size: 0x4)
GeometryCollectionSizeSpecificData.MinClusterLevelSetResolution = 0x10 // int32_t (Size: 0x4)
GeometryCollectionSizeSpecificData.MaxClusterLevelSetResolution = 0x14 // int32_t (Size: 0x4)
GeometryCollectionSizeSpecificData.CollisionObjectReductionPercentage = 0x18 // int32_t (Size: 0x4)
GeometryCollectionSizeSpecificData.CollisionParticlesFraction = 0x1c // float (Size: 0x4)
GeometryCollectionSizeSpecificData.MaximumCollisionParticles = 0x20 // int32_t (Size: 0x4)
GeometryCollectionSource.SourceGeometryObject = 0x0 // FSoftObjectPath (Size: 0x18)
GeometryCollectionSource.LocalTransform = 0x20 // FTransform (Size: 0x30)
GeometryCollectionSource.SourceMaterial = 0x50 // TArray<MaterialInterface*> (Size: 0x10)
SkeletalMeshSimulationComponent.PhysicalMaterial = 0x100 // ChaosPhysicalMaterial* (Size: 0x8)
SkeletalMeshSimulationComponent.ChaosSolverActor = 0x108 // ChaosSolverActor* (Size: 0x8)
SkeletalMeshSimulationComponent.OverridePhysicsAsset = 0x110 // PhysicsAsset* (Size: 0x8)
SkeletalMeshSimulationComponent.bSimulating = 0x118 // bool (Size: 0x1)
SkeletalMeshSimulationComponent.bNotifyCollisions = 0x119 // bool (Size: 0x1)
SkeletalMeshSimulationComponent.ObjectType = 0x11a // EEObjectStateTypeEnum (Size: 0x1)
SkeletalMeshSimulationComponent.Density = 0x11c // float (Size: 0x4)
SkeletalMeshSimulationComponent.MinMass = 0x120 // float (Size: 0x4)
SkeletalMeshSimulationComponent.MaxMass = 0x124 // float (Size: 0x4)
SkeletalMeshSimulationComponent.CollisionType = 0x128 // EECollisionTypeEnum (Size: 0x1)
SkeletalMeshSimulationComponent.ImplicitShapeParticlesPerUnitArea = 0x12c // float (Size: 0x4)
SkeletalMeshSimulationComponent.ImplicitShapeMinNumParticles = 0x130 // int32_t (Size: 0x4)
SkeletalMeshSimulationComponent.ImplicitShapeMaxNumParticles = 0x134 // int32_t (Size: 0x4)
SkeletalMeshSimulationComponent.MinLevelSetResolution = 0x138 // int32_t (Size: 0x4)
SkeletalMeshSimulationComponent.MaxLevelSetResolution = 0x13c // int32_t (Size: 0x4)
SkeletalMeshSimulationComponent.CollisionGroup = 0x140 // int32_t (Size: 0x4)
SkeletalMeshSimulationComponent.InitialVelocityType = 0x144 // EEInitialVelocityTypeEnum (Size: 0x1)
SkeletalMeshSimulationComponent.InitialLinearVelocity = 0x148 // FVector (Size: 0xc)
SkeletalMeshSimulationComponent.InitialAngularVelocity = 0x154 // FVector (Size: 0xc)
SkeletalMeshSimulationComponent.OnChaosPhysicsCollision = 0x160 // FMulticastInlineDelegate (Size: 0x10)
StaticMeshSimulationComponent.Simulating = 0x100 // bool (Size: 0x1)
StaticMeshSimulationComponent.bNotifyCollisions = 0x101 // bool (Size: 0x1)
StaticMeshSimulationComponent.ObjectType = 0x102 // EEObjectStateTypeEnum (Size: 0x1)
StaticMeshSimulationComponent.Mass = 0x104 // float (Size: 0x4)
StaticMeshSimulationComponent.CollisionType = 0x108 // EECollisionTypeEnum (Size: 0x1)
StaticMeshSimulationComponent.ImplicitType = 0x109 // EEImplicitTypeEnum (Size: 0x1)
StaticMeshSimulationComponent.MinLevelSetResolution = 0x10c // int32_t (Size: 0x4)
StaticMeshSimulationComponent.MaxLevelSetResolution = 0x110 // int32_t (Size: 0x4)
StaticMeshSimulationComponent.InitialVelocityType = 0x114 // EEInitialVelocityTypeEnum (Size: 0x1)
StaticMeshSimulationComponent.InitialLinearVelocity = 0x118 // FVector (Size: 0xc)
StaticMeshSimulationComponent.InitialAngularVelocity = 0x124 // FVector (Size: 0xc)
StaticMeshSimulationComponent.DamageThreshold = 0x130 // float (Size: 0x4)
StaticMeshSimulationComponent.PhysicalMaterial = 0x138 // ChaosPhysicalMaterial* (Size: 0x8)
StaticMeshSimulationComponent.ChaosSolverActor = 0x140 // ChaosSolverActor* (Size: 0x8)
StaticMeshSimulationComponent.OnChaosPhysicsCollision = 0x148 // FMulticastInlineDelegate (Size: 0x10)
StaticMeshSimulationComponent.SimulatedComponents = 0x168 // TArray<PrimitiveComponent*> (Size: 0x10)
MovieSceneGeometryCollectionParams.GeometryCollectionCache = 0x8 // FSoftObjectPath (Size: 0x18)
MovieSceneGeometryCollectionParams.StartFrameOffset = 0x20 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCollectionParams.EndFrameOffset = 0x24 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCollectionParams.PlayRate = 0x28 // float (Size: 0x4)
MovieSceneGeometryCollectionSection.Params = 0xe8 // FMovieSceneGeometryCollectionParams (Size: 0x30)
MovieSceneGeometryCollectionSectionTemplate.Params = 0x20 // FMovieSceneGeometryCollectionSectionTemplateParameters (Size: 0x38)
MovieSceneGeometryCollectionSectionTemplateParameters.SectionStartTime = 0x30 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCollectionSectionTemplateParameters.SectionEndTime = 0x34 // FFrameNumber (Size: 0x4)
MovieSceneGeometryCollectionTrack.AnimationSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
CallJS.Success = 0x30 // FMulticastInlineDelegate (Size: 0x10)
CallJS.Failure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
H5UIScene.MessageDelegate = 0x130 // FMulticastInlineDelegate (Size: 0x10)
H5UIScene.ShowDelegate = 0x140 // FMulticastInlineDelegate (Size: 0x10)
H5UIScene.CloseDelegate = 0x150 // FMulticastInlineDelegate (Size: 0x10)
H5UIScene.H5UISubsystem = 0x1b0 // H5UISubsystem* (Size: 0x8)
H5UISettings.GameId = 0x28 // FString (Size: 0x10)
H5UISettings.Server = 0x38 // FString (Size: 0x10)
H5UISettings.Version = 0x48 // FString (Size: 0x10)
LoadScene.Success = 0x48 // FMulticastInlineDelegate (Size: 0x10)
LoadScene.Failure = 0x58 // FMulticastInlineDelegate (Size: 0x10)
LoadScene.Callback = 0x68 // FDelegate (Size: 0x10)
LoadScene.WorldContextObject = 0x78 // Object* (Size: 0x8)
BluEye.Settings = 0x38 // FBluEyeSettings (Size: 0x14)
BluEye.TextureParameterName = 0x4c // FName (Size: 0x8)
BluEye.LogEventEmitter = 0x58 // FMulticastInlineDelegate (Size: 0x10)
BluEye.ViewTexture = 0x68 // Texture2D* (Size: 0x8)
BluEye.PopupTexture = 0x70 // Texture2D* (Size: 0x8)
BluEye.OldViewTexture = 0x78 // Texture2D* (Size: 0x8)
BluEye.OldPopupTexture = 0x80 // Texture2D* (Size: 0x8)
BluEye.MaterialInstance = 0x88 // MaterialInstanceDynamic* (Size: 0x8)
BluEyeSettings.FrameRate = 0x0 // float (Size: 0x4)
BluEyeSettings.bIsTransparent = 0x4 // bool (Size: 0x1)
BluEyeSettings.Width = 0x8 // int32_t (Size: 0x4)
BluEyeSettings.Height = 0xc // int32_t (Size: 0x4)
BluEyeSettings.bEnableWebGL = 0x10 // bool (Size: 0x1)
BluEyeSettings.bAudioMuted = 0x11 // bool (Size: 0x1)
BluEyeSettings.bAutoPlayEnabled = 0x12 // bool (Size: 0x1)
H5UIBasicConfigure.ServerAddress = 0x0 // FString (Size: 0x10)
H5UIBasicConfigure.Version = 0x10 // FString (Size: 0x10)
H5UIBasicConfigure.GameId = 0x20 // FString (Size: 0x10)
H5UIBasicConfigure.DeviceID = 0x30 // FString (Size: 0x10)
H5UIBasicConfigure.ChannelID = 0x40 // FString (Size: 0x10)
H5UIBasicConfigure.UserID = 0x50 // FString (Size: 0x10)
H5UIBasicConfigure.Role = 0x60 // FString (Size: 0x10)
H5UIBasicConfigure.Area = 0x70 // FString (Size: 0x10)
H5UIBasicConfigure.Os = 0x80 // FString (Size: 0x10)
H5UIBasicConfigure.Seq = 0x90 // FString (Size: 0x10)
H5UIBasicConfigure.Token = 0xa0 // FString (Size: 0x10)
H5UIBasicConfigure.LoggerServer = 0xb0 // FString (Size: 0x10)
H5UICacheEntry.Filename = 0x0 // FString (Size: 0x10)
H5UICacheEntry.FileHash = 0x10 // FString (Size: 0x10)
H5UICacheEntry.ExpirationTime = 0x20 // int64_t (Size: 0x8)
H5UICacheEntry.MetaData = 0x28 // TMap<...> (Size: 0x50)
H5UICacheFileItem.URL = 0x0 // FString (Size: 0x10)
H5UICacheFileItem.Hash = 0x10 // FString (Size: 0x10)
H5UICacheFileItem.Expire = 0x20 // int64_t (Size: 0x8)
H5UICacheMeta.DiskCache = 0x0 // TMap<...> (Size: 0x50)
H5UIConfigure.Prerender = 0x0 // bool (Size: 0x1)
H5UIConfigure.Index = 0x8 // FString (Size: 0x10)
H5UIConfigure.LoggerEndpoint = 0x18 // FString (Size: 0x10)
H5UIConfigure.LoggerLevel = 0x28 // FString (Size: 0x10)
H5UIConfigure.BackgroundColor = 0x38 // FString (Size: 0x10)
H5UIConfigure.ReserveStatusBar = 0x48 // bool (Size: 0x1)
H5UIConfigure.DisableHitAnimation = 0x49 // bool (Size: 0x1)
H5UILoggerInfo.Timestamp = 0x0 // int64_t (Size: 0x8)
H5UILoggerInfo.Level = 0x8 // FString (Size: 0x10)
H5UILoggerInfo.File = 0x18 // FString (Size: 0x10)
H5UILoggerInfo.Line = 0x28 // int32_t (Size: 0x4)
H5UILoggerInfo.Function = 0x30 // FString (Size: 0x10)
H5UILoggerInfo.Sence = 0x40 // int32_t (Size: 0x4)
H5UILoggerInfo.Message = 0x48 // FString (Size: 0x10)
H5UILoggerInfo.Pid = 0x58 // FString (Size: 0x10)
H5UILoggerInfo.uid = 0x68 // FString (Size: 0x10)
H5UILoggerInfo.Did = 0x78 // FString (Size: 0x10)
H5UILoggerInfo.Os = 0x88 // FString (Size: 0x10)
H5UILoggerInfo.Role = 0x98 // FString (Size: 0x10)
H5UIManifestConfigure.Version = 0x0 // int32_t (Size: 0x4)
H5UIManifestConfigure.Configure = 0x8 // FH5UIConfigure (Size: 0x50)
H5UIManifestConfigure.Tasks = 0x58 // TArray<FH5UITaskConfigure> (Size: 0x10)
H5UIServerAPIResponse.Code = 0x0 // int32_t (Size: 0x4)
H5UIServerAPIResponse.Message = 0x8 // FString (Size: 0x10)
H5UIServerAPIResponse.Data = 0x18 // FH5UIManifestConfigure (Size: 0x68)
H5UIShareInfo.Channel = 0x0 // FString (Size: 0x10)
H5UIShareInfo.AppID = 0x10 // FString (Size: 0x10)
H5UIShareInfo.Content = 0x20 // FString (Size: 0x10)
H5UIShareInfo.Link = 0x30 // FString (Size: 0x10)
H5UIShareInfo.Image = 0x40 // FString (Size: 0x10)
H5UIShareInfo.URL = 0x50 // FString (Size: 0x10)
H5UITaskConfigure.Command = 0x0 // FString (Size: 0x10)
H5UITaskConfigure.Name = 0x10 // FString (Size: 0x10)
H5UITaskConfigure.ReserveCount = 0x20 // int32_t (Size: 0x4)
H5UITaskConfigure.Expire = 0x28 // int64_t (Size: 0x8)
H5UITaskConfigure.Urls = 0x30 // TArray<FString> (Size: 0x10)
H5UITaskConfigure.ActualSize = 0x40 // int64_t (Size: 0x8)
H5UITaskConfigure.Domain = 0x48 // FString (Size: 0x10)
H5UITaskConfigure.Files = 0x58 // TArray<FH5UICacheFileItem> (Size: 0x10)
H5UITaskConfigure.Hash = 0x68 // FString (Size: 0x10)
H5UITaskConfigure.Size = 0x78 // int64_t (Size: 0x8)
H5UITaskConfigure.URL = 0x80 // FString (Size: 0x10)
H5UITaskConfigure.AllowAnonymous = 0x90 // bool (Size: 0x1)
H5UITaskConfigure.Stage = 0x98 // FString (Size: 0x10)
H5UITaskConfigure.ReserveSize = 0xa8 // int32_t (Size: 0x4)
H5UITaskConfigure.ReserveAge = 0xac // int32_t (Size: 0x4)
H5UIWebView.Owner = 0x298 // Object* (Size: 0x8)
H5UIWebView.BluEye = 0x320 // BluEye* (Size: 0x8)
H5UIWebView.ParentWidget = 0x328 // PanelWidget* (Size: 0x8)
H5UIWebView.CanvasPanel = 0x330 // CanvasPanel* (Size: 0x8)
H5UIWebView.HtmlImage = 0x338 // Image* (Size: 0x8)
H5UIWebView.PopupImage = 0x340 // Image* (Size: 0x8)
H5UIWebView.LoadingGrayImage = 0x348 // Image* (Size: 0x8)
H5UIWebView.LoadingWhiteImage = 0x350 // Image* (Size: 0x8)
H5UIWebView.DefaultBackgroundImage = 0x358 // Image* (Size: 0x8)
H5UIWebView.DefaultGrayImage = 0x360 // Image* (Size: 0x8)
H5UIWebView.DefaultWhiteImage = 0x368 // Image* (Size: 0x8)
H5UIWebView.ErrorText = 0x370 // TextBlock* (Size: 0x8)
H5UIWebView.CloseBlackButton = 0x378 // Button* (Size: 0x8)
H5UIWebView.CloseWhiteButton = 0x380 // Button* (Size: 0x8)
H5UIWebView.BackGrayButton = 0x388 // Button* (Size: 0x8)
H5UIWebView.ButtonGrayText = 0x390 // TextBlock* (Size: 0x8)
H5UIWebView.ButtonWhiteText = 0x398 // TextBlock* (Size: 0x8)
H5UIWebView.BackWhiteButton = 0x3a0 // Button* (Size: 0x8)
H5UIWinScene.Webview = 0x90 // H5UIWebView* (Size: 0x8)
H5UIWinScene.BluEye = 0x98 // BluEye* (Size: 0x8)
FollicleMaskOptions.Groom = 0x0 // GroomAsset* (Size: 0x8)
FollicleMaskOptions.Channel = 0x8 // EEFollicleMaskChannel (Size: 0x1)
GoomBindingGroupInfo.RenRootCount = 0x0 // int32_t (Size: 0x4)
GoomBindingGroupInfo.RenLODCount = 0x4 // int32_t (Size: 0x4)
GoomBindingGroupInfo.SimRootCount = 0x8 // int32_t (Size: 0x4)
GoomBindingGroupInfo.SimLODCount = 0xc // int32_t (Size: 0x4)
GroomActor.GroomComponent = 0x310 // GroomComponent* (Size: 0x8)
GroomAsset.HairGroupsInfo = 0x30 // TArray<FHairGroupInfoWithVisibility> (Size: 0x10)
GroomAsset.HairGroupsRendering = 0x40 // TArray<FHairGroupsRendering> (Size: 0x10)
GroomAsset.HairGroupsPhysics = 0x50 // TArray<FHairGroupsPhysics> (Size: 0x10)
GroomAsset.HairGroupsInterpolation = 0x60 // TArray<FHairGroupsInterpolation> (Size: 0x10)
GroomAsset.HairGroupsLOD = 0x70 // TArray<FHairGroupsLOD> (Size: 0x10)
GroomAsset.HairGroupsCards = 0x80 // TArray<FHairGroupsCardsSourceDescription> (Size: 0x10)
GroomAsset.HairGroupsMeshes = 0x90 // TArray<FHairGroupsMeshesSourceDescription> (Size: 0x10)
GroomAsset.HairGroupsMaterials = 0xa0 // TArray<FHairGroupsMaterial> (Size: 0x10)
GroomAsset.EnableGlobalInterpolation = 0xc0 // bool (Size: 0x1)
GroomAsset.HairInterpolationType = 0xc1 // EEGroomInterpolationType (Size: 0x1)
GroomAsset.LODSelectionType = 0xc2 // EEHairLODSelectionType (Size: 0x1)
GroomAsset.MinLOD = 0xc4 // FPerPlatformInt (Size: 0x8)
GroomAsset.DisableBelowMinLodStripping = 0xcc // FPerPlatformBool (Size: 0x1)
GroomAsset.EffectiveLODBias = 0xd0 // TArray<float> (Size: 0x10)
GroomAsset.AssetUserData = 0xe0 // TArray<AssetUserData*> (Size: 0x10)
GroomAssetImportData.ImportOptions = 0x28 // GroomImportOptions* (Size: 0x8)
GroomBindingAsset.Groom = 0x28 // GroomAsset* (Size: 0x8)
GroomBindingAsset.SourceSkeletalMesh = 0x30 // SkeletalMesh* (Size: 0x8)
GroomBindingAsset.TargetSkeletalMesh = 0x38 // SkeletalMesh* (Size: 0x8)
GroomBindingAsset.NumInterpolationPoints = 0x40 // int32_t (Size: 0x4)
GroomBindingAsset.MatchingSection = 0x44 // int32_t (Size: 0x4)
GroomBindingAsset.GroupInfos = 0x48 // TArray<FGoomBindingGroupInfo> (Size: 0x10)
GroomBuildSettings.bOverrideGuides = 0x0 // bool (Size: 0x1)
GroomBuildSettings.HairToGuideDensity = 0x4 // float (Size: 0x4)
GroomBuildSettings.InterpolationQuality = 0x8 // EEGroomInterpolationQuality (Size: 0x1)
GroomBuildSettings.InterpolationDistance = 0x9 // EEGroomInterpolationWeight (Size: 0x1)
GroomBuildSettings.bRandomizeGuide = 0xa // bool (Size: 0x1)
GroomBuildSettings.bUseUniqueGuide = 0xb // bool (Size: 0x1)
GroomComponent.GroomAsset = 0x608 // GroomAsset* (Size: 0x8)
GroomComponent.NiagaraComponents = 0x610 // TArray<NiagaraComponent*> (Size: 0x10)
GroomComponent.SourceSkeletalMesh = 0x620 // SkeletalMesh* (Size: 0x8)
GroomComponent.BindingAsset = 0x628 // GroomBindingAsset* (Size: 0x8)
GroomComponent.PhysicsAsset = 0x630 // PhysicsAsset* (Size: 0x8)
GroomComponent.Strands_DebugMaterial = 0x638 // MaterialInterface* (Size: 0x8)
GroomComponent.Strands_DefaultMaterial = 0x640 // MaterialInterface* (Size: 0x8)
GroomComponent.Cards_DefaultMaterial = 0x648 // MaterialInterface* (Size: 0x8)
GroomComponent.Meshes_DefaultMaterial = 0x650 // MaterialInterface* (Size: 0x8)
GroomComponent.AngularSpringsSystem = 0x658 // NiagaraSystem* (Size: 0x8)
GroomComponent.CosseratRodsSystem = 0x660 // NiagaraSystem* (Size: 0x8)
GroomComponent.AttachmentName = 0x668 // FString (Size: 0x10)
GroomComponent.GroomGroupsDesc = 0x6c0 // TArray<FHairGroupDesc> (Size: 0x10)
GroomConversionSettings.Rotation = 0x0 // FVector (Size: 0xc)
GroomConversionSettings.Scale = 0xc // FVector (Size: 0xc)
GroomCreateBindingOptions.SourceSkeletalMesh = 0x28 // SkeletalMesh* (Size: 0x8)
GroomCreateBindingOptions.TargetSkeletalMesh = 0x30 // SkeletalMesh* (Size: 0x8)
GroomCreateBindingOptions.NumInterpolationPoints = 0x38 // int32_t (Size: 0x4)
GroomCreateBindingOptions.MatchingSection = 0x3c // int32_t (Size: 0x4)
GroomCreateFollicleMaskOptions.Resolution = 0x28 // int32_t (Size: 0x4)
GroomCreateFollicleMaskOptions.RootRadius = 0x2c // int32_t (Size: 0x4)
GroomCreateFollicleMaskOptions.Grooms = 0x30 // TArray<FFollicleMaskOptions> (Size: 0x10)
GroomCreateStrandsTexturesOptions.Resolution = 0x28 // int32_t (Size: 0x4)
GroomCreateStrandsTexturesOptions.TraceType = 0x2c // EEStrandsTexturesTraceType (Size: 0x1)
GroomCreateStrandsTexturesOptions.TraceDistance = 0x30 // float (Size: 0x4)
GroomCreateStrandsTexturesOptions.MeshType = 0x34 // EEStrandsTexturesMeshType (Size: 0x1)
GroomCreateStrandsTexturesOptions.StaticMesh = 0x38 // StaticMesh* (Size: 0x8)
GroomCreateStrandsTexturesOptions.SkeletalMesh = 0x40 // SkeletalMesh* (Size: 0x8)
GroomCreateStrandsTexturesOptions.LODIndex = 0x48 // int32_t (Size: 0x4)
GroomCreateStrandsTexturesOptions.SectionIndex = 0x4c // int32_t (Size: 0x4)
GroomCreateStrandsTexturesOptions.UVChannelIndex = 0x50 // int32_t (Size: 0x4)
GroomCreateStrandsTexturesOptions.GroupIndex = 0x58 // TArray<int32_t> (Size: 0x10)
GroomHairGroupPreview.GroupID = 0x0 // int32_t (Size: 0x4)
GroomHairGroupPreview.CurveCount = 0x4 // int32_t (Size: 0x4)
GroomHairGroupPreview.GuideCount = 0x8 // int32_t (Size: 0x4)
GroomHairGroupPreview.InterpolationSettings = 0xc // FHairGroupsInterpolation (Size: 0x14)
GroomHairGroupsPreview.Groups = 0x28 // TArray<FGroomHairGroupPreview> (Size: 0x10)
GroomImportOptions.ConversionSettings = 0x28 // FGroomConversionSettings (Size: 0x18)
GroomImportOptions.InterpolationSettings = 0x40 // TArray<FHairGroupsInterpolation> (Size: 0x10)
HairAdvancedRenderingSettings.bUseStableRasterization = 0x0 // bool (Size: 0x1)
HairAdvancedRenderingSettings.bScatterSceneLighting = 0x1 // bool (Size: 0x1)
HairBendConstraint.SolveBend = 0x0 // bool (Size: 0x1)
HairBendConstraint.ProjectBend = 0x1 // bool (Size: 0x1)
HairBendConstraint.BendDamping = 0x4 // float (Size: 0x4)
HairBendConstraint.BendStiffness = 0x8 // float (Size: 0x4)
HairBendConstraint.BendScale = 0x10 // FRuntimeFloatCurve (Size: 0x88)
HairCardsClusterSettings.ClusterDecimation = 0x0 // float (Size: 0x4)
HairCardsClusterSettings.Type = 0x4 // EEHairCardsClusterType (Size: 0x1)
HairCardsClusterSettings.bUseGuide = 0x5 // bool (Size: 0x1)
HairCardsGeometrySettings.GenerationType = 0x0 // EEHairCardsGenerationType (Size: 0x1)
HairCardsGeometrySettings.CardsCount = 0x4 // int32_t (Size: 0x4)
HairCardsGeometrySettings.ClusterType = 0x8 // EEHairCardsClusterType (Size: 0x1)
HairCardsGeometrySettings.MinSegmentLength = 0xc // float (Size: 0x4)
HairCardsGeometrySettings.AngularThreshold = 0x10 // float (Size: 0x4)
HairCardsGeometrySettings.MinCardsLength = 0x14 // float (Size: 0x4)
HairCardsGeometrySettings.MaxCardsLength = 0x18 // float (Size: 0x4)
HairCardsTextureSettings.AtlasMaxResolution = 0x0 // int32_t (Size: 0x4)
HairCardsTextureSettings.PixelPerCentimeters = 0x4 // int32_t (Size: 0x4)
HairCardsTextureSettings.LengthTextureCount = 0x8 // int32_t (Size: 0x4)
HairCardsTextureSettings.DensityTextureCount = 0xc // int32_t (Size: 0x4)
HairCollisionConstraint.SolveCollision = 0x0 // bool (Size: 0x1)
HairCollisionConstraint.ProjectCollision = 0x1 // bool (Size: 0x1)
HairCollisionConstraint.StaticFriction = 0x4 // float (Size: 0x4)
HairCollisionConstraint.KineticFriction = 0x8 // float (Size: 0x4)
HairCollisionConstraint.StrandsViscosity = 0xc // float (Size: 0x4)
HairCollisionConstraint.GridDimension = 0x10 // FIntVector (Size: 0xc)
HairCollisionConstraint.CollisionRadius = 0x1c // float (Size: 0x4)
HairCollisionConstraint.RadiusScale = 0x20 // FRuntimeFloatCurve (Size: 0x88)
HairDecimationSettings.CurveDecimation = 0x0 // float (Size: 0x4)
HairDecimationSettings.VertexDecimation = 0x4 // float (Size: 0x4)
HairExternalForces.GravityVector = 0x0 // FVector (Size: 0xc)
HairExternalForces.AirDrag = 0xc // float (Size: 0x4)
HairExternalForces.AirVelocity = 0x10 // FVector (Size: 0xc)
HairGeometrySettings.HairWidth = 0x0 // float (Size: 0x4)
HairGeometrySettings.HairRootScale = 0x4 // float (Size: 0x4)
HairGeometrySettings.HairTipScale = 0x8 // float (Size: 0x4)
HairGeometrySettings.HairClipScale = 0xc // float (Size: 0x4)
HairGroupCardsInfo.NumCards = 0x0 // int32_t (Size: 0x4)
HairGroupCardsInfo.NumCardVertices = 0x4 // int32_t (Size: 0x4)
HairGroupCardsTextures.DepthTexture = 0x0 // Texture2D* (Size: 0x8)
HairGroupCardsTextures.CoverageTexture = 0x8 // Texture2D* (Size: 0x8)
HairGroupCardsTextures.TangentTexture = 0x10 // Texture2D* (Size: 0x8)
HairGroupCardsTextures.AttributeTexture = 0x18 // Texture2D* (Size: 0x8)
HairGroupCardsTextures.AuxilaryDataTexture = 0x20 // Texture2D* (Size: 0x8)
HairGroupDesc.HairCount = 0x0 // int32_t (Size: 0x4)
HairGroupDesc.GuideCount = 0x4 // int32_t (Size: 0x4)
HairGroupDesc.HairLength = 0x8 // float (Size: 0x4)
HairGroupDesc.HairWidth = 0xc // float (Size: 0x4)
HairGroupDesc.HairWidth_Override = 0x10 // bool (Size: 0x1)
HairGroupDesc.HairRootScale = 0x14 // float (Size: 0x4)
HairGroupDesc.HairRootScale_Override = 0x18 // bool (Size: 0x1)
HairGroupDesc.HairTipScale = 0x1c // float (Size: 0x4)
HairGroupDesc.HairTipScale_Override = 0x20 // bool (Size: 0x1)
HairGroupDesc.HairClipLength = 0x24 // float (Size: 0x4)
HairGroupDesc.HairClipLength_Override = 0x28 // bool (Size: 0x1)
HairGroupDesc.HairShadowDensity = 0x2c // float (Size: 0x4)
HairGroupDesc.HairShadowDensity_Override = 0x30 // bool (Size: 0x1)
HairGroupDesc.HairRaytracingRadiusScale = 0x34 // float (Size: 0x4)
HairGroupDesc.HairRaytracingRadiusScale_Override = 0x38 // bool (Size: 0x1)
HairGroupDesc.bUseHairRaytracingGeometry = 0x39 // bool (Size: 0x1)
HairGroupDesc.bUseHairRaytracingGeometry_Override = 0x3a // bool (Size: 0x1)
HairGroupDesc.LODBias = 0x3c // float (Size: 0x4)
HairGroupDesc.bUseStableRasterization = 0x40 // bool (Size: 0x1)
HairGroupDesc.bUseStableRasterization_Override = 0x41 // bool (Size: 0x1)
HairGroupDesc.bScatterSceneLighting = 0x42 // bool (Size: 0x1)
HairGroupDesc.bScatterSceneLighting_Override = 0x43 // bool (Size: 0x1)
HairGroupDesc.bSupportVoxelization = 0x44 // bool (Size: 0x1)
HairGroupDesc.bSupportVoxelization_Override = 0x45 // bool (Size: 0x1)
HairGroupDesc.LODForcedIndex = 0x48 // int32_t (Size: 0x4)
HairGroupInfo.GroupID = 0x0 // int32_t (Size: 0x4)
HairGroupInfo.NumCurves = 0x4 // int32_t (Size: 0x4)
HairGroupInfo.NumGuides = 0x8 // int32_t (Size: 0x4)
HairGroupInfo.NumCurveVertices = 0xc // int32_t (Size: 0x4)
HairGroupInfo.NumGuideVertices = 0x10 // int32_t (Size: 0x4)
HairGroupInfoWithVisibility.bIsVisible = 0x14 // bool (Size: 0x1)
HairGroupsCardsSourceDescription.Material = 0x0 // MaterialInterface* (Size: 0x8)
HairGroupsCardsSourceDescription.MaterialSlotName = 0x8 // FName (Size: 0x8)
HairGroupsCardsSourceDescription.SourceType = 0x10 // EEHairCardsSourceType (Size: 0x1)
HairGroupsCardsSourceDescription.ProceduralMesh = 0x18 // StaticMesh* (Size: 0x8)
HairGroupsCardsSourceDescription.ProceduralMeshKey = 0x20 // FString (Size: 0x10)
HairGroupsCardsSourceDescription.ImportedMesh = 0x30 // StaticMesh* (Size: 0x8)
HairGroupsCardsSourceDescription.ProceduralSettings = 0x38 // FHairGroupsProceduralCards (Size: 0x38)
HairGroupsCardsSourceDescription.Textures = 0x70 // FHairGroupCardsTextures (Size: 0x30)
HairGroupsCardsSourceDescription.GroupIndex = 0xa0 // int32_t (Size: 0x4)
HairGroupsCardsSourceDescription.LODIndex = 0xa4 // int32_t (Size: 0x4)
HairGroupsCardsSourceDescription.CardsInfo = 0xa8 // FHairGroupCardsInfo (Size: 0x8)
HairGroupsCardsSourceDescription.ImportedMeshKey = 0xb0 // FString (Size: 0x10)
HairGroupsInterpolation.DecimationSettings = 0x0 // FHairDecimationSettings (Size: 0x8)
HairGroupsInterpolation.InterpolationSettings = 0x8 // FHairInterpolationSettings (Size: 0xc)
HairGroupsLOD.LODs = 0x0 // TArray<FHairLODSettings> (Size: 0x10)
HairGroupsLOD.ClusterWorldSize = 0x10 // float (Size: 0x4)
HairGroupsLOD.ClusterScreenSizeScale = 0x14 // float (Size: 0x4)
HairGroupsMaterial.Material = 0x0 // MaterialInterface* (Size: 0x8)
HairGroupsMaterial.SlotName = 0x8 // FName (Size: 0x8)
HairGroupsMeshesSourceDescription.Material = 0x0 // MaterialInterface* (Size: 0x8)
HairGroupsMeshesSourceDescription.MaterialSlotName = 0x8 // FName (Size: 0x8)
HairGroupsMeshesSourceDescription.ImportedMesh = 0x10 // StaticMesh* (Size: 0x8)
HairGroupsMeshesSourceDescription.Textures = 0x18 // FHairGroupCardsTextures (Size: 0x30)
HairGroupsMeshesSourceDescription.GroupIndex = 0x48 // int32_t (Size: 0x4)
HairGroupsMeshesSourceDescription.LODIndex = 0x4c // int32_t (Size: 0x4)
HairGroupsMeshesSourceDescription.ImportedMeshKey = 0x50 // FString (Size: 0x10)
HairGroupsPhysics.SolverSettings = 0x0 // FHairSolverSettings (Size: 0x38)
HairGroupsPhysics.ExternalForces = 0x38 // FHairExternalForces (Size: 0x1c)
HairGroupsPhysics.MaterialConstraints = 0x58 // FHairMaterialConstraints (Size: 0x1d8)
HairGroupsPhysics.StrandsParameters = 0x230 // FHairStrandsParameters (Size: 0x98)
HairGroupsProceduralCards.ClusterSettings = 0x0 // FHairCardsClusterSettings (Size: 0x8)
HairGroupsProceduralCards.GeometrySettings = 0x8 // FHairCardsGeometrySettings (Size: 0x1c)
HairGroupsProceduralCards.TextureSettings = 0x24 // FHairCardsTextureSettings (Size: 0x10)
HairGroupsProceduralCards.Version = 0x34 // int32_t (Size: 0x4)
HairGroupsRendering.MaterialSlotName = 0x0 // FName (Size: 0x8)
HairGroupsRendering.Material = 0x8 // MaterialInterface* (Size: 0x8)
HairGroupsRendering.GeometrySettings = 0x10 // FHairGeometrySettings (Size: 0x10)
HairGroupsRendering.ShadowSettings = 0x20 // FHairShadowSettings (Size: 0xc)
HairGroupsRendering.AdvancedSettings = 0x2c // FHairAdvancedRenderingSettings (Size: 0x2)
HairInterpolationSettings.bOverrideGuides = 0x0 // bool (Size: 0x1)
HairInterpolationSettings.HairToGuideDensity = 0x4 // float (Size: 0x4)
HairInterpolationSettings.InterpolationQuality = 0x8 // EEHairInterpolationQuality (Size: 0x1)
HairInterpolationSettings.InterpolationDistance = 0x9 // EEHairInterpolationWeight (Size: 0x1)
HairInterpolationSettings.bRandomizeGuide = 0xa // bool (Size: 0x1)
HairInterpolationSettings.bUseUniqueGuide = 0xb // bool (Size: 0x1)
HairLODSettings.CurveDecimation = 0x0 // float (Size: 0x4)
HairLODSettings.VertexDecimation = 0x4 // float (Size: 0x4)
HairLODSettings.AngularThreshold = 0x8 // float (Size: 0x4)
HairLODSettings.ScreenSize = 0xc // float (Size: 0x4)
HairLODSettings.ThicknessScale = 0x10 // float (Size: 0x4)
HairLODSettings.bVisible = 0x14 // bool (Size: 0x1)
HairLODSettings.GeometryType = 0x15 // EEGroomGeometryType (Size: 0x1)
HairMaterialConstraints.BendConstraint = 0x0 // FHairBendConstraint (Size: 0x98)
HairMaterialConstraints.StretchConstraint = 0x98 // FHairStretchConstraint (Size: 0x98)
HairMaterialConstraints.CollisionConstraint = 0x130 // FHairCollisionConstraint (Size: 0xa8)
HairShadowSettings.HairShadowDensity = 0x0 // float (Size: 0x4)
HairShadowSettings.HairRaytracingRadiusScale = 0x4 // float (Size: 0x4)
HairShadowSettings.bUseHairRaytracingGeometry = 0x8 // bool (Size: 0x1)
HairShadowSettings.bVoxelize = 0x9 // bool (Size: 0x1)
HairSolverSettings.EnableSimulation = 0x0 // bool (Size: 0x1)
HairSolverSettings.NiagaraSolver = 0x1 // EEGroomNiagaraSolvers (Size: 0x1)
HairSolverSettings.CustomSystem = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
HairSolverSettings.SubSteps = 0x30 // int32_t (Size: 0x4)
HairSolverSettings.IterationCount = 0x34 // int32_t (Size: 0x4)
HairStrandsParameters.StrandsSize = 0x0 // EEGroomStrandsSize (Size: 0x1)
HairStrandsParameters.StrandsDensity = 0x4 // float (Size: 0x4)
HairStrandsParameters.StrandsSmoothing = 0x8 // float (Size: 0x4)
HairStrandsParameters.StrandsThickness = 0xc // float (Size: 0x4)
HairStrandsParameters.ThicknessScale = 0x10 // FRuntimeFloatCurve (Size: 0x88)
HairStretchConstraint.SolveStretch = 0x0 // bool (Size: 0x1)
HairStretchConstraint.ProjectStretch = 0x1 // bool (Size: 0x1)
HairStretchConstraint.StretchDamping = 0x4 // float (Size: 0x4)
HairStretchConstraint.StretchStiffness = 0x8 // float (Size: 0x4)
HairStretchConstraint.StretchScale = 0x10 // FRuntimeFloatCurve (Size: 0x88)
NiagaraDataInterfaceHairStrands.DefaultSource = 0x38 // GroomAsset* (Size: 0x8)
NiagaraDataInterfaceHairStrands.SourceActor = 0x40 // Actor* (Size: 0x8)
NiagaraDataInterfacePhysicsAsset.DefaultSource = 0x38 // PhysicsAsset* (Size: 0x8)
NiagaraDataInterfacePhysicsAsset.SourceActor = 0x40 // Actor* (Size: 0x8)
NiagaraDataInterfaceVelocityGrid.GridSize = 0xd8 // FIntVector (Size: 0xc)
AsyncTask_LoadXRDeviceVisComponent.OnModelLoaded = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AsyncTask_LoadXRDeviceVisComponent.OnLoadFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
AsyncTask_LoadXRDeviceVisComponent.SpawnedComponent = 0x58 // PrimitiveComponent* (Size: 0x8)
MotionControllerComponent.PlayerIndex = 0x5c8 // int32_t (Size: 0x4)
MotionControllerComponent.Hand = 0x5cc // EEControllerHand (Size: 0x1)
MotionControllerComponent.MotionSource = 0x5d0 // FName (Size: 0x8)
MotionControllerComponent.bDisableLowLatencyUpdate = 0x5d8 // uint8_t (Size: 0x1)
MotionControllerComponent.CurrentTrackingStatus = 0x5dc // EETrackingStatus (Size: 0x1)
MotionControllerComponent.bDisplayDeviceModel = 0x5dd // bool (Size: 0x1)
MotionControllerComponent.DisplayModelSource = 0x5e0 // FName (Size: 0x8)
MotionControllerComponent.CustomDisplayMesh = 0x5e8 // StaticMesh* (Size: 0x8)
MotionControllerComponent.DisplayMeshMaterialOverrides = 0x5f0 // TArray<MaterialInterface*> (Size: 0x10)
MotionControllerComponent.DisplayComponent = 0x660 // PrimitiveComponent* (Size: 0x8)
VRNotificationsComponent.HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDTrackingInitializedDelegate = 0x108 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDRecenteredDelegate = 0x118 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDLostDelegate = 0x128 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDReconnectedDelegate = 0x138 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDConnectCanceledDelegate = 0x148 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDPutOnHeadDelegate = 0x158 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.HMDRemovedFromHeadDelegate = 0x168 // FMulticastInlineDelegate (Size: 0x10)
VRNotificationsComponent.VRControllerRecenteredDelegate = 0x178 // FMulticastInlineDelegate (Size: 0x10)
XRDeviceId.SystemName = 0x0 // FName (Size: 0x8)
XRDeviceId.DeviceID = 0x8 // int32_t (Size: 0x4)
XRGestureConfig.bTap = 0x0 // bool (Size: 0x1)
XRGestureConfig.bHold = 0x1 // bool (Size: 0x1)
XRGestureConfig.AxisGesture = 0x2 // EESpatialInputGestureAxis (Size: 0x1)
XRGestureConfig.bNavigationAxisX = 0x3 // bool (Size: 0x1)
XRGestureConfig.bNavigationAxisY = 0x4 // bool (Size: 0x1)
XRGestureConfig.bNavigationAxisZ = 0x5 // bool (Size: 0x1)
XRHMDData.bValid = 0x0 // bool (Size: 0x1)
XRHMDData.DeviceName = 0x4 // FName (Size: 0x8)
XRHMDData.ApplicationInstanceID = 0xc // FGuid (Size: 0x10)
XRHMDData.TrackingStatus = 0x1c // EETrackingStatus (Size: 0x1)
XRHMDData.position = 0x20 // FVector (Size: 0xc)
XRHMDData.Rotation = 0x30 // FQuat (Size: 0x10)
XRMotionControllerData.bValid = 0x0 // bool (Size: 0x1)
XRMotionControllerData.DeviceName = 0x4 // FName (Size: 0x8)
XRMotionControllerData.ApplicationInstanceID = 0xc // FGuid (Size: 0x10)
XRMotionControllerData.DeviceVisualType = 0x1c // EEXRVisualType (Size: 0x1)
XRMotionControllerData.HandIndex = 0x1d // EEControllerHand (Size: 0x1)
XRMotionControllerData.TrackingStatus = 0x1e // EETrackingStatus (Size: 0x1)
XRMotionControllerData.GripPosition = 0x20 // FVector (Size: 0xc)
XRMotionControllerData.GripRotation = 0x30 // FQuat (Size: 0x10)
XRMotionControllerData.AimPosition = 0x40 // FVector (Size: 0xc)
XRMotionControllerData.AimRotation = 0x50 // FQuat (Size: 0x10)
XRMotionControllerData.HandKeyPositions = 0x60 // TArray<FVector> (Size: 0x10)
XRMotionControllerData.HandKeyRotations = 0x70 // TArray<FQuat> (Size: 0x10)
XRMotionControllerData.HandKeyRadii = 0x80 // TArray<float> (Size: 0x10)
XRMotionControllerData.bIsGrasped = 0x90 // bool (Size: 0x1)
AnimNode_FKRetarget.TargetMesh = 0x1d8 // TSoftObjectPtr<UObject> (Size: 0x28)
AnimNode_FKRetarget.bEnableFKRetarget = 0x200 // bool (Size: 0x1)
AnimNode_FKRetarget.DefaultRetargetMode = 0x201 // EEFKRetargetMode (Size: 0x1)
AnimNode_FKRetarget.bRetargetRoot = 0x202 // bool (Size: 0x1)
AnimNode_FKRetarget.bRetargetTranslation = 0x203 // bool (Size: 0x1)
AnimNode_FKRetarget.bRetargetRotation = 0x204 // bool (Size: 0x1)
AnimNode_FKRetarget.bRetargetScale = 0x205 // bool (Size: 0x1)
AnimNode_FKRetarget.BoneRetargetModes = 0x208 // TMap<...> (Size: 0x50)
AnimNode_FKRetarget.ExcludedBones = 0x258 // TArray<FName> (Size: 0x10)
AnimNode_IKFootControl.bEnableLeftFootControl = 0xd0 // bool (Size: 0x1)
AnimNode_IKFootControl.LeftFootIKBoneScaleValue = 0xd4 // FVector (Size: 0xc)
AnimNode_IKFootControl.LeftFootTranslationOffset = 0xe0 // FVector (Size: 0xc)
AnimNode_IKFootControl.LeftFootRotationOffset = 0xec // FRotator (Size: 0xc)
AnimNode_IKFootControl.LeftFootInfluenceAlpha = 0xf8 // float (Size: 0x4)
AnimNode_IKFootControl.bEnableRightFootControl = 0xfc // bool (Size: 0x1)
AnimNode_IKFootControl.RightFootIKBoneScaleValue = 0x100 // FVector (Size: 0xc)
AnimNode_IKFootControl.RightFootTranslationOffset = 0x10c // FVector (Size: 0xc)
AnimNode_IKFootControl.RightFootRotationOffset = 0x118 // FRotator (Size: 0xc)
AnimNode_IKFootControl.RightFootInfluenceAlpha = 0x124 // float (Size: 0x4)
AnimNode_IKFootControl.LeftFootIKBone = 0x128 // FBoneReference (Size: 0x10)
AnimNode_IKFootControl.RightFootIKBone = 0x138 // FBoneReference (Size: 0x10)
AnimNode_SingleBoneRotation.TargetBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_SingleBoneRotation.bEnableRotationControl = 0xe0 // bool (Size: 0x1)
AnimNode_SingleBoneRotation.bUseAdditiveRotation = 0xe1 // bool (Size: 0x1)
AnimNode_SingleBoneRotation.TargetRotation = 0xe4 // FRotator (Size: 0xc)
CutoutInfoResult.HasCutout = 0x40 // bool (Size: 0x1)
CutoutInfoResult.IsCutoutHidden = 0x41 // bool (Size: 0x1)
CutoutInfoResult.ScreenHeight = 0x44 // int32_t (Size: 0x4)
CutoutInfoResult.ScreenWidth = 0x48 // int32_t (Size: 0x4)
CutoutInfoResult.StatusBarHeight = 0x4c // int32_t (Size: 0x4)
CutoutInfoResult.CutoutRects = 0x50 // TArray<FCutoutRect> (Size: 0x10)
CutoutInfoResult.SafeArea = 0x60 // FCutoutRect (Size: 0x10)
CutoutRect.Top = 0x0 // int32_t (Size: 0x4)
CutoutRect.Bottom = 0x4 // int32_t (Size: 0x4)
CutoutRect.Left = 0x8 // int32_t (Size: 0x4)
CutoutRect.Right = 0xc // int32_t (Size: 0x4)
INTLAccountProfile.userName = 0x0 // FString (Size: 0x10)
INTLAccountProfile.Birthday = 0x10 // FString (Size: 0x10)
INTLAccountProfile.BirthdayYear = 0x20 // int32_t (Size: 0x4)
INTLAccountProfile.BirthdayMonth = 0x24 // int32_t (Size: 0x4)
INTLAccountProfile.BirthdayDay = 0x28 // int32_t (Size: 0x4)
INTLAccountProfile.isReceiveEmail = 0x2c // int32_t (Size: 0x4)
INTLAccountProfile.Region = 0x30 // FString (Size: 0x10)
INTLAccountProfile.LangType = 0x40 // FString (Size: 0x10)
INTLAccountProfile.extraJson = 0x50 // FString (Size: 0x10)
INTLAccountProfile.Email = 0x60 // FString (Size: 0x10)
INTLAccountProfile.Phone = 0x70 // FString (Size: 0x10)
INTLAccountProfile.PhoneAreaCode = 0x80 // FString (Size: 0x10)
INTLAccountProfile.AccountType = 0x90 // int32_t (Size: 0x4)
INTLAccountProfile.NickName = 0x98 // FString (Size: 0x10)
INTLAccountProfile.PrivacyPolicy = 0xa8 // FString (Size: 0x10)
INTLAccountProfile.TermsOfService = 0xb8 // FString (Size: 0x10)
INTLAccountProfile.PrivacyUpdateTime = 0xc8 // int32_t (Size: 0x4)
INTLAccountProfile.TermsUpdateTime = 0xcc // int32_t (Size: 0x4)
INTLAccountProfile.UsernamePassVerify = 0xd0 // int32_t (Size: 0x4)
INTLAccountResult.ChannelID = 0x40 // int32_t (Size: 0x4)
INTLAccountResult.Channel = 0x48 // FString (Size: 0x10)
INTLAccountResult.SeqId = 0x58 // FString (Size: 0x10)
INTLAccountResult.userName = 0x68 // FString (Size: 0x10)
INTLAccountResult.uid = 0x78 // FString (Size: 0x10)
INTLAccountResult.Token = 0x88 // FString (Size: 0x10)
INTLAccountResult.ExpireTime = 0x98 // int32_t (Size: 0x4)
INTLAccountResult.isRegister = 0x9c // int32_t (Size: 0x4)
INTLAccountResult.isSetPassword = 0xa0 // int32_t (Size: 0x4)
INTLAccountResult.isReceiveEmail = 0xa4 // int32_t (Size: 0x4)
INTLAccountResult.VerifyCodeExpireTime = 0xa8 // int32_t (Size: 0x4)
INTLAccountResult.RequestIsLogin = 0xac // bool (Size: 0x1)
INTLAccountResult.CanBind = 0xb0 // int32_t (Size: 0x4)
INTLAccountResult.LoginDays = 0xb4 // int32_t (Size: 0x4)
INTLAccountResult.PpAcceptanceVersion = 0xb8 // FString (Size: 0x10)
INTLAccountResult.TosAcceptanceVersion = 0xc8 // FString (Size: 0x10)
INTLAccountResult.PpAcceptanceTime = 0xd8 // FDateTime (Size: 0x8)
INTLAccountResult.TosAcceptanceTime = 0xe0 // FDateTime (Size: 0x8)
INTLAccountResult.Profile = 0xe8 // FINTLAccountProfile (Size: 0xd8)
INTLAccountResult.IsUserNameAvailable = 0x1c0 // int32_t (Size: 0x4)
INTLAccountResult.HasGameSaccUid = 0x1c4 // bool (Size: 0x1)
INTLAccountResult.GameSaccUid = 0x1c8 // FString (Size: 0x10)
INTLAccountResult.HasGameSaccOpenId = 0x1d8 // bool (Size: 0x1)
INTLAccountResult.GameSaccOpenId = 0x1e0 // FString (Size: 0x10)
INTLAccountResult.HasLiUid = 0x1f0 // bool (Size: 0x1)
INTLAccountResult.LiUid = 0x1f8 // FString (Size: 0x10)
INTLAccountResult.HasLiOpenId = 0x208 // bool (Size: 0x1)
INTLAccountResult.LiOpenId = 0x210 // FString (Size: 0x10)
INTLAccountResult.NeedNotify = 0x220 // bool (Size: 0x1)
INTLAccountResult.UserAgreedGameTos = 0x228 // FString (Size: 0x10)
INTLAccountResult.UserAgreedGamePP = 0x238 // FString (Size: 0x10)
INTLAccountResult.UserAgreedLiPP = 0x248 // FString (Size: 0x10)
INTLAccountResult.UserAgreedLiDt = 0x258 // FString (Size: 0x10)
INTLAccountResult.UserAgreedLiTos = 0x268 // FString (Size: 0x10)
INTLAdjustAttrsChangedResult.AdjustAttribution = 0x40 // FString (Size: 0x10)
INTLAuthResult.Openid = 0x40 // FString (Size: 0x10)
INTLAuthResult.Token = 0x50 // FString (Size: 0x10)
INTLAuthResult.TokenExpireTime = 0x60 // int32_t (Size: 0x4)
INTLAuthResult.FirstLogin = 0x64 // int32_t (Size: 0x4)
INTLAuthResult.RegChannelDis = 0x68 // FString (Size: 0x10)
INTLAuthResult.userName = 0x78 // FString (Size: 0x10)
INTLAuthResult.Gender = 0x88 // int32_t (Size: 0x4)
INTLAuthResult.Birthday = 0x90 // FString (Size: 0x10)
INTLAuthResult.PicUrl = 0xa0 // FString (Size: 0x10)
INTLAuthResult.Pf = 0xb0 // FString (Size: 0x10)
INTLAuthResult.PfKey = 0xc0 // FString (Size: 0x10)
INTLAuthResult.NeedRealNameAuth = 0xd0 // bool (Size: 0x1)
INTLAuthResult.ChannelID = 0xd4 // int32_t (Size: 0x4)
INTLAuthResult.ChannelName = 0xd8 // EEINTLLoginChannel (Size: 0x1)
INTLAuthResult.ChannelInfo = 0xe0 // FString (Size: 0x10)
INTLAuthResult.ConfirmCode = 0xf0 // FString (Size: 0x10)
INTLAuthResult.ConfirmCodeExpireTime = 0x100 // int32_t (Size: 0x4)
INTLAuthResult.BindList = 0x108 // FString (Size: 0x10)
INTLAuthResult.LegalDocumentsAcceptedVersion = 0x118 // FString (Size: 0x10)
INTLAuthResult.DeleteAccountStatus = 0x128 // int32_t (Size: 0x4)
INTLAuthResult.DeleteAccountInfo = 0x130 // FString (Size: 0x10)
INTLAuthResult.DeleteLIAccountStatus = 0x140 // int32_t (Size: 0x4)
INTLAuthResult.TransferCode = 0x148 // FString (Size: 0x10)
INTLAuthResult.TransferCodeExpireTime = 0x158 // int32_t (Size: 0x4)
INTLAuthResult.Email = 0x160 // FString (Size: 0x10)
INTLBaseResult.methodId = 0x0 // int32_t (Size: 0x4)
INTLBaseResult.RetCode = 0x4 // int32_t (Size: 0x4)
INTLBaseResult.RetMsg = 0x8 // FString (Size: 0x10)
INTLBaseResult.ThirdCode = 0x18 // int32_t (Size: 0x4)
INTLBaseResult.ThirdMsg = 0x20 // FString (Size: 0x10)
INTLBaseResult.extraJson = 0x30 // FString (Size: 0x10)
INTLComplianceResult.AdultStatus = 0x40 // int32_t (Size: 0x4)
INTLComplianceResult.ParentCertificateStatus = 0x44 // int32_t (Size: 0x4)
INTLComplianceResult.ParentCertificateStatusExpiration = 0x48 // FString (Size: 0x10)
INTLComplianceResult.EUUserAgreeStatus = 0x58 // int32_t (Size: 0x4)
INTLComplianceResult.CountryCode = 0x60 // FString (Size: 0x10)
INTLComplianceResult.AdultAge = 0x70 // int32_t (Size: 0x4)
INTLComplianceResult.GameGrade = 0x74 // int32_t (Size: 0x4)
INTLComplianceResult.CertificateType = 0x78 // int32_t (Size: 0x4)
INTLComplianceResult.AdultStatusExpiration = 0x80 // FString (Size: 0x10)
INTLComplianceResult.TS = 0x90 // FString (Size: 0x10)
INTLComplianceResult.IsEEA = 0xa0 // bool (Size: 0x1)
INTLComplianceResult.Region = 0xa8 // FString (Size: 0x10)
INTLComplianceResult.Email = 0xb8 // FString (Size: 0x10)
INTLComplianceResult.RealNameAuthStatus = 0xc8 // int32_t (Size: 0x4)
INTLComplianceResult.NeedRealNameAuth = 0xcc // int32_t (Size: 0x4)
INTLComplianceResult.NeedLICertification = 0xd0 // bool (Size: 0x1)
INTLCustomerResult.MsgType = 0x40 // int32_t (Size: 0x4)
INTLCustomerUserProfile.LangType = 0x0 // FString (Size: 0x10)
INTLCustomerUserProfile.Sign = 0x10 // FString (Size: 0x10)
INTLCustomerUserProfile.Openid = 0x20 // FString (Size: 0x10)
INTLCustomerUserProfile.GameLevel = 0x30 // FString (Size: 0x10)
INTLCustomerUserProfile.NickName = 0x40 // FString (Size: 0x10)
INTLCustomerUserProfile.RoleId = 0x50 // FString (Size: 0x10)
INTLCustomerUserProfile.AreaID = 0x60 // FString (Size: 0x10)
INTLCustomerUserProfile.ZoneId = 0x70 // FString (Size: 0x10)
INTLCustomerUserProfile.GameSvrId = 0x80 // FString (Size: 0x10)
INTLCustomerUserProfile.Region = 0x90 // FString (Size: 0x10)
INTLCustomerUserProfile.PictureUrl = 0xa0 // FString (Size: 0x10)
INTLCustomerUserProfile.CustomParam1 = 0xb0 // FString (Size: 0x10)
INTLCustomerUserProfile.CustomParam2 = 0xc0 // FString (Size: 0x10)
INTLCustomerUserProfile.CustomParam3 = 0xd0 // FString (Size: 0x10)
INTLCustomerUserProfile.CustomParam4 = 0xe0 // FString (Size: 0x10)
INTLCustomerUserProfile.CustomParam5 = 0xf0 // FString (Size: 0x10)
INTLDNSResult.V4 = 0x40 // FString (Size: 0x10)
INTLDNSResult.V6 = 0x50 // FString (Size: 0x10)
INTLDNSResult.Host = 0x60 // FString (Size: 0x10)
INTLDetectNetworkResult.LocalRouterTime = 0x40 // float (Size: 0x4)
INTLDetectNetworkResult.InternetRouterTime = 0x44 // float (Size: 0x4)
INTLDetectNetworkResult.InternetDelay = 0x48 // int32_t (Size: 0x4)
INTLDeviceLevelResult.DeviceLevel = 0x40 // int32_t (Size: 0x4)
INTLDirTreeNode.NodeId = 0x0 // int32_t (Size: 0x4)
INTLDirTreeNode.ParentID = 0x4 // int32_t (Size: 0x4)
INTLDirTreeNode.IsLeaf = 0x8 // bool (Size: 0x1)
INTLDirTreeNode.Name = 0x10 // FString (Size: 0x10)
INTLDirTreeNode.URL = 0x20 // FString (Size: 0x10)
INTLDirTreeNode.status = 0x30 // int32_t (Size: 0x4)
INTLDirTreeNode.Tag = 0x34 // int32_t (Size: 0x4)
INTLDirTreeNode.CustomInt1 = 0x38 // int32_t (Size: 0x4)
INTLDirTreeNode.CustomInt2 = 0x3c // int32_t (Size: 0x4)
INTLDirTreeNode.CustomStr = 0x40 // FString (Size: 0x10)
INTLDirTreeNode.ChildrenIdSet = 0x50 // TArray<int32_t> (Size: 0x10)
INTLDirTreeResult.TreeId = 0x40 // int32_t (Size: 0x4)
INTLDirTreeResult.NodeId = 0x44 // int32_t (Size: 0x4)
INTLDirTreeResult.TreeInfo = 0x48 // FString (Size: 0x10)
INTLDirTreeResult.RoleInfo = 0x58 // FString (Size: 0x10)
INTLDirTreeResult.ExpireTime = 0x68 // int32_t (Size: 0x4)
INTLEventsInfoItem.CanSend = 0x0 // uint8_t (Size: 0x1)
INTLEventsInfoItem.IsSent = 0x1 // uint8_t (Size: 0x1)
INTLEventsInfoItem.Image = 0x8 // FString (Size: 0x10)
INTLEventsInfoItem.Content = 0x18 // FString (Size: 0x10)
INTLEventsInfoItem.eventId = 0x28 // int32_t (Size: 0x4)
INTLEventsInfoItem.rewards = 0x30 // TArray<FINTLRewardItem> (Size: 0x10)
INTLExtendResult.Channel = 0x40 // EEINTLLoginChannel (Size: 0x1)
INTLExtendResult.ExtendMethodName = 0x48 // FString (Size: 0x10)
INTLFriendReqInfo.Type = 0x0 // int32_t (Size: 0x4)
INTLFriendReqInfo.User = 0x8 // FString (Size: 0x10)
INTLFriendReqInfo.Title = 0x18 // FString (Size: 0x10)
INTLFriendReqInfo.Description = 0x28 // FString (Size: 0x10)
INTLFriendReqInfo.ImagePath = 0x38 // FString (Size: 0x10)
INTLFriendReqInfo.ThumbPath = 0x48 // FString (Size: 0x10)
INTLFriendReqInfo.MediaPath = 0x58 // FString (Size: 0x10)
INTLFriendReqInfo.Link = 0x68 // FString (Size: 0x10)
INTLFriendReqInfo.extraJson = 0x78 // FString (Size: 0x10)
INTLFriendResult.FriendInfoList = 0x40 // TArray<FINTLPersonInfo> (Size: 0x10)
INTLGroupReqInfo.worldId = 0x40 // FString (Size: 0x10)
INTLGroupReqInfo.guildId = 0x50 // FString (Size: 0x10)
INTLIDTokenResult.IdToken = 0x40 // FString (Size: 0x10)
INTLLBSIPInfoResult.Region = 0x40 // FString (Size: 0x10)
INTLLBSIPInfoResult.Alpha2 = 0x50 // FString (Size: 0x10)
INTLLBSIPInfoResult.Timestamp = 0x60 // int32_t (Size: 0x4)
INTLLIBindRewardResult.Image = 0x40 // FString (Size: 0x10)
INTLLIBindRewardResult.Content = 0x50 // FString (Size: 0x10)
INTLLIBindRewardResult.CanSend = 0x60 // int32_t (Size: 0x4)
INTLLIBindRewardResult.IsSent = 0x64 // int32_t (Size: 0x4)
INTLLIBindRewardResult.FromNetwork = 0x68 // bool (Size: 0x1)
INTLLIBindRewardResult.eventId = 0x6c // int32_t (Size: 0x4)
INTLLIBindRewardResult.Events = 0x70 // TArray<FINTLEventsInfoItem> (Size: 0x10)
INTLLocalNotification.NotificationID = 0x0 // int32_t (Size: 0x4)
INTLLocalNotification.ActionType = 0x4 // int32_t (Size: 0x4)
INTLLocalNotification.SoundEnabled = 0x8 // int32_t (Size: 0x4)
INTLLocalNotification.Lights = 0xc // int32_t (Size: 0x4)
INTLLocalNotification.Vibrate = 0x10 // int32_t (Size: 0x4)
INTLLocalNotification.FireTime = 0x14 // int32_t (Size: 0x4)
INTLLocalNotification.Title = 0x18 // FString (Size: 0x10)
INTLLocalNotification.Content = 0x28 // FString (Size: 0x10)
INTLLocalNotification.TickerText = 0x38 // FString (Size: 0x10)
INTLLocalNotification.ActionParameter = 0x48 // FString (Size: 0x10)
INTLLocalNotification.RingUri = 0x58 // FString (Size: 0x10)
INTLLocalNotification.SmallIcon = 0x68 // FString (Size: 0x10)
INTLLocalNotificationIOS.RepeatType = 0x0 // int32_t (Size: 0x4)
INTLLocalNotificationIOS.AlertTitle = 0x8 // FString (Size: 0x10)
INTLLocalNotificationIOS.FireTime = 0x18 // int32_t (Size: 0x4)
INTLLocalNotificationIOS.Badge = 0x1c // int32_t (Size: 0x4)
INTLLocalNotificationIOS.AlertBody = 0x20 // FString (Size: 0x10)
INTLLocalNotificationIOS.AlertAction = 0x30 // FString (Size: 0x10)
INTLLocalNotificationIOS.NotificationID = 0x40 // FString (Size: 0x10)
INTLLocalNotificationIOS.UserInfo = 0x50 // TMap<...> (Size: 0x50)
INTLNoticeContent.ContentId = 0x0 // int32_t (Size: 0x4)
INTLNoticeContent.AppContentId = 0x8 // FString (Size: 0x10)
INTLNoticeContent.Title = 0x18 // FString (Size: 0x10)
INTLNoticeContent.Content = 0x28 // FString (Size: 0x10)
INTLNoticeContent.LangType = 0x38 // FString (Size: 0x10)
INTLNoticeContent.UpdateTime = 0x48 // int32_t (Size: 0x4)
INTLNoticeContent.ExtraData = 0x50 // FString (Size: 0x10)
INTLNoticeContent.PictureList = 0x60 // TArray<FINTLNoticePicture> (Size: 0x10)
INTLNoticeInfo.NoticeID = 0x0 // int32_t (Size: 0x4)
INTLNoticeInfo.AppID = 0x8 // FString (Size: 0x10)
INTLNoticeInfo.AppNoticeId = 0x18 // FString (Size: 0x10)
INTLNoticeInfo.status = 0x28 // int32_t (Size: 0x4)
INTLNoticeInfo.StartTime = 0x2c // int32_t (Size: 0x4)
INTLNoticeInfo.EndTime = 0x30 // int32_t (Size: 0x4)
INTLNoticeInfo.UpdateTime = 0x34 // int32_t (Size: 0x4)
INTLNoticeInfo.AreaList = 0x38 // FString (Size: 0x10)
INTLNoticeInfo.PictureList = 0x48 // TArray<FINTLNoticePicture> (Size: 0x10)
INTLNoticeInfo.ExtraData = 0x58 // FString (Size: 0x10)
INTLNoticeInfo.ContentList = 0x68 // TArray<FINTLNoticeContent> (Size: 0x10)
INTLNoticePicture.URL = 0x0 // FString (Size: 0x10)
INTLNoticePicture.Hash = 0x10 // FString (Size: 0x10)
INTLNoticePicture.RedirectURL = 0x20 // FString (Size: 0x10)
INTLNoticePicture.ExtraData = 0x30 // FString (Size: 0x10)
INTLNoticeResult.SeqId = 0x40 // FString (Size: 0x10)
INTLNoticeResult.NoticeInfoList = 0x50 // TArray<FINTLNoticeInfo> (Size: 0x10)
INTLPermissionResult.permission_json_ = 0x40 // FString (Size: 0x10)
INTLPersonInfo.Openid = 0x0 // FString (Size: 0x10)
INTLPersonInfo.userName = 0x10 // FString (Size: 0x10)
INTLPersonInfo.Gender = 0x20 // int32_t (Size: 0x4)
INTLPersonInfo.PictureUrl = 0x28 // FString (Size: 0x10)
INTLPersonInfo.Country = 0x38 // FString (Size: 0x10)
INTLPersonInfo.Province = 0x48 // FString (Size: 0x10)
INTLPersonInfo.City = 0x58 // FString (Size: 0x10)
INTLPersonInfo.Language = 0x68 // FString (Size: 0x10)
INTLPersonInfo.extraJson = 0x78 // FString (Size: 0x10)
INTLPushResult.Type = 0x40 // int32_t (Size: 0x4)
INTLPushResult.Notification = 0x48 // FString (Size: 0x10)
INTLRewardItem.desc = 0x0 // FString (Size: 0x10)
INTLRewardItem.icon = 0x10 // FString (Size: 0x10)
INTLRewardItem.ID = 0x20 // int32_t (Size: 0x4)
INTLRewardItem.Num = 0x24 // int32_t (Size: 0x4)
INTLStartUdpSocketResult.Ip = 0x40 // FString (Size: 0x10)
INTLStartUdpSocketResult.Net_delay = 0x50 // int32_t (Size: 0x4)
INTLStartUdpSocketResult.Port = 0x54 // int32_t (Size: 0x4)
INTLTabExpEntity.ExpName = 0x0 // FString (Size: 0x10)
INTLTabExpEntity.Assignment = 0x10 // FString (Size: 0x10)
INTLTabExpEntity.ExpGrayId = 0x20 // FString (Size: 0x10)
INTLTabExpEntity.LayerName = 0x30 // FString (Size: 0x10)
INTLTabExpEntity.ExpParams = 0x40 // TMap<...> (Size: 0x50)
INTLTabExpEntity.ExpId = 0x90 // int32_t (Size: 0x4)
INTLTabExpEntity.Bucket = 0x94 // int32_t (Size: 0x4)
INTLTabExpEntity.ModuleBucketNum = 0x98 // int32_t (Size: 0x4)
INTLTabExpEntity.percentage = 0x9c // float (Size: 0x4)
INTLTabExpEntity.ExpKey = 0xa0 // FString (Size: 0x10)
INTLTabExpEntity.ExpGroupKey = 0xb0 // FString (Size: 0x10)
INTLTabExpEntity.ModuleCode = 0xc0 // FString (Size: 0x10)
INTLTabExpEntity.Params = 0xd0 // TMap<...> (Size: 0x50)
INTLToolsResult.DeepLinkUrl = 0x40 // FString (Size: 0x10)
INTLToolsResult.ShortLinkUrl = 0x50 // FString (Size: 0x10)
INTLUpdateInitInfo.ActionType = 0x0 // EEINTLUpdateActionType (Size: 0x1)
INTLUpdateInitInfo.RepoID = 0x4 // int32_t (Size: 0x4)
INTLUpdateInitInfo.ResourceCopyType = 0x8 // int32_t (Size: 0x4)
INTLUpdateInitInfo.ResourceSavePath = 0x10 // FString (Size: 0x10)
INTLUpdateInitInfo.FirstResourceDirPath = 0x20 // FString (Size: 0x10)
INTLUpdateOptionalRepoFilesStatus.FilePath = 0x0 // FString (Size: 0x10)
INTLUpdateOptionalRepoFilesStatus.TotalFileNum = 0x10 // int32_t (Size: 0x4)
INTLUpdateOptionalRepoFilesStatus.ValidFileNum = 0x14 // int32_t (Size: 0x4)
INTLUpdateOptionalRepoFilesStatus.NeedDownloadSize = 0x18 // FString (Size: 0x10)
INTLUpdateOptionalRepoInitResult.ActionType = 0x40 // EEINTLUpdateActionType (Size: 0x1)
INTLUpdateOptionalRepoInitResult.RepoID = 0x44 // int32_t (Size: 0x4)
INTLUpdateProgress.methodId = 0x0 // int32_t (Size: 0x4)
INTLUpdateProgress.ActionType = 0x4 // EEINTLUpdateActionType (Size: 0x1)
INTLUpdateProgress.UpdateStep = 0x8 // int32_t (Size: 0x4)
INTLUpdateProgress.RepoID = 0xc // int32_t (Size: 0x4)
INTLUpdateProgress.TaskId = 0x10 // int32_t (Size: 0x4)
INTLUpdateProgress.FinishedSize = 0x18 // FString (Size: 0x10)
INTLUpdateProgress.TotalSize = 0x28 // FString (Size: 0x10)
INTLUpdateProgress.Speed = 0x38 // FString (Size: 0x10)
INTLUpdateProgress.RemainTime = 0x48 // int32_t (Size: 0x4)
INTLUpdateProgress.StepProgress = 0x4c // float (Size: 0x4)
INTLUpdateProgress.TotalProgress = 0x50 // float (Size: 0x4)
INTLUpdateProgress.ErrorMsg = 0x58 // FString (Size: 0x10)
INTLUpdateResult.ActionType = 0x40 // EEINTLUpdateActionType (Size: 0x1)
INTLUpdateResult.RepoID = 0x44 // int32_t (Size: 0x4)
INTLUpdateResult.TaskId = 0x48 // int32_t (Size: 0x4)
INTLUpdateStartRepoNewVersionInfo.methodId = 0x0 // int32_t (Size: 0x4)
INTLUpdateStartRepoNewVersionInfo.ActionType = 0x4 // EEINTLUpdateActionType (Size: 0x1)
INTLUpdateStartRepoNewVersionInfo.NewVersionType = 0x8 // int32_t (Size: 0x4)
INTLUpdateStartRepoNewVersionInfo.Version = 0x10 // FString (Size: 0x10)
INTLUpdateStartRepoNewVersionInfo.NeedDownloadSize = 0x20 // FString (Size: 0x10)
INTLUpdateStartRepoNewVersionInfo.GameDefinedStr = 0x30 // FString (Size: 0x10)
INTLWebViewResult.MsgType = 0x40 // int32_t (Size: 0x4)
INTLWebViewResult.MsgJsonData = 0x48 // FString (Size: 0x10)
ImageWriteOptions.Format = 0x0 // EEDesiredImageFormat (Size: 0x1)
ImageWriteOptions.OnComplete = 0x4 // FDelegate (Size: 0x10)
ImageWriteOptions.CompressionQuality = 0x14 // int32_t (Size: 0x4)
ImageWriteOptions.bOverwriteFile = 0x18 // bool (Size: 0x1)
ImageWriteOptions.bAsync = 0x19 // bool (Size: 0x1)
Key.KeyName = 0x0 // FName (Size: 0x8)
AxisAngleGizmo.AxisSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
AxisAngleGizmo.AngleSource = 0x58 // TScriptInterface<IInterface> (Size: 0x10)
AxisAngleGizmo.HitTarget = 0x68 // TScriptInterface<IInterface> (Size: 0x10)
AxisAngleGizmo.StateTarget = 0x78 // TScriptInterface<IInterface> (Size: 0x10)
AxisAngleGizmo.bInInteraction = 0x88 // bool (Size: 0x1)
AxisAngleGizmo.RotationOrigin = 0x8c // FVector (Size: 0xc)
AxisAngleGizmo.RotationAxis = 0x98 // FVector (Size: 0xc)
AxisAngleGizmo.RotationPlaneX = 0xa4 // FVector (Size: 0xc)
AxisAngleGizmo.RotationPlaneY = 0xb0 // FVector (Size: 0xc)
AxisAngleGizmo.InteractionStartPoint = 0xbc // FVector (Size: 0xc)
AxisAngleGizmo.InteractionCurPoint = 0xc8 // FVector (Size: 0xc)
AxisAngleGizmo.InteractionStartAngle = 0xd4 // float (Size: 0x4)
AxisAngleGizmo.InteractionCurAngle = 0xd8 // float (Size: 0x4)
AxisPositionGizmo.AxisSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
AxisPositionGizmo.ParameterSource = 0x58 // TScriptInterface<IInterface> (Size: 0x10)
AxisPositionGizmo.HitTarget = 0x68 // TScriptInterface<IInterface> (Size: 0x10)
AxisPositionGizmo.StateTarget = 0x78 // TScriptInterface<IInterface> (Size: 0x10)
AxisPositionGizmo.bEnableSignedAxis = 0x88 // bool (Size: 0x1)
AxisPositionGizmo.bInInteraction = 0x89 // bool (Size: 0x1)
AxisPositionGizmo.InteractionOrigin = 0x8c // FVector (Size: 0xc)
AxisPositionGizmo.InteractionAxis = 0x98 // FVector (Size: 0xc)
AxisPositionGizmo.InteractionStartPoint = 0xa4 // FVector (Size: 0xc)
AxisPositionGizmo.InteractionCurPoint = 0xb0 // FVector (Size: 0xc)
AxisPositionGizmo.InteractionStartParameter = 0xbc // float (Size: 0x4)
AxisPositionGizmo.InteractionCurParameter = 0xc0 // float (Size: 0x4)
AxisPositionGizmo.ParameterSign = 0xc4 // float (Size: 0x4)
BaseBrushTool.BrushProperties = 0xc0 // BrushBaseProperties* (Size: 0x8)
BaseBrushTool.bInBrushStroke = 0xc8 // bool (Size: 0x1)
BaseBrushTool.WorldToLocalScale = 0xcc // float (Size: 0x4)
BaseBrushTool.LastBrushStamp = 0xd0 // FBrushStampData (Size: 0xc0)
BaseBrushTool.PropertyClass = 0x1a0 // TSoftClassPtr<UObject> (Size: 0x28)
BaseBrushTool.BrushStampIndicator = 0x1c8 // BrushStampIndicator* (Size: 0x8)
BehaviorInfo.Behavior = 0x0 // InputBehavior* (Size: 0x8)
BrushBaseProperties.BrushSize = 0x60 // float (Size: 0x4)
BrushBaseProperties.bSpecifyRadius = 0x64 // bool (Size: 0x1)
BrushBaseProperties.BrushRadius = 0x68 // float (Size: 0x4)
BrushBaseProperties.BrushStrength = 0x6c // float (Size: 0x4)
BrushBaseProperties.BrushFalloffAmount = 0x70 // float (Size: 0x4)
BrushBaseProperties.bShowStrength = 0x74 // bool (Size: 0x1)
BrushBaseProperties.bShowFalloff = 0x75 // bool (Size: 0x1)
BrushStampIndicator.BrushRadius = 0x38 // float (Size: 0x4)
BrushStampIndicator.BrushFalloff = 0x3c // float (Size: 0x4)
BrushStampIndicator.BrushPosition = 0x40 // FVector (Size: 0xc)
BrushStampIndicator.BrushNormal = 0x4c // FVector (Size: 0xc)
BrushStampIndicator.bDrawIndicatorLines = 0x58 // bool (Size: 0x1)
BrushStampIndicator.bDrawRadiusCircle = 0x59 // bool (Size: 0x1)
BrushStampIndicator.SampleStepCount = 0x5c // int32_t (Size: 0x4)
BrushStampIndicator.LineColor = 0x60 // FLinearColor (Size: 0x10)
BrushStampIndicator.LineThickness = 0x70 // float (Size: 0x4)
BrushStampIndicator.bDepthTested = 0x74 // bool (Size: 0x1)
BrushStampIndicator.bDrawSecondaryLines = 0x75 // bool (Size: 0x1)
BrushStampIndicator.SecondaryLineThickness = 0x78 // float (Size: 0x4)
BrushStampIndicator.SecondaryLineColor = 0x7c // FLinearColor (Size: 0x10)
BrushStampIndicator.AttachedComponent = 0x90 // PrimitiveComponent* (Size: 0x8)
ClickDragInputBehavior.bUpdateModifiersDuringDrag = 0x120 // bool (Size: 0x1)
GizmoArrowComponent.Direction = 0x5e8 // FVector (Size: 0xc)
GizmoArrowComponent.Gap = 0x5f4 // float (Size: 0x4)
GizmoArrowComponent.Length = 0x5f8 // float (Size: 0x4)
GizmoArrowComponent.Thickness = 0x5fc // float (Size: 0x4)
GizmoAxisIntervalParameterSource.FloatParameterSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisIntervalParameterSource.MinParameter = 0x58 // float (Size: 0x4)
GizmoAxisIntervalParameterSource.MaxParameter = 0x5c // float (Size: 0x4)
GizmoAxisRotationParameterSource.AxisSource = 0x90 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisRotationParameterSource.TransformSource = 0xa0 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisRotationParameterSource.Angle = 0xb0 // float (Size: 0x4)
GizmoAxisRotationParameterSource.LastChange = 0xb4 // FGizmoFloatParameterChange (Size: 0x8)
GizmoAxisRotationParameterSource.CurRotationAxis = 0xbc // FVector (Size: 0xc)
GizmoAxisRotationParameterSource.CurRotationOrigin = 0xc8 // FVector (Size: 0xc)
GizmoAxisRotationParameterSource.InitialTransform = 0xe0 // FTransform (Size: 0x30)
GizmoAxisScaleParameterSource.AxisSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisScaleParameterSource.TransformSource = 0x58 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisScaleParameterSource.ScaleMultiplier = 0x68 // float (Size: 0x4)
GizmoAxisScaleParameterSource.Parameter = 0x6c // float (Size: 0x4)
GizmoAxisScaleParameterSource.LastChange = 0x70 // FGizmoFloatParameterChange (Size: 0x8)
GizmoAxisScaleParameterSource.CurScaleAxis = 0x78 // FVector (Size: 0xc)
GizmoAxisScaleParameterSource.CurScaleOrigin = 0x84 // FVector (Size: 0xc)
GizmoAxisScaleParameterSource.InitialTransform = 0x90 // FTransform (Size: 0x30)
GizmoAxisTranslationParameterSource.AxisSource = 0x90 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisTranslationParameterSource.TransformSource = 0xa0 // TScriptInterface<IInterface> (Size: 0x10)
GizmoAxisTranslationParameterSource.Parameter = 0xb0 // float (Size: 0x4)
GizmoAxisTranslationParameterSource.LastChange = 0xb4 // FGizmoFloatParameterChange (Size: 0x8)
GizmoAxisTranslationParameterSource.CurTranslationAxis = 0xbc // FVector (Size: 0xc)
GizmoAxisTranslationParameterSource.CurTranslationOrigin = 0xc8 // FVector (Size: 0xc)
GizmoAxisTranslationParameterSource.InitialTransform = 0xe0 // FTransform (Size: 0x30)
GizmoBaseComponent.Color = 0x5c8 // FLinearColor (Size: 0x10)
GizmoBaseComponent.HoverSizeMultiplier = 0x5d8 // float (Size: 0x4)
GizmoBaseComponent.PixelHitDistanceThreshold = 0x5dc // float (Size: 0x4)
GizmoBoxComponent.Origin = 0x5e8 // FVector (Size: 0xc)
GizmoBoxComponent.Rotation = 0x600 // FQuat (Size: 0x10)
GizmoBoxComponent.Dimensions = 0x610 // FVector (Size: 0xc)
GizmoBoxComponent.LineThickness = 0x61c // float (Size: 0x4)
GizmoBoxComponent.bRemoveHiddenLines = 0x620 // bool (Size: 0x1)
GizmoBoxComponent.bEnableAxisFlip = 0x621 // bool (Size: 0x1)
GizmoCircleComponent.Normal = 0x5e8 // FVector (Size: 0xc)
GizmoCircleComponent.Radius = 0x5f4 // float (Size: 0x4)
GizmoCircleComponent.Thickness = 0x5f8 // float (Size: 0x4)
GizmoCircleComponent.NumSides = 0x5fc // int32_t (Size: 0x4)
GizmoCircleComponent.bViewAligned = 0x600 // bool (Size: 0x1)
GizmoCircleComponent.bOnlyAllowFrontFacingHits = 0x601 // bool (Size: 0x1)
GizmoComponentAxisSource.Component = 0x30 // SceneComponent* (Size: 0x8)
GizmoComponentAxisSource.AxisIndex = 0x38 // int32_t (Size: 0x4)
GizmoComponentAxisSource.bLocalAxes = 0x3c // bool (Size: 0x1)
GizmoComponentHitTarget.Component = 0x30 // PrimitiveComponent* (Size: 0x8)
GizmoComponentWorldTransformSource.Component = 0x48 // SceneComponent* (Size: 0x8)
GizmoComponentWorldTransformSource.bModifyComponentOnTransform = 0x50 // bool (Size: 0x1)
GizmoConstantAxisSource.Origin = 0x30 // FVector (Size: 0xc)
GizmoConstantAxisSource.Direction = 0x3c // FVector (Size: 0xc)
GizmoConstantFrameAxisSource.Origin = 0x30 // FVector (Size: 0xc)
GizmoConstantFrameAxisSource.Direction = 0x3c // FVector (Size: 0xc)
GizmoConstantFrameAxisSource.TangentX = 0x48 // FVector (Size: 0xc)
GizmoConstantFrameAxisSource.TangentY = 0x54 // FVector (Size: 0xc)
GizmoFloatParameterChange.InitialValue = 0x0 // float (Size: 0x4)
GizmoFloatParameterChange.CurrentValue = 0x4 // float (Size: 0x4)
GizmoLineHandleComponent.Normal = 0x5e8 // FVector (Size: 0xc)
GizmoLineHandleComponent.HandleSize = 0x5f4 // float (Size: 0x4)
GizmoLineHandleComponent.Thickness = 0x5f8 // float (Size: 0x4)
GizmoLineHandleComponent.Direction = 0x5fc // FVector (Size: 0xc)
GizmoLineHandleComponent.Length = 0x608 // float (Size: 0x4)
GizmoLineHandleComponent.bImageScale = 0x60c // bool (Size: 0x1)
GizmoLocalFloatParameterSource.Value = 0x48 // float (Size: 0x4)
GizmoLocalFloatParameterSource.LastChange = 0x4c // FGizmoFloatParameterChange (Size: 0x8)
GizmoLocalVec2ParameterSource.Value = 0x48 // FVector2D (Size: 0x8)
GizmoLocalVec2ParameterSource.LastChange = 0x50 // FGizmoVec2ParameterChange (Size: 0x10)
GizmoPlaneScaleParameterSource.AxisSource = 0x90 // TScriptInterface<IInterface> (Size: 0x10)
GizmoPlaneScaleParameterSource.TransformSource = 0xa0 // TScriptInterface<IInterface> (Size: 0x10)
GizmoPlaneScaleParameterSource.ScaleMultiplier = 0xb0 // float (Size: 0x4)
GizmoPlaneScaleParameterSource.Parameter = 0xb4 // FVector2D (Size: 0x8)
GizmoPlaneScaleParameterSource.LastChange = 0xbc // FGizmoVec2ParameterChange (Size: 0x10)
GizmoPlaneScaleParameterSource.CurScaleOrigin = 0xcc // FVector (Size: 0xc)
GizmoPlaneScaleParameterSource.CurScaleNormal = 0xd8 // FVector (Size: 0xc)
GizmoPlaneScaleParameterSource.CurScaleAxisX = 0xe4 // FVector (Size: 0xc)
GizmoPlaneScaleParameterSource.CurScaleAxisY = 0xf0 // FVector (Size: 0xc)
GizmoPlaneScaleParameterSource.InitialTransform = 0x100 // FTransform (Size: 0x30)
GizmoPlaneTranslationParameterSource.AxisSource = 0x90 // TScriptInterface<IInterface> (Size: 0x10)
GizmoPlaneTranslationParameterSource.TransformSource = 0xa0 // TScriptInterface<IInterface> (Size: 0x10)
GizmoPlaneTranslationParameterSource.Parameter = 0xb0 // FVector2D (Size: 0x8)
GizmoPlaneTranslationParameterSource.LastChange = 0xb8 // FGizmoVec2ParameterChange (Size: 0x10)
GizmoPlaneTranslationParameterSource.CurTranslationOrigin = 0xc8 // FVector (Size: 0xc)
GizmoPlaneTranslationParameterSource.CurTranslationNormal = 0xd4 // FVector (Size: 0xc)
GizmoPlaneTranslationParameterSource.CurTranslationAxisX = 0xe0 // FVector (Size: 0xc)
GizmoPlaneTranslationParameterSource.CurTranslationAxisY = 0xec // FVector (Size: 0xc)
GizmoPlaneTranslationParameterSource.InitialTransform = 0x100 // FTransform (Size: 0x30)
GizmoRectangleComponent.DirectionX = 0x5e8 // FVector (Size: 0xc)
GizmoRectangleComponent.DirectionY = 0x5f4 // FVector (Size: 0xc)
GizmoRectangleComponent.offsetX = 0x600 // float (Size: 0x4)
GizmoRectangleComponent.OffsetY = 0x604 // float (Size: 0x4)
GizmoRectangleComponent.LengthX = 0x608 // float (Size: 0x4)
GizmoRectangleComponent.LengthY = 0x60c // float (Size: 0x4)
GizmoRectangleComponent.Thickness = 0x610 // float (Size: 0x4)
GizmoRectangleComponent.SegmentFlags = 0x614 // uint8_t (Size: 0x1)
GizmoScaledTransformSource.ChildTransformSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
GizmoTransformChangeStateTarget.TransactionManager = 0x50 // TScriptInterface<IInterface> (Size: 0x10)
GizmoTransformProxyTransformSource.Proxy = 0x48 // TransformProxy* (Size: 0x8)
GizmoUniformScaleParameterSource.AxisSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
GizmoUniformScaleParameterSource.TransformSource = 0x58 // TScriptInterface<IInterface> (Size: 0x10)
GizmoUniformScaleParameterSource.ScaleMultiplier = 0x68 // float (Size: 0x4)
GizmoUniformScaleParameterSource.Parameter = 0x6c // FVector2D (Size: 0x8)
GizmoUniformScaleParameterSource.LastChange = 0x74 // FGizmoVec2ParameterChange (Size: 0x10)
GizmoUniformScaleParameterSource.CurScaleOrigin = 0x84 // FVector (Size: 0xc)
GizmoUniformScaleParameterSource.CurScaleNormal = 0x90 // FVector (Size: 0xc)
GizmoUniformScaleParameterSource.CurScaleAxisX = 0x9c // FVector (Size: 0xc)
GizmoUniformScaleParameterSource.CurScaleAxisY = 0xa8 // FVector (Size: 0xc)
GizmoUniformScaleParameterSource.InitialTransform = 0xc0 // FTransform (Size: 0x30)
GizmoVec2ParameterChange.InitialValue = 0x0 // FVector2D (Size: 0x8)
GizmoVec2ParameterChange.CurrentValue = 0x8 // FVector2D (Size: 0x8)
GizmoWorldAxisSource.Origin = 0x30 // FVector (Size: 0xc)
GizmoWorldAxisSource.AxisIndex = 0x3c // int32_t (Size: 0x4)
InputBehaviorSet.Behaviors = 0x28 // TArray<FBehaviorInfo> (Size: 0x10)
InputRouter.bAutoInvalidateOnHover = 0x28 // bool (Size: 0x1)
InputRouter.bAutoInvalidateOnCapture = 0x29 // bool (Size: 0x1)
InputRouter.ActiveInputBehaviors = 0x38 // InputBehaviorSet* (Size: 0x8)
InteractiveGizmo.InputBehaviors = 0x30 // InputBehaviorSet* (Size: 0x8)
InteractiveGizmoManager.ActiveGizmos = 0x30 // TArray<FActiveGizmo> (Size: 0x10)
InteractiveGizmoManager.GizmoBuilders = 0x58 // TMap<...> (Size: 0x50)
InteractiveTool.InputBehaviors = 0x48 // InputBehaviorSet* (Size: 0x8)
InteractiveTool.ToolPropertyObjects = 0x50 // TArray<Object*> (Size: 0x10)
InteractiveToolManager.ActiveLeftTool = 0x30 // InteractiveTool* (Size: 0x8)
InteractiveToolManager.ActiveRightTool = 0x38 // InteractiveTool* (Size: 0x8)
InteractiveToolManager.ToolBuilders = 0x90 // TMap<...> (Size: 0x50)
InteractiveToolPropertySet.CachedProperties = 0x38 // InteractiveToolPropertySet* (Size: 0x8)
InteractiveToolPropertySet.bIsPropertySetEnabled = 0x40 // bool (Size: 0x1)
InteractiveToolsContext.InputRouter = 0x58 // InputRouter* (Size: 0x8)
InteractiveToolsContext.ToolManager = 0x60 // InteractiveToolManager* (Size: 0x8)
InteractiveToolsContext.GizmoManager = 0x68 // InteractiveGizmoManager* (Size: 0x8)
InteractiveToolsContext.ToolManagerClass = 0x70 // TSoftClassPtr<UObject> (Size: 0x28)
IntervalGizmo.StateTarget = 0x38 // GizmoTransformChangeStateTarget* (Size: 0x8)
IntervalGizmo.TransformProxy = 0x50 // TransformProxy* (Size: 0x8)
IntervalGizmo.ActiveComponents = 0x58 // TArray<PrimitiveComponent*> (Size: 0x10)
IntervalGizmo.ActiveGizmos = 0x68 // TArray<InteractiveGizmo*> (Size: 0x10)
IntervalGizmo.AxisYSource = 0x90 // GizmoComponentAxisSource* (Size: 0x8)
IntervalGizmo.AxisZSource = 0x98 // GizmoComponentAxisSource* (Size: 0x8)
IntervalGizmoActor.UpIntervalComponent = 0x310 // GizmoLineHandleComponent* (Size: 0x8)
IntervalGizmoActor.DownIntervalComponent = 0x318 // GizmoLineHandleComponent* (Size: 0x8)
IntervalGizmoActor.ForwardIntervalComponent = 0x320 // GizmoLineHandleComponent* (Size: 0x8)
MeshSelectionSet.Vertices = 0x40 // TArray<int32_t> (Size: 0x10)
MeshSelectionSet.Edges = 0x50 // TArray<int32_t> (Size: 0x10)
MeshSelectionSet.Faces = 0x60 // TArray<int32_t> (Size: 0x10)
MeshSelectionSet.Groups = 0x70 // TArray<int32_t> (Size: 0x10)
PlanePositionGizmo.AxisSource = 0x48 // TScriptInterface<IInterface> (Size: 0x10)
PlanePositionGizmo.ParameterSource = 0x58 // TScriptInterface<IInterface> (Size: 0x10)
PlanePositionGizmo.HitTarget = 0x68 // TScriptInterface<IInterface> (Size: 0x10)
PlanePositionGizmo.StateTarget = 0x78 // TScriptInterface<IInterface> (Size: 0x10)
PlanePositionGizmo.bEnableSignedAxis = 0x88 // bool (Size: 0x1)
PlanePositionGizmo.bFlipX = 0x89 // bool (Size: 0x1)
PlanePositionGizmo.bFlipY = 0x8a // bool (Size: 0x1)
PlanePositionGizmo.bInInteraction = 0x8b // bool (Size: 0x1)
PlanePositionGizmo.InteractionOrigin = 0x8c // FVector (Size: 0xc)
PlanePositionGizmo.InteractionNormal = 0x98 // FVector (Size: 0xc)
PlanePositionGizmo.InteractionAxisX = 0xa4 // FVector (Size: 0xc)
PlanePositionGizmo.InteractionAxisY = 0xb0 // FVector (Size: 0xc)
PlanePositionGizmo.InteractionStartPoint = 0xbc // FVector (Size: 0xc)
PlanePositionGizmo.InteractionCurPoint = 0xc8 // FVector (Size: 0xc)
PlanePositionGizmo.InteractionStartParameter = 0xd4 // FVector2D (Size: 0x8)
PlanePositionGizmo.InteractionCurParameter = 0xdc // FVector2D (Size: 0x8)
PlanePositionGizmo.ParameterSigns = 0xe4 // FVector2D (Size: 0x8)
SingleClickInputBehavior.HitTestOnRelease = 0xc0 // bool (Size: 0x1)
TransformGizmo.ActiveTarget = 0x40 // TransformProxy* (Size: 0x8)
TransformGizmo.bSnapToWorldGrid = 0x48 // bool (Size: 0x1)
TransformGizmo.bGridSizeIsExplicit = 0x49 // bool (Size: 0x1)
TransformGizmo.ExplicitGridSize = 0x4c // FVector (Size: 0xc)
TransformGizmo.bRotationGridSizeIsExplicit = 0x58 // bool (Size: 0x1)
TransformGizmo.ExplicitRotationGridSize = 0x5c // FRotator (Size: 0xc)
TransformGizmo.bSnapToWorldRotGrid = 0x68 // bool (Size: 0x1)
TransformGizmo.bUseContextCoordinateSystem = 0x69 // bool (Size: 0x1)
TransformGizmo.CurrentCoordinateSystem = 0x6c // EEToolContextCoordinateSystem (Size: 0x4)
TransformGizmo.ActiveComponents = 0x100 // TArray<PrimitiveComponent*> (Size: 0x10)
TransformGizmo.NonuniformScaleComponents = 0x110 // TArray<PrimitiveComponent*> (Size: 0x10)
TransformGizmo.ActiveGizmos = 0x120 // TArray<InteractiveGizmo*> (Size: 0x10)
TransformGizmo.CameraAxisSource = 0x140 // GizmoConstantFrameAxisSource* (Size: 0x8)
TransformGizmo.AxisXSource = 0x148 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.AxisYSource = 0x150 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.AxisZSource = 0x158 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.UnitAxisXSource = 0x160 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.UnitAxisYSource = 0x168 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.UnitAxisZSource = 0x170 // GizmoComponentAxisSource* (Size: 0x8)
TransformGizmo.StateTarget = 0x178 // GizmoTransformChangeStateTarget* (Size: 0x8)
TransformGizmo.ScaledTransformSource = 0x180 // GizmoScaledTransformSource* (Size: 0x8)
TransformGizmoActor.TranslateX = 0x310 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.TranslateY = 0x318 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.TranslateZ = 0x320 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.TranslateYZ = 0x328 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.TranslateXZ = 0x330 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.TranslateXY = 0x338 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.RotateX = 0x340 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.RotateY = 0x348 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.RotateZ = 0x350 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.UniformScale = 0x358 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.AxisScaleX = 0x360 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.AxisScaleY = 0x368 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.AxisScaleZ = 0x370 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.PlaneScaleYZ = 0x378 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.PlaneScaleXZ = 0x380 // PrimitiveComponent* (Size: 0x8)
TransformGizmoActor.PlaneScaleXY = 0x388 // PrimitiveComponent* (Size: 0x8)
TransformProxy.bRotatePerObject = 0x70 // bool (Size: 0x1)
TransformProxy.bSetPivotMode = 0x71 // bool (Size: 0x1)
TransformProxy.SharedTransform = 0x90 // FTransform (Size: 0x30)
TransformProxy.InitialSharedTransform = 0xc0 // FTransform (Size: 0x30)
JsonObjectWrapper.JsonString = 0x0 // FString (Size: 0x10)
AdjacentEdgesInfo.AdjacentBones = 0x0 // TArray<FBoneReference> (Size: 0x10)
AnimNode_BoneConstrain.BoneConfigs = 0xd0 // TArray<FBoneConstrain_BoneConfig> (Size: 0x10)
AnimNode_KawaiiPhysics.RootBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_KawaiiPhysics.ExcludeBones = 0xe0 // TArray<FBoneReference> (Size: 0x10)
AnimNode_KawaiiPhysics.bEnableEdgeCollide = 0xf0 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.bEnableEndBoneControl = 0xf1 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.EndBoneTargetBone = 0xf4 // FBoneReference (Size: 0x10)
AnimNode_KawaiiPhysics.EndBoneTargetTransform = 0x110 // FTransform (Size: 0x30)
AnimNode_KawaiiPhysics.StripIndex = 0x140 // int32_t (Size: 0x4)
AnimNode_KawaiiPhysics.IsLastStrip = 0x144 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.FocusedDebugBoneIndex = 0x148 // TArray<int32_t> (Size: 0x10)
AnimNode_KawaiiPhysics.CircleStartIndex = 0x158 // int32_t (Size: 0x4)
AnimNode_KawaiiPhysics.TargetFramerate = 0x15c // int32_t (Size: 0x4)
AnimNode_KawaiiPhysics.OverrideTargetFramerate = 0x160 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.PhysicsSettings = 0x164 // FKawaiiPhysicsSettings (Size: 0x18)
AnimNode_KawaiiPhysics.DampingCurve = 0x180 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.WorldDampingLocationCurve = 0x188 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.WorldDampingRotationCurve = 0x190 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.StiffnessCurve = 0x198 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.RadiusCurve = 0x1a0 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.LimitAngleCurve = 0x1a8 // CurveFloat* (Size: 0x8)
AnimNode_KawaiiPhysics.DampingCurveData = 0x1b0 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.WorldDampingLocationCurveData = 0x238 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.WorldDampingRotationCurveData = 0x2c0 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.StiffnessCurveData = 0x348 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.RadiusCurveData = 0x3d0 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.LimitAngleCurveData = 0x458 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.bUpdatePhysicsSettingsInGame = 0x4e0 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.DummyBoneLength = 0x4e4 // float (Size: 0x4)
AnimNode_KawaiiPhysics.BoneForwardAxis = 0x4e8 // EEBoneForwardAxis (Size: 0x1)
AnimNode_KawaiiPhysics.PlanarConstraint = 0x4e9 // EEPlanarConstraint (Size: 0x1)
AnimNode_KawaiiPhysics.ResetBoneTransformWhenBoneNotFound = 0x4ea // bool (Size: 0x1)
AnimNode_KawaiiPhysics.SphericalLimits = 0x4f0 // TArray<FSphericalLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.CapsuleLimits = 0x500 // TArray<FCapsuleLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.PlanarLimits = 0x510 // TArray<FPlanarLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.LimitsDataAsset = 0x520 // KawaiiPhysicsLimitsDataAsset* (Size: 0x8)
AnimNode_KawaiiPhysics.SphericalLimitsData = 0x528 // TArray<FSphericalLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.CapsuleLimitsData = 0x538 // TArray<FCapsuleLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.PlanarLimitsData = 0x548 // TArray<FPlanarLimit> (Size: 0x10)
AnimNode_KawaiiPhysics.TeleportDistanceThreShold = 0x558 // float (Size: 0x4)
AnimNode_KawaiiPhysics.TeleportRotationThreShold = 0x55c // float (Size: 0x4)
AnimNode_KawaiiPhysics.Gravity = 0x560 // FVector (Size: 0xc)
AnimNode_KawaiiPhysics.bEnableWind = 0x56c // bool (Size: 0x1)
AnimNode_KawaiiPhysics.WindRandRange = 0x570 // float (Size: 0x4)
AnimNode_KawaiiPhysics.WindScale = 0x574 // float (Size: 0x4)
AnimNode_KawaiiPhysics.WindMode = 0x578 // EEWindMode (Size: 0x1)
AnimNode_KawaiiPhysics.LocalWindDirection = 0x57c // FVector (Size: 0xc)
AnimNode_KawaiiPhysics.LocalWindSpeed = 0x588 // float (Size: 0x4)
AnimNode_KawaiiPhysics.LocalWindWeight = 0x58c // float (Size: 0x4)
AnimNode_KawaiiPhysics.BaseBone = 0x590 // FBoneReference (Size: 0x10)
AnimNode_KawaiiPhysics.bEnableWindSpeedCurve = 0x5a0 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.WindSpeedCurveData = 0x5a8 // FRuntimeFloatCurve (Size: 0x88)
AnimNode_KawaiiPhysics.WindSpeedCycleDuration = 0x630 // float (Size: 0x4)
AnimNode_KawaiiPhysics.bAllowWorldCollision = 0x634 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.bOverrideCollisionParams = 0x635 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.CollisionChannelSettings = 0x638 // FBodyInstance (Size: 0x158)
AnimNode_KawaiiPhysics.bIgnoreSelfComponent = 0x790 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.IgnoreBones = 0x798 // TArray<FBoneReference> (Size: 0x10)
AnimNode_KawaiiPhysics.IgnoreBoneNamePrefix = 0x7a8 // TArray<FName> (Size: 0x10)
AnimNode_KawaiiPhysics.ModifyBones = 0x7b8 // TArray<FKawaiiPhysicsModifyBone> (Size: 0x10)
AnimNode_KawaiiPhysics.bActiveDebugging = 0x7c8 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.bActiveLateralConstraint = 0x7c9 // bool (Size: 0x1)
AnimNode_KawaiiPhysics.LateralConstraintIterationCountAfterCollision = 0x7cc // int32_t (Size: 0x4)
AnimNode_KawaiiPhysics.LateralConstraintMode = 0x7d0 // EBoneConstraintMode (Size: 0x1)
AnimNode_KawaiiPhysics.ComplianceType = 0x7d1 // EEXPBDComplianceType (Size: 0x1)
AnimNode_KawaiiPhysics.ComplianceValueOverride = 0x7d4 // float (Size: 0x4)
AnimNode_KawaiiPhysics.TotalBoneLength = 0x7d8 // float (Size: 0x4)
AnimNode_KawaiiPhysics.PreSkelCompTransform = 0x7e0 // FTransform (Size: 0x30)
AnimNode_KawaiiPhysics.bInitPhysicsSettings = 0x810 // bool (Size: 0x1)
BoneConstrain_BoneConfig.DrivenBone = 0x0 // FBoneReference (Size: 0x10)
BoneConstrain_BoneConfig.Contrains = 0x10 // TArray<FBoneConstrain_ConstrainConfig> (Size: 0x10)
BoneConstrain_ConstrainConfig.DriverBone = 0x0 // FBoneReference (Size: 0x10)
BoneConstrain_ConstrainConfig.ConstrainType = 0x10 // EEBoneConstrainType (Size: 0x1)
BoneConstrain_ConstrainConfig.Weight = 0x14 // float (Size: 0x4)
CapsuleLimit.Radius = 0x58 // float (Size: 0x4)
CapsuleLimit.Length = 0x5c // float (Size: 0x4)
CapsuleLimitData.Radius = 0x50 // float (Size: 0x4)
CapsuleLimitData.Length = 0x54 // float (Size: 0x4)
CollisionLimitBase.DrivingBone = 0x0 // FBoneReference (Size: 0x10)
CollisionLimitBase.OffsetLocation = 0x10 // FVector (Size: 0xc)
CollisionLimitBase.OffsetRotation = 0x1c // FRotator (Size: 0xc)
CollisionLimitBase.Location = 0x28 // FVector (Size: 0xc)
CollisionLimitBase.Rotation = 0x40 // FQuat (Size: 0x10)
CollisionLimitBase.bEnable = 0x50 // bool (Size: 0x1)
CollisionLimitDataBase.DrivingBoneName = 0x0 // FName (Size: 0x8)
CollisionLimitDataBase.OffsetLocation = 0x8 // FVector (Size: 0xc)
CollisionLimitDataBase.OffsetRotation = 0x14 // FRotator (Size: 0xc)
CollisionLimitDataBase.Location = 0x20 // FVector (Size: 0xc)
CollisionLimitDataBase.Rotation = 0x30 // FQuat (Size: 0x10)
CollisionLimitDataBase.Guid = 0x40 // FGuid (Size: 0x10)
EdgeDebugInfo.CurrentBoneIndex = 0x0 // int32_t (Size: 0x4)
EdgeDebugInfo.AdjacentBoneIndex = 0x4 // int32_t (Size: 0x4)
EdgeDebugInfo.AdjacentBoneSameChain = 0x8 // bool (Size: 0x1)
EdgeDebugInfo.CapsuleInfo = 0x10 // FCapsuleLimit (Size: 0x60)
EdgeDebugInfo.EdgeCollideLocation = 0x70 // FVector (Size: 0xc)
EdgeDebugInfo.CapsuleCollideLocation = 0x7c // FVector (Size: 0xc)
EdgeDebugInfo.EdgeCollide = 0x88 // bool (Size: 0x1)
EdgeDebugInfo.AdjacentBoneCannotMove = 0x89 // bool (Size: 0x1)
EdgeDebugInfo.EdgeStartLocation = 0x8c // FVector (Size: 0xc)
EdgeDebugInfo.EdgeEndLocation = 0x98 // FVector (Size: 0xc)
EdgeDebugInfo.ExtrudeLocation = 0xa4 // FVector (Size: 0xc)
EdgeDebugInfo.ExtrudeReverseLocation = 0xb0 // FVector (Size: 0xc)
EdgeDebugInfo.AssumedStartLocation = 0xbc // FVector (Size: 0xc)
EdgeDebugInfo.AssumedEndLocation = 0xc8 // FVector (Size: 0xc)
EdgeDebugInfo.AdjustedStartLocation = 0xd4 // FVector (Size: 0xc)
EdgeDebugInfo.AdjustedEndLocation = 0xe0 // FVector (Size: 0xc)
KawaiiPhysicsLimitsDataAsset.SphericalLimits = 0x30 // TArray<FSphericalLimit> (Size: 0x10)
KawaiiPhysicsLimitsDataAsset.CapsuleLimits = 0x40 // TArray<FCapsuleLimit> (Size: 0x10)
KawaiiPhysicsLimitsDataAsset.PlanarLimits = 0x50 // TArray<FPlanarLimit> (Size: 0x10)
KawaiiPhysicsModifyBone.BoneRef = 0x0 // FBoneReference (Size: 0x10)
KawaiiPhysicsModifyBone.SelfIndex = 0x10 // int32_t (Size: 0x4)
KawaiiPhysicsModifyBone.ParentIndex = 0x14 // int32_t (Size: 0x4)
KawaiiPhysicsModifyBone.ChildIndexs = 0x18 // TArray<int32_t> (Size: 0x10)
KawaiiPhysicsModifyBone.BoneIndices = 0x28 // TArray<FBoneReference> (Size: 0x10)
KawaiiPhysicsModifyBone.PhysicsSettings = 0x38 // FKawaiiPhysicsSettings (Size: 0x18)
KawaiiPhysicsModifyBone.Location = 0x50 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.PrevLocation = 0x5c // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.PrevRotation = 0x70 // FQuat (Size: 0x10)
KawaiiPhysicsModifyBone.PoseLocation = 0x80 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.PoseRotation = 0x90 // FQuat (Size: 0x10)
KawaiiPhysicsModifyBone.PoseScale = 0xa0 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.LengthFromRoot = 0xac // float (Size: 0x4)
KawaiiPhysicsModifyBone.bDummy = 0xb0 // bool (Size: 0x1)
KawaiiPhysicsModifyBone.bIsEndBone = 0xb1 // bool (Size: 0x1)
KawaiiPhysicsModifyBone.FinalRotation = 0xc0 // FQuat (Size: 0x10)
KawaiiPhysicsModifyBone.RightEdgeIndexs = 0xd0 // TArray<int32_t> (Size: 0x10)
KawaiiPhysicsModifyBone.RightEdgeIndexsLength = 0xe0 // TArray<float> (Size: 0x10)
KawaiiPhysicsModifyBone.RightEdgeIndexsLambda = 0xf0 // TArray<float> (Size: 0x10)
KawaiiPhysicsModifyBone.DebugCollideInfo = 0x100 // TArray<FEdgeDebugInfo> (Size: 0x10)
KawaiiPhysicsModifyBone.PlanarProjection = 0x110 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.PlanarOrigin = 0x11c // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.ParentLocationBeforeFinalPlanarAdjust = 0x128 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.ParentRotationBeforeFinalPlanarAdjust = 0x140 // FQuat (Size: 0x10)
KawaiiPhysicsModifyBone.LocalLocationBeforeFinalPlanarAdjust = 0x150 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.WorldPoseLocation = 0x15c // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.WorldPoseRotation = 0x170 // FQuat (Size: 0x10)
KawaiiPhysicsModifyBone.ForwardPos = 0x180 // FVector (Size: 0xc)
KawaiiPhysicsModifyBone.BackwardPos = 0x18c // FVector (Size: 0xc)
KawaiiPhysicsSettings.Damping = 0x0 // float (Size: 0x4)
KawaiiPhysicsSettings.WorldDampingLocation = 0x4 // float (Size: 0x4)
KawaiiPhysicsSettings.WorldDampingRotation = 0x8 // float (Size: 0x4)
KawaiiPhysicsSettings.Stiffness = 0xc // float (Size: 0x4)
KawaiiPhysicsSettings.Radius = 0x10 // float (Size: 0x4)
KawaiiPhysicsSettings.LimitAngle = 0x14 // float (Size: 0x4)
PlanarLimit.Plane = 0x60 // FPlane (Size: 0x10)
PlanarLimit.LimitIndexs = 0x70 // TArray<int32_t> (Size: 0x10)
PlanarLimit.DebugVisible = 0x80 // bool (Size: 0x1)
PlanarLimit.DebugEnable = 0x81 // bool (Size: 0x1)
PlanarLimit.CompareFront = 0x82 // bool (Size: 0x1)
PlanarLimitData.Plane = 0x50 // FPlane (Size: 0x10)
SphericalLimit.Radius = 0x58 // float (Size: 0x4)
SphericalLimit.LimitType = 0x5c // EESphericalLimitType (Size: 0x1)
SphericalLimitData.Radius = 0x50 // float (Size: 0x4)
SphericalLimitData.LimitType = 0x54 // EESphericalLimitType (Size: 0x1)
INTLLuaActor.LuaFilePath = 0x3a0 // FString (Size: 0x10)
INTLLuaActor.LuaStateName = 0x3b0 // FString (Size: 0x10)
INTLLuaActorComponent.LuaFilePath = 0x198 // FString (Size: 0x10)
INTLLuaActorComponent.LuaStateName = 0x1a8 // FString (Size: 0x10)
INTLLuaCharacter.LuaFilePath = 0x668 // FString (Size: 0x10)
INTLLuaCharacter.LuaStateName = 0x678 // FString (Size: 0x10)
INTLLuaController.LuaFilePath = 0x418 // FString (Size: 0x10)
INTLLuaController.LuaStateName = 0x428 // FString (Size: 0x10)
INTLLuaGameModeBase.LuaFilePath = 0x440 // FString (Size: 0x10)
INTLLuaGameModeBase.LuaStateName = 0x450 // FString (Size: 0x10)
INTLLuaHUD.LuaFilePath = 0x498 // FString (Size: 0x10)
INTLLuaHUD.LuaStateName = 0x4a8 // FString (Size: 0x10)
INTLLuaPawn.LuaFilePath = 0x410 // FString (Size: 0x10)
INTLLuaPawn.LuaStateName = 0x420 // FString (Size: 0x10)
INTLLuaPlayerController.LuaFilePath = 0x700 // FString (Size: 0x10)
INTLLuaPlayerController.LuaStateName = 0x710 // FString (Size: 0x10)
INTLLuaUserWidget.LuaFilePath = 0x320 // FString (Size: 0x10)
INTLLuaUserWidget.LuaStateName = 0x330 // FString (Size: 0x10)
ControlPointMeshActor.ControlPointMeshComponent = 0x310 // ControlPointMeshComponent* (Size: 0x8)
ControlPointMeshComponent.VirtualTextureMainPassMaxDrawDistance = 0x670 // float (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.LandscapeBound = 0x5d0 // FVector4 (Size: 0x10)
GPUDrivenLandscapeBatchingComponent.Origin = 0x5e0 // FVector (Size: 0xc)
GPUDrivenLandscapeBatchingComponent.MinLocation = 0x5ec // FVector (Size: 0xc)
GPUDrivenLandscapeBatchingComponent.LandscapeMaterial = 0x5f8 // MaterialInterface* (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.MaterialInstance = 0x600 // MaterialInstanceConstant* (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.MaterialInstanceMobile = 0x608 // MaterialInstanceConstant* (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.LandscapeGuid = 0x610 // FGuid (Size: 0x10)
GPUDrivenLandscapeBatchingComponent.SubsectionSizeQuads = 0x620 // int32_t (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.NumSubsections = 0x624 // int32_t (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.ComponentBaseMin = 0x628 // FVector2D (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.ComponentBaseSize = 0x630 // FVector2D (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.ComponentBaseStart = 0x638 // FIntPoint (Size: 0x8)
GPUDrivenLandscapeBatchingComponent.LandscapeComponentNum = 0x640 // int32_t (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.FirstVirtualTextureLOD = 0x644 // int32_t (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.LastVirtualTextureLOD = 0x648 // int32_t (Size: 0x4)
GPUDrivenLandscapeBatchingComponent.SetTransformButton = 0x64c // bool (Size: 0x1)
GrassInput.Name = 0x0 // FName (Size: 0x8)
GrassInput.GrassType = 0x8 // LandscapeGrassType* (Size: 0x8)
GrassInput.Input = 0x10 // FExpressionInput (Size: 0xc)
GrassOffsetData.OffsetData = 0x28 // TMap<...> (Size: 0x50)
GrassVariety.GrassMesh = 0x0 // StaticMesh* (Size: 0x8)
GrassVariety.OverrideMaterials = 0x8 // TArray<MaterialInterface*> (Size: 0x10)
GrassVariety.GrassDensity = 0x18 // FPerPlatformFloat (Size: 0x4)
GrassVariety.MaxOffset = 0x1c // FPerPlatformFloat (Size: 0x4)
GrassVariety.MinGrassWeight = 0x20 // FPerPlatformFloat (Size: 0x4)
GrassVariety.SlopeRange = 0x24 // FFloatInterval (Size: 0x8)
GrassVariety.bUseGrid = 0x2c // bool (Size: 0x1)
GrassVariety.PlacementJitter = 0x30 // float (Size: 0x4)
GrassVariety.StartCullDistance = 0x34 // FPerPlatformInt (Size: 0x8)
GrassVariety.EndCullDistance = 0x3c // FPerPlatformInt (Size: 0x8)
GrassVariety.FalloffExponent = 0x44 // float (Size: 0x4)
GrassVariety.OffsetWeight = 0x48 // FFloatInterval (Size: 0x8)
GrassVariety.OffsetRange = 0x50 // FFloatInterval (Size: 0x8)
GrassVariety.EdgeScaleWeight = 0x58 // FFloatInterval (Size: 0x8)
GrassVariety.EdgeScaleRatio = 0x60 // FFloatInterval (Size: 0x8)
GrassVariety.MinLOD = 0x68 // int32_t (Size: 0x4)
GrassVariety.Scaling = 0x6c // EEGrassScaling (Size: 0x1)
GrassVariety.GrassPreservePriority = 0x70 // EEGrassPreservePriority (Size: 0x4)
GrassVariety.ScaleX = 0x74 // FFloatInterval (Size: 0x8)
GrassVariety.ScaleY = 0x7c // FFloatInterval (Size: 0x8)
GrassVariety.ScaleZ = 0x84 // FFloatInterval (Size: 0x8)
GrassVariety.RandomRotation = 0x8c // bool (Size: 0x1)
GrassVariety.AlignToSurface = 0x8d // bool (Size: 0x1)
GrassVariety.bUseLandscapeLightmap = 0x8e // bool (Size: 0x1)
GrassVariety.LightingChannels = 0x8f // FLightingChannels (Size: 0x1)
GrassVariety.bReceivesDecals = 0x90 // bool (Size: 0x1)
GrassVariety.bCastDynamicShadow = 0x91 // bool (Size: 0x1)
GrassVariety.bCastShadow = 0x92 // bool (Size: 0x1)
GrassVariety.bCastContactShadow = 0x93 // bool (Size: 0x1)
GrassVariety.bKeepInstanceBufferCPUCopy = 0x94 // bool (Size: 0x1)
GrassVariety.bForceUseSkyLightAsDiffuseGI = 0x95 // bool (Size: 0x1)
GrassVariety.IndirectLightingCacheQuality = 0x96 // uint8_t (Size: 0x1)
GrassVariety.bReMergeInstancing = 0x97 // bool (Size: 0x1)
GrassVariety.bHiddenShadowOnShadowCapture = 0x98 // bool (Size: 0x1)
GrassVariety.ShadowCaptureLayer = 0x99 // EEShadowCaptureLayer (Size: 0x1)
HeightmapData.Texture = 0x0 // Texture2D* (Size: 0x8)
LandscapeComponent.SectionBaseX = 0x5c8 // int32_t (Size: 0x4)
LandscapeComponent.SectionBaseY = 0x5cc // int32_t (Size: 0x4)
LandscapeComponent.ComponentSizeQuads = 0x5d0 // int32_t (Size: 0x4)
LandscapeComponent.SubsectionSizeQuads = 0x5d4 // int32_t (Size: 0x4)
LandscapeComponent.NumSubsections = 0x5d8 // int32_t (Size: 0x4)
LandscapeComponent.OverrideMaterial = 0x5e0 // MaterialInterface* (Size: 0x8)
LandscapeComponent.OverrideHoleMaterial = 0x5e8 // MaterialInterface* (Size: 0x8)
LandscapeComponent.OverrideMaterials = 0x5f0 // TArray<FLandscapeComponentMaterialOverride> (Size: 0x10)
LandscapeComponent.bRemoveMobileWeightmap = 0x600 // bool (Size: 0x1)
LandscapeComponent.MaterialInstances = 0x608 // TArray<MaterialInstanceConstant*> (Size: 0x10)
LandscapeComponent.MaterialInstancesDynamic = 0x618 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
LandscapeComponent.LODIndexToMaterialIndex = 0x628 // TArray<int8_t> (Size: 0x10)
LandscapeComponent.MaterialIndexToDisabledTessellationMaterial = 0x638 // TArray<int8_t> (Size: 0x10)
LandscapeComponent.XYOffsetmapTexture = 0x648 // Texture2D* (Size: 0x8)
LandscapeComponent.WeightmapScaleBias = 0x650 // FVector4 (Size: 0x10)
LandscapeComponent.WeightmapSubsectionOffset = 0x660 // float (Size: 0x4)
LandscapeComponent.HeightmapScaleBias = 0x670 // FVector4 (Size: 0x10)
LandscapeComponent.CachedLocalBox = 0x680 // FBox (Size: 0x1c)
LandscapeComponent.CollisionComponent = 0x69c // TLazyObjectPtr<UObject> (Size: 0x1c)
LandscapeComponent.HeightmapTexture = 0x6b8 // Texture2D* (Size: 0x8)
LandscapeComponent.WeightmapLayerAllocations = 0x6c0 // TArray<FWeightmapLayerAllocationInfo> (Size: 0x10)
LandscapeComponent.WeightmapTextures = 0x6d0 // TArray<Texture2D*> (Size: 0x10)
LandscapeComponent.LODStreamingProxy = 0x6e0 // LandscapeLODStreamingProxy* (Size: 0x8)
LandscapeComponent.MapBuildDataId = 0x6e8 // FGuid (Size: 0x10)
LandscapeComponent.IrrelevantLights = 0x6f8 // TArray<FGuid> (Size: 0x10)
LandscapeComponent.CollisionMipLevel = 0x708 // int32_t (Size: 0x4)
LandscapeComponent.SimpleCollisionMipLevel = 0x70c // int32_t (Size: 0x4)
LandscapeComponent.NegativeZBoundsExtension = 0x710 // float (Size: 0x4)
LandscapeComponent.PositiveZBoundsExtension = 0x714 // float (Size: 0x4)
LandscapeComponent.StaticLightingResolution = 0x718 // float (Size: 0x4)
LandscapeComponent.ForcedLOD = 0x71c // int32_t (Size: 0x4)
LandscapeComponent.LODBias = 0x720 // int32_t (Size: 0x4)
LandscapeComponent.StateId = 0x724 // FGuid (Size: 0x10)
LandscapeComponent.BakedTextureMaterialGuid = 0x734 // FGuid (Size: 0x10)
LandscapeComponent.GIBakedBaseColorTexture = 0x748 // Texture2D* (Size: 0x8)
LandscapeComponent.MobileBlendableLayerMask = 0x750 // uint8_t (Size: 0x1)
LandscapeComponent.MobileMaterialInterface = 0x758 // MaterialInterface* (Size: 0x8)
LandscapeComponent.MobileMaterialInterfaces = 0x760 // TArray<MaterialInterface*> (Size: 0x10)
LandscapeComponent.MobileWeightmapTextures = 0x770 // TArray<Texture2D*> (Size: 0x10)
LandscapeComponentMaterialOverride.LODIndex = 0x0 // FPerPlatformInt (Size: 0x8)
LandscapeComponentMaterialOverride.Material = 0x8 // MaterialInterface* (Size: 0x8)
LandscapeEditToolRenderData.ToolMaterial = 0x0 // MaterialInterface* (Size: 0x8)
LandscapeEditToolRenderData.GizmoMaterial = 0x8 // MaterialInterface* (Size: 0x8)
LandscapeEditToolRenderData.SelectedType = 0x10 // int32_t (Size: 0x4)
LandscapeEditToolRenderData.DebugChannelR = 0x14 // int32_t (Size: 0x4)
LandscapeEditToolRenderData.DebugChannelG = 0x18 // int32_t (Size: 0x4)
LandscapeEditToolRenderData.DebugChannelB = 0x1c // int32_t (Size: 0x4)
LandscapeEditToolRenderData.DataTexture = 0x20 // Texture2D* (Size: 0x8)
LandscapeEditToolRenderData.LayerContributionTexture = 0x28 // Texture2D* (Size: 0x8)
LandscapeEditToolRenderData.DirtyTexture = 0x30 // Texture2D* (Size: 0x8)
LandscapeGrassType.GrassVarieties = 0x28 // TArray<FGrassVariety> (Size: 0x10)
LandscapeGrassType.LUT = 0x38 // Texture* (Size: 0x8)
LandscapeGrassType.bEnableDensityScaling = 0x40 // uint8_t (Size: 0x1)
LandscapeGrassType.GrassMesh = 0x48 // StaticMesh* (Size: 0x8)
LandscapeGrassType.GrassDensity = 0x50 // float (Size: 0x4)
LandscapeGrassType.PlacementJitter = 0x54 // float (Size: 0x4)
LandscapeGrassType.StartCullDistance = 0x58 // int32_t (Size: 0x4)
LandscapeGrassType.EndCullDistance = 0x5c // int32_t (Size: 0x4)
LandscapeGrassType.RandomRotation = 0x60 // bool (Size: 0x1)
LandscapeGrassType.AlignToSurface = 0x61 // bool (Size: 0x1)
LandscapeHeightfieldCollisionComponent.ComponentLayerInfos = 0x5c8 // TArray<LandscapeLayerInfoObject*> (Size: 0x10)
LandscapeHeightfieldCollisionComponent.SectionBaseX = 0x5d8 // int32_t (Size: 0x4)
LandscapeHeightfieldCollisionComponent.SectionBaseY = 0x5dc // int32_t (Size: 0x4)
LandscapeHeightfieldCollisionComponent.CollisionSizeQuads = 0x5e0 // int32_t (Size: 0x4)
LandscapeHeightfieldCollisionComponent.CollisionScale = 0x5e4 // float (Size: 0x4)
LandscapeHeightfieldCollisionComponent.SimpleCollisionSizeQuads = 0x5e8 // int32_t (Size: 0x4)
LandscapeHeightfieldCollisionComponent.CollisionQuadFlags = 0x5f0 // TArray<uint8_t> (Size: 0x10)
LandscapeHeightfieldCollisionComponent.HeightfieldGuid = 0x600 // FGuid (Size: 0x10)
LandscapeHeightfieldCollisionComponent.CachedLocalBox = 0x610 // FBox (Size: 0x1c)
LandscapeHeightfieldCollisionComponent.RenderComponent = 0x62c // TLazyObjectPtr<UObject> (Size: 0x1c)
LandscapeHeightfieldCollisionComponent.CookedPhysicalMaterials = 0x658 // TArray<PhysicalMaterial*> (Size: 0x10)
LandscapeInfo.LandscapeActor = 0x28 // TLazyObjectPtr<UObject> (Size: 0x1c)
LandscapeInfo.LandscapeGuid = 0x44 // FGuid (Size: 0x10)
LandscapeInfo.ComponentSizeQuads = 0x54 // int32_t (Size: 0x4)
LandscapeInfo.SubsectionSizeQuads = 0x58 // int32_t (Size: 0x4)
LandscapeInfo.ComponentNumSubsections = 0x5c // int32_t (Size: 0x4)
LandscapeInfo.DrawScale = 0x60 // FVector (Size: 0xc)
LandscapeInfo.Proxies = 0x110 // TArray<LandscapeStreamingProxy*> (Size: 0x10)
LandscapeInfoLayerSettings.LayerInfoObj = 0x0 // LandscapeLayerInfoObject* (Size: 0x8)
LandscapeInfoLayerSettings.LayerName = 0x8 // FName (Size: 0x8)
LandscapeLayer.Guid = 0x0 // FGuid (Size: 0x10)
LandscapeLayer.Name = 0x10 // FName (Size: 0x8)
LandscapeLayer.bVisible = 0x18 // bool (Size: 0x1)
LandscapeLayer.bLocked = 0x19 // bool (Size: 0x1)
LandscapeLayer.HeightmapAlpha = 0x1c // float (Size: 0x4)
LandscapeLayer.WeightmapAlpha = 0x20 // float (Size: 0x4)
LandscapeLayer.BlendMode = 0x24 // uint8_t (Size: 0x1)
LandscapeLayer.Brushes = 0x28 // TArray<FLandscapeLayerBrush> (Size: 0x10)
LandscapeLayer.WeightmapLayerAllocationBlend = 0x38 // TMap<...> (Size: 0x50)
LandscapeLayerComponentData.HeightmapData = 0x0 // FHeightmapData (Size: 0x8)
LandscapeLayerComponentData.WeightmapData = 0x8 // FWeightmapData (Size: 0x30)
LandscapeLayerInfoObject.LayerName = 0x28 // FName (Size: 0x8)
LandscapeLayerInfoObject.PhysMaterial = 0x30 // PhysicalMaterial* (Size: 0x8)
LandscapeLayerInfoObject.Hardness = 0x38 // float (Size: 0x4)
LandscapeLayerInfoObject.LayerUsageDebugColor = 0x3c // FLinearColor (Size: 0x10)
LandscapeLayerStruct.LayerInfoObj = 0x0 // LandscapeLayerInfoObject* (Size: 0x8)
LandscapeMaterialInstanceConstant.TextureStreamingInfo = 0x3a8 // TArray<FLandscapeMaterialTextureStreamingInfo> (Size: 0x10)
LandscapeMaterialInstanceConstant.bIsLayerThumbnail = 0x3b8 // uint8_t (Size: 0x1)
LandscapeMaterialInstanceConstant.bDisableTessellation = 0x3b8 // uint8_t (Size: 0x1)
LandscapeMaterialInstanceConstant.bMobile = 0x3b8 // uint8_t (Size: 0x1)
LandscapeMaterialInstanceConstant.bEditorToolUsage = 0x3b8 // uint8_t (Size: 0x1)
LandscapeMaterialTextureStreamingInfo.TextureName = 0x0 // FName (Size: 0x8)
LandscapeMaterialTextureStreamingInfo.TexelFactor = 0x8 // float (Size: 0x4)
LandscapeMeshCollisionComponent.MeshGuid = 0x6b0 // FGuid (Size: 0x10)
LandscapeMeshProxyActor.LandscapeMeshProxyComponent = 0x310 // LandscapeMeshProxyComponent* (Size: 0x8)
LandscapeMeshProxyComponent.LandscapeGuid = 0x670 // FGuid (Size: 0x10)
LandscapeMeshProxyComponent.ProxyComponentBases = 0x680 // TArray<FIntPoint> (Size: 0x10)
LandscapeMeshProxyComponent.ProxyLOD = 0x690 // int8_t (Size: 0x1)
LandscapeProxy.SplineComponent = 0x310 // LandscapeSplinesComponent* (Size: 0x8)
LandscapeProxy.LandscapeGuid = 0x318 // FGuid (Size: 0x10)
LandscapeProxy.LandscapeSectionOffset = 0x328 // FIntPoint (Size: 0x8)
LandscapeProxy.MaxLODLevel = 0x330 // int32_t (Size: 0x4)
LandscapeProxy.LODDistanceFactor = 0x334 // float (Size: 0x4)
LandscapeProxy.LODFalloff = 0x338 // uint8_t (Size: 0x1)
LandscapeProxy.ComponentScreenSizeToUseSubSections = 0x33c // float (Size: 0x4)
LandscapeProxy.LOD0ScreenSize = 0x340 // float (Size: 0x4)
LandscapeProxy.LOD0DistributionSetting = 0x344 // float (Size: 0x4)
LandscapeProxy.LODDistributionSetting = 0x348 // float (Size: 0x4)
LandscapeProxy.TessellationComponentScreenSize = 0x34c // float (Size: 0x4)
LandscapeProxy.UseTessellationComponentScreenSizeFalloff = 0x350 // bool (Size: 0x1)
LandscapeProxy.TessellationComponentScreenSizeFalloff = 0x354 // float (Size: 0x4)
LandscapeProxy.OccluderGeometryLOD = 0x358 // int32_t (Size: 0x4)
LandscapeProxy.bUseAsOccluder = 0x35c // bool (Size: 0x1)
LandscapeProxy.StaticLightingLOD = 0x360 // int32_t (Size: 0x4)
LandscapeProxy.DefaultPhysMaterial = 0x368 // PhysicalMaterial* (Size: 0x8)
LandscapeProxy.StreamingDistanceMultiplier = 0x370 // float (Size: 0x4)
LandscapeProxy.LandscapeMaterial = 0x378 // MaterialInterface* (Size: 0x8)
LandscapeProxy.LandscapeHoleMaterial = 0x3a0 // MaterialInterface* (Size: 0x8)
LandscapeProxy.LandscapeMaterialsOverride = 0x3a8 // TArray<FLandscapeProxyMaterialOverride> (Size: 0x10)
LandscapeProxy.bMeshHoles = 0x3b8 // bool (Size: 0x1)
LandscapeProxy.MeshHolesMaxLod = 0x3b9 // uint8_t (Size: 0x1)
LandscapeProxy.RuntimeVirtualTextures = 0x3c0 // TArray<RuntimeVirtualTexture*> (Size: 0x10)
LandscapeProxy.VirtualTextureNumLods = 0x3d0 // int32_t (Size: 0x4)
LandscapeProxy.VirtualTextureLodBias = 0x3d4 // int32_t (Size: 0x4)
LandscapeProxy.VirtualTextureRenderPassType = 0x3d8 // EERuntimeVirtualTextureMainPassType (Size: 0x1)
LandscapeProxy.NegativeZBoundsExtension = 0x3dc // float (Size: 0x4)
LandscapeProxy.PositiveZBoundsExtension = 0x3e0 // float (Size: 0x4)
LandscapeProxy.LandscapeComponents = 0x3e8 // TArray<LandscapeComponent*> (Size: 0x10)
LandscapeProxy.CollisionComponents = 0x3f8 // TArray<LandscapeHeightfieldCollisionComponent*> (Size: 0x10)
LandscapeProxy.FoliageComponents = 0x408 // TArray<HierarchicalInstancedStaticMeshComponent*> (Size: 0x10)
LandscapeProxy.bHasLandscapeGrass = 0x47c // bool (Size: 0x1)
LandscapeProxy.StaticLightingResolution = 0x480 // float (Size: 0x4)
LandscapeProxy.CastShadow = 0x484 // uint8_t (Size: 0x1)
LandscapeProxy.bCastDynamicShadow = 0x484 // uint8_t (Size: 0x1)
LandscapeProxy.bCastStaticShadow = 0x484 // uint8_t (Size: 0x1)
LandscapeProxy.bCastFarShadow = 0x488 // uint8_t (Size: 0x1)
LandscapeProxy.bCastHiddenShadow = 0x48c // uint8_t (Size: 0x1)
LandscapeProxy.bHiddenShadowOnShadowCapture = 0x48c // uint8_t (Size: 0x1)
LandscapeProxy.ShadowCaptureLayer = 0x48d // EEShadowCaptureLayer (Size: 0x1)
LandscapeProxy.bCastShadowAsTwoSided = 0x490 // uint8_t (Size: 0x1)
LandscapeProxy.bAffectDistanceFieldLighting = 0x494 // uint8_t (Size: 0x1)
LandscapeProxy.LightingChannels = 0x495 // FLightingChannels (Size: 0x1)
LandscapeProxy.bUseMaterialPositionOffsetInStaticLighting = 0x498 // uint8_t (Size: 0x1)
LandscapeProxy.bStaticShadowMaskOnly = 0x49c // uint8_t (Size: 0x1)
LandscapeProxy.bForceUseSkyLightAsDiffuseGI = 0x4a0 // uint8_t (Size: 0x1)
LandscapeProxy.bRenderCustomDepth = 0x4a0 // uint8_t (Size: 0x1)
LandscapeProxy.CustomDepthStencilWriteMask = 0x4a4 // EERendererStencilMask (Size: 0x1)
LandscapeProxy.CustomDepthStencilValue = 0x4a8 // int32_t (Size: 0x4)
LandscapeProxy.LDMaxDrawDistance = 0x4ac // float (Size: 0x4)
LandscapeProxy.bForceUseSkyReflectionCaptureOnly = 0x4b0 // uint8_t (Size: 0x1)
LandscapeProxy.LightmassSettings = 0x4b4 // FLightmassPrimitiveSettings (Size: 0x18)
LandscapeProxy.CollisionMipLevel = 0x4cc // int32_t (Size: 0x4)
LandscapeProxy.SimpleCollisionMipLevel = 0x4d0 // int32_t (Size: 0x4)
LandscapeProxy.CollisionThickness = 0x4d4 // float (Size: 0x4)
LandscapeProxy.BodyInstance = 0x4d8 // FBodyInstance (Size: 0x158)
LandscapeProxy.bGenerateOverlapEvents = 0x630 // uint8_t (Size: 0x1)
LandscapeProxy.bBakeMaterialPositionOffsetIntoCollision = 0x630 // uint8_t (Size: 0x1)
LandscapeProxy.ComponentSizeQuads = 0x634 // int32_t (Size: 0x4)
LandscapeProxy.SubsectionSizeQuads = 0x638 // int32_t (Size: 0x4)
LandscapeProxy.NumSubsections = 0x63c // int32_t (Size: 0x4)
LandscapeProxy.bUsedForNavigation = 0x640 // uint8_t (Size: 0x1)
LandscapeProxy.bFillCollisionUnderLandscapeForNavmesh = 0x640 // uint8_t (Size: 0x1)
LandscapeProxy.bUseDynamicMaterialInstance = 0x644 // bool (Size: 0x1)
LandscapeProxy.NavigationGeometryGatheringMode = 0x645 // EENavDataGatheringMode (Size: 0x1)
LandscapeProxy.bUseLandscapeForCullingInvisibleHLODVertices = 0x646 // bool (Size: 0x1)
LandscapeProxy.bHasLayersContent = 0x647 // bool (Size: 0x1)
LandscapeProxy.WeightmapUsageMap = 0x648 // TMap<...> (Size: 0x50)
LandscapeProxyMaterialOverride.LODIndex = 0x0 // FPerPlatformInt (Size: 0x8)
LandscapeProxyMaterialOverride.Material = 0x8 // MaterialInterface* (Size: 0x8)
LandscapeSettings.MaxNumberOfLayers = 0x38 // int32_t (Size: 0x4)
LandscapeSettings.ReductionPercent = 0x3c // float (Size: 0x4)
LandscapeSettings.ReductionError = 0x40 // float (Size: 0x4)
LandscapeSettings.ProxyMeshReductionError = 0x44 // float (Size: 0x4)
LandscapeSettings.ProxyMeshWithHoleReductionError = 0x48 // float (Size: 0x4)
LandscapeSplineConnection.Segment = 0x0 // LandscapeSplineSegment* (Size: 0x8)
LandscapeSplineConnection.End = 0x8 // uint8_t (Size: 0x1)
LandscapeSplineControlPoint.Location = 0x28 // FVector (Size: 0xc)
LandscapeSplineControlPoint.Rotation = 0x34 // FRotator (Size: 0xc)
LandscapeSplineControlPoint.Width = 0x40 // float (Size: 0x4)
LandscapeSplineControlPoint.LayerWidthRatio = 0x44 // float (Size: 0x4)
LandscapeSplineControlPoint.SideFalloff = 0x48 // float (Size: 0x4)
LandscapeSplineControlPoint.LeftSideFalloffFactor = 0x4c // float (Size: 0x4)
LandscapeSplineControlPoint.RightSideFalloffFactor = 0x50 // float (Size: 0x4)
LandscapeSplineControlPoint.LeftSideLayerFalloffFactor = 0x54 // float (Size: 0x4)
LandscapeSplineControlPoint.RightSideLayerFalloffFactor = 0x58 // float (Size: 0x4)
LandscapeSplineControlPoint.EndFalloff = 0x5c // float (Size: 0x4)
LandscapeSplineControlPoint.ConnectedSegments = 0x60 // TArray<FLandscapeSplineConnection> (Size: 0x10)
LandscapeSplineControlPoint.Points = 0x70 // TArray<FLandscapeSplineInterpPoint> (Size: 0x10)
LandscapeSplineControlPoint.Bounds = 0x80 // FBox (Size: 0x1c)
LandscapeSplineControlPoint.LocalMeshComponent = 0xa0 // ControlPointMeshComponent* (Size: 0x8)
LandscapeSplineInterpPoint.Center = 0x0 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.Left = 0xc // FVector (Size: 0xc)
LandscapeSplineInterpPoint.Right = 0x18 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.FalloffLeft = 0x24 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.FalloffRight = 0x30 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.LayerLeft = 0x3c // FVector (Size: 0xc)
LandscapeSplineInterpPoint.LayerRight = 0x48 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.LayerFalloffLeft = 0x54 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.LayerFalloffRight = 0x60 // FVector (Size: 0xc)
LandscapeSplineInterpPoint.StartEndFalloff = 0x6c // float (Size: 0x4)
LandscapeSplineMeshEntry.Mesh = 0x0 // StaticMesh* (Size: 0x8)
LandscapeSplineMeshEntry.MaterialOverrides = 0x8 // TArray<MaterialInterface*> (Size: 0x10)
LandscapeSplineMeshEntry.bCenterH = 0x18 // uint8_t (Size: 0x1)
LandscapeSplineMeshEntry.CenterAdjust = 0x1c // FVector2D (Size: 0x8)
LandscapeSplineMeshEntry.bScaleToWidth = 0x24 // uint8_t (Size: 0x1)
LandscapeSplineMeshEntry.Scale = 0x28 // FVector (Size: 0xc)
LandscapeSplineMeshEntry.Orientation = 0x34 // uint8_t (Size: 0x1)
LandscapeSplineMeshEntry.ForwardAxis = 0x35 // uint8_t (Size: 0x1)
LandscapeSplineMeshEntry.UpAxis = 0x36 // uint8_t (Size: 0x1)
LandscapeSplineSegment.Connections = 0x28 // FLandscapeSplineSegmentConnection (Size: 0x18)
LandscapeSplineSegment.SplineInfo = 0x58 // FInterpCurveVector (Size: 0x18)
LandscapeSplineSegment.Points = 0x70 // TArray<FLandscapeSplineInterpPoint> (Size: 0x10)
LandscapeSplineSegment.Bounds = 0x80 // FBox (Size: 0x1c)
LandscapeSplineSegment.LocalMeshComponents = 0xa0 // TArray<SplineMeshComponent*> (Size: 0x10)
LandscapeSplineSegmentConnection.ControlPoint = 0x0 // LandscapeSplineControlPoint* (Size: 0x8)
LandscapeSplineSegmentConnection.TangentLen = 0x8 // float (Size: 0x4)
LandscapeSplineSegmentConnection.SocketName = 0xc // FName (Size: 0x8)
LandscapeSplinesComponent.ControlPoints = 0x5c8 // TArray<LandscapeSplineControlPoint*> (Size: 0x10)
LandscapeSplinesComponent.Segments = 0x5d8 // TArray<LandscapeSplineSegment*> (Size: 0x10)
LandscapeSplinesComponent.CookedForeignMeshComponents = 0x5e8 // TArray<MeshComponent*> (Size: 0x10)
LandscapeStreamingProxy.LandscapeActor = 0x698 // TLazyObjectPtr<UObject> (Size: 0x1c)
LandscapeWeightmapUsage.ChannelUsage = 0x28 // LandscapeComponent* (Size: 0x8)
LandscapeWeightmapUsage.LayerGuid = 0x48 // FGuid (Size: 0x10)
LayerBlendInput.LayerName = 0x0 // FName (Size: 0x8)
LayerBlendInput.BlendType = 0x8 // uint8_t (Size: 0x1)
LayerBlendInput.LayerInput = 0xc // FExpressionInput (Size: 0xc)
LayerBlendInput.HeightInput = 0x20 // FExpressionInput (Size: 0xc)
LayerBlendInput.PreviewWeight = 0x34 // float (Size: 0x4)
LayerBlendInput.ConstLayerInput = 0x38 // FVector (Size: 0xc)
LayerBlendInput.ConstHeightInput = 0x44 // float (Size: 0x4)
MaterialExpressionLandscapeDisplacement.LandscapeDisplacement = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeGrassOutput.GrassTypes = 0x40 // TArray<FGrassInput> (Size: 0x10)
MaterialExpressionLandscapeLayerBlend.Layers = 0x40 // TArray<FLayerBlendInput> (Size: 0x10)
MaterialExpressionLandscapeLayerBlend.ExpressionGUID = 0x50 // FGuid (Size: 0x10)
MaterialExpressionLandscapeLayerCoords.MappingType = 0x40 // uint8_t (Size: 0x1)
MaterialExpressionLandscapeLayerCoords.CustomUVType = 0x41 // uint8_t (Size: 0x1)
MaterialExpressionLandscapeLayerCoords.MappingScale = 0x44 // float (Size: 0x4)
MaterialExpressionLandscapeLayerCoords.MappingRotation = 0x48 // float (Size: 0x4)
MaterialExpressionLandscapeLayerCoords.MappingPanU = 0x4c // float (Size: 0x4)
MaterialExpressionLandscapeLayerCoords.MappingPanV = 0x50 // float (Size: 0x4)
MaterialExpressionLandscapeLayerSample.ParameterName = 0x40 // FName (Size: 0x8)
MaterialExpressionLandscapeLayerSample.PreviewWeight = 0x48 // float (Size: 0x4)
MaterialExpressionLandscapeLayerSample.ExpressionGUID = 0x4c // FGuid (Size: 0x10)
MaterialExpressionLandscapeLayerSwitch.LayerUsed = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeLayerSwitch.LayerNotUsed = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeLayerSwitch.ParameterName = 0x68 // FName (Size: 0x8)
MaterialExpressionLandscapeLayerSwitch.PreviewUsed = 0x70 // uint8_t (Size: 0x1)
MaterialExpressionLandscapeLayerSwitch.ExpressionGUID = 0x74 // FGuid (Size: 0x10)
MaterialExpressionLandscapeLayerWeight.Base = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeLayerWeight.Layer = 0x54 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeLayerWeight.ParameterName = 0x68 // FName (Size: 0x8)
MaterialExpressionLandscapeLayerWeight.PreviewWeight = 0x70 // float (Size: 0x4)
MaterialExpressionLandscapeLayerWeight.ConstBase = 0x74 // FVector (Size: 0xc)
MaterialExpressionLandscapeLayerWeight.ExpressionGUID = 0x80 // FGuid (Size: 0x10)
MaterialExpressionLandscapePhysicalMaterialOutput.Inputs = 0x40 // TArray<FPhysicalMaterialInput> (Size: 0x10)
MaterialExpressionLandscapeVisibilityMask.ExpressionGUID = 0x40 // FGuid (Size: 0x10)
OffsetData.Data = 0x0 // TArray<uint8_t> (Size: 0x10)
OffsetData.bUseDefault = 0x10 // bool (Size: 0x1)
PhysicalMaterialInput.PhysicalMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
PhysicalMaterialInput.Input = 0x8 // FExpressionInput (Size: 0xc)
WeightmapData.Textures = 0x0 // TArray<Texture2D*> (Size: 0x10)
WeightmapData.LayerAllocations = 0x10 // TArray<FWeightmapLayerAllocationInfo> (Size: 0x10)
WeightmapData.TextureUsages = 0x20 // TArray<LandscapeWeightmapUsage*> (Size: 0x10)
WeightmapLayerAllocationInfo.LayerInfo = 0x0 // LandscapeLayerInfoObject* (Size: 0x8)
WeightmapLayerAllocationInfo.WeightmapTextureIndex = 0x8 // uint8_t (Size: 0x1)
WeightmapLayerAllocationInfo.WeightmapTextureChannel = 0x9 // uint8_t (Size: 0x1)
GrassHDBuildData.State = 0x410 // EEGrassHDBuildState (Size: 0x1)
GrassHDBuildData.Description = 0x418 // FString (Size: 0x10)
GrassHDComponent.BuildDataCollection = 0xf8 // TArray<GrassHDBuildData*> (Size: 0x10)
GrassHDData.RuntimeDataMap = 0x28 // TMap<...> (Size: 0x50)
GrassHDRuntimeData.CompressedData = 0x28 // TArray<uint8_t> (Size: 0x10)
GrassHDRuntimeData.OBBsNum = 0x38 // int32_t (Size: 0x4)
GrassHDRuntimeData.CompressionVersion = 0x3c // uint8_t (Size: 0x1)
GrassHDRuntimeData.bRequireCPUAccess = 0x3d // bool (Size: 0x1)
GrassHDRuntimeData.bUseLandscapeLightmap = 0x3e // bool (Size: 0x1)
GrassHDRuntimeData.ComponentOrigin = 0x40 // FVector (Size: 0xc)
GrassHDRuntimeData.LightmapBaseBias = 0x4c // FVector2D (Size: 0x8)
GrassHDRuntimeData.LightmapBaseScale = 0x54 // FVector2D (Size: 0x8)
GrassHDRuntimeData.ShadowmapBaseBias = 0x5c // FVector2D (Size: 0x8)
GrassHDRuntimeData.ShadowmapBaseScale = 0x64 // FVector2D (Size: 0x8)
GrassHDRuntimeData.LightMapComponentBias = 0x6c // FVector2D (Size: 0x8)
GrassHDRuntimeData.LightMapComponentScale = 0x74 // FVector2D (Size: 0x8)
GrassHDRuntimeData.MeshBoxMin = 0x7c // FVector (Size: 0xc)
GrassHDRuntimeData.MeshBoxMax = 0x88 // FVector (Size: 0xc)
GrassHDRuntimeData.DesiredInstancesPerLeaf = 0x94 // int32_t (Size: 0x4)
GrassHDRuntimeData.RandomSeed = 0x98 // int32_t (Size: 0x4)
GrassHDRuntimeData.DrawScale = 0x9c // FVector (Size: 0xc)
GrassHDRuntimeData.SectionBase = 0xa8 // FIntPoint (Size: 0x8)
GrassHDRuntimeData.LandscapeSectionOffset = 0xb0 // FIntPoint (Size: 0x8)
GrassHDRuntimeData.LandscapeLocationOffset = 0xb8 // FVector (Size: 0xc)
GrassHDSettingsActor.CompressionVersion = 0x310 // uint8_t (Size: 0x1)
GrassHDSettingsActor.bEnabled = 0x311 // bool (Size: 0x1)
GrassHDSettingsActor.bNormalFixEnabled = 0x312 // bool (Size: 0x1)
MaterialExpressionLandscapeGrassHDOutput.MinGrassWeight = 0x40 // FExpressionInput (Size: 0xc)
MaterialExpressionLandscapeGrassHDOutput.Tolerance = 0x54 // FExpressionInput (Size: 0xc)
GNPanelReadyEventExtraParam.asset_version = 0x0 // FString (Size: 0x10)
GNPanelReadyEventExtraParam.is_cdn_asset = 0x10 // bool (Size: 0x1)
GNPanelReadyEventParam.Module = 0x0 // FString (Size: 0x10)
GNPanelReadyEventParam.isPopPanel = 0x10 // bool (Size: 0x1)
GNPanelReadyEventParam.ExtraParams = 0x18 // FGNPanelReadyEventExtraParam (Size: 0x18)
LIBaseEvent.EventType = 0x0 // EELIEventType (Size: 0x1)
LIBaseEvent.extraJson = 0x8 // FString (Size: 0x10)
LIHyperLinkTextBlockDecorator.m_Style = 0x28 // FHyperlinkStyle (Size: 0x540)
LIPanelBase.OnTickDelegate = 0x290 // FDelegate (Size: 0x10)
LIPanelBase.OnKeyDownDelegate = 0x2a0 // FDelegate (Size: 0x10)
LIPanelBase.OnKeyUpDelegate = 0x2b0 // FDelegate (Size: 0x10)
LIPanelBase.OnAddedToFocusPathDelegate = 0x2c0 // FDelegate (Size: 0x10)
LIPanelBase.OnRemovedFromFocusPathDelegate = 0x2d0 // FDelegate (Size: 0x10)
LIPanelBase.OnAnimationStartedDelegate = 0x2e0 // FDelegate (Size: 0x10)
LIPanelBase.OnAnimationFinishedDelegate = 0x2f0 // FDelegate (Size: 0x10)
LIUserData.GameId = 0x0 // int32_t (Size: 0x4)
LIUserData.ChannelID = 0x8 // FString (Size: 0x10)
LIUserData.Openid = 0x18 // FString (Size: 0x10)
LIUserData.Token = 0x28 // FString (Size: 0x10)
LIUserData.RoleId = 0x38 // FString (Size: 0x10)
LIUserData.Region = 0x48 // FString (Size: 0x10)
LIUserData.AreaID = 0x58 // int32_t (Size: 0x4)
LIUserData.ZoneId = 0x5c // int32_t (Size: 0x4)
LIUserData.LangType = 0x60 // FString (Size: 0x10)
LIUserData.DefLangType = 0x70 // FString (Size: 0x10)
LIUserData.RoleName = 0x80 // FString (Size: 0x10)
LIUserData.AppVersion = 0x90 // FString (Size: 0x10)
LIUserData.extraJson = 0xa0 // FString (Size: 0x10)
RadarChartWidget.Offset = 0x130 // FVector2D (Size: 0x8)
RadarChartWidget.Rotation = 0x138 // float (Size: 0x4)
RadarChartWidget.Radius = 0x13c // float (Size: 0x4)
RadarChartWidget.Segmentation = 0x140 // uint8_t (Size: 0x1)
RadarChartWidget.SegmentationThickness = 0x144 // float (Size: 0x4)
RadarChartWidget.SegmentationColor = 0x148 // FColor (Size: 0x4)
RadarChartWidget.PlateOutlineThickness = 0x14c // float (Size: 0x4)
RadarChartWidget.PlateOutlineColor = 0x150 // FColor (Size: 0x4)
RadarChartWidget.PlateColor = 0x154 // FColor (Size: 0x4)
RadarChartWidget.ChartColor = 0x158 // FColor (Size: 0x4)
RadarChartWidget.ChartOutlineColor = 0x15c // FColor (Size: 0x4)
RadarChartWidget.ChartOutlineThickness = 0x160 // float (Size: 0x4)
RadarChartWidget.ChartValues = 0x168 // TArray<float> (Size: 0x10)
RadarChartWidget.RadiusDelegate = 0x178 // FDelegate (Size: 0x10)
RadarChartWidget.SegmentationDelegate = 0x188 // FDelegate (Size: 0x10)
AnimSequenceLevelSequenceLink.SkelTrackGuid = 0x28 // FGuid (Size: 0x10)
AnimSequenceLevelSequenceLink.PathToLevelSequence = 0x38 // FSoftObjectPath (Size: 0x18)
DefaultLevelSequenceInstanceData.TransformOriginActor = 0x30 // Actor* (Size: 0x8)
DefaultLevelSequenceInstanceData.TransformOrigin = 0x40 // FTransform (Size: 0x30)
LevelSequence.MovieScene = 0x68 // MovieScene* (Size: 0x8)
LevelSequence.ObjectReferences = 0x70 // FLevelSequenceObjectReferenceMap (Size: 0x50)
LevelSequence.BindingReferences = 0xc0 // FLevelSequenceBindingReferences (Size: 0xa0)
LevelSequence.PossessedObjects = 0x160 // TMap<...> (Size: 0x50)
LevelSequence.DirectorClass = 0x1b0 // ClassProperty (Size: 0x8)
LevelSequence.AssetUserData = 0x1b8 // TArray<AssetUserData*> (Size: 0x10)
LevelSequenceActor.PlaybackSettings = 0x320 // FMovieSceneSequencePlaybackSettings (Size: 0x14)
LevelSequenceActor.SequencePlayer = 0x338 // LevelSequencePlayer* (Size: 0x8)
LevelSequenceActor.LevelSequence = 0x340 // FSoftObjectPath (Size: 0x18)
LevelSequenceActor.CameraSettings = 0x358 // FLevelSequenceCameraSettings (Size: 0x2)
LevelSequenceActor.BurnInOptions = 0x360 // LevelSequenceBurnInOptions* (Size: 0x8)
LevelSequenceActor.BindingOverrides = 0x368 // MovieSceneBindingOverrides* (Size: 0x8)
LevelSequenceActor.bAutoPlay = 0x370 // uint8_t (Size: 0x1)
LevelSequenceActor.bOverrideInstanceData = 0x370 // uint8_t (Size: 0x1)
LevelSequenceActor.bReplicatePlayback = 0x370 // uint8_t (Size: 0x1)
LevelSequenceActor.DefaultInstanceData = 0x378 // Object* (Size: 0x8)
LevelSequenceActor.BurnInInstance = 0x380 // LevelSequenceBurnIn* (Size: 0x8)
LevelSequenceActor.bShowBurnin = 0x388 // bool (Size: 0x1)
LevelSequenceAnimSequenceLink.AnimSequenceLinks = 0x28 // TArray<FLevelSequenceAnimSequenceLinkItem> (Size: 0x10)
LevelSequenceAnimSequenceLinkItem.SkelTrackGuid = 0x0 // FGuid (Size: 0x10)
LevelSequenceAnimSequenceLinkItem.PathToAnimSequence = 0x10 // FSoftObjectPath (Size: 0x18)
LevelSequenceAnimSequenceLinkItem.bExportTransforms = 0x28 // bool (Size: 0x1)
LevelSequenceAnimSequenceLinkItem.bExportCurves = 0x29 // bool (Size: 0x1)
LevelSequenceAnimSequenceLinkItem.bRecordInWorldSpace = 0x2a // bool (Size: 0x1)
LevelSequenceBindingReference.PackageName = 0x0 // FString (Size: 0x10)
LevelSequenceBindingReference.ExternalObjectPath = 0x10 // FSoftObjectPath (Size: 0x18)
LevelSequenceBindingReference.ObjectPath = 0x28 // FString (Size: 0x10)
LevelSequenceBindingReferenceArray.References = 0x0 // TArray<FLevelSequenceBindingReference> (Size: 0x10)
LevelSequenceBindingReferences.BindingIdToReferences = 0x0 // TMap<...> (Size: 0x50)
LevelSequenceBindingReferences.AnimSequenceInstances = 0x50 // TSet<...> (Size: 0x50)
LevelSequenceBurnIn.FrameInformation = 0x290 // FLevelSequencePlayerSnapshot (Size: 0xb8)
LevelSequenceBurnIn.LevelSequenceActor = 0x348 // LevelSequenceActor* (Size: 0x8)
LevelSequenceBurnInOptions.bUseBurnIn = 0x28 // bool (Size: 0x1)
LevelSequenceBurnInOptions.BurnInClass = 0x30 // FSoftClassPath (Size: 0x18)
LevelSequenceBurnInOptions.Settings = 0x48 // LevelSequenceBurnInInitSettings* (Size: 0x8)
LevelSequenceCameraSettings.bOverrideAspectRatioAxisConstraint = 0x0 // bool (Size: 0x1)
LevelSequenceCameraSettings.AspectRatioAxisConstraint = 0x1 // uint8_t (Size: 0x1)
LevelSequenceDirector.Player = 0x28 // LevelSequencePlayer* (Size: 0x8)
LevelSequenceMediaController.Sequence = 0x318 // LevelSequenceActor* (Size: 0x8)
LevelSequenceMediaController.MediaComponent = 0x320 // MediaComponent* (Size: 0x8)
LevelSequenceMediaController.ServerStartTimeSeconds = 0x328 // float (Size: 0x4)
LevelSequenceObject.ObjectOrOwner = 0x0 // TLazyObjectPtr<UObject> (Size: 0x1c)
LevelSequenceObject.ComponentName = 0x20 // FString (Size: 0x10)
LevelSequenceObject.CachedComponent = 0x30 // TWeakObjectPtr<UObject> (Size: 0x8)
LevelSequencePlayer.OnCameraCut = 0x690 // FMulticastInlineDelegate (Size: 0x10)
LevelSequencePlayerSnapshot.MasterName = 0x0 // FString (Size: 0x10)
LevelSequencePlayerSnapshot.MasterTime = 0x10 // FQualifiedFrameTime (Size: 0x10)
LevelSequencePlayerSnapshot.SourceTime = 0x20 // FQualifiedFrameTime (Size: 0x10)
LevelSequencePlayerSnapshot.CurrentShotName = 0x30 // FString (Size: 0x10)
LevelSequencePlayerSnapshot.CurrentShotLocalTime = 0x40 // FQualifiedFrameTime (Size: 0x10)
LevelSequencePlayerSnapshot.CurrentShotSourceTime = 0x50 // FQualifiedFrameTime (Size: 0x10)
LevelSequencePlayerSnapshot.SourceTimecode = 0x60 // FString (Size: 0x10)
LevelSequencePlayerSnapshot.CameraComponent = 0x70 // TSoftObjectPtr<UObject> (Size: 0x28)
LevelSequencePlayerSnapshot.Settings = 0x98 // FLevelSequenceSnapshotSettings (Size: 0xc)
LevelSequencePlayerSnapshot.ActiveShot = 0xa8 // LevelSequence* (Size: 0x8)
LevelSequencePlayerSnapshot.ShotID = 0xb0 // FMovieSceneSequenceID (Size: 0x4)
LevelSequenceSnapshotSettings.ZeroPadAmount = 0x0 // uint8_t (Size: 0x1)
LevelSequenceSnapshotSettings.FrameRate = 0x4 // FFrameRate (Size: 0x8)
VideoCaptureManager.ResolutionX = 0x28 // uint32_t (Size: 0x4)
VideoCaptureManager.ResolutionY = 0x2c // uint32_t (Size: 0x4)
VideoCaptureManager.CodeRate = 0x30 // uint32_t (Size: 0x4)
VideoCaptureManager.CaptureState = 0x34 // EEMovieCaptureState (Size: 0x1)
VideoCaptureManager.bForceStop = 0x175 // bool (Size: 0x1)
ADSSetting.Axis = 0x0 // uint8_t (Size: 0x1)
ADSSetting.AdjustType = 0x1 // EEAdjustType (Size: 0x1)
ADSSetting.CurveName = 0x4 // FName (Size: 0x8)
AnimNode_AdjustArmStretch.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_AdjustArmStretch.EndBone = 0xe0 // FBoneReference (Size: 0x10)
AnimNode_AdjustArmStretch.IKHandBone = 0xf0 // FBoneReference (Size: 0x10)
AnimNode_AdjustArmStretch.ExtraOffset = 0x100 // FVector (Size: 0xc)
AnimNode_AdjustArmStretch.ExpectAngleBetweenBones = 0x10c // float (Size: 0x4)
AnimNode_AdjustArmStretch.CalcStretchAlgorithm = 0x110 // EECalcStretchAlgorithm (Size: 0x1)
AnimNode_AlignAroundPivot.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_AlignAroundPivot.AlignTarget = 0xe0 // FBoneSocketTarget (Size: 0x60)
AnimNode_AlignAroundPivot.AlignTransform = 0x140 // FTransform (Size: 0x30)
AnimNode_AlignAroundPivot.Pivot = 0x170 // FVector (Size: 0xc)
AnimNode_AlignAroundPivot.AlignAlpha = 0x17c // float (Size: 0x4)
AnimNode_AlignAroundPivot.InterpSpeed = 0x180 // float (Size: 0x4)
AnimNode_AlignAroundPivot.AxisMask = 0x184 // uint8_t (Size: 0x1)
AnimNode_ApplyBonesAdditive.SourceBase = 0x10 // FPoseLink (Size: 0x10)
AnimNode_ApplyBonesAdditive.Base = 0x20 // FPoseLink (Size: 0x10)
AnimNode_ApplyBonesAdditive.Additive = 0x30 // FPoseLink (Size: 0x10)
AnimNode_ApplyBonesAdditive.TargetBoneList = 0x40 // TArray<FBoneReference> (Size: 0x10)
AnimNode_BoneAdjustment.Input = 0x10 // FPoseLink (Size: 0x10)
AnimNode_BoneAdjustment.Additive = 0x20 // FPoseLink (Size: 0x10)
AnimNode_BoneAdjustment.Target = 0x30 // FPoseLink (Size: 0x10)
AnimNode_BoneAdjustment.Sequence = 0x40 // AnimSequenceBase* (Size: 0x8)
AnimNode_BoneAdjustment.ScaledBone = 0x48 // FBoneReference (Size: 0x10)
AnimNode_BoneAdjustment.bEvaluateSequenceEndFrame = 0x58 // bool (Size: 0x1)
AnimNode_BoneAdjustment.ADSSettings = 0x60 // TArray<FADSSetting> (Size: 0x10)
AnimNode_BoneAdjustment.LastAnimSequence = 0x70 // AnimSequenceBase* (Size: 0x8)
AnimNode_MotionForceWarping.MotionBone = 0x1e0 // FBoneReference (Size: 0x10)
AnimNode_MotionForceWarping.MotionParentBone = 0x1f0 // FBoneReference (Size: 0x10)
AnimNode_MotionForceWarping.bAccelChange = 0x200 // bool (Size: 0x1)
AnimNode_MotionForceWarping.MotionLinearAccScale = 0x204 // FVector (Size: 0xc)
AnimNode_MotionForceWarping.MotionLinearVelScale = 0x210 // FVector (Size: 0xc)
AnimNode_MotionForceWarping.LocalMotionAppliedLinearAccClamp = 0x21c // FVector (Size: 0xc)
AnimNode_MotionForceWarping.MotionReciever = 0x228 // SkeletalMeshComponent* (Size: 0x8)
AnimNode_MotionForceWarping.MotionRecieverBone = 0x230 // FName (Size: 0x8)
AnimNode_SpeedWarping.IkFootRootBone = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_SpeedWarping.FeetDefinitions = 0xe0 // TArray<FIKBones> (Size: 0x10)
AnimNode_SpeedWarping.PelvisBone = 0xf0 // FBoneReference (Size: 0x10)
AnimNode_SpeedWarping.SpeedScaling = 0x100 // float (Size: 0x4)
AnimNode_SpeedWarping.ActualSpeedScaling = 0x104 // float (Size: 0x4)
AnimNode_SpeedWarping.SpeedScalingBiasClamp = 0x108 // FInputScaleBiasClamp (Size: 0x30)
AnimNode_SpeedWarping.ClampIKUsingFKLeg = 0x138 // bool (Size: 0x1)
AnimNode_VirtualPivot.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_VirtualPivot.VirtualParent = 0xe0 // FBoneSocketTarget (Size: 0x60)
AnimNode_VirtualPivot.PivotOffset = 0x140 // FVector (Size: 0xc)
AnimNode_VirtualPivot.PivotSpace = 0x14c // uint8_t (Size: 0x1)
AnimNode_VirtualPivot.Rotation = 0x150 // FRotator (Size: 0xc)
AnimNode_VirtualPivot.RotateSpace = 0x15c // uint8_t (Size: 0x1)
AnimationCurvesMap.CurveToValueMap = 0x0 // TMap<...> (Size: 0x50)
AnimationFloatCurvesMap.NameToCurveMap = 0x0 // TMap<...> (Size: 0x50)
IKBones.IKFootBone = 0x0 // FBoneReference (Size: 0x10)
IKBones.FKFootBone = 0x10 // FBoneReference (Size: 0x10)
IKBones.NumBonesInUpperLimb = 0x20 // int32_t (Size: 0x4)
IKBones.NumBonesInLowerLimb = 0x24 // int32_t (Size: 0x4)
IKFootLocation.LimbRootLocation = 0x0 // FVector (Size: 0xc)
IKFootLocation.OriginLocation = 0xc // FVector (Size: 0xc)
IKFootLocation.ActualLocation = 0x18 // FVector (Size: 0xc)
IKFootLocation.NewLocation = 0x24 // FVector (Size: 0xc)
MontageBlendTimePair.BlendInTime = 0x0 // float (Size: 0x4)
MontageBlendTimePair.BlendOutTime = 0x4 // float (Size: 0x4)
PelvisAdjustmentInterp.Stiffness = 0x0 // float (Size: 0x4)
PelvisAdjustmentInterp.Dampen = 0x4 // float (Size: 0x4)
CaptureSample.WorldPositionNoOriginOffset = 0x0 // FVector (Size: 0xc)
CaptureSample.CameraRotation = 0xc // FRotator (Size: 0xc)
GPUTraceCaptureActor.CaptureSamples = 0x310 // TArray<FCaptureSample> (Size: 0x10)
GPUTraceCaptureActor.NextCaptureIndex = 0x320 // int32_t (Size: 0x4)
MFBenchmarkManager.bTickTrs = 0x310 // bool (Size: 0x1)
MFBenchmarkMarker.GamePerfPositionTag = 0x338 // FName (Size: 0x8)
MFMarkerDataWriter.TargetTable = 0x310 // DataTable* (Size: 0x8)
MFMarkerPosDataTabelData.PosX = 0x8 // float (Size: 0x4)
MFMarkerPosDataTabelData.PosY = 0xc // float (Size: 0x4)
MFMarkerPosDataTabelData.PosZ = 0x10 // float (Size: 0x4)
MFMarkerPosDataTabelData.RotX = 0x14 // float (Size: 0x4)
MFMarkerPosDataTabelData.RotY = 0x18 // float (Size: 0x4)
MFMarkerPosDataTabelData.RotZ = 0x1c // float (Size: 0x4)
MFClimateActor.System = 0x310 // MFClimateWorldSubSystem* (Size: 0x8)
MFClimateBakeMode.BakeMode = 0x310 // MFClimateBakeModeComponent* (Size: 0x8)
MFClimateBakeModeComponent.RegisteredBakeProcedures = 0x118 // TArray<MFClimateBaseBakeProcedure*> (Size: 0x10)
MFClimateBakeModeComponent.bBakeMode = 0x188 // bool (Size: 0x1)
MFClimateBakeModeComponent.RunningBakeProcedure = 0x190 // MFClimateBaseBakeProcedure* (Size: 0x8)
MFClimateBakeProcedure.TodsToBake = 0x40 // TArray<float> (Size: 0x10)
MFClimateBakeProcedure.bIterateWeatherPresets = 0x50 // bool (Size: 0x1)
MFClimateBakeProcedure.bHideCelestials = 0x51 // bool (Size: 0x1)
MFClimateBakeProcedure.bHideLightning = 0x52 // bool (Size: 0x1)
MFClimateBakeProcedure.bHideRain = 0x53 // bool (Size: 0x1)
MFClimateBakeProcedure.PrepareTime = 0x54 // float (Size: 0x4)
MFClimateBakeProcedure.bDisableVolumetricFog = 0x58 // bool (Size: 0x1)
MFClimateBakeProcedure.bDisableRealTimeSkyLightTimeSlicing = 0x59 // bool (Size: 0x1)
MFClimateBakeProcedure.OuterLoopCount = 0x5c // int32_t (Size: 0x4)
MFClimateBakeProcedure.CurrentOuterLoop = 0x60 // int32_t (Size: 0x4)
MFClimateBakeProcedure.CurrentTODIndex = 0x64 // int32_t (Size: 0x4)
MFClimateBakeProcedure.CurrentTOD = 0x68 // float (Size: 0x4)
MFClimateBakeProcedure.CurrentWeatherIndex = 0x6c // int32_t (Size: 0x4)
MFClimateBakeProcedure.CurrentWeatherName = 0x70 // FString (Size: 0x10)
MFClimateBakeProcedure.BackupTimeSlicingEnabled = 0x80 // int32_t (Size: 0x4)
MFClimateBakeProcedure.BackupVolumetricFog = 0x84 // int32_t (Size: 0x4)
MFClimateBakeProcedure.BackupTOD = 0x88 // float (Size: 0x4)
MFClimateBakeProcedure.bBackupEventProducerActive = 0x8c // bool (Size: 0x1)
MFClimateBakeProcedure.BackupWeatherLayers = 0x90 // TArray<float> (Size: 0x10)
MFClimateBaseBakeProcedure.bEditorOnly = 0x28 // bool (Size: 0x1)
MFClimateBaseBakeProcedure.Baker = 0x30 // MFClimateBakeModeComponent* (Size: 0x8)
MFClimateBaseBakeProcedure.bBakeDone = 0x38 // bool (Size: 0x1)
MFClimateBaseLightningEventProducer.Director = 0x28 // MFClimateLightningDirectorComponent* (Size: 0x8)
MFClimateBaseSkyMesh.bCenterAtCamera = 0x310 // bool (Size: 0x1)
MFClimateCelestialBody.bSpriteMode = 0x310 // bool (Size: 0x1)
MFClimateCelestialBody.Color = 0x314 // FColor (Size: 0x4)
MFClimateCelestialBody.Intensity = 0x318 // float (Size: 0x4)
MFClimateCelestialBody.AngularDiameter = 0x31c // float (Size: 0x4)
MFClimateCelestialBody.Distance = 0x320 // float (Size: 0x4)
MFClimateCelestialBody.OrbitComponent = 0x328 // MFClimateCelestialOrbit* (Size: 0x8)
MFClimateCelestialBody.RotatedPivot = 0x330 // SceneComponent* (Size: 0x8)
MFClimateCelestialOrbit.OrbitType = 0x238 // EEMFClimateCelestialOrbitType (Size: 0x4)
MFClimateCelestialOrbit.SatelliteOrbitFrequencyYear = 0x23c // uint8_t (Size: 0x1)
MFClimateCelestialOrbit.AscendingNodeLongitude = 0x240 // float (Size: 0x4)
MFClimateCelestialOrbit.OrbitalInclination = 0x244 // float (Size: 0x4)
MFClimateCelestialOrbit.OrbitOffset = 0x248 // float (Size: 0x4)
MFClimateCelestialOrbit.DistantOrbitLatitude = 0x24c // float (Size: 0x4)
MFClimateCelestialOrbit.DistantOrbitLongitude = 0x250 // float (Size: 0x4)
MFClimateCelestialOrbit.ExtraHorizontalOffset = 0x254 // float (Size: 0x4)
MFClimateCelestialOrbit.CelestialRotation = 0x258 // FRotator (Size: 0xc)
MFClimateCelestialOrbit.CelestialPosition = 0x264 // FRotator (Size: 0xc)
MFClimateCelestialOrbit.CelestialToEarthEcliptic = 0x270 // FRotator (Size: 0xc)
MFClimateCirrusCloud.bAutoColorFromSystem = 0x110 // bool (Size: 0x1)
MFClimateCirrusCloud.EnvironmentLightColor = 0x114 // FLinearColor (Size: 0x10)
MFClimateCirrusCloud.EnvironmentLightDir = 0x124 // FVector (Size: 0xc)
MFClimateCirrusCloud.Height = 0x130 // float (Size: 0x4)
MFClimateCirrusCloud.Fill = 0x134 // float (Size: 0x4)
MFClimateCirrusCloud.Albedo = 0x138 // FColor (Size: 0x4)
MFClimateCirrusCloud.Emissive = 0x13c // FLinearColor (Size: 0x10)
MFClimateCirrusCloud.ExtinctionCoefficient = 0x14c // float (Size: 0x4)
MFClimateCirrusCloud.FirstLobeG = 0x150 // float (Size: 0x4)
MFClimateCirrusCloud.SecondLobeG = 0x154 // float (Size: 0x4)
MFClimateCloudCustomVolume.TextureIndex = 0x310 // int32_t (Size: 0x4)
MFClimateCloudCustomVolume.EdgeThreshold = 0x314 // float (Size: 0x4)
MFClimateCloudCustomVolume.BaseTiling = 0x318 // float (Size: 0x4)
MFClimateCloudCustomVolume.DetailStrength = 0x31c // float (Size: 0x4)
MFClimateCloudCustomVolume.DetailTiling = 0x320 // float (Size: 0x4)
MFClimateCloudCustomVolume.CurlStrength = 0x324 // float (Size: 0x4)
MFClimateCloudCustomVolume.CurlTiling = 0x328 // float (Size: 0x4)
MFClimateCloudCustomVolume.DetailOffset = 0x32c // FVector2D (Size: 0x8)
MFClimateCloudCustomVolume.BaseNoiseCenter = 0x334 // float (Size: 0x4)
MFClimateCloudCustomVolume.BaseNoiseVariation = 0x338 // float (Size: 0x4)
MFClimateCloudCustomVolume.ExtinctionScale = 0x33c // float (Size: 0x4)
MFClimateCloudCustomVolume.Erosion = 0x340 // float (Size: 0x4)
MFClimateCloudCustomVolumesManager.CloudTextures = 0x310 // TArray<VolumeTexture*> (Size: 0x10)
MFClimateCloudCustomVolumesManager.bShowCloudBoundingBoxes = 0x320 // bool (Size: 0x1)
MFClimateCloudCustomVolumesManager.CloudTextureAtlas = 0x328 // VolumeTexture* (Size: 0x8)
MFClimateCloudNoiseGeneratorV2.NoiseTextureSize = 0x30 // FIntVector (Size: 0xc)
MFClimateCloudNoiseGeneratorV2.bSingleChannel = 0x3c // bool (Size: 0x1)
MFClimateCloudNoiseGeneratorV2.WorleyFbmOctaves = 0x40 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinFbmOctaves = 0x44 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.WorleyNoiseCells_Channel1 = 0x48 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinNoiseCells_Channel1 = 0x4c // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinWeight_Channel1 = 0x50 // float (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.WorleyNoiseCells_Channel2 = 0x54 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinNoiseCells_Channel2 = 0x58 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinWeight_Channel2 = 0x5c // float (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.WorleyNoiseCells_Channel3 = 0x60 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinNoiseCells_Channel3 = 0x64 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinWeight_Channel3 = 0x68 // float (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.WorleyNoiseCells_Channel4 = 0x6c // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinNoiseCells_Channel4 = 0x70 // int32_t (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.PerlinWeight_Channel4 = 0x74 // float (Size: 0x4)
MFClimateCloudNoiseGeneratorV2.OutputTexture3D = 0x78 // VolumeTexture* (Size: 0x8)
MFClimateCloudNoiseGeneratorV2.OutputTexture2D = 0x80 // Texture2D* (Size: 0x8)
MFClimateCloudNoiseGroup.PlatformSettings = 0x30 // FMFClimatePlatformNoiseGenerationSettings (Size: 0x38)
MFClimateCloudNoiseGroup.SavedBaseNoise = 0x68 // VolumeTexture* (Size: 0x8)
MFClimateCloudNoiseGroup.SavedDetailNoise = 0x70 // VolumeTexture* (Size: 0x8)
MFClimateCloudNoiseGroup.SavedWeatherMapNoise = 0x78 // Texture2D* (Size: 0x8)
MFClimateCloudNoiseGroup.SavedCurlNoise = 0x80 // Texture2D* (Size: 0x8)
MFClimateCloudNoiseGroupPlatformSwitcher.CookedAsset = 0x30 // MFClimateCloudNoiseGroup* (Size: 0x8)
MFClimateCloudProfile.TypeDescriptors = 0x30 // TArray<FMFClimateCloudTypeDescriptor> (Size: 0x10)
MFClimateCloudProfile.LUT0 = 0x40 // Texture2D* (Size: 0x8)
MFClimateCloudProfile.LUT0SizeX = 0x48 // uint32_t (Size: 0x4)
MFClimateCloudProfile.LUT0SizeY = 0x4c // uint32_t (Size: 0x4)
MFClimateCloudProfile.LUTMSApproxMaxOpticalDepth = 0x50 // float (Size: 0x4)
MFClimateCloudProfile.LUTMSApproxRangeCompress = 0x54 // float (Size: 0x4)
MFClimateCloudProfile.LUTMSApproxSizeX = 0x58 // uint32_t (Size: 0x4)
MFClimateCloudProfile.LUTMSApproxSizeY = 0x5c // uint32_t (Size: 0x4)
MFClimateCloudProfile.LUTMSApproxIterationCount = 0x60 // uint32_t (Size: 0x4)
MFClimateCloudProfile.CloudMSApproxA = 0x64 // float (Size: 0x4)
MFClimateCloudProfile.CloudMSApproxB = 0x68 // float (Size: 0x4)
MFClimateCloudProfile.CloudMSApproxC = 0x6c // float (Size: 0x4)
MFClimateCloudProfile.CloudMSApproxLobeG1 = 0x70 // float (Size: 0x4)
MFClimateCloudProfile.CloudMSApproxLobeG2 = 0x74 // float (Size: 0x4)
MFClimateCloudSettings.CloudBaseTilingVertical = 0x0 // float (Size: 0x4)
MFClimateCloudSettings.CloudBaseTilingHorizontal = 0x4 // float (Size: 0x4)
MFClimateCloudSettings.CloudDetailTiling = 0x8 // float (Size: 0x4)
MFClimateCloudSettings.CloudDetailStrength = 0xc // float (Size: 0x4)
MFClimateCloudSettings.CloudCurlStrength = 0x10 // float (Size: 0x4)
MFClimateCloudSettings.CloudCurlTiling = 0x14 // float (Size: 0x4)
MFClimateCloudSettings.DetailWindMultiply = 0x18 // float (Size: 0x4)
MFClimateCloudSettings.CloudBottomHeight = 0x1c // float (Size: 0x4)
MFClimateCloudSettings.CloudThickness = 0x20 // float (Size: 0x4)
MFClimateCloudSettings.CloudDetailFadeStart = 0x24 // float (Size: 0x4)
MFClimateCloudSettings.CloudDetailFadeEnd = 0x28 // float (Size: 0x4)
MFClimateCloudSettings.HorizonAARange = 0x2c // float (Size: 0x4)
MFClimateCloudSettings.HorizonAAValue = 0x30 // float (Size: 0x4)
MFClimateCloudSettings.CloudAlbedo = 0x34 // FLinearColor (Size: 0x10)
MFClimateCloudSettings.CloudExtinction = 0x44 // float (Size: 0x4)
MFClimateCloudSettings.CloudFirstLobeG = 0x48 // float (Size: 0x4)
MFClimateCloudSettings.CloudSecondLobeG = 0x4c // float (Size: 0x4)
MFClimateCloudSettings.MaxShadowRayLength = 0x50 // float (Size: 0x4)
MFClimateCloudSettings.ShadowAttenuation = 0x54 // float (Size: 0x4)
MFClimateCloudSettings.CloudAmbientOcclusionSky = 0x58 // float (Size: 0x4)
MFClimateCloudSettings.CloudAmbientOcclusionGround = 0x5c // float (Size: 0x4)
MFClimateCloudSettings.CloudOpacityScale = 0x60 // float (Size: 0x4)
MFClimateCloudSettings.CloudEmissive = 0x64 // FLinearColor (Size: 0x10)
MFClimateCloudSettings.LightningTint = 0x74 // FLinearColor (Size: 0x10)
MFClimateCloudSettings.EarthShadowSharpness = 0x84 // float (Size: 0x4)
MFClimateCloudSettings.InscatteringBrightness = 0x88 // float (Size: 0x4)
MFClimateCloudTypeDescriptor.TypeWeight = 0x0 // float (Size: 0x4)
MFClimateCloudTypeDescriptor.BaseNoiseCenter = 0x8 // FRuntimeFloatCurve (Size: 0x88)
MFClimateCloudTypeDescriptor.BaseNoiseVariation = 0x90 // FRuntimeFloatCurve (Size: 0x88)
MFClimateCloudTypeDescriptor.ExtinctionScale = 0x118 // FRuntimeFloatCurve (Size: 0x88)
MFClimateCloudTypeDescriptor.Erosion = 0x1a0 // FRuntimeFloatCurve (Size: 0x88)
MFClimateComponent.System = 0xf8 // MFClimateWorldSubSystem* (Size: 0x8)
MFClimateCurlCloudNoiseGenerationParams.CurlCells = 0x0 // int32_t (Size: 0x4)
MFClimateCurlCloudNoiseGenerationParams.CurlBrightness = 0x4 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.RandomSeed = 0x0 // int32_t (Size: 0x4)
MFClimateFractalLightningGenerateParams.InitialBranchProb = 0x4 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.BranchProbAttenuation = 0x8 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.TargetOffset = 0xc // FVector (Size: 0xc)
MFClimateFractalLightningGenerateParams.MinSegmentLength = 0x18 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.MaxFracTimes = 0x1c // int32_t (Size: 0x4)
MFClimateFractalLightningGenerateParams.WidthFactor = 0x20 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.BranchShortenFactor = 0x24 // float (Size: 0x4)
MFClimateFractalLightningGenerateParams.MinMaxBranchLiftAngleDegrees = 0x28 // FVector2D (Size: 0x8)
MFClimateFractalLightningGenerateParams.MinChannelCreationDistance = 0x30 // float (Size: 0x4)
MFClimateGlobalWind.GlobalWindComponent = 0x310 // MFClimateGlobalWindComponent* (Size: 0x8)
MFClimateGlobalWindComponent.Direction = 0x110 // FVector2D (Size: 0x8)
MFClimateGlobalWindComponent.Level = 0x118 // float (Size: 0x4)
MFClimateGlobalWindComponent.WindTravel = 0x11c // FVector2D (Size: 0x8)
MFClimateGlobalWindComponent.WindFrequency = 0x124 // float (Size: 0x4)
MFClimateGlobalWindComponent.WindAmplitude = 0x128 // float (Size: 0x4)
MFClimateGlobalWindComponent.OnWindParameterChanged = 0x130 // FMulticastInlineDelegate (Size: 0x10)
MFClimateHDSunMoonSceneLight.MFClimateLight = 0x310 // MFClimateHDSunMoonSceneLightComponent* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.SunLight = 0x118 // DirectionalLight* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.MoonLight = 0x120 // DirectionalLight* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.BindSun = 0x128 // MFClimateCelestialBody* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.BindMoon = 0x130 // MFClimateCelestialBody* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.SunDirection = 0x138 // FVector (Size: 0xc)
MFClimateHDSunMoonSceneLightComponent.MoonDirection = 0x144 // FVector (Size: 0xc)
MFClimateHDSunMoonSceneLightComponent.SunColoredBrightness = 0x150 // FLinearColor (Size: 0x10)
MFClimateHDSunMoonSceneLightComponent.MoonColoredBrightness = 0x160 // FLinearColor (Size: 0x10)
MFClimateHDSunMoonSceneLightComponent.bAutoUpdateCloudCastShadow = 0x170 // bool (Size: 0x1)
MFClimateHDSunMoonSceneLightComponent.CastCloudShadowTransferTime = 0x174 // float (Size: 0x4)
MFClimateHDSunMoonSceneLightComponent.CloudShadowValue = 0x178 // float (Size: 0x4)
MFClimateHDSunMoonSceneLightComponent.SunLightComponent = 0x180 // DirectionalLightComponent* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.MoonLightComponent = 0x188 // DirectionalLightComponent* (Size: 0x8)
MFClimateHDSunMoonSceneLightComponent.SunScatteredIrradiance = 0x190 // FLinearColor (Size: 0x10)
MFClimateHDSunMoonSceneLightComponent.MoonScatteredIrradiance = 0x1a0 // FLinearColor (Size: 0x10)
MFClimateHDSunMoonSceneLightComponent.CurrentLightningSceneLightColor = 0x1b0 // FLinearColor (Size: 0x10)
MFClimateHDSunMoonSceneLightComponent.LightningFakeLight = 0x1c0 // DirectionalLightComponent* (Size: 0x8)
MFClimateIrcCamera.CameraComponent = 0x310 // CameraComponent* (Size: 0x8)
MFClimateIrcCamera.CameraTag = 0x318 // FString (Size: 0x10)
MFClimateLayerPreset.PresetName = 0x0 // FString (Size: 0x10)
MFClimateLayerPreset.Items = 0x10 // TArray<FMFClimateWeatherLayerPresetItem> (Size: 0x10)
MFClimateLayerPreset.Weight = 0x20 // float (Size: 0x4)
MFClimateLightningChannelActor.LightningMaterial = 0x310 // MaterialInterface* (Size: 0x8)
MFClimateLightningChannelActor.Mid = 0x318 // MaterialInstanceDynamic* (Size: 0x8)
MFClimateLightningChannelActor.Params = 0x320 // FMFClimateFractalLightningGenerateParams (Size: 0x34)
MFClimateLightningChannelActor.PMC = 0x358 // ProceduralMeshComponent* (Size: 0x8)
MFClimateLightningChannelActor.Width = 0x360 // float (Size: 0x4)
MFClimateLightningChannelActor.MinObserveDegree = 0x364 // float (Size: 0x4)
MFClimateLightningChannelActor.bEnableMockRange = 0x368 // bool (Size: 0x1)
MFClimateLightningChannelActor.MockRange = 0x36c // float (Size: 0x4)
MFClimateLightningDirectorComponent.InstantiatedLightningActor = 0x110 // MFClimateLightningChannelActor* (Size: 0x8)
MFClimateLightningDirectorComponent.ExecutingLightningEvent = 0x118 // FMFClimateLightningEvent (Size: 0x24)
MFClimateLightningDirectorComponent.LightningLeaderProgress = 0x13c // float (Size: 0x4)
MFClimateLightningDirectorComponent.CurrentEnergy = 0x140 // float (Size: 0x4)
MFClimateLightningDirectorComponent.RemainingReStrike = 0x144 // int32_t (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeTimer = 0x148 // float (Size: 0x4)
MFClimateLightningDirectorComponent.EventProducer = 0x150 // MFClimateBaseLightningEventProducer* (Size: 0x8)
MFClimateLightningDirectorComponent.LightningChannelType = 0x158 // ClassProperty (Size: 0x8)
MFClimateLightningDirectorComponent.LightningFrequency = 0x160 // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReturnStrikeEnergyMean = 0x164 // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReturnStrikeEnergyStdDev = 0x168 // float (Size: 0x4)
MFClimateLightningDirectorComponent.StrikeEnergyBoost = 0x16c // float (Size: 0x4)
MFClimateLightningDirectorComponent.LightningDecayAlpha = 0x170 // float (Size: 0x4)
MFClimateLightningDirectorComponent.LightningTint = 0x174 // FLinearColor (Size: 0x10)
MFClimateLightningDirectorComponent.EventOverEnergyThreshold = 0x184 // float (Size: 0x4)
MFClimateLightningDirectorComponent.bAllowLightningEventOverride = 0x188 // bool (Size: 0x1)
MFClimateLightningDirectorComponent.ReStrikeFrequency = 0x18c // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeCountMean = 0x190 // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeCountStdDev = 0x194 // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeEnergyMean = 0x198 // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeEnergyStdDev = 0x19c // float (Size: 0x4)
MFClimateLightningDirectorComponent.ReStrikeTickInterval = 0x1a0 // float (Size: 0x4)
MFClimateLightningDirectorComponent.LightningLeaderDuration = 0x1a4 // float (Size: 0x4)
MFClimateLightningDirectorComponent.LightningLeaderRelativeEv = 0x1a8 // float (Size: 0x4)
MFClimateLightningDirectorComponent.bRelativeToCamera = 0x1ac // bool (Size: 0x1)
MFClimateLightningDirectorComponent.LightningCloudLayerHeight = 0x1b0 // float (Size: 0x4)
MFClimateLightningDirectorComponent.MaxDistance = 0x1b4 // float (Size: 0x4)
MFClimateLightningDirectorComponent.MinDistance = 0x1b8 // float (Size: 0x4)
MFClimateLightningDirectorComponent.MaxGroundOffset = 0x1bc // float (Size: 0x4)
MFClimateLightningDirectorComponent.SceneLightEVScale = 0x1c0 // float (Size: 0x4)
MFClimateLightningDirectorComponent.bDevelopmentModeEnable = 0x1c4 // bool (Size: 0x1)
MFClimateLightningDirectorComponent.bDevelopmentModeAutoLightning = 0x1c5 // bool (Size: 0x1)
MFClimateLightningDirectorComponent.DevelopmentModeAutoLightningInterval = 0x1c8 // float (Size: 0x4)
MFClimateLightningDirectorComponent.bEventProducerActive = 0x1d0 // bool (Size: 0x1)
MFClimateLightningDirectorComponent.OnLightningEventRegistered = 0x1d8 // FMulticastInlineDelegate (Size: 0x10)
MFClimateLightningDirectorComponent.OnLightningStrike = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
MFClimateLightningEvent.bForceRejectPrevious = 0x0 // bool (Size: 0x1)
MFClimateLightningEvent.StartPosition = 0x4 // FVector (Size: 0xc)
MFClimateLightningEvent.EndPosition = 0x10 // FVector (Size: 0xc)
MFClimateLightningEvent.NormalizedReturnStrikeEnergy = 0x1c // float (Size: 0x4)
MFClimateLightningEvent.ReStrikeCount = 0x20 // int32_t (Size: 0x4)
MFClimateLightningEventProducer.bDeterministicByTOD = 0x30 // bool (Size: 0x1)
MFClimateLightningEventProducer.TestIntervalInTodSeconds = 0x34 // float (Size: 0x4)
MFClimateLightningEventProducer.bDisableDeterministicInEditor = 0x38 // bool (Size: 0x1)
MFClimateMPCItem.PublicMPC = 0x0 // MaterialParameterCollection* (Size: 0x8)
MFClimateMPCItem.MPCI = 0x8 // MaterialParameterCollectionInstance* (Size: 0x8)
MFClimateMovableRainWetnessComponent.LastOccludePhysicalMaterial = 0xf8 // PhysicalMaterial* (Size: 0x8)
MFClimateMovableRainWetnessComponent.WetSpeed = 0x100 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.DrySpeed = 0x104 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.OcclusionWetRate = 0x108 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.OcclusionDryRate = 0x10c // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.SnowWetSpeed = 0x110 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.SnowDrySpeed = 0x114 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.SnowOcclusionWetRate = 0x118 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.SnowOcclusionDryRate = 0x11c // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.bUpdateMaterialParam = 0x120 // bool (Size: 0x1)
MFClimateMovableRainWetnessComponent.AccumulationParameterName = 0x124 // FName (Size: 0x8)
MFClimateMovableRainWetnessComponent.OcclusionParameterName = 0x12c // FName (Size: 0x8)
MFClimateMovableRainWetnessComponent.bUpdatePrimitiveData = 0x134 // bool (Size: 0x1)
MFClimateMovableRainWetnessComponent.PrimitiveDataIndex = 0x135 // uint8_t (Size: 0x1)
MFClimateMovableRainWetnessComponent.OcclusionRate = 0x138 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.CurrentAccumulation = 0x13c // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.SmoothedOcclusion = 0x140 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.AppliedVisualAccumulation = 0x144 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.AppliedVisualOcclusion = 0x148 // float (Size: 0x4)
MFClimateMovableRainWetnessComponent.MFClimateSystem = 0x160 // MFClimateWorldSubSystem* (Size: 0x8)
MFClimateMovableRainWetnessComponent.RainActor = 0x168 // MFClimateRain* (Size: 0x8)
MFClimateMovableRainWetnessComponent.CollectedMaterials = 0x170 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
MFClimateMovableRainWetnessComponent.CollectedPrimitive = 0x180 // TSet<...> (Size: 0x50)
MFClimateMovableRainWetnessComponent.CollectedProtective = 0x1d0 // TSet<...> (Size: 0x50)
MFClimateNoiseGenerationParams.NoiseType = 0x0 // EEMFClimateNoiseType (Size: 0x4)
MFClimateNoiseGenerationParams.CellNoiseCells = 0x4 // int32_t (Size: 0x4)
MFClimateNoiseGenerationParams.CellNoiseScale = 0x8 // float (Size: 0x4)
MFClimateNoiseGenerationParams.bCellNoiseUseSmoothMin = 0xc // uint8_t (Size: 0x1)
MFClimateNoiseGenerationParams.CellNoiseSmoothMinK = 0x10 // float (Size: 0x4)
MFClimateParticleRain.RainShadowCapture = 0x410 // ActorComponent* (Size: 0x8)
MFClimateParticleRain.WideShadowCapture = 0x418 // ActorComponent* (Size: 0x8)
MFClimateParticleRain.bDelayParametersUpdate = 0x420 // bool (Size: 0x1)
MFClimateParticleRain.NiagaraComponents = 0x428 // TArray<NiagaraComponent*> (Size: 0x10)
MFClimateParticleRain.CascadesComponents = 0x438 // TArray<ParticleSystemComponent*> (Size: 0x10)
MFClimatePlatformNoiseGenerationSettings.BaseNoiseTextureSize = 0x0 // FIntVector (Size: 0xc)
MFClimatePlatformNoiseGenerationSettings.DetailNoiseTextureSize = 0xc // FIntVector (Size: 0xc)
MFClimatePlatformNoiseGenerationSettings.BaseNoise2DTextureSize = 0x18 // FIntPoint (Size: 0x8)
MFClimatePlatformNoiseGenerationSettings.DetailNoise2DTextureSize = 0x20 // FIntPoint (Size: 0x8)
MFClimatePlatformNoiseGenerationSettings.WeatherMapNoiseTextureSize = 0x28 // FIntPoint (Size: 0x8)
MFClimatePlatformNoiseGenerationSettings.CurlNoiseTextureSize = 0x30 // FIntPoint (Size: 0x8)
MFClimatePlayerTransformComponent.bCameraOrPawn = 0x238 // bool (Size: 0x1)
MFClimatePlayerTransformComponent.bSyncPosition = 0x239 // bool (Size: 0x1)
MFClimatePlayerTransformComponent.bSyncRotation = 0x23a // bool (Size: 0x1)
MFClimatePlayerTransformComponent.bIgnorePitchRotation = 0x23b // bool (Size: 0x1)
MFClimateRain.DynamicObjectPrimitiveIndex = 0x320 // uint8_t (Size: 0x1)
MFClimateRain.bIsUsePrimitiveCustomData = 0x321 // bool (Size: 0x1)
MFClimateRain.PuddleDisturbSpeed = 0x324 // float (Size: 0x4)
MFClimateRain.PuddleDisturbTiling = 0x328 // float (Size: 0x4)
MFClimateRain.PuddleDisturbStrength = 0x32c // float (Size: 0x4)
MFClimateRain.PuddleRippleStrength = 0x330 // float (Size: 0x4)
MFClimateRain.PuddleRippleFrequencies = 0x340 // FVector4 (Size: 0x10)
MFClimateRain.PuddleRippleTiling = 0x350 // float (Size: 0x4)
MFClimateRain.IsSnow = 0x354 // bool (Size: 0x1)
MFClimateRain.SnowTrailManager = 0x358 // MFClimateSnowTrailManager* (Size: 0x8)
MFClimateRain.AmountOfRain = 0x360 // float (Size: 0x4)
MFClimateRain.Accumulation = 0x364 // float (Size: 0x4)
MFClimateRain.MaxAccumulation = 0x368 // float (Size: 0x4)
MFClimateRain.bRainAutoUpdateAccumulation = 0x36c // bool (Size: 0x1)
MFClimateRain.AccumulateSpeed = 0x370 // float (Size: 0x4)
MFClimateRain.DecaySpeed = 0x374 // float (Size: 0x4)
MFClimateRain.WindTiltMultiplier = 0x378 // float (Size: 0x4)
MFClimateRain.PlayerPosition = 0x380 // MFClimatePlayerTransformComponent* (Size: 0x8)
MFClimateRain.PlayerRotation = 0x388 // MFClimatePlayerTransformComponent* (Size: 0x8)
MFClimateRain.WindAlignedPivot = 0x390 // SceneComponent* (Size: 0x8)
MFClimateRain.WetnessComponent = 0x398 // MFClimateMovableRainWetnessComponent* (Size: 0x8)
MFClimateRain.bTraceComplex = 0x3a0 // bool (Size: 0x1)
MFClimateRain.DebugType = 0x3a1 // uint8_t (Size: 0x1)
MFClimateRain.bUseObjectChannels = 0x3a2 // bool (Size: 0x1)
MFClimateRain.DetectChannel = 0x3a3 // uint8_t (Size: 0x1)
MFClimateRain.ObjectChannels = 0x3a8 // TArray<uint8_t> (Size: 0x10)
MFClimateRain.detectrange = 0x3b8 // float (Size: 0x4)
MFClimateRain.RainOcclusionTestManager = 0x3c0 // MFClimateRainOcclusionTestManager* (Size: 0x8)
MFClimateRainOcclusionTestManager.Rain = 0xf8 // MFClimateRain* (Size: 0x8)
MFClimateRainOcclusionTestManager.TickBudget = 0x100 // float (Size: 0x4)
MFClimateRainOcclusionTestManager.LocalObservingTargetComponent = 0x108 // MFClimateMovableRainWetnessComponent* (Size: 0x8)
MFClimateRainOcclusionTestManager.MovableObjectQueue = 0x110 // TArray<FMFClimateRainOcclusionTestQueueItem> (Size: 0x10)
MFClimateRainOcclusionTestManager.MovableObjectQueue_Off = 0x120 // TArray<FMFClimateRainOcclusionTestQueueItem> (Size: 0x10)
MFClimateRainOcclusionTestQueueItem.Component = 0x0 // MFClimateMovableRainWetnessComponent* (Size: 0x8)
MFClimateRainParameterUpdateTick.Rain = 0x38 // MFClimateRain* (Size: 0x8)
MFClimateSDFCanvas.Root = 0x310 // StaticMeshComponent* (Size: 0x8)
MFClimateSDFCanvas.SourceMesh = 0x318 // StaticMesh* (Size: 0x8)
MFClimateSDFCanvas.TargetTexture = 0x320 // VolumeTexture* (Size: 0x8)
MFClimateSDFCanvas.SaveDistanceFieldPortion = 0x328 // float (Size: 0x4)
MFClimateSDFCanvas.bSaveEveryFrame = 0x32c // bool (Size: 0x1)
MFClimateSceneLightInterfaceComponent.bHasMainLightControl = 0x110 // bool (Size: 0x1)
MFClimateSceneLightInterfaceComponent.MobileForceUpdateTimer = 0x114 // float (Size: 0x4)
MFClimateSettings.MFClimateMPCPaths = 0x38 // TArray<FSoftObjectPath> (Size: 0x10)
MFClimateSharedNoiseGenerationSettings.BaseNoiseGenerationParams = 0x0 // FMFClimateNoiseGenerationParams (Size: 0x14)
MFClimateSharedNoiseGenerationSettings.DetailNoiseGenerationParams = 0x14 // FMFClimateNoiseGenerationParams (Size: 0x14)
MFClimateSharedNoiseGenerationSettings.BaseNoise2DGenerationParams = 0x28 // FMFClimateNoiseGenerationParams (Size: 0x14)
MFClimateSharedNoiseGenerationSettings.DetailNoise2DGenerationParams = 0x3c // FMFClimateNoiseGenerationParams (Size: 0x14)
MFClimateSharedNoiseGenerationSettings.CurlNoiseParams = 0x50 // FMFClimateCurlCloudNoiseGenerationParams (Size: 0x8)
MFClimateSharedNoiseGenerationSettings.WeatherMapParams = 0x58 // FMFClimateWeatherMapCloudNoiseGenerationParams (Size: 0xc)
MFClimateSimpleLight.MFClimateLight = 0x310 // MFClimateSingleSceneLightComponent* (Size: 0x8)
MFClimateSingleMeshSky.Material = 0x318 // MaterialInterface* (Size: 0x8)
MFClimateSingleMeshSky.ShadingMesh = 0x320 // StaticMeshComponent* (Size: 0x8)
MFClimateSingleMeshSky.SkySphereScale = 0x328 // FVector (Size: 0xc)
MFClimateSingleMeshSky.SkySphereLocation = 0x334 // FVector (Size: 0xc)
MFClimateSingleSceneLightComponent.BoundCelestialBody = 0x118 // MFClimateCelestialBody* (Size: 0x8)
MFClimateSingleSceneLightComponent.LongShadowFixDegrees = 0x120 // float (Size: 0x4)
MFClimateSingleSceneLightComponent.LongShadowPower = 0x124 // float (Size: 0x4)
MFClimateSingleSceneLightComponent.MainLight = 0x128 // DirectionalLight* (Size: 0x8)
MFClimateSingleSceneLightComponent.Light = 0x130 // DirectionalLightComponent* (Size: 0x8)
MFClimateSkyAtmosphereComponent.RawSkyAtmosphere = 0x350 // SkyAtmosphereComponent* (Size: 0x8)
MFClimateSkyAtmosphereComponent.SkyAtmosphereTransmittanceAtZenith = 0x358 // FLinearColor (Size: 0x10)
MFClimateSkyAtmosphereComponent.SkyAtmosphereTransmittanceCurrent = 0x368 // FLinearColor (Size: 0x10)
MFClimateSkyAtmosphereComponent.CpuSkyAtmosphereSkyTex = 0x388 // Texture2D* (Size: 0x8)
MFClimateSkyAtmosphereComponent.CpuSkyAtmosphereTransmittanceTex = 0x390 // Texture2D* (Size: 0x8)
MFClimateSnowTrailManager.TrailMaterial = 0xf8 // MaterialInterface* (Size: 0x8)
MFClimateSnowTrailManager.HistoryBlendMaterial = 0x100 // MaterialInterface* (Size: 0x8)
MFClimateSnowTrailManager.ClearMaterial = 0x108 // MaterialInterface* (Size: 0x8)
MFClimateSnowTrailManager.CopyMaterial = 0x110 // MaterialInterface* (Size: 0x8)
MFClimateSnowTrailManager.EdgeAccumulationMaterial = 0x118 // MaterialInterface* (Size: 0x8)
MFClimateSnowTrailManager.SnowTrailMPC = 0x120 // MaterialParameterCollection* (Size: 0x8)
MFClimateSnowTrailManager.TrailExtent = 0x128 // FVector2D (Size: 0x8)
MFClimateSnowTrailManager.FootPrintScale = 0x130 // FVector2D (Size: 0x8)
MFClimateSnowTrailManager.SnowHeight = 0x138 // float (Size: 0x4)
MFClimateSnowTrailManager.SideFade = 0x13c // float (Size: 0x4)
MFClimateSnowTrailManager.Current = 0x140 // TextureRenderTarget2D* (Size: 0x8)
MFClimateSnowTrailManager.History = 0x148 // TextureRenderTarget2D* (Size: 0x8)
MFClimateSnowTrailManager.Trails = 0x150 // TextureRenderTarget2D* (Size: 0x8)
MFClimateSnowTrailManager.Snow = 0x158 // MFClimateRain* (Size: 0x8)
MFClimateSnowTrailManager.SnowTrails = 0x160 // TArray<FSnowTrail> (Size: 0x10)
MFClimateSunMoonSceneLight.MFClimateLight = 0x310 // MFClimateSunMoonSceneLightComponent* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.BindSun = 0x118 // MFClimateCelestialBody* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.BindMoon = 0x120 // MFClimateCelestialBody* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.MainLightTransferTime = 0x128 // float (Size: 0x4)
MFClimateSunMoonSceneLightComponent.LongShadowFixDegrees = 0x12c // float (Size: 0x4)
MFClimateSunMoonSceneLightComponent.LongShadowFixPower = 0x130 // float (Size: 0x4)
MFClimateSunMoonSceneLightComponent.MainDirectionalLight = 0x138 // DirectionalLight* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.MainDirectionalLightComponent = 0x140 // DirectionalLightComponent* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.LightningColor = 0x148 // FLinearColor (Size: 0x10)
MFClimateSunMoonSceneLightComponent.FakeAtmLight1 = 0x158 // DirectionalLightComponent* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.FakeAtmLight2 = 0x160 // DirectionalLightComponent* (Size: 0x8)
MFClimateSunMoonSceneLightComponent.SunWeight = 0x168 // float (Size: 0x4)
MFClimateSunMoonSceneLightComponent.SunScatteredIrradiance = 0x16c // FLinearColor (Size: 0x10)
MFClimateSunMoonSceneLightComponent.MoonScatteredIrradiance = 0x17c // FLinearColor (Size: 0x10)
MFClimateTimeGeography.TimeGeographyComponent = 0x310 // MFClimateTimeGeographyComponent* (Size: 0x8)
MFClimateTimeGeographyComponent.TimeZone = 0x110 // float (Size: 0x4)
MFClimateTimeGeographyComponent.YearPercent = 0x114 // float (Size: 0x4)
MFClimateTimeGeographyComponent.TimeOfDay = 0x118 // float (Size: 0x4)
MFClimateTimeGeographyComponent.Longitude = 0x11c // float (Size: 0x4)
MFClimateTimeGeographyComponent.Latitude = 0x120 // float (Size: 0x4)
MFClimateTimeGeographyComponent.EarthAxialTilt = 0x124 // float (Size: 0x4)
MFClimateTimeGeographyComponent.EarthRadiusKM = 0x128 // float (Size: 0x4)
MFClimateTimeGeographyComponent.SceneNorthVector = 0x12c // FVector2D (Size: 0x8)
MFClimateTimeGeographyComponent.bAutoStepTime = 0x134 // bool (Size: 0x1)
MFClimateTimeGeographyComponent.AutoStepTimeRate = 0x138 // float (Size: 0x4)
MFClimateTimeGeographyComponent.AutoStepInEditor = 0x13c // EEAutoAutoStepMode (Size: 0x1)
MFClimateTimeGeographyComponent.AutoStepRateInEditor = 0x140 // float (Size: 0x4)
MFClimateTodIrc2D.bSuperFastEyeAdaption = 0x118 // bool (Size: 0x1)
MFClimateTodIrc2D.bHDR = 0x119 // bool (Size: 0x1)
MFClimateTodIrc2D.Width = 0x11c // int32_t (Size: 0x4)
MFClimateTodIrc2D.Height = 0x120 // int32_t (Size: 0x4)
MFClimateTodIrcBase.OutputFolder = 0xb8 // FString (Size: 0x10)
MFClimateTodIrcBase.FileNameFormat = 0xc8 // FString (Size: 0x10)
MFClimateTodIrcBase.CameraTagFilter = 0xd8 // TArray<FString> (Size: 0x10)
MFClimateTodIrcBase.bSyncEditorViewportWithCamera = 0xe8 // bool (Size: 0x1)
MFClimateTodIrcBase.Cameras = 0xf0 // TArray<MFClimateIrcCamera*> (Size: 0x10)
MFClimateTodIrcBase.BackupCameraLocation = 0x100 // FVector (Size: 0xc)
MFClimateTodIrcBase.BackupCameraRotation = 0x10c // FRotator (Size: 0xc)
MFClimateTodIrcPanorama.Size = 0x118 // int32_t (Size: 0x4)
MFClimateTodSequenceMixer.WeatherComponent = 0x310 // MFClimateWeatherComponent* (Size: 0x8)
MFClimateTodSequenceMixer.PresetsComponent = 0x318 // MFClimateWeatherLayerPresetsComponent* (Size: 0x8)
MFClimateUIBase.MFClimateSystem = 0x290 // MFClimateWorldSubSystem* (Size: 0x8)
MFClimateVolumeCloud.VolumeCloud = 0x310 // MFClimateVolumeCloudComponent* (Size: 0x8)
MFClimateVolumeCloudComponent.bAutoColorFromSystem = 0x110 // bool (Size: 0x1)
MFClimateVolumeCloudComponent.SunColorTop = 0x114 // FLinearColor (Size: 0x10)
MFClimateVolumeCloudComponent.SunColorBottom = 0x124 // FLinearColor (Size: 0x10)
MFClimateVolumeCloudComponent.SunDirection = 0x134 // FVector (Size: 0xc)
MFClimateVolumeCloudComponent.CloudAmbientGround = 0x140 // FLinearColor (Size: 0x10)
MFClimateVolumeCloudComponent.CloudAmbientSky = 0x150 // FLinearColor (Size: 0x10)
MFClimateVolumeCloudComponent.PreExposureSmoothness = 0x160 // float (Size: 0x4)
MFClimateVolumeCloudComponent.bAutoWindFromSystem = 0x164 // bool (Size: 0x1)
MFClimateVolumeCloudComponent.SystemWindMultiplier = 0x168 // float (Size: 0x4)
MFClimateVolumeCloudComponent.CloudWind = 0x16c // FVector2D (Size: 0x8)
MFClimateVolumeCloudComponent.CloudVerticalWind = 0x174 // float (Size: 0x4)
MFClimateVolumeCloudComponent.WeatherMapGenerator = 0x178 // MFClimateWeatherMapGenerator* (Size: 0x8)
MFClimateVolumeCloudComponent.CustomWeatherMap = 0x180 // Texture* (Size: 0x8)
MFClimateVolumeCloudComponent.CustomWeatherMapSize = 0x188 // float (Size: 0x4)
MFClimateVolumeCloudComponent.CloudProfile = 0x190 // MFClimateCloudProfile* (Size: 0x8)
MFClimateVolumeCloudComponent.CloudSettings = 0x198 // FMFClimateCloudSettings (Size: 0x8c)
MFClimateVolumeCloudComponent.HibernateUpdateRemain = 0x440 // float (Size: 0x4)
MFClimateVolumeCloudComponent.NoiseGroupSwitcher = 0x448 // MFClimateCloudNoiseGroupPlatformSwitcher* (Size: 0x8)
MFClimateVolumeCloudComponent.MSApproxRT = 0x450 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.RaymarchRTFull = 0x458 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.RaymarchRTCheckerboard = 0x460 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.ResolveRT = 0x468 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.CachedBaseNoiseTexture = 0x470 // VolumeTexture* (Size: 0x8)
MFClimateVolumeCloudComponent.CachedDetailNoiseTexture = 0x478 // VolumeTexture* (Size: 0x8)
MFClimateVolumeCloudComponent.CachedCurlNoiseTexture = 0x480 // Texture2D* (Size: 0x8)
MFClimateVolumeCloudComponent.CachedLUT0Texture = 0x488 // Texture2D* (Size: 0x8)
MFClimateVolumeCloudComponent.CustomVolumes = 0x490 // TArray<MFClimateCloudCustomVolume*> (Size: 0x10)
MFClimateVolumeCloudComponent.SDFManager = 0x4a8 // MFClimateCloudCustomVolumesManager* (Size: 0x8)
MFClimateVolumeCloudComponent.SDFCloudRTFull = 0x4b0 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.SDFCloudRTCheckerboard = 0x4b8 // TextureRenderTarget2D* (Size: 0x8)
MFClimateVolumeCloudComponent.SDFCloudResolveRT = 0x4c0 // TextureRenderTarget2D* (Size: 0x8)
MFClimateWeatherComponent.SceneBindings = 0x110 // MFClimateWeatherLayerSceneBindings* (Size: 0x8)
MFClimateWeatherComponent.Layers = 0x118 // TArray<FMFClimateWeatherLayer> (Size: 0x10)
MFClimateWeatherComponent.bBindingsDirty = 0x198 // bool (Size: 0x1)
MFClimateWeatherLayer.BlendWeight = 0x0 // float (Size: 0x4)
MFClimateWeatherLayer.EffectiveBlendWeight = 0x4 // float (Size: 0x4)
MFClimateWeatherLayer.TimeOfDaySequence = 0x8 // LevelSequence* (Size: 0x8)
MFClimateWeatherLayer.EvaluationMode = 0x10 // EEWeatherLayerEvaluationMode (Size: 0x4)
MFClimateWeatherLayer.bIgnorePresetSystem = 0x14 // bool (Size: 0x1)
MFClimateWeatherLayerPresetItem.Sequence = 0x0 // LevelSequence* (Size: 0x8)
MFClimateWeatherLayerPresetItem.Weight = 0x8 // float (Size: 0x4)
MFClimateWeatherLayerPresetsComponent.OnPresetChangedEvent = 0x110 // FMulticastInlineDelegate (Size: 0x10)
MFClimateWeatherLayerPresetsComponent.ActivatedPresets = 0x120 // TArray<FMFClimateLayerPreset> (Size: 0x10)
MFClimateWeatherLayerPresetsComponent.WeatherComponent = 0x130 // MFClimateWeatherComponent* (Size: 0x8)
MFClimateWeatherLayerSceneBindings.PersistentMappings_New = 0x328 // TMap<...> (Size: 0x50)
MFClimateWeatherMapCloudMask.DrawLayer = 0x310 // int32_t (Size: 0x4)
MFClimateWeatherMapCloudMask.DrawType = 0x314 // EEMFClimateCloudMaskType (Size: 0x4)
MFClimateWeatherMapCloudMask.Material = 0x318 // MaterialInterface* (Size: 0x8)
MFClimateWeatherMapCloudMask.Mid = 0x320 // MaterialInstanceDynamic* (Size: 0x8)
MFClimateWeatherMapCloudMask.MaterialParameter = 0x330 // FVector4 (Size: 0x10)
MFClimateWeatherMapCloudNoiseGenerationParams.CoverageWorleyCellNum = 0x0 // int32_t (Size: 0x4)
MFClimateWeatherMapCloudNoiseGenerationParams.CoveragePerlinFreq = 0x4 // int32_t (Size: 0x4)
MFClimateWeatherMapCloudNoiseGenerationParams.CloudTypePerlinFreq = 0x8 // int32_t (Size: 0x4)
MFClimateWeatherMapGenerator.bRefreshEveryFrame = 0x310 // bool (Size: 0x1)
MFClimateWeatherMapGenerator.WeatherMapScaleInKM = 0x314 // int32_t (Size: 0x4)
MFClimateWeatherMapGenerator.OutputTarget = 0x318 // TextureRenderTarget2D* (Size: 0x8)
MFClimateWeatherMapGenerator.GlobalCoverage = 0x330 // float (Size: 0x4)
MFClimateWeatherMapGenerator.GlobalCloudType = 0x334 // float (Size: 0x4)
MFClimateWeatherMapGenerator.bGeometryDirty = 0x338 // bool (Size: 0x1)
MFClimateWeatherMapGenerator.bRenderingDirty = 0x339 // bool (Size: 0x1)
MFClimateWorldSubSystem.DuplicatedFeatures = 0x90 // TArray<Object*> (Size: 0x10)
MFClimateWorldSubSystem.FeatureTable = 0xa0 // TArray<Object*> (Size: 0x10)
MFClimateWorldSubSystem.PublicMPCs = 0xc0 // TArray<FMFClimateMPCItem> (Size: 0x10)
MFStatisticDataCollectCore.SceneInfoCollect = 0x28 // TArray<FSceneObjeInfo_Base> (Size: 0x10)
MFStatisticDataCollectCore_Foliage.SceneInfoCollect_Foliage = 0x38 // TArray<FSceneObjInfo_Foliage> (Size: 0x10)
MFStatisticDataCollectCore_Foliage.MyCollectType = 0x48 // EEFoliageCollectType (Size: 0x1)
MFStatisticDataCollectCore_RenderObjCount.SceneInfoCollect_RenderObj = 0x38 // TArray<FSceneObjInfo_RenderObj> (Size: 0x10)
MFStatisticDataCollectCore_RenderObjCount.bIncludeFoliage = 0x48 // bool (Size: 0x1)
MFStatisticDataCollectCore_RenderObjCount.bCollectCenterMode = 0x49 // bool (Size: 0x1)
MFStatisticDataCollectCore_RenderObjCount.RenderObjType = 0x4a // EERenderObjType (Size: 0x1)
MFStatisticDataCollectCore_SMBound.SceneInfoCollect_SM = 0x38 // TArray<FSceneObjInfo_StaticMeshActor> (Size: 0x10)
MFStatisticDataVisualizeActor.DataCollecterClass = 0x310 // ClassProperty (Size: 0x8)
MFStatisticDataVisualizeActor.StatCollectClass = 0x318 // ClassProperty (Size: 0x8)
MFStatisticDataVisualizeActor.PixelMesh = 0x320 // StaticMesh* (Size: 0x8)
MFStatisticDataVisualizeActor.PixelSize = 0x328 // float (Size: 0x4)
MFStatisticDataVisualizeActor.StartAnchor = 0x330 // Actor* (Size: 0x8)
MFStatisticDataVisualizeActor.EndAnchor = 0x338 // Actor* (Size: 0x8)
MFStatisticDataVisualizeActor.DataUpperLimit = 0x340 // float (Size: 0x4)
MFStatisticDataVisualizeActor.DataLowerLimit = 0x344 // float (Size: 0x4)
MFStatisticDataVisualizeActor.XCountCache = 0x348 // int32_t (Size: 0x4)
MFStatisticDataVisualizeActor.YCountCache = 0x34c // int32_t (Size: 0x4)
MFStatisticDataVisualizeActor.DataCache = 0x350 // TArray<float> (Size: 0x10)
MFStatisticDataVisualizeActor.DataCache_FourDir = 0x360 // TArray<FVector4> (Size: 0x10)
MFStatisticDataVisualizeActor.ColorLevelMaterial = 0x370 // TArray<MaterialInterface*> (Size: 0x10)
MFStatisticDataVisualizeActor.MarkerClass = 0x380 // ClassProperty (Size: 0x8)
MFStatisticDataVisualizeActor.NewLine = 0x388 // FString (Size: 0x10)
SceneObjInfo_Foliage.MeshResource = 0x28 // StaticMesh* (Size: 0x8)
SceneObjInfo_RenderObj.MeshResource = 0x28 // StaticMesh* (Size: 0x8)
SceneObjInfo_StaticMeshActor.MeshResource = 0x38 // StaticMesh* (Size: 0x8)
SceneObjInfo_StaticMeshActor.MainMat = 0x40 // MaterialInterface* (Size: 0x8)
DestructibleObjParam.DestructibleLevel = 0x0 // int32_t (Size: 0x4)
DestructibleObjParam.ChunkLife = 0x4 // float (Size: 0x4)
DestructibleObjParam.ChunkLife5 = 0x8 // float (Size: 0x4)
DestructibleObjParamBind.PhysicalMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
DestructibleObjParamBind.Param = 0x8 // FDestructibleObjParam (Size: 0xc)
GlassBreakParam.Pos = 0x0 // FVector (Size: 0xc)
GlassBreakParam.Dir = 0xc // FVector (Size: 0xc)
GlassBreakParam.Size = 0x18 // FVector (Size: 0xc)
GlassBreakParam.StaticMesh = 0x28 // Object* (Size: 0x8)
GlassBreakParam.TriStartIndex = 0x30 // int32_t (Size: 0x4)
GlassBreakParam.TriEndIndex = 0x34 // int32_t (Size: 0x4)
GlassBreakParam.VelocityDir = 0x38 // FVector (Size: 0xc)
GlassBreakParam.EffectType = 0x44 // int8_t (Size: 0x1)
GlassBreakParam.WeaponType = 0x45 // int8_t (Size: 0x1)
GlassBreakParam.PhysMat = 0x48 // PhysicalMaterial* (Size: 0x8)
MFDestructibleManagerCollectionSingleton.DestructibleObjParamMgr = 0x28 // ClassProperty (Size: 0x8)
MFDestructibleObjParamManager.MgrClassCache = 0x28 // ClassProperty (Size: 0x8)
MFDestructibleObjParamManager.DestructibleObjParamBindList = 0x30 // TArray<FDestructibleObjParamBind> (Size: 0x10)
MFDestructibleObjParamManager.DefaultParam = 0x40 // FDestructibleObjParam (Size: 0xc)
MFDestructionEffectPlayerComponent.GlassWindowParticles = 0xf8 // TArray<NiagaraSystem*> (Size: 0x10)
MFDestructionEffectPlayerComponent.GlassWindowParticles_SaaS = 0x108 // TArray<NiagaraSystem*> (Size: 0x10)
MFDestructionEffectPlayerComponent.SaaSNiagaraComponents = 0x118 // TArray<NiagaraComponent*> (Size: 0x10)
MFDestructionEffectPlayerComponent.BatchThresholdDistSquared = 0x128 // float (Size: 0x4)
MFDestructionEffectPlayerComponent.EffectSizeMultipler = 0x12c // float (Size: 0x4)
MFDestructionEffectPlayerComponent.WeaponTypeAudioMapping = 0x130 // TMap<...> (Size: 0x50)
MSingletonCollectionActor.DestructibleManagerCollectionSingleton = 0x310 // ClassProperty (Size: 0x8)
MSingletonCollectionActor.SingletonCache = 0x318 // MFDestructibleManagerCollectionSingleton* (Size: 0x8)
MFEnvActorInfoComponent.EnvSystem = 0xf8 // MFEnvSystem* (Size: 0x8)
MFEnvActorInfoComponent.SkinMeshArray = 0x100 // TArray<SkinnedMeshComponent*> (Size: 0x10)
MFEnvActorInfoComponent.PreviousPosition = 0x110 // FVector (Size: 0xc)
MFEnvActorInfoComponent.PreviousPositionTime = 0x11c // float (Size: 0x4)
MFEnvActorInfoComponent.EnvActorType = 0x120 // EEEnvActorType (Size: 0x1)
MFEnvActorInfoComponent.LatentFrames = 0x124 // int32_t (Size: 0x4)
MFEnvAutoExposureComponent.ComponentTag = 0x100 // FName (Size: 0x8)
MFEnvAutoExposureComponent.TakeEffect = 0x108 // bool (Size: 0x1)
MFEnvAutoExposureComponent.AEComp = 0x110 // StaticMeshComponent* (Size: 0x8)
MFEnvBlockInitInfo.BurnBounds = 0x0 // FMFEnvBurnBlockBound (Size: 0x10)
MFEnvBlockInitInfo.DamageScale = 0x10 // uint8_t (Size: 0x1)
MFEnvBlockInitInfo.TimeScale = 0x11 // uint8_t (Size: 0x1)
MFEnvBlockInitInfo.bNoEffects = 0x12 // bool (Size: 0x1)
MFEnvBurnBlockBound.CenterPos = 0x0 // FVector (Size: 0xc)
MFEnvBurnBlockBound.RotYaw = 0xc // int16_t (Size: 0x2)
MFEnvBurnBlockBound.Extent = 0xe // uint8_t (Size: 0x1)
MFEnvBurnComponent.BurnedBlocks = 0x100 // TArray<FMFEnvBurnBlockBound> (Size: 0x10)
MFEnvBurnComponent.FireComponents = 0x110 // TArray<MFEnvBurnFireComponent*> (Size: 0x10)
MFEnvBurnComponent.BurnMaskTex = 0x120 // Texture2D* (Size: 0x8)
MFEnvBurnComponent.AshesPSCArray = 0x128 // TArray<ParticleSystemComponent*> (Size: 0x10)
MFEnvBurnComponent.BurnFireBlockEvent = 0x138 // FMulticastInlineDelegate (Size: 0x10)
MFEnvBurnComponent.BurnTexSize = 0x14c // int32_t (Size: 0x4)
MFEnvBurnComponent.BurnAreaSize = 0x150 // int32_t (Size: 0x4)
MFEnvBurnComponent.BurnAreaCenter = 0x154 // FVector2D (Size: 0x8)
MFEnvBurnComponent.SpreadTimes = 0x15c // int32_t (Size: 0x4)
MFEnvBurnComponent.Extent = 0x160 // int32_t (Size: 0x4)
MFEnvBurnComponent.DitherScale = 0x164 // float (Size: 0x4)
MFEnvBurnComponent.BurnProbability = 0x168 // float (Size: 0x4)
MFEnvBurnComponent.BurnWeightProbabilityScale = 0x16c // float (Size: 0x4)
MFEnvBurnComponent.BurnWindDirWeightScale = 0x170 // float (Size: 0x4)
MFEnvBurnComponent.SpreadInv = 0x174 // float (Size: 0x4)
MFEnvBurnComponent.BurnTimePlantDown = 0x178 // float (Size: 0x4)
MFEnvBurnComponent.BurnTimePlantBufferRatio = 0x17c // float (Size: 0x4)
MFEnvBurnComponent.BurnTimeEffectOff = 0x180 // float (Size: 0x4)
MFEnvBurnComponent.FireDamagePerSec = 0x184 // float (Size: 0x4)
MFEnvBurnComponent.FireDamageDuration = 0x188 // float (Size: 0x4)
MFEnvBurnComponent.BurnDecalMaterial = 0x190 // MaterialInterface* (Size: 0x8)
MFEnvBurnComponent.DecalFadeInTime = 0x198 // float (Size: 0x4)
MFEnvBurnComponent.ContinuousFiringPS1 = 0x1a0 // ParticleSystem* (Size: 0x8)
MFEnvBurnComponent.ContinuousFiringPS2 = 0x1a8 // ParticleSystem* (Size: 0x8)
MFEnvBurnComponent.FiringPS1Probability = 0x1b0 // float (Size: 0x4)
MFEnvBurnComponent.AshesPSProbability = 0x1b4 // float (Size: 0x4)
MFEnvBurnComponent.TexBoxExpand = 0x1b8 // float (Size: 0x4)
MFEnvBurnComponent.AshesPS = 0x1c0 // ParticleSystem* (Size: 0x8)
MFEnvBurnFireBlockComponent.BlockInfo = 0x100 // FMFEnvBlockInitInfo (Size: 0x14)
MFEnvBurnFireBlockComponent.bRemovePlants = 0x125 // bool (Size: 0x1)
MFEnvBurnFireBlockComponent.bTurnOffEffect = 0x126 // bool (Size: 0x1)
MFEnvBurnFireBlockComponent.ContinuousFiringPSC = 0x128 // ParticleSystemComponent* (Size: 0x8)
MFEnvBurnFireBlockComponent.FireComponent = 0x130 // MFEnvBurnFireComponent* (Size: 0x8)
MFEnvBurnFireComponent.BurnComponent = 0x100 // MFEnvBurnComponent* (Size: 0x8)
MFEnvBurnFireComponent.FireBlocks = 0x108 // TArray<MFEnvBurnFireBlockComponent*> (Size: 0x10)
MFEnvMudComponent.MudRTMID = 0x128 // MaterialInstanceDynamic* (Size: 0x8)
MFEnvMudComponent.MudRTCopyMID = 0x130 // MaterialInstanceDynamic* (Size: 0x8)
MFEnvMudComponent.UpdateInv = 0x150 // float (Size: 0x4)
MFEnvMudComponent.SampleInv = 0x154 // float (Size: 0x4)
MFEnvMudComponent.MudDepth = 0x158 // float (Size: 0x4)
MFEnvMudComponent.MudRoll = 0x15c // float (Size: 0x4)
MFEnvMudComponent.MudBottom = 0x160 // float (Size: 0x4)
MFEnvMudComponent.MudBottomTime = 0x164 // float (Size: 0x4)
MFEnvMudComponent.MudRT = 0x168 // TextureRenderTarget2D* (Size: 0x8)
MFEnvMudComponent.MudRTCopy = 0x170 // TextureRenderTarget2D* (Size: 0x8)
MFEnvMudComponent.MudRTComposite = 0x178 // TextureRenderTarget2D* (Size: 0x8)
MFEnvMudComponent.MudRTBlur = 0x180 // TextureRenderTarget2D* (Size: 0x8)
MFEnvMudComponent.MudRTNormal = 0x188 // TextureRenderTarget2D* (Size: 0x8)
MFEnvPhysFoliageActor.HISMInc = 0x320 // HierarchicalInstancedStaticMeshComponent* (Size: 0x8)
MFEnvPhysFoliageActor.StaticMeshComponent = 0x338 // StaticMeshComponent* (Size: 0x8)
MFEnvPhysFoliageActor.SkeletalMeshComponent = 0x340 // SkeletalMeshComponent* (Size: 0x8)
MFEnvPhysFoliageComponent.FoliageReplaceInv = 0x100 // float (Size: 0x4)
MFEnvPhysFoliageComponent.FoliageReplaceRadius = 0x104 // float (Size: 0x4)
MFEnvPhysFoliageComponent.CollisionObjectType = 0x108 // uint8_t (Size: 0x1)
MFEnvPhysFoliageComponent.CollisionResponse = 0x109 // uint8_t (Size: 0x1)
MFEnvPhysFoliageComponent.EnvPhysFoliageActorTemplate = 0x110 // ClassProperty (Size: 0x8)
MFEnvPhysFoliageComponent.PhysFoliageMeshDT = 0x118 // DataTable* (Size: 0x8)
MFEnvPhysFoliageComponent.EnvPhysFoliageActorList = 0x138 // TArray<MFEnvPhysFoliageActor*> (Size: 0x10)
MFEnvPhysFoliageMeshRow.StaticMeshSoftPtr = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
MFEnvPhysFoliageMeshRow.MeshObjectPath = 0x30 // FSoftObjectPath (Size: 0x18)
MFEnvPhysFoliageMeshRow.MeshType = 0x48 // EEMFPhysFoliageMeshTypeEnum (Size: 0x1)
MFEnvSceneInfoCharacterComponent.WindSpeedDown = 0x108 // float (Size: 0x4)
MFEnvSceneInfoCharacterComponent.WindSpeedHorizontal = 0x10c // float (Size: 0x4)
MFEnvSceneInfoCharacterComponent.WindRotation = 0x110 // float (Size: 0x4)
MFEnvSceneInfoCharacterComponent.WindDirection = 0x114 // FVector2D (Size: 0x8)
MFEnvSceneInfoComponent.CaptureObjectData_RenderThread = 0x100 // TArray<SkinnedMeshComponent*> (Size: 0x10)
MFEnvSceneInfoComponent.ActorInfoArray = 0x160 // TArray<MFEnvActorInfoComponent*> (Size: 0x10)
MFEnvSceneInfoComponent.HeightMapCaptureComponent = 0x1a0 // SceneCaptureComponent2D* (Size: 0x8)
MFEnvSceneInfoComponent.RainDepthCaptureComponent = 0x1a8 // SceneCaptureComponent2D* (Size: 0x8)
MFEnvSceneInfoComponent.CaptureCharacterRT = 0x1b0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvSceneInfoComponent.CaptureHeightMapRT = 0x1b8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvSceneInfoComponent.CaptureRainDepthRT = 0x1c0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvSceneInfoComponent.CaptureHeightMat = 0x1c8 // MaterialInterface* (Size: 0x8)
MFEnvSceneInfoComponent.CaptureRainDepthMat = 0x1d0 // MaterialInterface* (Size: 0x8)
MFEnvSceneInfoComponent.IdleWaveInv = 0x1d8 // float (Size: 0x4)
MFEnvSceneInfoComponent.IdleWaveWindow = 0x1dc // float (Size: 0x4)
MFEnvSceneInfoComponent.CaptureExtent = 0x1e0 // float (Size: 0x4)
MFEnvSceneInfoComponent.CaptureCharacterRange = 0x1e4 // float (Size: 0x4)
MFEnvSceneInfoComponent.CaptureZOffsetMax = 0x1e8 // float (Size: 0x4)
MFEnvSceneInfoComponent.CaptureZOffsetMin = 0x1ec // float (Size: 0x4)
MFEnvSceneInfoComponent.CaptureHeightMapUpdateDistance = 0x1f0 // float (Size: 0x4)
MFEnvSceneInfoComponent.DebugUpdateEveryFrame = 0x1f4 // bool (Size: 0x1)
MFEnvSceneInfoComponent.enableShowOnlyRainBlockerMode = 0x1f5 // bool (Size: 0x1)
MFEnvSystem.BurnComponent = 0x310 // MFEnvBurnComponent* (Size: 0x8)
MFEnvSystem.HeightMapCaptureComponent = 0x320 // SceneCaptureComponent2D* (Size: 0x8)
MFEnvSystem.RainDepthCaptureComponent = 0x328 // SceneCaptureComponent2D* (Size: 0x8)
MFEnvSystem.SceneInfoComponent = 0x330 // MFEnvSceneInfoComponent* (Size: 0x8)
MFEnvSystem.WaterComponent = 0x338 // MFEnvWaterComponent* (Size: 0x8)
MFEnvSystem.TrailComponent = 0x340 // MFEnvTrailComponent* (Size: 0x8)
MFEnvSystem.WindComponent = 0x348 // MFEnvWindComponent* (Size: 0x8)
MFEnvSystem.MudComponent = 0x350 // MFEnvMudComponent* (Size: 0x8)
MFEnvSystem.PhysFoliageComponent = 0x358 // MFEnvPhysFoliageComponent* (Size: 0x8)
MFEnvSystem.AutoExposureComponent = 0x360 // MFEnvAutoExposureComponent* (Size: 0x8)
MFEnvSystem.DebugActorMID = 0x370 // MaterialInstanceDynamic* (Size: 0x8)
MFEnvSystem.CacheLocalPC = 0x378 // PlayerController* (Size: 0x8)
MFEnvSystem.EnvMPC = 0x390 // MaterialParameterCollection* (Size: 0x8)
MFEnvSystem.Debug_TryFindDebugActor = 0x398 // bool (Size: 0x1)
MFEnvSystem.Debug_UseAssetTexture = 0x399 // bool (Size: 0x1)
MFEnvSystem.Debug_IsMonsterHunterDemo = 0x39a // bool (Size: 0x1)
MFEnvSystem.Debug_ForRenderDocCapture = 0x39b // bool (Size: 0x1)
MFEnvTrailComponent.TrailRTMID = 0x100 // MaterialInstanceDynamic* (Size: 0x8)
MFEnvTrailComponent.TrailRTCopyMID = 0x108 // MaterialInstanceDynamic* (Size: 0x8)
MFEnvTrailComponent.Extent = 0x208 // float (Size: 0x4)
MFEnvTrailComponent.TrailPosExtent = 0x20c // float (Size: 0x4)
MFEnvTrailComponent.TrailOldScale = 0x210 // float (Size: 0x4)
MFEnvTrailComponent.ZHeight = 0x214 // float (Size: 0x4)
MFEnvTrailComponent.ZFootOffset = 0x218 // float (Size: 0x4)
MFEnvTrailComponent.Radius = 0x21c // float (Size: 0x4)
MFEnvTrailComponent.ReserveTime = 0x220 // float (Size: 0x4)
MFEnvTrailComponent.UpdateInv = 0x224 // float (Size: 0x4)
MFEnvTrailComponent.TrailRT = 0x228 // TextureRenderTarget2D* (Size: 0x8)
MFEnvTrailComponent.TrailRTCopy = 0x230 // TextureRenderTarget2D* (Size: 0x8)
MFEnvTrailComponent.TrailPosRT = 0x238 // TextureRenderTarget2D* (Size: 0x8)
MFEnvTrailComponent.TrailPosRTCopy = 0x240 // TextureRenderTarget2D* (Size: 0x8)
MFEnvTrailComponent.PlayerInfos_RenderThread = 0x250 // TArray<FVector4> (Size: 0x10)
MFEnvTrailPlayerInfo.PlayerPosition = 0x0 // FVector (Size: 0xc)
MFEnvTrailPlayerInfo.PlayerPositionLeft = 0xc // FVector (Size: 0xc)
MFEnvTrailPlayerInfo.PlayerPositionRight = 0x18 // FVector (Size: 0xc)
MFEnvTrailPlayerInfo.Direction = 0x24 // FVector2D (Size: 0x8)
MFEnvTrailPlayerInfo.Velocity = 0x2c // float (Size: 0x4)
MFEnvTrailPlayerInfo.Radius = 0x30 // float (Size: 0x4)
MFEnvTrailPlayerInfo.Shape = 0x34 // EEMFEnvTrailShapeEnum (Size: 0x1)
MFEnvWaterComponent.SimulateFrame = 0x104 // int32_t (Size: 0x4)
MFEnvWaterComponent.Extent = 0x108 // float (Size: 0x4)
MFEnvWaterComponent.WaterHeightRT0 = 0x110 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWaterComponent.WaterHeightRT1 = 0x118 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWaterComponent.WaterHeightRT2 = 0x120 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWaterComponent.WaterCompositeRT = 0x128 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.SwayTexUpdateInv = 0x130 // float (Size: 0x4)
MFEnvWindComponent.SwayTexUpdateDist = 0x134 // float (Size: 0x4)
MFEnvWindComponent.SwayTexExtent = 0x138 // float (Size: 0x4)
MFEnvWindComponent.SwayParamTex = 0x140 // Texture2D* (Size: 0x8)
MFEnvWindComponent.WindSwayRT = 0x148 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindSwayRTCopy = 0x150 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.Extent = 0x158 // float (Size: 0x4)
MFEnvWindComponent.IterCountDiffuse = 0x15c // int32_t (Size: 0x4)
MFEnvWindComponent.IterCountProjection = 0x160 // int32_t (Size: 0x4)
MFEnvWindComponent.ForceDirectMomentum = 0x164 // float (Size: 0x4)
MFEnvWindComponent.ForceDirectExponent = 0x168 // float (Size: 0x4)
MFEnvWindComponent.ForceExplodeMomentum = 0x16c // float (Size: 0x4)
MFEnvWindComponent.ForceExplodeExponent = 0x170 // float (Size: 0x4)
MFEnvWindComponent.ForceExplodeLastTime = 0x174 // float (Size: 0x4)
MFEnvWindComponent.WindDeltaTimeScale = 0x178 // float (Size: 0x4)
MFEnvWindComponent.WindViscosity = 0x17c // float (Size: 0x4)
MFEnvWindComponent.WindForce = 0x184 // float (Size: 0x4)
MFEnvWindComponent.WindDirection = 0x188 // FVector2D (Size: 0x8)
MFEnvWindComponent.WindMax = 0x190 // float (Size: 0x4)
MFEnvWindComponent.WindSpeedLarge = 0x194 // float (Size: 0x4)
MFEnvWindComponent.WindSpeedDetail = 0x198 // float (Size: 0x4)
MFEnvWindComponent.WindScaleLarge = 0x19c // float (Size: 0x4)
MFEnvWindComponent.WindScaleDetail = 0x1a0 // float (Size: 0x4)
MFEnvWindComponent.WindSequence = 0x1a8 // LevelSequence* (Size: 0x8)
MFEnvWindComponent.WindRTV1 = 0x1b0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTV2 = 0x1b8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTV3 = 0x1c0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTP1 = 0x1c8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTP2 = 0x1d0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTVelocity = 0x1d8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindSequencePlayer = 0x1e0 // LevelSequencePlayer* (Size: 0x8)
MFEnvWindComponent.WindRTV_Slot1_RenderThread = 0x1e8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTV_Slot2_RenderThread = 0x1f0 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTV_Slot3_RenderThread = 0x1f8 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTP_Slot1_RenderThread = 0x200 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTP_Slot2_RenderThread = 0x208 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTDebugSlot1_RenderThread = 0x210 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTDebugSlot2_RenderThread = 0x218 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTJacobi1_RenderThread = 0x220 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.WindRTJacobi2_RenderThread = 0x228 // TextureRenderTarget2D* (Size: 0x8)
MFEnvWindComponent.Jacobi_Alpha = 0x230 // float (Size: 0x4)
MFEnvWindComponent.Jacobi_Beta = 0x234 // float (Size: 0x4)
MFEnvWindDirectForceInfo.ForceVector = 0x0 // FVector2D (Size: 0x8)
MFEnvWindDirectForceInfo.ForceOrigin = 0x8 // FVector2D (Size: 0x8)
MFEnvWindDirectForceInfo.ForceMomentum = 0x10 // float (Size: 0x4)
MFEnvWindExplodeForceInfo.ForceOrigin = 0x0 // FVector2D (Size: 0x8)
MFEnvWindExplodeForceInfo.ForceMomentum = 0x8 // float (Size: 0x4)
MFEnvWindExplodeForceInfo.LastTime = 0xc // float (Size: 0x4)
MFEnvWindSwayInstInfo.InstPtr = 0x0 // HierarchicalInstancedStaticMeshComponent* (Size: 0x8)
MFEnvWindSwayInstInfo.InstId = 0x8 // int32_t (Size: 0x4)
MFEnvWindSwayInstInfo.Pos = 0xc // FVector2D (Size: 0x8)
MFEnvWindSwayInstInfo.Params = 0x20 // FVector4 (Size: 0x10)
MFMudDeformationActor.HeightMaskTexelSize = 0x324 // int32_t (Size: 0x4)
MFMudDeformationActor.ScanStepNum = 0x328 // int32_t (Size: 0x4)
MFMudDeformationActor.LastPos = 0x32c // FVector (Size: 0xc)
MFMudDeformationActor.HeightMaskTex = 0x340 // Texture2D* (Size: 0x8)
MFMudDeformationActor.HeightMaskData = 0x348 // TArray<uint8_t> (Size: 0x10)
MFMudDeformationActor.TexLatentCreateFrameIndexMax = 0x358 // int32_t (Size: 0x4)
FluidInteractionManager.ClipHeight = 0x318 // float (Size: 0x4)
FluidInteractionManager.InteractionStrength = 0x31c // float (Size: 0x4)
FluidInteractionManager.InteractionFadeInSpeed = 0x320 // float (Size: 0x4)
FluidInteractionManager.InteractionFadeOutSpeed = 0x324 // float (Size: 0x4)
FluidInteractionManager.WindFieldMaterialParameters = 0x328 // MaterialParameterCollection* (Size: 0x8)
FluidInteractionManager.HeightField = 0x330 // TextureRenderTarget2D* (Size: 0x8)
FluidInteractionManager.HeightFieldBackBuffer = 0x338 // TextureRenderTarget2D* (Size: 0x8)
FluidInteractionManager.HeightFieldPrevFrame = 0x340 // TextureRenderTarget2D* (Size: 0x8)
FluidInteractionManager.CopyHeightMaterial = 0x348 // MaterialInterface* (Size: 0x8)
FluidInteractionManager.FadeOutHeightMaterial = 0x350 // MaterialInterface* (Size: 0x8)
FluidInteractionManager.DrawBorderMaterial = 0x358 // MaterialInterface* (Size: 0x8)
FluidInteractionManager.VisualizeMeshMaterial = 0x360 // MaterialInterface* (Size: 0x8)
FluidInteractionManager.Interactors = 0x368 // TArray<FluidInteractorComponent*> (Size: 0x10)
FluidInteractionManager.CopyHeight_MID = 0x588 // MaterialInstanceDynamic* (Size: 0x8)
FluidInteractionManager.CopyHeightPrevFrame_MID = 0x590 // MaterialInstanceDynamic* (Size: 0x8)
FluidInteractionManager.FadeOutHeight_MID = 0x598 // MaterialInstanceDynamic* (Size: 0x8)
FluidInteractionManager.DrawBorder_MID = 0x5a0 // MaterialInstanceDynamic* (Size: 0x8)
FluidInteractionManager.DrawMeshHeight_MID = 0x5a8 // MaterialInstanceDynamic* (Size: 0x8)
FluidInteractorComponent.bInteracting = 0x238 // bool (Size: 0x1)
FluidInteractorComponent.InteractionStrength = 0x23c // float (Size: 0x4)
FluidInteractorComponent.InteractorGroup = 0x248 // FluidInteractorGroupComponent* (Size: 0x8)
FluidInteractorGroupComponent.bInteracting = 0x238 // bool (Size: 0x1)
FluidInteractorGroupComponent.InteractionStrength = 0x23c // float (Size: 0x4)
FluidInteractorGroupComponent.Scale = 0x240 // float (Size: 0x4)
FluidMeshInteractorComponent.Mesh = 0x250 // StaticMesh* (Size: 0x8)
FluidMeshInteractorComponent.CharacterMovement = 0x258 // CharacterMovementComponent* (Size: 0x8)
FluidMeshInteractorComponent.DrawHeightMaterial = 0x260 // MaterialInterface* (Size: 0x8)
FluidSimpleInteractorComponent.PawnRadius = 0x250 // float (Size: 0x4)
FluidSimpleInteractorComponent.DrawHeightMaterial = 0x258 // MaterialInterface* (Size: 0x8)
FluidSimpleInteractorComponent.DrawHeight_MID = 0x260 // MaterialInstanceDynamic* (Size: 0x8)
FluidSystemManager.OnCPUReadBack = 0x318 // FMulticastInlineDelegate (Size: 0x10)
FluidSystemManager.OnCPUReadBackSingle = 0x328 // FMulticastInlineDelegate (Size: 0x10)
FluidSystemManager.bEnableDebug = 0x338 // uint8_t (Size: 0x1)
FluidSystemManager.bUseFastRenderMethod = 0x33c // uint8_t (Size: 0x1)
FluidSystemManager.WindLevel = 0x340 // float (Size: 0x4)
FluidSystemManager.StaticWindDirection = 0x344 // FVector (Size: 0xc)
FluidSystemManager.WindSpeedUniformScale = 0x350 // float (Size: 0x4)
FluidSystemManager.WindNoiseStrength = 0x354 // float (Size: 0x4)
FluidSystemManager.PlayerWalkWindRadius = 0x358 // float (Size: 0x4)
FluidSystemManager.InteractionStrength = 0x35c // float (Size: 0x4)
FluidSystemManager.InteractionRegionSize = 0x360 // float (Size: 0x4)
FluidSystemManager.InteractionSwayFrequency = 0x364 // float (Size: 0x4)
FluidSystemManager.InteractionSwayStrength = 0x368 // float (Size: 0x4)
FluidSystemManager.InteractionNumPreallocatedMaterialInstances = 0x36c // int32_t (Size: 0x4)
FluidSystemManager.WindOccluderMesh = 0x370 // StaticMesh* (Size: 0x8)
FluidSystemManager.WindOccluderScale = 0x378 // FVector (Size: 0xc)
FluidSystemManager.WindOccluderFalloffScale = 0x384 // FVector2D (Size: 0x8)
FluidSystemManager.WindOccluderMaxFalloffDistance = 0x38c // float (Size: 0x4)
FluidSystemManager.WindOccluderMaxHeight = 0x390 // float (Size: 0x4)
FluidSystemManager.WindOccluderMaterial = 0x398 // Material* (Size: 0x8)
FluidSystemManager.WindOccluderHeightRVT = 0x3a0 // RuntimeVirtualTexture* (Size: 0x8)
FluidSystemManager.bRVTIncludeMeshBounds = 0x3a8 // bool (Size: 0x1)
FluidSystemManager.bRVTIncludeMeshHeights = 0x3a9 // bool (Size: 0x1)
FluidSystemManager.WindOccluderRVTScreenSizeScale = 0x3ac // FVector2D (Size: 0x8)
FluidSystemManager.OccluderHeightRVTVolume = 0x3b4 // TWeakObjectPtr<UObject> (Size: 0x8)
FluidSystemManager.WindOccluderActors = 0x3c0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
FluidSystemManager.SceneComponent = 0x3d0 // SceneComponent* (Size: 0x8)
FluidSystemManager.SpeedtreeWindFieldComponent = 0x3d8 // SpeedtreeWindFieldComponent* (Size: 0x8)
FluidSystemManager.DisturbWaterWhenPlayerStill = 0x3e0 // uint8_t (Size: 0x1)
FluidSystemManager.WaterForceSize = 0x3e4 // float (Size: 0x4)
FluidSystemManager.WaterForceStrength = 0x3e8 // float (Size: 0x4)
FluidSystemManager.WaterTravelSpeed = 0x3ec // float (Size: 0x4)
FluidSystemManager.WaterDampening = 0x3f0 // float (Size: 0x4)
FluidSystemManager.WaterCollisionThreshold = 0x3f4 // float (Size: 0x4)
FluidSystemManager.WaterForwardOffset = 0x3f8 // float (Size: 0x4)
FluidSystemManager.WaterBurstRadiusScale = 0x3fc // float (Size: 0x4)
FluidSystemManager.WindRippleDirection = 0x400 // FVector (Size: 0xc)
FluidSystemManager.WindRippleCenterDistance = 0x40c // float (Size: 0x4)
FluidSystemManager.WindRippleRadiusScale = 0x410 // float (Size: 0x4)
FluidSystemManager.WindRippleSpeed = 0x414 // float (Size: 0x4)
FluidSystemManager.WindRippleStrength = 0x418 // float (Size: 0x4)
FluidSystemManager.WindRippleNoiseSize = 0x41c // float (Size: 0x4)
FluidSystemManager.WindField_MPC = 0x460 // MaterialParameterCollection* (Size: 0x8)
FluidSystemManager.WindField_NPC = 0x468 // NiagaraParameterCollection* (Size: 0x8)
FluidSystemManager.WindFieldGlobal = 0x470 // TextureRenderTarget2D* (Size: 0x8)
FluidSystemManager.WindFieldGlobalPrev = 0x478 // TextureRenderTarget2D* (Size: 0x8)
FluidSystemManager.OffsetFromSimAreaMotion = 0x480 // float (Size: 0x4)
FluidSystemManager.VelocityOffset = 0x484 // FVector2D (Size: 0x8)
FluidSystemManager.WaterPlayerInteractionMat = 0x490 // MaterialInterface* (Size: 0x8)
FluidSystemManager.WaterBurstInteractionMat = 0x498 // MaterialInterface* (Size: 0x8)
FluidSystemManager.InputMaterials = 0x4a0 // TArray<Material*> (Size: 0x10)
FluidSystemManager.WaterBurstMaterials = 0x4b0 // TArray<MaterialInterface*> (Size: 0x10)
FluidSystemManager.WaterBurstMaterials_MID = 0x4c0 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
FluidSystemManager.WaterPlayerInteraction_MID = 0x4d0 // MaterialInstanceDynamic* (Size: 0x8)
FluidSystemManager.InputMaterialDynamicInstances = 0x4d8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
FluidSystemManager.InteractionManagers = 0x4e8 // TArray<FluidInteractionManager*> (Size: 0x10)
FluidSystemManager.Interactors = 0x4f8 // TArray<FluidInteractorComponent*> (Size: 0x10)
LandscapeGrassManageComponent.bPrintLandscapeInfoOnBeginPlay = 0xf8 // uint8_t (Size: 0x1)
LandscapeGrassManageComponent.bPrintLandscapeInfoOnTick = 0xf8 // uint8_t (Size: 0x1)
LandscapeGrassManageComponent.SavedLandscapeMaterials = 0x100 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
TickEditorActor.bTickInEditor = 0x310 // bool (Size: 0x1)
TickEditorActorComponent.bTickEditor = 0xf8 // bool (Size: 0x1)
VisualizeMeshComponent.bEnable = 0x5c8 // bool (Size: 0x1)
VisualizeMeshComponent.Mesh = 0x5d0 // StaticMesh* (Size: 0x8)
WaterFieldBaseComponent.HeightMaps = 0x108 // TArray<TextureRenderTarget2D*> (Size: 0x10)
WaterFieldBaseComponent.HeightMapIndex = 0x118 // int32_t (Size: 0x4)
WindFieldWorldSubsystem.WindField_DataAsset = 0x40 // DataAsset* (Size: 0x8)
WindFieldWorldSubsystem.WindLevel = 0x48 // int32_t (Size: 0x4)
WindFieldWorldSubsystem.WindField_MPC = 0x50 // MaterialParameterCollection* (Size: 0x8)
MFGlobalEventParameter.Tag = 0x8 // FName (Size: 0x8)
MFGlobalEventParameter.DevComment = 0x10 // FString (Size: 0x10)
MFGlobalEventParameter.PropertyType = 0x20 // FName (Size: 0x8)
MFGlobalEventParameterTag.TagName = 0x0 // FName (Size: 0x8)
MFGlobalEventParameterTagCategoryRemap.BaseCategory = 0x0 // FString (Size: 0x10)
MFGlobalEventParameterTagCategoryRemap.RemapCategories = 0x10 // TArray<FString> (Size: 0x10)
MFGlobalEventParameterTagContainer.MFGlobalEventParameterTags = 0x0 // TArray<FMFGlobalEventParameterTag> (Size: 0x10)
MFGlobalEventParameterTagContainer.ParentTags = 0x10 // TArray<FMFGlobalEventParameterTag> (Size: 0x10)
MFGlobalEventParameterTagRedirect.OldTagName = 0x0 // FName (Size: 0x8)
MFGlobalEventParameterTagRedirect.NewTagName = 0x8 // FName (Size: 0x8)
MFGlobalEventParameterTagSource.SourceName = 0x0 // FName (Size: 0x8)
MFGlobalEventParameterTagSource.SourceType = 0x8 // EEMFGlobalEventParameterTagSourceType (Size: 0x1)
MFGlobalEventParameterTagSource.SourceTagList = 0x10 // MFGlobalEventParameterTagsList* (Size: 0x8)
MFGlobalEventParameterTagSource.SourceRestrictedTagList = 0x18 // RestrictedMFGlobalEventParameterTagsList* (Size: 0x8)
MFGlobalEventParameterTagsDeveloperSettings.DeveloperConfigName = 0x38 // FString (Size: 0x10)
MFGlobalEventParameterTagsDeveloperSettings.FavoriteTagSource = 0x48 // FName (Size: 0x8)
MFGlobalEventParameterTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
MFGlobalEventParameterTagsList.MFGlobalEventParameterTagList = 0x38 // TArray<FMFGlobalEventParameter> (Size: 0x10)
MFGlobalEventParameterTagsManager.TagSources = 0xc0 // TArray<FMFGlobalEventParameterTagSource> (Size: 0x10)
MFGlobalEventParameterTagsManager.MFGlobalEventParameterTagTables = 0x1b0 // TArray<DataTable*> (Size: 0x10)
MFGlobalEventParameterTagsSettings.ImportTagsFromConfig = 0x48 // bool (Size: 0x1)
MFGlobalEventParameterTagsSettings.WarnOnInvalidTags = 0x49 // bool (Size: 0x1)
MFGlobalEventParameterTagsSettings.FastReplication = 0x4a // bool (Size: 0x1)
MFGlobalEventParameterTagsSettings.InvalidTagCharacters = 0x50 // FString (Size: 0x10)
MFGlobalEventParameterTagsSettings.CategoryRemapping = 0x60 // TArray<FMFGlobalEventParameterTagCategoryRemap> (Size: 0x10)
MFGlobalEventParameterTagsSettings.MFGlobalEventParameterTagTableList = 0x70 // TArray<FSoftObjectPath> (Size: 0x10)
MFGlobalEventParameterTagsSettings.MFGlobalEventParameterTagRedirects = 0x80 // TArray<FMFGlobalEventParameterTagRedirect> (Size: 0x10)
MFGlobalEventParameterTagsSettings.CommonlyReplicatedTags = 0x90 // TArray<FName> (Size: 0x10)
MFGlobalEventParameterTagsSettings.NumBitsForContainerSize = 0xa0 // int32_t (Size: 0x4)
MFGlobalEventParameterTagsSettings.NetIndexFirstBitSegment = 0xa4 // int32_t (Size: 0x4)
MFGlobalEventParameterTagsSettings.RestrictedConfigFiles = 0xa8 // TArray<FRestrictedMFGlobalEventParameterConfigInfo> (Size: 0x10)
RestrictedMFGlobalEventParameterConfigInfo.RestrictedConfigName = 0x0 // FString (Size: 0x10)
RestrictedMFGlobalEventParameterConfigInfo.Owners = 0x10 // TArray<FString> (Size: 0x10)
RestrictedMFGlobalEventParameterTagTableRow.bAllowNonRestrictedChildren = 0x28 // bool (Size: 0x1)
RestrictedMFGlobalEventParameterTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
RestrictedMFGlobalEventParameterTagsList.RestrictedMFGlobalEventParameterTagList = 0x38 // TArray<FRestrictedMFGlobalEventParameterTagTableRow> (Size: 0x10)
MFGlobalEvent.Tag = 0x8 // FName (Size: 0x8)
MFGlobalEvent.DevComment = 0x10 // FString (Size: 0x10)
MFGlobalEvent.Parameters = 0x20 // TArray<FMFGlobalEventParameter> (Size: 0x10)
MFGlobalEventTag.TagName = 0x0 // FName (Size: 0x8)
MFGlobalEventTagCategoryRemap.BaseCategory = 0x0 // FString (Size: 0x10)
MFGlobalEventTagCategoryRemap.RemapCategories = 0x10 // TArray<FString> (Size: 0x10)
MFGlobalEventTagContainer.MFGlobalEventTags = 0x0 // TArray<FMFGlobalEventTag> (Size: 0x10)
MFGlobalEventTagContainer.ParentTags = 0x10 // TArray<FMFGlobalEventTag> (Size: 0x10)
MFGlobalEventTagRedirect.OldTagName = 0x0 // FName (Size: 0x8)
MFGlobalEventTagRedirect.NewTagName = 0x8 // FName (Size: 0x8)
MFGlobalEventTagSource.SourceName = 0x0 // FName (Size: 0x8)
MFGlobalEventTagSource.SourceType = 0x8 // EEMFGlobalEventTagSourceType (Size: 0x1)
MFGlobalEventTagSource.SourceTagList = 0x10 // MFGlobalEventTagsList* (Size: 0x8)
MFGlobalEventTagSource.SourceRestrictedTagList = 0x18 // RestrictedMFGlobalEventTagsList* (Size: 0x8)
MFGlobalEventTagsDeveloperSettings.DeveloperConfigName = 0x38 // FString (Size: 0x10)
MFGlobalEventTagsDeveloperSettings.FavoriteTagSource = 0x48 // FName (Size: 0x8)
MFGlobalEventTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
MFGlobalEventTagsList.MFGlobalEventTagList = 0x38 // TArray<FMFGlobalEvent> (Size: 0x10)
MFGlobalEventTagsManager.TagSources = 0xc0 // TArray<FMFGlobalEventTagSource> (Size: 0x10)
MFGlobalEventTagsManager.MFGlobalEventTagTables = 0x1b0 // TArray<DataTable*> (Size: 0x10)
MFGlobalEventTagsSettings.ImportTagsFromConfig = 0x48 // bool (Size: 0x1)
MFGlobalEventTagsSettings.WarnOnInvalidTags = 0x49 // bool (Size: 0x1)
MFGlobalEventTagsSettings.FastReplication = 0x4a // bool (Size: 0x1)
MFGlobalEventTagsSettings.InvalidTagCharacters = 0x50 // FString (Size: 0x10)
MFGlobalEventTagsSettings.CategoryRemapping = 0x60 // TArray<FMFGlobalEventTagCategoryRemap> (Size: 0x10)
MFGlobalEventTagsSettings.MFGlobalEventTagTableList = 0x70 // TArray<FSoftObjectPath> (Size: 0x10)
MFGlobalEventTagsSettings.MFGlobalEventTagRedirects = 0x80 // TArray<FMFGlobalEventTagRedirect> (Size: 0x10)
MFGlobalEventTagsSettings.CommonlyReplicatedTags = 0x90 // TArray<FName> (Size: 0x10)
MFGlobalEventTagsSettings.NumBitsForContainerSize = 0xa0 // int32_t (Size: 0x4)
MFGlobalEventTagsSettings.NetIndexFirstBitSegment = 0xa4 // int32_t (Size: 0x4)
MFGlobalEventTagsSettings.RestrictedConfigFiles = 0xa8 // TArray<FRestrictedMFGlobalEventConfigInfo> (Size: 0x10)
RestrictedMFGlobalEventConfigInfo.RestrictedConfigName = 0x0 // FString (Size: 0x10)
RestrictedMFGlobalEventConfigInfo.Owners = 0x10 // TArray<FString> (Size: 0x10)
RestrictedMFGlobalEventTagTableRow.bAllowNonRestrictedChildren = 0x30 // bool (Size: 0x1)
RestrictedMFGlobalEventTagsList.ConfigFileName = 0x28 // FString (Size: 0x10)
RestrictedMFGlobalEventTagsList.RestrictedMFGlobalEventTagList = 0x38 // TArray<FRestrictedMFGlobalEventTagTableRow> (Size: 0x10)
AutoHISM.MinInstanceCount = 0x310 // int32_t (Size: 0x4)
AutoHISM.StaticMesheInstanceIndexPairs = 0x318 // TMap<...> (Size: 0x50)
AutoHISM.SMToHISMMap = 0x368 // TMap<...> (Size: 0x50)
AutoHISM.ForceVisibleStaticMeshes = 0x3b8 // TArray<StaticMesh*> (Size: 0x10)
AutoHISM.ForceInvisibleStaticMeshComponents = 0x3c8 // TArray<HierarchicalInstancedStaticMeshComponent*> (Size: 0x10)
CreatePlayModeLevelStreamingPolicyParam.PlayMode = 0x0 // FSelectPlayModeIdParam (Size: 0x20)
CreatePlayModeLevelStreamingPolicyParam.PolicyClass = 0x20 // ClassProperty (Size: 0x8)
LODViewDistanceVolume.SubActors = 0x368 // TArray<Actor*> (Size: 0x10)
LODViewDistanceVolume.LevelPathNames = 0x378 // TArray<FString> (Size: 0x10)
LODViewDistanceVolume.DrawDistanceMultiply = 0x388 // float (Size: 0x4)
LODViewDistanceVolume.DrawDistanceAdd = 0x38c // float (Size: 0x4)
MFFoliageBillboardInstanceInfo.SectionIndex = 0x0 // int32_t (Size: 0x4)
MFFoliageBillboardInstanceInfo.bVisibile = 0x4 // uint8_t (Size: 0x1)
MFFoliageBillboardProxy.MaterialInterface = 0x328 // MaterialInterface* (Size: 0x8)
MFFoliageBillboardProxy.LoadedLevels = 0x330 // TMap<...> (Size: 0x50)
MFFoliageBillboardProxy.TotalProcMeshSectionNums = 0x380 // int32_t (Size: 0x4)
MFFoliageBillboardProxy.FoliageBillboardComponent = 0x388 // MFFoliageBillboardMeshComponent* (Size: 0x8)
MFFoliageBillboardSection.StaticMesh = 0x0 // StaticMesh* (Size: 0x8)
MFFoliageBillboardSection.MaterialInterface = 0x8 // MaterialInterface* (Size: 0x8)
MFFoliageBillboardSection.PerInstanceTransform = 0x10 // TArray<FTransform> (Size: 0x10)
MFFoliageBillboardSection.PerInstanceCustomData = 0x20 // TArray<float> (Size: 0x10)
MFFoliageBillboardSectionProxy.BillboardMinHeightToMerge = 0x310 // float (Size: 0x4)
MFFoliageBillboardSectionProxy.BillboardSections = 0x318 // TArray<FMFFoliageBillboardSection> (Size: 0x10)
MFGeneralDynamicCombineProxy.MaterialInterfaces = 0x320 // TArray<MaterialInterface*> (Size: 0x10)
MFGeneralDynamicCombineProxy.MaxVertexNumsPerMesh = 0x330 // int32_t (Size: 0x4)
MFGeneralDynamicCombineProxy.DistanceToUseMaxLOD = 0x334 // int32_t (Size: 0x4)
MFGeneralDynamicCombineProxy.DistanceToHideMesh = 0x338 // int32_t (Size: 0x4)
MFGeneralDynamicCombineProxy.AddStaticMeshComponentGroups = 0x340 // TMap<...> (Size: 0x50)
MFGeneralDynamicCombineProxy.AddedMaterials = 0x390 // TMap<...> (Size: 0x50)
MFGeneralDynamicCombineProxy.CombinedMeshComponents = 0x3e0 // TArray<MFGeneralDynamicCombineMeshComponent*> (Size: 0x10)
MFGeneralDynamicCombineProxy.SectionIndexMap = 0x3f0 // TMap<...> (Size: 0x50)
MFInstancedStaticMeshActor.InstancedStaticMeshComponent = 0x310 // InstancedStaticMeshComponent* (Size: 0x8)
MFInstancedStaticMeshActor.RelatedStaticMeshComponents = 0x318 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFPlayModeLevelStreamingPolicy_FixedViewLocation.ViewLocation = 0x28 // FVector (Size: 0xc)
MFPlayModeLevelStreamingPolicy_FixedViewLocation.LevelStreamingDistance = 0x34 // int32_t (Size: 0x4)
MFStaticMeshComponentForCombine.Component = 0x0 // StaticMeshComponent* (Size: 0x8)
MFStaticMeshComponentForCombine.Material = 0x8 // MaterialInterface* (Size: 0x8)
MFStaticMeshComponentForCombine.HashCode = 0x10 // uint32_t (Size: 0x4)
MFStaticMeshComponentGroupForCombine.StaticMeshComponents = 0x0 // TArray<FMFStaticMeshComponentForCombine> (Size: 0x10)
MFWorldComposition.ClientLevelPathFilters = 0x90 // TArray<FString> (Size: 0x10)
MFWorldComposition.ClientLevelPathIgnores = 0xa0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ClientLevelPathIgnoresForStandardPackage = 0xb0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ClientLevelPathIgnoresForLowDevice = 0xc0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ClientLevelPathIgnoresForMediumDevice = 0xd0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ClientLevelPathConsider = 0xe0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ServerLevelPathFilters = 0xf0 // TArray<FString> (Size: 0x10)
MFWorldComposition.ServerLevelPathIgnores = 0x100 // TArray<FString> (Size: 0x10)
MFWorldComposition.ServerLevelPathConsider = 0x110 // TArray<FString> (Size: 0x10)
MFWorldComposition.bOverrideStreamingDistance = 0x120 // bool (Size: 0x1)
MFWorldComposition.StreamingDistance = 0x124 // float (Size: 0x4)
MFWorldComposition.StreamingDistanceScaleLowMemory = 0x128 // TMap<...> (Size: 0x50)
MFWorldComposition.PlayModeLevelStreamingPolicies = 0x178 // TMap<...> (Size: 0x50)
MFWorldComposition.DiscardTilesStreaming = 0x230 // TArray<LevelStreaming*> (Size: 0x10)
MFWorldComposition.VolumedLevelStreaming = 0x240 // TArray<LevelStreaming*> (Size: 0x10)
MFWorldComposition.LimitLoadLevel = 0x260 // bool (Size: 0x1)
MFWorldComposition.MaxAsynLoadNum = 0x264 // int32_t (Size: 0x4)
MFWorldComposition.CentreLevels = 0x270 // TSet<...> (Size: 0x50)
MFWorldComposition.PerFrameCount = 0x2c4 // int32_t (Size: 0x4)
MFWorldComposition.LevelLoadActors = 0x2f0 // TArray<WorldCompositionLevelLoadActor*> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathFilters = 0x310 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathIgnores = 0x320 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathIgnoresForStandardPackage = 0x330 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathIgnoresForLowDevice = 0x340 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathIgnoresForMediumDevice = 0x350 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ClientLevelPathConsider = 0x360 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ServerLevelPathFilters = 0x370 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ServerLevelPathIgnores = 0x380 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.ServerLevelPathConsider = 0x390 // TArray<FString> (Size: 0x10)
MFWorldCompositionActor.bUseLandscapeMeshProxy = 0x3a0 // bool (Size: 0x1)
MFWorldCompositionActor.MPC_LandscapeRegion = 0x3e0 // MaterialParameterCollection* (Size: 0x8)
MFWorldCompositionActor.bOverrideStreamingDistance = 0x3e8 // bool (Size: 0x1)
MFWorldCompositionActor.StreamingDistance = 0x3ec // float (Size: 0x4)
MFWorldCompositionActor.StreamingDistanceScaleLowMemory = 0x3f0 // TMap<...> (Size: 0x50)
MFWorldCompositionActor.PlayModeLevelStreamingPolicies = 0x440 // TMap<...> (Size: 0x50)
SelectPlayModeIdParam.bUsePlayModeId = 0x0 // bool (Size: 0x1)
SelectPlayModeIdParam.MainModeID = 0x4 // int32_t (Size: 0x4)
SelectPlayModeIdParam.SubModeID = 0x8 // int32_t (Size: 0x4)
SelectPlayModeIdParam.MapID = 0xc // int32_t (Size: 0x4)
SelectPlayModeIdParam.SpecialID = 0x10 // int32_t (Size: 0x4)
SelectPlayModeIdParam.Difficulty = 0x14 // int32_t (Size: 0x4)
SelectPlayModeIdParam.PlayModeId = 0x18 // int64_t (Size: 0x8)
WorldCompositionLevelLoadActor.LevelLoadType = 0x310 // EEMFLevelLoadType (Size: 0x1)
WorldCompositionLevelLoadActor.Distance = 0x314 // float (Size: 0x4)
WorldCompositionLevelLoadActor.bIgnoreViewTarget = 0x318 // bool (Size: 0x1)
WorldCompositionLevelLoadActor.BoxComponent = 0x320 // BoxComponent* (Size: 0x8)
MFHeightShadow.Component = 0x310 // MFHeightShadowComponent* (Size: 0x8)
MFHeightShadowComponent.HeightmapTexture = 0x238 // TArray<Texture2D*> (Size: 0x10)
MFHeightShadowComponent.bShowVisualizationBox = 0x248 // bool (Size: 0x1)
MFHeightShadowComponent.BoxComponent = 0x250 // BoxComponent* (Size: 0x8)
MFInputBaseComponent.Controller = 0x1f0 // PlayerController* (Size: 0x8)
MFInputBaseComponent.pGameInstanceSubsystem = 0x200 // MfInputControlGameInstanceSubsystem* (Size: 0x8)
MFInputBaseComponent.ComponentEventDelegate = 0x338 // FMulticastInlineDelegate (Size: 0x10)
MfInputControlActor.RecordEventDelegate = 0x310 // FMulticastInlineDelegate (Size: 0x10)
MfInputControlActor.RecordReplayHudWidgetClass = 0x320 // ClassProperty (Size: 0x8)
MfInputControlActor.SoftRecordReplayHudWidgetClassPath = 0x328 // FSoftClassPath (Size: 0x18)
MfInputControlActor.RecordReplayHudUserWidget = 0x340 // UserWidget* (Size: 0x8)
MfInputReplayComponent.WidgetClass = 0x530 // ClassProperty (Size: 0x8)
MfInputReplayComponent.SoftHudWidgetClassPath = 0x538 // FSoftClassPath (Size: 0x18)
MfInputReplayComponent.WidgetInstance = 0x550 // UserWidget* (Size: 0x8)
MfInputReplayComponent.TouchCanvasPanelSlot = 0x558 // CanvasPanelSlot* (Size: 0x8)
MfInputReplayComponent.TouchImage = 0x560 // Image* (Size: 0x8)
MftHttpTask.ScreenNotifyName = 0xa8 // FString (Size: 0x10)
MftHttpTask.LuaNotifyName = 0xb8 // FString (Size: 0x10)
MFLandscapeProxyMeshActor.MFLandscapeProxyMeshComponent = 0x310 // MFLandscapeProxyMeshComponent* (Size: 0x8)
MFLandscapeProxyMeshComponent.SkirtZPlus = 0x600 // float (Size: 0x4)
MFLandscapeProxyMeshComponent.SkirtLength = 0x604 // float (Size: 0x4)
MFLandscapeProxyMeshComponent.LightmassSettings = 0x608 // FLightmassPrimitiveSettings (Size: 0x18)
MFLandscapeProxyMeshComponent.LightmapResolutionX = 0x620 // int32_t (Size: 0x4)
MFLandscapeProxyMeshComponent.LightmapResolutionY = 0x624 // int32_t (Size: 0x4)
MFLandscapeProxyMeshComponent.ShadowMaskResolutionRatio = 0x628 // float (Size: 0x4)
MFLandscapeProxyMeshComponent.MinID = 0x62c // FIntPoint (Size: 0x8)
MFLandscapeProxyMeshComponent.MaxID = 0x634 // FIntPoint (Size: 0x8)
MFLandscapeProxyMeshComponent.SkirtZ = 0x63c // float (Size: 0x4)
MFLandscapeProxyMeshComponent.ProxyMeshBounds = 0x640 // FBox (Size: 0x1c)
MFLandscapeProxyMeshComponent.NumVerts = 0x65c // int32_t (Size: 0x4)
MFLandscapeProxyMeshComponent.NumTriangles = 0x660 // int32_t (Size: 0x4)
MFLandscapeProxyMeshComponent.MapBuildDataId = 0x664 // FGuid (Size: 0x10)
MFLandscapeProxyMeshConfigActor.LevelCountXToMerge = 0x310 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.LevelCountYToMerge = 0x314 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.ExportLOD = 0x318 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.ExportTextureSize = 0x31c // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.LevelCountX = 0x320 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.LevelCountY = 0x324 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.MinLevelX = 0x328 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.MinLevelY = 0x32c // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.LandscapeBounds = 0x330 // FBox (Size: 0x1c)
MFLandscapeProxyMeshConfigActor.Roughness = 0x34c // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.Specular = 0x350 // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.MergedCountX = 0x354 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.MergedCountY = 0x358 // uint32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.MinID = 0x35c // FIntPoint (Size: 0x8)
MFLandscapeProxyMeshConfigActor.MaxID = 0x364 // FIntPoint (Size: 0x8)
MFLandscapeProxyMeshConfigActor.SkirtZPlus = 0x36c // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.SkirtLength = 0x370 // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.WorldZOffset = 0x374 // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.TotalVertices = 0x378 // int32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.TotalTriangles = 0x37c // int32_t (Size: 0x4)
MFLandscapeProxyMeshConfigActor.LandscapeProxyMeshLayerName = 0x380 // FString (Size: 0x10)
MFLandscapeProxyMeshConfigActor.LandscapeLayerName = 0x390 // FString (Size: 0x10)
MFLandscapeProxyMeshConfigActor.StreamingDistance = 0x3a0 // float (Size: 0x4)
MFLandscapeProxyMeshConfigActor.TextureGroup = 0x3a4 // uint8_t (Size: 0x1)
MFLandscapeProxyMeshConfigActor.ParentMaterial = 0x3a8 // Material* (Size: 0x8)
MFLandscapeProxyMeshConfigActor.LightmapResolutionPerTile = 0x3b0 // int32_t (Size: 0x4)
MFGlobalEventMessage_MissionActivate.Instigator = 0x0 // Actor* (Size: 0x8)
MFGlobalEventMessage_MissionFailed.Instigator = 0x0 // Actor* (Size: 0x8)
MFGlobalEventMessage_MissionSuccess.Instigator = 0x0 // Actor* (Size: 0x8)
MFMission.Objective = 0x28 // MFMissionObjective* (Size: 0x8)
MFMissionAction.Objective = 0x38 // MFMissionObjective* (Size: 0x8)
MFMissionCondition.Objective = 0x38 // MFMissionObjective* (Size: 0x8)
MFMissionCondition.bEqualCondition = 0x40 // bool (Size: 0x1)
MFMissionDataComponent.MissionFlowInstanceDataMap = 0xf8 // TMap<...> (Size: 0x50)
MFMissionDataComponent.NodeInstanceDataMap = 0x148 // TMap<...> (Size: 0x50)
MFMissionDataComponent.MissionFlowReplicateDatas = 0x198 // TArray<FMFMissionFlowReplicateData> (Size: 0x10)
MFMissionDataComponent.MissionReplicateDatas = 0x1a8 // TArray<FMFMissionReplicateData> (Size: 0x10)
MFMissionDataComponent.VariableInstanceDataMap = 0x1b8 // TMap<...> (Size: 0x50)
MFMissionFlow.WorldPrivate = 0x30 // World* (Size: 0x8)
MFMissionFlow.StartNode = 0x38 // MFMissionFlowNode_Start* (Size: 0x8)
MFMissionFlow.EndNode = 0x40 // MFMissionFlowNode_End* (Size: 0x8)
MFMissionFlow.NodeList = 0x48 // TArray<MFMissionFlowNode*> (Size: 0x10)
MFMissionFlow.bCustomName = 0x58 // bool (Size: 0x1)
MFMissionFlow.MissionFlowName = 0x60 // FString (Size: 0x10)
MFMissionFlow.DataType = 0x70 // EEMissionDataType (Size: 0x1)
MFMissionFlow.LoopTimes = 0x74 // int32_t (Size: 0x4)
MFMissionFlow.bFailedLoopEnable = 0x78 // bool (Size: 0x1)
MFMissionFlow.VariableAsset = 0x80 // MFMissionFlowVariableData* (Size: 0x8)
MFMissionFlow.MissionTaskIDs = 0x88 // TArray<FMissionTaskID> (Size: 0x10)
MFMissionFlow.MissionDesc = 0x98 // FText (Size: 0x18)
MFMissionFlow.bTotalTimeMode = 0xb0 // bool (Size: 0x1)
MFMissionFlow.MissionTotalTime = 0xb4 // uint32_t (Size: 0x4)
MFMissionFlowComponent.InstigatorType = 0xf8 // EEMissionDataType (Size: 0x1)
MFMissionFlowComponent.MissionFlowMap = 0x100 // TMap<...> (Size: 0x50)
MFMissionFlowComponent.DataComponentMap = 0x150 // TMap<...> (Size: 0x50)
MFMissionFlowComponent.AccessibleComponents = 0x1a0 // TMap<...> (Size: 0x50)
MFMissionFlowComponent.MissionFlowExecutingNodes = 0x1f0 // TMap<...> (Size: 0x50)
MFMissionFlowExecutingNodeConfig.bExecutingFlow = 0x0 // bool (Size: 0x1)
MFMissionFlowExecutingNodeConfig.NodeList = 0x8 // TArray<MFMissionFlowNode*> (Size: 0x10)
MFMissionFlowInstanceData.Instigator = 0x0 // Actor* (Size: 0x8)
MFMissionFlowInstanceData.MissionFlow = 0x8 // MFMissionFlow* (Size: 0x8)
MFMissionFlowInstanceData.MissionFlowStatus = 0x10 // EEMissionStatus (Size: 0x1)
MFMissionFlowInstanceData.bBeforeState = 0x11 // bool (Size: 0x1)
MFMissionFlowInstanceData.LastTriggerCharacter = 0x18 // Character* (Size: 0x8)
MFMissionFlowInstanceData.LoopCount = 0x20 // int32_t (Size: 0x4)
MFMissionFlowInstanceData.bLoopExit = 0x24 // bool (Size: 0x1)
MFMissionFlowNode.MissionFlowAsset = 0x28 // MFMissionFlow* (Size: 0x8)
MFMissionFlowNode.ParentNode = 0x30 // TWeakObjectPtr<UObject> (Size: 0x8)
MFMissionFlowNode.PrevConnections = 0x38 // TArray<FMissionFlowPrevConnection> (Size: 0x10)
MFMissionFlowNode.NextConnectionsMap = 0x48 // TMap<...> (Size: 0x50)
MFMissionFlowNode.bCustomName = 0x98 // bool (Size: 0x1)
MFMissionFlowNode.MissionName = 0xa0 // FString (Size: 0x10)
MFMissionFlowNode.Objective = 0xb0 // MFMissionObjective* (Size: 0x8)
MFMissionFlowNode.NodeType = 0xb8 // EEMissionFlowNodeType (Size: 0x1)
MFMissionFlowNode.NodeName = 0xc0 // FString (Size: 0x10)
MFMissionFlowNodeInstanceData.Instigator = 0x0 // Actor* (Size: 0x8)
MFMissionFlowNodeInstanceData.MissionFlowNode = 0x8 // MFMissionFlowNode* (Size: 0x8)
MFMissionFlowNodeInstanceData.NodeStatus = 0x10 // EEMissionFlowNodeStatus (Size: 0x1)
MFMissionFlowNodeInstanceData.Objective = 0x18 // MFMissionObjective* (Size: 0x8)
MFMissionFlowNodeInstanceData.MissionStatus = 0x20 // EEMissionStatus (Size: 0x1)
MFMissionFlowNodeInstanceData.InitialProgress = 0x24 // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.OldProgress = 0x28 // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.CurProgress = 0x2c // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.BeginProgress = 0x30 // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.EndProgress = 0x34 // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.CachedProgress = 0x38 // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.OneBattleAddedProgress = 0x3c // int32_t (Size: 0x4)
MFMissionFlowNodeInstanceData.ActivationTime = 0x40 // float (Size: 0x4)
MFMissionFlowNodeInstanceData.FinishTime = 0x44 // float (Size: 0x4)
MFMissionFlowNodeInstanceData.RemainTime = 0x48 // float (Size: 0x4)
MFMissionFlowNodeInstanceData.RemainTimeUpdateServerTime = 0x4c // float (Size: 0x4)
MFMissionFlowNodeInstanceData.bHasTryInteract = 0x50 // bool (Size: 0x1)
MFMissionFlowNodeInstanceData.FailedType = 0x51 // EEMissionFailedType (Size: 0x1)
MFMissionFlowNode_Assemble.AffiliateNodeList = 0xd8 // TArray<MFMissionFlowNode_Affiliate*> (Size: 0x10)
MFMissionFlowNode_IntVariable.Value = 0x138 // int64_t (Size: 0x8)
MFMissionFlowNode_MissionFlow.OwnMissionFlow = 0xd8 // MFMissionFlow* (Size: 0x8)
MFMissionFlowNode_MultipleGates.bOnlySuccessedCanOpenGate = 0xd8 // bool (Size: 0x1)
MFMissionFlowNode_MultipleGates.SuccessedNumToOpen = 0xdc // int32_t (Size: 0x4)
MFMissionFlowNode_ObjectVariable.Value = 0x138 // Object* (Size: 0x8)
MFMissionFlowNode_Random.NextConnectionWeights = 0xd8 // TArray<FMissionFlowConnectionWeight> (Size: 0x10)
MFMissionFlowNode_Random.RandomTimes = 0xe8 // uint8_t (Size: 0x1)
MFMissionFlowNode_Random.MaxRandomTimes = 0xe9 // uint8_t (Size: 0x1)
MFMissionFlowNode_RotatorVariable.Value = 0x138 // FRotator (Size: 0xc)
MFMissionFlowNode_StringVariable.Value = 0x138 // FString (Size: 0x10)
MFMissionFlowNode_Variable.VariableReference = 0xd8 // FMemberReference (Size: 0x38)
MFMissionFlowNode_Variable.VariableKey = 0x110 // FMFMissionFlowVariableKeySelector (Size: 0x28)
MFMissionFlowNode_VectorVariable.Value = 0x138 // FVector (Size: 0xc)
MFMissionFlowReplicateData.Instigator = 0x0 // Actor* (Size: 0x8)
MFMissionFlowReplicateData.MissionFlowName = 0x8 // FString (Size: 0x10)
MFMissionFlowReplicateData.MissionFlowStatus = 0x18 // EEMissionStatus (Size: 0x1)
MFMissionFlowReplicateData.OldMissionFlowStatus = 0x19 // EEMissionStatus (Size: 0x1)
MFMissionFlowReplicateData.bBeforeState = 0x1a // bool (Size: 0x1)
MFMissionFlowReplicateData.StatusChangeTime = 0x1c // float (Size: 0x4)
MFMissionFlowVariableData.Parent = 0x30 // MFMissionFlowVariableData* (Size: 0x8)
MFMissionFlowVariableData.Keys = 0x38 // TArray<FMFMissionFlowVariableEntry> (Size: 0x10)
MFMissionFlowVariableData.bHasSynchronizedKeys = 0x48 // uint8_t (Size: 0x1)
MFMissionFlowVariableEntry.EntryName = 0x0 // FName (Size: 0x8)
MFMissionFlowVariableEntry.KeyType = 0x8 // MFMissionFlowVariableKeyType* (Size: 0x8)
MFMissionFlowVariableEntry.bInstanceSynced = 0x10 // uint8_t (Size: 0x1)
MFMissionFlowVariableEntry.Category = 0x14 // FName (Size: 0x8)
MFMissionFlowVariableInstanceData.DataComp = 0x0 // MFMissionDataComponent* (Size: 0x8)
MFMissionFlowVariableInstanceData.MissionFlow = 0x8 // MFMissionFlow* (Size: 0x8)
MFMissionFlowVariableInstanceData.VariableAsset = 0x10 // MFMissionFlowVariableData* (Size: 0x8)
MFMissionFlowVariableInstanceData.KeyInstances = 0x38 // TArray<MFMissionFlowVariableKeyType*> (Size: 0x10)
MFMissionFlowVariableKeySelector.AllowedTypes = 0x0 // TArray<MFMissionFlowVariableKeyType*> (Size: 0x10)
MFMissionFlowVariableKeySelector.SelectedKeyName = 0x10 // FName (Size: 0x8)
MFMissionFlowVariableKeySelector.SelectedKeyType = 0x18 // ClassProperty (Size: 0x8)
MFMissionFlowVariableKeySelector.SelectedKeyID = 0x20 // uint8_t (Size: 0x1)
MFMissionFlowVariableKeySelector.bNoneIsAllowedValue = 0x21 // bool (Size: 0x1)
MFMissionFlowVariableKeyType_Int.DefaultValue = 0x30 // int32_t (Size: 0x4)
MFMissionFlowVariableKeyType_Object.BaseClass = 0x30 // ClassProperty (Size: 0x8)
MFMissionFlowVariableKeyType_Object.DefaultValue = 0x38 // Object* (Size: 0x8)
MFMissionFlowVariableKeyType_String.DefaultValue = 0x30 // FString (Size: 0x10)
MFMissionFlowVariableKeyType_String.StringValue = 0x40 // FString (Size: 0x10)
MFMissionFlowVariableKeyType_StringArray.DefaultValue = 0x30 // TArray<FString> (Size: 0x10)
MFMissionFlowVariableKeyType_StringArray.StringValues = 0x40 // TArray<FString> (Size: 0x10)
MFMissionNode.MissionFlowNode = 0x28 // MFMissionFlowNode* (Size: 0x8)
MFMissionNode.InstigatorTag = 0x30 // FMFGlobalEventParameterTag (Size: 0x8)
MFMissionObjective.InstigatorType = 0x38 // EEMissionDataType (Size: 0x1)
MFMissionObjective.CheckConditions = 0x40 // FMissionObjectiveCheckConditions (Size: 0x60)
MFMissionObjective.PreConditions = 0xa0 // FMissionObjectivePreConditions (Size: 0x28)
MFMissionObjective.InstigatorStatus = 0xc8 // TMap<...> (Size: 0x50)
MFMissionReplicateData.Instigator = 0x0 // Actor* (Size: 0x8)
MFMissionReplicateData.MissionName = 0x8 // FString (Size: 0x10)
MFMissionReplicateData.MissionFlowName = 0x18 // FString (Size: 0x10)
MFMissionReplicateData.MissionStatus = 0x28 // EEMissionStatus (Size: 0x1)
MFMissionReplicateData.OldMissionStatus = 0x29 // EEMissionStatus (Size: 0x1)
MFMissionReplicateData.OldProgress = 0x2c // int32_t (Size: 0x4)
MFMissionReplicateData.CurProgress = 0x30 // int32_t (Size: 0x4)
MFMissionReplicateData.RemainTime = 0x34 // float (Size: 0x4)
MFMissionReplicateData.RemainTimeUpdateServerTime = 0x38 // float (Size: 0x4)
MFMissionReplicateData.bFailWhenAchieved = 0x3c // bool (Size: 0x1)
MFMissionReplicateData.bNeedReport = 0x3d // bool (Size: 0x1)
MFMissionReplicateData.bNeedReportProgress = 0x3e // bool (Size: 0x1)
MFMissionReplicateData.AffiliateMissionList = 0x40 // TArray<FString> (Size: 0x10)
MFMissionReplicateData.bValid = 0x50 // bool (Size: 0x1)
MFMissionSubsystem.MissionFlowObjectMap = 0x38 // TMap<...> (Size: 0x50)
MFMissionVariableReadBase.Key = 0x0 // FMFMissionFlowVariableKeySelector (Size: 0x28)
MFMissionVariableRead_Int.ConfigValue = 0x28 // int32_t (Size: 0x4)
MFMissionVariableRead_Object.ConfigValue = 0x28 // Object* (Size: 0x8)
MFMissionVariableRead_Rotator.ConfigValue = 0x28 // FRotator (Size: 0xc)
MFMissionVariableRead_String.ConfigValue = 0x28 // FString (Size: 0x10)
MFMissionVariableRead_StringArray.ConfigValue = 0x28 // TArray<FString> (Size: 0x10)
MFMissionVariableRead_Vector.ConfigValue = 0x28 // FVector (Size: 0xc)
MFMissionVariableWriteBase.Key = 0x28 // FMFMissionFlowVariableKeySelector (Size: 0x28)
MFMissionVariableWrite_Int.Value = 0x50 // int32_t (Size: 0x4)
MFMissionVariableWrite_Object.Value = 0x50 // Object* (Size: 0x8)
MFMissionVariableWrite_Rotator.Value = 0x50 // FRotator (Size: 0xc)
MFMissionVariableWrite_String.Value = 0x50 // FString (Size: 0x10)
MFMissionVariableWrite_Vector.Value = 0x50 // FVector (Size: 0xc)
MissionFlowConnection.ConnectNode = 0x0 // MFMissionFlowNode* (Size: 0x8)
MissionFlowConnectionWeight.Index = 0x0 // uint8_t (Size: 0x1)
MissionFlowConnectionWeight.Weight = 0x4 // int32_t (Size: 0x4)
MissionFlowConnections.Connections = 0x0 // TArray<FMissionFlowConnection> (Size: 0x10)
MissionFlowData.MissionFlowName = 0x0 // FString (Size: 0x10)
MissionFlowData.MissionDesc = 0x10 // FText (Size: 0x18)
MissionFlowData.MissionTaskIDs = 0x28 // TArray<FMissionTaskID> (Size: 0x10)
MissionFlowPrevConnection.PrevConnectionType = 0x8 // EEMissionFlowConnectionType (Size: 0x1)
MissionInstigatorInfo.Instigators = 0x0 // TArray<Object*> (Size: 0x10)
MissionObjectiveCheckConditions.HelpType = 0x0 // EEMissionHelpType (Size: 0x1)
MissionObjectiveCheckConditions.CompareType = 0x1 // EEMissionCompareType (Size: 0x1)
MissionObjectiveCheckConditions.BeginProgress = 0x4 // int32_t (Size: 0x4)
MissionObjectiveCheckConditions.EndProgress = 0x8 // int32_t (Size: 0x4)
MissionObjectiveCheckConditions.ProgressUnit = 0xc // int32_t (Size: 0x4)
MissionObjectiveCheckConditions.ProgressFactor = 0x10 // int32_t (Size: 0x4)
MissionObjectiveCheckConditions.bNeedReportProgress = 0x14 // bool (Size: 0x1)
MissionObjectiveCheckConditions.bNeedReport = 0x15 // bool (Size: 0x1)
MissionObjectiveCheckConditions.bReachEndNotComplete = 0x16 // bool (Size: 0x1)
MissionObjectiveCheckConditions.bActivateReachEndComplete = 0x17 // bool (Size: 0x1)
MissionObjectiveCheckConditions.OneBattleMaxAddProgress = 0x18 // int32_t (Size: 0x4)
MissionObjectiveCheckConditions.bFailWhenAchieved = 0x1c // bool (Size: 0x1)
MissionObjectiveCheckConditions.CheckType = 0x1d // EEMissionObjectiveConditionCheckType (Size: 0x1)
MissionObjectiveCheckConditions.ConditionContainers = 0x20 // TArray<FMissionObjectiveConditionContainer> (Size: 0x10)
MissionObjectiveCheckConditions.ProgressActions = 0x30 // TArray<MFMissionAction*> (Size: 0x10)
MissionObjectiveCheckConditions.SuccessActions = 0x40 // TArray<MFMissionAction*> (Size: 0x10)
MissionObjectiveCheckConditions.FailedActions = 0x50 // TArray<MFMissionAction*> (Size: 0x10)
MissionObjectiveConditionContainer.CheckType = 0x0 // EEMissionObjectiveConditionCheckType (Size: 0x1)
MissionObjectiveConditionContainer.Conditions = 0x8 // TArray<MFMissionCondition*> (Size: 0x10)
MissionObjectivePreConditions.CheckType = 0x0 // EEMissionObjectiveConditionCheckType (Size: 0x1)
MissionObjectivePreConditions.ConditionContainers = 0x8 // TArray<FMissionObjectiveConditionContainer> (Size: 0x10)
MissionObjectivePreConditions.ActivateActions = 0x18 // TArray<MFMissionAction*> (Size: 0x10)
MissionTaskID.PlayID = 0x0 // int32_t (Size: 0x4)
MissionTaskID.MissionTaskID = 0x4 // int32_t (Size: 0x4)
MFMobileCircleUserWidget.WidgetPointIndex = 0x290 // int32_t (Size: 0x4)
MFMobileCircleUserWidget.bOpenTouchTick = 0x294 // bool (Size: 0x1)
MFMobileCircleUserWidget.OnTouchStart = 0x298 // FMulticastInlineDelegate (Size: 0x10)
MFMobileCircleUserWidget.OnTouchEnd = 0x2a8 // FMulticastInlineDelegate (Size: 0x10)
MFMobileCircleUserWidget.OnTouchOutCircle = 0x2b8 // FMulticastInlineDelegate (Size: 0x10)
MFMobileCircleUserWidget.OnOutOfButtonTouchEnded = 0x2c8 // FMulticastInlineDelegate (Size: 0x10)
MFMobileCircleUserWidget.AcceptInputType = 0x2d8 // EEButtonAcceptInputType (Size: 0x1)
MFMobileCircleUserWidget.CurrentAcceptInputType = 0x2d9 // EEButtonAcceptInputType (Size: 0x1)
MFMobileCircleUserWidget_Fire.PostStartFireByTouch = 0x2e0 // FMulticastInlineDelegate (Size: 0x10)
MFMobileCircleUserWidget_Fire.bIsLeftFireBtn = 0x2f0 // bool (Size: 0x1)
MFMobileCircleUserWidget_Fire.CachedPlayerController = 0x300 // SGPlayerController* (Size: 0x8)
MFMobileCircleUserWidget_Fire.CachedCharacter = 0x308 // SGCharacter* (Size: 0x8)
MFMobileCustomShapeButton.AdvancedHitTexture = 0x498 // Texture2D* (Size: 0x8)
MFMobileCustomShapeButton.AdvancedHitAlpha = 0x4a0 // int32_t (Size: 0x4)
MFMobileDragDropUserWidget.OnDropEvent = 0x2f0 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnDragDetectedEvent = 0x300 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnDragOverEvent = 0x310 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnDragEnterEvent = 0x320 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnDragLeaveEvent = 0x330 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnDragCancelledEvent = 0x340 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnTouchStartedEvent = 0x350 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.OnTouchEndedEvent = 0x360 // FMulticastInlineDelegate (Size: 0x10)
MFMobileDragDropUserWidget.bDropable = 0x370 // bool (Size: 0x1)
MFMobileGameHandle.MovementButton = 0x50 // MFMobileInputButton* (Size: 0x8)
MFMobileGameHandle.RotationButton = 0x58 // MFMobileInputButton* (Size: 0x8)
MFMobileGameHandle.MoveHandleImpl = 0x60 // MFMobileMoveHandleImpl* (Size: 0x8)
MFMobileGameHandle.CachedPlayerInput = 0x198 // MFMobilePlayerInput* (Size: 0x8)
MFMobileGamePad.CachedPlayerInput = 0x30 // MFMobilePlayerInput* (Size: 0x8)
MFMobileGamePad.VisibleViewCache = 0x38 // TArray<MFMobileGamePadView*> (Size: 0x10)
MFMobileGamePad.MobileGamePadViewClasses = 0x48 // TArray<ClassProperty> (Size: 0x10)
MFMobileGamePad.MobileGamePadViewZorder = 0x58 // int32_t (Size: 0x4)
MFMobileGamePad.MobileGamePadViews = 0x60 // TArray<MFMobileGamePadView*> (Size: 0x10)
MFMobileGamePadView.GamePadId = 0x2f0 // int32_t (Size: 0x4)
MFMobileGamePadView.CachedGamePad = 0x2f8 // MFMobileGamePad* (Size: 0x8)
MFMobileGamePadView.DraggableBtns = 0x300 // TArray<MFMobileDraggableButton*> (Size: 0x10)
MFMobileMoveJoystickHandleImpl.OuterGameHandle = 0x40 // MFMobileGameHandle* (Size: 0x8)
MFMobileMutilSlider.SliderBarNum = 0x550 // int32_t (Size: 0x4)
MFMobileMutilSlider.bCanCross = 0x554 // bool (Size: 0x1)
MFMobilePlayerInput.NormalSensitivityX = 0x688 // float (Size: 0x4)
MFMobilePlayerInput.NormalSensitivityY = 0x68c // float (Size: 0x4)
MFMobilePlayerInput.SwimmingSensitivityX = 0x690 // float (Size: 0x4)
MFMobilePlayerInput.SwimmingSensitivityY = 0x694 // float (Size: 0x4)
MFMobilePlayerInput.DrivingSensitivityX = 0x698 // float (Size: 0x4)
MFMobilePlayerInput.DrivingSensitivityY = 0x69c // float (Size: 0x4)
MFMobilePlayerInput.bDisableMoveAndRotate = 0x6a0 // bool (Size: 0x1)
MFMobilePlayerInput.FingerIndexDisableMoveAndRotateMap = 0x6a8 // TMap<...> (Size: 0x50)
MFMobilePlayerInput.FingerIndexFullScreenRotateSet = 0x6f8 // TSet<...> (Size: 0x50)
MFMobilePlayerInput.FingerIndexIgnoreMap = 0x748 // TMap<...> (Size: 0x50)
MFMobilePlayerInput.FixedSensitivityFactor = 0x79c // float (Size: 0x4)
MFMobilePlayerInput.DisAccSensitivityFactor = 0x7a0 // float (Size: 0x4)
MFMobilePlayerInput.DisFixedInputSensitivityFactor = 0x7a4 // float (Size: 0x4)
MFMobilePlayerInput.MaxAccumulateAxis = 0x7a8 // float (Size: 0x4)
MFMobilePlayerInput.SpeedAccSensitivityFactor = 0x7ac // float (Size: 0x4)
MFMobilePlayerInput.SpeedAccFixedInputSensitivityFactor = 0x7b0 // float (Size: 0x4)
MFMobilePlayerInput.NewSpeedAccSensitivityFactor = 0x7b4 // float (Size: 0x4)
MFMobilePlayerInput.NewSpeedAccFixedInputSensitivityFactor = 0x7b8 // float (Size: 0x4)
MFMobilePlayerInput.UseSensitivityMode = 0x7bc // EERotateSensitivityMode (Size: 0x1)
MFMobilePlayerInput.EmulatorScale = 0x7c0 // float (Size: 0x4)
MFMobilePlayerInput.bCullingYRotaion = 0x7c5 // bool (Size: 0x1)
MFMobilePlayerInput.DefaultFixedSensitivityValue = 0x7d0 // float (Size: 0x4)
MFMobilePlayerInput.DefaultDisAccSensitivityValue = 0x7d8 // float (Size: 0x4)
MFMobilePlayerInput.DefaultSpeedAccSensitivityValue = 0x7e0 // float (Size: 0x4)
MFMobilePlayerInput.GameHandle = 0x7e8 // MFMobileGameHandle* (Size: 0x8)
MFMobilePlayerInput.GamePadClassSoft = 0x7f0 // ClassProperty (Size: 0x8)
MFMobilePlayerInput.Gamepad = 0x7f8 // MFMobileGamePad* (Size: 0x8)
MFMobilePlayerInput.CurrentInputModeNum = 0x814 // int32_t (Size: 0x4)
MFMobilePlayerInput.MobileInputDataList = 0x818 // TArray<FMobileInputData> (Size: 0x10)
MFMobilePlayerInput.TempMobileInputDataList = 0x828 // TArray<FMobileInputData> (Size: 0x10)
MFMobilePlayerInput.AcceptOP = 0x83c // EEAcceptOP (Size: 0x1)
MFMobilePlayerInput.DeltaMoveSpeedScaleCurve = 0x840 // CurveFloat* (Size: 0x8)
MFMobilePlayerInput.BlendOP = 0x848 // EEBlendOP (Size: 0x1)
MFMobilePlayerInput.DeltaMoveBlendFactor = 0x84c // float (Size: 0x4)
MFMobilePlayerInput.InterpSpeed = 0x850 // float (Size: 0x4)
MFMobilePlayerInput.DeltaMoveBlendFactorCurve = 0x858 // CurveFloat* (Size: 0x8)
MFMobilePlayerInput.MagicMin_X1 = 0x860 // float (Size: 0x4)
MFMobilePlayerInput.MagicMin_X2 = 0x864 // float (Size: 0x4)
MFMobilePlayerInput.MagicMax_X1 = 0x868 // float (Size: 0x4)
MFMobilePlayerInput.MagicMax_X2 = 0x86c // float (Size: 0x4)
MFMobilePlayerInput.MagicMax_X3 = 0x870 // float (Size: 0x4)
MFPCPlayerInput.Gamepad = 0x688 // MFMobileGamePad* (Size: 0x8)
MFPCPlayerInput.GamePadClassSoft = 0x690 // TSoftClassPtr<UObject> (Size: 0x28)
AIArmorAttributeModifier.DurabilityConsumeScale_Blocked = 0x0 // float (Size: 0x4)
AIArmorAttributeModifier.DurabilityConsumeScale_Penetrated = 0x4 // float (Size: 0x4)
AIArmorAttributeModifier.AntiPenetrationFactor = 0x8 // float (Size: 0x4)
AIArmorAttributeModifier.DamageScaleForPenetration = 0xc // float (Size: 0x4)
AIArmorAttributeModifier.DamageScaleForBlock = 0x10 // float (Size: 0x4)
AIBackUpCoverPointFinder.AIPosistion = 0x0 // FVector (Size: 0xc)
AIBackUpCoverPointFinder.EnemyPosition = 0xc // FVector (Size: 0xc)
AIBackUpCoverPointFinder.LastTime = 0x18 // float (Size: 0x4)
AIBeenShootRecord.Investigator = 0x0 // Actor* (Size: 0x8)
AIBeenShootRecord.bIsHit = 0x8 // bool (Size: 0x1)
AIBeenShootRecord.ShootTimeSecond = 0xc // float (Size: 0x4)
AIBeenShootRecord.ShootDistance = 0x10 // float (Size: 0x4)
AIBeenShootRecord.ShootLocation = 0x14 // FVector (Size: 0xc)
AIBeenShootRecord.DamageDealt = 0x20 // float (Size: 0x4)
AIBlockArea.TileType = 0x0 // EENPCAIPerceptibleTile (Size: 0x1)
AIBlockArea.BlockBox = 0x4 // FBox (Size: 0x1c)
AIBlockArea.EffectiveBox = 0x20 // FBox (Size: 0x1c)
AIBlockArea.Center = 0x3c // FVector (Size: 0xc)
AIBlockArea.Radius = 0x48 // float (Size: 0x4)
AIBlockArea.Heigh = 0x4c // float (Size: 0x4)
AIBlockArea.StartTime = 0x50 // float (Size: 0x4)
AIBlockArea.EndTime = 0x54 // float (Size: 0x4)
AIBlockArea.BlockStartTime = 0x58 // float (Size: 0x4)
AIBlockArea.BlockEndTime = 0x5c // float (Size: 0x4)
AIBodyBulkAimingChoice.BodyBulk = 0x0 // EEAIBodyBulkType (Size: 0x1)
AIBodyBulkAimingChoice.Weight = 0x4 // float (Size: 0x4)
AIBodyBulkAimingChoice.BodyParts = 0x8 // TArray<FAIBodyPartAimingChoice> (Size: 0x10)
AIBodyPartAimingChoice.BodyPart = 0x0 // EEAIBodyPartType (Size: 0x1)
AIBodyPartAimingChoice.Weight = 0x4 // float (Size: 0x4)
AIBodyPartHitInfo.BodyPartType = 0x0 // EEAIBodyPartType (Size: 0x1)
AIBodyPartHitInfo.HitDurationStartTime = 0x4 // float (Size: 0x4)
AIBodyPartHitInfo.HitDurationValues = 0x8 // float (Size: 0x4)
AIBodyPartHitInfo.FirstHitTime = 0xc // float (Size: 0x4)
AIBodyPartHitInfo.LastHitTime = 0x10 // float (Size: 0x4)
AIBodyPartVisibilityInfo.BodyPartType = 0x0 // EEAIBodyPartType (Size: 0x1)
AIBodyPartVisibilityInfo.bIsVisible = 0x1 // bool (Size: 0x1)
AIBodyPartVisibilityInfo.bCanShoot = 0x2 // bool (Size: 0x1)
AIBodyPartVisibilityInfo.LastCanSeeTime = 0x4 // float (Size: 0x4)
AIBodyPartVisibilityInfo.GrassWeight = 0x8 // int32_t (Size: 0x4)
AIBodyPartVisibilityInfo.ShootCalculateCount = 0xc // int32_t (Size: 0x4)
AIBodyPartVisibilityInfo.Barrier = 0x10 // EENPCAISenseBarrier (Size: 0x1)
AICandidateStandPosition.PathLength = 0x0 // float (Size: 0x4)
AICandidateStandPosition.Location = 0x4 // FVector (Size: 0xc)
AICharacterConfig.FireInterval = 0x0 // float (Size: 0x4)
AICharacterConfig.PerBurstReduce = 0x4 // float (Size: 0x4)
AICoverPointInfo.ID = 0x0 // int32_t (Size: 0x4)
AICoverPointInfo.IsFree = 0x4 // bool (Size: 0x1)
AICoverPointInfo.OwnerActor = 0x8 // Actor* (Size: 0x8)
AICoverPointInfo.Location = 0x10 // FVector (Size: 0xc)
AICoverPointInfo.ToWallVector = 0x1c // FVector (Size: 0xc)
AICoverPointInfo.ProtectedStance = 0x28 // EEAIPose (Size: 0x1)
AICoverPointInfo.IsSafe = 0x29 // bool (Size: 0x1)
AICoverPointInfo.LastSpottedTime = 0x2c // float (Size: 0x4)
AICoverPointInfo.FirePosition = 0x30 // FVector (Size: 0xc)
AICoverPointInfo.FireStance = 0x3c // EEAIPose (Size: 0x1)
AICoverPointInfo.TiltType = 0x3d // EEAILeanType (Size: 0x1)
AICoverPointInfo.BaseWeight = 0x40 // float (Size: 0x4)
AIDataProviderFVectorValue.DefaultValue = 0x30 // FVector (Size: 0xc)
AIDebugDrawLineInfo.StartLoc = 0x0 // FVector (Size: 0xc)
AIDebugDrawLineInfo.EndLoc = 0xc // FVector (Size: 0xc)
AIDebugDrawLineInfo.LineColor = 0x18 // FLinearColor (Size: 0x10)
AIDebugDrawLineInfo.Duration = 0x28 // float (Size: 0x4)
AIDebugDrawLineInfo.Thickness = 0x2c // float (Size: 0x4)
AIDebugDrawSphereInfo.Loc = 0x0 // FVector (Size: 0xc)
AIDebugDrawSphereInfo.Radius = 0xc // float (Size: 0x4)
AIDebugDrawSphereInfo.LineColor = 0x10 // FLinearColor (Size: 0x10)
AIDebugDrawSphereInfo.Duration = 0x20 // float (Size: 0x4)
AIDebugLineStruct.ID = 0x0 // int32_t (Size: 0x4)
AIDebugLineStruct.StartLocation = 0x4 // FVector (Size: 0xc)
AIDebugLineStruct.EndLocation = 0x10 // FVector (Size: 0xc)
AIDebugLineStruct.Color = 0x1c // FColor (Size: 0x4)
AIDebugLineStruct.DurationTime = 0x20 // float (Size: 0x4)
AIDebugLineStruct.EndTime = 0x24 // float (Size: 0x4)
AIDoorSingleSafetyPoint.Location = 0x0 // FVector (Size: 0xc)
AIDoorSingleSafetyPoint.DangerValue = 0xc // float (Size: 0x4)
AIEnemyInfo.FireTime = 0x0 // float (Size: 0x4)
AIEnemyInfo.TimeInterval = 0x4 // float (Size: 0x4)
AIEnemyInfo.FireLocation = 0x8 // FVector (Size: 0xc)
AIEnemyInfo.FireDirection = 0x14 // FVector (Size: 0xc)
AIFoliageGrassBlock.Index = 0x0 // int32_t (Size: 0x4)
AIFoliageGrassBlock.Bounds = 0x4 // FBox (Size: 0x1c)
AIFoliageGrassBlock.Location = 0x20 // FVector (Size: 0xc)
AIFoliageGrassBlock.RotatonYaw = 0x2c // float (Size: 0x4)
AIFoliageGrassBlock.Density = 0x30 // uint8_t (Size: 0x1)
AIFoliageGrassBlock.ScaleValue = 0x34 // float (Size: 0x4)
AIFoliageGrassBlock.bSlowDownCharacter = 0x38 // bool (Size: 0x1)
AIFoliageGrassBlock.bReduceAimingAccuracy = 0x39 // bool (Size: 0x1)
AIGlobalCacheActors.LastTimeSeconds = 0x0 // float (Size: 0x4)
AIGlobalCacheActors.CacheActors = 0x8 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
AIGrassBlock.AIGrassName = 0x28 // FName (Size: 0x8)
AIGrassBlock.Density = 0x30 // uint8_t (Size: 0x1)
AIGrassBlock.GrassBoxList = 0x38 // TArray<FAIGrassBox> (Size: 0x10)
AIGrassBlock.GrassCylinderList = 0x48 // TArray<FAIGrassCylinder> (Size: 0x10)
AIGrassBlock.bSlowDownCharacter = 0x58 // bool (Size: 0x1)
AIGrassBlock.bReduceAimingAccuracy = 0x59 // bool (Size: 0x1)
AIGrassBox.Center = 0x0 // FVector (Size: 0xc)
AIGrassBox.Extent = 0xc // FVector (Size: 0xc)
AIGrassBox.Density = 0x18 // float (Size: 0x4)
AIGrassClusterInfo.Bounds = 0x0 // FBox (Size: 0x1c)
AIGrassClusterInfo.BoxList = 0x20 // TArray<FBox> (Size: 0x10)
AIGrassCylinder.ZCenter = 0x0 // float (Size: 0x4)
AIGrassCylinder.HalfHeight = 0x4 // float (Size: 0x4)
AIGrassCylinder.Radius = 0x8 // float (Size: 0x4)
AIGrassCylinder.PartsDensities = 0x10 // TArray<uint8_t> (Size: 0x10)
AIGrassEditorBlock.StaticMesh = 0x60 // StaticMesh* (Size: 0x8)
AIGrassGrayBMP.BMPWidth = 0x0 // int32_t (Size: 0x4)
AIGrassGrayBMP.BMPHeight = 0x4 // int32_t (Size: 0x4)
AIGrassGrayBMP.Colors = 0x8 // TArray<FColor> (Size: 0x10)
AIGrassGrayBMP.ZeroPoint = 0x18 // FVector2D (Size: 0x8)
AIGrassGrayBMP.ScaleValue = 0x20 // float (Size: 0x4)
AIGrassGrayBMP.MinLine = 0x24 // int32_t (Size: 0x4)
AIGrassGrayBMP.MaxLine = 0x28 // int32_t (Size: 0x4)
AIGrassGrayBMP.MinRow = 0x2c // int32_t (Size: 0x4)
AIGrassGrayBMP.MaxRow = 0x30 // int32_t (Size: 0x4)
AIGrassGrayBMP.OriginBoundBox = 0x34 // FBox (Size: 0x1c)
AIGrassMapInfo.MapName = 0x0 // FString (Size: 0x10)
AIGrassMapInfo.MapTopX = 0x10 // float (Size: 0x4)
AIGrassMapInfo.MapTopY = 0x14 // float (Size: 0x4)
AIGrassMapInfo.MapSizeX = 0x18 // float (Size: 0x4)
AIGrassMapInfo.MapSizeY = 0x1c // float (Size: 0x4)
AIGrassMapInfo.MapLandscapeGrassCellCountX = 0x20 // int32_t (Size: 0x4)
AIGrassMapInfo.MapLandscapeGrassCellCountY = 0x24 // int32_t (Size: 0x4)
AIGrassMapInfo.LandscapeGrassCellSize = 0x28 // float (Size: 0x4)
AIGrassMapInfo.MinLandscapeGrassCountInCell = 0x2c // int32_t (Size: 0x4)
AIGrassMapInfo.MinCellCoverPercent = 0x30 // float (Size: 0x4)
AIGrassMapInfo.MinLandscapeGrassHeight = 0x34 // float (Size: 0x4)
AIGrassMapInfo.LandscapeGrassZGapLimit = 0x38 // float (Size: 0x4)
AIGrassMapInfo.MinGrassHeight = 0x3c // float (Size: 0x4)
AIGrassMapInfo.AverageDensityLimit = 0x40 // float (Size: 0x4)
AIGrassMapInfo.IgnoreFoliageTags = 0x48 // FString (Size: 0x10)
AIGrassMapInfo.bIsGenerateMeshGrass = 0x58 // bool (Size: 0x1)
AIGrassMapInfo.MeshGrassTags = 0x60 // FString (Size: 0x10)
AIGrassMapInfo.SaveLevelName = 0x70 // FString (Size: 0x10)
AIGrassMapInfo.bShouldSkipMainLevel = 0x80 // bool (Size: 0x1)
AIGroupAllyDeathInfo.DeathTime = 0x0 // float (Size: 0x4)
AIGroupAllyDeathInfo.DeathLocation = 0x4 // FVector (Size: 0xc)
AIGroupAllyDeathInfo.KillerLocation = 0x10 // FVector (Size: 0xc)
AIHearingNoisePower.NOISE_POWER_SPRINT = 0x0 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_PRONE = 0x4 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_CROUCH = 0x8 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_WALK = 0xc // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_SLIENT_WALK = 0x10 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_SLIENT_CROUCH = 0x14 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_GUN_FIRE = 0x18 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_SILENCED_FIRE = 0x1c // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_DOOR_OPEN = 0x20 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_DOOR_WRECK = 0x24 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_GRENADE_EXPLOSIVE = 0x28 // float (Size: 0x4)
AIHearingNoisePower.NOISE_POWER_FOOT_STEP_SOUNDER = 0x2c // float (Size: 0x4)
AIIDSegInfo.MainCategory = 0x0 // FAIIDSegInfoData (Size: 0x10)
AIIDSegInfo.Career = 0x10 // FAIIDSegInfoData (Size: 0x10)
AIIDSegInfo.Tendency = 0x20 // FAIIDSegInfoData (Size: 0x10)
AIIDSegInfo.Difficulty = 0x30 // FAIIDSegInfoData (Size: 0x10)
AIIDSegInfoData.Div = 0x0 // int64_t (Size: 0x8)
AIIDSegInfoData.Mod = 0x8 // int64_t (Size: 0x8)
AILandscapeGrassBlock.Bounds = 0x0 // FBox (Size: 0x1c)
AILandscapeGrassBlock.Location = 0x1c // FVector (Size: 0xc)
AILocationMonitor.Target = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
AILocationMonitor.MonitoringInterval = 0x8 // float (Size: 0x4)
AILocationMonitor.MaxTimeAllowOutOfNavmesh = 0xc // float (Size: 0x4)
AIMindGoalEnemyAngleMultiple.Angle = 0x0 // float (Size: 0x4)
AIMindGoalEnemyAngleMultiple.ScoreMultiple = 0x4 // float (Size: 0x4)
AIMindGoalEnemyAngleMultiple.AngleCos = 0x8 // float (Size: 0x4)
AIModifierAITypeProfile.AIMainType = 0x38 // EEAIMainType (Size: 0x1)
AIModifierArmorProfile.HeadArmor = 0x38 // FAIArmorAttributeModifier (Size: 0x14)
AIModifierArmorProfile.BodyArmor = 0x4c // FAIArmorAttributeModifier (Size: 0x14)
AIModifierDamageProfile.DamageScale = 0x38 // float (Size: 0x4)
AINavGenerationSettings.NavLinkProxyGeneratorClass = 0x38 // TSoftClassPtr<UObject> (Size: 0x28)
AINavGenerationSettings.NavLinkProxyGenerator_MapID = 0x60 // TArray<int32_t> (Size: 0x10)
AINavGenerationSettings.DefaultPlatformBuildConfig = 0x70 // FNPCAINavPlatformBuildConfig (Size: 0x48)
AINavGenerationSettings.PlatformBuildConfigs = 0xb8 // TMap<...> (Size: 0x50)
AINavGenerationSettings.DefaultPlatformBuildData = 0x108 // FNPCAINavPlatformBuildData (Size: 0x48)
AINearGrassBounds.Center = 0x0 // FVector (Size: 0xc)
AINearGrassBounds.Radius = 0xc // float (Size: 0x4)
AINearGrassBounds.GrassIndexs = 0x10 // TArray<int32_t> (Size: 0x10)
AINoiseMakerInfo.lasttime_footstep = 0x0 // float (Size: 0x4)
AINoiseMakerInfo.lasttime_gunfire = 0x4 // float (Size: 0x4)
AINoiseMakerInfo.lasttime_bulletfire = 0x8 // float (Size: 0x4)
AINoiseMakerInfo.lasttime_bullethit = 0xc // float (Size: 0x4)
AIPathDebugInfo.PathPoints = 0x0 // TArray<FVector> (Size: 0x10)
AIPathDebugInfo.SegmentStartIndex = 0x10 // int32_t (Size: 0x4)
AIPropertyAimingProfile.UA_QUICK_AIM_OFFSET_DIS_RATE = 0x38 // float (Size: 0x4)
AIPropertyAimingProfile.UA_QUICK_AIM_UNDER_SEEN_TIME = 0x3c // float (Size: 0x4)
AIPropertyAimingProfile.UA_QUICK_AIM_TIME_CALC_COEF = 0x40 // float (Size: 0x4)
AIPropertyAimingProfile.UA_AIM_TIME_TO_DIST_MULTIPLIER_CURVE = 0x48 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SCATTERING_DIST_CURVE = 0x50 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_FAKE_RANDOM_HIT_RATE_CURVE = 0x58 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATES = 0x60 // TArray<float> (Size: 0x10)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATES_AI = 0x70 // TArray<float> (Size: 0x10)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_DISTANCE_TO_PLAYER_CURVE = 0x80 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_DISTANCE_TO_AI_CURVE = 0x88 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_DISTANCE_NOT_ADS = 0x90 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_ADD_AIMING_TICK_WHEN_ANGLE_SMALLER_THAN = 0x98 // float (Size: 0x4)
AIPropertyAimingProfile.UA_ADD_AIMING_TICK_WHEN_ANGLE_SMALLER_THAN_COS = 0x9c // float (Size: 0x4)
AIPropertyAimingProfile.IS_USE_PREDESTINED_FAKE_RANDOM = 0xa0 // bool (Size: 0x1)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_AIMOVE = 0xa4 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_ENEMY_MOVE_SPEED = 0xa8 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_ENEMY_MOVE = 0xac // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_ARM_BROKEN = 0xb0 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_INCOVER_SAFE = 0xb4 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_BE_HITED = 0xb8 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_BATTLE_DURATION_CURVE = 0xc0 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_WEAPON_ADSMOA_BIAS_CURVE = 0xc8 // CurveFloat* (Size: 0x8)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_SHOOT_HEAD = 0xd0 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_RATE_IF_UNDER_FLASH_LIGHT = 0xd4 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HEAD_FACE_RATE_IF_USE_PREDESTINED = 0xd8 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SHOOT_HIT_LIMITED_TIME = 0xdc // float (Size: 0x4)
AIPropertyAimingProfile.MinAimDuration = 0xe0 // float (Size: 0x4)
AIPropertyAimingProfile.MaxAimDuration = 0xe4 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SPREAD_OFFSET_XY_CLAMP = 0xe8 // float (Size: 0x4)
AIPropertyAimingProfile.UA_SPREAD_OFFSET_MIN_Z_CLAMP = 0xec // float (Size: 0x4)
AIPropertyAimingProfile.UA_SPREAD_OFFSET_MAX_Z_CLAMP = 0xf0 // float (Size: 0x4)
AIPropertyAimingProfile.AIMING_BULK_FOR_PLAYER = 0xf8 // TArray<FAIBodyBulkAimingChoice> (Size: 0x10)
AIPropertyAimingProfile.AIMING_BULK_FOR_AI = 0x108 // TArray<FAIBodyBulkAimingChoice> (Size: 0x10)
AIPropertyAimingProfile.IS_FILTER_NOT_SEEN_PART_TO_AIMING = 0x118 // bool (Size: 0x1)
AIPropertyAimingProfile.AIMING_BODYPART_TREND = 0x119 // EEAIAimingBodyPartTrend (Size: 0x1)
AIPropertyAimingProfile.ShootPartRandInterval = 0x11c // float (Size: 0x4)
AIPropertyAimingProfile.ShootSpecifiedPartTime = 0x120 // float (Size: 0x4)
AIPropertyAimingProfile.ReAimThreshold_Z = 0x124 // float (Size: 0x4)
AIPropertyAimingProfile.ReAimThreshold_XY = 0x128 // float (Size: 0x4)
AIPropertyAimingProfile.FireCountMin = 0x130 // int32_t (Size: 0x4)
AIPropertyAimingProfile.FireCountMax = 0x134 // int32_t (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByDamageProb = 0x138 // float (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByDamageMin = 0x13c // float (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByDamageMax = 0x140 // float (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByFirstShoot = 0x144 // float (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByFirstShootProb = 0x148 // float (Size: 0x4)
AIPropertyAimingProfile.AimTimeDelayByMove = 0x14c // float (Size: 0x4)
AIPropertyAimingProfile.EffectiveCountPerBullet = 0x150 // TMap<...> (Size: 0x50)
AIPropertyAimingProfile.DeathSaveChance = 0x1a0 // float (Size: 0x4)
AIPropertyAimingProfile.DeathSaveChanceCurve = 0x1a8 // CurveFloat* (Size: 0x8)
AIPropertyBossProfile.ThreatenShootEnable = 0x38 // bool (Size: 0x1)
AIPropertyBossProfile.ThreatenShootDist = 0x3c // float (Size: 0x4)
AIPropertyBossProfile.ThreatenShootTime = 0x40 // float (Size: 0x4)
AIPropertyBossProfile.ThreatenShootCloseDist = 0x44 // float (Size: 0x4)
AIPropertyBossProfile.ThreatenShootEndDist = 0x48 // float (Size: 0x4)
AIPropertyCoreProfile.AccuratySpeed = 0x38 // float (Size: 0x4)
AIPropertyCurveProfile.SightCurveDaytime = 0x38 // CurveFloat* (Size: 0x8)
AIPropertyCurveProfile.SightCureOutLight = 0x40 // CurveFloat* (Size: 0x8)
AIPropertyDamageProfile.DamageScale = 0x38 // float (Size: 0x4)
AIPropertyDamageProfile.ArmorDamageScale = 0x3c // float (Size: 0x4)
AIPropertyDamageProfile.BulletArmorPenetrationNotHurt = 0x40 // float (Size: 0x4)
AIPropertyDamageProfile.EnabledTeamGrenadeHarm = 0x44 // bool (Size: 0x1)
AIPropertyDamageProfile.EnabledFactionGrenadeHarm = 0x45 // bool (Size: 0x1)
AIPropertyDamageProfile.bDamageLimitEnabledForAI = 0x46 // bool (Size: 0x1)
AIPropertyDamageProfile.DamageLimit = 0x48 // int32_t (Size: 0x4)
AIPropertyDamageProfile.DamageLimitTime = 0x4c // float (Size: 0x4)
AIPropertyDamageProfile.DamageLimitPercentage = 0x50 // float (Size: 0x4)
AIPropertyDamageProfile.DamageNoZeroHPValue = 0x54 // float (Size: 0x4)
AIPropertyDamageProfile.DamageNoZeroHPParts = 0x58 // TArray<EEAIBodyPartType> (Size: 0x10)
AIPropertyDamageProfile.DamageBleedExtraProbability = 0x68 // float (Size: 0x4)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_STAND = 0x38 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_STAND_LLEAN = 0x44 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_STAND_RLEAN = 0x50 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_CROUCH = 0x5c // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_CROUCH_LLEAN = 0x68 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_CROUCH_RLEAN = 0x74 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.UA_THROW_POSITION_OFFSET_PRONE = 0x80 // FVector (Size: 0xc)
AIPropertyGrenadeProfile.EXTRA_PROJECTILE_PLAY_EFFECT_TIME = 0x8c // float (Size: 0x4)
AIPropertyGrenadeProfile.CLOSE_GRENADE_HIT_DISTANCE = 0x90 // float (Size: 0x4)
AIPropertyGrenadeProfile.COMING_GRENADE_BE_KONW_IF_FALL_IN_DISTANCE = 0x94 // float (Size: 0x4)
AIPropertyGrenadeProfile.HOLDING_GRENADE_BE_KONW_IF_IN_DISTANCE = 0x98 // float (Size: 0x4)
AIPropertyGrenadeProfile.SELF_HOLDING_GRENADE_PROBABILITY = 0x9c // float (Size: 0x4)
AIPropertyHealthProfile.HeadEnduranceMax = 0x38 // float (Size: 0x4)
AIPropertyHealthProfile.ChestEnduranceMax = 0x3c // float (Size: 0x4)
AIPropertyHealthProfile.StomachEnduranceMax = 0x40 // float (Size: 0x4)
AIPropertyHealthProfile.LeftArmEnduranceMax = 0x44 // float (Size: 0x4)
AIPropertyHealthProfile.RightArmEnduranceMax = 0x48 // float (Size: 0x4)
AIPropertyHealthProfile.LeftLegEnduranceMax = 0x4c // float (Size: 0x4)
AIPropertyHealthProfile.RightLegEnduranceMax = 0x50 // float (Size: 0x4)
AIPropertyHealthProfile.MaxHealthAdjustment = 0x54 // float (Size: 0x4)
AIPropertyHealthProfile.bEnableDBNO = 0x58 // bool (Size: 0x1)
AIPropertyHealthProfile.bEnableBroaderDBNO = 0x59 // bool (Size: 0x1)
AIPropertyHealthProfile.DangerCoefOfDBNO = 0x5c // float (Size: 0x4)
AIPropertyHearingProfile.AUTO_BE_ENEMY_IF_CREATE_DANAGE_NOISE = 0x38 // bool (Size: 0x1)
AIPropertyHearingProfile.NOISE_POWER_SPRINT = 0x3c // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_PRONE = 0x40 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_CROUCH = 0x44 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_WALK = 0x48 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_SLIENT_WALK = 0x4c // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_SLIENT_CROUCH = 0x50 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_GUN_FIRE = 0x54 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_SILENCED_FIRE = 0x58 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_DOOR_OPEN = 0x5c // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_DOOR_WRECK = 0x60 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_GRENADE_EXPLOSIVE = 0x64 // float (Size: 0x4)
AIPropertyHearingProfile.NOISE_POWER_FOOT_STEP_SOUNDER = 0x68 // float (Size: 0x4)
AIPropertyHearingProfile.NoisePowerByWeather = 0x70 // TMap<...> (Size: 0x50)
AIPropertyHearingProfile.POWER_DANGER = 0xc0 // float (Size: 0x4)
AIPropertyHearingProfile.HEARING_POWER_COEF = 0xc4 // float (Size: 0x4)
AIPropertyHearingProfile.FOOT_STEP_FAR_DIST = 0xc8 // float (Size: 0x4)
AIPropertyHearingProfile.GUN_FAR_DIST = 0xcc // float (Size: 0x4)
AIPropertyHearingProfile.GUN_HIT_CLOSE_DIST = 0xd0 // float (Size: 0x4)
AIPropertyHearingProfile.GUN_BULLET_TRACK_FROM_ME_RADIUS = 0xd4 // float (Size: 0x4)
AIPropertyHearingProfile.GUN_BULLET_TRACK_CHECK_IN_FIRE_DISTANCE = 0xd8 // float (Size: 0x4)
AIPropertyHearingProfile.COEF_FOOTSTEP_SUSPECTED_POINT_OFFSET = 0xdc // float (Size: 0x4)
AIPropertyHearingProfile.COEF_GUN_SUSPECTED_POINT_OFFSET = 0xe0 // float (Size: 0x4)
AIPropertyHearingProfile.COEF_SILENT_GUN_SUSPECTED_POINT_OFFSET = 0xe4 // float (Size: 0x4)
AIPropertyHearingProfile.SUSPECTED_POINT_ACCURACY_INCREASE_GAP_TIME = 0xe8 // float (Size: 0x4)
AIPropertyHearingProfile.SUSPECTED_POINT_ACCURACY_DAMPING_GAP_TIME = 0xec // float (Size: 0x4)
AIPropertyHearingProfile.SUSPECTED_POINT_ACCURACY_MAX_NUM = 0xf0 // int32_t (Size: 0x4)
AIPropertyHearingProfile.SUSPECTED_POINT_POS_UPDATE_INTERVAL = 0xf4 // float (Size: 0x4)
AIPropertyLayProfile.ProneCooldown = 0x38 // float (Size: 0x4)
AIPropertyLayProfile.EndProneCooldown = 0x3c // float (Size: 0x4)
AIPropertyLayProfile.StandUpCooldown = 0x40 // float (Size: 0x4)
AIPropertyLookProfile.SIGHT_PRIORITY = 0x38 // EENPCAIPriority (Size: 0x1)
AIPropertyLookProfile.VISION_NORMAL = 0x40 // TArray<FAISenseSightNormal> (Size: 0x10)
AIPropertyLookProfile.VISIBLE_ANG_NORMAL = 0x50 // float (Size: 0x4)
AIPropertyLookProfile.NORMAL_VISION_RADIUS = 0x54 // float (Size: 0x4)
AIPropertyLookProfile.NORMAL_VISION_RADIUS_LOST = 0x58 // float (Size: 0x4)
AIPropertyLookProfile.WEATHER_WITH_IMPAIRED_VISION = 0x60 // TArray<EEWeatherType> (Size: 0x10)
AIPropertyLookProfile.FOG_VISION_CURVE = 0x70 // CurveVector* (Size: 0x8)
AIPropertyLookProfile.FOG_DELAY_SEE_TIME_MAX = 0x78 // float (Size: 0x4)
AIPropertyLookProfile.FOG_SHOT_IN_TIME_CAN_IGNORE_FOGVISION = 0x7c // float (Size: 0x4)
AIPropertyLookProfile.SMOKE_SIGHT_IGNORE_DISTANCE = 0x80 // float (Size: 0x4)
AIPropertyLookProfile.GRASS_SIGHT_IGNORE_DISTANCE = 0x84 // float (Size: 0x4)
AIPropertyLookProfile.LANDSCAPE_GRASS_SIGHT_IGNORE_ANGLE = 0x88 // float (Size: 0x4)
AIPropertyLookProfile.GRASS_SIGHT_BLOCK_POWER = 0x8c // float (Size: 0x4)
AIPropertyLookProfile.GRASS_SIGHT_BLOCK_DENSITY100 = 0x90 // float (Size: 0x4)
AIPropertyLookProfile.RAINY_SIGHT_RADIUS_MIN = 0x94 // float (Size: 0x4)
AIPropertyLookProfile.RAINY_SIGHT_RADIUS_MAX = 0x98 // float (Size: 0x4)
AIPropertyLookProfile.INGORE_NOLIGHT_RADIUS = 0x9c // float (Size: 0x4)
AIPropertyLookProfile.DIST_NORMAL_SUSPECTED_POINT_INTERVAL = 0xa0 // float (Size: 0x4)
AIPropertyLookProfile.DIST_DANGER_SUSPECTED_POINT_INTERVAL = 0xa4 // float (Size: 0x4)
AIPropertyLookProfile.FAR_DISTANCE = 0xa8 // float (Size: 0x4)
AIPropertyLookProfile.MIDDLE_DIST = 0xac // float (Size: 0x4)
AIPropertyLookProfile.CLOSE_DIST = 0xb0 // float (Size: 0x4)
AIPropertyLookProfile.InvisibleDelayTime = 0xb4 // float (Size: 0x4)
AIPropertyLookProfile.GOAL_NEED_TO_CALCULATE_FIRST_APPEAR_DISTANCE = 0xb8 // float (Size: 0x4)
AIPropertyLookProfile.GOAL_FIRST_APPEAR_CALCULATE_COEF = 0xbc // float (Size: 0x4)
AIPropertyLookProfile.GOAL_FIRST_APPEAR_ANGLE_CALCULATE_COEF = 0xc0 // float (Size: 0x4)
AIPropertyLookProfile.GOAL_FIRST_APPEAR_MIN_TIME = 0xc4 // float (Size: 0x4)
AIPropertyLookProfile.GOAL_FIRST_APPEAR_MAX_TIME = 0xc8 // float (Size: 0x4)
AIPropertyLookProfile.TIME_CAN_SEE_ENEMY_IF_BEEN_SHOOT = 0xcc // float (Size: 0x4)
AIPropertyLookProfile.TIME_CAN_SEE_ENEMY_IF_FLASH_LIGHT = 0xd0 // float (Size: 0x4)
AIPropertyLookProfile.FLASH_LIGHT_BURN_LOSS_SIGHT_CURVE = 0xd8 // CurveFloat* (Size: 0x8)
AIPropertyLookProfile.WEAKEN_VISION_RADIUS_SCALE_WHILE_ROTATE = 0xe0 // float (Size: 0x4)
AIPropertyLookProfile.WEAKEN_VISION_RADIUS_SCALE_MAX_WHILE_ROTATE = 0xe4 // float (Size: 0x4)
AIPropertyLookProfile.RECOVER_VISION_RADIUS_SPEED_AFTER_WEAKEN = 0xe8 // float (Size: 0x4)
AIPropertyLookProfile.DISTANCE_CHECK_IF_OUTSIDE_SIGHT_PIE = 0xec // float (Size: 0x4)
AIPropertyLookProfile.TIME_CREATE_SUSPECTED_POINT_CHECK_IF_OUTSIDE_SIGHT_PIE = 0xf0 // float (Size: 0x4)
AIPropertyLookProfile.INTERVAL_CHECK_IF_OUTSIDE_SIGHT_PIE = 0xf4 // float (Size: 0x4)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_STAND = 0xf8 // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_STAND_LLEAN = 0x104 // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_STAND_RLEAN = 0x110 // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_CROUCH = 0x11c // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_CROUCH_LLEAN = 0x128 // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_CROUCH_RLEAN = 0x134 // FVector (Size: 0xc)
AIPropertyLookProfile.LOOK_POSITION_OFFSET_PRONE = 0x140 // FVector (Size: 0xc)
AIPropertyLookProfile.LEAN_CHECK_BLOCK_WALL_OFFSET = 0x14c // FVector (Size: 0xc)
AIPropertyMindProfile.CALCULATE_GOAL_ENEMY_PRIORITY_INTERVAL = 0x38 // EENPCAIPriority (Size: 0x1)
AIPropertyMindProfile.HATRED_VALUE_TO_DIST = 0x3c // float (Size: 0x4)
AIPropertyMindProfile.SCORE_TO_DISTANCE_FOR_GOAL_ENEMY = 0x40 // float (Size: 0x4)
AIPropertyMindProfile.TIME_OF_HIT_FOR_GOAL_ENEMY = 0x44 // float (Size: 0x4)
AIPropertyMindProfile.SCORE_CUT_OF_HIT_ME_FOR_GOAL_ENEMY = 0x48 // float (Size: 0x4)
AIPropertyMindProfile.SCORE_CUT_OF_HIT_ALLY_FOR_GOAL_ENEMY = 0x4c // float (Size: 0x4)
AIPropertyMindProfile.SCORE_CUT_OF_ZOOM_WEAPON_FOR_GOAL_ENEMY = 0x50 // float (Size: 0x4)
AIPropertyMindProfile.CARE_TARGET_HAS_ZOOM_WEAPON_DSITANCE = 0x54 // float (Size: 0x4)
AIPropertyMindProfile.SCORE_MULTIPLE_FACE_ANGLE_FOR_GOAL_ENEMY = 0x58 // TArray<FAIMindGoalEnemyAngleMultiple> (Size: 0x10)
AIPropertyMindProfile.TIME_NOT_SEE_FOR_GOAL_ENEMY = 0x68 // float (Size: 0x4)
AIPropertyMindProfile.TIME_TO_FORGOR_ABOUT_ENEMY_SEC = 0x6c // float (Size: 0x4)
AIPropertyMindProfile.TIME_ENEMY_DEAD_PASS_CAN_CONFIRM = 0x70 // float (Size: 0x4)
AIPropertyMindProfile.TIME_ENEMY_DEAD_PASS_CAN_DELETE = 0x74 // float (Size: 0x4)
AIPropertyMindProfile.ITEM_CHEAP_PRICE_CAN_DESTORY_WHEN_PICKUP = 0x78 // int32_t (Size: 0x4)
AIPropertyMindProfile.ITEM_PICKUP_PRICE_THRESHOLD = 0x7c // int32_t (Size: 0x4)
AIPropertyMindProfile.ITEM_PICKUP_PRICE_MAX = 0x80 // int32_t (Size: 0x4)
AIPropertyMindProfile.ITEM_PICKUP_RARITY_MIN = 0x84 // int32_t (Size: 0x4)
AIPropertyMindProfile.ITEM_PICKUP_PER_CONTAINER_MAX = 0x88 // int32_t (Size: 0x4)
AIPropertyMindProfile.NO_REPEAT_QRE_MYSELF_AT_DISTANCE = 0x8c // float (Size: 0x4)
AIPropertyMindProfile.NO_REPEAT_QRE_ENEMY_AT_DISTANCE = 0x90 // float (Size: 0x4)
AIPropertyMindProfile.MOUSE_PIN_LIMIT_NUM = 0x94 // int32_t (Size: 0x4)
AIPropertyMindProfile.MOUSE_PIN_LIFE_TIME = 0x98 // float (Size: 0x4)
AIPropertyMoveProfile.AcceptanceRadius = 0x38 // float (Size: 0x4)
AIPropertyMoveProfile.AcceptanceRadiusZ = 0x3c // float (Size: 0x4)
AIPropertyMoveProfile.MAX_SPRINT_DURATION = 0x40 // float (Size: 0x4)
AIPropertyMoveProfile.MIN_REQUIRED_TIME_TO_SPRINT = 0x44 // float (Size: 0x4)
AIPropertyMoveProfile.MAX_REQUIRED_TIME_TO_RECOVER = 0x48 // float (Size: 0x4)
AIPropertyMoveProfile.RECOVER_POINT_PER_SECOND = 0x4c // float (Size: 0x4)
AIPropertyMoveProfile.MIN_ROTATE_SPEED = 0x50 // float (Size: 0x4)
AIPropertyMoveProfile.ENABLED_USE_ROTATE_ANGLE_LIMIT = 0x54 // bool (Size: 0x1)
AIPropertyMoveProfile.MAX_ROTATE_ANGLE = 0x58 // float (Size: 0x4)
AIPropertyMoveProfile.ROTATE_ANGLE_INTERVAL = 0x5c // float (Size: 0x4)
AIPropertyMoveProfile.ROTATE_ANGLE_MIN_DEVIATION = 0x60 // float (Size: 0x4)
AIPropertyMoveProfile.ROTATE_ANGLE_MAX_DEVIATION = 0x64 // float (Size: 0x4)
AIPropertyMoveProfile.ENABLED_QUICKLY_TURN_IN_PLACE = 0x68 // bool (Size: 0x1)
AIPropertyMoveProfile.CAN_MOVE_TEST_DISTANCE = 0x6c // float (Size: 0x4)
AIPropertyMoveProfile.SOUND_DIFFUSION_LEVEL_FACTOR = 0x70 // float (Size: 0x4)
AIPropertyMoveProfile.SOUND_DIFFUSION_MAX_DISTANCE_FACTOR = 0x74 // float (Size: 0x4)
AIPropertyMoveProfile.WEAPON_SHOOTING_MOVING_SCALE = 0x78 // float (Size: 0x4)
AIPropertyShootProfile.UA_Curve_ShootAccuracyByRecoil = 0x38 // CurveFloat* (Size: 0x8)
AIPropertyShootProfile.RecoilRecoverTime = 0x40 // float (Size: 0x4)
AIPropertyShootProfile.RecoilRecoverTimeMax = 0x44 // float (Size: 0x4)
AIPropertyShootProfile.VerticalRecoilScale = 0x48 // float (Size: 0x4)
AIPropertyShootProfile.VerticalRecoilScaleMax = 0x4c // float (Size: 0x4)
AIPropertyShootProfile.UA_SHOOT_POSITION_ZOFFSET = 0x50 // float (Size: 0x4)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_STAND = 0x54 // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_STAND_LLEAN = 0x60 // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_STAND_RLEAN = 0x6c // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_CROUCH = 0x78 // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_CROUCH_LLEAN = 0x84 // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_CROUCH_RLEAN = 0x90 // FVector (Size: 0xc)
AIPropertyShootProfile.UA_SHOOT_POSITION_OFFSET_PRONE = 0x9c // FVector (Size: 0xc)
AIPropertyShootProfile.HorizontalRecoilScale = 0xa8 // float (Size: 0x4)
AIPropertyShootProfile.HORIZONT_RECOIL_STEP_SZIE_NUM = 0xac // int32_t (Size: 0x4)
AIPropertyShootProfile.ENABLED_TRANSFTER_HIT_BETTER_PART = 0xb0 // bool (Size: 0x1)
AIPropertyShootProfile.COUNT_IF_HIT_HEAD_TRANSFER_TO_OTHER = 0xb4 // int32_t (Size: 0x4)
AIPropertyShootProfile.COUNT_IF_HIT_CHEST_TRANSFER_TO_OTHER = 0xb8 // int32_t (Size: 0x4)
AIPropertyShootProfile.INSTANT_BULLET_VAILD_DISTANCE = 0xbc // float (Size: 0x4)
AIPropertyShootProfile.TRY_LEAN_RAY_CHECK_DISTANCE = 0xc0 // float (Size: 0x4)
AIPropertyShootProfile.TRY_LEAN_RAY_CHECK_DISTANCE_SQR = 0xc4 // float (Size: 0x4)
AIPropertyShootProfile.STAND_SHOOT_Z_LOCATION = 0xc8 // float (Size: 0x4)
AIPropertyShootProfile.CROUCH_HEAD_TOP_Z_LOCATION = 0xcc // float (Size: 0x4)
AIPropertyShootProfile.FACE_TO_TARGET_ANGLE_LIMIT_CAN_FIRE = 0xd0 // float (Size: 0x4)
AIPropertyShootProfile.HIT_INTERVAL_RATE = 0xd4 // float (Size: 0x4)
AIPropertyShootProfile.HIT_INTERVAL_INCREASE_BY_SHOOT = 0xd8 // int32_t (Size: 0x4)
AIPropertyShootProfile.HIT_INTERVAL_COUNT_BASE = 0xdc // int32_t (Size: 0x4)
AIPropertyShootProfile.ENABLED_HIT_INTERVAL_BY_GROUP = 0xe0 // bool (Size: 0x1)
AIPropertySoundProfile.DataTableOfAI = 0x38 // DataTable* (Size: 0x8)
AIPropertySoundProfile.SelfYellCD = 0x40 // float (Size: 0x4)
AIPropertySoundProfile.AreaYellCD = 0x44 // float (Size: 0x4)
AIPropertySoundProfile.AIVoiceRadius = 0x48 // float (Size: 0x4)
AIPropertyWeaponProfile.WeaponBaseSpread = 0x38 // float (Size: 0x4)
AIPropertyWeaponProfile.WeaponBaseRecoil = 0x3c // float (Size: 0x4)
AIPropertyWeaponProfile.ReloadMinPercentage = 0x40 // float (Size: 0x4)
AIPropertyWeaponProfile.ReloadMaxPercentage = 0x44 // float (Size: 0x4)
AIPropertyWeaponProfile.MinFillBulletTime = 0x48 // float (Size: 0x4)
AIPropertyWeaponProfile.MeleeWeaponID = 0x50 // int64_t (Size: 0x8)
AIPropertyWeaponProfile.WeaponTorrBodyBoneName = 0x58 // FName (Size: 0x8)
AIPropertyWeaponProfile.GunShieldPositionOffset_Stand = 0x60 // FVector (Size: 0xc)
AIPropertyWeaponProfile.GunShieldPositionOffset_Crouch = 0x6c // FVector (Size: 0xc)
AIPropertyWeaponProfile.GunShieldPositionOffset_Prone = 0x78 // FVector (Size: 0xc)
AIPropertyWeaponProfile.GunShieldPositionOffset_LeftLean = 0x84 // FVector (Size: 0xc)
AIPropertyWeaponProfile.GunShieldPositionOffset_RightLean = 0x90 // FVector (Size: 0xc)
AIPropertyWeaponProfile.GunShieldSphereRadius = 0x9c // float (Size: 0x4)
AIPropertyWeaponProfile.GunShieldDistFromBody = 0xa0 // float (Size: 0x4)
AIPropertyWeaponProfile.ProbabilityFlashlightOn = 0xa4 // float (Size: 0x4)
AIProtectTreasureBox.BoxInstance = 0x0 // Actor* (Size: 0x8)
AIRoundPathFindingNodes.LastTimeCheckUpdate = 0x0 // float (Size: 0x4)
AIRoundPathFindingNodes.CheckUpdateCount = 0x4 // int32_t (Size: 0x4)
AIRoundPathFindingNodes.RoundPathLength = 0x8 // float (Size: 0x4)
AIRoundPathFindingNodes.RadiusReCalcRoundPathNodes = 0xc // float (Size: 0x4)
AIRoundPathFindingNodes.CurrentPolyId = 0x10 // int64_t (Size: 0x8)
AIRoundPathFindingNodes.LastLocationCalcRoundPathNodes = 0x18 // FVector (Size: 0xc)
AIRoutePoint.Point = 0x0 // FVector (Size: 0xc)
AIRoutePoint.Content = 0x10 // FString (Size: 0x10)
AIRuntimeMonitor.StatMap = 0x28 // TMap<...> (Size: 0x50)
AIRuntimeMonitorStatInfo.HistoryIncAvg = 0x0 // float (Size: 0x4)
AIRuntimeMonitorStatInfo.HistoryIncMax = 0x4 // float (Size: 0x4)
AIRuntimeMonitorStatInfo.HistoryMaxCallCount = 0x8 // int32_t (Size: 0x4)
AIRuntimeMonitorStatInfo.HistoryAvgCallCount = 0xc // float (Size: 0x4)
AIRuntimeMonitorStatInfo.TotalIncCount = 0x10 // int32_t (Size: 0x4)
AIRuntimeMonitorStatInfo.TotalIncExeTime = 0x14 // float (Size: 0x4)
AIRuntimeMonitorStatInfo.TotalSavedNum = 0x18 // int32_t (Size: 0x4)
AIRuntimeMonitorStatInfo.NowFrame32 = 0x1c // uint32_t (Size: 0x4)
AIRuntimeMonitorStatInfo.NowFrameCallCount = 0x20 // int32_t (Size: 0x4)
AIRuntimeMonitorStatInfo.NowFrameExeUseTime = 0x24 // float (Size: 0x4)
AIRuntimeMonitorStatInfo.WarningTopCost = 0x28 // float (Size: 0x4)
AISGDoorManager.AISGDoorUsedList = 0x28 // TArray<FAISGDoorUsed> (Size: 0x10)
AISGDoorManager.DoorsInWorld = 0x38 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
AISGDoorManager.TimeFindDoorsInWorld = 0x48 // float (Size: 0x4)
AISGDoorUsed.SGDoor = 0x0 // Actor* (Size: 0x8)
AISGDoorUsed.AIPawn = 0x8 // Character* (Size: 0x8)
AISGDoorUsed.UsedTime = 0x10 // double (Size: 0x8)
AISGDoorUsed.WaitPersons = 0x18 // uint8_t (Size: 0x1)
AISafetyOpenDoorResp.SGDoor = 0x0 // Actor* (Size: 0x8)
AISafetyOpenDoorResp.NavLinkPoint = 0x8 // FVector (Size: 0xc)
AISafetyOpenDoorResp.SafetyWaitPoint = 0x14 // FVector (Size: 0xc)
AISceneEventMessage.ValidTime = 0x28 // float (Size: 0x4)
AISceneEventMessage.ValidScope = 0x2c // float (Size: 0x4)
AISceneEventMessage.Tags = 0x30 // TArray<FString> (Size: 0x10)
AISceneEventMessage.EvtUniqueId = 0x40 // int32_t (Size: 0x4)
AISceneEventMessage.StartTime = 0x44 // float (Size: 0x4)
AISceneEventMessage.EndTime = 0x48 // float (Size: 0x4)
AISceneEventMessage.TriggerLocation = 0x4c // FVector (Size: 0xc)
AISceneEventsTriggerManager.SceneEventsList = 0x28 // TArray<AISceneEventMessage*> (Size: 0x10)
AISenseFlashBlock.StartPos = 0x10 // FVector (Size: 0xc)
AISenseFlashBlock.Dir = 0x1c // FVector (Size: 0xc)
AISenseFlashBlock.FaceAngle = 0x28 // float (Size: 0x4)
AISenseFlashBlock.SevereDebuffDistance = 0x2c // float (Size: 0x4)
AISenseFlashBlock.ModerateDebuffDistance = 0x30 // float (Size: 0x4)
AISenseFlashBlock.MildDebuffDistance = 0x34 // float (Size: 0x4)
AISenseFlashBlock.Height = 0x38 // float (Size: 0x4)
AISenseFlashBlock.MaxHeight = 0x3c // float (Size: 0x4)
AISenseSightNormal.Angle = 0x0 // float (Size: 0x4)
AISenseSightNormal.VisionRadius = 0x4 // float (Size: 0x4)
AISenseSightNormal.LostVisionRadius = 0x8 // float (Size: 0x4)
AISenseSightNormal.AngleCos = 0xc // float (Size: 0x4)
AISenseSightNormal.VisionRadiusSqr = 0x10 // float (Size: 0x4)
AISenseSightNormal.LostVisionRadiusSqr = 0x14 // float (Size: 0x4)
AIShotCountStat.Count = 0x0 // int32_t (Size: 0x4)
AIShotCountStat.LastTime = 0x4 // float (Size: 0x4)
AIShotCountStat.FirstTime = 0x8 // float (Size: 0x4)
AIShotCountStat.IntervalToClear = 0xc // float (Size: 0x4)
AIStackGunRecord.CanStackGun = 0x0 // bool (Size: 0x1)
AIStackGunRecord.MyPosition = 0x4 // FVector (Size: 0xc)
AIStackGunRecord.EnemyPosition = 0x10 // FVector (Size: 0xc)
AIStackGunRecord.AILean = 0x1c // EEAILeanType (Size: 0x1)
AIStackGunRecord.AIPose = 0x1d // EEAIPose (Size: 0x1)
AIStackGunRecord.GunPoint = 0x20 // FVector (Size: 0xc)
AIStackGunRecord.EeyPoint = 0x2c // FVector (Size: 0xc)
AIStackGunRecord.ShootPoint = 0x38 // FVector (Size: 0xc)
AITrackLOG.LogType = 0x0 // EEAITrackLOGType (Size: 0x1)
AITrackLOG.LOGTime = 0x8 // int64_t (Size: 0x8)
AITrackLOG.LOGKValues = 0x10 // FString (Size: 0x10)
AITrackLOGTemplateForDataTable.LogType = 0x8 // EEAITrackLOGType (Size: 0x1)
AITrackLOGTemplateForDataTable.Template = 0x10 // FString (Size: 0x10)
AITrackLOGUnit.AIPawn = 0x28 // Actor* (Size: 0x8)
AITrackLOGUnit.AIName = 0x30 // FString (Size: 0x10)
AITrackLOGUnit.TrackLOGList = 0x40 // TArray<FAITrackLOG> (Size: 0x10)
AIVisibleResult.IsVisible = 0x0 // bool (Size: 0x1)
AIVisibleResult.BlockWeight = 0x4 // int32_t (Size: 0x4)
AIVisibleResult.Barrier = 0x8 // EENPCAISenseBarrier (Size: 0x1)
CheckCoverPointFinder.AIPawn = 0x0 // Actor* (Size: 0x8)
CheckCoverPointFinder.CheckPathLength = 0x8 // float (Size: 0x4)
CheckCoverPointFinder.IndexFind = 0xc // int32_t (Size: 0x4)
CheckCoverPointFinder.LastTimestamp = 0x10 // float (Size: 0x4)
CheckCoverPointFinder.Elements = 0x18 // TArray<FCoverPointOctreeElement> (Size: 0x10)
ComponentInfo.Component = 0x0 // ActorComponent* (Size: 0x8)
CoverPointPathLengthResult.PointID = 0x0 // int32_t (Size: 0x4)
CoverPointPathLengthResult.PathLength = 0x4 // float (Size: 0x4)
FloodSeedCollection.PlayerStarts = 0x28 // TArray<Actor*> (Size: 0x10)
FloodSeedCollection.AISpawnPoints = 0x38 // TArray<Actor*> (Size: 0x10)
FloodSeedCollection.DoorNavLinks = 0x48 // TArray<Actor*> (Size: 0x10)
FloodSeedCollection.PlatformPolys = 0x58 // TSet<...> (Size: 0x50)
HNavGraph.Level = 0x0 // int32_t (Size: 0x4)
HNavGraph.NodeCount = 0x4 // int32_t (Size: 0x4)
HNavGraph.bIntermediate = 0x8 // bool (Size: 0x1)
HNavGraph.ParentIndices = 0x10 // TArray<int32_t> (Size: 0x10)
HNavGraph.ChildIndexOffsets = 0x40 // TArray<int32_t> (Size: 0x10)
HNavGraph.ChildIndices = 0x50 // TArray<int32_t> (Size: 0x10)
HNavGraph.PortalEdgeOffsets = 0x60 // TArray<int32_t> (Size: 0x10)
HNavGraph.PortalEdges = 0x70 // TArray<FPortalEdge> (Size: 0x10)
HNavGraph.IntraPathOffsets = 0x80 // TArray<int32_t> (Size: 0x10)
HNavGraph.IntraPaths = 0x90 // TArray<FIntraPath> (Size: 0x10)
HNavGraph.IntraPathSourceIndexOffsets = 0xa0 // TArray<int32_t> (Size: 0x10)
HNavGraph.IntraPathSourceIndices = 0xb0 // TArray<int32_t> (Size: 0x10)
HNavGraph.IntraPathTargetIndexOffsets = 0xc0 // TArray<int32_t> (Size: 0x10)
HNavGraph.IntraPathCounts = 0xe0 // TArray<uint64_t> (Size: 0x10)
HNavGraph.IntraPathPolyRefOffsets = 0xf0 // TArray<int32_t> (Size: 0x10)
HNavGraph.IntraPathPolyRefs = 0x100 // TArray<uint64_t> (Size: 0x10)
HNavGraph.IntraPathCosts = 0x110 // TArray<float> (Size: 0x10)
HNavGraph.IntraPathLengths = 0x120 // TArray<float> (Size: 0x10)
HNavSettings.bAutoBuildAfterNavigationGenerationFinished = 0x0 // bool (Size: 0x1)
HNavSettings.bBuildIntermediateGraph = 0x1 // bool (Size: 0x1)
HNavSettings.bRemoveIntermediateGraph = 0x2 // bool (Size: 0x1)
HNavSettings.bIntraPathOnlyInSelfNode = 0x3 // bool (Size: 0x1)
HNavSettings.bCombineMultiEdges = 0x4 // bool (Size: 0x1)
HNavSettings.bEnableEdgeWeight = 0x5 // bool (Size: 0x1)
HNavSettings.bBreakNavLinkConnection = 0x6 // bool (Size: 0x1)
HNavSettings.MaxGraphLevel = 0x8 // int32_t (Size: 0x4)
HNavSettings.PartitionSize = 0xc // int32_t (Size: 0x4)
HNavSettings.ForceBuildForTopK = 0x10 // int32_t (Size: 0x4)
HNavSettings.MinNodeCountToBuild = 0x14 // int32_t (Size: 0x4)
HNavSettings.MaxSearchNode = 0x18 // int32_t (Size: 0x4)
HNavSettings.MetisOptions = 0x1c // FMetisOptions (Size: 0x20)
Int32Storage.Items = 0x10 // TArray<int32_t> (Size: 0x10)
IntraPath.PackedData = 0x0 // uint64_t (Size: 0x8)
IntraPath.Nodes = 0x8 // TArray<uint64_t> (Size: 0x10)
IntraPath.Length = 0x18 // float (Size: 0x4)
IntraPath.Cost = 0x1c // float (Size: 0x4)
MFGraphAStarPolicy.NodePoolSize = 0x0 // int32_t (Size: 0x4)
MFGraphAStarPolicy.OpenSetSize = 0x4 // int32_t (Size: 0x4)
MFGraphAStarPolicy.MaxPathNodeCount = 0x8 // int32_t (Size: 0x4)
MFGraphAStarPolicy.bReuseNodePoolInSubsequentSearches = 0xc // bool (Size: 0x1)
MetisOptions.bUseDefault = 0x0 // bool (Size: 0x1)
MetisOptions.ObjectiveType = 0x4 // EEMETIS_OBJTYPE (Size: 0x4)
MetisOptions.CoarsenType = 0x8 // EEMETIS_CTYPE (Size: 0x4)
MetisOptions.InitialPartitioningType = 0xc // EEMETIS_IPTYPE (Size: 0x4)
MetisOptions.RifinementType = 0x10 // EEMETIS_RTYPE (Size: 0x4)
MetisOptions.NCuts = 0x14 // int32_t (Size: 0x4)
MetisOptions.IterateTimes = 0x18 // int32_t (Size: 0x4)
MetisOptions.bMinimizeMaximumConnectivity = 0x1c // bool (Size: 0x1)
MetisOptions.bNo2Hop = 0x1d // bool (Size: 0x1)
MetisOptions.bForcesContiguousPartitions = 0x1e // bool (Size: 0x1)
NPCAIActivityAIIDModifierTableRow.ActivityID = 0x10 // int64_t (Size: 0x8)
NPCAIActivityAIIDModifierTableRow.Priority = 0x18 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.SourceCategory = 0x1c // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.SourceCareer = 0x20 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.SourceTendency = 0x24 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.SourceDifficulty = 0x28 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.TargetCategory = 0x2c // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.TargetCareer = 0x30 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.TargetTendency = 0x34 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.TargetDifficulty = 0x38 // int32_t (Size: 0x4)
NPCAIActivityAIIDModifierTableRow.TargetEquipPoolID = 0x3c // int32_t (Size: 0x4)
NPCAIActorComponent.PropertyComponents = 0xf8 // TArray<NPCAIProfileBaseComponent*> (Size: 0x10)
NPCAIAsyncTask.AIPawn = 0x0 // Actor* (Size: 0x8)
NPCAIAsyncTask.Type = 0x8 // EENPCAIAsyncTaskType (Size: 0x1)
NPCAIAsyncTask.AsyncTask = 0x10 // NPCAIAsyncTaskBase* (Size: 0x8)
NPCAIAsyncTaskBase.bSimpleTodo = 0x30 // bool (Size: 0x1)
NPCAIAsyncTaskBase.AIPawn = 0x38 // Actor* (Size: 0x8)
NPCAIAsyncTaskSystem.AsyncTasks = 0x30 // TArray<FNPCAIAsyncTask> (Size: 0x10)
NPCAIAttentionPoint.bIsCome = 0x28 // bool (Size: 0x1)
NPCAIAttentionPoint.Creator = 0x30 // Actor* (Size: 0x8)
NPCAIAttentionPoint.IsFootSounder = 0x39 // bool (Size: 0x1)
NPCAIAttentionPoint.FootSounderSpawnCharacter = 0x40 // Actor* (Size: 0x8)
NPCAIAttentionPoint.CheckingPlayer = 0x48 // AIController* (Size: 0x8)
NPCAIAttentionPoint.bReachable = 0x50 // bool (Size: 0x1)
NPCAIAttentionPoint.PointType = 0x51 // EENPCPlaceForCheckType (Size: 0x1)
NPCAIAttentionPoint.CreatedTime = 0x54 // float (Size: 0x4)
NPCAIAttentionPoint.DiedTime = 0x58 // float (Size: 0x4)
NPCAIComingExplosionEvent.ExplosionLocation = 0x4 // FVector (Size: 0xc)
NPCAIComingExplosionEvent.Damage = 0x10 // float (Size: 0x4)
NPCAIComingExplosionEvent.MaxRange = 0x14 // float (Size: 0x4)
NPCAIComingExplosionEvent.Instigator = 0x18 // Actor* (Size: 0x8)
NPCAIComingExplosionEvent.Tag = 0x20 // FName (Size: 0x8)
NPCAICoverEnvQueryData.Generator_Location = 0xd0 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.Generator_Radius = 0xdc // float (Size: 0x4)
NPCAICoverEnvQueryData.Generator_BotZoneVolume = 0xe0 // Volume* (Size: 0x8)
NPCAICoverEnvQueryData.IsFree_TreatAsFreeAfterSeconds = 0xe8 // float (Size: 0x4)
NPCAICoverEnvQueryData.IsSafe_TreatAsSafeAfterSeconds = 0xec // float (Size: 0x4)
NPCAICoverEnvQueryData.IsNear_Location = 0xf0 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.IsNear_Distance = 0xfc // float (Size: 0x4)
NPCAICoverEnvQueryData.IsNear_Reversed = 0x100 // bool (Size: 0x1)
NPCAICoverEnvQueryData.CloserRatio_Location = 0x104 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.CloserRatio_Ratio = 0x110 // float (Size: 0x4)
NPCAICoverEnvQueryData.CanContain_TargetLocation = 0x114 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.CanContain_HorizontalAngle = 0x120 // float (Size: 0x4)
NPCAICoverEnvQueryData.CanContain_TopAngle = 0x124 // float (Size: 0x4)
NPCAICoverEnvQueryData.CanContain_BottomAngle = 0x128 // float (Size: 0x4)
NPCAICoverEnvQueryData.CanAttackTo_TargetLocation = 0x12c // FVector (Size: 0xc)
NPCAICoverEnvQueryData.CanAttackTo_IgnoredActors = 0x138 // TArray<Actor*> (Size: 0x10)
NPCAICoverEnvQueryData.PathLength_StartLocation = 0x148 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.PathLength_MaxPathLength = 0x154 // float (Size: 0x4)
NPCAICoverEnvQueryData.PathLength_MaxRatio = 0x158 // float (Size: 0x4)
NPCAICoverEnvQueryData.PathLength_CheckPoint = 0x15c // float (Size: 0x4)
NPCAICoverEnvQueryData.DefenceRatio_MinRatio = 0x160 // float (Size: 0x4)
NPCAICoverEnvQueryData.DefenceAngle_MinAngle = 0x164 // float (Size: 0x4)
NPCAICoverEnvQueryData.DistanceToHotPoint_Locations = 0x168 // TArray<FVector> (Size: 0x10)
NPCAICoverEnvQueryData.DistanceToAllyCover_Location = 0x178 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.DistanceToAllyCover_MinDistance = 0x184 // float (Size: 0x4)
NPCAICoverEnvQueryData.IsSameSideToTarget_TargetLocation = 0x188 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.IsSameSideToTarget_TargetDirection = 0x194 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.IsInCone_Location = 0x1a0 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.IsInCone_Direction = 0x1ac // FVector (Size: 0xc)
NPCAICoverEnvQueryData.IsInCone_Radius = 0x1b8 // float (Size: 0x4)
NPCAICoverEnvQueryData.IsInCone_Angle = 0x1bc // float (Size: 0x4)
NPCAICoverEnvQueryData.CoverDist_Location = 0x1c0 // FVector (Size: 0xc)
NPCAICoverEnvQueryData.CoverDist_MaxDistance = 0x1cc // float (Size: 0x4)
NPCAICoverEnvQueryGenerator.CacheCoverSystem = 0x210 // CoverSystem* (Size: 0x8)
NPCAICoverEnvQueryTest_PathLength.bEnabledDebug = 0x1f8 // bool (Size: 0x1)
NPCAICoverEnvQueryTest_Protection.ProtectionFrom = 0x1f8 // ClassProperty (Size: 0x8)
NPCAICoverEnvQueryTest_ShootDistance.ShootDistanceTo = 0x1f8 // ClassProperty (Size: 0x8)
NPCAIDamageData.TimeDamage = 0x28 // float (Size: 0x4)
NPCAIDamageData.position = 0x2c // FVector (Size: 0xc)
NPCAIDamageData.CachedMaxActiveTime = 0x38 // float (Size: 0x4)
NPCAIDynamicGroupInfo.DyGroupId = 0x30 // int32_t (Size: 0x4)
NPCAIDynamicGroupInfo.CreateTime = 0x34 // float (Size: 0x4)
NPCAIDynamicGroupInfo.CanAutoRelease = 0x38 // bool (Size: 0x1)
NPCAIDynamicGroupInfo.AllyList = 0x40 // TArray<Actor*> (Size: 0x10)
NPCAIDynamicGroupInfo.WorldPrivate = 0x50 // World* (Size: 0x8)
NPCAIEnemyGroupSingleInfo.IsTemporaryEnemy = 0x60 // bool (Size: 0x1)
NPCAIEnemyGroupSingleInfo.IsTemporaryEnemyFromAlly = 0x61 // bool (Size: 0x1)
NPCAIEnemyGroupSingleInfo.EndTimeOfTemporaryEnemy = 0x64 // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.EnemyLastSeenPosition = 0x68 // FVector (Size: 0xc)
NPCAIEnemyGroupSingleInfo.EndTimeOfSupressed = 0x74 // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.LastTimeCreateSuspectedPoint = 0x78 // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.PersonInValidTime = 0x7c // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.Person = 0x80 // Actor* (Size: 0x8)
NPCAIEnemyGroupSingleInfo.HatredValue = 0x88 // int32_t (Size: 0x4)
NPCAIEnemyGroupSingleInfo.HatredEndtime = 0x8c // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.LastShootGroupAllyTime = 0x90 // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.SuspectedPointCreatedNum = 0x94 // int32_t (Size: 0x4)
NPCAIEnemyGroupSingleInfo.LastIncreaseTimeSuspectedPoint = 0x98 // float (Size: 0x4)
NPCAIEnemyGroupSingleInfo.EnemyLastEstimatePosition = 0x9c // FVector (Size: 0xc)
NPCAIEnvQueryGenerator_BlueprintBase.IntParam = 0x80 // FAIDataProviderIntValue (Size: 0x38)
NPCAIEnvQueryGenerator_OnPolyCenter.OnlyCurrentRegion = 0x210 // FAIDataProviderBoolValue (Size: 0x38)
NPCAIEnvQueryGenerator_OnPolyCenter.IncludeNavMeshPolyCenters = 0x248 // FAIDataProviderBoolValue (Size: 0x38)
NPCAIEnvQueryGenerator_OnPolyCenter.IncludeNavMeshInternalEdges = 0x280 // FAIDataProviderBoolValue (Size: 0x38)
NPCAIEnvQueryGenerator_OnPolyCenter.IncludeNavMeshBoundaryEdges = 0x2b8 // FAIDataProviderBoolValue (Size: 0x38)
NPCAIEnvQueryGenerator_OnPolyCenter.PointZOffset = 0x2f0 // float (Size: 0x4)
NPCAIEnvQueryInstanceBlueprintWrapper.QueryTime = 0x78 // float (Size: 0x4)
NPCAIEnvQueryTest_BlueprintBase.Context = 0x1f8 // ClassProperty (Size: 0x8)
NPCAIEnvQueryTest_BlueprintBase.TestDescription = 0x200 // FText (Size: 0x18)
NPCAIEnvQueryTest_PathfindingFromQuerier.TestMode = 0x1f8 // uint8_t (Size: 0x1)
NPCAIEnvQueryTest_PathfindingFromQuerier.SkipUnreachable = 0x200 // FAIDataProviderBoolValue (Size: 0x38)
NPCAIEnvQueryTest_PointBase.Context = 0x1f8 // ClassProperty (Size: 0x8)
NPCAIEnvQueryTest_PointBase.TestDescription = 0x200 // FText (Size: 0x18)
NPCAIFactionComponent.PropertyProfiles = 0x110 // TArray<NPCAIPropertyProfile*> (Size: 0x10)
NPCAIFactionPlugin.ProfileTypeMap = 0x38 // TMap<...> (Size: 0x50)
NPCAIFactionPlugin.ProfileCover = 0x88 // FNPCAIProfileCover (Size: 0x28)
NPCAIFactionPluginBase.ObjectRefs = 0x28 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
NPCAIFindAmbushAgainstPointAsyncTask.OnSuccess = 0x40 // FMulticastInlineDelegate (Size: 0x10)
NPCAIFindAmbushAgainstPointAsyncTask.OnFail = 0x50 // FMulticastInlineDelegate (Size: 0x10)
NPCAIFindAmbushAgainstPointAsyncTask.PointStart = 0x60 // FVector (Size: 0xc)
NPCAIFindAmbushAgainstPointAsyncTask.PointToGo = 0x6c // FVector (Size: 0xc)
NPCAIFindAmbushAgainstPointResult.AgainstPoint = 0x0 // FVector (Size: 0xc)
NPCAIFindAmbushAgainstPointResult.bCanFind = 0xc // bool (Size: 0x1)
NPCAIFindPathByKeyRouteAsyncTask.OnSuccess = 0x40 // FMulticastInlineDelegate (Size: 0x10)
NPCAIFindPathByKeyRouteAsyncTask.OnFail = 0x50 // FMulticastInlineDelegate (Size: 0x10)
NPCAIFindPathByKeyRouteAsyncTask.FromPoint = 0x60 // FKeyRoutePointData (Size: 0x60)
NPCAIFindPathByKeyRouteAsyncTask.ToPoint = 0xc0 // FKeyRoutePointData (Size: 0x60)
NPCAIFindPathByKeyRouteAsyncTask.QueryType = 0x120 // EEAIKeyRouteQueryType (Size: 0x1)
NPCAIFindPathByKeyRouteResult.Path = 0x0 // TArray<FKeyRoutePointData> (Size: 0x10)
NPCAIFireOrder.bValidOrder = 0x0 // bool (Size: 0x1)
NPCAIFireOrder.FirePoint = 0x4 // FVector (Size: 0xc)
NPCAIFireOrder.HitPart = 0x10 // EEAIBodyPartType (Size: 0x1)
NPCAIFireOrder.IsUsingPredestined = 0x11 // bool (Size: 0x1)
NPCAIFireOrder.IsHit = 0x12 // bool (Size: 0x1)
NPCAIFireOrder.bShotLimited = 0x13 // bool (Size: 0x1)
NPCAIFireOrder.bFakeShot = 0x14 // bool (Size: 0x1)
NPCAIFireSetting.Location = 0x0 // FVector (Size: 0xc)
NPCAIFireSetting.EnemyTarget = 0x10 // Actor* (Size: 0x8)
NPCAIFireSetting.bCalcSight = 0x18 // bool (Size: 0x1)
NPCAIFireSetting.bCalcShoot = 0x19 // bool (Size: 0x1)
NPCAIFireSetting.FireInterval = 0x1c // float (Size: 0x4)
NPCAIFireSetting.bIgnoreAimingTime = 0x20 // bool (Size: 0x1)
NPCAIFireSetting.bEnabledHitRateControl = 0x21 // bool (Size: 0x1)
NPCAIFireSetting.bEnabledRecoilControl = 0x22 // bool (Size: 0x1)
NPCAIFireSetting.ShootPartID = 0x23 // EEAIBodyPartType (Size: 0x1)
NPCAIFireSetting.LastShootPartID = 0x24 // EEAIBodyPartType (Size: 0x1)
NPCAIFireSetting.RealHitPartID = 0x25 // EEAIBodyPartType (Size: 0x1)
NPCAIFireSetting.bPressureAim = 0x26 // bool (Size: 0x1)
NPCAIFireSetting.WaitEndtime = 0x28 // float (Size: 0x4)
NPCAIFireSetting.LastFireLocation = 0x2c // FVector (Size: 0xc)
NPCAIFireSetting.EnemyInfo = 0x38 // NPCAITargetInfo* (Size: 0x8)
NPCAIGlobalSharedInfo.TimeOfRunEQS_FindBackUpCoverPoint = 0x28 // float (Size: 0x4)
NPCAIGlobalSharedInfo.CacheActorsInWorld = 0x30 // TMap<...> (Size: 0x50)
NPCAIGlobalSharedInfo.AIEnemyInfos = 0x80 // TMap<...> (Size: 0x50)
NPCAIGlobalSharedInfo.bEnableAIPerceptionLines = 0xd0 // bool (Size: 0x1)
NPCAIGlobalSharedInfo.AITrackLOGLastAutoReleaseTime = 0xd4 // float (Size: 0x4)
NPCAIGlobalSharedInfo.AITrackLOGData = 0xd8 // TMap<...> (Size: 0x50)
NPCAIGlobalSharedInfo.bAITrackEnabled = 0x128 // bool (Size: 0x1)
NPCAIGlobalSharedInfo.AITrackLOGTemplate = 0x130 // TMap<...> (Size: 0x50)
NPCAIGlobalSharedInfo.DSPoseUpdateWaitList = 0x180 // TArray<Actor*> (Size: 0x10)
NPCAIGlobalSharedInfo.DSLeanPoseUpdateWaitList = 0x190 // TArray<Actor*> (Size: 0x10)
NPCAIGlobalSharedInfo.DSPoseUpdateCharacter = 0x1a0 // Actor* (Size: 0x8)
NPCAIGlobalSharedInfo.DSIKUpdateWaitList = 0x1a8 // TArray<Actor*> (Size: 0x10)
NPCAIGlobalSharedInfo.DSIKUpdateCharacter = 0x1b8 // Actor* (Size: 0x8)
NPCAIGlobalSharedInfo.TreasureBoxInfos = 0x1c0 // TArray<FAIProtectTreasureBox> (Size: 0x10)
NPCAIGlobalSharedInfo.AIPropClassTypes = 0x1d0 // TMap<...> (Size: 0x50)
NPCAIGlobalSharedInfo.CachedInvIDLimitedAIPickUp = 0x220 // TMap<...> (Size: 0x50)
NPCAIGoalTarget.AttentionPoint = 0x28 // NPCAIAttentionPoint* (Size: 0x8)
NPCAIGoalTarget.AIOwner = 0x30 // AIController* (Size: 0x8)
NPCAIGroupBaseRequest.RequestType = 0x28 // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.DynamicGroupId = 0x2c // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.bOnlyInDynamicGroup = 0x30 // bool (Size: 0x1)
NPCAIGroupBaseRequest.RequestPriority = 0x31 // EEAIGroupRequestPriority (Size: 0x1)
NPCAIGroupBaseRequest.bCanExecuteByMyself = 0x32 // bool (Size: 0x1)
NPCAIGroupBaseRequest.MaxTakenCount = 0x34 // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.IsNeedAllCompleted = 0x38 // bool (Size: 0x1)
NPCAIGroupBaseRequest.CurrentTakenCount = 0x3c // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.CurrentCompleteCount = 0x40 // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.MaxRequestCount = 0x44 // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.RequestTypeNeedCompletedInPast = 0x48 // int32_t (Size: 0x4)
NPCAIGroupBaseRequest.StartTimeOfTake = 0x4c // float (Size: 0x4)
NPCAIGroupBaseRequest.EndTimeOfTake = 0x50 // float (Size: 0x4)
NPCAIGroupBaseRequest.EndTimeOfExecute = 0x54 // float (Size: 0x4)
NPCAIGroupBaseRequest.Requester = 0x60 // Actor* (Size: 0x8)
NPCAIGroupBaseRequest.WorldContext = 0x68 // Object* (Size: 0x8)
NPCAIGroupBaseRequest.ExecuterList = 0x70 // TArray<Actor*> (Size: 0x10)
NPCAIGroupBaseRequest.HistoryExecuterList = 0x80 // TArray<Actor*> (Size: 0x10)
NPCAIGroupBaseRequest.PossibleExecuterList = 0x90 // TArray<Actor*> (Size: 0x10)
NPCAIGroupDoorOpenRequest.Door = 0xa8 // Actor* (Size: 0x8)
NPCAIGroupFollowMeRequest.TimeLimit = 0xa8 // float (Size: 0x4)
NPCAIGroupGoToPointRequest.PointToGo = 0xa8 // FVector (Size: 0xc)
NPCAIGroupGoToPointRequest.Radius = 0xb4 // float (Size: 0x4)
NPCAIGroupHoldRequest.Direction = 0xa8 // FVector (Size: 0xc)
NPCAIGroupRequestComponent.bIsLogEnabled = 0x108 // bool (Size: 0x1)
NPCAIGroupRequestComponent.LastCompletedRequestType = 0x10c // int32_t (Size: 0x4)
NPCAIGroupRequestComponent.OnRequestCompleted = 0x110 // FMulticastInlineDelegate (Size: 0x10)
NPCAIGroupRequestComponent.OnRequestGiveUp = 0x120 // FMulticastInlineDelegate (Size: 0x10)
NPCAIGroupRequestComponent.NextSearchRequestTime = 0x130 // float (Size: 0x4)
NPCAIGroupRequestComponent.CurrentRequest = 0x138 // NPCAIGroupBaseRequest* (Size: 0x8)
NPCAIGroupRequestComponent.CompletedRequestTypeList = 0x140 // TArray<int32_t> (Size: 0x10)
NPCAIGroupRequestComponent.GpRequestController = 0x150 // NPCAIGroupRequestController* (Size: 0x8)
NPCAIGroupRequestController.GroupRequestsList = 0x28 // TArray<NPCAIGroupBaseRequest*> (Size: 0x10)
NPCAIGroupRequestController.LastTimeAutoFiltRequests = 0x38 // float (Size: 0x4)
NPCAIGroupSusspressionFireRequest.TargetType = 0xa8 // EEAIGroupRequestFireTarget (Size: 0x1)
NPCAIGroupSusspressionFireRequest.EnemyTarget = 0xb0 // Actor* (Size: 0x8)
NPCAIGroupSusspressionFireRequest.PointTarget = 0xb8 // FVector (Size: 0xc)
NPCAIGroupThrowGrenadeRequest.EnemyTarget = 0xa8 // Actor* (Size: 0x8)
NPCAIGroupThrowGrenadeRequest.PointTarget = 0xb0 // FVector (Size: 0xc)
NPCAIGroupWarnPlayerRequest.WarnPlayer = 0xa8 // Actor* (Size: 0x8)
NPCAIGroupWarnPlayerRequest.StateWarnPlayer = 0xb0 // EEAIStateWarnPlayerRequest (Size: 0x1)
NPCAIGroupWarnPlayerRequest.DistanceToRequester = 0xb4 // float (Size: 0x4)
NPCAIGroupWarnPlayerRequest.PointToShoot = 0xb8 // FVector (Size: 0xc)
NPCAIGroupWarnPlayerRequest.TimeOfStay = 0xc4 // float (Size: 0x4)
NPCAIGroupWarnPlayerRequest.CountOfWarns = 0xc8 // int32_t (Size: 0x4)
NPCAIHNavActor.Settings = 0x310 // FHNavSettings (Size: 0x3c)
NPCAIHNavActor.Graphs = 0x350 // TArray<FHNavGraph> (Size: 0x10)
NPCAIHNavActor.MinimumPartitionCount = 0x360 // int32_t (Size: 0x4)
NPCAIHNavActor.PortalNodeFlags = 0x368 // TArray<uint8_t> (Size: 0x10)
NPCAIHNavActor.SearchedInfo = 0x438 // FHNavSearchInfo (Size: 0x60)
NPCAIHNavActor.bUseDefaultPathfinding = 0x49c // bool (Size: 0x1)
NPCAIHNavActor.bNewMaxPortalAdjacency = 0x49d // bool (Size: 0x1)
NPCAIIDModifierTableRow.TargetAIID = 0x8 // int64_t (Size: 0x8)
NPCAILaunchPad.Root = 0x310 // SceneComponent* (Size: 0x8)
NPCAILaunchPad.Launchpad = 0x318 // StaticMeshComponent* (Size: 0x8)
NPCAILaunchPad.TriggerVolume = 0x320 // SphereComponent* (Size: 0x8)
NPCAILaunchPad.NavLink = 0x328 // NavLinkComponent* (Size: 0x8)
NPCAILaunchPad.Target = 0x330 // FVector (Size: 0xc)
NPCAILaunchPad.LaunchedCharacter = 0x340 // Character* (Size: 0x8)
NPCAILocalNavigationSubsystem.GridCellSize = 0x38 // float (Size: 0x4)
NPCAILocalNavigationSubsystem.CauserToGridId = 0x70 // TMap<...> (Size: 0x50)
NPCAILocalNavigationSubsystem.OnNavigationGridUpdated = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
NPCAILocalNavigationTestingActor.EmptyCellColor = 0x350 // FColor (Size: 0x4)
NPCAILocalNavigationTestingActor.BlockedCellColor = 0x354 // FColor (Size: 0x4)
NPCAILocalNavigationTestingActor.CellTextOffset = 0x358 // FVector (Size: 0xc)
NPCAILocalNavigationTestingActor.bDrawNavGrids = 0x364 // bool (Size: 0x1)
NPCAILocalNavigationTestingActor.bDrawCellId = 0x365 // bool (Size: 0x1)
NPCAILocalNavigationTestingActor.bDrawCellCoords = 0x366 // bool (Size: 0x1)
NPCAILocalNavigationTestingActor.bDrawCellZ = 0x367 // bool (Size: 0x1)
NPCAILocalNavigationTestingActor.Destination = 0x368 // Actor* (Size: 0x8)
NPCAILocalNavigationTestingActor.PathPoints = 0x370 // TArray<FVector> (Size: 0x10)
NPCAILocalNavigationTestingActor.SelfCombinedGridId = 0x380 // int32_t (Size: 0x4)
NPCAILocalNavigationTestingActor.SelfSourceGridIds = 0x388 // TArray<int32_t> (Size: 0x10)
NPCAILocalNavigationTestingActor.SelfGridSize = 0x398 // FIntVector (Size: 0xc)
NPCAILocalNavigationTestingActor.SelfCoords = 0x3a4 // FIntVector (Size: 0xc)
NPCAIMemorySystemComponent.AIOwner = 0x108 // AIController* (Size: 0x8)
NPCAIMemorySystemComponent.IsLockingGoalEnemy = 0x120 // bool (Size: 0x1)
NPCAIMemorySystemComponent.GoalEnemy = 0x128 // NPCAITargetInfo* (Size: 0x8)
NPCAIMemorySystemComponent.LastEnemy = 0x130 // NPCAITargetInfo* (Size: 0x8)
NPCAIMemorySystemComponent.LastSetGoalEnemyTime = 0x138 // float (Size: 0x4)
NPCAIMemorySystemComponent.MemoryServiceNodeName = 0x140 // FString (Size: 0x10)
NPCAIMemorySystemComponent.GoalTarget = 0x150 // NPCAIGoalTarget* (Size: 0x8)
NPCAIMemorySystemComponent.CheckCoverPointPosition = 0x158 // FVector (Size: 0xc)
NPCAIMemorySystemComponent.CurrentCoverPointID = 0x164 // int32_t (Size: 0x4)
NPCAIMemorySystemComponent.BackUpCoverPointFinder = 0x168 // FAIBackUpCoverPointFinder (Size: 0x1c)
NPCAIMemorySystemComponent.PeekCount = 0x184 // int32_t (Size: 0x4)
NPCAIMemorySystemComponent.CallUpReason = 0x188 // uint8_t (Size: 0x1)
NPCAIMemorySystemComponent.CallUpResult = 0x189 // uint8_t (Size: 0x1)
NPCAIMemorySystemComponent.LastMolotovHurttime = 0x18c // float (Size: 0x4)
NPCAIMemorySystemComponent.SightWeakenEndTime = 0x190 // float (Size: 0x4)
NPCAIMemorySystemComponent.bIsInTryLeanShoot = 0x194 // bool (Size: 0x1)
NPCAIMemorySystemComponent.PauseBehaviorEndTime = 0x198 // float (Size: 0x4)
NPCAIMemorySystemComponent.StackGunRecord = 0x19c // FAIStackGunRecord (Size: 0x44)
NPCAIMemorySystemComponent.AcceptedSceneEvtUniqueIds = 0x1e0 // TArray<int32_t> (Size: 0x10)
NPCAIMemorySystemComponent.RoundPathNodes = 0x1f0 // FAIRoundPathFindingNodes (Size: 0x80)
NPCAIMemorySystemComponent.TreasureBoxWantProtect = 0x270 // Actor* (Size: 0x8)
NPCAIMemorySystemComponent.Cache_AmbushAgainstStartPoint = 0x278 // FVector (Size: 0xc)
NPCAIMemorySystemComponent.Cache_AmbushAgainstEndPoint = 0x284 // FVector (Size: 0xc)
NPCAIMemorySystemComponent.Cache_AmbushAgainstResultPoint = 0x290 // FVector (Size: 0xc)
NPCAIMemorySystemComponent.Cache_QREResult = 0x29c // FNPCAIQueryRoundEnvironmentResult (Size: 0x5c)
NPCAIMemorySystemComponent.AIStaticComponent = 0x2f8 // ActorComponent* (Size: 0x8)
NPCAIMemorySystemComponent.AISceneEventsTriggerManager = 0x300 // AISceneEventsTriggerManager* (Size: 0x8)
NPCAIMemorySystemComponent.CachedPerceptionComponent = 0x308 // NPCAIPerceptionComponent* (Size: 0x8)
NPCAIMemorySystemComponent.MoverSystemComponent = 0x310 // NPCAIMoverSystemComponent* (Size: 0x8)
NPCAIMoverSystemComponent.bAllowStrafe = 0x108 // bool (Size: 0x1)
NPCAIMoverSystemComponent.bAllowPartialPath = 0x109 // bool (Size: 0x1)
NPCAIMoverSystemComponent.AcceptableRadius = 0x10c // float (Size: 0x4)
NPCAIMoverSystemComponent.OffsetFromCornersDistance = 0x110 // float (Size: 0x4)
NPCAIMoverSystemComponent.DisposableOffsetFromCornersDistance = 0x114 // float (Size: 0x4)
NPCAIMoverSystemComponent.bReachTestIncludesAgentRadius = 0x11c // bool (Size: 0x1)
NPCAIMoverSystemComponent.bReachTestIncludesGoalRadius = 0x11d // bool (Size: 0x1)
NPCAIMoverSystemComponent.bProjectGoalLocation = 0x11e // bool (Size: 0x1)
NPCAIMoverSystemComponent.bHandleLandedDelegate = 0x120 // bool (Size: 0x1)
NPCAIMoverSystemComponent.bEnableMoverSystem = 0x121 // bool (Size: 0x1)
NPCAIMoverSystemComponent.MovementKind = 0x122 // EENPCAIMovementKind (Size: 0x1)
NPCAIMoverSystemComponent.GotoPointDecision = 0x124 // int32_t (Size: 0x4)
NPCAIMoverSystemComponent.AvoidVolumes = 0x128 // TArray<Volume*> (Size: 0x10)
NPCAIMoverSystemComponent.DirCurPoint = 0x178 // FVector (Size: 0xc)
NPCAIMoverSystemComponent.LastMoveResult = 0x184 // EENPCAIMoveResult (Size: 0x1)
NPCAIMoverSystemComponent.CurrentSprintEngery = 0x19c // float (Size: 0x4)
NPCAIMoverSystemComponent.MoveProperty = 0x1a0 // NPCAIPropertyComponent_Move* (Size: 0x8)
NPCAIMoverSystemComponent.LocationMonitor = 0x1a8 // FAILocationMonitor (Size: 0x20)
NPCAIMoverSystemComponent.CaredActorWhenMoving = 0x1ec // TWeakObjectPtr<UObject> (Size: 0x8)
NPCAIMoverSystemComponent.CaredActorEffectRadius = 0x1f4 // float (Size: 0x4)
NPCAIMoverSystemComponent.BlendingVelocity = 0x1f8 // FVector (Size: 0xc)
NPCAIMoverSystemComponent.CheckPointCountOnPath = 0x204 // int32_t (Size: 0x4)
NPCAIMoverSystemComponent.OnAIPathChecked = 0x208 // FMulticastInlineDelegate (Size: 0x10)
NPCAIMoverSystemComponent.OnAIGoDirectlyFinished = 0x218 // FMulticastInlineDelegate (Size: 0x10)
NPCAIMoverSystemComponent.OnOutOfNavmesh = 0x228 // FMulticastInlineDelegate (Size: 0x10)
NPCAIMoverSystemComponent.bEnableDrawPathPoints = 0x238 // bool (Size: 0x1)
NPCAIMoverSystemComponent.bUseFlanking = 0x239 // bool (Size: 0x1)
NPCAIMoverSystemComponent.DangerPoint = 0x23c // FVector (Size: 0xc)
NPCAIMoverSystemComponent.DangerPointDirection = 0x248 // FVector (Size: 0xc)
NPCAIMoverSystemComponent.DangerPointEffectRadius = 0x254 // float (Size: 0x4)
NPCAIMoverSystemComponent.MaxTurnDistance = 0x25c // float (Size: 0x4)
NPCAIMoverSystemComponent.MinTurnDistance = 0x260 // float (Size: 0x4)
NPCAIMoverSystemComponent.DistanceCheck = 0x264 // float (Size: 0x4)
NPCAIMoverSystemComponent.SwayWidthCheck = 0x268 // float (Size: 0x4)
NPCAIMoverSystemComponent.SwayWidth = 0x26c // float (Size: 0x4)
NPCAIMoverSystemComponent.RandSwayWidthRate = 0x270 // float (Size: 0x4)
NPCAIMoverSystemComponent.PathOffset = 0x274 // float (Size: 0x4)
NPCAIMoverSystemComponent.SampleTimes = 0x278 // int32_t (Size: 0x4)
NPCAIMoverSystemComponent.RegionWhereNavLinksNeedDisable = 0x27c // int32_t (Size: 0x4)
NPCAIMoverSystemComponent.AIDoorOpenerComponent = 0x280 // ActorComponent* (Size: 0x8)
NPCAIMoverSystemComponent.AIPoseComponent = 0x288 // ActorComponent* (Size: 0x8)
NPCAIMoverSystemComponent.Blending_Count = 0x290 // int32_t (Size: 0x4)
NPCAIMoverSystemComponent.Blending_Time = 0x294 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.PerceptionTag1 = 0x1c0 // FString (Size: 0x10)
NPCAIMultiTargetSelectorComponent.PerceptionTag2 = 0x1d0 // FString (Size: 0x10)
NPCAIMultiTargetSelectorComponent.PerceptionTag3 = 0x1e0 // FString (Size: 0x10)
NPCAIMultiTargetSelectorComponent.DistanceToPercActor = 0x1f0 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.DistanceToPercLoc = 0x1f4 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.PerceptionActor = 0x1f8 // Actor* (Size: 0x8)
NPCAIMultiTargetSelectorComponent.PerceptionStimulus = 0x200 // FAIStimulus (Size: 0x3c)
NPCAIMultiTargetSelectorComponent.bIsTeamEnemy = 0x23c // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.bIsTeamFriendly = 0x23d // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.bIsGroupEnemy = 0x23e // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.bIsGroupAlly = 0x23f // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.bIsSounder = 0x240 // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.SounderThrower = 0x248 // Actor* (Size: 0x8)
NPCAIMultiTargetSelectorComponent.bIsCheatGhost = 0x250 // bool (Size: 0x1)
NPCAIMultiTargetSelectorComponent.LastCalculateWarnPlayerTime = 0x254 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastCalculateGoalEnemyTime = 0x258 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastCalculateGoalPointTime = 0x25c // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.NextLeanAutoRelaxTime = 0x260 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastTodoHearingTime = 0x264 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastFireToMePerson = 0x270 // Actor* (Size: 0x8)
NPCAIMultiTargetSelectorComponent.LastFireToMeTime = 0x278 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastShootMePerson = 0x280 // Actor* (Size: 0x8)
NPCAIMultiTargetSelectorComponent.LastShootMePersonLocation = 0x288 // FVector (Size: 0xc)
NPCAIMultiTargetSelectorComponent.LastShootMeSelfLocation = 0x294 // FVector (Size: 0xc)
NPCAIMultiTargetSelectorComponent.LastShootMeDamageValue = 0x2a0 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.LastBeenShootTime = 0x2a4 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.BeHitCount = 0x2a8 // FAIShotCountStat (Size: 0x10)
NPCAIMultiTargetSelectorComponent.TEMPORARY_ENEMY_DURATION_TIME = 0x2b8 // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.SWITCH_TO_ENEMY_IF_ATK_INRADIUS = 0x2bc // float (Size: 0x4)
NPCAIMultiTargetSelectorComponent.SWITCH_TO_ENEMY_IF_NEARBY_BETRAYER = 0x2c0 // float (Size: 0x4)
NPCAIMultiTargetSystemComponent.bDebugSuspectedPoint = 0x108 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.bDebugShootOffsetScope = 0x109 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.TimeOfShootOffsetScopeDraw = 0x10c // float (Size: 0x4)
NPCAIMultiTargetSystemComponent.bDebugShootScopeTestPoints = 0x110 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.bLogGoalEnemyScore = 0x111 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.bWantCalculateGoalTargetPoint = 0x112 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.bWantCalculateGoalEnemy = 0x113 // bool (Size: 0x1)
NPCAIMultiTargetSystemComponent.ZoneGroupInfo = 0x118 // NPCAIZoneGroupInfo* (Size: 0x8)
NPCAIMultiTargetSystemComponent.DynamicGroupId = 0x120 // int32_t (Size: 0x4)
NPCAIMultiTargetSystemComponent.AllTargetInfoList = 0x128 // TArray<NPCAITargetInfo*> (Size: 0x10)
NPCAIMultiTargetSystemComponent.LastChangeEnemyTime = 0x138 // float (Size: 0x4)
NPCAIMultiTargetSystemComponent.LastWantCalcEnemyTime = 0x13c // float (Size: 0x4)
NPCAIMultiTargetSystemComponent.DefaultTargetScoreCalculateBlueprint = 0x148 // ClassProperty (Size: 0x8)
NPCAIMultiTargetSystemComponent.TargetScoreCalculateOverrideBlueprint = 0x150 // ClassProperty (Size: 0x8)
NPCAIMultiTargetSystemComponent.CachedHatredList = 0x158 // TArray<NPCAITargetInfo*> (Size: 0x10)
NPCAIMultiTargetSystemComponent.MemoryComponent = 0x168 // NPCAIMemorySystemComponent* (Size: 0x8)
NPCAIMultiTargetSystemComponent.PerceptionComponent = 0x170 // NPCAIPerceptionComponent* (Size: 0x8)
NPCAIMultiTargetSystemComponent.AIStaticComponent = 0x178 // ActorComponent* (Size: 0x8)
NPCAIMultiTargetSystemComponent.SharedInfo = 0x180 // NPCAIGlobalSharedInfo* (Size: 0x8)
NPCAIMultiTargetSystemComponent.MindProps = 0x188 // NPCAIPropertyComponent_Mind* (Size: 0x8)
NPCAIMultiTargetSystemComponent.HearProps = 0x190 // NPCAIPropertyComponent_Hearing* (Size: 0x8)
NPCAIMultiTargetSystemComponent.AimingProps = 0x198 // NPCAIPropertyComponent_Aiming* (Size: 0x8)
NPCAIMultiTargetSystemComponent.HealthProps = 0x1a0 // NPCAIPropertyComponent_Health* (Size: 0x8)
NPCAIMultiTargetSystemComponent.GrenadeProps = 0x1a8 // NPCAIPropertyComponent_Grenade* (Size: 0x8)
NPCAIMultiTargetSystemComponent.DamageProps = 0x1b0 // NPCAIPropertyComponent_Damage* (Size: 0x8)
NPCAIMultiTargetSystemComponent.CD_CHANGE_GOALENEMY_IF_BOTH_NOT_SEE = 0x1b8 // float (Size: 0x4)
NPCAINavMeshManager.SkeletonBuildSettings = 0x4a8 // FNavSkeletonBuildSettings (Size: 0x8c)
NPCAINavMeshManager.NavSkeletonPoints = 0x538 // TArray<FNavSkeletonPoint> (Size: 0x10)
NPCAINavMeshManager.NavSkeletonData = 0x548 // FNavSkeletonData (Size: 0x60)
NPCAINavMeshManager.CachedNavLinkProxies = 0x5b0 // TArray<NPCAINavLinkProxy*> (Size: 0x10)
NPCAINavMeshManager.SkeletonForcePoints = 0x5c0 // TSet<...> (Size: 0x50)
NPCAINavMeshManager.PlatformBuildTemplates = 0x610 // TMap<...> (Size: 0x50)
NPCAINavMeshManager.PlatformBuildDatas = 0x660 // TMap<...> (Size: 0x50)
NPCAINavMeshManager.LinkLines = 0x6b0 // TMap<...> (Size: 0x50)
NPCAINavMeshManager.PlatformOctreeOrigin = 0x700 // FVector (Size: 0xc)
NPCAINavMeshManager.PlatformOctreeExtent = 0x70c // float (Size: 0x4)
NPCAINavMeshManager.PlatformMinimumUpdateInterval = 0x710 // float (Size: 0x4)
NPCAINavMeshTestingActor.ToWallCylinderHeight = 0x350 // float (Size: 0x4)
NPCAINavMeshTestingActor.RadiusMultiplier = 0x354 // float (Size: 0x4)
NPCAINavMeshTestingActor.DistanceHeightMultiplier = 0x358 // float (Size: 0x4)
NPCAINavMeshTestingActor.DistanceLineThickness = 0x35c // float (Size: 0x4)
NPCAINavMeshTestingActor.ShowGradientThreshold = 0x360 // float (Size: 0x4)
NPCAINavMeshTestingActor.GradientZOffset = 0x364 // float (Size: 0x4)
NPCAINavMeshTestingActor.UpdateGradientFlowAnimInterval = 0x368 // float (Size: 0x4)
NPCAINavMeshTestingActor.ShowDivergenceThreshold = 0x370 // float (Size: 0x4)
NPCAINavMeshTestingActor.DivergenceHeightMultiplier = 0x374 // float (Size: 0x4)
NPCAINavMeshTestingActor.DivergenceLineThickness = 0x378 // float (Size: 0x4)
NPCAINavMeshTestingActor.ConnectionLineThickness = 0x37c // float (Size: 0x4)
NPCAINavMeshTestingActor.SimlifiedConnectionZOffset = 0x380 // float (Size: 0x4)
NPCAINavMeshTestingActor.ShowCoverageLevel = 0x384 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.ShowWallLevel = 0x388 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.bEnableRefreshData = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawSamplePoints = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawWallCountMap = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawDistanceMap = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawGradient = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bShowAllGradient = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawGradientFlowAnim = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawCoverage = 0x38c // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bAlwaysShowMainCoverage = 0x38d // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawOriginalConnection = 0x38d // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawSimplifiedConnection = 0x38d // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bOnlyDrawMainSimplifiedConnection = 0x38d // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.NearestMainCoverageSampleIndex = 0x390 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.PolyMeshCount = 0x394 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.PolylineCount = 0x398 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.CurrentTileIndex = 0x39c // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.ClosestPointOnWall = 0x3a0 // FVector (Size: 0xc)
NPCAINavMeshTestingActor.NeighbourWallEdgeCount = 0x3c0 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.DistanceToWall = 0x3c4 // float (Size: 0x4)
NPCAINavMeshTestingActor.SamplePointCountStat = 0x3d0 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.WallStat = 0x3e0 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.DistanceStat = 0x3f0 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.DivergenceStat = 0x400 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.FilteredDistanceStat = 0x410 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.FilteredDivergenceStat = 0x420 // FVector4 (Size: 0x10)
NPCAINavMeshTestingActor.CoverageStats = 0x430 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.ConnectionStats = 0x444 // int32_t (Size: 0x4)
NPCAINavMeshTestingActor.MaxPathLength = 0x478 // float (Size: 0x4)
NPCAINavMeshTestingActor.BuildSettings = 0x47c // FNavSkeletonBuildSettings (Size: 0x8c)
NPCAINavMeshTestingActor.bDrawPersistent = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawForcePoint = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawTextInfo = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawProtection = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawNearestPoint = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawPointNeighbours = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawFindResultPoints = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.bDrawOutDoorsPoints = 0x508 // uint8_t (Size: 0x1)
NPCAINavMeshTestingActor.NavSkeletonPoint = 0x510 // FNavSkeletonPoint (Size: 0xa0)
NPCAINavMeshTestingActor.TargetNavSkeletonPoint = 0x5b0 // FNavSkeletonPoint (Size: 0xa0)
NPCAINavMeshTestingActor.FoundPointIDs = 0x650 // TArray<int32_t> (Size: 0x10)
NPCAINavMeshTestingActor.CostLimit = 0x660 // float (Size: 0x4)
NPCAINavMeshTestingActor.HalfAngleOfView = 0x664 // float (Size: 0x4)
NPCAINavMeshTestingActor.TargetDebugActor = 0x668 // Actor* (Size: 0x8)
NPCAINavModifierVolume.AffectedPolygons = 0x360 // TArray<int64_t> (Size: 0x10)
NPCAINavModifierVolume.AffectedNavLinks = 0x370 // TArray<NPCAINavLinkProxy*> (Size: 0x10)
NPCAINavMovablePlatformComponent.MinUpdateDist = 0x128 // float (Size: 0x4)
NPCAINavPlatformBuildConfig.FirstOffset = 0x0 // FVector (Size: 0xc)
NPCAINavPlatformBuildConfig.AdjustOffset = 0xc // FVector (Size: 0xc)
NPCAINavPlatformBuildConfig.WrapBoxExtent = 0x18 // FVector (Size: 0xc)
NPCAINavPlatformBuildConfig.CeilingHeight = 0x24 // float (Size: 0x4)
NPCAINavPlatformBuildConfig.AutoBuildLinkLine = 0x28 // bool (Size: 0x1)
NPCAINavPlatformBuildConfig.LinkLineLengthDefault = 0x2c // float (Size: 0x4)
NPCAINavPlatformBuildConfig.LinkPointMinIntervalDefault = 0x30 // float (Size: 0x4)
NPCAINavPlatformBuildConfig.LinkLineProjectHeightDefault = 0x34 // float (Size: 0x4)
NPCAINavPlatformBuildConfig.LinkLineHitIgnoreClassList = 0x38 // TArray<ClassProperty> (Size: 0x10)
NPCAINavPlatformBuildData.NavMeshBoundsVolumeData = 0x0 // FNPCAINavPlatformNavMeshBoundsVolumeData (Size: 0x30)
NPCAINavPlatformBuildData.PlatformRegions = 0x30 // TArray<FNPCAINavPlatformRegion> (Size: 0x10)
NPCAINavPlatformBuildData.MaxLinkLineLength = 0x40 // float (Size: 0x4)
NPCAINavPlatformBuildTemplate.Platform = 0x0 // Actor* (Size: 0x8)
NPCAINavPlatformBuildTemplate.ConfigID = 0x8 // int32_t (Size: 0x4)
NPCAINavPlatformComponent.Pid = 0xf8 // int64_t (Size: 0x8)
NPCAINavPlatformComponent.TemplateID = 0x100 // int32_t (Size: 0x4)
NPCAINavPlatformComponent.AffectedBottomHeight = 0x104 // float (Size: 0x4)
NPCAINavPlatformComponent.OriginLoc = 0x108 // FVector (Size: 0xc)
NPCAINavPlatformComponent.OriginRot = 0x114 // FRotator (Size: 0xc)
NPCAINavPlatformComponent.bDebugDraw = 0x120 // bool (Size: 0x1)
NPCAINavPlatformComponent.bDebugDrawBaseInfo = 0x121 // bool (Size: 0x1)
NPCAINavPlatformComponent.bDebugDrawLinkLines = 0x122 // bool (Size: 0x1)
NPCAINavPlatformComponent.bDebugDrawPlatformArea = 0x123 // bool (Size: 0x1)
NPCAINavPlatformComponent.bDebugDrawPolys = 0x124 // bool (Size: 0x1)
NPCAINavPlatformLinkLine.LinkLineStart = 0x0 // FVector (Size: 0xc)
NPCAINavPlatformLinkLine.LinkLineEnd = 0xc // FVector (Size: 0xc)
NPCAINavPlatformLinkLine.LinkLineDir = 0x18 // FVector (Size: 0xc)
NPCAINavPlatformLinkLine.ProjectHeight = 0x24 // float (Size: 0x4)
NPCAINavPlatformLinkLine.PathInfos = 0x28 // TMap<...> (Size: 0x50)
NPCAINavPlatformNavMeshBoundsVolumeData.NavMeshBoundsVolume = 0x0 // NavMeshBoundsVolume* (Size: 0x8)
NPCAINavPlatformNavMeshBoundsVolumeData.Location = 0x8 // FVector (Size: 0xc)
NPCAINavPlatformNavMeshBoundsVolumeData.Extent = 0x14 // FVector (Size: 0xc)
NPCAINavPlatformNavMeshBoundsVolumeData.NewPlatformLoc = 0x20 // FVector (Size: 0xc)
NPCAINavPlatformPathInfo.PathPoints = 0x0 // TArray<FVector> (Size: 0x10)
NPCAINavPlatformPathInfo.PathPointPolyRefs = 0x10 // TArray<uint64_t> (Size: 0x10)
NPCAINavPlatformPathInfo.PathCost = 0x20 // float (Size: 0x4)
NPCAINavPlatformPathInfo.PathCorridor = 0x28 // TArray<uint64_t> (Size: 0x10)
NPCAINavPlatformPathInfo.PathCorridorCost = 0x38 // TArray<float> (Size: 0x10)
NPCAINavPlatformRegion.LinkLineIDs = 0x0 // TMap<...> (Size: 0x50)
NPCAINavPlatformRegion.PolyRefs = 0x50 // TSet<...> (Size: 0x50)
NPCAINavPlatformRegion.LinkLinesNum = 0xa0 // int32_t (Size: 0x4)
NPCAINavPlatformSystem.Platforms = 0x1b0 // TMap<...> (Size: 0x50)
NPCAINavPlatformSystem.PlatformComponents = 0x280 // TMap<...> (Size: 0x50)
NPCAINavPlatformSystem.PlatformComponentInfos = 0x2d0 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.AreaIDToPerceptibleTile = 0x78 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.PerceptibleTileToNavCostDescriptor = 0xc8 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.BurningPolyRefs = 0x118 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.TearGasPolyRefs = 0x168 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.TripMinePolyRefs = 0x1b8 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.ClaymorePolyRefs = 0x208 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.ParadropPolyRefs = 0x258 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.ObjectToNavModifierVolume = 0x2a8 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.ObjectToNavCostModifier = 0x2f8 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.InvalidNavCostModifiers = 0x348 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
NPCAINavRuntimeSystem.AvoidPolyRefs = 0x358 // TMap<...> (Size: 0x50)
NPCAINavRuntimeSystem.CachedCoverSystem = 0x3a8 // CoverSystem* (Size: 0x8)
NPCAINavRuntimeSystem.CachedNavMeshManager = 0x3b0 // NPCAINavMeshManager* (Size: 0x8)
NPCAINavSkeletonBuilder.WorldContextObject = 0x0 // Object* (Size: 0x8)
NPCAINavSkeletonBuilder.World = 0xb8 // World* (Size: 0x8)
NPCAINavSkeletonBuilder.MainNavData = 0xc8 // RecastNavMesh* (Size: 0x8)
NPCAINavSkeletonBuilder.NavMeshManager = 0xd0 // NPCAINavMeshManager* (Size: 0x8)
NPCAINavSkeletonBuilder.LinkProxies = 0xe0 // TArray<NPCAINavLinkProxy*> (Size: 0x10)
NPCAINavSkeletonForcePoint.SceneComponent = 0x310 // SceneComponent* (Size: 0x8)
NPCAIPeekPointAsyncTask.OnSuccess = 0x40 // FMulticastInlineDelegate (Size: 0x10)
NPCAIPeekPointAsyncTask.OnFail = 0x50 // FMulticastInlineDelegate (Size: 0x10)
NPCAIPeekPointAsyncTask.TargetPoint = 0x60 // FVector (Size: 0xc)
NPCAIPeekPointAsyncTask.DangerPoint = 0x6c // FVector (Size: 0xc)
NPCAIPeekPointAsyncTask.PeekLength = 0x78 // float (Size: 0x4)
NPCAIPeekPointAsyncTask.PeekPoint = 0x7c // FVector (Size: 0xc)
NPCAIPeekPointAsyncTask.bWillExpose = 0x88 // bool (Size: 0x1)
NPCAIPeekPointResult.PeekPoint = 0x0 // FVector (Size: 0xc)
NPCAIPeekPointResult.bWillExpose = 0xc // bool (Size: 0x1)
NPCAIPerceptionAssistActor.MapInfo = 0x310 // FAIGrassMapInfo (Size: 0x88)
NPCAIPerceptionAssistActor.FoliageGrassBlockList = 0x398 // TArray<FAIFoliageGrassBlock> (Size: 0x10)
NPCAIPerceptionAssistActor.LandscapeGrassBlockList = 0x3a8 // TArray<FAILandscapeGrassBlock> (Size: 0x10)
NPCAIPerceptionAssistActor.GrassBlockAssets = 0x3b8 // TArray<FAIGrassBlock> (Size: 0x10)
NPCAIPerceptionAssistActor.bIsDebugAIGrass = 0x3c8 // bool (Size: 0x1)
NPCAIPerceptionAssistActor.DebugAIGrassBox = 0x3c9 // EEnumAIGrassDebugBox (Size: 0x1)
NPCAIPerceptionAssistActor.FindNearbyGrassRadiusBuffer = 0x3e0 // float (Size: 0x4)
NPCAIPerceptionAssistActor.SlowdownEdgePercent = 0x3e4 // float (Size: 0x4)
NPCAIPerceptionComponent.EnabledRecedeSightWhileRotate = 0x1d8 // bool (Size: 0x1)
NPCAIPerceptionComponent.RateDrawLine = 0x1dc // float (Size: 0x4)
NPCAIPerceptionComponent.bIsDebugSightRadius = 0x1e0 // bool (Size: 0x1)
NPCAIPerceptionComponent.bIsLogShootPart = 0x1e1 // bool (Size: 0x1)
NPCAIPerceptionComponent.bIsDebugFogRange = 0x1e2 // bool (Size: 0x1)
NPCAIPerceptionComponent.bEnabledDebugCanSeePoint = 0x1e3 // bool (Size: 0x1)
NPCAIPerceptionComponent.LastTimeCheckFlashBlocks = 0x1e4 // float (Size: 0x4)
NPCAIPerceptionComponent.FlashLightPos = 0x1e8 // FVector (Size: 0xc)
NPCAIPerceptionComponent.CheckAutoLeanInterval = 0x1f4 // float (Size: 0x4)
NPCAIPerceptionComponent.SightAngleScaleValue = 0x1f8 // float (Size: 0x4)
NPCAIPerceptionComponent.SightRadiusScaleValue = 0x1fc // float (Size: 0x4)
NPCAIPerceptionComponent.HearRadiusScaleValue = 0x200 // float (Size: 0x4)
NPCAIPerceptionComponent.SightCheckInterval = 0x20c // float (Size: 0x4)
NPCAIPerceptionComponent.AIOwnerPawn = 0x210 // Character* (Size: 0x8)
NPCAIPerceptionComponent.WeaponChannel = 0x218 // EENPCAISenseChannel (Size: 0x1)
NPCAIPerceptionComponent.AISightChannel = 0x219 // EENPCAISenseChannel (Size: 0x1)
NPCAIPerceptionComponent.PerceptionAssistActor = 0x220 // NPCAIPerceptionAssistActor* (Size: 0x8)
NPCAIPerceptionComponent.PerceptionDynamicActor = 0x228 // NPCAIPerceptionDynamicActor* (Size: 0x8)
NPCAIPerceptionComponent.OwnerMoverComponent = 0x230 // NPCAIMoverSystemComponent* (Size: 0x8)
NPCAIPerceptionComponent.OwnerMemoryComponent = 0x238 // NPCAIMemorySystemComponent* (Size: 0x8)
NPCAIPerceptionComponent.OwnerMultiTargetComponent = 0x240 // NPCAIMultiTargetSystemComponent* (Size: 0x8)
NPCAIPerceptionComponent.ShootProps = 0x248 // NPCAIPropertyComponent_Shoot* (Size: 0x8)
NPCAIPerceptionComponent.LookProps = 0x250 // NPCAIPropertyComponent_Look* (Size: 0x8)
NPCAIPerceptionComponent.AIFireComponent = 0x258 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.AIStaticsComponent = 0x260 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.AIPoseComponent = 0x268 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.IKComponent = 0x270 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.AISenseAbilityComponent = 0x278 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.AISharedInfo = 0x280 // NPCAIGlobalSharedInfo* (Size: 0x8)
NPCAIPerceptionComponent.AITurnComponent = 0x288 // ActorComponent* (Size: 0x8)
NPCAIPerceptionComponent.NextCheckLeanCanShootTime = 0x290 // float (Size: 0x4)
NPCAIPerceptionComponent.SelfIKFootOffsets = 0x294 // float (Size: 0x4)
NPCAIPerceptionComponent.TargetIKFootOffsets = 0x298 // float (Size: 0x4)
NPCAIPerceptionComponent.TurnSightWeakenScale = 0x29c // float (Size: 0x4)
NPCAIPerceptionComponent.LastTimeRecoverSight = 0x2a0 // float (Size: 0x4)
NPCAIPerceptionComponent.AutoLeanType = 0x2a4 // EEAILeanType (Size: 0x1)
NPCAIPerceptionComponent.AIPoseType = 0x2a5 // EEAIPose (Size: 0x1)
NPCAIPerceptionComponent.TargetPoseType = 0x2a6 // EEAIPose (Size: 0x1)
NPCAIPerceptionComponent.AILeanType = 0x2a7 // EEAILeanType (Size: 0x1)
NPCAIPerceptionComponent.bInitAIGrassElements = 0x2a8 // bool (Size: 0x1)
NPCAIPerceptionComponent.AIGrassElements = 0x2b0 // TArray<FAIGrassOctreeElement> (Size: 0x10)
NPCAIPerceptionDynamicActor.DynamicAreaList = 0x310 // TArray<FAIBlockArea> (Size: 0x10)
NPCAIPerceptionDynamicActor.SenseFlashBlockList = 0x320 // TArray<FAISenseFlashBlock> (Size: 0x10)
NPCAIPerceptionDynamicActor.bDebugBlock = 0x330 // bool (Size: 0x1)
NPCAIPerceptionDynamicActor.IndexOfUpdateFlashBlock = 0x334 // int32_t (Size: 0x4)
NPCAIPerceptionDynamicActor.IndexOfCheckEnemyFlashBlock = 0x338 // int32_t (Size: 0x4)
NPCAIPerceptionDynamicActor.SevereLightBurnDistanceCoef = 0x33c // float (Size: 0x4)
NPCAIPerceptionDynamicActor.ModerateLightBurnDistanceCoef = 0x340 // float (Size: 0x4)
NPCAIPerceptionDynamicActor.MildLightBurnDistanceCoef = 0x344 // float (Size: 0x4)
NPCAIPortraitToIDTableRow.PortraitClass = 0x8 // TSoftClassPtr<UObject> (Size: 0x28)
NPCAIPortraitToIDTableRow.AIID = 0x30 // int64_t (Size: 0x8)
NPCAIProfile.FactionClass = 0x28 // ClassProperty (Size: 0x8)
NPCAIProfile.RoleClass = 0x30 // ClassProperty (Size: 0x8)
NPCAIProfileBaseComponent.PropertyProfile = 0x28 // NPCAIPropertyProfileBase* (Size: 0x8)
NPCAIProfileBaseComponent.Owner = 0x30 // Actor* (Size: 0x8)
NPCAIProfileCover.Ars = 0x0 // TArray<uint8_t> (Size: 0x10)
NPCAIProfileCover.CoverName = 0x18 // FString (Size: 0x10)
NPCAIProfileCoverTag.ProfileClass = 0x0 // ClassProperty (Size: 0x8)
NPCAIProfileCoverTag.ProfileType = 0x8 // EEAIProfileType (Size: 0x1)
NPCAIProfileCoverTag.VarName = 0xc // FName (Size: 0x8)
NPCAIPropertyComponent_AIType.Modifier_AIType = 0x38 // NPCAIModifierComponent_AIType* (Size: 0x8)
NPCAIPropertyComponent_Damage.DamageLimitEnabledForAIModifier = 0x38 // bool (Size: 0x1)
NPCAIPropertyComponent_Damage.DamageLimitEnabledForAIModifierFlag = 0x39 // bool (Size: 0x1)
NPCAIPropertyProfileBase.PropertyComponentClass = 0x28 // ClassProperty (Size: 0x8)
NPCAIPropertyProfileBase.AIProfileType = 0x30 // EEAIProfileType (Size: 0x1)
NPCAIQueryRoundEnvironmentAsyncTask.OnSuccess = 0x40 // FMulticastInlineDelegate (Size: 0x10)
NPCAIQueryRoundEnvironmentAsyncTask.OnFail = 0x50 // FMulticastInlineDelegate (Size: 0x10)
NPCAIQueryRoundEnvironmentAsyncTask.EnemyLocation = 0x60 // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentAsyncTask.LRDistance = 0x6c // float (Size: 0x4)
NPCAIQueryRoundEnvironmentAsyncTask.FBDistance = 0x70 // float (Size: 0x4)
NPCAIQueryRoundEnvironmentAsyncTask.bCheckLRDefense = 0x74 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentAsyncTask.bCheckLRAttack = 0x75 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.AILocation = 0x0 // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.EnemyLocation = 0xc // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.LCanMove = 0x18 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.LMovePoint = 0x1c // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.RCanMove = 0x28 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.RMovePoint = 0x2c // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.FCanMove = 0x38 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.FMovePoint = 0x3c // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.BCanMove = 0x48 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.BMovePoint = 0x4c // FVector (Size: 0xc)
NPCAIQueryRoundEnvironmentResult.LCanDefense = 0x58 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.RCanDefense = 0x59 // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.LCanAttack = 0x5a // bool (Size: 0x1)
NPCAIQueryRoundEnvironmentResult.RCanAttack = 0x5b // bool (Size: 0x1)
NPCAIRecastNavMesh.HNavActor = 0x5c8 // NPCAIHNavActor* (Size: 0x8)
NPCAIRoleComponent.PropertyProfiles = 0x108 // TArray<NPCAIModifierProfile*> (Size: 0x10)
NPCAIRollDecisionStruct.Decision = 0x8 // EENPCAIDecision (Size: 0x1)
NPCAIRollDecisionStruct.BaseTendency = 0xc // float (Size: 0x4)
NPCAIRollDecisionStruct.BasePerceive = 0x10 // float (Size: 0x4)
NPCAISceneEventInfo.UniqueID = 0x0 // int32_t (Size: 0x4)
NPCAISceneEventInfo.eventId = 0x4 // EENPCAISceneEventID (Size: 0x1)
NPCAISceneEventInfo.StartTime = 0x8 // float (Size: 0x4)
NPCAISceneEventInfo.EndTime = 0xc // float (Size: 0x4)
NPCAISceneEventInfo.ValidScope = 0x10 // float (Size: 0x4)
NPCAISceneEventInfo.TriggerLocation = 0x14 // FVector (Size: 0xc)
NPCAISceneEventInfo.AIIDs = 0x20 // TArray<int64_t> (Size: 0x10)
NPCAISceneEventInfo.AIPathGroupIDs = 0x30 // TArray<int64_t> (Size: 0x10)
NPCAISceneEventTableRow.eventId = 0x8 // EENPCAISceneEventID (Size: 0x1)
NPCAISceneEventTableRow.ValidTime = 0xc // float (Size: 0x4)
NPCAISceneEventTableRow.ValidScope = 0x10 // float (Size: 0x4)
NPCAISceneEventTableRow.AIIDs = 0x18 // TArray<int64_t> (Size: 0x10)
NPCAISceneEventTableRow.PathGroupIDs = 0x28 // TArray<int64_t> (Size: 0x10)
NPCAISceneEventTableRow.Comments = 0x38 // FString (Size: 0x10)
NPCAISenseConfig_ComingExplosion.Implementation = 0x48 // ClassProperty (Size: 0x8)
NPCAISenseConfig_ComingExplosion.AwareRange = 0x50 // float (Size: 0x4)
NPCAISenseConfig_ComingExplosion.DetectionByAffiliation = 0x54 // FAISenseAffiliationFilter (Size: 0x4)
NPCAISenseConfig_Damage.Implementation = 0x48 // ClassProperty (Size: 0x8)
NPCAISenseConfig_Hearing.IsDebugHearingScope = 0x60 // bool (Size: 0x1)
NPCAISenseConfig_Sight.AISightUseChannel = 0x70 // EENPCAISenseChannel (Size: 0x1)
NPCAISenseConfig_Sight.WeaponUseChannel = 0x71 // EENPCAISenseChannel (Size: 0x1)
NPCAISenseEvent_ComingExplosion.Event = 0x28 // FNPCAIComingExplosionEvent (Size: 0x30)
NPCAISenseEvent_Damage.Event = 0x28 // FNPCAIDamageEvent (Size: 0x38)
NPCAISense_ComingExplosion.ExplosionEvents = 0x80 // TArray<FNPCAIComingExplosionEvent> (Size: 0x10)
NPCAISense_Damage.RegisteredEvents = 0x80 // TArray<FNPCAIDamageEvent> (Size: 0x10)
NPCAISense_Hearing.NoiseMakerMap = 0xf0 // TMap<...> (Size: 0x50)
NPCAISpawnPoint.bCanBePlacedOnIsolateRegion = 0x338 // bool (Size: 0x1)
NPCAISteepZoneDeleter.WorldContextObject = 0x0 // Object* (Size: 0x8)
NPCAISteepZoneDeleter.World = 0x20 // World* (Size: 0x8)
NPCAISteepZoneDeleter.MainNavData = 0x30 // RecastNavMesh* (Size: 0x8)
NPCAISteepZoneDeleter.NavMeshManager = 0x38 // NPCAINavMeshManager* (Size: 0x8)
NPCAISteepZoneTestingActor.Settings = 0x350 // FSteepZoneDeleteSettings (Size: 0x34)
NPCAISteepZoneTestingActor.Deleter = 0x390 // FNPCAISteepZoneDeleter (Size: 0x180)
NPCAISteepZoneTestingActor.PolyZOffset = 0x510 // float (Size: 0x4)
NPCAISteepZoneTestingActor.NormalScaling = 0x514 // float (Size: 0x4)
NPCAISteepZoneTestingActor.NormalThickness = 0x518 // float (Size: 0x4)
NPCAISteepZoneTestingActor.PolyNormalIncludedAngleTolerance = 0x51c // float (Size: 0x4)
NPCAISteepZoneTestingActor.PointNormalIncludedAngleTolerance = 0x520 // float (Size: 0x4)
NPCAISteepZoneTestingActor.DisplayableSteepDensity = 0x524 // float (Size: 0x4)
NPCAISteepZoneTestingActor.bDrawNavMeshPoly = 0x528 // bool (Size: 0x1)
NPCAISteepZoneTestingActor.bDrawDetailTriangle = 0x529 // bool (Size: 0x1)
NPCAISteepZoneTestingActor.bDrawDetailTriangleNormal = 0x52a // bool (Size: 0x1)
NPCAISteepZoneTestingActor.bDrawSamplePoint = 0x52b // bool (Size: 0x1)
NPCAISteepZoneTestingActor.bDrawSamplePointNormal = 0x52c // bool (Size: 0x1)
NPCAISteepZoneTestingActor.bDrawSteepZone = 0x52d // bool (Size: 0x1)
NPCAISubSystemComponent.OwnerPawn = 0xf8 // Character* (Size: 0x8)
NPCAISubSystemComponent.OwnerController = 0x100 // AIController* (Size: 0x8)
NPCAITacticSystemComponent.OccupyPointID = 0x108 // int32_t (Size: 0x4)
NPCAITacticSystemComponent.TimeGetEnemyList = 0x10c // float (Size: 0x4)
NPCAITacticSystemComponent.CoverSystem = 0x110 // CoverSystem* (Size: 0x8)
NPCAITacticSystemComponent.TacticSystemActor = 0x118 // TacticSystemActor* (Size: 0x8)
NPCAITargetInfo.BodyPartsInArmor = 0x60 // TArray<EEAIBodyPartType> (Size: 0x10)
NPCAITargetInfo.LastCalculateBodyPartsInArmorTime = 0x70 // float (Size: 0x4)
NPCAITargetInfo.Person = 0x2c8 // Actor* (Size: 0x8)
NPCAITargetInfo.AIPawn = 0x2d0 // Actor* (Size: 0x8)
NPCAITargetInfo.EnemyGroupSingleInfo = 0x2d8 // NPCAIEnemyGroupSingleInfo* (Size: 0x8)
NPCAITargetInfo.LookProps = 0x2e0 // NPCAIPropertyComponent_Look* (Size: 0x8)
NPCAITargetInfo.AimingProps = 0x2e8 // NPCAIPropertyComponent_Aiming* (Size: 0x8)
NPCAITargetInfo.VisibileOnlyBySense = 0x2f0 // EEAIEnemyVisibilityType (Size: 0x1)
NPCAITargetInfoBase.FirstTimeSeen = 0x28 // float (Size: 0x4)
NPCAITargetInfoBase.TimeToForgorAboutEnemySec = 0x2c // float (Size: 0x4)
NPCAITargetInfoBase.BeFireCount = 0x30 // FAIShotCountStat (Size: 0x10)
NPCAITargetInfoBase.BeHitCount = 0x40 // FAIShotCountStat (Size: 0x10)
NPCAITargetInfoBase.EnemyStartSeenTime = 0x50 // float (Size: 0x4)
NPCAITargetInfoBase.EnemyLastSeenTime = 0x54 // float (Size: 0x4)
NPCAITargetInfoBase.EnemyLastKnowTime = 0x58 // float (Size: 0x4)
NPCAITeam.AllyBeHitCount = 0x38 // FAIShotCountStat (Size: 0x10)
NPCAITeam.AllyList = 0x48 // TArray<Actor*> (Size: 0x10)
NPCAITeam.PlayerAllyList = 0x58 // TArray<Actor*> (Size: 0x10)
NPCAITeam.EnemyInfoList = 0x68 // TArray<NPCAIEnemyGroupSingleInfo*> (Size: 0x10)
NPCAITeam.NeutralList = 0x78 // TArray<Actor*> (Size: 0x10)
NPCAITeam.SuspectedPoints = 0x88 // TArray<NPCAIAttentionPoint*> (Size: 0x10)
NPCAITeam.AllyDeathList = 0x98 // TArray<FAIGroupAllyDeathInfo> (Size: 0x10)
NPCAITeam.GroupRequestController = 0xa8 // NPCAIGroupRequestController* (Size: 0x8)
NPCAITeam.FactionComponent = 0xb0 // ActorComponent* (Size: 0x8)
NPCAITestingActor.CapsuleComponent = 0x310 // CapsuleComponent* (Size: 0x8)
NPCAITestingActor.NavAgentProps = 0x318 // FNavAgentProperties (Size: 0x30)
NPCAITestingActor.bEnableDrawing = 0x348 // bool (Size: 0x1)
NPCAITestingActor.DrawDistanceLimit = 0x34c // float (Size: 0x4)
NPCAIThrowSystem.INVALID_THROW_ANGLE_BP = 0x30 // float (Size: 0x4)
NPCAIWeaponConfigTableRow.WeaponId = 0x8 // int64_t (Size: 0x8)
NPCAIWeaponConfigTableRow.FireIntervalMin = 0x10 // float (Size: 0x4)
NPCAIWeaponConfigTableRow.FireIntervalMax = 0x14 // float (Size: 0x4)
NPCAIZoneGroupInfo.FactionType = 0xc0 // int32_t (Size: 0x4)
NPCAIZoneGroupInfo.GroupType = 0xc4 // int32_t (Size: 0x4)
NPCAIZoneGroupInfo.SquadID = 0xc8 // int32_t (Size: 0x4)
NPCAIZoneGroupInfo.DynamicGroupList = 0xd0 // TArray<NPCAIDynamicGroupInfo*> (Size: 0x10)
NPCAIZoneGroupInfo.WorldPrivate = 0xe0 // World* (Size: 0x8)
NPCBTDecorator.bWithTime = 0x68 // uint8_t (Size: 0x1)
NPCBTDecorator.TagText = 0x70 // FString (Size: 0x10)
NPCBTDecorator.Message = 0x80 // FString (Size: 0x10)
NPCBTDecorator_AIPropertyComparison.AIPropertyComponent = 0x90 // ClassProperty (Size: 0x8)
NPCBTDecorator_AIPropertyComparison.ComponentFunctionName = 0x98 // FString (Size: 0x10)
NPCBTDecorator_AIPropertyComparison.BoolOperation = 0xa8 // uint8_t (Size: 0x1)
NPCBTDecorator_AIPropertyComparison.ArithmeticOperation = 0xa9 // uint8_t (Size: 0x1)
NPCBTDecorator_AIPropertyComparison.FloatValue = 0xac // float (Size: 0x4)
NPCBTDecorator_AIPropertyComparison.IntValue = 0xb0 // int32_t (Size: 0x4)
NPCBTDecorator_AIPropertyComparison.bUseBlackboardValue = 0xb4 // bool (Size: 0x1)
NPCBTDecorator_AIPropertyComparison.CachedDescription = 0xb8 // FString (Size: 0x10)
NPCBTDecorator_BBConditionBase.bUseTargetValue = 0x90 // bool (Size: 0x1)
NPCBTDecorator_BBConditionBase.SourceBlackboardKey = 0x98 // FBlackboardKeySelector (Size: 0x28)
NPCBTDecorator_BBConditionBase.TargetBlackboardKey = 0xc0 // FBlackboardKeySelector (Size: 0x28)
NPCBTDecorator_BBConditionBool.BlackboardKey = 0x90 // FBlackboardKeySelector (Size: 0x28)
NPCBTDecorator_BBConditionBool.ConditionType = 0xb8 // uint8_t (Size: 0x1)
NPCBTDecorator_BBConditionBool.TargetValue = 0xb9 // bool (Size: 0x1)
NPCBTDecorator_BBConditionFloat.SourceBlackboardKey = 0x90 // FBlackboardKeySelector (Size: 0x28)
NPCBTDecorator_BBConditionFloat.TargetBlackboardKey = 0xb8 // FBlackboardKeySelector (Size: 0x28)
NPCBTDecorator_BBConditionFloat.TargetValue = 0xe0 // float (Size: 0x4)
NPCBTDecorator_BBConditionFloat.bUseBBTargetValue = 0xe4 // bool (Size: 0x1)
NPCBTDecorator_BBConditionFloat.ConditionType = 0xe5 // uint8_t (Size: 0x1)
NPCBTDecorator_BBConditionInt.OperationType = 0xe8 // uint8_t (Size: 0x1)
NPCBTDecorator_BBConditionInt.TargetValue = 0xec // int32_t (Size: 0x4)
NPCBTDecorator_BBConditionString.OperationType = 0xe8 // uint8_t (Size: 0x1)
NPCBTDecorator_BBConditionString.TargetValue = 0xf0 // FString (Size: 0x10)
NPCBTDecorator_BlueprintBase.bAsSharedInstance = 0x68 // bool (Size: 0x1)
NPCBTDecorator_BlueprintBase.AIOwner = 0x70 // AIController* (Size: 0x8)
NPCBTDecorator_BlueprintBase.ObservedKeyNames = 0x78 // TArray<FName> (Size: 0x10)
NPCBTDecorator_BlueprintBase.bShowPropertyDetails = 0x9c // uint8_t (Size: 0x1)
NPCBTDecorator_BlueprintBase.bCheckConditionOnlyBlackBoardChanges = 0x9c // uint8_t (Size: 0x1)
NPCBTDecorator_BlueprintBase.bIsObservingBB = 0x9c // uint8_t (Size: 0x1)
NPCBTDecorator_HasSuspectPoints.Radius = 0x90 // float (Size: 0x4)
NPCBTDecorator_HasSuspectPoints.HalfHeight = 0x94 // float (Size: 0x4)
NPCBTDecorator_HasSuspectPoints.HalfAngle = 0x98 // float (Size: 0x4)
NPCBTDecorator_HasSuspectPoints.Offset = 0x9c // FVector (Size: 0xc)
NPCBTDecorator_IsCloseEnough.CloseEnoughDistance = 0x90 // float (Size: 0x4)
NPCBTDecorator_SingletonBlueprintBase.AIOwner = 0x68 // AIController* (Size: 0x8)
NPCBTDecorator_SingletonBlueprintBase.ObservedKeyNames = 0x70 // TArray<FName> (Size: 0x10)
NPCBTDecorator_SingletonBlueprintBase.bShowPropertyDetails = 0x90 // uint8_t (Size: 0x1)
NPCBTDecorator_SingletonBlueprintBase.bCheckConditionOnlyBlackBoardChanges = 0x90 // uint8_t (Size: 0x1)
NPCBTDecorator_SingletonBlueprintBase.bIsObservingBB = 0x90 // uint8_t (Size: 0x1)
NPCBTDecorator_TickIntervalBase.Interval = 0xa0 // float (Size: 0x4)
NPCBTDecorator_TickIntervalBase.RandomDeviation = 0xa4 // float (Size: 0x4)
NPCBTDecorator_Wait.bWaitFirstTime = 0x70 // bool (Size: 0x1)
NPCBTService.bWithTime = 0x70 // uint8_t (Size: 0x1)
NPCBTService.bOnActivation = 0x70 // uint8_t (Size: 0x1)
NPCBTService.bOnDeactivation = 0x70 // uint8_t (Size: 0x1)
NPCBTService.bOnTick = 0x70 // uint8_t (Size: 0x1)
NPCBTService.bOnSearchStart = 0x70 // uint8_t (Size: 0x1)
NPCBTService.TagText = 0x78 // FString (Size: 0x10)
NPCBTService.Message = 0x88 // FString (Size: 0x10)
NPCBTService_BlueprintBase.bAsSharedInstance = 0x70 // bool (Size: 0x1)
NPCBTService_BlueprintBase.AIOwner = 0x78 // AIController* (Size: 0x8)
NPCBTService_BlueprintBase.bShowPropertyDetails = 0x94 // uint8_t (Size: 0x1)
NPCBTService_BlueprintBase.bShowEventDetails = 0x94 // uint8_t (Size: 0x1)
NPCBTService_FindRandomPosition.CenterTarget = 0x98 // FBlackboardKeySelector (Size: 0x28)
NPCBTService_FindRandomPosition.RandomLocation = 0xc0 // FBlackboardKeySelector (Size: 0x28)
NPCBTService_FindRandomPosition.MinRange = 0xe8 // float (Size: 0x4)
NPCBTService_FindRandomPosition.MaxRange = 0xec // float (Size: 0x4)
NPCBTService_SetSenseRangeScale.CatchSenseScale = 0x98 // float (Size: 0x4)
NPCBTService_SetSenseRangeScale.LossSenseScale = 0x9c // float (Size: 0x4)
NPCBTService_SetSenseRangeScale.AISenseType = 0xa0 // EEAISenseType (Size: 0x1)
NPCBTService_SetVisionHalfAngle.LookAngleScale = 0x98 // float (Size: 0x4)
NPCBTService_SingletonBlueprintBase.AIOwner = 0x70 // AIController* (Size: 0x8)
NPCBTService_SingletonBlueprintBase.bShowPropertyDetails = 0x88 // uint8_t (Size: 0x1)
NPCBTService_SingletonBlueprintBase.bShowEventDetails = 0x88 // uint8_t (Size: 0x1)
NPCBTTaskNode.bWithTime = 0x70 // uint8_t (Size: 0x1)
NPCBTTaskNode.TagText = 0x78 // FString (Size: 0x10)
NPCBTTaskNode.Message = 0x88 // FString (Size: 0x10)
NPCBTTask_BlueprintBase.bAsSharedInstance = 0x70 // bool (Size: 0x1)
NPCBTTask_BlueprintBase.AIOwner = 0x78 // AIController* (Size: 0x8)
NPCBTTask_BlueprintBase.TickInterval = 0x80 // FIntervalCountdown (Size: 0x8)
NPCBTTask_BlueprintBase.bShowPropertyDetails = 0xa4 // uint8_t (Size: 0x1)
NPCBTTask_CalcNextAttackPosition.bDebugMoveTrace = 0x98 // bool (Size: 0x1)
NPCBTTask_CalcNextAttackPosition.MaxTryTimes = 0x9c // int32_t (Size: 0x4)
NPCBTTask_CalcNextAttackPosition.MinMoveDistance = 0xa0 // float (Size: 0x4)
NPCBTTask_CalcNextAttackPosition.MaxMoveDistance = 0xa4 // float (Size: 0x4)
NPCBTTask_CalcNextAttackPosition.MoveDistanceThreshold = 0xa8 // float (Size: 0x4)
NPCBTTask_CalcNextAttackPosition.MinDistanceToPlayer = 0xac // float (Size: 0x4)
NPCBTTask_CalcNextAttackPosition.FilterClass = 0xb0 // ClassProperty (Size: 0x8)
NPCBTTask_DBNORescue.Tgt_DBNOTarget = 0xa8 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemy.FireTarget = 0xb0 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemy.MovementMultiplier = 0xd8 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemy.AimingMultiplier = 0x100 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemy.BurstMultiplier = 0x128 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemy.TargetStateMultiplier = 0x150 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemyEx.FireTarget = 0xb0 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FireEnemyEx.FireType = 0xd8 // EEAISpecialFireType (Size: 0x1)
NPCBTTask_FireEnemyEx.MissRadiusMin = 0xdc // float (Size: 0x4)
NPCBTTask_FireEnemyEx.MissRadiusMax = 0xe0 // float (Size: 0x4)
NPCBTTask_FireEnemyEx.SpeedThreshold = 0xe4 // float (Size: 0x4)
NPCBTTask_FollowPathNode.WanderLocationKey = 0x98 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_FollowPathNode.WaitTimeKey = 0xc0 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_LatenTaskBase.TaskDuration = 0xa8 // float (Size: 0x4)
NPCBTTask_LatenTaskBase.StartTime = 0xac // float (Size: 0x4)
NPCBTTask_MeleeAttackEnemy.FireTarget = 0xb0 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_MeleeAttackEnemy.FireTargetPawn = 0xd8 // Character* (Size: 0x8)
NPCBTTask_MeleeAttackEnemy.FireTargetLoc = 0xe0 // FVector (Size: 0xc)
NPCBTTask_MeleeAttackEnemy.IsShotEnemy = 0xec // bool (Size: 0x1)
NPCBTTask_MeleeAttackEnemy.bIsFiring = 0xed // bool (Size: 0x1)
NPCBTTask_MeleeAttackEnemy.StartFireTimestamp = 0xf0 // float (Size: 0x4)
NPCBTTask_MoveToEx.MoveType = 0xb0 // EEAIMoveType (Size: 0x1)
NPCBTTask_MoveToEx.RandomReachableRadius = 0xb4 // float (Size: 0x4)
NPCBTTask_MoveToEx.bWithTime = 0xb8 // uint8_t (Size: 0x1)
NPCBTTask_MoveToEx.TagText = 0xc0 // FString (Size: 0x10)
NPCBTTask_MoveToEx.Message = 0xd0 // FString (Size: 0x10)
NPCBTTask_PlayAkSound.SoundToPlay = 0x98 // AkAudioEvent* (Size: 0x8)
NPCBTTask_PlayAkSound.bSoundAttached = 0xa0 // bool (Size: 0x1)
NPCBTTask_SetAIPose.TargetAIPose = 0x98 // EEAIPose (Size: 0x1)
NPCBTTask_SetBlackboardValue.SourceValue = 0x98 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_SetBlackboardValue.TargetValue = 0xc0 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_SetFocalPoint.bWithTime = 0x98 // uint8_t (Size: 0x1)
NPCBTTask_SetFocalPoint.TagText = 0xa0 // FString (Size: 0x10)
NPCBTTask_SetFocalPoint.Message = 0xb0 // FString (Size: 0x10)
NPCBTTask_SetMovementSpeed.BasicStandSpeed = 0x98 // float (Size: 0x4)
NPCBTTask_SetMovementSpeed.BasicCrouchSpeed = 0x9c // float (Size: 0x4)
NPCBTTask_SetMovementSpeed.BasicProneSpeed = 0xa0 // float (Size: 0x4)
NPCBTTask_SetSenseRangeScale.CatchSenseScale = 0x98 // float (Size: 0x4)
NPCBTTask_SetSenseRangeScale.LossSenseScale = 0x9c // float (Size: 0x4)
NPCBTTask_SetSenseRangeScale.AISenseType = 0xa0 // EEAISenseType (Size: 0x1)
NPCBTTask_SetTargetHatred.EnemyTargetKey = 0xa8 // FBlackboardKeySelector (Size: 0x28)
NPCBTTask_SetTargetHatred.HatredValue = 0xd0 // int32_t (Size: 0x4)
NPCBTTask_SetTargetHatred.Hatred_IndateTime = 0xd4 // float (Size: 0x4)
NPCBTTask_SetTargetHatred.NeedToCalucateGoalEnemy = 0xd8 // bool (Size: 0x1)
NPCBTTask_SetVisionHalfAngle.VisionHalfAngle = 0x98 // float (Size: 0x4)
NPCBehaviorLOD.OwnerPawn = 0x28 // Character* (Size: 0x8)
NPCBehaviorLOD.bConsiderDistance = 0x30 // bool (Size: 0x1)
NPCBehaviorLOD.bConsiderVisible = 0x31 // bool (Size: 0x1)
NPCBehaviorLOD.MinDistance = 0x34 // float (Size: 0x4)
NPCBehaviorLOD.MaxDistance = 0x38 // float (Size: 0x4)
NPCBehaviorLOD.bConsiderVisionAngle = 0x3c // bool (Size: 0x1)
NPCBehaviorLOD.VisionAngleInDegree = 0x40 // float (Size: 0x4)
NPCBehaviorLOD.Actions = 0x48 // TArray<NPCBehaviorLODActionTick*> (Size: 0x10)
NPCBehaviorLODAction.bLoop = 0x28 // bool (Size: 0x1)
NPCBehaviorLODAction.LoopInterval = 0x2c // float (Size: 0x4)
NPCBehaviorLODAction.OwnerPawn = 0x38 // Character* (Size: 0x8)
NPCBehaviorLODActionTick.OwnerPawn = 0x28 // Character* (Size: 0x8)
NPCBehaviorLODActionTick.LODSysComp = 0x30 // NPCBehaviorLODSystemComponent* (Size: 0x8)
NPCBehaviorLODActionTick.ControllerTickInterval = 0x38 // float (Size: 0x4)
NPCBehaviorLODActionTick.CharacterTickInterval = 0x3c // float (Size: 0x4)
NPCBehaviorLODSystemComponent.UpdateLODInterval = 0x110 // float (Size: 0x4)
NPCBehaviorLODSystemComponent.bPMCAIAsPlayer = 0x114 // bool (Size: 0x1)
NPCBehaviorLODSystemComponent.LODs = 0x118 // TArray<NPCBehaviorLOD*> (Size: 0x10)
NPCBehaviorLODSystemComponent.EnemyLeaveTimeCanLODEnabled = 0x128 // float (Size: 0x4)
NPCBehaviorLODSystemComponent.CurrLODCache = 0x130 // NPCBehaviorLOD* (Size: 0x8)
NPCBehaviorLODSystemComponent.bIgnoreUpdate = 0x138 // bool (Size: 0x1)
NPCBehaviorLODSystemComponent.bControllerOringinalTickEnabled = 0x139 // bool (Size: 0x1)
NPCBehaviorLODSystemComponent.ControllerOringinalTickInterval = 0x13c // float (Size: 0x4)
NPCBehaviorLODSystemComponent.bCharacterOringinalTickEnabled = 0x140 // bool (Size: 0x1)
NPCBehaviorLODSystemComponent.CharacterOringinalTickInterval = 0x144 // float (Size: 0x4)
NPCBehaviorLODSystemComponent.CharacterCachedCompList = 0x148 // TArray<FComponentInfo> (Size: 0x10)
NPCBehaviorLODSystemComponent.ControllerCachedCompList = 0x158 // TArray<FComponentInfo> (Size: 0x10)
NPCBehaviorLODSystemComponent.bHasAnyPlayerAround = 0x168 // bool (Size: 0x1)
NPCBehaviorLODSystemComponent.MemroySystemComponent = 0x170 // NPCAIMemorySystemComponent* (Size: 0x8)
NavCostModifier.Kind = 0x0 // EENPCAIPerceptibleTile (Size: 0x1)
NavCostModifier.Instigator = 0x4 // TWeakObjectPtr<UObject> (Size: 0x8)
NavCostModifier.BeginTime = 0xc // float (Size: 0x4)
NavCostModifier.EndTime = 0x10 // float (Size: 0x4)
NavCostModifier.Location = 0x14 // FVector (Size: 0xc)
NavCostModifier.Boundary = 0x20 // FBox (Size: 0x1c)
NavCostModifier.AffectedPolyRefs = 0x40 // TArray<uint64_t> (Size: 0x10)
NavCostModifier.LocalNavigationGridId = 0x50 // int32_t (Size: 0x4)
NavCostModifier.bMoving = 0x54 // bool (Size: 0x1)
NavLinkInfo.bValid = 0x0 // bool (Size: 0x1)
NavLinkInfo.bEnabled = 0x1 // bool (Size: 0x1)
NavLinkInfo.Direction = 0x2 // uint8_t (Size: 0x1)
NavLinkInfo.LinkType = 0x3 // EENavLinkType (Size: 0x1)
NavLinkInfo.LinkId = 0x4 // uint32_t (Size: 0x4)
NavLinkInfo.LinkIndex = 0x8 // int32_t (Size: 0x4)
NavLinkInfo.LeftIndex = 0xc // int32_t (Size: 0x4)
NavLinkInfo.RightIndex = 0x10 // int32_t (Size: 0x4)
NavLinkInfo.LeftRegionIndex = 0x14 // int32_t (Size: 0x4)
NavLinkInfo.RightRegionIndex = 0x18 // int32_t (Size: 0x4)
NavPathPointActor.NodeIndex = 0x310 // int32_t (Size: 0x4)
NavPathPointActor.NodeRef = 0x318 // uint64_t (Size: 0x8)
NavPathPointActor.NodeLocation = 0x320 // FVector (Size: 0xc)
NavPathPointActor.NextPathPointArray = 0x330 // TArray<NavPathPointActor*> (Size: 0x10)
NavSkeletonBuildSettings.NavQueryExtent = 0x0 // FVector (Size: 0xc)
NavSkeletonBuildSettings.SampleSpacing = 0xc // float (Size: 0x4)
NavSkeletonBuildSettings.DeltaLength = 0x10 // float (Size: 0x4)
NavSkeletonBuildSettings.GradientNeighbourRadius = 0x14 // int32_t (Size: 0x4)
NavSkeletonBuildSettings.DivergenceFilterThreshold = 0x18 // float (Size: 0x4)
NavSkeletonBuildSettings.DivergenceNeighbourRadius = 0x1c // float (Size: 0x4)
NavSkeletonBuildSettings.CoarseCoverageNeighbourRadius = 0x20 // float (Size: 0x4)
NavSkeletonBuildSettings.RefinedCoverageNeighbourRadius = 0x24 // float (Size: 0x4)
NavSkeletonBuildSettings.PolylineSimplificationDistanceThreshold = 0x28 // float (Size: 0x4)
NavSkeletonBuildSettings.bUseNewBuilder = 0x30 // bool (Size: 0x1)
NavSkeletonBuildSettings.bCheckEdgeOnNavMesh = 0x31 // bool (Size: 0x1)
NavSkeletonBuildSettings.bRemoveUnreachablePoints = 0x32 // bool (Size: 0x1)
NavSkeletonBuildSettings.bHintProjection2D = 0x33 // bool (Size: 0x1)
NavSkeletonBuildSettings.bAddRegionConnection = 0x34 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableCollapseShortPolylines = 0x35 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelFindWallsInNeighbourhood = 0x36 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateWallDistance = 0x37 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelGenerateRawPoints = 0x38 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateGradient = 0x39 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateDivergence = 0x3a // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateOutdoors = 0x3b // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelPruneSamplePoints = 0x3c // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateProtection = 0x3d // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateVisibility = 0x3e // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateThrowing = 0x3f // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableParallelCalculateMoving = 0x40 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnablePruneSamplePoints = 0x41 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableRemoveTooCloseMainPointAtCoverageStage = 0x42 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableRefineCoverage = 0x43 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnablePruneEndBranch = 0x44 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableCalculateVisibilityStage = 0x45 // bool (Size: 0x1)
NavSkeletonBuildSettings.bEnableCalculateThrowingStage = 0x46 // bool (Size: 0x1)
NavSkeletonBuildSettings.DivergenceMethod = 0x47 // EENavSkeletonDivergenceMethod (Size: 0x1)
NavSkeletonBuildSettings.FindWallInRadius = 0x48 // float (Size: 0x4)
NavSkeletonBuildSettings.MaxWallCount = 0x4c // int32_t (Size: 0x4)
NavSkeletonBuildSettings.PolylineLengthLowerBound = 0x50 // float (Size: 0x4)
NavSkeletonBuildSettings.RegionConnectionDistanceTolerance = 0x54 // float (Size: 0x4)
NavSkeletonBuildSettings.VisiblityQueryZExtent = 0x58 // float (Size: 0x4)
NavSkeletonBuildSettings.VisiblityTraceZOffset = 0x5c // float (Size: 0x4)
NavSkeletonBuildSettings.VisiblityMaxRange = 0x60 // float (Size: 0x4)
NavSkeletonBuildSettings.ProtectionTraceAngleStep = 0x64 // float (Size: 0x4)
NavSkeletonBuildSettings.ProtectionTraceZOffset = 0x68 // float (Size: 0x4)
NavSkeletonBuildSettings.ProtectionTraceMaxRange = 0x6c // float (Size: 0x4)
NavSkeletonBuildSettings.EndpointProtectionLowerBound = 0x70 // float (Size: 0x4)
NavSkeletonBuildSettings.ThrowingInitialSpeed = 0x74 // float (Size: 0x4)
NavSkeletonBuildSettings.ThrowingMaxRange = 0x78 // float (Size: 0x4)
NavSkeletonBuildSettings.MovingMaxRange = 0x7c // float (Size: 0x4)
NavSkeletonBuildSettings.CheckOutdoorsRadius = 0x84 // float (Size: 0x4)
NavSkeletonBuildSettings.CheckOutdoorsHeight = 0x88 // float (Size: 0x4)
NavSkeletonData.Points = 0x0 // TArray<FNavSkeletonPoint> (Size: 0x10)
NavSkeletonData.UnstableSegmentPatchPaths = 0x10 // TMap<...> (Size: 0x50)
NavSkeletonGraphAStarFilter.WeakOwner = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
NavSkeletonGraphAStarFilter.MaxSearchNodes = 0x8 // int32_t (Size: 0x4)
NavSkeletonGraphAStarFilter.CostLimit = 0xc // float (Size: 0x4)
NavSkeletonGraphAStarFilter.MaxUnreachablePathCostLimit = 0x10 // float (Size: 0x4)
NavSkeletonGraphAStarFilter.TimeLimit = 0x14 // float (Size: 0x4)
NavSkeletonGraphAStarFilter.RadiusLimit = 0x18 // float (Size: 0x4)
NavSkeletonGraphAStarFilter.bShouldIncludeStartNodeInPath = 0x1c // bool (Size: 0x1)
NavSkeletonGraphAStarFilter.UnreachablePointIDs = 0x20 // TSet<...> (Size: 0x50)
NavSkeletonGraphAStarFilter.bOnTryBestToIncludePointIDs = 0x70 // bool (Size: 0x1)
NavSkeletonGraphAStarFilter.TryBestToIncludePointIDs = 0x78 // TSet<...> (Size: 0x50)
NavSkeletonGraphCostType.PathCost = 0x0 // float (Size: 0x4)
NavSkeletonGraphCostType.UnreachablePathCost = 0x4 // float (Size: 0x4)
NavSkeletonGraphFindResult.status = 0x0 // EEMFGraphAStarResult (Size: 0x1)
NavSkeletonGraphFindResult.Nodes = 0x8 // TArray<FNavSkeletonGraphResultNode> (Size: 0x10)
NavSkeletonGraphFindResult.DesiredNodeIndices = 0x18 // TArray<int32_t> (Size: 0x10)
NavSkeletonGraphFindResult.DesiredPointIDs = 0x28 // TArray<int32_t> (Size: 0x10)
NavSkeletonGraphResultNode.PointID = 0x0 // int32_t (Size: 0x4)
NavSkeletonGraphResultNode.ParentID = 0x4 // int32_t (Size: 0x4)
NavSkeletonGraphResultNode.PathLength = 0x8 // float (Size: 0x4)
NavSkeletonGraphResultNode.UnreachablePathLength = 0xc // float (Size: 0x4)
NavSkeletonMoveSettings.bWantPathOptimization = 0x0 // bool (Size: 0x1)
NavSkeletonPatchedPath.PathPoints = 0x0 // TArray<FNavSkeletonPathPoint> (Size: 0x10)
NavSkeletonPathFindingQueue.QuerierToRequest = 0x18 // TMap<...> (Size: 0x50)
NavSkeletonPathPoint.Location = 0x0 // FVector (Size: 0xc)
NavSkeletonPathPoint.NodeRef = 0x10 // uint64_t (Size: 0x8)
NavSkeletonPathPoint.Flags = 0x18 // uint32_t (Size: 0x4)
NavSkeletonPathPoint.CustomLinkId = 0x1c // uint32_t (Size: 0x4)
NavSkeletonPathPoint.CustomNavLinkId = 0x20 // FNavLinkId (Size: 0x8)
NavSkeletonPoint.Outdoors = 0x10 // bool (Size: 0x1)
NavSkeletonPoint.Radius = 0x14 // float (Size: 0x4)
NavSkeletonPoint.EffectiveRange = 0x18 // float (Size: 0x4)
NavSkeletonPoint.LinkId = 0x1c // int32_t (Size: 0x4)
NavSkeletonPoint.AtPolyRef = 0x20 // uint64_t (Size: 0x8)
NavSkeletonPoint.ProtectionDirection = 0x28 // FVector (Size: 0xc)
NavSkeletonPoint.ProtectionHalfAngle = 0x34 // float (Size: 0x4)
NavSkeletonPoint.BattleIntensityExpectation = 0x38 // int32_t (Size: 0x4)
NavSkeletonPoint.NeighbourIndices = 0x40 // TArray<int32_t> (Size: 0x10)
NavSkeletonPoint.NeighbourDistances = 0x50 // TArray<float> (Size: 0x10)
NavSkeletonPoint.VisibleIndices = 0x60 // TArray<int32_t> (Size: 0x10)
NavSkeletonPoint.ThrowableIndices = 0x70 // TArray<int32_t> (Size: 0x10)
NavSkeletonPoint.MovableIndices = 0x80 // TArray<int32_t> (Size: 0x10)
NavSkeletonPoint.FriendIndices = 0x90 // TArray<int32_t> (Size: 0x10)
NavSkeletonPolyline.PointIDs = 0x0 // TArray<int32_t> (Size: 0x10)
NavSkeletonPolyline.PolylineLength = 0x10 // float (Size: 0x4)
PMCAISpawnInfo_ForSearchPath.SourcePoint = 0x0 // Actor* (Size: 0x8)
PMCAISpawnInfo_ForSearchPath.TotalCost = 0x8 // float (Size: 0x4)
PMCAISpawnInfo_ForSearchPath.Checked = 0xc // bool (Size: 0x1)
PortalEdge.PackedData = 0x0 // uint64_t (Size: 0x8)
PortalEdgeStorage.Items = 0x10 // TArray<FPortalEdge> (Size: 0x10)
RangeLimit.MinCount = 0x0 // int32_t (Size: 0x4)
RangeLimit.MaxCount = 0x4 // int32_t (Size: 0x4)
SoAStorage.Offsets = 0x0 // TArray<int32_t> (Size: 0x10)
SteepZoneDeleteSettings.NavQueryExtent = 0x0 // FVector (Size: 0xc)
SteepZoneDeleteSettings.bHintProjection2D = 0xc // bool (Size: 0x1)
SteepZoneDeleteSettings.SampleSpacing = 0x10 // float (Size: 0x4)
SteepZoneDeleteSettings.TraceRadius = 0x14 // float (Size: 0x4)
SteepZoneDeleteSettings.IncludedAngleTolerance = 0x18 // float (Size: 0x4)
SteepZoneDeleteSettings.WalkableFloorAngle = 0x1c // float (Size: 0x4)
SteepZoneDeleteSettings.DensityQuerySize = 0x20 // float (Size: 0x4)
SteepZoneDeleteSettings.TraceChannel = 0x2c // uint8_t (Size: 0x1)
SteepZoneDeleteSettings.bTraceComplex = 0x2d // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelCollectNavMeshPoly = 0x2e // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelCalculatePolyNormal = 0x2f // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelGenerateSamplePoint = 0x30 // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelCalculatePointNormal = 0x31 // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelCalculateSteepDensity = 0x32 // bool (Size: 0x1)
SteepZoneDeleteSettings.bParallelModifyTileCache = 0x33 // bool (Size: 0x1)
UInt64Storage.Items = 0x10 // TArray<uint64_t> (Size: 0x10)
NumKeyboardComponent.WidgetClass = 0xf8 // ClassProperty (Size: 0x8)
NumKeyboardComponent.KeyboardPanel = 0x100 // MFNumKeyboardWidget* (Size: 0x8)
HashChecker.OnHashCheckerEvent = 0x28 // FMulticastInlineDelegate (Size: 0x10)
HashChecker.RunningTasks = 0x38 // TArray<FString> (Size: 0x10)
HashChecker.CachedFileHash = 0x48 // TMap<...> (Size: 0x50)
MFGCloudCrashService.CrashObserver = 0x40 // MFGCloudCrashObserver* (Size: 0x8)
MFGCloudFriendService.Image = 0xe0 // Image* (Size: 0x8)
MFGCloudFriendService.InDyTexture = 0xe8 // Texture2DDynamic* (Size: 0x8)
MFGCloudFriendService.MFGCloudFriendObserver = 0x100 // MFGCloudFriendObserver* (Size: 0x8)
MFGCloudGroupService.MFGCloudGroupObserver = 0x40 // MFGCloudGroupObserver* (Size: 0x8)
MFGCloudLoginService.LoginObserver = 0x40 // MFGCloudLoginObserver* (Size: 0x8)
MFGCloudLoginService.IntlLoginObserver = 0x48 // MFIntlLoginObserver* (Size: 0x8)
MFGCloudLoginService.HttpPostDelegate = 0x50 // FMulticastInlineDelegate (Size: 0x10)
MFGCloudMessageObserver.SendPkgHeader = 0x80 // MFPWMessageHeader* (Size: 0x8)
MFGCloudMessageObserver.RecvPkgHeader = 0x88 // MFPWMessageHeader* (Size: 0x8)
MFGCloudMessageObserver.IsDebug = 0x121 // bool (Size: 0x1)
MFGCloudMessageObserver.IsNetworkOptimizationOn = 0x122 // bool (Size: 0x1)
MFGCloudMessageService.MsgHandlerArr = 0x40 // TArray<MFGCloudMessageHandler*> (Size: 0x10)
MFGCloudMessageService.ConnectorObserver = 0x50 // MFGCloudMessageObserver* (Size: 0x8)
MFGCloudNetWorkStateService.NetworkObserver = 0x40 // MFGCloudNetWorkStateObserver* (Size: 0x8)
MFGCloudNotice.OnLoadNoticeCompleted = 0x40 // FDelegate (Size: 0x10)
MFGCloudNotice.LastReturnData = 0x50 // FMSDKNoticeReturnData (Size: 0x60)
MFGCloudNotice.CachedGroup = 0xb0 // FString (Size: 0x10)
MFGCloudNotice.CachedLanguage = 0xc0 // FString (Size: 0x10)
MFGCloudNotice.CachedRegion = 0xd0 // FString (Size: 0x10)
MFGCloudNotice.CachedPartition = 0xe0 // FString (Size: 0x10)
MFGCloudNotice.CachedExtra = 0xf0 // FString (Size: 0x10)
MFGCloudPlugin.ServiceMap = 0x40 // TMap<...> (Size: 0x50)
MFGCloudPlugin.GCloudServiceClasses = 0x90 // TArray<ClassProperty> (Size: 0x10)
MFGCloudSetting.TbusppProjectName = 0x28 // FString (Size: 0x10)
MFGCloudSetting.TbusppGameID = 0x38 // FString (Size: 0x10)
MFGCloudSetting.TbusppServiceName = 0x48 // FString (Size: 0x10)
MFGCloudSetting.GameId = 0x58 // FString (Size: 0x10)
MFGCloudSetting.GameKey = 0x68 // FString (Size: 0x10)
MFGCloudSetting.QQAppID = 0x78 // FString (Size: 0x10)
MFGCloudSetting.QQAppKey = 0x88 // FString (Size: 0x10)
MFGCloudSetting.WeiXinAppID = 0x98 // FString (Size: 0x10)
MFGCloudSetting.WeiXinAppKey = 0xa8 // FString (Size: 0x10)
MFGCloudSetting.MSDK_GAME_ID = 0xb8 // FString (Size: 0x10)
MFGCloudSetting.MSDK_SDK_Key = 0xc8 // FString (Size: 0x10)
MFGCloudSetting.ConnectorDHP = 0xd8 // FString (Size: 0x10)
MFGCloudSetting.Dumphitches = 0xe8 // int32_t (Size: 0x4)
MFGCloudSetting.TssSDKID = 0xec // int32_t (Size: 0x4)
MFGCloudSetting.GRobotGameID = 0xf0 // int32_t (Size: 0x4)
MFGCloudSetting.GRobotGameCode = 0xf8 // FString (Size: 0x10)
MFGCloudSetting.SkipAuth = 0x108 // bool (Size: 0x1)
MFGCloudSetting.WeGameID = 0x110 // FString (Size: 0x10)
MFGCloudTGPAService.GCLoudTGPAObserver = 0x40 // MFGCloudTGPAObserver* (Size: 0x8)
MFGCloudToolsService.ToolsObserver = 0x40 // MFGCloudToolsObserver* (Size: 0x8)
MFGCloudWebViewService.WebViewObserver = 0x40 // MFGCloudWebViewObserver* (Size: 0x8)
MFGCloudWebViewService.IntlWebViewObserver = 0x48 // MFIntlWebViewObserver* (Size: 0x8)
MFGCloudXGService.XGObserver = 0x40 // MFGCloudXGObserver* (Size: 0x8)
MFGMEService.gmeObserver = 0x60 // MFGMEObserver* (Size: 0x8)
MFGMEService.mRoomId = 0x98 // FString (Size: 0x10)
MFGMEService.mRoomQualityType = 0xa8 // int32_t (Size: 0x4)
MFH5UIService.RootWidgetArrs = 0x48 // TMap<...> (Size: 0x50)
MFLBSObserver.OnAuthorizationStatusChanged = 0x40 // FMulticastInlineDelegate (Size: 0x10)
MFLBSService.INTLLBSObserver = 0x40 // MFIntlLBSObserver* (Size: 0x8)
MFLBSService.LBSObserver = 0x48 // MFLBSObserver* (Size: 0x8)
MFMNAService.StartingWidgetClass = 0x40 // ClassProperty (Size: 0x8)
MFMNAService.CurrentWidget = 0x48 // UserWidget* (Size: 0x8)
MFMidasService.MFMidasObserver = 0x88 // MFMidasObserver* (Size: 0x8)
MFMidasService.MFCTIPayObserver = 0x90 // MFCTIPayObserver* (Size: 0x8)
MFPWPluginManager.PluginMap = 0x28 // TMap<...> (Size: 0x50)
MFPWPluginManager.PluginClasses = 0x88 // TArray<ClassProperty> (Size: 0x10)
MFVoiceService.MFVoiceObserver = 0x60 // MFVoiceObserver* (Size: 0x8)
MFWeGamePlugin.OnQueryExpansionPackListResult = 0x40 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnInstallExpansionPackStart = 0x50 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnInstallExpansionPackProgress = 0x60 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnPauseInstallExpansionPack = 0x70 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnResumeInstallExpansionPack = 0x80 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnInstallExpansionPackResult = 0x90 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.OnUninstallExpansionPackResult = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
MFWeGamePlugin.bExpansionPackInited = 0xb0 // bool (Size: 0x1)
MFWeGamePlugin.WeGameObserver = 0xf0 // MFWeGameObserver* (Size: 0x8)
MSDKNoticeInfo.NoticeID = 0x0 // int32_t (Size: 0x4)
MSDKNoticeInfo.NoticeType = 0x4 // int32_t (Size: 0x4)
MSDKNoticeInfo.NoticeGroup = 0x8 // FString (Size: 0x10)
MSDKNoticeInfo.BeginTime = 0x18 // int32_t (Size: 0x4)
MSDKNoticeInfo.EndTime = 0x1c // int32_t (Size: 0x4)
MSDKNoticeInfo.UpdateTime = 0x20 // int32_t (Size: 0x4)
MSDKNoticeInfo.Order = 0x24 // int32_t (Size: 0x4)
MSDKNoticeInfo.ContentType = 0x28 // int32_t (Size: 0x4)
MSDKNoticeInfo.Language = 0x30 // FString (Size: 0x10)
MSDKNoticeInfo.TextInfo = 0x40 // FMSDKNoticeTextInfo (Size: 0x30)
MSDKNoticeInfo.PicUrlList = 0x70 // TArray<FMSDKNoticePictureInfo> (Size: 0x10)
MSDKNoticeInfo.WebUrl = 0x80 // FString (Size: 0x10)
MSDKNoticeInfo.extraJson = 0x90 // FString (Size: 0x10)
MSDKNoticePictureInfo.NoticePicUrl = 0x0 // FString (Size: 0x10)
MSDKNoticePictureInfo.NoticePicHashcode = 0x10 // FString (Size: 0x10)
MSDKNoticePictureInfo.NoticePicTitle = 0x20 // FString (Size: 0x10)
MSDKNoticePictureInfo.NoticePicSize = 0x30 // FString (Size: 0x10)
MSDKNoticePictureInfo.ScreenDir = 0x40 // int32_t (Size: 0x4)
MSDKNoticeReturnData.MethodNameID = 0x0 // int32_t (Size: 0x4)
MSDKNoticeReturnData.RetCode = 0x4 // int32_t (Size: 0x4)
MSDKNoticeReturnData.RetMsg = 0x8 // FString (Size: 0x10)
MSDKNoticeReturnData.ThirdCode = 0x18 // int32_t (Size: 0x4)
MSDKNoticeReturnData.ThirdMsg = 0x20 // FString (Size: 0x10)
MSDKNoticeReturnData.extraJson = 0x30 // FString (Size: 0x10)
MSDKNoticeReturnData.RequestID = 0x40 // FString (Size: 0x10)
MSDKNoticeReturnData.NoticeInfoList = 0x50 // TArray<FMSDKNoticeInfo> (Size: 0x10)
MSDKNoticeTextInfo.NoticeTitle = 0x0 // FString (Size: 0x10)
MSDKNoticeTextInfo.NoticeContent = 0x10 // FString (Size: 0x10)
MSDKNoticeTextInfo.NoticeRedirectUrl = 0x20 // FString (Size: 0x10)
MyHotfixStruct.A = 0x0 // int32_t (Size: 0x4)
MyHotfixStruct.B = 0x4 // int32_t (Size: 0x4)
PufferInitConfigData.MaxDownloadSpeed = 0x0 // int32_t (Size: 0x4)
PufferInitConfigData.MaxDownTask = 0x4 // int32_t (Size: 0x4)
PufferInitConfigData.MaxDownloadsPerTask = 0x8 // int32_t (Size: 0x4)
PufferInitConfigData.PufferProductId = 0x10 // int64_t (Size: 0x8)
PufferInitConfigData.NeedCheck = 0x18 // int32_t (Size: 0x4)
PufferInitConfigData.NeedFileRestore = 0x1c // int32_t (Size: 0x4)
PufferInitConfigData.RemoveOldWhenUpdate = 0x20 // int32_t (Size: 0x4)
PufferInitConfigData.StrSourceDir = 0x28 // FString (Size: 0x10)
PufferInitConfigData.StrPufferServerUrl = 0x38 // FString (Size: 0x10)
PufferInitConfigData.StrPufferGroupMarkId = 0x48 // FString (Size: 0x10)
PufferInitConfigData.strUserID = 0x58 // FString (Size: 0x10)
PufferInitConfigData.PufferGameId = 0x68 // int64_t (Size: 0x8)
PufferInitConfigData.PufferUpdateType = 0x70 // int32_t (Size: 0x4)
PufferInitConfigData.PufferDolphinProductId = 0x78 // int64_t (Size: 0x8)
PufferInitConfigData.StrDolphinAppVersion = 0x80 // FString (Size: 0x10)
PufferInitConfigData.StrDolphinResVersion = 0x90 // FString (Size: 0x10)
PufferInitConfigData.EnableIOSBGDownload = 0xa0 // int32_t (Size: 0x4)
PufferInitConfigData.ShowFileList = 0xa4 // int32_t (Size: 0x4)
PufferTaskInfo.TaskId = 0x0 // int32_t (Size: 0x4)
PufferTaskInfo.TaskName = 0x8 // FString (Size: 0x10)
PufferTaskInfo.TaskState = 0x18 // EEPufferTaskState (Size: 0x1)
PufferTaskInfo.NowSize = 0x20 // int64_t (Size: 0x8)
PufferTaskInfo.TotalSize = 0x28 // int64_t (Size: 0x8)
PufferTaskInfo.bIsFileTask = 0x30 // bool (Size: 0x1)
PufferTaskInfo.bIsBatchTask = 0x31 // bool (Size: 0x1)
PufferTaskInfo.bIsRestoreTask = 0x32 // bool (Size: 0x1)
MFPreExposureReadSystem.NPC = 0x50 // NiagaraParameterCollection* (Size: 0x8)
MFPreExposureReadSystem.NPCI = 0x58 // NiagaraParameterCollectionInstance* (Size: 0x8)
ObjPool.ObjPool = 0x0 // TArray<Object*> (Size: 0x10)
PreloadSubsystem.ObjPoolMap = 0x30 // TMap<...> (Size: 0x50)
GlassBoxCollisionInfo.bBroken = 0x0 // bool (Size: 0x1)
GlassBoxComponent.ColorID = 0x5f0 // int32_t (Size: 0x4)
GlassBoxComponent.GlassBoxCollisionInfo = 0x5f4 // FGlassBoxCollisionInfo (Size: 0x1)
GlassBoxComponent.CachedGlassCutter = 0x5f8 // MFGlassCutterComponent* (Size: 0x8)
GlassHitEffectInfo.IDList = 0x0 // TArray<int32_t> (Size: 0x10)
GlassHitEffectInfo.DirList = 0x10 // TArray<FVector> (Size: 0x10)
GlassHitEffectInfo.WeaponTypeList = 0x20 // TArray<int32_t> (Size: 0x10)
GlassHitEffectInfo.Count = 0x30 // int32_t (Size: 0x4)
MFGlassCachedImpact.ColorID = 0x0 // int32_t (Size: 0x4)
MFGlassCachedImpact.WeaponType = 0x4 // int8_t (Size: 0x1)
MFGlassCachedImpact.Location = 0x8 // FVector (Size: 0xc)
MFGlassCachedImpact.Normal = 0x14 // FVector (Size: 0xc)
MFGlassCutterComponent.MaskIDCache = 0x100 // TArray<uint8_t> (Size: 0x10)
MFGlassCutterComponent.ClientMaskIDCache = 0x110 // TArray<uint8_t> (Size: 0x10)
MFGlassCutterComponent.Inited = 0x140 // bool (Size: 0x1)
MFGlassCutterComponent.IDMaxCount = 0x144 // int32_t (Size: 0x4)
MFGlassCutterComponent.TestPartId = 0x148 // int32_t (Size: 0x4)
MFGlassCutterComponent.Scale = 0x14c // FVector (Size: 0xc)
MFGlassCutterComponent.Dir = 0x158 // FVector (Size: 0xc)
MFGlassCutterComponent.Pos = 0x168 // TArray<FVector> (Size: 0x10)
MFGlassCutterComponent.IDTriangleStartIndexMap = 0x178 // TMap<...> (Size: 0x50)
MFGlassCutterComponent.IDTriangleEndIndexMap = 0x1c8 // TMap<...> (Size: 0x50)
MFGlassCutterComponent.bPassable = 0x218 // uint8_t (Size: 0x1)
MFGlassCutterComponent.CachedImpacts = 0x368 // TArray<FMFGlassCachedImpact> (Size: 0x10)
MFGlassCutterComponent.GlassBoxCompList = 0x398 // TArray<GlassBoxComponent*> (Size: 0x10)
MFGlassImpact.WeaponType = 0x0 // int8_t (Size: 0x1)
MFGlassImpact.Location = 0x4 // FVector (Size: 0xc)
MFGlassImpact.Normal = 0x10 // FVector (Size: 0xc)
MFQCloudWrapper.OnUploadProgress = 0x28 // FMulticastInlineDelegate (Size: 0x10)
MFQCloudWrapper.OnUploadCompleted = 0x38 // FMulticastInlineDelegate (Size: 0x10)
BlackboardOperatorBase.TargetActor = 0x28 // ClassProperty (Size: 0x8)
BlackboardOperatorBase.BTeamInfo = 0x30 // bool (Size: 0x1)
CheckActorClass.ParentClass = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
CheckActorLocation.Center = 0x28 // FVector (Size: 0xc)
CheckActorLocation.Radius = 0x34 // float (Size: 0x4)
CheckBlackboardBase.TargetActor = 0x28 // ClassProperty (Size: 0x8)
CheckIntArrayMapNum.Key = 0x30 // FGameplayTag (Size: 0x8)
CheckIntArrayMapNum.CompareType = 0x38 // EENumberCompareType (Size: 0x1)
CheckIntArrayMapNum.Value1 = 0x3c // int32_t (Size: 0x4)
CheckIntArrayMapNum.Value2 = 0x40 // int32_t (Size: 0x4)
CheckIntMapValue.Key = 0x30 // FGameplayTag (Size: 0x8)
CheckIntMapValue.CompareType = 0x38 // EENumberCompareType (Size: 0x1)
CheckIntMapValue.Value1 = 0x3c // int32_t (Size: 0x4)
CheckIntMapValue.Value2 = 0x40 // int32_t (Size: 0x4)
CheckObjectArrayMapNum.Key = 0x30 // FGameplayTag (Size: 0x8)
CheckObjectArrayMapNum.CompareType = 0x38 // EENumberCompareType (Size: 0x1)
CheckObjectArrayMapNum.Value1 = 0x3c // int32_t (Size: 0x4)
CheckObjectArrayMapNum.Value2 = 0x40 // int32_t (Size: 0x4)
IntArrayMapAddValue.Key = 0x38 // FGameplayTag (Size: 0x8)
IntArrayMapAddValue.ModifyValueSource = 0x40 // ClassProperty (Size: 0x8)
IntArrayMapAddValue.ModifyValue = 0x48 // int32_t (Size: 0x4)
IntArrayMapRemoveValue.Key = 0x38 // FGameplayTag (Size: 0x8)
IntArrayMapRemoveValue.RemoveIndex = 0x40 // int32_t (Size: 0x4)
IntMapAddValue.Key = 0x38 // FGameplayTag (Size: 0x8)
IntMapAddValue.ModifyValueSource = 0x40 // ClassProperty (Size: 0x8)
IntMapAddValue.ModifyValue = 0x48 // int32_t (Size: 0x4)
IntMapSetValue.Key = 0x38 // FGameplayTag (Size: 0x8)
IntMapSetValue.ValueSource = 0x40 // ClassProperty (Size: 0x8)
IntMapSetValue.Value = 0x48 // int32_t (Size: 0x4)
MFQuestActivationComp_TriggerVolume.TriggerVolume = 0x100 // Volume* (Size: 0x8)
MFQuestAssembleNode.QuestAffiliateNodeArray = 0x58 // TArray<MFQuestAffiliateNode*> (Size: 0x10)
MFQuestBase.OnQuestStateChange = 0x340 // FMulticastInlineDelegate (Size: 0x10)
MFQuestBase.ActionComponents = 0x360 // TArray<MFQuestActionComponentBase*> (Size: 0x10)
MFQuestBase.LevelUnrelatedActionComponents = 0x370 // TArray<MFQuestActionComponentBase*> (Size: 0x10)
MFQuestBase.ActivationComponents = 0x380 // TArray<MFQuestActivationComponentBase*> (Size: 0x10)
MFQuestBase.CanRunOnClient = 0x390 // bool (Size: 0x1)
MFQuestBase.ObjectiveComponent = 0x398 // MFQuestObjectiveComponentBase* (Size: 0x8)
MFQuestBase.CustomIndex = 0x3a8 // int32_t (Size: 0x4)
MFQuestBase.GraphID = 0x3ac // int32_t (Size: 0x4)
MFQuestBase.QuestStatus = 0x3b0 // FQuestState (Size: 0x2)
MFQuestBase.QuestFailedType = 0x3b2 // EEQuestFailedType (Size: 0x1)
MFQuestBase.IsAffiliateQuest = 0x3b3 // bool (Size: 0x1)
MFQuestBase.AssembleCustomIndexList = 0x3b8 // TArray<int32_t> (Size: 0x10)
MFQuestBase.QuestTemplateParams = 0x3c8 // TArray<int32_t> (Size: 0x10)
MFQuestBase.bIsTemplate = 0x3d8 // bool (Size: 0x1)
MFQuestBase.ActivateTime = 0x3dc // float (Size: 0x4)
MFQuestBase.FinishTime = 0x3e0 // float (Size: 0x4)
MFQuestBase.CacheCharacter = 0x3e8 // Character* (Size: 0x8)
MFQuestCheckNode.bSuccessWhenParallelNodeSuccess = 0x58 // bool (Size: 0x1)
MFQuestComponentBase.OwnerQuest = 0xf8 // MFQuestBase* (Size: 0x8)
MFQuestConditionComp_CheckActorProperty.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
MFQuestConditionComp_CheckActorProperty.CheckParams = 0x58 // TArray<CheckActorParamBase*> (Size: 0x10)
MFQuestConditionComp_CheckBlackboard.CheckParams = 0x50 // TArray<CheckBlackboardBase*> (Size: 0x10)
MFQuestConditionComp_Dist.SourceActorContextConfig = 0x50 // ClassProperty (Size: 0x8)
MFQuestConditionComp_Dist.DestActorContextConfig = 0x58 // ClassProperty (Size: 0x8)
MFQuestConditionComp_Dist.MinDist = 0x60 // float (Size: 0x4)
MFQuestConditionComp_Dist.MaxDist = 0x64 // float (Size: 0x4)
MFQuestConditionComp_RandomProbability.ProbabilityPercent = 0x50 // float (Size: 0x4)
MFQuestConditionComponentBase.OnGenerateDebugInfo = 0x28 // FMulticastInlineDelegate (Size: 0x10)
MFQuestConditionComponentBase.OwnerQuest = 0x38 // MFQuestBase* (Size: 0x8)
MFQuestConditionComponentBase.bAdvanceEdit = 0x40 // bool (Size: 0x1)
MFQuestConditionComponentBase.ConditionType = 0x41 // EEQuestConditionType (Size: 0x1)
MFQuestConditionComponentBase.CheckType = 0x42 // EEQuestConditionCheckType (Size: 0x1)
MFQuestConditionComponentBase.bExpectConditionResult = 0x43 // bool (Size: 0x1)
MFQuestConditionComponentBase.CustomTickInterval = 0x44 // float (Size: 0x4)
MFQuestConditionComponentBase.CustomTickTimerHandle = 0x48 // FTimerHandle (Size: 0x8)
MFQuestContext_Actor.ContextActor = 0x28 // Actor* (Size: 0x8)
MFQuestContext_Object.Object = 0x28 // Object* (Size: 0x8)
MFQuestDistributerBase.QuestType = 0x310 // EEQuestType (Size: 0x1)
MFQuestDistributerBase.QuestConditionEffectContainers = 0x318 // TArray<QuestConditionEffectContainer*> (Size: 0x10)
MFQuestDistributerBase.ActorBlackboards = 0x328 // TMap<...> (Size: 0x50)
MFQuestDistributerBase.OnBlackboardIntMapChanged = 0x378 // FMulticastInlineDelegate (Size: 0x10)
MFQuestDistributerBase.OnBlackboardIntArrayMapChanged = 0x388 // FMulticastInlineDelegate (Size: 0x10)
MFQuestDistributerBase.OnBlackboardObjectArrayMapChanged = 0x398 // FMulticastInlineDelegate (Size: 0x10)
MFQuestDistributerBase.LastTriggerCharacter = 0x3a8 // Character* (Size: 0x8)
MFQuestEffectBase.OnGenerateDebugInfo = 0x28 // FMulticastInlineDelegate (Size: 0x10)
MFQuestEffect_ModifyBlackboard.BlackboardOperators = 0x38 // TArray<BlackboardOperatorBase*> (Size: 0x10)
MFQuestInstigatorComponentBase.bLogToClient = 0x100 // bool (Size: 0x1)
MFQuestInstigatorComponentBase.InstigatorType = 0x101 // EEQuestInstigatorType (Size: 0x1)
MFQuestManagerActor.QuestGraphList = 0x310 // TArray<MFQuestNodeGraph*> (Size: 0x10)
MFQuestManagerComponent.QuestManagerActorClass = 0xf8 // ClassProperty (Size: 0x8)
MFQuestManagerComponent.QuestManagerActor = 0x100 // MFQuestManagerActor* (Size: 0x8)
MFQuestNode.bFailedWhenAndParallelNodeFailed = 0x4a // bool (Size: 0x1)
MFQuestNode.bForceCheck = 0x55 // bool (Size: 0x1)
MFQuestNodeGraph.OnGraphStatusChange = 0x28 // FMulticastInlineDelegate (Size: 0x10)
MFQuestNodeGraph.bOwnedQuestStateChanged = 0x38 // bool (Size: 0x1)
MFQuestNodeGraph.bCompleteInOneBattle = 0x39 // bool (Size: 0x1)
MFQuestNodeGraph.bIsActTask = 0x3a // bool (Size: 0x1)
MFQuestNodeGraph.NodeList = 0x40 // TArray<MFQuestNode*> (Size: 0x10)
MFQuestNodeGraph.QuestAffiliateNodeList = 0x50 // TArray<MFQuestAffiliateNode*> (Size: 0x10)
MFQuestNodeGraph.QuestList = 0x60 // TArray<MFQuestBase*> (Size: 0x10)
MFQuestNodeGraph.StartNode = 0x70 // MFQuestStartNode* (Size: 0x8)
MFQuestNodeGraph.EndNode = 0x78 // MFQuestEndNode* (Size: 0x8)
MFQuestNodeGraph.CustomIndex = 0x80 // int32_t (Size: 0x4)
MFQuestNodeGraph.OwnerController = 0x88 // Controller* (Size: 0x8)
MFQuestNodeGraph.CheckNodeArray = 0x98 // TArray<MFQuestNode*> (Size: 0x10)
MFQuestObjectiveComponentBase.OnObjectiveStateChanged = 0x100 // FMulticastInlineDelegate (Size: 0x10)
MFQuestObjectiveComponentBase.QuestContextPairConfigList = 0x110 // TArray<FQuestContextPairConfig> (Size: 0x10)
MFQuestObjectiveComponentBase.QuestObjectiveType = 0x120 // EEQuestObjectiveType (Size: 0x1)
MFQuestObjectiveComponentBase.AndObjectiveConditionList = 0x128 // TArray<MFQuestConditionComponentBase*> (Size: 0x10)
MFQuestObjectiveComponentBase.OrObjectiveConditionList = 0x138 // TArray<MFQuestConditionComponentBase*> (Size: 0x10)
MFQuestObjectiveComponentBase.QuestProgress = 0x148 // MFQuestProgressComponentBase* (Size: 0x8)
MFQuestObjectiveComponentBase.FailWhenAchieved = 0x150 // bool (Size: 0x1)
MFQuestObjectiveComponentBase.CurrQuestCompStatus = 0x151 // EEQuestStatus (Size: 0x1)
MFQuestObjectiveComponentBase.QuestContextList = 0x158 // TArray<FQuestContextPair> (Size: 0x10)
MFQuestPrimaryConditionBase.OnTriggerPrimaryCondition = 0x28 // FMulticastInlineDelegate (Size: 0x10)
MFQuestPrimaryConditionBase.OnGenerateDebugInfo = 0x38 // FMulticastInlineDelegate (Size: 0x10)
MFQuestPrimaryConditionBase.QuestContextPairConfigList = 0x48 // TArray<FQuestContextPairConfig> (Size: 0x10)
MFQuestPrimaryConditionBase.ConditionEffectContainer = 0x58 // QuestConditionEffectContainer* (Size: 0x8)
MFQuestPrimaryConditionBase.QuestDistributer = 0x60 // MFQuestDistributerBase* (Size: 0x8)
MFQuestPrimaryConditionBase.QuestContextList = 0x68 // TArray<FQuestContextPair> (Size: 0x10)
MFQuestProgressComp_Count.ProgressUnit = 0x118 // int32_t (Size: 0x4)
MFQuestProgressComp_Count.CachedProgress = 0x11c // int32_t (Size: 0x4)
MFQuestProgressComp_Count.bReachMaxNotComplete = 0x120 // bool (Size: 0x1)
MFQuestProgressComp_Count.OneBattleMaxAddProgress = 0x124 // int32_t (Size: 0x4)
MFQuestProgressComp_Count.OneBattleAddedProgress = 0x128 // int32_t (Size: 0x4)
MFQuestProgressComponentBase.BringInProgress = 0x100 // int32_t (Size: 0x4)
MFQuestProgressComponentBase.CurrProgress = 0x104 // int32_t (Size: 0x4)
MFQuestProgressComponentBase.MaxProgress = 0x108 // int32_t (Size: 0x4)
MFQuestProgressComponentBase.OldProgress = 0x10c // int32_t (Size: 0x4)
MFQuestProgressComponentBase.bClearWhenFail = 0x110 // bool (Size: 0x1)
MFQuestProgressComponentBase.bCanBringInProgress = 0x111 // bool (Size: 0x1)
NestedIntArray.IntArray = 0x0 // TArray<int32_t> (Size: 0x10)
NestedObjectArray.ObjectArray = 0x0 // TArray<Object*> (Size: 0x10)
ObjectArrayMapAddUnique.Key = 0x38 // FGameplayTag (Size: 0x8)
ObjectArrayMapAddUnique.TargetContextSource = 0x40 // ClassProperty (Size: 0x8)
ObjectArrayMapEmpty.Key = 0x38 // FGameplayTag (Size: 0x8)
QuestConditionEffectContainer.QuestDistributer = 0x28 // MFQuestDistributerBase* (Size: 0x8)
QuestConditionEffectContainer.PrimaryCondition = 0x30 // MFQuestPrimaryConditionBase* (Size: 0x8)
QuestConditionEffectContainer.SubConditions = 0x38 // TArray<MFQuestConditionComponentBase*> (Size: 0x10)
QuestConditionEffectContainer.QuestEffects = 0x48 // TArray<MFQuestEffectBase*> (Size: 0x10)
QuestConditionEffectContainer.FailQuestEffects = 0x58 // TArray<MFQuestEffectBase*> (Size: 0x10)
QuestContextPair.ContextSource = 0x0 // MFQuestContextSourceBase* (Size: 0x8)
QuestContextPair.Context = 0x8 // MFQuestContextBase* (Size: 0x8)
QuestContextPairConfig.ContextSourceClass = 0x0 // ClassProperty (Size: 0x8)
QuestContextPairConfig.ContextClass = 0x8 // ClassProperty (Size: 0x8)
QuestDistributerBlackboard.IntMap = 0x0 // TMap<...> (Size: 0x50)
QuestDistributerBlackboard.IntArrayMap = 0x50 // TMap<...> (Size: 0x50)
QuestDistributerBlackboard.ObjectArrayMap = 0xa0 // TMap<...> (Size: 0x50)
QuestDistributerBlackboard.ObjectMap = 0xf0 // TMap<...> (Size: 0x50)
QuestState.CurrQuestStatus = 0x0 // EEQuestStatus (Size: 0x1)
QuestState.OldQuestStatus = 0x1 // EEQuestStatus (Size: 0x1)
MFRelightableReflectionSettings.CaptureDirectionalLight = 0x38 // uint8_t (Size: 0x1)
RelightableData.CapturedCubeSize = 0x28 // int32_t (Size: 0x4)
RelightableData.CompressedAlbedo = 0x30 // TextureCube* (Size: 0x8)
RelightableData.CompressedAmbient = 0x38 // TextureCube* (Size: 0x8)
RelightableData.CompressedNormalAndSkyMask = 0x40 // TextureCube* (Size: 0x8)
RelightableData.CompressedLocalLight = 0x48 // TextureCube* (Size: 0x8)
RelightableData.KeyedShadowDirections = 0x50 // TArray<FVector> (Size: 0x10)
RelightableData.ShadowMaskDataVersion = 0xb0 // int32_t (Size: 0x4)
RelightableData.AmbientAndLocalLightNormalizeMask = 0xb4 // uint32_t (Size: 0x4)
MFRelightingPortalActor.RelightingPortal = 0x310 // MFRelightingPortalComponent* (Size: 0x8)
MFRelightingPortalComponent.Weight = 0x240 // float (Size: 0x4)
MFRelightingPortalComponent.bReverse = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bAffectsWorld = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bUseProbeInjection = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bSunGI = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bSkyLight = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bLocalLight = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bNeedWriteIndoorMask = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bNeedReplaceIndoorMask = 0x244 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bMultiBounceGI = 0x245 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bCastShadowMap = 0x245 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.bSurfelLighting = 0x245 // uint8_t (Size: 0x1)
MFRelightingPortalComponent.LocalLightSHCoefficientR = 0x250 // FVector4 (Size: 0x10)
MFRelightingPortalComponent.LocalLightSHCoefficientG = 0x260 // FVector4 (Size: 0x10)
MFRelightingPortalComponent.LocalLightSHCoefficientB = 0x270 // FVector4 (Size: 0x10)
MFRelightingPortalComponent.LocalLights = 0x280 // TArray<FMFRelightingPortalLocalLight> (Size: 0x10)
MFRelightingPortalComponent.LocalLightingVolumeBounds = 0x290 // FBoxSphereBounds (Size: 0x1c)
MFRelightingPortalComponent.EffectiveBoundsMask = 0x2ac // uint8_t (Size: 0x1)
MFRelightingPortalComponent.ShadowMapData = 0x2b0 // FMFRelightingPortalStaticMap (Size: 0x18)
MFRelightingPortalComponent.SurfelNormalMapData = 0x2c8 // FMFRelightingPortalStaticMap (Size: 0x18)
MFRelightingPortalComponent.SurfelAlbedoMapData = 0x2e0 // FMFRelightingPortalStaticMap (Size: 0x18)
MFRelightingPortalComponent.PreviewBox = 0x2f8 // BoxComponent* (Size: 0x8)
MFRelightingPortalComponent.OcclusionMeshComponent = 0x300 // StaticMeshComponent* (Size: 0x8)
MFRelightingPortalLocalLight.position = 0x0 // FVector (Size: 0xc)
MFRelightingPortalLocalLight.Radius = 0xc // float (Size: 0x4)
MFRelightingPortalLocalLight.Direction = 0x10 // FVector (Size: 0xc)
MFRelightingPortalLocalLight.IndirectColor = 0x1c // FLinearColor (Size: 0x10)
MFRelightingPortalLocalLight.FalloffExponent = 0x2c // float (Size: 0x4)
MFRelightingPortalLocalLight.bIsSpotLight = 0x30 // uint8_t (Size: 0x1)
MFRelightingPortalLocalLight.bInverseSquared = 0x30 // uint8_t (Size: 0x1)
MFRelightingPortalLocalLight.CosOuterConeAngle = 0x34 // float (Size: 0x4)
MFRelightingPortalLocalLight.CosInnerConeAngle = 0x38 // float (Size: 0x4)
MFRelightingPortalLocalLight.InvCosConeDifference = 0x3c // float (Size: 0x4)
MFRelightingPortalStaticMap.MapSize = 0x0 // int32_t (Size: 0x4)
MFRelightingPortalStaticMap.Samples = 0x8 // TArray<uint8_t> (Size: 0x10)
BlendSettings.BlendTime = 0x0 // float (Size: 0x4)
BlendSettings.BlendFunction = 0x4 // uint8_t (Size: 0x1)
BlendSettings.BlendExponent = 0x8 // float (Size: 0x4)
BlendSettings.bLockOutgoing = 0xc // bool (Size: 0x1)
DeleteReplayObject.OnDeleteComplete = 0x28 // FMulticastInlineDelegate (Size: 0x10)
GetSavedReplaysObject.OnGetReplaysComplete = 0x28 // FMulticastInlineDelegate (Size: 0x10)
GoToTimeObject.OnGotoTimeComplete = 0x28 // FMulticastInlineDelegate (Size: 0x10)
GoToTimeObject.WCO = 0x38 // Object* (Size: 0x8)
MFPCLocalFileKillCamComponent.ClientCapWhenDownLoad = 0xf8 // int32_t (Size: 0x4)
RenameReplayObject.OnRenameComplete = 0x28 // FMulticastInlineDelegate (Size: 0x10)
ReplayBoolData.Name = 0x0 // FString (Size: 0x10)
ReplayBoolData.Value = 0x10 // bool (Size: 0x1)
ReplayByteData.Name = 0x0 // FString (Size: 0x10)
ReplayByteData.Value = 0x10 // TArray<uint8_t> (Size: 0x10)
ReplayDataObject.BoolData = 0x158 // TArray<FReplayBoolData> (Size: 0x10)
ReplayDataObject.byteData = 0x168 // TArray<FReplayByteData> (Size: 0x10)
ReplayDataObject.IntData = 0x178 // TArray<FReplayIntData> (Size: 0x10)
ReplayDataObject.int64Data = 0x188 // TArray<FReplayInt64Data> (Size: 0x10)
ReplayDataObject.FloatData = 0x198 // TArray<FReplayFloatData> (Size: 0x10)
ReplayDataObject.nameData = 0x1a8 // TArray<FReplayNameData> (Size: 0x10)
ReplayDataObject.stringData = 0x1b8 // TArray<FReplayStringData> (Size: 0x10)
ReplayDataObject.textData = 0x1c8 // TArray<FReplayTextData> (Size: 0x10)
ReplayDataObject.vectorData = 0x1d8 // TArray<FReplayVectorData> (Size: 0x10)
ReplayDataObject.rotatorData = 0x1e8 // TArray<FReplayRotatorData> (Size: 0x10)
ReplayDataObject.transformData = 0x1f8 // TArray<FReplayTransformData> (Size: 0x10)
ReplayEvent.eventId = 0x0 // FString (Size: 0x10)
ReplayEvent.Group = 0x10 // FString (Size: 0x10)
ReplayEvent.TimeInMs = 0x20 // int32_t (Size: 0x4)
ReplayEvent.Data = 0x28 // ReplayDataObject* (Size: 0x8)
ReplayFloatData.Name = 0x0 // FString (Size: 0x10)
ReplayFloatData.Value = 0x10 // float (Size: 0x4)
ReplayInfo.FriendlyName = 0x0 // FString (Size: 0x10)
ReplayInfo.ActualName = 0x10 // FString (Size: 0x10)
ReplayInfo.RecordDate = 0x20 // FDateTime (Size: 0x8)
ReplayInfo.LengthInMS = 0x28 // int32_t (Size: 0x4)
ReplayInfo.SizeInMb = 0x2c // float (Size: 0x4)
ReplayInt64Data.Name = 0x0 // FString (Size: 0x10)
ReplayInt64Data.Value = 0x10 // int64_t (Size: 0x8)
ReplayIntData.Name = 0x0 // FString (Size: 0x10)
ReplayIntData.Value = 0x10 // int32_t (Size: 0x4)
ReplayNameData.Name = 0x0 // FString (Size: 0x10)
ReplayNameData.Value = 0x10 // FName (Size: 0x8)
ReplayObject.World = 0x28 // World* (Size: 0x8)
ReplayObject.ReplayInfo = 0x30 // FReplayInfo (Size: 0x30)
ReplayObject.OnRequestEventsComplete = 0x60 // FMulticastInlineDelegate (Size: 0x10)
ReplayObjectData.Name = 0x0 // FString (Size: 0x10)
ReplayObjectData.Value = 0x10 // Object* (Size: 0x8)
ReplayRotatorData.Name = 0x0 // FString (Size: 0x10)
ReplayRotatorData.Value = 0x10 // FRotator (Size: 0xc)
ReplayStringData.Name = 0x0 // FString (Size: 0x10)
ReplayStringData.Value = 0x10 // FString (Size: 0x10)
ReplayTextData.Name = 0x0 // FString (Size: 0x10)
ReplayTextData.Value = 0x10 // FText (Size: 0x18)
ReplayTransformData.Name = 0x0 // FString (Size: 0x10)
ReplayTransformData.Value = 0x10 // FTransform (Size: 0x30)
ReplayVectorData.Name = 0x0 // FString (Size: 0x10)
ReplayVectorData.Value = 0x10 // FVector (Size: 0xc)
RequestEventsObject.OnRequestEventsComplete = 0x28 // FMulticastInlineDelegate (Size: 0x10)
HeightMapComponentData.HeightMap = 0x28 // Texture2D* (Size: 0x8)
HeightMapComponentData.TexOffset = 0x30 // FVector (Size: 0xc)
IndexMapData.IndexMap = 0x28 // Texture2D* (Size: 0x8)
IndexMapData.LandscapeInfo = 0x30 // FLinearColor (Size: 0x10)
MFSceneryRuntimeSettingsActor.LayerNum = 0x310 // float (Size: 0x4)
MFSceneryRuntimeSettingsActor.FadeoutDistance = 0x314 // int32_t (Size: 0x4)
MFSceneryRuntimeSettingsActor.bOverrideConsoleVarInEditor = 0x318 // bool (Size: 0x1)
MFSceneryRuntimeSettingsActor.MaxTessellationFactor = 0x31c // int32_t (Size: 0x4)
MFSceneryRuntimeSettingsActor.bUseGlobalTessFactor = 0x320 // bool (Size: 0x1)
MFSceneryRuntimeSettingsActor.GlobalTessellationFactorInner = 0x324 // float (Size: 0x4)
MFSceneryRuntimeSettingsActor.GlobalTessellationFactorOuter = 0x328 // float (Size: 0x4)
MFSceneryRuntimeSettingsActor.IndexMapMPC = 0x330 // MaterialParameterCollection* (Size: 0x8)
MFSceneryRuntimeSettingsActor.IndirectTexture = 0x338 // TextureRenderTarget2D* (Size: 0x8)
MFSceneryRuntimeSettingsActor.StreamingAssets = 0x340 // TArray<FMFSceneryStreamingAsset> (Size: 0x10)
MFSceneryStreamingAsset.StreamingTexture = 0x0 // TextureRenderTarget2DArray* (Size: 0x8)
MFSceneryStreamingAsset.StreamingTextureType = 0x8 // ClassProperty (Size: 0x8)
PigmentData.PigmentMap = 0x28 // Texture2D* (Size: 0x8)
MFSubMeshDecalActor.SubMeshDecalComponent = 0x318 // MFSubMeshDecalComponent* (Size: 0x8)
MFSubMeshDecalComponent.DecalMaterial = 0x238 // MaterialInterface* (Size: 0x8)
MFSubMeshDecalComponent.DecalSize = 0x240 // FVector (Size: 0xc)
MFSubMeshDecalComponent.MaxCullingDegree = 0x24c // float (Size: 0x4)
MFSubMeshDecalComponent.VertNormalOffsetForStaticMesh = 0x250 // float (Size: 0x4)
MFSubMeshDecalComponent.VertNormalOffsetForLandscape = 0x254 // float (Size: 0x4)
MFSubMeshDecalComponent.StaticProcMeshComponent = 0x258 // ProceduralMeshComponent* (Size: 0x8)
MFSubMeshDecalComponent.DynamicProcMeshComponents = 0x260 // TArray<ProceduralMeshComponent*> (Size: 0x10)
MFVolumetricDistanceMapImportanceVolume.bGenerateDistanceMaps = 0x348 // uint8_t (Size: 0x1)
MFVolumetricDistanceMapImportanceVolume.bGenerateProbeBiasMaps = 0x348 // uint8_t (Size: 0x1)
MFVolumetricDistanceMapImportanceVolume.bOverride_MaxFrontProbeBias = 0x348 // uint8_t (Size: 0x1)
MFVolumetricDistanceMapImportanceVolume.MaxFrontProbeBias = 0x34c // float (Size: 0x4)
MFVolumetricDistanceMapImportanceVolume.bOverride_MaxBackProbeBias = 0x350 // uint8_t (Size: 0x1)
MFVolumetricDistanceMapImportanceVolume.MaxBackProbeBias = 0x354 // float (Size: 0x4)
MFVolumetricDistanceMapImportanceVolume.bOverride_ProbeBiasScale = 0x358 // uint8_t (Size: 0x1)
MFVolumetricDistanceMapImportanceVolume.ProbeBiasScale = 0x35c // float (Size: 0x4)
MFVolumetricLighmtapRenderSettingsActor.Component = 0x310 // MFVolumetricLighmtapRenderSettingsComponent* (Size: 0x8)
MFVolumetricLighmtapRenderSettingsComponent.bOverride_DistanceMapWidth = 0xf8 // uint8_t (Size: 0x1)
MFVolumetricLighmtapRenderSettingsComponent.DistanceMapWidth = 0xfc // int32_t (Size: 0x4)
MFVolumetricLighmtapRenderSettingsComponent.bOverride_DistanceMapHeight = 0x100 // uint8_t (Size: 0x1)
MFVolumetricLighmtapRenderSettingsComponent.DistanceMapHeight = 0x104 // int32_t (Size: 0x4)
MFVolumetricLighmtapRenderSettingsComponent.bOverride_DistanceMapDownSample = 0x108 // uint8_t (Size: 0x1)
MFVolumetricLighmtapRenderSettingsComponent.DistanceMapDownSample = 0x10c // int32_t (Size: 0x4)
MFVolumetricLighmtapRenderSettingsComponent.bOverride_TwoBandSHDistance = 0x110 // uint8_t (Size: 0x1)
MFVolumetricLighmtapRenderSettingsComponent.TwoBandSHDistance = 0x114 // float (Size: 0x4)
MFVolumetricLightmapExtraBrick.bInitialized = 0x0 // bool (Size: 0x1)
MFVolumetricLightmapExtraBrick.bIsPainted = 0x1 // bool (Size: 0x1)
EnvQueryTest_NodeWeight.WeightScale = 0x1f8 // float (Size: 0x4)
MFVoxelEnvComponent.Heuristic = 0xf8 // EEMFVoxelEnvHeuristic (Size: 0x1)
MFVoxelEnvComponent.HeuristicWeight = 0xfc // float (Size: 0x4)
MFVoxelEnvComponent.NodeSizePreference = 0x100 // float (Size: 0x4)
MFVoxelEnvComponent.PathPruning = 0x104 // EEMFVoxelEnvPathPruning (Size: 0x1)
MFVoxelEnvComponent.PathSmoothing = 0x108 // int32_t (Size: 0x4)
MFVoxelEnvComponent.Volume = 0x130 // MFVoxelEnvVolume* (Size: 0x8)
MFVoxelEnvCoverLocation.Actor = 0x0 // Actor* (Size: 0x8)
MFVoxelEnvCoverLocation.Location = 0x8 // FVector (Size: 0xc)
MFVoxelEnvCoverLocation.Normal = 0x14 // FVector (Size: 0xc)
MFVoxelEnvDebugLocation.Location = 0x0 // FVector (Size: 0xc)
MFVoxelEnvDebugLocation.Colour = 0xc // FColor (Size: 0x4)
MFVoxelEnvDebugLocation.LineScale = 0x10 // float (Size: 0x4)
MFVoxelEnvDebugPath.Points = 0x0 // TArray<FVector> (Size: 0x10)
MFVoxelEnvDebugPath.Colour = 0x10 // FColor (Size: 0x4)
MFVoxelEnvDebugPath.LineScale = 0x14 // float (Size: 0x4)
MFVoxelEnvModifierVolume.PathCostModifier = 0x348 // float (Size: 0x4)
MFVoxelEnvModifierVolume.bInvalidateCoverLocations = 0x34c // bool (Size: 0x1)
MFVoxelEnvModifierVolume.bEnabled = 0x34d // bool (Size: 0x1)
MFVoxelEnvModifierVolume.bDisplayVolumeBounds = 0x34e // bool (Size: 0x1)
MFVoxelEnvModifierVolume.bDisplayOverlaps = 0x34f // bool (Size: 0x1)
MFVoxelEnvModifierVolume.VolumeBoundsColour = 0x350 // FColor (Size: 0x4)
MFVoxelEnvModifierVolume.OverlapColour = 0x354 // FColor (Size: 0x4)
MFVoxelEnvOcclusionComponent.TransformTriggerTolerance = 0xf8 // float (Size: 0x4)
MFVoxelEnvOcclusionComponent.bEnableCover = 0xfc // bool (Size: 0x1)
MFVoxelEnvOcclusionComponent.Volume = 0x100 // MFVoxelEnvVolume* (Size: 0x8)
MFVoxelEnvOcclusionComponent.CachedTransform = 0x110 // FTransform (Size: 0x30)
MFVoxelEnvOcclusionComponent.bEnabled = 0x140 // bool (Size: 0x1)
MFVoxelEnvPath.Points = 0x0 // TArray<FMFVoxelEnvPathPoint> (Size: 0x10)
MFVoxelEnvPathPoint.Location = 0x0 // FVector (Size: 0xc)
MFVoxelEnvPathPoint.Layer = 0xc // int32_t (Size: 0x4)
MFVoxelEnvPathPointFindingConfig.EstimateWeight = 0x0 // float (Size: 0x4)
MFVoxelEnvPathPointFindingConfig.NodeSizePreference = 0x4 // float (Size: 0x4)
MFVoxelEnvPathPointFindingConfig.Heuristic = 0x8 // EEMFVoxelEnvHeuristic (Size: 0x1)
MFVoxelEnvPathPointFindingConfig.PathPruning = 0x9 // EEMFVoxelEnvPathPruning (Size: 0x1)
MFVoxelEnvPathPointFindingConfig.PathSmoothing = 0xc // int32_t (Size: 0x4)
MFVoxelEnvVolume.VolumeSize = 0x348 // float (Size: 0x4)
MFVoxelEnvVolume.VoxelSize = 0x34c // float (Size: 0x4)
MFVoxelEnvVolume.CollisionChannel = 0x350 // uint8_t (Size: 0x1)
MFVoxelEnvVolume.Clearance = 0x354 // float (Size: 0x4)
MFVoxelEnvVolume.TickInterval = 0x358 // float (Size: 0x4)
MFVoxelEnvVolume.bEnableCoverMap = 0x35c // bool (Size: 0x1)
MFVoxelEnvVolume.MinimumObjectRadius = 0x360 // float (Size: 0x4)
MFVoxelEnvVolume.MinimumDensity = 0x364 // float (Size: 0x4)
MFVoxelEnvVolume.DebugDistance = 0x368 // float (Size: 0x4)
MFVoxelEnvVolume.bDisplayVolumeBounds = 0x36c // bool (Size: 0x1)
MFVoxelEnvVolume.VolumeBoundsColour = 0x370 // FColor (Size: 0x4)
MFVoxelEnvVolume.bDisplayLayers = 0x374 // bool (Size: 0x1)
MFVoxelEnvVolume.bDisplayLeafs = 0x375 // bool (Size: 0x1)
MFVoxelEnvVolume.bDisplayWalkable = 0x376 // bool (Size: 0x1)
MFVoxelEnvVolume.bDisplayLeafOcclusion = 0x377 // bool (Size: 0x1)
MFVoxelEnvVolume.bDisplayEdgeAdjacency = 0x378 // bool (Size: 0x1)
MFVoxelEnvVolume.bDisplayCustomVoxel = 0x379 // bool (Size: 0x1)
MFVoxelEnvVolume.LineScale = 0x37c // float (Size: 0x4)
MFVoxelEnvVolume.LayerColours = 0x380 // TArray<FColor> (Size: 0x10)
MFVoxelEnvVolume.LeafOcclusionColour = 0x390 // FColor (Size: 0x4)
MFVoxelEnvVolume.bDisplayMortonCodes = 0x394 // bool (Size: 0x1)
MFVoxelEnvVolume.MortonCodeColour = 0x398 // FColor (Size: 0x4)
MFVoxelEnvVolume.MortonCodeScale = 0x39c // float (Size: 0x4)
MFVoxelEnvVolume.bDisplayCoverMap = 0x3a0 // bool (Size: 0x1)
MFVoxelEnvVolume.VoxelExponent = 0x3a4 // int32_t (Size: 0x4)
MFVoxelEnvVolume.ActualVolumeSize = 0x3a8 // float (Size: 0x4)
MFVoxelEnvVolume.NumLayers = 0x3ac // uint8_t (Size: 0x1)
MFVoxelEnvVolume.NumBytes = 0x3b0 // int32_t (Size: 0x4)
MFVoxelEnvVolume.OcclusionComponents = 0x470 // TArray<MFVoxelEnvOcclusionComponent*> (Size: 0x10)
MFVoxelEnvVolume.ModifierVolumes = 0x480 // TArray<MFVoxelEnvModifierVolume*> (Size: 0x10)
MFVoxelEnvVolume.MFVoxelEnvAgentHeight = 0x8a0 // float (Size: 0x4)
MFVoxelEnvVolume.DampingUpdateInterval = 0x8a4 // float (Size: 0x4)
MFVoxelEnvVolume.NodeWeightUpdaterDampingTimestamp = 0x8ac // uint16_t (Size: 0x2)
MFVoxelEnvVolume.NodeUpdaterExpireTimestamp = 0x8ae // uint16_t (Size: 0x2)
MFVoxelEnvVolume.bEnableRuntimeDebugShow = 0x8b0 // bool (Size: 0x1)
MFVoxelEnvVolume.RuntimeDebugShowInterval = 0x8b4 // float (Size: 0x4)
MFVoxelEnvVolume.CachedNavSys = 0x8c0 // NavigationSystemV1* (Size: 0x8)
MFVoxelEnvVolume.WalkableIgnoreClassList = 0x10e0 // TArray<ClassProperty> (Size: 0x10)
MFVoxelReflectionDoorSwitch.Door = 0x348 // TLazyObjectPtr<UObject> (Size: 0x1c)
MFVoxelReflectionDoorSwitch.SwitchMode = 0x364 // EEMFDoorSwitchMode (Size: 0x1)
MFVoxelReflectionDoorSwitch.ReflectionCaptureDoorOpened = 0x368 // TWeakObjectPtr<UObject> (Size: 0x8)
MFVoxelReflectionDoorSwitch.ReflectionCaptureDoorClosed = 0x370 // TWeakObjectPtr<UObject> (Size: 0x8)
MFVoxelReflectionDoorSwitch.VoxelReflectionID = 0x378 // int32_t (Size: 0x4)
MFVoxelReflectionPatchVolume.bInterior = 0x348 // bool (Size: 0x1)
MFVoxelReflectionPatchVolume.bNoSkyLightCompensation = 0x349 // bool (Size: 0x1)
MFVoxelReflectionPatchVolume.bEraseVoxels = 0x34a // bool (Size: 0x1)
MFVoxelReflectionPatchVolume.IgnoredReflectionCaptures = 0x350 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFVoxelReflectionPatchVolume.ForcedReflectionCaptures = 0x360 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFVoxelReflectionSystem.VoxelSampleBiasScale = 0x310 // float (Size: 0x4)
MFVoxelReflectionSystem.ReflectionCaptureFadePower = 0x314 // float (Size: 0x4)
MFVoxelReflectionSystem.VoxelVolumeBoundFadeDistance = 0x318 // float (Size: 0x4)
MFVoxelReflectionSystem.VoxelDataAsset = 0x320 // VoxelDataAsset* (Size: 0x8)
MFVoxelReflectionSystem.SparseVoxelDataAsset = 0x328 // SparseVoxelDataAsset* (Size: 0x8)
MFVoxelReflectionSystem.VoxelDimensions = 0x330 // FIntVector (Size: 0xc)
MFVoxelReflectionSystem.VoxelBounds = 0x33c // FBox (Size: 0x1c)
MFVoxelReflectionSystem.VoxelGridSize = 0x358 // float (Size: 0x4)
MFVoxelReflectionSystem.FadeInSpeed = 0x35c // float (Size: 0x4)
MFVoxelReflectionSystem.FadeOutSpeed = 0x360 // float (Size: 0x4)
MFVoxelReflectionSystem.VoxelTreeBranchingFactor = 0x364 // int32_t (Size: 0x4)
MFVoxelReflectionSystem.InteriorReflectionCaptures = 0x368 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFVoxelReflectionSystem.InteriorObbs = 0x378 // TArray<FTransform> (Size: 0x10)
MFVoxelReflectionSystem.ObbInteriorVolumes = 0x388 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFVoxelReflectionSystem.InteriorPatchVolumes = 0x398 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MFVoxelReflectionSystem.InteriorFadeOutRange = 0x3a8 // float (Size: 0x4)
MFVoxelReflectionSystem.BoxComponent = 0x3b0 // BoxComponent* (Size: 0x8)
ObbInteriorVolume.InteriorClippingPlane = 0x350 // FPlane (Size: 0x10)
ObbInteriorVolume.FadeOutRange = 0x360 // float (Size: 0x4)
ReflectionVoxel.ReflectionCaptureIDs = 0x0 // TArray<int32_t> (Size: 0x10)
ReflectionVoxel.CornerNeighbourFlags = 0x10 // uint32_t (Size: 0x4)
ReflectionVoxelTreeNode.ChildMaskL = 0x0 // uint32_t (Size: 0x4)
ReflectionVoxelTreeNode.ChildMaskH = 0x4 // uint32_t (Size: 0x4)
ReflectionVoxelTreeNode.ChildStartIndex = 0x8 // uint32_t (Size: 0x4)
SparseVoxelDataAsset.Version = 0x30 // int32_t (Size: 0x4)
SparseVoxelDataAsset.TreeRootDimensions = 0x34 // FIntVector (Size: 0xc)
SparseVoxelDataAsset.TreeHeight = 0x40 // int32_t (Size: 0x4)
SparseVoxelDataAsset.SparseTree = 0x48 // TArray<FReflectionVoxelTreeNode> (Size: 0x10)
SparseVoxelDataAsset.Voxels = 0x58 // TArray<FReflectionVoxel> (Size: 0x10)
VoxelDataAsset.Voxels = 0x30 // TArray<FReflectionVoxel> (Size: 0x10)
VoxelReflectionWorldSubsystem.VoxelReflectionSystem = 0x38 // MFVoxelReflectionSystem* (Size: 0x8)
VoxelReflectionWorldSubsystem.CurrentReflectionCapturesWorld = 0x40 // World* (Size: 0x8)
VoxelReflectionWorldSubsystem.AllReflectionCaptures = 0x48 // TArray<ReflectionCaptureComponent*> (Size: 0x10)
MFWeakNetworkIpNetDriver.UseReservedNetworkGUIDMap = 0x860 // bool (Size: 0x1)
MFWeakNetworkNetConnection.ReconnectTimeForNotify = 0x1c60 // float (Size: 0x4)
MFWeakNetworkNetConnection.SingleReconnectTime = 0x1c78 // float (Size: 0x4)
MFWeakNetworkNetConnection.SingleMaxReconnectCount = 0x1c7c // int32_t (Size: 0x4)
MFWeakNetworkNetConnection.MaxReconnectCount = 0x1c80 // float (Size: 0x4)
MFWeakNetworkNetConnection.ClientConnectionTimeout = 0x1c84 // float (Size: 0x4)
MFWeakNetworkNetConnection.EnableInitSocketFix = 0x1c88 // bool (Size: 0x1)
MFWeakNetworkNetConnection.SocketFixTime = 0x1c8c // float (Size: 0x4)
MFWeakNetworkNetConnection.CircularBitArrayNum = 0x1c9c // int32_t (Size: 0x4)
MRMeshComponent.Material = 0x5d8 // MaterialInterface* (Size: 0x8)
MRMeshComponent.WireframeMaterial = 0x5e0 // MaterialInterface* (Size: 0x8)
MRMeshComponent.bCreateMeshProxySections = 0x5e8 // bool (Size: 0x1)
MRMeshComponent.bUpdateNavMeshOnMeshUpdate = 0x5e9 // bool (Size: 0x1)
MRMeshComponent.bNeverCreateCollisionMesh = 0x5ea // bool (Size: 0x1)
MRMeshComponent.CachedBodySetup = 0x5f0 // BodySetup* (Size: 0x8)
MRMeshComponent.BodySetups = 0x5f8 // TArray<BodySetup*> (Size: 0x10)
MockDataMeshTrackerComponent.OnMeshTrackerUpdated = 0x238 // FMulticastInlineDelegate (Size: 0x10)
MockDataMeshTrackerComponent.ScanWorld = 0x248 // bool (Size: 0x1)
MockDataMeshTrackerComponent.RequestNormals = 0x249 // bool (Size: 0x1)
MockDataMeshTrackerComponent.RequestVertexConfidence = 0x24a // bool (Size: 0x1)
MockDataMeshTrackerComponent.VertexColorMode = 0x24b // EEMeshTrackerVertexColorMode (Size: 0x1)
MockDataMeshTrackerComponent.BlockVertexColors = 0x250 // TArray<FColor> (Size: 0x10)
MockDataMeshTrackerComponent.VertexColorFromConfidenceZero = 0x260 // FLinearColor (Size: 0x10)
MockDataMeshTrackerComponent.VertexColorFromConfidenceOne = 0x270 // FLinearColor (Size: 0x10)
MockDataMeshTrackerComponent.UpdateInterval = 0x280 // float (Size: 0x4)
MockDataMeshTrackerComponent.MRMesh = 0x288 // MRMeshComponent* (Size: 0x8)
MagicLeapARPinComponent.ObjectUID = 0x238 // FString (Size: 0x10)
MagicLeapARPinComponent.UserIndex = 0x248 // int32_t (Size: 0x4)
MagicLeapARPinComponent.AutoPinType = 0x24c // EEMagicLeapAutoPinType (Size: 0x1)
MagicLeapARPinComponent.bShouldPinActor = 0x24d // bool (Size: 0x1)
MagicLeapARPinComponent.PinDataClass = 0x250 // ClassProperty (Size: 0x8)
MagicLeapARPinComponent.SearchPinTypes = 0x258 // TSet<...> (Size: 0x50)
MagicLeapARPinComponent.SearchVolume = 0x2a8 // SphereComponent* (Size: 0x8)
MagicLeapARPinComponent.OnPersistentEntityPinned = 0x2b0 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapARPinComponent.OnPersistentEntityPinLost = 0x2c0 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapARPinComponent.OnPinDataLoadAttemptCompleted = 0x2d0 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapARPinComponent.PinnedCFUID = 0x2e0 // FGuid (Size: 0x10)
MagicLeapARPinComponent.PinnedSceneComponent = 0x2f0 // SceneComponent* (Size: 0x8)
MagicLeapARPinComponent.PinData = 0x2f8 // MagicLeapARPinSaveGame* (Size: 0x8)
MagicLeapARPinContentBindings.AllContentBindings = 0x28 // TMap<...> (Size: 0x50)
MagicLeapARPinInfoActorBase.PinId = 0x310 // FGuid (Size: 0x10)
MagicLeapARPinInfoActorBase.bVisibilityOverride = 0x320 // bool (Size: 0x1)
MagicLeapARPinObjectIdList.ObjectIdList = 0x0 // TSet<...> (Size: 0x50)
MagicLeapARPinQuery.Types = 0x0 // TSet<...> (Size: 0x50)
MagicLeapARPinQuery.MaxResults = 0x50 // int32_t (Size: 0x4)
MagicLeapARPinQuery.TargetPoint = 0x54 // FVector (Size: 0xc)
MagicLeapARPinQuery.Radius = 0x60 // float (Size: 0x4)
MagicLeapARPinQuery.bSorted = 0x64 // bool (Size: 0x1)
MagicLeapARPinRenderer.bInfoActorsVisibilityOverride = 0x310 // bool (Size: 0x1)
MagicLeapARPinRenderer.AllInfoActors = 0x318 // TMap<...> (Size: 0x50)
MagicLeapARPinRenderer.ClassToSpawn = 0x370 // ClassProperty (Size: 0x8)
MagicLeapARPinSaveGame.PinnedID = 0x28 // FGuid (Size: 0x10)
MagicLeapARPinSaveGame.ComponentWorldTransform = 0x40 // FTransform (Size: 0x30)
MagicLeapARPinSaveGame.PinTransform = 0x70 // FTransform (Size: 0x30)
MagicLeapARPinSaveGame.bShouldPinActor = 0xa0 // bool (Size: 0x1)
MagicLeapARPinSettings.UpdateCheckFrequency = 0x28 // float (Size: 0x4)
MagicLeapARPinSettings.OnUpdatedEventTriggerDelta = 0x2c // FMagicLeapARPinState (Size: 0x14)
MagicLeapARPinState.Confidence = 0x0 // float (Size: 0x4)
MagicLeapARPinState.ValidRadius = 0x4 // float (Size: 0x4)
MagicLeapARPinState.RotationError = 0x8 // float (Size: 0x4)
MagicLeapARPinState.TranslationError = 0xc // float (Size: 0x4)
MagicLeapARPinState.PinType = 0x10 // EEMagicLeapARPinType (Size: 0x1)
MagicLeapSharedWorldAlignmentTransforms.AlignmentTransforms = 0x0 // TArray<FTransform> (Size: 0x10)
MagicLeapSharedWorldGameMode.SharedWorldData = 0x3f8 // FMagicLeapSharedWorldSharedData (Size: 0x10)
MagicLeapSharedWorldGameMode.OnNewLocalDataFromClients = 0x408 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapSharedWorldGameMode.PinSelectionConfidenceThreshold = 0x418 // float (Size: 0x4)
MagicLeapSharedWorldGameMode.ChosenOne = 0x4c0 // MagicLeapSharedWorldPlayerController* (Size: 0x8)
MagicLeapSharedWorldGameState.SharedWorldData = 0x380 // FMagicLeapSharedWorldSharedData (Size: 0x10)
MagicLeapSharedWorldGameState.AlignmentTransforms = 0x390 // FMagicLeapSharedWorldAlignmentTransforms (Size: 0x10)
MagicLeapSharedWorldGameState.OnSharedWorldDataUpdated = 0x3a0 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapSharedWorldGameState.OnAlignmentTransformsUpdated = 0x3b0 // FMulticastInlineDelegate (Size: 0x10)
MagicLeapSharedWorldLocalData.LocalPins = 0x0 // TArray<FMagicLeapSharedWorldPinData> (Size: 0x10)
MagicLeapSharedWorldPinData.PinId = 0x0 // FGuid (Size: 0x10)
MagicLeapSharedWorldPinData.PinState = 0x10 // FMagicLeapARPinState (Size: 0x14)
MagicLeapSharedWorldSharedData.PinIDs = 0x0 // TArray<FGuid> (Size: 0x10)
MaterialQualityOverrides.bDiscardQualityDuringCook = 0x0 // bool (Size: 0x1)
MaterialQualityOverrides.bEnableOverride = 0x1 // bool (Size: 0x1)
MaterialQualityOverrides.bForceFullyRough = 0x2 // bool (Size: 0x1)
MaterialQualityOverrides.bForceNonMetal = 0x3 // bool (Size: 0x1)
MaterialQualityOverrides.bForceDisableLMDirectionality = 0x4 // bool (Size: 0x1)
MaterialQualityOverrides.bForceLQReflections = 0x5 // bool (Size: 0x1)
MaterialQualityOverrides.bForceDisablePreintegratedGF = 0x6 // bool (Size: 0x1)
MaterialQualityOverrides.bDisableMaterialNormalCalculation = 0x7 // bool (Size: 0x1)
MaterialQualityOverrides.MobileShadowQuality = 0x8 // EEMobileShadowQuality (Size: 0x1)
MaterialQualityOverrides.bDisableAdditiveReflection = 0x9 // bool (Size: 0x1)
MaterialQualityOverrides.bDisableMaterialPlanarReflection = 0xa // bool (Size: 0x1)
MaterialQualityOverrides.bCalcILCPerVertex = 0xb // bool (Size: 0x1)
MaterialQualityOverrides.b1dSHForTransferTexture = 0xc // bool (Size: 0x1)
MaterialQualityOverrides.bDisableGeometricSpecularAA = 0xd // bool (Size: 0x1)
MaterialShaderQualitySettings.ForwardSettingMap = 0x28 // TMap<...> (Size: 0x50)
ShaderPlatformQualitySettings.QualityOverrides = 0x28 // FMaterialQualityOverrides (Size: 0xe)
BaseMediaSource.PlayerName = 0x80 // FName (Size: 0x8)
FileMediaSource.FilePath = 0x88 // FString (Size: 0x10)
FileMediaSource.PrecacheFile = 0x98 // bool (Size: 0x1)
MediaCaptureDevice.DisplayName = 0x0 // FText (Size: 0x18)
MediaCaptureDevice.URL = 0x18 // FString (Size: 0x10)
MediaComponent.MediaTexture = 0xf8 // MediaTexture* (Size: 0x8)
MediaComponent.MediaPlayer = 0x100 // MediaPlayer* (Size: 0x8)
MediaPlayer.OnEndReached = 0x30 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnMediaClosed = 0x40 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnMediaEventString = 0x50 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnMediaOpened = 0x60 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnMediaOpenFailed = 0x70 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnPlaybackResumed = 0x80 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnPlaybackSuspended = 0x90 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnSeekCompleted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.OnTracksChanged = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
MediaPlayer.CacheAhead = 0xc0 // FTimespan (Size: 0x8)
MediaPlayer.CacheBehind = 0xc8 // FTimespan (Size: 0x8)
MediaPlayer.CacheBehindGame = 0xd0 // FTimespan (Size: 0x8)
MediaPlayer.NativeAudioOut = 0xd8 // bool (Size: 0x1)
MediaPlayer.PlayOnOpen = 0xd9 // bool (Size: 0x1)
MediaPlayer.Shuffle = 0xdc // uint8_t (Size: 0x1)
MediaPlayer.Loop = 0xdc // uint8_t (Size: 0x1)
MediaPlayer.Playlist = 0xe0 // MediaPlaylist* (Size: 0x8)
MediaPlayer.PlaylistIndex = 0xe8 // int32_t (Size: 0x4)
MediaPlayer.TimeDelay = 0xf0 // FTimespan (Size: 0x8)
MediaPlayer.HorizontalFieldOfView = 0xf8 // float (Size: 0x4)
MediaPlayer.VerticalFieldOfView = 0xfc // float (Size: 0x4)
MediaPlayer.ViewRotation = 0x100 // FRotator (Size: 0xc)
MediaPlayer.PlayerGuid = 0x138 // FGuid (Size: 0x10)
MediaPlaylist.Items = 0x28 // TArray<MediaSource*> (Size: 0x10)
MediaSoundComponent.Channels = 0x700 // EEMediaSoundChannels (Size: 0x4)
MediaSoundComponent.DynamicRateAdjustment = 0x704 // bool (Size: 0x1)
MediaSoundComponent.RateAdjustmentFactor = 0x708 // float (Size: 0x4)
MediaSoundComponent.RateAdjustmentRange = 0x70c // FFloatRange (Size: 0x10)
MediaSoundComponent.MediaPlayer = 0x720 // MediaPlayer* (Size: 0x8)
MediaSoundComponentSpectralData.FrequencyHz = 0x0 // float (Size: 0x4)
MediaSoundComponentSpectralData.Magnitude = 0x4 // float (Size: 0x4)
MediaTexture.AddressX = 0xf0 // uint8_t (Size: 0x1)
MediaTexture.AddressY = 0xf1 // uint8_t (Size: 0x1)
MediaTexture.AutoClear = 0xf2 // bool (Size: 0x1)
MediaTexture.ClearColor = 0xf4 // FLinearColor (Size: 0x10)
MediaTexture.EnableGenMips = 0x104 // bool (Size: 0x1)
MediaTexture.NumMips = 0x105 // uint8_t (Size: 0x1)
MediaTexture.NewStyleOutput = 0x106 // bool (Size: 0x1)
MediaTexture.OutputFormat = 0x107 // uint8_t (Size: 0x1)
MediaTexture.CurrentAspectRatio = 0x108 // float (Size: 0x4)
MediaTexture.CurrentOrientation = 0x10c // uint8_t (Size: 0x1)
MediaTexture.MediaPlayer = 0x110 // MediaPlayer* (Size: 0x8)
MediaTimeStampInfo.Time = 0x28 // FTimespan (Size: 0x8)
MediaTimeStampInfo.SequenceIndex = 0x30 // int64_t (Size: 0x8)
PlatformMediaSource.MediaSource = 0x80 // MediaSource* (Size: 0x8)
StreamMediaSource.StreamUrl = 0x88 // FString (Size: 0x10)
TimeSynchronizableMediaSource.bUseTimeSynchronization = 0x88 // bool (Size: 0x1)
TimeSynchronizableMediaSource.FrameDelay = 0x8c // int32_t (Size: 0x4)
TimeSynchronizableMediaSource.TimeDelay = 0x90 // double (Size: 0x8)
MediaPlayerOptions.Tracks = 0x0 // FMediaPlayerTrackOptions (Size: 0x1c)
MediaPlayerOptions.SeekTime = 0x20 // FTimespan (Size: 0x8)
MediaPlayerOptions.PlayOnOpen = 0x28 // EEMediaPlayerOptionBooleanOverride (Size: 0x1)
MediaPlayerOptions.Loop = 0x29 // EEMediaPlayerOptionBooleanOverride (Size: 0x1)
MediaPlayerTrackOptions.Audio = 0x0 // int32_t (Size: 0x4)
MediaPlayerTrackOptions.Caption = 0x4 // int32_t (Size: 0x4)
MediaPlayerTrackOptions.MetaData = 0x8 // int32_t (Size: 0x4)
MediaPlayerTrackOptions.Script = 0xc // int32_t (Size: 0x4)
MediaPlayerTrackOptions.Subtitle = 0x10 // int32_t (Size: 0x4)
MediaPlayerTrackOptions.Text = 0x14 // int32_t (Size: 0x4)
MediaPlayerTrackOptions.Video = 0x18 // int32_t (Size: 0x4)
ElementID.IDValue = 0x0 // int32_t (Size: 0x4)
AcceptOutputProperties.bExportSeparatedPiecesAsNewMeshAssets = 0x60 // bool (Size: 0x1)
AddPatchTool.ShapeSettings = 0x90 // AddPatchToolProperties* (Size: 0x8)
AddPatchTool.MaterialProperties = 0x98 // NewMeshMaterialProperties* (Size: 0x8)
AddPatchTool.PreviewMesh = 0xa0 // PreviewMesh* (Size: 0x8)
AddPatchToolProperties.Width = 0x60 // float (Size: 0x4)
AddPatchToolProperties.Rotation = 0x64 // float (Size: 0x4)
AddPatchToolProperties.Subdivisions = 0x68 // int32_t (Size: 0x4)
AddPatchToolProperties.Shift = 0x6c // float (Size: 0x4)
AddPrimitiveTool.ShapeSettings = 0x90 // ProceduralShapeToolProperties* (Size: 0x8)
AddPrimitiveTool.MaterialProperties = 0x98 // NewMeshMaterialProperties* (Size: 0x8)
AddPrimitiveTool.PreviewMesh = 0xa0 // PreviewMesh* (Size: 0x8)
AddPrimitiveTool.LastGenerated = 0xa8 // LastActorInfo* (Size: 0x8)
AddPrimitiveTool.AssetName = 0xb0 // FString (Size: 0x10)
AlignObjectsTool.AlignProps = 0x98 // AlignObjectsToolProperties* (Size: 0x8)
AlignObjectsToolProperties.AlignType = 0x60 // EEAlignObjectsAlignTypes (Size: 0x4)
AlignObjectsToolProperties.AlignTo = 0x64 // EEAlignObjectsAlignToOptions (Size: 0x4)
AlignObjectsToolProperties.BoxPosition = 0x68 // EEAlignObjectsBoxPoint (Size: 0x4)
AlignObjectsToolProperties.bAlignX = 0x6c // bool (Size: 0x1)
AlignObjectsToolProperties.bAlignY = 0x6d // bool (Size: 0x1)
AlignObjectsToolProperties.bAlignZ = 0x6e // bool (Size: 0x1)
BakeMeshAttributeMapsTool.Settings = 0x90 // BakeMeshAttributeMapsToolProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.NormalMapProps = 0x98 // BakedNormalMapToolProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.OcclusionMapProps = 0xa0 // BakedOcclusionMapToolProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.CurvatureMapProps = 0xa8 // BakedCurvatureMapToolProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.Texture2DProps = 0xb0 // BakedTexture2DImageProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.VisualizationProps = 0xb8 // BakedOcclusionMapVisualizationProperties* (Size: 0x8)
BakeMeshAttributeMapsTool.PreviewMaterial = 0xd0 // MaterialInstanceDynamic* (Size: 0x8)
BakeMeshAttributeMapsTool.CachedNormalMap = 0x430 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.CachedOcclusionMap = 0x450 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.CachedCurvatureMap = 0x480 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.CachedMeshPropertyMap = 0x498 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.CachedTexture2DImageMap = 0x4b0 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.EmptyNormalMap = 0x4b8 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.EmptyColorMapBlack = 0x4c0 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsTool.EmptyColorMapWhite = 0x4c8 // Texture2D* (Size: 0x8)
BakeMeshAttributeMapsToolProperties.MapType = 0x60 // EEBakeMapType (Size: 0x4)
BakeMeshAttributeMapsToolProperties.Resolution = 0x64 // EEBakeTextureResolution (Size: 0x4)
BakeMeshAttributeMapsToolProperties.UVLayer = 0x68 // FString (Size: 0x10)
BakeMeshAttributeMapsToolProperties.UVLayerNamesList = 0x78 // TArray<FString> (Size: 0x10)
BakeMeshAttributeMapsToolProperties.bUseWorldSpace = 0x88 // bool (Size: 0x1)
BakeMeshAttributeMapsToolProperties.Result = 0x90 // Texture2D* (Size: 0x8)
BakeTransformTool.BasicProperties = 0x90 // BakeTransformToolProperties* (Size: 0x8)
BakeTransformToolProperties.bBakeRotation = 0x60 // bool (Size: 0x1)
BakeTransformToolProperties.BakeScale = 0x61 // EEBakeScaleMethod (Size: 0x1)
BakeTransformToolProperties.bRecenterPivot = 0x62 // bool (Size: 0x1)
BakedCurvatureMapToolProperties.CurvatureType = 0x60 // EEBakedCurvatureTypeMode (Size: 0x4)
BakedCurvatureMapToolProperties.ColorMode = 0x64 // EEBakedCurvatureColorMode (Size: 0x4)
BakedCurvatureMapToolProperties.RangeMultiplier = 0x68 // float (Size: 0x4)
BakedCurvatureMapToolProperties.MinRangeMultiplier = 0x6c // float (Size: 0x4)
BakedCurvatureMapToolProperties.Clamping = 0x70 // EEBakedCurvatureClampMode (Size: 0x4)
BakedCurvatureMapToolProperties.bGaussianBlur = 0x74 // bool (Size: 0x1)
BakedCurvatureMapToolProperties.BlurRadius = 0x78 // float (Size: 0x4)
BakedOcclusionMapToolProperties.OcclusionRays = 0x60 // int32_t (Size: 0x4)
BakedOcclusionMapToolProperties.MaxDistance = 0x64 // float (Size: 0x4)
BakedOcclusionMapToolProperties.bGaussianBlur = 0x68 // bool (Size: 0x1)
BakedOcclusionMapToolProperties.BlurRadius = 0x6c // float (Size: 0x4)
BakedOcclusionMapToolProperties.BiasAngle = 0x70 // float (Size: 0x4)
BakedOcclusionMapVisualizationProperties.BaseGrayLevel = 0x60 // float (Size: 0x4)
BakedOcclusionMapVisualizationProperties.OcclusionMultiplier = 0x64 // float (Size: 0x4)
BakedTexture2DImageProperties.SourceTexture = 0x60 // Texture2D* (Size: 0x8)
BakedTexture2DImageProperties.UVLayer = 0x68 // int32_t (Size: 0x4)
BaseKelvinletBrushOpProps.Stiffness = 0x60 // float (Size: 0x4)
BaseKelvinletBrushOpProps.Incompressiblity = 0x64 // float (Size: 0x4)
BaseKelvinletBrushOpProps.BrushSteps = 0x68 // int32_t (Size: 0x4)
BrushRemeshProperties.bEnableRemeshing = 0x70 // bool (Size: 0x1)
BrushRemeshProperties.TriangleSize = 0x74 // int32_t (Size: 0x4)
BrushRemeshProperties.PreserveDetail = 0x78 // int32_t (Size: 0x4)
BrushSculptProperties.bIsRemeshingEnabled = 0x60 // bool (Size: 0x1)
BrushSculptProperties.PrimaryBrushType = 0x61 // EEDynamicMeshSculptBrushType (Size: 0x1)
BrushSculptProperties.PrimaryBrushSpeed = 0x64 // float (Size: 0x4)
BrushSculptProperties.bPreserveUVFlow = 0x68 // bool (Size: 0x1)
BrushSculptProperties.bFreezeTarget = 0x69 // bool (Size: 0x1)
BrushSculptProperties.SmoothBrushSpeed = 0x6c // float (Size: 0x4)
BrushSculptProperties.bDetailPreservingSmooth = 0x70 // bool (Size: 0x1)
CSGMeshesTool.CSGProperties = 0xf0 // CSGMeshesToolProperties* (Size: 0x8)
CSGMeshesTool.DrawnLineSet = 0x108 // LineSetComponent* (Size: 0x8)
CSGMeshesToolProperties.Operation = 0x60 // EECSGOperation (Size: 0x1)
CSGMeshesToolProperties.bShowNewBoundaryEdges = 0x61 // bool (Size: 0x1)
CSGMeshesToolProperties.bAttemptFixHoles = 0x62 // bool (Size: 0x1)
CSGMeshesToolProperties.bOnlyUseFirstMeshMaterials = 0x63 // bool (Size: 0x1)
CollisionGeometryVisualizationProperties.LineThickness = 0x60 // float (Size: 0x4)
CollisionGeometryVisualizationProperties.bShowHidden = 0x64 // bool (Size: 0x1)
CollisionGeometryVisualizationProperties.Color = 0x68 // FColor (Size: 0x4)
CombineMeshesTool.BasicProperties = 0x90 // CombineMeshesToolProperties* (Size: 0x8)
CombineMeshesTool.HandleSourceProperties = 0x98 // OnAcceptHandleSourcesProperties* (Size: 0x8)
CombineMeshesToolProperties.bIsDuplicateMode = 0x60 // bool (Size: 0x1)
CombineMeshesToolProperties.WriteOutputTo = 0x64 // EECombineTargetType (Size: 0x4)
CombineMeshesToolProperties.OutputName = 0x68 // FString (Size: 0x10)
CombineMeshesToolProperties.OutputAsset = 0x78 // FString (Size: 0x10)
ConvertToPolygonsTool.Settings = 0x88 // ConvertToPolygonsToolProperties* (Size: 0x8)
ConvertToPolygonsTool.PreviewMesh = 0x90 // PreviewMesh* (Size: 0x8)
ConvertToPolygonsToolProperties.ConversionMode = 0x60 // EEConvertToPolygonsMode (Size: 0x4)
ConvertToPolygonsToolProperties.AngleTolerance = 0x64 // float (Size: 0x4)
ConvertToPolygonsToolProperties.bCalculateNormals = 0x68 // bool (Size: 0x1)
ConvertToPolygonsToolProperties.bShowGroupColors = 0x69 // bool (Size: 0x1)
DeformMeshPolygonsTool.DynamicMeshComponent = 0xc8 // SimpleDynamicMeshComponent* (Size: 0x8)
DeformMeshPolygonsTool.TransformProps = 0xd0 // DeformMeshPolygonsTransformProperties* (Size: 0x8)
DeformMeshPolygonsTransformProperties.DeformationStrategy = 0x60 // EEGroupTopologyDeformationStrategy (Size: 0x1)
DeformMeshPolygonsTransformProperties.TransformMode = 0x61 // EEQuickTransformerMode (Size: 0x1)
DeformMeshPolygonsTransformProperties.bSelectFaces = 0x62 // bool (Size: 0x1)
DeformMeshPolygonsTransformProperties.bSelectEdges = 0x63 // bool (Size: 0x1)
DeformMeshPolygonsTransformProperties.bSelectVertices = 0x64 // bool (Size: 0x1)
DeformMeshPolygonsTransformProperties.bSnapToWorldGrid = 0x65 // bool (Size: 0x1)
DeformMeshPolygonsTransformProperties.bShowWireframe = 0x66 // bool (Size: 0x1)
DeformMeshPolygonsTransformProperties.SelectedWeightScheme = 0x68 // EEWeightScheme (Size: 0x4)
DeformMeshPolygonsTransformProperties.HandleWeight = 0x70 // double (Size: 0x8)
DeformMeshPolygonsTransformProperties.bPostFixHandles = 0x78 // bool (Size: 0x1)
DiffusionSmoothProperties.SmoothingPerStep = 0x60 // float (Size: 0x4)
DiffusionSmoothProperties.Steps = 0x64 // int32_t (Size: 0x4)
DiffusionSmoothProperties.bPreserveUVs = 0x68 // bool (Size: 0x1)
DisplaceMeshCommonProperties.DisplacementType = 0x60 // EEDisplaceMeshToolDisplaceType (Size: 0x1)
DisplaceMeshCommonProperties.DisplaceIntensity = 0x64 // float (Size: 0x4)
DisplaceMeshCommonProperties.RandomSeed = 0x68 // int32_t (Size: 0x4)
DisplaceMeshCommonProperties.Subdivisions = 0x6c // int32_t (Size: 0x4)
DisplaceMeshCommonProperties.WeightMap = 0x70 // FName (Size: 0x8)
DisplaceMeshCommonProperties.WeightMapsList = 0x78 // TArray<FString> (Size: 0x10)
DisplaceMeshCommonProperties.bInvertWeightMap = 0x88 // bool (Size: 0x1)
DisplaceMeshCommonProperties.bDisableSizeWarning = 0x89 // bool (Size: 0x1)
DisplaceMeshDirectionalFilterProperties.bEnableFilter = 0x60 // bool (Size: 0x1)
DisplaceMeshDirectionalFilterProperties.FilterDirection = 0x64 // FVector (Size: 0xc)
DisplaceMeshDirectionalFilterProperties.FilterWidth = 0x70 // float (Size: 0x4)
DisplaceMeshPerlinNoiseProperties.PerlinLayerProperties = 0x60 // TArray<FPerlinLayerProperties> (Size: 0x10)
DisplaceMeshSineWaveProperties.SineWaveFrequency = 0x60 // float (Size: 0x4)
DisplaceMeshSineWaveProperties.SineWavePhaseShift = 0x64 // float (Size: 0x4)
DisplaceMeshSineWaveProperties.SineWaveDirection = 0x68 // FVector (Size: 0xc)
DisplaceMeshTextureMapProperties.DisplacementMap = 0x60 // Texture2D* (Size: 0x8)
DisplaceMeshTool.CommonProperties = 0x88 // DisplaceMeshCommonProperties* (Size: 0x8)
DisplaceMeshTool.DirectionalFilterProperties = 0x90 // DisplaceMeshDirectionalFilterProperties* (Size: 0x8)
DisplaceMeshTool.TextureMapProperties = 0x98 // DisplaceMeshTextureMapProperties* (Size: 0x8)
DisplaceMeshTool.NoiseProperties = 0xa0 // DisplaceMeshPerlinNoiseProperties* (Size: 0x8)
DisplaceMeshTool.SineWaveProperties = 0xa8 // DisplaceMeshSineWaveProperties* (Size: 0x8)
DrawAndRevolveTool.ControlPointsMechanic = 0xf8 // CurveControlPointsMechanic* (Size: 0x8)
DrawAndRevolveTool.PlaneMechanic = 0x100 // ConstructionPlaneMechanic* (Size: 0x8)
DrawAndRevolveTool.Settings = 0x108 // RevolveToolProperties* (Size: 0x8)
DrawAndRevolveTool.MaterialProperties = 0x110 // NewMeshMaterialProperties* (Size: 0x8)
DrawAndRevolveTool.Preview = 0x118 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
DrawPolyPathExtrudeProperties.Direction = 0x60 // EEDrawPolyPathExtrudeDirection (Size: 0x4)
DrawPolyPathProperties.OutputType = 0x60 // EEDrawPolyPathOutputMode (Size: 0x4)
DrawPolyPathProperties.WidthMode = 0x64 // EEDrawPolyPathWidthMode (Size: 0x4)
DrawPolyPathProperties.Width = 0x68 // float (Size: 0x4)
DrawPolyPathProperties.HeightMode = 0x6c // EEDrawPolyPathHeightMode (Size: 0x4)
DrawPolyPathProperties.Height = 0x70 // float (Size: 0x4)
DrawPolyPathProperties.RampStartRatio = 0x74 // float (Size: 0x4)
DrawPolyPathProperties.bSnapToWorldGrid = 0x78 // bool (Size: 0x1)
DrawPolyPathTool.TransformProps = 0xa0 // DrawPolyPathProperties* (Size: 0x8)
DrawPolyPathTool.ExtrudeProperties = 0xa8 // DrawPolyPathExtrudeProperties* (Size: 0x8)
DrawPolyPathTool.MaterialProperties = 0xb0 // NewMeshMaterialProperties* (Size: 0x8)
DrawPolyPathTool.PlaneMechanic = 0x140 // ConstructionPlaneMechanic* (Size: 0x8)
DrawPolyPathTool.EditPreview = 0x1e8 // PolyEditPreviewMesh* (Size: 0x8)
DrawPolyPathTool.ExtrudeHeightMechanic = 0x1f0 // PlaneDistanceFromHitMechanic* (Size: 0x8)
DrawPolyPathTool.CurveDistMechanic = 0x1f8 // SpatialCurveDistanceMechanic* (Size: 0x8)
DrawPolyPathTool.SurfacePathMechanic = 0x200 // CollectSurfacePathMechanic* (Size: 0x8)
DrawPolygonTool.PolygonProperties = 0x88 // DrawPolygonToolStandardProperties* (Size: 0x8)
DrawPolygonTool.SnapProperties = 0x90 // DrawPolygonToolSnapProperties* (Size: 0x8)
DrawPolygonTool.MaterialProperties = 0x98 // NewMeshMaterialProperties* (Size: 0x8)
DrawPolygonTool.PreviewMesh = 0x150 // PreviewMesh* (Size: 0x8)
DrawPolygonTool.PlaneTransformGizmo = 0x158 // TransformGizmo* (Size: 0x8)
DrawPolygonTool.PlaneTransformProxy = 0x160 // TransformProxy* (Size: 0x8)
DrawPolygonTool.HeightMechanic = 0x540 // PlaneDistanceFromHitMechanic* (Size: 0x8)
DrawPolygonToolSnapProperties.bEnableSnapping = 0x60 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.bSnapToWorldGrid = 0x61 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.bSnapToVertices = 0x62 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.bSnapToEdges = 0x63 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.bSnapToAngles = 0x64 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.bSnapToLengths = 0x65 // bool (Size: 0x1)
DrawPolygonToolSnapProperties.SegmentLength = 0x68 // float (Size: 0x4)
DrawPolygonToolSnapProperties.bHitSceneObjects = 0x6c // bool (Size: 0x1)
DrawPolygonToolSnapProperties.HitNormalOffset = 0x70 // float (Size: 0x4)
DrawPolygonToolStandardProperties.PolygonType = 0x60 // EEDrawPolygonDrawMode (Size: 0x1)
DrawPolygonToolStandardProperties.OutputMode = 0x61 // EEDrawPolygonOutputMode (Size: 0x1)
DrawPolygonToolStandardProperties.FeatureSizeRatio = 0x64 // float (Size: 0x4)
DrawPolygonToolStandardProperties.ExtrudeHeight = 0x68 // float (Size: 0x4)
DrawPolygonToolStandardProperties.Steps = 0x6c // int32_t (Size: 0x4)
DrawPolygonToolStandardProperties.bAllowSelfIntersections = 0x70 // bool (Size: 0x1)
DrawPolygonToolStandardProperties.bShowGizmo = 0x71 // bool (Size: 0x1)
DynamicMeshBrushTool.PreviewMesh = 0x1d0 // PreviewMesh* (Size: 0x8)
DynamicMeshSculptTool.BrushProperties = 0xc0 // SculptBrushProperties* (Size: 0x8)
DynamicMeshSculptTool.SculptProperties = 0xc8 // BrushSculptProperties* (Size: 0x8)
DynamicMeshSculptTool.SculptMaxBrushProperties = 0xd0 // SculptMaxBrushProperties* (Size: 0x8)
DynamicMeshSculptTool.KelvinBrushProperties = 0xd8 // KelvinBrushProperties* (Size: 0x8)
DynamicMeshSculptTool.RemeshProperties = 0xe0 // BrushRemeshProperties* (Size: 0x8)
DynamicMeshSculptTool.GizmoProperties = 0xe8 // FixedPlaneBrushProperties* (Size: 0x8)
DynamicMeshSculptTool.ViewProperties = 0xf0 // MeshEditingViewProperties* (Size: 0x8)
DynamicMeshSculptTool.BrushIndicator = 0x130 // BrushStampIndicator* (Size: 0x8)
DynamicMeshSculptTool.BrushIndicatorMaterial = 0x138 // MaterialInstanceDynamic* (Size: 0x8)
DynamicMeshSculptTool.BrushIndicatorMesh = 0x140 // PreviewMesh* (Size: 0x8)
DynamicMeshSculptTool.DynamicMeshComponent = 0x148 // OctreeDynamicMeshComponent* (Size: 0x8)
DynamicMeshSculptTool.ActiveOverrideMaterial = 0x150 // MaterialInstanceDynamic* (Size: 0x8)
DynamicMeshSculptTool.PlaneTransformGizmo = 0xc50 // TransformGizmo* (Size: 0x8)
DynamicMeshSculptTool.PlaneTransformProxy = 0xc58 // TransformProxy* (Size: 0x8)
EdgeLoopInsertionOperatorFactory.Tool = 0x30 // EdgeLoopInsertionTool* (Size: 0x8)
EdgeLoopInsertionProperties.PositionMode = 0x60 // EEEdgeLoopPositioningMode (Size: 0x4)
EdgeLoopInsertionProperties.InsertionMode = 0x64 // EEEdgeLoopInsertionMode (Size: 0x4)
EdgeLoopInsertionProperties.NumLoops = 0x68 // int32_t (Size: 0x4)
EdgeLoopInsertionProperties.ProportionOffset = 0x70 // double (Size: 0x8)
EdgeLoopInsertionProperties.DistanceOffset = 0x78 // double (Size: 0x8)
EdgeLoopInsertionProperties.bInteractive = 0x80 // bool (Size: 0x1)
EdgeLoopInsertionProperties.bFlipOffsetDirection = 0x81 // bool (Size: 0x1)
EdgeLoopInsertionProperties.bWireframe = 0x82 // bool (Size: 0x1)
EdgeLoopInsertionProperties.VertexTolerance = 0x88 // double (Size: 0x8)
EdgeLoopInsertionTool.Settings = 0x98 // EdgeLoopInsertionProperties* (Size: 0x8)
EdgeLoopInsertionTool.Preview = 0x300 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
EditMeshPolygonsTool.DynamicMeshComponent = 0xd0 // SimpleDynamicMeshComponent* (Size: 0x8)
EditMeshPolygonsTool.CommonProps = 0xd8 // PolyEditCommonProperties* (Size: 0x8)
EditMeshPolygonsTool.EditActions = 0xe0 // EditMeshPolygonsToolActions* (Size: 0x8)
EditMeshPolygonsTool.EditActions_Triangles = 0xe8 // EditMeshPolygonsToolActions_Triangles* (Size: 0x8)
EditMeshPolygonsTool.EditEdgeActions = 0xf0 // EditMeshPolygonsToolEdgeActions* (Size: 0x8)
EditMeshPolygonsTool.EditEdgeActions_Triangles = 0xf8 // EditMeshPolygonsToolEdgeActions_Triangles* (Size: 0x8)
EditMeshPolygonsTool.EditUVActions = 0x100 // EditMeshPolygonsToolUVActions* (Size: 0x8)
EditMeshPolygonsTool.ExtrudeProperties = 0x108 // PolyEditExtrudeProperties* (Size: 0x8)
EditMeshPolygonsTool.OffsetProperties = 0x110 // PolyEditOffsetProperties* (Size: 0x8)
EditMeshPolygonsTool.InsetProperties = 0x118 // PolyEditInsetProperties* (Size: 0x8)
EditMeshPolygonsTool.OutsetProperties = 0x120 // PolyEditOutsetProperties* (Size: 0x8)
EditMeshPolygonsTool.CutProperties = 0x128 // PolyEditCutProperties* (Size: 0x8)
EditMeshPolygonsTool.SetUVProperties = 0x130 // PolyEditSetUVProperties* (Size: 0x8)
EditMeshPolygonsTool.SelectionMechanic = 0x138 // PolygonSelectionMechanic* (Size: 0x8)
EditMeshPolygonsTool.MultiTransformer = 0x148 // MultiTransformer* (Size: 0x8)
EditMeshPolygonsTool.EditPreview = 0x4a0 // PolyEditPreviewMesh* (Size: 0x8)
EditMeshPolygonsTool.ExtrudeHeightMechanic = 0x4b0 // PlaneDistanceFromHitMechanic* (Size: 0x8)
EditMeshPolygonsTool.CurveDistMechanic = 0x4b8 // SpatialCurveDistanceMechanic* (Size: 0x8)
EditMeshPolygonsTool.SurfacePathMechanic = 0x4c0 // CollectSurfacePathMechanic* (Size: 0x8)
EditNormalsOperatorFactory.Tool = 0x30 // EditNormalsTool* (Size: 0x8)
EditNormalsTool.BasicProperties = 0x90 // EditNormalsToolProperties* (Size: 0x8)
EditNormalsTool.AdvancedProperties = 0x98 // EditNormalsAdvancedProperties* (Size: 0x8)
EditNormalsTool.Previews = 0xa0 // TArray<MeshOpPreviewWithBackgroundCompute*> (Size: 0x10)
EditNormalsToolProperties.bRecomputeNormals = 0x60 // bool (Size: 0x1)
EditNormalsToolProperties.NormalCalculationMethod = 0x61 // EENormalCalculationMethod (Size: 0x1)
EditNormalsToolProperties.bFixInconsistentNormals = 0x62 // bool (Size: 0x1)
EditNormalsToolProperties.bInvertNormals = 0x63 // bool (Size: 0x1)
EditNormalsToolProperties.SplitNormalMethod = 0x64 // EESplitNormalMethod (Size: 0x1)
EditNormalsToolProperties.SharpEdgeAngleThreshold = 0x68 // float (Size: 0x4)
EditNormalsToolProperties.bAllowSharpVertices = 0x6c // bool (Size: 0x1)
EditPivotTarget.TransformProxy = 0x0 // TransformProxy* (Size: 0x8)
EditPivotTarget.TransformGizmo = 0x8 // TransformGizmo* (Size: 0x8)
EditPivotTool.TransformProps = 0x98 // EditPivotToolProperties* (Size: 0x8)
EditPivotTool.EditPivotActions = 0xa0 // EditPivotToolActionPropertySet* (Size: 0x8)
EditPivotTool.ActiveGizmos = 0x178 // TArray<FEditPivotTarget> (Size: 0x10)
EditPivotToolActionPropertySet.bUseWorldBox = 0x68 // bool (Size: 0x1)
EditPivotToolProperties.bEnableSnapDragging = 0x60 // bool (Size: 0x1)
EditPivotToolProperties.RotationMode = 0x61 // EEEditPivotSnapDragRotationMode (Size: 0x1)
EditUVIslandsTool.MaterialSettings = 0xc8 // ExistingMeshMaterialProperties* (Size: 0x8)
EditUVIslandsTool.CheckerMaterial = 0xd0 // MaterialInstanceDynamic* (Size: 0x8)
EditUVIslandsTool.DynamicMeshComponent = 0xd8 // SimpleDynamicMeshComponent* (Size: 0x8)
EditUVIslandsTool.SelectionMechanic = 0xe0 // PolygonSelectionMechanic* (Size: 0x8)
EditUVIslandsTool.MultiTransformer = 0xf0 // MultiTransformer* (Size: 0x8)
EraseBrushOpProps.Strength = 0x60 // float (Size: 0x4)
EraseBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
ExistingMeshMaterialProperties.MaterialMode = 0x60 // EESetMeshMaterialMode (Size: 0x1)
ExistingMeshMaterialProperties.CheckerDensity = 0x64 // float (Size: 0x4)
ExistingMeshMaterialProperties.OverrideMaterial = 0x68 // MaterialInterface* (Size: 0x8)
ExistingMeshMaterialProperties.CheckerMaterial = 0x70 // MaterialInstanceDynamic* (Size: 0x8)
ExtractCollisionGeometryTool.VizSettings = 0x88 // CollisionGeometryVisualizationProperties* (Size: 0x8)
ExtractCollisionGeometryTool.ObjectProps = 0x90 // PhysicsObjectToolPropertySet* (Size: 0x8)
ExtractCollisionGeometryTool.PreviewElements = 0x98 // PreviewGeometry* (Size: 0x8)
ExtractCollisionGeometryTool.PreviewMesh = 0xa0 // PreviewMesh* (Size: 0x8)
FixedPlaneBrushOpProps.Strength = 0x60 // float (Size: 0x4)
FixedPlaneBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
FixedPlaneBrushOpProps.Depth = 0x68 // float (Size: 0x4)
FixedPlaneBrushOpProps.WhichSide = 0x6c // EEPlaneBrushSideMode (Size: 0x1)
FixedPlaneBrushProperties.bPropertySetEnabled = 0x60 // bool (Size: 0x1)
FixedPlaneBrushProperties.bShowGizmo = 0x61 // bool (Size: 0x1)
FixedPlaneBrushProperties.bSnapToGrid = 0x62 // bool (Size: 0x1)
FixedPlaneBrushProperties.position = 0x64 // FVector (Size: 0xc)
FixedPlaneBrushProperties.Rotation = 0x70 // FQuat (Size: 0x10)
FlattenBrushOpProps.Strength = 0x60 // float (Size: 0x4)
FlattenBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
FlattenBrushOpProps.Depth = 0x68 // float (Size: 0x4)
FlattenBrushOpProps.WhichSide = 0x6c // EEPlaneBrushSideMode (Size: 0x1)
GroupEdgeInsertionOperatorFactory.Tool = 0x30 // GroupEdgeInsertionTool* (Size: 0x8)
GroupEdgeInsertionProperties.InsertionMode = 0x60 // EEGroupEdgeInsertionMode (Size: 0x4)
GroupEdgeInsertionProperties.bWireframe = 0x64 // bool (Size: 0x1)
GroupEdgeInsertionProperties.VertexTolerance = 0x68 // double (Size: 0x8)
GroupEdgeInsertionTool.Settings = 0x98 // GroupEdgeInsertionProperties* (Size: 0x8)
GroupEdgeInsertionTool.Preview = 0xa0 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
HoleFillOperatorFactory.FillTool = 0x30 // HoleFillTool* (Size: 0x8)
HoleFillStatisticsProperties.InitialHoles = 0x60 // FString (Size: 0x10)
HoleFillStatisticsProperties.SelectedHoles = 0x70 // FString (Size: 0x10)
HoleFillStatisticsProperties.SuccessfulFills = 0x80 // FString (Size: 0x10)
HoleFillStatisticsProperties.FailedFills = 0x90 // FString (Size: 0x10)
HoleFillStatisticsProperties.RemainingHoles = 0xa0 // FString (Size: 0x10)
HoleFillTool.SmoothHoleFillProperties = 0x98 // SmoothHoleFillProperties* (Size: 0x8)
HoleFillTool.Properties = 0xa0 // HoleFillToolProperties* (Size: 0x8)
HoleFillTool.Actions = 0xa8 // HoleFillToolActions* (Size: 0x8)
HoleFillTool.Statistics = 0xb0 // HoleFillStatisticsProperties* (Size: 0x8)
HoleFillTool.Preview = 0xb8 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
HoleFillTool.SelectionMechanic = 0xc0 // PolygonSelectionMechanic* (Size: 0x8)
HoleFillToolProperties.FillType = 0x60 // EEHoleFillOpFillType (Size: 0x1)
HoleFillToolProperties.bRemoveIsolatedTriangles = 0x61 // bool (Size: 0x1)
ImplicitOffsetProperties.Smoothness = 0x60 // float (Size: 0x4)
ImplicitOffsetProperties.bPreserveUVs = 0x64 // bool (Size: 0x1)
ImplicitSmoothProperties.SmoothSpeed = 0x60 // float (Size: 0x4)
ImplicitSmoothProperties.Smoothness = 0x64 // float (Size: 0x4)
ImplicitSmoothProperties.bPreserveUVs = 0x68 // bool (Size: 0x1)
ImplicitSmoothProperties.VolumeCorrection = 0x6c // float (Size: 0x4)
InflateBrushOpProps.Strength = 0x60 // float (Size: 0x4)
InflateBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
IterativeOffsetProperties.Steps = 0x60 // int32_t (Size: 0x4)
IterativeOffsetProperties.bOffsetBoundaries = 0x64 // bool (Size: 0x1)
IterativeOffsetProperties.SmoothingPerStep = 0x68 // float (Size: 0x4)
IterativeOffsetProperties.bReprojectSmooth = 0x6c // bool (Size: 0x1)
IterativeSmoothProperties.SmoothingPerStep = 0x60 // float (Size: 0x4)
IterativeSmoothProperties.Steps = 0x64 // int32_t (Size: 0x4)
IterativeSmoothProperties.bSmoothBoundary = 0x68 // bool (Size: 0x1)
KelvinBrushProperties.FalloffDistance = 0x60 // float (Size: 0x4)
KelvinBrushProperties.Stiffness = 0x64 // float (Size: 0x4)
KelvinBrushProperties.Incompressiblity = 0x68 // float (Size: 0x4)
KelvinBrushProperties.BrushSteps = 0x6c // int32_t (Size: 0x4)
LastActorInfo.Actor = 0x38 // Actor* (Size: 0x8)
LastActorInfo.StaticMesh = 0x40 // StaticMesh* (Size: 0x8)
LastActorInfo.ShapeSettings = 0x48 // ProceduralShapeToolProperties* (Size: 0x8)
LastActorInfo.MaterialProperties = 0x50 // NewMeshMaterialProperties* (Size: 0x8)
MeshAnalysisProperties.SurfaceArea = 0x60 // FString (Size: 0x10)
MeshAnalysisProperties.Volume = 0x70 // FString (Size: 0x10)
MeshAttributePaintTool.AttribProps = 0x210 // MeshAttributePaintToolProperties* (Size: 0x8)
MeshAttributePaintToolProperties.Attributes = 0x60 // TArray<FName> (Size: 0x10)
MeshAttributePaintToolProperties.SelectedAttribute = 0x70 // int32_t (Size: 0x4)
MeshAttributePaintToolProperties.AttributeName = 0x78 // FString (Size: 0x10)
MeshBoundaryToolBase.SelectionMechanic = 0x138 // PolygonSelectionMechanic* (Size: 0x8)
MeshBoundaryToolBase.LoopSelectClickBehavior = 0x140 // SingleClickInputBehavior* (Size: 0x8)
MeshConstraintProperties.bPreserveSharpEdges = 0x60 // bool (Size: 0x1)
MeshConstraintProperties.MeshBoundaryConstraint = 0x61 // EEMeshBoundaryConstraint (Size: 0x1)
MeshConstraintProperties.GroupBoundaryConstraint = 0x62 // EEGroupBoundaryConstraint (Size: 0x1)
MeshConstraintProperties.MaterialBoundaryConstraint = 0x63 // EEMaterialBoundaryConstraint (Size: 0x1)
MeshConstraintProperties.bPreventNormalFlips = 0x64 // bool (Size: 0x1)
MeshEditingViewProperties.bShowWireframe = 0x60 // bool (Size: 0x1)
MeshEditingViewProperties.MaterialMode = 0x64 // EEMeshEditingMaterialModes (Size: 0x4)
MeshEditingViewProperties.bFlatShading = 0x68 // bool (Size: 0x1)
MeshEditingViewProperties.Color = 0x6c // FLinearColor (Size: 0x10)
MeshEditingViewProperties.Image = 0x80 // Texture2D* (Size: 0x8)
MeshInspectorProperties.bWireframe = 0x60 // bool (Size: 0x1)
MeshInspectorProperties.bBoundaryEdges = 0x61 // bool (Size: 0x1)
MeshInspectorProperties.bBowtieVertices = 0x62 // bool (Size: 0x1)
MeshInspectorProperties.bPolygonBorders = 0x63 // bool (Size: 0x1)
MeshInspectorProperties.bUVSeams = 0x64 // bool (Size: 0x1)
MeshInspectorProperties.bUVBowties = 0x65 // bool (Size: 0x1)
MeshInspectorProperties.bNormalSeams = 0x66 // bool (Size: 0x1)
MeshInspectorProperties.bNormalVectors = 0x67 // bool (Size: 0x1)
MeshInspectorProperties.bTangentVectors = 0x68 // bool (Size: 0x1)
MeshInspectorProperties.NormalLength = 0x6c // float (Size: 0x4)
MeshInspectorProperties.TangentLength = 0x70 // float (Size: 0x4)
MeshInspectorTool.Settings = 0x88 // MeshInspectorProperties* (Size: 0x8)
MeshInspectorTool.MaterialSettings = 0x90 // ExistingMeshMaterialProperties* (Size: 0x8)
MeshInspectorTool.PreviewMesh = 0xa0 // PreviewMesh* (Size: 0x8)
MeshInspectorTool.DrawnLineSet = 0xa8 // LineSetComponent* (Size: 0x8)
MeshInspectorTool.DefaultMaterial = 0xb0 // MaterialInterface* (Size: 0x8)
MeshSculptToolBase.BrushProperties = 0xc0 // SculptBrushProperties* (Size: 0x8)
MeshSculptToolBase.GizmoProperties = 0xc8 // WorkPlaneProperties* (Size: 0x8)
MeshSculptToolBase.BrushOpPropSets = 0x1b0 // TMap<...> (Size: 0x50)
MeshSculptToolBase.SecondaryBrushOpPropSets = 0x250 // TMap<...> (Size: 0x50)
MeshSculptToolBase.ViewProperties = 0x870 // MeshEditingViewProperties* (Size: 0x8)
MeshSculptToolBase.ActiveOverrideMaterial = 0x878 // MaterialInstanceDynamic* (Size: 0x8)
MeshSculptToolBase.BrushIndicator = 0x880 // BrushStampIndicator* (Size: 0x8)
MeshSculptToolBase.BrushIndicatorMaterial = 0x888 // MaterialInstanceDynamic* (Size: 0x8)
MeshSculptToolBase.BrushIndicatorMesh = 0x890 // PreviewMesh* (Size: 0x8)
MeshSculptToolBase.PlaneTransformGizmo = 0x898 // TransformGizmo* (Size: 0x8)
MeshSculptToolBase.PlaneTransformProxy = 0x8a0 // TransformProxy* (Size: 0x8)
MeshSelectionTool.SelectionProps = 0x210 // MeshSelectionToolProperties* (Size: 0x8)
MeshSelectionTool.SelectionActions = 0x218 // MeshSelectionEditActions* (Size: 0x8)
MeshSelectionTool.EditActions = 0x220 // MeshSelectionToolActionPropertySet* (Size: 0x8)
MeshSelectionTool.Selection = 0x228 // MeshSelectionSet* (Size: 0x8)
MeshSelectionTool.SpawnedActors = 0x230 // TArray<Actor*> (Size: 0x10)
MeshSelectionToolProperties.SelectionMode = 0x60 // EEMeshSelectionToolPrimaryMode (Size: 0x4)
MeshSelectionToolProperties.AngleTolerance = 0x64 // float (Size: 0x4)
MeshSelectionToolProperties.bHitBackFaces = 0x68 // bool (Size: 0x1)
MeshSelectionToolProperties.bShowWireframe = 0x69 // bool (Size: 0x1)
MeshSelectionToolProperties.FaceColorMode = 0x6c // EEMeshFacesColorMode (Size: 0x4)
MeshSpaceDeformerTool.SelectedOperationType = 0xc0 // EENonlinearOperationType (Size: 0x1)
MeshSpaceDeformerTool.UpperBoundsInterval = 0xc4 // float (Size: 0x4)
MeshSpaceDeformerTool.LowerBoundsInterval = 0xc8 // float (Size: 0x4)
MeshSpaceDeformerTool.ModifierPercent = 0xcc // float (Size: 0x4)
MeshSpaceDeformerTool.bSnapToWorldGrid = 0xd0 // bool (Size: 0x1)
MeshSpaceDeformerTool.StateTarget = 0xd8 // GizmoTransformChangeStateTarget* (Size: 0x8)
MeshSpaceDeformerTool.Preview = 0xe8 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
MeshSpaceDeformerTool.GizmoCenter = 0x110 // FVector (Size: 0xc)
MeshSpaceDeformerTool.GizmoOrientation = 0x120 // FQuat (Size: 0x10)
MeshSpaceDeformerTool.IntervalGizmo = 0x130 // IntervalGizmo* (Size: 0x8)
MeshSpaceDeformerTool.TransformGizmo = 0x138 // TransformGizmo* (Size: 0x8)
MeshSpaceDeformerTool.TransformProxy = 0x140 // TransformProxy* (Size: 0x8)
MeshSpaceDeformerTool.UpIntervalSource = 0x148 // GizmoLocalFloatParameterSource* (Size: 0x8)
MeshSpaceDeformerTool.DownIntervalSource = 0x150 // GizmoLocalFloatParameterSource* (Size: 0x8)
MeshSpaceDeformerTool.ForwardIntervalSource = 0x158 // GizmoLocalFloatParameterSource* (Size: 0x8)
MeshStatisticsProperties.Mesh = 0x60 // FString (Size: 0x10)
MeshStatisticsProperties.UV = 0x70 // FString (Size: 0x10)
MeshStatisticsProperties.Attributes = 0x80 // FString (Size: 0x10)
MeshVertexSculptTool.SculptProperties = 0x9d8 // VertexBrushSculptProperties* (Size: 0x8)
MeshVertexSculptTool.DynamicMeshComponent = 0x9e0 // SimpleDynamicMeshComponent* (Size: 0x8)
MirrorOperatorFactory.MirrorTool = 0x30 // MirrorTool* (Size: 0x8)
MirrorTool.Settings = 0x98 // MirrorToolProperties* (Size: 0x8)
MirrorTool.ToolActions = 0xa0 // MirrorToolActionPropertySet* (Size: 0x8)
MirrorTool.MeshesToMirror = 0xa8 // TArray<DynamicMeshReplacementChangeTarget*> (Size: 0x10)
MirrorTool.Previews = 0xb8 // TArray<MeshOpPreviewWithBackgroundCompute*> (Size: 0x10)
MirrorTool.PlaneMechanic = 0x110 // ConstructionPlaneMechanic* (Size: 0x8)
MirrorToolProperties.OperationMode = 0x60 // EEMirrorOperationMode (Size: 0x1)
MirrorToolProperties.bCropAlongMirrorPlaneFirst = 0x61 // bool (Size: 0x1)
MirrorToolProperties.bWeldVerticesOnMirrorPlane = 0x62 // bool (Size: 0x1)
MirrorToolProperties.bAllowBowtieVertexCreation = 0x63 // bool (Size: 0x1)
MirrorToolProperties.bSnapToWorldGrid = 0x64 // bool (Size: 0x1)
MirrorToolProperties.CtrlClickBehavior = 0x65 // EEMirrorCtrlClickBehavior (Size: 0x1)
MirrorToolProperties.bButtonsOnlyChangeOrientation = 0x66 // bool (Size: 0x1)
MirrorToolProperties.bShowPreview = 0x67 // bool (Size: 0x1)
MirrorToolProperties.SaveMode = 0x68 // EEMirrorSaveMode (Size: 0x1)
MoveBrushOpProps.Strength = 0x60 // float (Size: 0x4)
MoveBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
MoveBrushOpProps.Depth = 0x68 // float (Size: 0x4)
NewMeshMaterialProperties.Material = 0x60 // TWeakObjectPtr<UObject> (Size: 0x8)
NewMeshMaterialProperties.UVScale = 0x68 // float (Size: 0x4)
NewMeshMaterialProperties.bWorldSpaceUVScale = 0x6c // bool (Size: 0x1)
NewMeshMaterialProperties.bWireframe = 0x6d // bool (Size: 0x1)
NewMeshMaterialProperties.bShowExtendedOptions = 0x6e // bool (Size: 0x1)
OffsetMeshTool.OffsetProperties = 0x400 // OffsetMeshToolProperties* (Size: 0x8)
OffsetMeshTool.IterativeProperties = 0x408 // IterativeOffsetProperties* (Size: 0x8)
OffsetMeshTool.ImplicitProperties = 0x410 // ImplicitOffsetProperties* (Size: 0x8)
OffsetMeshTool.WeightMapProperties = 0x418 // OffsetWeightMapSetProperties* (Size: 0x8)
OffsetMeshToolProperties.OffsetType = 0x60 // EEOffsetMeshToolOffsetType (Size: 0x1)
OffsetMeshToolProperties.Distance = 0x64 // float (Size: 0x4)
OffsetMeshToolProperties.bCreateShell = 0x68 // bool (Size: 0x1)
OffsetWeightMapSetProperties.MinDistance = 0x80 // float (Size: 0x4)
PerlinLayerProperties.Frequency = 0x0 // float (Size: 0x4)
PerlinLayerProperties.Intensity = 0x4 // float (Size: 0x4)
PhysicsBoxData.Dimensions = 0x0 // FVector (Size: 0xc)
PhysicsBoxData.Transform = 0x10 // FTransform (Size: 0x30)
PhysicsBoxData.Element = 0x40 // FKShapeElem (Size: 0x30)
PhysicsCapsuleData.Radius = 0x0 // float (Size: 0x4)
PhysicsCapsuleData.Length = 0x4 // float (Size: 0x4)
PhysicsCapsuleData.Transform = 0x10 // FTransform (Size: 0x30)
PhysicsCapsuleData.Element = 0x40 // FKShapeElem (Size: 0x30)
PhysicsConvexData.NumVertices = 0x0 // int32_t (Size: 0x4)
PhysicsConvexData.NumFaces = 0x4 // int32_t (Size: 0x4)
PhysicsConvexData.Element = 0x8 // FKShapeElem (Size: 0x30)
PhysicsInspectorTool.VizSettings = 0x90 // CollisionGeometryVisualizationProperties* (Size: 0x8)
PhysicsInspectorTool.ObjectData = 0x98 // TArray<PhysicsObjectToolPropertySet*> (Size: 0x10)
PhysicsInspectorTool.LineMaterial = 0xa8 // MaterialInterface* (Size: 0x8)
PhysicsInspectorTool.PreviewElements = 0xb0 // TArray<PreviewGeometry*> (Size: 0x10)
PhysicsObjectToolPropertySet.ObjectName = 0x60 // FString (Size: 0x10)
PhysicsObjectToolPropertySet.CollisionType = 0x70 // EECollisionGeometryMode (Size: 0x4)
PhysicsObjectToolPropertySet.Spheres = 0x78 // TArray<FPhysicsSphereData> (Size: 0x10)
PhysicsObjectToolPropertySet.Boxes = 0x88 // TArray<FPhysicsBoxData> (Size: 0x10)
PhysicsObjectToolPropertySet.Capsules = 0x98 // TArray<FPhysicsCapsuleData> (Size: 0x10)
PhysicsObjectToolPropertySet.Convexes = 0xa8 // TArray<FPhysicsConvexData> (Size: 0x10)
PhysicsSphereData.Radius = 0x0 // float (Size: 0x4)
PhysicsSphereData.Transform = 0x10 // FTransform (Size: 0x30)
PhysicsSphereData.Element = 0x40 // FKShapeElem (Size: 0x30)
PinchBrushOpProps.Strength = 0x60 // float (Size: 0x4)
PinchBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
PinchBrushOpProps.Depth = 0x68 // float (Size: 0x4)
PinchBrushOpProps.bPerpDamping = 0x6c // bool (Size: 0x1)
PlaneBrushOpProps.Strength = 0x60 // float (Size: 0x4)
PlaneBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
PlaneBrushOpProps.Depth = 0x68 // float (Size: 0x4)
PlaneBrushOpProps.WhichSide = 0x6c // EEPlaneBrushSideMode (Size: 0x1)
PlaneCutOperatorFactory.CutTool = 0x30 // PlaneCutTool* (Size: 0x8)
PlaneCutTool.BasicProperties = 0x98 // PlaneCutToolProperties* (Size: 0x8)
PlaneCutTool.AcceptProperties = 0xa0 // AcceptOutputProperties* (Size: 0x8)
PlaneCutTool.CutPlaneOrigin = 0xa8 // FVector (Size: 0xc)
PlaneCutTool.CutPlaneOrientation = 0xc0 // FQuat (Size: 0x10)
PlaneCutTool.Previews = 0xd0 // TArray<MeshOpPreviewWithBackgroundCompute*> (Size: 0x10)
PlaneCutTool.MeshesToCut = 0xe0 // TArray<DynamicMeshReplacementChangeTarget*> (Size: 0x10)
PlaneCutTool.PlaneTransformGizmo = 0x158 // TransformGizmo* (Size: 0x8)
PlaneCutTool.PlaneTransformProxy = 0x160 // TransformProxy* (Size: 0x8)
PlaneCutToolProperties.bSnapToWorldGrid = 0x60 // bool (Size: 0x1)
PlaneCutToolProperties.bKeepBothHalves = 0x61 // bool (Size: 0x1)
PlaneCutToolProperties.SpacingBetweenHalves = 0x64 // float (Size: 0x4)
PlaneCutToolProperties.bFillCutHole = 0x68 // bool (Size: 0x1)
PlaneCutToolProperties.bShowPreview = 0x69 // bool (Size: 0x1)
PlaneCutToolProperties.bFillSpans = 0x6a // bool (Size: 0x1)
PolyEditCommonProperties.bShowWireframe = 0x60 // bool (Size: 0x1)
PolyEditCommonProperties.bSelectEdgeLoops = 0x61 // bool (Size: 0x1)
PolyEditCommonProperties.LocalFrameMode = 0x64 // EELocalFrameMode (Size: 0x4)
PolyEditCommonProperties.bLockRotation = 0x68 // bool (Size: 0x1)
PolyEditCommonProperties.bSnapToWorldGrid = 0x69 // bool (Size: 0x1)
PolyEditCutProperties.Orientation = 0x60 // EEPolyEditCutPlaneOrientation (Size: 0x4)
PolyEditCutProperties.bSnapToVertices = 0x64 // bool (Size: 0x1)
PolyEditExtrudeProperties.Direction = 0x60 // EEPolyEditExtrudeDirection (Size: 0x4)
PolyEditExtrudeProperties.bShellsToSolids = 0x64 // bool (Size: 0x1)
PolyEditInsetProperties.bReproject = 0x60 // bool (Size: 0x1)
PolyEditInsetProperties.Softness = 0x64 // float (Size: 0x4)
PolyEditInsetProperties.bBoundaryOnly = 0x68 // bool (Size: 0x1)
PolyEditInsetProperties.AreaScale = 0x6c // float (Size: 0x4)
PolyEditOffsetProperties.bUseFaceNormals = 0x60 // bool (Size: 0x1)
PolyEditOutsetProperties.Softness = 0x60 // float (Size: 0x4)
PolyEditOutsetProperties.bBoundaryOnly = 0x64 // bool (Size: 0x1)
PolyEditOutsetProperties.AreaScale = 0x68 // float (Size: 0x4)
PolyEditSetUVProperties.bShowMaterial = 0x60 // bool (Size: 0x1)
PositionPlaneGizmo.CenterBallShape = 0x88 // PreviewMesh* (Size: 0x8)
PositionPlaneGizmo.CenterBallMaterial = 0x90 // MaterialInstance* (Size: 0x8)
ProceduralArrowToolProperties.ShaftRadius = 0x70 // float (Size: 0x4)
ProceduralArrowToolProperties.ShaftHeight = 0x74 // float (Size: 0x4)
ProceduralArrowToolProperties.HeadRadius = 0x78 // float (Size: 0x4)
ProceduralArrowToolProperties.HeadHeight = 0x7c // float (Size: 0x4)
ProceduralArrowToolProperties.RadialSlices = 0x80 // int32_t (Size: 0x4)
ProceduralArrowToolProperties.TotalSubdivisions = 0x84 // int32_t (Size: 0x4)
ProceduralBoxToolProperties.Height = 0x80 // float (Size: 0x4)
ProceduralBoxToolProperties.HeightSubdivisions = 0x84 // int32_t (Size: 0x4)
ProceduralConeToolProperties.Radius = 0x70 // float (Size: 0x4)
ProceduralConeToolProperties.Height = 0x74 // float (Size: 0x4)
ProceduralConeToolProperties.RadialSlices = 0x78 // int32_t (Size: 0x4)
ProceduralConeToolProperties.HeightSubdivisions = 0x7c // int32_t (Size: 0x4)
ProceduralCylinderToolProperties.Radius = 0x70 // float (Size: 0x4)
ProceduralCylinderToolProperties.Height = 0x74 // float (Size: 0x4)
ProceduralCylinderToolProperties.RadialSlices = 0x78 // int32_t (Size: 0x4)
ProceduralCylinderToolProperties.HeightSubdivisions = 0x7c // int32_t (Size: 0x4)
ProceduralDiscToolProperties.Radius = 0x70 // float (Size: 0x4)
ProceduralDiscToolProperties.RadialSlices = 0x74 // int32_t (Size: 0x4)
ProceduralDiscToolProperties.RadialSubdivisions = 0x78 // int32_t (Size: 0x4)
ProceduralPuncturedDiscToolProperties.HoleRadius = 0x80 // float (Size: 0x4)
ProceduralRectangleToolProperties.Width = 0x70 // float (Size: 0x4)
ProceduralRectangleToolProperties.Depth = 0x74 // float (Size: 0x4)
ProceduralRectangleToolProperties.WidthSubdivisions = 0x78 // int32_t (Size: 0x4)
ProceduralRectangleToolProperties.DepthSubdivisions = 0x7c // int32_t (Size: 0x4)
ProceduralRoundedRectangleToolProperties.CornerRadius = 0x80 // float (Size: 0x4)
ProceduralRoundedRectangleToolProperties.CornerSlices = 0x84 // int32_t (Size: 0x4)
ProceduralShapeToolProperties.bInstanceIfPossible = 0x60 // bool (Size: 0x1)
ProceduralShapeToolProperties.PolygroupMode = 0x61 // EEMakeMeshPolygroupMode (Size: 0x1)
ProceduralShapeToolProperties.PlaceMode = 0x62 // EEMakeMeshPlacementType (Size: 0x1)
ProceduralShapeToolProperties.bSnapToGrid = 0x63 // bool (Size: 0x1)
ProceduralShapeToolProperties.PivotLocation = 0x64 // EEMakeMeshPivotLocation (Size: 0x1)
ProceduralShapeToolProperties.Rotation = 0x68 // float (Size: 0x4)
ProceduralShapeToolProperties.bAlignShapeToPlacementSurface = 0x6c // bool (Size: 0x1)
ProceduralSphereToolProperties.Radius = 0x70 // float (Size: 0x4)
ProceduralSphereToolProperties.LatitudeSlices = 0x74 // int32_t (Size: 0x4)
ProceduralSphereToolProperties.LongitudeSlices = 0x78 // int32_t (Size: 0x4)
ProceduralSphericalBoxToolProperties.Radius = 0x70 // float (Size: 0x4)
ProceduralSphericalBoxToolProperties.Subdivisions = 0x74 // int32_t (Size: 0x4)
ProceduralTorusToolProperties.MajorRadius = 0x70 // float (Size: 0x4)
ProceduralTorusToolProperties.MinorRadius = 0x74 // float (Size: 0x4)
ProceduralTorusToolProperties.TubeSlices = 0x78 // int32_t (Size: 0x4)
ProceduralTorusToolProperties.CrossSectionSlices = 0x7c // int32_t (Size: 0x4)
PullKelvinletBrushOpProps.Falloff = 0x70 // float (Size: 0x4)
PullKelvinletBrushOpProps.Depth = 0x74 // float (Size: 0x4)
RemeshMeshTool.BasicProperties = 0x98 // RemeshMeshToolProperties* (Size: 0x8)
RemeshMeshTool.MeshStatisticsProperties = 0xa0 // MeshStatisticsProperties* (Size: 0x8)
RemeshMeshTool.Preview = 0xa8 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
RemeshMeshToolProperties.TargetTriangleCount = 0x70 // int32_t (Size: 0x4)
RemeshMeshToolProperties.SmoothingType = 0x74 // EERemeshSmoothingType (Size: 0x1)
RemeshMeshToolProperties.bDiscardAttributes = 0x75 // bool (Size: 0x1)
RemeshMeshToolProperties.bShowWireframe = 0x76 // bool (Size: 0x1)
RemeshMeshToolProperties.bShowGroupColors = 0x77 // bool (Size: 0x1)
RemeshMeshToolProperties.RemeshType = 0x78 // EERemeshType (Size: 0x1)
RemeshMeshToolProperties.RemeshIterations = 0x7c // int32_t (Size: 0x4)
RemeshMeshToolProperties.bUseTargetEdgeLength = 0x80 // bool (Size: 0x1)
RemeshMeshToolProperties.TargetEdgeLength = 0x84 // float (Size: 0x4)
RemeshMeshToolProperties.bReproject = 0x88 // bool (Size: 0x1)
RemeshProperties.SmoothingStrength = 0x68 // float (Size: 0x4)
RemeshProperties.bFlips = 0x6c // bool (Size: 0x1)
RemeshProperties.bSplits = 0x6d // bool (Size: 0x1)
RemeshProperties.bCollapses = 0x6e // bool (Size: 0x1)
RemoveOccludedTrianglesOperatorFactory.Tool = 0x30 // RemoveOccludedTrianglesTool* (Size: 0x8)
RemoveOccludedTrianglesTool.BasicProperties = 0x90 // RemoveOccludedTrianglesToolProperties* (Size: 0x8)
RemoveOccludedTrianglesTool.AdvancedProperties = 0x98 // RemoveOccludedTrianglesAdvancedProperties* (Size: 0x8)
RemoveOccludedTrianglesTool.Previews = 0xa0 // TArray<MeshOpPreviewWithBackgroundCompute*> (Size: 0x10)
RemoveOccludedTrianglesTool.PreviewCopies = 0xb0 // TArray<PreviewMesh*> (Size: 0x10)
RemoveOccludedTrianglesToolProperties.OcclusionTestMethod = 0x60 // EEOcclusionCalculationUIMode (Size: 0x1)
RemoveOccludedTrianglesToolProperties.TriangleSampling = 0x61 // EEOcclusionTriangleSamplingUIMode (Size: 0x1)
RemoveOccludedTrianglesToolProperties.WindingIsoValue = 0x68 // double (Size: 0x8)
RemoveOccludedTrianglesToolProperties.AddRandomRays = 0x70 // int32_t (Size: 0x4)
RemoveOccludedTrianglesToolProperties.AddTriangleSamples = 0x74 // int32_t (Size: 0x4)
RemoveOccludedTrianglesToolProperties.bOnlySelfOcclude = 0x78 // bool (Size: 0x1)
RevolveBoundaryOperatorFactory.RevolveBoundaryTool = 0x30 // RevolveBoundaryTool* (Size: 0x8)
RevolveBoundaryTool.Settings = 0x160 // RevolveBoundaryToolProperties* (Size: 0x8)
RevolveBoundaryTool.MaterialProperties = 0x168 // NewMeshMaterialProperties* (Size: 0x8)
RevolveBoundaryTool.PlaneMechanic = 0x170 // ConstructionPlaneMechanic* (Size: 0x8)
RevolveBoundaryTool.Preview = 0x178 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
RevolveBoundaryToolProperties.bDisplayOriginalMesh = 0xb0 // bool (Size: 0x1)
RevolveBoundaryToolProperties.AxisOrigin = 0xb4 // FVector (Size: 0xc)
RevolveBoundaryToolProperties.AxisYaw = 0xc0 // float (Size: 0x4)
RevolveBoundaryToolProperties.AxisPitch = 0xc4 // float (Size: 0x4)
RevolveBoundaryToolProperties.bSnapToWorldGrid = 0xc8 // bool (Size: 0x1)
RevolveOperatorFactory.RevolveTool = 0x30 // DrawAndRevolveTool* (Size: 0x8)
RevolveProperties.RevolutionDegrees = 0x60 // double (Size: 0x8)
RevolveProperties.RevolutionDegreesOffset = 0x68 // double (Size: 0x8)
RevolveProperties.Steps = 0x70 // int32_t (Size: 0x4)
RevolveProperties.bReverseRevolutionDirection = 0x74 // bool (Size: 0x1)
RevolveProperties.bFlipMesh = 0x75 // bool (Size: 0x1)
RevolveProperties.bProfileIsCrossSectionOfSide = 0x76 // bool (Size: 0x1)
RevolveProperties.PolygroupMode = 0x77 // EERevolvePropertiesPolygroupMode (Size: 0x1)
RevolveProperties.QuadSplitMode = 0x78 // EERevolvePropertiesQuadSplit (Size: 0x1)
RevolveProperties.DiagonalProportionTolerance = 0x80 // double (Size: 0x8)
RevolveProperties.CapFillMode = 0x88 // EERevolvePropertiesCapFillMode (Size: 0x1)
RevolveProperties.bWeldFullRevolution = 0x89 // bool (Size: 0x1)
RevolveProperties.bWeldVertsOnAxis = 0x8a // bool (Size: 0x1)
RevolveProperties.AxisWeldTolerance = 0x90 // double (Size: 0x8)
RevolveProperties.bSharpNormals = 0x98 // bool (Size: 0x1)
RevolveProperties.SharpNormalAngleTolerance = 0xa0 // double (Size: 0x8)
RevolveProperties.bFlipVs = 0xa8 // bool (Size: 0x1)
RevolveProperties.bUVsSkipFullyWeldedEdges = 0xa9 // bool (Size: 0x1)
RevolveToolProperties.bConnectOpenProfileToAxis = 0xb0 // bool (Size: 0x1)
RevolveToolProperties.bSnapToWorldGrid = 0xb1 // bool (Size: 0x1)
RevolveToolProperties.DrawPlaneOrigin = 0xb4 // FVector (Size: 0xc)
RevolveToolProperties.DrawPlaneOrientation = 0xc0 // FRotator (Size: 0xc)
RevolveToolProperties.bEnableSnapping = 0xcc // bool (Size: 0x1)
RevolveToolProperties.bAllowedToEditDrawPlane = 0xcd // bool (Size: 0x1)
ScaleKelvinletBrushOpProps.Strength = 0x70 // float (Size: 0x4)
ScaleKelvinletBrushOpProps.Falloff = 0x74 // float (Size: 0x4)
SculptBrushProperties.Depth = 0x78 // float (Size: 0x4)
SculptBrushProperties.bHitBackFaces = 0x7c // bool (Size: 0x1)
SculptBrushProperties.Lazyness = 0x80 // float (Size: 0x4)
SculptBrushProperties.bShowPerBrushProps = 0x84 // bool (Size: 0x1)
SculptMaxBrushOpProps.Strength = 0x60 // float (Size: 0x4)
SculptMaxBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
SculptMaxBrushOpProps.MaxHeight = 0x68 // float (Size: 0x4)
SculptMaxBrushOpProps.bUseFixedHeight = 0x6c // bool (Size: 0x1)
SculptMaxBrushOpProps.FixedHeight = 0x70 // float (Size: 0x4)
SculptMaxBrushProperties.MaxHeight = 0x60 // float (Size: 0x4)
SculptMaxBrushProperties.bFreezeCurrentHeight = 0x64 // bool (Size: 0x1)
SeamSculptTool.Settings = 0x210 // SeamSculptToolProperties* (Size: 0x8)
SeamSculptTool.PreviewGeom = 0x218 // PreviewGeometry* (Size: 0x8)
SeamSculptToolProperties.bShowWireframe = 0x60 // bool (Size: 0x1)
SeamSculptToolProperties.bHitBackFaces = 0x61 // bool (Size: 0x1)
SecondarySmoothBrushOpProps.Strength = 0x60 // float (Size: 0x4)
SecondarySmoothBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
SecondarySmoothBrushOpProps.bPreserveUVFlow = 0x68 // bool (Size: 0x1)
SelfUnionMeshesTool.Properties = 0xf0 // SelfUnionMeshesToolProperties* (Size: 0x8)
SelfUnionMeshesTool.DrawnLineSet = 0xf8 // LineSetComponent* (Size: 0x8)
SelfUnionMeshesToolProperties.bAttemptFixHoles = 0x60 // bool (Size: 0x1)
SelfUnionMeshesToolProperties.bShowNewBoundaryEdges = 0x61 // bool (Size: 0x1)
SelfUnionMeshesToolProperties.bTrimFlaps = 0x62 // bool (Size: 0x1)
SelfUnionMeshesToolProperties.WindingNumberThreshold = 0x68 // double (Size: 0x8)
SelfUnionMeshesToolProperties.bOnlyUseFirstMeshMaterials = 0x70 // bool (Size: 0x1)
SetCollisionGeometryTool.Settings = 0x90 // SetCollisionGeometryToolProperties* (Size: 0x8)
SetCollisionGeometryTool.VizSettings = 0x98 // CollisionGeometryVisualizationProperties* (Size: 0x8)
SetCollisionGeometryTool.CollisionProps = 0xa0 // PhysicsObjectToolPropertySet* (Size: 0x8)
SetCollisionGeometryTool.LineMaterial = 0xa8 // MaterialInterface* (Size: 0x8)
SetCollisionGeometryTool.PreviewGeom = 0xb0 // PreviewGeometry* (Size: 0x8)
SetCollisionGeometryToolProperties.GeometryType = 0x60 // EECollisionGeometryType (Size: 0x4)
SetCollisionGeometryToolProperties.InputMode = 0x64 // EESetCollisionGeometryInputMode (Size: 0x4)
SetCollisionGeometryToolProperties.bUseWorldSpace = 0x68 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.bRemoveContained = 0x69 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.bEnableMaxCount = 0x6a // bool (Size: 0x1)
SetCollisionGeometryToolProperties.MaxCount = 0x6c // int32_t (Size: 0x4)
SetCollisionGeometryToolProperties.MinThickness = 0x70 // float (Size: 0x4)
SetCollisionGeometryToolProperties.bDetectBoxes = 0x74 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.bDetectSpheres = 0x75 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.bDetectCapsules = 0x76 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.bSimplifyHulls = 0x77 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.HullTargetFaceCount = 0x78 // int32_t (Size: 0x4)
SetCollisionGeometryToolProperties.bSimplifyPolygons = 0x7c // bool (Size: 0x1)
SetCollisionGeometryToolProperties.HullTolerance = 0x80 // float (Size: 0x4)
SetCollisionGeometryToolProperties.SweepAxis = 0x84 // EEProjectedHullAxis (Size: 0x4)
SetCollisionGeometryToolProperties.bAppendToExisting = 0x88 // bool (Size: 0x1)
SetCollisionGeometryToolProperties.SetCollisionType = 0x8c // EECollisionGeometryMode (Size: 0x4)
SharpPullKelvinletBrushOpProps.Falloff = 0x70 // float (Size: 0x4)
SharpPullKelvinletBrushOpProps.Depth = 0x74 // float (Size: 0x4)
SmoothBrushOpProps.Strength = 0x60 // float (Size: 0x4)
SmoothBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
SmoothBrushOpProps.bPreserveUVFlow = 0x68 // bool (Size: 0x1)
SmoothFillBrushOpProps.Strength = 0x60 // float (Size: 0x4)
SmoothFillBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
SmoothFillBrushOpProps.bPreserveUVFlow = 0x68 // bool (Size: 0x1)
SmoothHoleFillProperties.bConstrainToHoleInterior = 0x60 // bool (Size: 0x1)
SmoothHoleFillProperties.RemeshingExteriorRegionWidth = 0x64 // int32_t (Size: 0x4)
SmoothHoleFillProperties.SmoothingExteriorRegionWidth = 0x68 // int32_t (Size: 0x4)
SmoothHoleFillProperties.SmoothingInteriorRegionWidth = 0x6c // int32_t (Size: 0x4)
SmoothHoleFillProperties.InteriorSmoothness = 0x70 // float (Size: 0x4)
SmoothHoleFillProperties.FillDensityScalar = 0x78 // double (Size: 0x8)
SmoothHoleFillProperties.bProjectDuringRemesh = 0x80 // bool (Size: 0x1)
SmoothMeshTool.SmoothProperties = 0x400 // SmoothMeshToolProperties* (Size: 0x8)
SmoothMeshTool.IterativeProperties = 0x408 // IterativeSmoothProperties* (Size: 0x8)
SmoothMeshTool.DiffusionProperties = 0x410 // DiffusionSmoothProperties* (Size: 0x8)
SmoothMeshTool.ImplicitProperties = 0x418 // ImplicitSmoothProperties* (Size: 0x8)
SmoothMeshTool.WeightMapProperties = 0x420 // SmoothWeightMapSetProperties* (Size: 0x8)
SmoothMeshToolProperties.SmoothingType = 0x60 // EESmoothMeshToolSmoothType (Size: 0x1)
SmoothWeightMapSetProperties.MinSmoothMultiplier = 0x80 // float (Size: 0x4)
SpaceDeformerOperatorFactory.SpaceDeformerTool = 0x30 // MeshSpaceDeformerTool* (Size: 0x8)
StandardSculptBrushOpProps.Strength = 0x60 // float (Size: 0x4)
StandardSculptBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
TransformMeshesTarget.TransformProxy = 0x0 // TransformProxy* (Size: 0x8)
TransformMeshesTarget.TransformGizmo = 0x8 // TransformGizmo* (Size: 0x8)
TransformMeshesTool.TransformProps = 0x98 // TransformMeshesToolProperties* (Size: 0x8)
TransformMeshesTool.ActiveGizmos = 0xb0 // TArray<FTransformMeshesTarget> (Size: 0x10)
TransformMeshesToolProperties.TransformMode = 0x60 // EETransformMeshesTransformMode (Size: 0x1)
TransformMeshesToolProperties.bSetPivot = 0x61 // bool (Size: 0x1)
TransformMeshesToolProperties.bEnableSnapDragging = 0x62 // bool (Size: 0x1)
TransformMeshesToolProperties.SnapDragSource = 0x63 // EETransformMeshesSnapDragSource (Size: 0x1)
TransformMeshesToolProperties.RotationMode = 0x64 // EETransformMeshesSnapDragRotationMode (Size: 0x1)
TwistKelvinletBrushOpProps.Strength = 0x70 // float (Size: 0x4)
TwistKelvinletBrushOpProps.Falloff = 0x74 // float (Size: 0x4)
UVProjectionOperatorFactory.Tool = 0x30 // UVProjectionTool* (Size: 0x8)
UVProjectionTool.BasicProperties = 0x90 // UVProjectionToolProperties* (Size: 0x8)
UVProjectionTool.AdvancedProperties = 0x98 // UVProjectionAdvancedProperties* (Size: 0x8)
UVProjectionTool.MaterialSettings = 0xa0 // ExistingMeshMaterialProperties* (Size: 0x8)
UVProjectionTool.Previews = 0xa8 // TArray<MeshOpPreviewWithBackgroundCompute*> (Size: 0x10)
UVProjectionTool.CheckerMaterial = 0xb8 // MaterialInstanceDynamic* (Size: 0x8)
UVProjectionTool.TransformGizmos = 0xc0 // TArray<TransformGizmo*> (Size: 0x10)
UVProjectionTool.TransformProxies = 0xd0 // TArray<TransformProxy*> (Size: 0x10)
UVProjectionToolProperties.UVProjectionMethod = 0x60 // EEUVProjectionMethod (Size: 0x1)
UVProjectionToolProperties.ProjectionPrimitiveScale = 0x64 // FVector (Size: 0xc)
UVProjectionToolProperties.CylinderProjectToTopOrBottomAngleThreshold = 0x70 // float (Size: 0x4)
UVProjectionToolProperties.UVScale = 0x74 // FVector2D (Size: 0x8)
UVProjectionToolProperties.UVOffset = 0x7c // FVector2D (Size: 0x8)
UVProjectionToolProperties.bWorldSpaceUVScale = 0x84 // bool (Size: 0x1)
VertexBrushSculptProperties.PrimaryBrushType = 0x60 // EEMeshVertexSculptBrushType (Size: 0x1)
VertexBrushSculptProperties.PrimaryFalloffType = 0x61 // EEMeshSculptFalloffType (Size: 0x1)
VertexBrushSculptProperties.bFreezeTarget = 0x62 // bool (Size: 0x1)
VertexBrushSculptProperties.bSmoothErases = 0x63 // bool (Size: 0x1)
ViewAlignedPlaneBrushOpProps.Strength = 0x60 // float (Size: 0x4)
ViewAlignedPlaneBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
ViewAlignedPlaneBrushOpProps.Depth = 0x68 // float (Size: 0x4)
ViewAlignedPlaneBrushOpProps.WhichSide = 0x6c // EEPlaneBrushSideMode (Size: 0x1)
ViewAlignedSculptBrushOpProps.Strength = 0x60 // float (Size: 0x4)
ViewAlignedSculptBrushOpProps.Falloff = 0x64 // float (Size: 0x4)
VoxelBlendMeshesTool.BlendProperties = 0x108 // VoxelBlendMeshesToolProperties* (Size: 0x8)
VoxelBlendMeshesToolProperties.BlendPower = 0x60 // double (Size: 0x8)
VoxelBlendMeshesToolProperties.BlendFalloff = 0x68 // double (Size: 0x8)
VoxelBlendMeshesToolProperties.bSolidifyInput = 0x70 // bool (Size: 0x1)
VoxelBlendMeshesToolProperties.bRemoveInternalsAfterSolidify = 0x71 // bool (Size: 0x1)
VoxelBlendMeshesToolProperties.OffsetSolidifySurface = 0x78 // double (Size: 0x8)
VoxelMorphologyMeshesTool.MorphologyProperties = 0x108 // VoxelMorphologyMeshesToolProperties* (Size: 0x8)
VoxelMorphologyMeshesToolProperties.Operation = 0x60 // EEMorphologyOperation (Size: 0x1)
VoxelMorphologyMeshesToolProperties.Distance = 0x68 // double (Size: 0x8)
VoxelMorphologyMeshesToolProperties.bSolidifyInput = 0x70 // bool (Size: 0x1)
VoxelMorphologyMeshesToolProperties.bRemoveInternalsAfterSolidify = 0x71 // bool (Size: 0x1)
VoxelMorphologyMeshesToolProperties.OffsetSolidifySurface = 0x78 // double (Size: 0x8)
VoxelSolidifyMeshesTool.SolidifyProperties = 0x108 // VoxelSolidifyMeshesToolProperties* (Size: 0x8)
VoxelSolidifyMeshesToolProperties.WindingThreshold = 0x60 // double (Size: 0x8)
VoxelSolidifyMeshesToolProperties.ExtendBounds = 0x68 // double (Size: 0x8)
VoxelSolidifyMeshesToolProperties.SurfaceSearchSteps = 0x70 // int32_t (Size: 0x4)
VoxelSolidifyMeshesToolProperties.bSolidAtBoundaries = 0x74 // bool (Size: 0x1)
VoxelSolidifyMeshesToolProperties.bMakeOffsetSurfaces = 0x75 // bool (Size: 0x1)
VoxelSolidifyMeshesToolProperties.OffsetThickness = 0x78 // double (Size: 0x8)
WeldMeshEdgesTool.Tolerance = 0x88 // float (Size: 0x4)
WeldMeshEdgesTool.bOnlyUnique = 0x8c // bool (Size: 0x1)
WorkPlaneProperties.bPropertySetEnabled = 0x60 // bool (Size: 0x1)
WorkPlaneProperties.bShowGizmo = 0x61 // bool (Size: 0x1)
WorkPlaneProperties.bSnapToGrid = 0x62 // bool (Size: 0x1)
WorkPlaneProperties.position = 0x64 // FVector (Size: 0xc)
WorkPlaneProperties.Rotation = 0x70 // FQuat (Size: 0x10)
MessageRpcCancel.CallId = 0x0 // FGuid (Size: 0x10)
MessageRpcProgress.Completion = 0x0 // float (Size: 0x4)
MessageRpcProgress.CallId = 0x4 // FGuid (Size: 0x10)
MessageRpcProgress.StatusText = 0x18 // FString (Size: 0x10)
MessageRpcUnhandled.CallId = 0x0 // FGuid (Size: 0x10)
RpcMessage.CallId = 0x0 // FGuid (Size: 0x10)
BaseCreateFromSelectedHandleSourceProperties.WriteOutputTo = 0x68 // EEBaseCreateFromSelectedTargetType (Size: 0x4)
BaseCreateFromSelectedHandleSourceProperties.OutputName = 0x70 // FString (Size: 0x10)
BaseCreateFromSelectedHandleSourceProperties.OutputAsset = 0x80 // FString (Size: 0x10)
BaseCreateFromSelectedTool.TransformProperties = 0x98 // TransformInputsToolProperties* (Size: 0x8)
BaseCreateFromSelectedTool.HandleSourcesProperties = 0xa0 // BaseCreateFromSelectedHandleSourceProperties* (Size: 0x8)
BaseCreateFromSelectedTool.Preview = 0xa8 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
BaseCreateFromSelectedTool.TransformProxies = 0xb0 // TArray<TransformProxy*> (Size: 0x10)
BaseCreateFromSelectedTool.TransformGizmos = 0xc0 // TArray<TransformGizmo*> (Size: 0x10)
BaseCreateFromSelectedTool.TransformInitialScales = 0xd0 // TArray<FVector> (Size: 0x10)
BaseMeshProcessingTool.Preview = 0xb0 // MeshOpPreviewWithBackgroundCompute* (Size: 0x8)
BaseVoxelTool.VoxProperties = 0xf0 // VoxelProperties* (Size: 0x8)
ConstructionPlaneMechanic.PlaneTransformGizmo = 0xc8 // TransformGizmo* (Size: 0x8)
ConstructionPlaneMechanic.PlaneTransformProxy = 0xd0 // TransformProxy* (Size: 0x8)
ConstructionPlaneMechanic.ClickToSetPlaneBehavior = 0xe8 // SingleClickInputBehavior* (Size: 0x8)
CurveControlPointsMechanic.ClickBehavior = 0x40 // SingleClickInputBehavior* (Size: 0x8)
CurveControlPointsMechanic.HoverBehavior = 0x48 // MouseHoverBehavior* (Size: 0x8)
CurveControlPointsMechanic.PreviewGeometryActor = 0x4e8 // PreviewGeometryActor* (Size: 0x8)
CurveControlPointsMechanic.DrawnControlPoints = 0x4f0 // PointSetComponent* (Size: 0x8)
CurveControlPointsMechanic.DrawnControlSegments = 0x4f8 // LineSetComponent* (Size: 0x8)
CurveControlPointsMechanic.PreviewPoint = 0x500 // PointSetComponent* (Size: 0x8)
CurveControlPointsMechanic.PreviewSegment = 0x508 // LineSetComponent* (Size: 0x8)
CurveControlPointsMechanic.PointTransformProxy = 0x588 // TransformProxy* (Size: 0x8)
CurveControlPointsMechanic.PointTransformGizmo = 0x590 // TransformGizmo* (Size: 0x8)
LineSetComponent.LineMaterial = 0x600 // MaterialInterface* (Size: 0x8)
LineSetComponent.Bounds = 0x608 // FBoxSphereBounds (Size: 0x1c)
LineSetComponent.bBoundsDirty = 0x624 // bool (Size: 0x1)
MeshOpPreviewWithBackgroundCompute.PreviewMesh = 0x58 // PreviewMesh* (Size: 0x8)
MeshOpPreviewWithBackgroundCompute.StandardMaterials = 0x60 // TArray<MaterialInterface*> (Size: 0x10)
MeshOpPreviewWithBackgroundCompute.OverrideMaterial = 0x70 // MaterialInterface* (Size: 0x8)
MeshOpPreviewWithBackgroundCompute.WorkingMaterial = 0x78 // MaterialInterface* (Size: 0x8)
MultiTransformer.GizmoManager = 0x70 // InteractiveGizmoManager* (Size: 0x8)
MultiTransformer.TransformGizmo = 0xe0 // TransformGizmo* (Size: 0x8)
MultiTransformer.TransformProxy = 0xe8 // TransformProxy* (Size: 0x8)
OctreeDynamicMeshComponent.bExplicitShowWireframe = 0x660 // bool (Size: 0x1)
OnAcceptHandleSourcesProperties.OnToolAccept = 0x60 // EEHandleSourcesMethod (Size: 0x1)
PointSetComponent.PointMaterial = 0x600 // MaterialInterface* (Size: 0x8)
PointSetComponent.Bounds = 0x608 // FBoxSphereBounds (Size: 0x1c)
PointSetComponent.bBoundsDirty = 0x624 // bool (Size: 0x1)
PolygonSelectionMechanic.Properties = 0x50 // PolygonSelectionMechanicProperties* (Size: 0x8)
PolygonSelectionMechanic.PreviewGeometryActor = 0x360 // PreviewGeometryActor* (Size: 0x8)
PolygonSelectionMechanic.DrawnTriangleSetComponent = 0x368 // TriangleSetComponent* (Size: 0x8)
PolygonSelectionMechanic.HighlightedFaceMaterial = 0x3c0 // MaterialInterface* (Size: 0x8)
PolygonSelectionMechanicProperties.bSelectFaces = 0x60 // bool (Size: 0x1)
PolygonSelectionMechanicProperties.bSelectEdges = 0x61 // bool (Size: 0x1)
PolygonSelectionMechanicProperties.bSelectVertices = 0x62 // bool (Size: 0x1)
PolygonSelectionMechanicProperties.bPreferProjectedElement = 0x63 // bool (Size: 0x1)
PolygonSelectionMechanicProperties.bSelectDownRay = 0x64 // bool (Size: 0x1)
PolygonSelectionMechanicProperties.bIgnoreOcclusion = 0x65 // bool (Size: 0x1)
PreviewGeometry.ParentActor = 0x28 // PreviewGeometryActor* (Size: 0x8)
PreviewGeometry.LineSets = 0x30 // TMap<...> (Size: 0x50)
PreviewMesh.bBuildSpatialDataStructure = 0x40 // bool (Size: 0x1)
PreviewMesh.bDrawOnTop = 0x41 // bool (Size: 0x1)
PreviewMesh.DynamicMeshComponent = 0x50 // SimpleDynamicMeshComponent* (Size: 0x8)
RenderableTriangle.Material = 0x0 // MaterialInterface* (Size: 0x8)
RenderableTriangle.Vertex0 = 0x8 // FRenderableTriangleVertex (Size: 0x24)
RenderableTriangle.Vertex1 = 0x2c // FRenderableTriangleVertex (Size: 0x24)
RenderableTriangle.Vertex2 = 0x50 // FRenderableTriangleVertex (Size: 0x24)
RenderableTriangleVertex.position = 0x0 // FVector (Size: 0xc)
RenderableTriangleVertex.UV = 0xc // FVector2D (Size: 0x8)
RenderableTriangleVertex.Normal = 0x14 // FVector (Size: 0xc)
RenderableTriangleVertex.Color = 0x20 // FColor (Size: 0x4)
SimpleDynamicMeshComponent.TangentsType = 0x648 // EEDynamicMeshTangentCalcType (Size: 0x1)
SimpleDynamicMeshComponent.bInvalidateProxyOnChange = 0x649 // bool (Size: 0x1)
SimpleDynamicMeshComponent.bExplicitShowWireframe = 0x680 // bool (Size: 0x1)
SimpleDynamicMeshComponent.bDrawOnTop = 0x6d0 // bool (Size: 0x1)
SpaceCurveDeformationMechanic.ClickBehavior = 0x40 // SingleClickInputBehavior* (Size: 0x8)
SpaceCurveDeformationMechanic.HoverBehavior = 0x48 // MouseHoverBehavior* (Size: 0x8)
SpaceCurveDeformationMechanic.TransformProperties = 0x68 // SpaceCurveDeformationMechanicPropertySet* (Size: 0x8)
SpaceCurveDeformationMechanic.PreviewGeometryActor = 0x168 // PreviewGeometryActor* (Size: 0x8)
SpaceCurveDeformationMechanic.RenderPoints = 0x170 // PointSetComponent* (Size: 0x8)
SpaceCurveDeformationMechanic.RenderSegments = 0x178 // LineSetComponent* (Size: 0x8)
SpaceCurveDeformationMechanic.PointTransformProxy = 0x1b8 // TransformProxy* (Size: 0x8)
SpaceCurveDeformationMechanic.PointTransformGizmo = 0x1c0 // TransformGizmo* (Size: 0x8)
SpaceCurveDeformationMechanicPropertySet.TransformMode = 0x60 // EESpaceCurveControlPointTransformMode (Size: 0x4)
SpaceCurveDeformationMechanicPropertySet.TransformOrigin = 0x64 // EESpaceCurveControlPointOriginMode (Size: 0x4)
SpaceCurveDeformationMechanicPropertySet.Softness = 0x68 // float (Size: 0x4)
SpaceCurveDeformationMechanicPropertySet.SoftFalloff = 0x6c // EESpaceCurveControlPointFalloffType (Size: 0x4)
TransformInputsToolProperties.bShowTransformUI = 0x60 // bool (Size: 0x1)
TransformInputsToolProperties.bSnapToWorldGrid = 0x61 // bool (Size: 0x1)
TriangleSetComponent.Bounds = 0x600 // FBoxSphereBounds (Size: 0x1c)
TriangleSetComponent.bBoundsDirty = 0x61c // bool (Size: 0x1)
UVLayoutPreview.Settings = 0x28 // UVLayoutPreviewProperties* (Size: 0x8)
UVLayoutPreview.PreviewMesh = 0x30 // PreviewMesh* (Size: 0x8)
UVLayoutPreview.TriangleComponent = 0x38 // TriangleSetComponent* (Size: 0x8)
UVLayoutPreview.bShowBackingRectangle = 0x40 // bool (Size: 0x1)
UVLayoutPreview.BackingRectangleMaterial = 0x48 // MaterialInterface* (Size: 0x8)
UVLayoutPreviewProperties.bVisible = 0x60 // bool (Size: 0x1)
UVLayoutPreviewProperties.ScaleFactor = 0x64 // float (Size: 0x4)
UVLayoutPreviewProperties.WhichSide = 0x68 // EEUVLayoutPreviewSide (Size: 0x4)
UVLayoutPreviewProperties.bShowWireframe = 0x6c // bool (Size: 0x1)
UVLayoutPreviewProperties.Shift = 0x70 // FVector2D (Size: 0x8)
VoxelProperties.VoxelCount = 0x60 // int32_t (Size: 0x4)
VoxelProperties.bAutoSimplify = 0x64 // bool (Size: 0x1)
VoxelProperties.bRemoveInternalSurfaces = 0x65 // bool (Size: 0x1)
VoxelProperties.SimplifyMaxErrorFactor = 0x68 // double (Size: 0x8)
VoxelProperties.CubeRootMinComponentVolume = 0x70 // double (Size: 0x8)
WeightMapSetProperties.WeightMap = 0x60 // FName (Size: 0x8)
WeightMapSetProperties.WeightMapsList = 0x68 // TArray<FString> (Size: 0x10)
WeightMapSetProperties.bInvertWeightMap = 0x78 // bool (Size: 0x1)
AnimNotifyState_MotionWarping.RootMotionModifier = 0x30 // RootMotionModifier* (Size: 0x8)
AnimNotify_WarpingTarget.TargetName = 0x38 // FName (Size: 0x8)
MotionDeltaTrack.BoneTransformTrack = 0x0 // TArray<FTransform> (Size: 0x10)
MotionDeltaTrack.DeltaTranslationTrack = 0x10 // TArray<FVector> (Size: 0x10)
MotionDeltaTrack.DeltaRotationTrack = 0x20 // TArray<FRotator> (Size: 0x10)
MotionDeltaTrack.TotalTranslation = 0x30 // FVector (Size: 0xc)
MotionDeltaTrack.TotalRotation = 0x3c // FRotator (Size: 0xc)
MotionDeltaTrackContainer.Tracks = 0x0 // TArray<FMotionDeltaTrack> (Size: 0x10)
MotionWarpingComponent.bSearchForWindowsInAnimsWithinMontages = 0xf8 // bool (Size: 0x1)
MotionWarpingComponent.OnPreUpdate = 0x100 // FMulticastInlineDelegate (Size: 0x10)
MotionWarpingComponent.bPendingAutoResetVelocity = 0x110 // bool (Size: 0x1)
MotionWarpingComponent.CharacterOwner = 0x114 // TWeakObjectPtr<UObject> (Size: 0x8)
MotionWarpingComponent.Modifiers = 0x120 // TArray<RootMotionModifier*> (Size: 0x10)
MotionWarpingComponent.SyncPoints = 0x130 // TMap<...> (Size: 0x50)
MotionWarpingComponent.SyncTargetToTime = 0x180 // TMap<...> (Size: 0x50)
MotionWarpingComponent.CachedCharacterPhysicsModifier = 0x1e0 // RootMotionModifier_CharacterPhysics* (Size: 0x8)
MotionWarpingComponent.CachedCollisionResponse = 0x1e8 // TArray<uint8_t> (Size: 0x10)
MotionWarpingSyncPoint.Location = 0x0 // FVector (Size: 0xc)
MotionWarpingSyncPoint.Rotation = 0x10 // FQuat (Size: 0x10)
MotionWarpingWindowData.AnimNotify = 0x0 // AnimNotifyState_MotionWarping* (Size: 0x8)
MotionWarpingWindowData.StartTime = 0x8 // float (Size: 0x4)
MotionWarpingWindowData.EndTime = 0xc // float (Size: 0x4)
RootMotionModifier.Animation = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
RootMotionModifier.StartTime = 0x30 // float (Size: 0x4)
RootMotionModifier.EndTime = 0x34 // float (Size: 0x4)
RootMotionModifier.PreviousPosition = 0x38 // float (Size: 0x4)
RootMotionModifier.CurrentPosition = 0x3c // float (Size: 0x4)
RootMotionModifier.Weight = 0x40 // float (Size: 0x4)
RootMotionModifier.bInLocalSpace = 0x44 // bool (Size: 0x1)
RootMotionModifier.OnActivateDelegate = 0x48 // FDelegate (Size: 0x10)
RootMotionModifier.OnUpdateDelegate = 0x58 // FDelegate (Size: 0x10)
RootMotionModifier.OnDeactivateDelegate = 0x68 // FDelegate (Size: 0x10)
RootMotionModifier.State = 0x78 // EERootMotionModifierState (Size: 0x1)
RootMotionModifier_AdjustmentBlendWarp.bWarpIKBones = 0x160 // bool (Size: 0x1)
RootMotionModifier_AdjustmentBlendWarp.IKBones = 0x168 // TArray<FName> (Size: 0x10)
RootMotionModifier_AdjustmentBlendWarp.CachedMeshTransform = 0x180 // FTransform (Size: 0x30)
RootMotionModifier_AdjustmentBlendWarp.CachedMeshRelativeTransform = 0x1b0 // FTransform (Size: 0x30)
RootMotionModifier_AdjustmentBlendWarp.CachedRootMotion = 0x1e0 // FTransform (Size: 0x30)
RootMotionModifier_AdjustmentBlendWarp.Result = 0x210 // FAnimSequenceTrackContainer (Size: 0x20)
RootMotionModifier_AdjustmentBlendWarp.ActualStartTime = 0x230 // float (Size: 0x4)
RootMotionModifier_CharacterPhysics.bIgnoreCollision = 0x80 // bool (Size: 0x1)
RootMotionModifier_CharacterPhysics.bIgnoreGravity = 0x81 // bool (Size: 0x1)
RootMotionModifier_CharacterPhysics.bRevertWalkMovementMode = 0x82 // bool (Size: 0x1)
RootMotionModifier_CharacterPhysics.bRevertCharacterPhysicsEffect = 0x83 // bool (Size: 0x1)
RootMotionModifier_CharacterPhysics.MovementMode = 0x84 // uint8_t (Size: 0x1)
RootMotionModifier_CharacterPhysics.ProcessedCollisionChannels = 0x88 // TArray<uint8_t> (Size: 0x10)
RootMotionModifier_OnlyWarpControlRotation.LerpPitchAlpha = 0x80 // float (Size: 0x4)
RootMotionModifier_Scale.Scale = 0x80 // FVector (Size: 0xc)
RootMotionModifier_Warp.WarpTargetName = 0x80 // FName (Size: 0x8)
RootMotionModifier_Warp.WarpPointAnimProvider = 0x88 // EEWarpPointAnimProvider (Size: 0x1)
RootMotionModifier_Warp.WarpPointAnimTransform = 0x90 // FTransform (Size: 0x30)
RootMotionModifier_Warp.WarpPointAnimBoneName = 0xc0 // FName (Size: 0x8)
RootMotionModifier_Warp.bWarpTranslation = 0xc8 // bool (Size: 0x1)
RootMotionModifier_Warp.bIgnoreZAxis = 0xc9 // bool (Size: 0x1)
RootMotionModifier_Warp.bWarpRotation = 0xca // bool (Size: 0x1)
RootMotionModifier_Warp.RotationType = 0xcb // EEMotionWarpRotationType (Size: 0x1)
RootMotionModifier_Warp.bAdjustPlayRate = 0xcc // bool (Size: 0x1)
RootMotionModifier_Warp.MaxWarpScale = 0xd0 // float (Size: 0x4)
RootMotionModifier_Warp.WarpPlayRateAlpha = 0xd4 // float (Size: 0x4)
RootMotionModifier_Warp.CachedTargetTime = 0xd8 // float (Size: 0x4)
RootMotionModifier_Warp.bEnableInterruptByInput = 0xdc // bool (Size: 0x1)
RootMotionModifier_Warp.bWarpControlRotation = 0xdd // bool (Size: 0x1)
RootMotionModifier_Warp.bWarpControlRotationIgnorePitch = 0xde // bool (Size: 0x1)
RootMotionModifier_Warp.bAutoResetVelocity = 0xdf // bool (Size: 0x1)
RootMotionModifier_Warp.WarpRotationTimeMultiplier = 0xe0 // float (Size: 0x4)
RootMotionModifier_Warp.CachedTargetTransform = 0xf0 // FTransform (Size: 0x30)
GrainTableEntry.SampleIndex = 0x0 // int32_t (Size: 0x4)
GrainTableEntry.RPM = 0x4 // float (Size: 0x4)
MotoSynthPreset.Settings = 0x28 // FMotoSynthRuntimeSettings (Size: 0x68)
MotoSynthRuntimeSettings.bSynthToneEnabled = 0x0 // bool (Size: 0x1)
MotoSynthRuntimeSettings.SynthToneVolume = 0x4 // float (Size: 0x4)
MotoSynthRuntimeSettings.SynthToneFilterFrequency = 0x8 // float (Size: 0x4)
MotoSynthRuntimeSettings.SynthOctaveShift = 0xc // int32_t (Size: 0x4)
MotoSynthRuntimeSettings.bGranularEngineEnabled = 0x10 // bool (Size: 0x1)
MotoSynthRuntimeSettings.GranularEngineVolume = 0x14 // float (Size: 0x4)
MotoSynthRuntimeSettings.GranularEnginePitchScale = 0x18 // float (Size: 0x4)
MotoSynthRuntimeSettings.NumSamplesToCrossfadeBetweenGrains = 0x1c // int32_t (Size: 0x4)
MotoSynthRuntimeSettings.NumGrainTableEntriesPerGrain = 0x20 // int32_t (Size: 0x4)
MotoSynthRuntimeSettings.GrainTableRandomOffsetForConstantRPMs = 0x24 // int32_t (Size: 0x4)
MotoSynthRuntimeSettings.GrainCrossfadeSamplesForConstantRPMs = 0x28 // int32_t (Size: 0x4)
MotoSynthRuntimeSettings.AccelerationSource = 0x30 // MotoSynthSource* (Size: 0x8)
MotoSynthRuntimeSettings.DecelerationSource = 0x38 // MotoSynthSource* (Size: 0x8)
MotoSynthRuntimeSettings.bStereoWidenerEnabled = 0x40 // bool (Size: 0x1)
MotoSynthRuntimeSettings.StereoDelayMsec = 0x44 // float (Size: 0x4)
MotoSynthRuntimeSettings.StereoFeedback = 0x48 // float (Size: 0x4)
MotoSynthRuntimeSettings.StereoWidenerWetlevel = 0x4c // float (Size: 0x4)
MotoSynthRuntimeSettings.StereoWidenerDryLevel = 0x50 // float (Size: 0x4)
MotoSynthRuntimeSettings.StereoWidenerDelayRatio = 0x54 // float (Size: 0x4)
MotoSynthRuntimeSettings.bStereoWidenerFilterEnabled = 0x58 // bool (Size: 0x1)
MotoSynthRuntimeSettings.StereoWidenerFilterFrequency = 0x5c // float (Size: 0x4)
MotoSynthRuntimeSettings.StereoWidenerFilterQ = 0x60 // float (Size: 0x4)
MotoSynthSource.bConvertTo8Bit = 0x28 // bool (Size: 0x1)
MotoSynthSource.DownSampleFactor = 0x2c // float (Size: 0x4)
MotoSynthSource.RPMCurve = 0x30 // FRuntimeFloatCurve (Size: 0x88)
MotoSynthSource.SourceData = 0xb8 // TArray<float> (Size: 0x10)
MotoSynthSource.SourceDataPCM = 0xc8 // TArray<int16_t> (Size: 0x10)
MotoSynthSource.SourceSampleRate = 0xd8 // int32_t (Size: 0x4)
MotoSynthSource.GrainTable = 0xe0 // TArray<FGrainTableEntry> (Size: 0x10)
SynthComponentMoto.MotoSynthPreset = 0x700 // MotoSynthPreset* (Size: 0x8)
SynthComponentMoto.RPM = 0x708 // float (Size: 0x4)
MoviePlayerSettings.bWaitForMoviesToComplete = 0x28 // bool (Size: 0x1)
MoviePlayerSettings.bMoviesAreSkippable = 0x29 // bool (Size: 0x1)
MoviePlayerSettings.StartupMovies = 0x30 // TArray<FString> (Size: 0x10)
EasingComponentData.Section = 0x0 // MovieSceneSection* (Size: 0x8)
MovieScene.Spawnables = 0x50 // TArray<FMovieSceneSpawnable> (Size: 0x10)
MovieScene.Possessables = 0x60 // TArray<FMovieScenePossessable> (Size: 0x10)
MovieScene.ObjectBindings = 0x70 // TArray<FMovieSceneBinding> (Size: 0x10)
MovieScene.BindingGroups = 0x80 // TMap<...> (Size: 0x50)
MovieScene.MasterTracks = 0xd0 // TArray<MovieSceneTrack*> (Size: 0x10)
MovieScene.CameraCutTrack = 0xe0 // MovieSceneTrack* (Size: 0x8)
MovieScene.SelectionRange = 0xe8 // FMovieSceneFrameRange (Size: 0x10)
MovieScene.PlaybackRange = 0xf8 // FMovieSceneFrameRange (Size: 0x10)
MovieScene.TickResolution = 0x108 // FFrameRate (Size: 0x8)
MovieScene.DisplayRate = 0x110 // FFrameRate (Size: 0x8)
MovieScene.EvaluationType = 0x118 // EEMovieSceneEvaluationType (Size: 0x1)
MovieScene.ClockSource = 0x119 // EEUpdateClockSource (Size: 0x1)
MovieScene.CustomClockSourcePath = 0x120 // FSoftObjectPath (Size: 0x18)
MovieScene.MarkedFrames = 0x138 // TArray<FMovieSceneMarkedFrame> (Size: 0x10)
MovieSceneBinding.ObjectGuid = 0x0 // FGuid (Size: 0x10)
MovieSceneBinding.BindingName = 0x10 // FString (Size: 0x10)
MovieSceneBinding.Tracks = 0x20 // TArray<MovieSceneTrack*> (Size: 0x10)
MovieSceneBindingOverrideData.ObjectBindingID = 0x0 // FMovieSceneObjectBindingID (Size: 0x18)
MovieSceneBindingOverrideData.Object = 0x18 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneBindingOverrideData.bOverridesDefault = 0x20 // bool (Size: 0x1)
MovieSceneBindingOverrides.BindingData = 0x28 // TArray<FMovieSceneBindingOverrideData> (Size: 0x10)
MovieSceneBoolChannel.Times = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneBoolChannel.DefaultValue = 0x18 // bool (Size: 0x1)
MovieSceneBoolChannel.bHasDefaultValue = 0x19 // bool (Size: 0x1)
MovieSceneBoolChannel.Values = 0x20 // TArray<bool> (Size: 0x10)
MovieSceneBoolSection.DefaultValue = 0xe8 // bool (Size: 0x1)
MovieSceneBoolSection.BoolCurve = 0xf0 // FMovieSceneBoolChannel (Size: 0x90)
MovieSceneBuiltInEasingFunction.Type = 0x30 // EEMovieSceneBuiltInEasing (Size: 0x1)
MovieSceneByteChannel.Times = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneByteChannel.DefaultValue = 0x18 // uint8_t (Size: 0x1)
MovieSceneByteChannel.bHasDefaultValue = 0x19 // bool (Size: 0x1)
MovieSceneByteChannel.Values = 0x20 // TArray<uint8_t> (Size: 0x10)
MovieSceneByteChannel.Enum = 0x30 // Enum* (Size: 0x8)
MovieSceneCompiledData.EvaluationTemplate = 0x28 // FMovieSceneEvaluationTemplate (Size: 0x160)
MovieSceneCompiledData.Hierarchy = 0x188 // FMovieSceneSequenceHierarchy (Size: 0x118)
MovieSceneCompiledData.EntityComponentField = 0x2a0 // FMovieSceneEntityComponentField (Size: 0xf0)
MovieSceneCompiledData.TrackTemplateField = 0x390 // FMovieSceneEvaluationField (Size: 0x30)
MovieSceneCompiledData.DeterminismFences = 0x3c0 // TArray<FFrameTime> (Size: 0x10)
MovieSceneCompiledData.CompiledSignature = 0x3d0 // FGuid (Size: 0x10)
MovieSceneCompiledData.CompilerVersion = 0x3e0 // FGuid (Size: 0x10)
MovieSceneCompiledData.AccumulatedMask = 0x3f0 // FMovieSceneSequenceCompilerMaskStruct (Size: 0x1)
MovieSceneCompiledData.AllocatedMask = 0x3f1 // FMovieSceneSequenceCompilerMaskStruct (Size: 0x1)
MovieSceneCompiledData.AccumulatedFlags = 0x3f2 // EEMovieSceneSequenceFlags (Size: 0x1)
MovieSceneCompiledDataManager.Hierarchies = 0xd8 // TMap<...> (Size: 0x50)
MovieSceneCompiledDataManager.TrackTemplates = 0x128 // TMap<...> (Size: 0x50)
MovieSceneCompiledDataManager.TrackTemplateFields = 0x178 // TMap<...> (Size: 0x50)
MovieSceneCompiledDataManager.EntityComponentFields = 0x1c8 // TMap<...> (Size: 0x50)
MovieSceneEasingExternalCurve.Curve = 0x30 // CurveFloat* (Size: 0x8)
MovieSceneEasingSettings.AutoEaseInDuration = 0x0 // int32_t (Size: 0x4)
MovieSceneEasingSettings.AutoEaseOutDuration = 0x4 // int32_t (Size: 0x4)
MovieSceneEasingSettings.EaseIn = 0x8 // TScriptInterface<IInterface> (Size: 0x10)
MovieSceneEasingSettings.bManualEaseIn = 0x18 // bool (Size: 0x1)
MovieSceneEasingSettings.ManualEaseInDuration = 0x1c // int32_t (Size: 0x4)
MovieSceneEasingSettings.EaseOut = 0x20 // TScriptInterface<IInterface> (Size: 0x10)
MovieSceneEasingSettings.bManualEaseOut = 0x30 // bool (Size: 0x1)
MovieSceneEasingSettings.ManualEaseOutDuration = 0x34 // int32_t (Size: 0x4)
MovieSceneEditorData.ExpansionStates = 0x0 // TMap<...> (Size: 0x50)
MovieSceneEditorData.PinnedNodes = 0x50 // TArray<FString> (Size: 0x10)
MovieSceneEditorData.ViewStart = 0x60 // double (Size: 0x8)
MovieSceneEditorData.ViewEnd = 0x68 // double (Size: 0x8)
MovieSceneEditorData.WorkStart = 0x70 // double (Size: 0x8)
MovieSceneEditorData.WorkEnd = 0x78 // double (Size: 0x8)
MovieSceneEditorData.MarkedFrames = 0x80 // TSet<...> (Size: 0x50)
MovieSceneEditorData.WorkingRange = 0xd0 // FFloatRange (Size: 0x10)
MovieSceneEditorData.ViewRange = 0xe0 // FFloatRange (Size: 0x10)
MovieSceneEntityComponentField.PersistentEntityTree = 0x0 // FMovieSceneEvaluationFieldEntityTree (Size: 0x60)
MovieSceneEntityComponentField.OneShotEntityTree = 0x60 // FMovieSceneEvaluationFieldEntityTree (Size: 0x60)
MovieSceneEntityComponentField.Entities = 0xc0 // TArray<FMovieSceneEvaluationFieldEntity> (Size: 0x10)
MovieSceneEntityComponentField.EntityMetaData = 0xd0 // TArray<FMovieSceneEvaluationFieldEntityMetaData> (Size: 0x10)
MovieSceneEntityComponentField.SharedMetaData = 0xe0 // TArray<FMovieSceneEvaluationFieldSharedEntityMetaData> (Size: 0x10)
MovieSceneEntitySystem.Linker = 0x28 // MovieSceneEntitySystemLinker* (Size: 0x8)
MovieSceneEntitySystemGraph.Nodes = 0x80 // FMovieSceneEntitySystemGraphNodes (Size: 0x38)
MovieSceneEntitySystemGraphNode.System = 0x20 // MovieSceneEntitySystem* (Size: 0x8)
MovieSceneEntitySystemLinker.SystemGraph = 0x238 // FMovieSceneEntitySystemGraph (Size: 0x138)
MovieSceneEvalTemplate.CompletionMode = 0x10 // EEMovieSceneCompletionMode (Size: 0x1)
MovieSceneEvalTemplate.SourceSectionPtr = 0x14 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneEvaluationField.Ranges = 0x0 // TArray<FMovieSceneFrameRange> (Size: 0x10)
MovieSceneEvaluationField.Groups = 0x10 // TArray<FMovieSceneEvaluationGroup> (Size: 0x10)
MovieSceneEvaluationField.MetaData = 0x20 // TArray<FMovieSceneEvaluationMetaData> (Size: 0x10)
MovieSceneEvaluationFieldEntity.Key = 0x0 // FMovieSceneEvaluationFieldEntityKey (Size: 0xc)
MovieSceneEvaluationFieldEntity.SharedMetaDataIndex = 0xc // int32_t (Size: 0x4)
MovieSceneEvaluationFieldEntityKey.EntityOwner = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneEvaluationFieldEntityKey.EntityID = 0x8 // uint32_t (Size: 0x4)
MovieSceneEvaluationFieldEntityMetaData.ForcedTime = 0x0 // FFrameNumber (Size: 0x4)
MovieSceneEvaluationFieldEntityMetaData.Flags = 0x8 // EESectionEvaluationFlags (Size: 0x1)
MovieSceneEvaluationFieldEntityMetaData.bEvaluateInSequencePreRoll = 0x9 // uint8_t (Size: 0x1)
MovieSceneEvaluationFieldEntityMetaData.bEvaluateInSequencePostRoll = 0x9 // uint8_t (Size: 0x1)
MovieSceneEvaluationFieldSegmentPtr.SegmentID = 0x8 // FMovieSceneSegmentIdentifier (Size: 0x4)
MovieSceneEvaluationFieldSharedEntityMetaData.ObjectBindingID = 0x0 // FGuid (Size: 0x10)
MovieSceneEvaluationFieldTrackPtr.SequenceID = 0x0 // FMovieSceneSequenceID (Size: 0x4)
MovieSceneEvaluationFieldTrackPtr.TrackIdentifier = 0x4 // FMovieSceneTrackIdentifier (Size: 0x4)
MovieSceneEvaluationGroup.LUTIndices = 0x0 // TArray<FMovieSceneEvaluationGroupLUTIndex> (Size: 0x10)
MovieSceneEvaluationGroup.TrackLUT = 0x10 // TArray<FMovieSceneFieldEntry_EvaluationTrack> (Size: 0x10)
MovieSceneEvaluationGroup.SectionLUT = 0x20 // TArray<FMovieSceneFieldEntry_ChildTemplate> (Size: 0x10)
MovieSceneEvaluationGroupLUTIndex.NumInitPtrs = 0x0 // int32_t (Size: 0x4)
MovieSceneEvaluationGroupLUTIndex.NumEvalPtrs = 0x4 // int32_t (Size: 0x4)
MovieSceneEvaluationKey.SequenceID = 0x0 // FMovieSceneSequenceID (Size: 0x4)
MovieSceneEvaluationKey.TrackIdentifier = 0x4 // FMovieSceneTrackIdentifier (Size: 0x4)
MovieSceneEvaluationKey.SectionIndex = 0x8 // uint32_t (Size: 0x4)
MovieSceneEvaluationMetaData.ActiveSequences = 0x0 // TArray<FMovieSceneSequenceID> (Size: 0x10)
MovieSceneEvaluationMetaData.ActiveEntities = 0x10 // TArray<FMovieSceneOrderedEvaluationKey> (Size: 0x10)
MovieSceneEvaluationOperand.ObjectBindingID = 0x0 // FGuid (Size: 0x10)
MovieSceneEvaluationOperand.SequenceID = 0x10 // FMovieSceneSequenceID (Size: 0x4)
MovieSceneEvaluationTemplate.Tracks = 0x0 // TMap<...> (Size: 0x50)
MovieSceneEvaluationTemplate.SequenceSignature = 0xa0 // FGuid (Size: 0x10)
MovieSceneEvaluationTemplate.TemplateSerialNumber = 0xb0 // FMovieSceneEvaluationTemplateSerialNumber (Size: 0x4)
MovieSceneEvaluationTemplate.TemplateLedger = 0xb8 // FMovieSceneTemplateGenerationLedger (Size: 0xa8)
MovieSceneEvaluationTemplateSerialNumber.Value = 0x0 // uint32_t (Size: 0x4)
MovieSceneEvaluationTrack.ObjectBindingID = 0x0 // FGuid (Size: 0x10)
MovieSceneEvaluationTrack.EvaluationPriority = 0x10 // uint16_t (Size: 0x2)
MovieSceneEvaluationTrack.EvaluationMethod = 0x12 // EEEvaluationMethod (Size: 0x1)
MovieSceneEvaluationTrack.SourceTrack = 0x14 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneEvaluationTrack.ChildTemplates = 0x20 // TArray<FMovieSceneEvalTemplatePtr> (Size: 0x10)
MovieSceneEvaluationTrack.TrackTemplate = 0x30 // FMovieSceneTrackImplementationPtr (Size: 0x38)
MovieSceneEvaluationTrack.EvaluationGroup = 0x68 // FName (Size: 0x8)
MovieSceneEvaluationTrack.bEvaluateInPreroll = 0x70 // uint8_t (Size: 0x1)
MovieSceneEvaluationTrack.bEvaluateInPostroll = 0x70 // uint8_t (Size: 0x1)
MovieSceneEvaluationTrack.bTearDownPriority = 0x70 // uint8_t (Size: 0x1)
MovieSceneExpansionState.bExpanded = 0x0 // bool (Size: 0x1)
MovieSceneFieldEntry_ChildTemplate.ChildIndex = 0x0 // uint16_t (Size: 0x2)
MovieSceneFieldEntry_ChildTemplate.Flags = 0x2 // EESectionEvaluationFlags (Size: 0x1)
MovieSceneFieldEntry_ChildTemplate.ForcedTime = 0x4 // FFrameNumber (Size: 0x4)
MovieSceneFieldEntry_EvaluationTrack.TrackPtr = 0x0 // FMovieSceneEvaluationFieldTrackPtr (Size: 0x8)
MovieSceneFieldEntry_EvaluationTrack.NumChildren = 0x8 // uint16_t (Size: 0x2)
MovieSceneFloatChannel.PreInfinityExtrap = 0x8 // uint8_t (Size: 0x1)
MovieSceneFloatChannel.PostInfinityExtrap = 0x9 // uint8_t (Size: 0x1)
MovieSceneFloatChannel.Times = 0x10 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneFloatChannel.Values = 0x20 // TArray<FMovieSceneFloatValue> (Size: 0x10)
MovieSceneFloatChannel.DefaultValue = 0x30 // float (Size: 0x4)
MovieSceneFloatChannel.bHasDefaultValue = 0x34 // bool (Size: 0x1)
MovieSceneFloatChannel.KeyHandles = 0x38 // FMovieSceneKeyHandleMap (Size: 0x60)
MovieSceneFloatChannel.TickResolution = 0x98 // FFrameRate (Size: 0x8)
MovieSceneFloatValue.Value = 0x0 // float (Size: 0x4)
MovieSceneFloatValue.Tangent = 0x4 // FMovieSceneTangentData (Size: 0x14)
MovieSceneFloatValue.InterpMode = 0x18 // uint8_t (Size: 0x1)
MovieSceneFloatValue.TangentMode = 0x19 // uint8_t (Size: 0x1)
MovieSceneFloatValue.PaddingByte = 0x1a // uint8_t (Size: 0x1)
MovieSceneFolder.FolderName = 0x28 // FName (Size: 0x8)
MovieSceneFolder.ChildFolders = 0x30 // TArray<MovieSceneFolder*> (Size: 0x10)
MovieSceneFolder.ChildMasterTracks = 0x40 // TArray<MovieSceneTrack*> (Size: 0x10)
MovieSceneFolder.ChildObjectBindingStrings = 0x50 // TArray<FString> (Size: 0x10)
MovieSceneIntegerChannel.Times = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneIntegerChannel.DefaultValue = 0x18 // int32_t (Size: 0x4)
MovieSceneIntegerChannel.bHasDefaultValue = 0x1c // bool (Size: 0x1)
MovieSceneIntegerChannel.Values = 0x20 // TArray<int32_t> (Size: 0x10)
MovieSceneKeyTimeStruct.Time = 0x8 // FFrameNumber (Size: 0x4)
MovieSceneMarkedFrame.FrameNumber = 0x0 // FFrameNumber (Size: 0x4)
MovieSceneMarkedFrame.label = 0x8 // FString (Size: 0x10)
MovieSceneNestedSequenceTransform.LinearTransform = 0x0 // FMovieSceneTimeTransform (Size: 0xc)
MovieSceneNestedSequenceTransform.Warping = 0xc // FMovieSceneTimeWarping (Size: 0x8)
MovieSceneObjectBindingID.SequenceID = 0x0 // int32_t (Size: 0x4)
MovieSceneObjectBindingID.Space = 0x4 // EEMovieSceneObjectBindingSpace (Size: 0x1)
MovieSceneObjectBindingID.Guid = 0x8 // FGuid (Size: 0x10)
MovieSceneObjectBindingIDs.IDs = 0x0 // TArray<FMovieSceneObjectBindingID> (Size: 0x10)
MovieSceneObjectPathChannel.PropertyClass = 0x8 // ClassProperty (Size: 0x8)
MovieSceneObjectPathChannel.Times = 0x10 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneObjectPathChannel.Values = 0x20 // TArray<FMovieSceneObjectPathChannelKeyValue> (Size: 0x10)
MovieSceneObjectPathChannel.DefaultValue = 0x30 // FMovieSceneObjectPathChannelKeyValue (Size: 0x30)
MovieSceneObjectPathChannelKeyValue.SoftPtr = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
MovieSceneObjectPathChannelKeyValue.HardPtr = 0x28 // Object* (Size: 0x8)
MovieSceneOrderedEvaluationKey.Key = 0x0 // FMovieSceneEvaluationKey (Size: 0xc)
MovieSceneOrderedEvaluationKey.SetupIndex = 0xc // uint16_t (Size: 0x2)
MovieSceneOrderedEvaluationKey.TearDownIndex = 0xe // uint16_t (Size: 0x2)
MovieScenePossessable.Tags = 0x0 // TArray<FName> (Size: 0x10)
MovieScenePossessable.Guid = 0x10 // FGuid (Size: 0x10)
MovieScenePossessable.Name = 0x20 // FString (Size: 0x10)
MovieScenePossessable.PossessedObjectClass = 0x30 // ClassProperty (Size: 0x8)
MovieScenePossessable.ParentGuid = 0x38 // FGuid (Size: 0x10)
MovieScenePropertyBinding.PropertyName = 0x0 // FName (Size: 0x8)
MovieScenePropertyBinding.PropertyPath = 0x8 // FName (Size: 0x8)
MovieScenePropertyBinding.bCanUseClassLookup = 0x10 // bool (Size: 0x1)
MovieScenePropertySectionData.PropertyName = 0x0 // FName (Size: 0x8)
MovieScenePropertySectionData.PropertyPath = 0x8 // FString (Size: 0x10)
MovieScenePropertySectionTemplate.PropertyData = 0x20 // FMovieScenePropertySectionData (Size: 0x18)
MovieSceneRootEvaluationTemplateInstance.WeakRootSequence = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneRootEvaluationTemplateInstance.CompiledDataManager = 0x8 // MovieSceneCompiledDataManager* (Size: 0x8)
MovieSceneRootEvaluationTemplateInstance.EntitySystemLinker = 0x18 // MovieSceneEntitySystemLinker* (Size: 0x8)
MovieSceneRootEvaluationTemplateInstance.DirectorInstances = 0x90 // TMap<...> (Size: 0x50)
MovieSceneSection.EvalOptions = 0x50 // FMovieSceneSectionEvalOptions (Size: 0x2)
MovieSceneSection.Easing = 0x58 // FMovieSceneEasingSettings (Size: 0x38)
MovieSceneSection.SectionRange = 0x90 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSection.PreRollFrames = 0xa0 // FFrameNumber (Size: 0x4)
MovieSceneSection.PostRollFrames = 0xa4 // FFrameNumber (Size: 0x4)
MovieSceneSection.RowIndex = 0xa8 // int32_t (Size: 0x4)
MovieSceneSection.OverlapPriority = 0xac // int32_t (Size: 0x4)
MovieSceneSection.bIsActive = 0xb0 // uint8_t (Size: 0x1)
MovieSceneSection.bIsLocked = 0xb0 // uint8_t (Size: 0x1)
MovieSceneSection.StartTime = 0xb4 // float (Size: 0x4)
MovieSceneSection.EndTime = 0xb8 // float (Size: 0x4)
MovieSceneSection.PrerollTime = 0xbc // float (Size: 0x4)
MovieSceneSection.PostrollTime = 0xc0 // float (Size: 0x4)
MovieSceneSection.bIsInfinite = 0xc4 // uint8_t (Size: 0x1)
MovieSceneSection.bSupportsInfiniteRange = 0xc8 // bool (Size: 0x1)
MovieSceneSection.BlendType = 0xc9 // FOptionalMovieSceneBlendType (Size: 0x2)
MovieSceneSectionEvalOptions.bCanEditCompletionMode = 0x0 // bool (Size: 0x1)
MovieSceneSectionEvalOptions.CompletionMode = 0x1 // EEMovieSceneCompletionMode (Size: 0x1)
MovieSceneSectionGroup.Sections = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MovieSceneSectionParameters.StartFrameOffset = 0x0 // FFrameNumber (Size: 0x4)
MovieSceneSectionParameters.bCanLoop = 0x4 // bool (Size: 0x1)
MovieSceneSectionParameters.EndFrameOffset = 0x8 // FFrameNumber (Size: 0x4)
MovieSceneSectionParameters.FirstLoopStartFrameOffset = 0xc // FFrameNumber (Size: 0x4)
MovieSceneSectionParameters.TimeScale = 0x10 // float (Size: 0x4)
MovieSceneSectionParameters.HierarchicalBias = 0x14 // int32_t (Size: 0x4)
MovieSceneSectionParameters.StartOffset = 0x18 // float (Size: 0x4)
MovieSceneSectionParameters.PrerollTime = 0x1c // float (Size: 0x4)
MovieSceneSectionParameters.PostrollTime = 0x20 // float (Size: 0x4)
MovieSceneSegmentIdentifier.IdentifierIndex = 0x0 // int32_t (Size: 0x4)
MovieSceneSequence.CompiledData = 0x50 // MovieSceneCompiledData* (Size: 0x8)
MovieSceneSequence.DefaultCompletionMode = 0x58 // EEMovieSceneCompletionMode (Size: 0x1)
MovieSceneSequence.bParentContextsAreSignificant = 0x59 // bool (Size: 0x1)
MovieSceneSequence.bPlayableDirectly = 0x5a // bool (Size: 0x1)
MovieSceneSequence.SequenceFlags = 0x5b // EEMovieSceneSequenceFlags (Size: 0x1)
MovieSceneSequenceCompilerMaskStruct.bHierarchy = 0x0 // uint8_t (Size: 0x1)
MovieSceneSequenceCompilerMaskStruct.bEvaluationTemplate = 0x0 // uint8_t (Size: 0x1)
MovieSceneSequenceCompilerMaskStruct.bEvaluationTemplateField = 0x0 // uint8_t (Size: 0x1)
MovieSceneSequenceCompilerMaskStruct.bEntityComponentField = 0x0 // uint8_t (Size: 0x1)
MovieSceneSequenceHierarchy.RootNode = 0x0 // FMovieSceneSequenceHierarchyNode (Size: 0x18)
MovieSceneSequenceHierarchy.Tree = 0x18 // FMovieSceneSubSequenceTree (Size: 0x60)
MovieSceneSequenceHierarchy.SubSequences = 0x78 // TMap<...> (Size: 0x50)
MovieSceneSequenceHierarchy.Hierarchy = 0xc8 // TMap<...> (Size: 0x50)
MovieSceneSequenceHierarchyNode.ParentID = 0x0 // FMovieSceneSequenceID (Size: 0x4)
MovieSceneSequenceHierarchyNode.Children = 0x8 // TArray<FMovieSceneSequenceID> (Size: 0x10)
MovieSceneSequenceID.Value = 0x0 // uint32_t (Size: 0x4)
MovieSceneSequenceLoopCount.Value = 0x0 // int32_t (Size: 0x4)
MovieSceneSequencePlaybackParams.Frame = 0x0 // FFrameTime (Size: 0x8)
MovieSceneSequencePlaybackParams.Time = 0x8 // float (Size: 0x4)
MovieSceneSequencePlaybackParams.MarkedFrame = 0x10 // FString (Size: 0x10)
MovieSceneSequencePlaybackParams.PositionType = 0x20 // EEMovieScenePositionType (Size: 0x1)
MovieSceneSequencePlaybackParams.UpdateMethod = 0x21 // EEUpdatePositionMethod (Size: 0x1)
MovieSceneSequencePlaybackSettings.bAutoPlay = 0x0 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.LoopCount = 0x4 // FMovieSceneSequenceLoopCount (Size: 0x4)
MovieSceneSequencePlaybackSettings.PlayRate = 0x8 // float (Size: 0x4)
MovieSceneSequencePlaybackSettings.StartTime = 0xc // float (Size: 0x4)
MovieSceneSequencePlaybackSettings.bRandomStartTime = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bRestoreState = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bDisableMovementInput = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bDisableLookAtInput = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bHidePlayer = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bHideHud = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bDisableCameraCuts = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlaybackSettings.bPauseAtEnd = 0x10 // uint8_t (Size: 0x1)
MovieSceneSequencePlayer.OnPlay = 0x410 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.OnPlayReverse = 0x420 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.OnStop = 0x430 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.OnPause = 0x440 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.OnFinished = 0x450 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.OnUpdate = 0x460 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneSequencePlayer.status = 0x470 // uint8_t (Size: 0x1)
MovieSceneSequencePlayer.bReversePlayback = 0x474 // uint8_t (Size: 0x1)
MovieSceneSequencePlayer.Sequence = 0x478 // MovieSceneSequence* (Size: 0x8)
MovieSceneSequencePlayer.StartTime = 0x480 // FFrameNumber (Size: 0x4)
MovieSceneSequencePlayer.DurationFrames = 0x484 // int32_t (Size: 0x4)
MovieSceneSequencePlayer.DurationSubFrames = 0x488 // float (Size: 0x4)
MovieSceneSequencePlayer.CurrentNumLoops = 0x48c // int32_t (Size: 0x4)
MovieSceneSequencePlayer.PlaybackSettings = 0x490 // FMovieSceneSequencePlaybackSettings (Size: 0x14)
MovieSceneSequencePlayer.RootTemplateInstance = 0x4a8 // FMovieSceneRootEvaluationTemplateInstance (Size: 0xe8)
MovieSceneSequencePlayer.NetSyncProps = 0x5f8 // FMovieSceneSequenceReplProperties (Size: 0x10)
MovieSceneSequencePlayer.PlaybackClient = 0x608 // TScriptInterface<IInterface> (Size: 0x10)
MovieSceneSequencePlayer.TickManager = 0x618 // MovieSceneSequenceTickManager* (Size: 0x8)
MovieSceneSequenceReplProperties.LastKnownPosition = 0x0 // FFrameTime (Size: 0x8)
MovieSceneSequenceReplProperties.LastKnownStatus = 0x8 // uint8_t (Size: 0x1)
MovieSceneSequenceReplProperties.LastKnownNumLoops = 0xc // int32_t (Size: 0x4)
MovieSceneSequenceTickManager.SequenceActors = 0x28 // TArray<Actor*> (Size: 0x10)
MovieSceneSequenceTickManager.Linker = 0x38 // MovieSceneEntitySystemLinker* (Size: 0x8)
MovieSceneSequenceTransform.LinearTransform = 0x0 // FMovieSceneTimeTransform (Size: 0xc)
MovieSceneSequenceTransform.NestedTransforms = 0x10 // TArray<FMovieSceneNestedSequenceTransform> (Size: 0x10)
MovieSceneSignedObject.Signature = 0x28 // FGuid (Size: 0x10)
MovieSceneSpawnTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneSpawnTrack.ObjectGuid = 0x88 // FGuid (Size: 0x10)
MovieSceneSpawnable.SpawnTransform = 0x0 // FTransform (Size: 0x30)
MovieSceneSpawnable.Tags = 0x30 // TArray<FName> (Size: 0x10)
MovieSceneSpawnable.bContinuouslyRespawn = 0x40 // bool (Size: 0x1)
MovieSceneSpawnable.bEvaluateTracksWhenNotSpawned = 0x41 // bool (Size: 0x1)
MovieSceneSpawnable.Guid = 0x44 // FGuid (Size: 0x10)
MovieSceneSpawnable.Name = 0x58 // FString (Size: 0x10)
MovieSceneSpawnable.ObjectTemplate = 0x68 // Object* (Size: 0x8)
MovieSceneSpawnable.ChildPossessables = 0x70 // TArray<FGuid> (Size: 0x10)
MovieSceneSpawnable.Ownership = 0x80 // EESpawnOwnership (Size: 0x1)
MovieSceneSpawnable.LevelName = 0x84 // FName (Size: 0x8)
MovieSceneSubSection.Parameters = 0xe8 // FMovieSceneSectionParameters (Size: 0x24)
MovieSceneSubSection.StartOffset = 0x10c // float (Size: 0x4)
MovieSceneSubSection.TimeScale = 0x110 // float (Size: 0x4)
MovieSceneSubSection.PrerollTime = 0x114 // float (Size: 0x4)
MovieSceneSubSection.SubSequence = 0x118 // MovieSceneSequence* (Size: 0x8)
MovieSceneSubSection.ActorToRecord = 0x120 // TLazyObjectPtr<UObject> (Size: 0x1c)
MovieSceneSubSection.TargetSequenceName = 0x140 // FString (Size: 0x10)
MovieSceneSubSection.TargetPathToRecordTo = 0x150 // FDirectoryPath (Size: 0x10)
MovieSceneSubSectionData.Section = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
MovieSceneSubSectionData.ObjectBindingID = 0x8 // FGuid (Size: 0x10)
MovieSceneSubSectionData.Flags = 0x18 // EESectionEvaluationFlags (Size: 0x1)
MovieSceneSubSequenceData.Sequence = 0x0 // FSoftObjectPath (Size: 0x18)
MovieSceneSubSequenceData.RootToSequenceTransform = 0x18 // FMovieSceneSequenceTransform (Size: 0x20)
MovieSceneSubSequenceData.TickResolution = 0x38 // FFrameRate (Size: 0x8)
MovieSceneSubSequenceData.DeterministicSequenceID = 0x40 // FMovieSceneSequenceID (Size: 0x4)
MovieSceneSubSequenceData.PlayRange = 0x44 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSubSequenceData.FullPlayRange = 0x54 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSubSequenceData.UnwarpedPlayRange = 0x64 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSubSequenceData.PreRollRange = 0x74 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSubSequenceData.PostRollRange = 0x84 // FMovieSceneFrameRange (Size: 0x10)
MovieSceneSubSequenceData.HierarchicalBias = 0x94 // int16_t (Size: 0x2)
MovieSceneSubSequenceData.bHasHierarchicalEasing = 0x96 // bool (Size: 0x1)
MovieSceneSubSequenceData.InstanceData = 0x98 // FMovieSceneSequenceInstanceDataPtr (Size: 0x18)
MovieSceneSubSequenceData.SubSectionSignature = 0xb8 // FGuid (Size: 0x10)
MovieSceneSubSequenceData.OuterToInnerTransform = 0xc8 // FMovieSceneSequenceTransform (Size: 0x20)
MovieSceneSubTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneTangentData.ArriveTangent = 0x0 // float (Size: 0x4)
MovieSceneTangentData.LeaveTangent = 0x4 // float (Size: 0x4)
MovieSceneTangentData.ArriveTangentWeight = 0x8 // float (Size: 0x4)
MovieSceneTangentData.LeaveTangentWeight = 0xc // float (Size: 0x4)
MovieSceneTangentData.TangentWeightMode = 0x10 // uint8_t (Size: 0x1)
MovieSceneTemplateGenerationLedger.LastTrackIdentifier = 0x0 // FMovieSceneTrackIdentifier (Size: 0x4)
MovieSceneTemplateGenerationLedger.TrackSignatureToTrackIdentifier = 0x8 // TMap<...> (Size: 0x50)
MovieSceneTemplateGenerationLedger.SubSectionRanges = 0x58 // TMap<...> (Size: 0x50)
MovieSceneTimeTransform.TimeScale = 0x0 // float (Size: 0x4)
MovieSceneTimeTransform.Offset = 0x4 // FFrameTime (Size: 0x8)
MovieSceneTimeWarping.Start = 0x0 // FFrameNumber (Size: 0x4)
MovieSceneTimeWarping.End = 0x4 // FFrameNumber (Size: 0x4)
MovieSceneTimecodeSource.Timecode = 0x0 // FTimecode (Size: 0x14)
MovieSceneTimecodeSource.DeltaFrame = 0x14 // FFrameNumber (Size: 0x4)
MovieSceneTrack.EvalOptions = 0x50 // FMovieSceneTrackEvalOptions (Size: 0x4)
MovieSceneTrack.bIsEvalDisabled = 0x55 // bool (Size: 0x1)
MovieSceneTrack.EvaluationFieldGuid = 0x58 // FGuid (Size: 0x10)
MovieSceneTrack.EvaluationField = 0x68 // FMovieSceneTrackEvaluationField (Size: 0x10)
MovieSceneTrackDisplayOptions.bShowVerticalFrames = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvalOptions.bCanEvaluateNearestSection = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvalOptions.bEvalNearestSection = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvalOptions.bEvaluateInPreroll = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvalOptions.bEvaluateInPostroll = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvalOptions.bEvaluateNearestSection = 0x0 // uint8_t (Size: 0x1)
MovieSceneTrackEvaluationField.Entries = 0x0 // TArray<FMovieSceneTrackEvaluationFieldEntry> (Size: 0x10)
MovieSceneTrackEvaluationFieldEntry.Section = 0x0 // MovieSceneSection* (Size: 0x8)
MovieSceneTrackEvaluationFieldEntry.Range = 0x8 // FFrameNumberRange (Size: 0x10)
MovieSceneTrackEvaluationFieldEntry.ForcedTime = 0x18 // FFrameNumber (Size: 0x4)
MovieSceneTrackEvaluationFieldEntry.Flags = 0x1c // EESectionEvaluationFlags (Size: 0x1)
MovieSceneTrackEvaluationFieldEntry.LegacySortOrder = 0x1e // int16_t (Size: 0x2)
MovieSceneTrackIdentifier.Value = 0x0 // uint32_t (Size: 0x4)
MovieSceneTrackInstance.AnimatedObject = 0x28 // Object* (Size: 0x8)
MovieSceneTrackInstance.bIsMasterTrackInstance = 0x30 // bool (Size: 0x1)
MovieSceneTrackInstance.Linker = 0x38 // MovieSceneEntitySystemLinker* (Size: 0x8)
MovieSceneTrackInstance.Inputs = 0x40 // TArray<FMovieSceneTrackInstanceInput> (Size: 0x10)
MovieSceneTrackInstanceComponent.Owner = 0x0 // MovieSceneSection* (Size: 0x8)
MovieSceneTrackInstanceComponent.TrackInstanceClass = 0x8 // ClassProperty (Size: 0x8)
MovieSceneTrackInstanceEntry.BoundObject = 0x0 // Object* (Size: 0x8)
MovieSceneTrackInstanceEntry.TrackInstance = 0x8 // MovieSceneTrackInstance* (Size: 0x8)
MovieSceneTrackInstanceInput.Section = 0x0 // MovieSceneSection* (Size: 0x8)
MovieSceneTrackInstanceSystem.Instantiator = 0x40 // MovieSceneTrackInstanceInstantiator* (Size: 0x8)
MovieSceneTrackLabels.Strings = 0x0 // TArray<FString> (Size: 0x10)
MovieSceneWarpCounter.WarpCounts = 0x0 // TArray<uint32_t> (Size: 0x10)
OptionalMovieSceneBlendType.BlendType = 0x0 // EEMovieSceneBlendType (Size: 0x1)
OptionalMovieSceneBlendType.bIsValid = 0x1 // bool (Size: 0x1)
SectionEvaluationData.ImplIndex = 0x0 // int32_t (Size: 0x4)
SectionEvaluationData.ForcedTime = 0x4 // FFrameNumber (Size: 0x4)
SectionEvaluationData.Flags = 0x8 // EESectionEvaluationFlags (Size: 0x1)
TestMovieSceneSequence.MovieScene = 0x60 // MovieScene* (Size: 0x8)
TestMovieSceneSubTrack.SectionArray = 0x88 // TArray<MovieSceneSection*> (Size: 0x10)
TestMovieSceneTrack.bHighPassFilter = 0x80 // bool (Size: 0x1)
TestMovieSceneTrack.SectionArray = 0x88 // TArray<MovieSceneSection*> (Size: 0x10)
TrackInstanceInputComponent.Section = 0x0 // MovieSceneSection* (Size: 0x8)
TrackInstanceInputComponent.OutputIndex = 0x8 // int32_t (Size: 0x4)
CaptureResolution.ResX = 0x0 // int32_t (Size: 0x4)
CaptureResolution.ResY = 0x4 // int32_t (Size: 0x4)
CapturedPixelsID.Identifiers = 0x0 // TMap<...> (Size: 0x50)
CompositionGraphCapturePasses.Value = 0x0 // TArray<FString> (Size: 0x10)
CompositionGraphCaptureProtocol.IncludeRenderPasses = 0x58 // FCompositionGraphCapturePasses (Size: 0x10)
CompositionGraphCaptureProtocol.bCaptureFramesInHDR = 0x68 // bool (Size: 0x1)
CompositionGraphCaptureProtocol.HDRCompressionQuality = 0x6c // int32_t (Size: 0x4)
CompositionGraphCaptureProtocol.CaptureGamut = 0x70 // uint8_t (Size: 0x1)
CompositionGraphCaptureProtocol.PostProcessingMaterial = 0x78 // FSoftObjectPath (Size: 0x18)
CompositionGraphCaptureProtocol.bDisableScreenPercentage = 0x90 // bool (Size: 0x1)
CompositionGraphCaptureProtocol.PostProcessingMaterialPtr = 0x98 // MaterialInterface* (Size: 0x8)
CompressedImageSequenceProtocol.CompressionQuality = 0xd8 // int32_t (Size: 0x4)
FrameMetrics.TotalElapsedTime = 0x0 // float (Size: 0x4)
FrameMetrics.FrameDelta = 0x4 // float (Size: 0x4)
FrameMetrics.FrameNumber = 0x8 // int32_t (Size: 0x4)
FrameMetrics.NumDroppedFrames = 0xc // int32_t (Size: 0x4)
ImageSequenceProtocol_EXR.bCompressed = 0xd8 // bool (Size: 0x1)
ImageSequenceProtocol_EXR.CaptureGamut = 0xd9 // uint8_t (Size: 0x1)
LevelCapture.bAutoStartCapture = 0x228 // bool (Size: 0x1)
LevelCapture.PrerequisiteActorId = 0x234 // FGuid (Size: 0x10)
MasterAudioSubmixCaptureProtocol.Filename = 0x58 // FString (Size: 0x10)
MovieSceneCapture.ImageCaptureProtocolType = 0x38 // FSoftClassPath (Size: 0x18)
MovieSceneCapture.AudioCaptureProtocolType = 0x50 // FSoftClassPath (Size: 0x18)
MovieSceneCapture.ImageCaptureProtocol = 0x68 // MovieSceneImageCaptureProtocolBase* (Size: 0x8)
MovieSceneCapture.AudioCaptureProtocol = 0x70 // MovieSceneAudioCaptureProtocolBase* (Size: 0x8)
MovieSceneCapture.Settings = 0x78 // FMovieSceneCaptureSettings (Size: 0x70)
MovieSceneCapture.bUseSeparateProcess = 0xe8 // bool (Size: 0x1)
MovieSceneCapture.bCloseEditorWhenCaptureStarts = 0xe9 // bool (Size: 0x1)
MovieSceneCapture.AdditionalCommandLineArguments = 0xf0 // FString (Size: 0x10)
MovieSceneCapture.InheritedCommandLineArguments = 0x100 // FString (Size: 0x10)
MovieSceneCaptureProtocolBase.State = 0x50 // EEMovieSceneCaptureProtocolState (Size: 0x1)
MovieSceneCaptureSettings.OutputDirectory = 0x0 // FDirectoryPath (Size: 0x10)
MovieSceneCaptureSettings.GameModeOverride = 0x10 // ClassProperty (Size: 0x8)
MovieSceneCaptureSettings.OutputFormat = 0x18 // FString (Size: 0x10)
MovieSceneCaptureSettings.bOverwriteExisting = 0x28 // bool (Size: 0x1)
MovieSceneCaptureSettings.bUseRelativeFrameNumbers = 0x29 // bool (Size: 0x1)
MovieSceneCaptureSettings.HandleFrames = 0x2c // int32_t (Size: 0x4)
MovieSceneCaptureSettings.MovieExtension = 0x30 // FString (Size: 0x10)
MovieSceneCaptureSettings.ZeroPadFrameNumbers = 0x40 // uint8_t (Size: 0x1)
MovieSceneCaptureSettings.FrameRate = 0x44 // FFrameRate (Size: 0x8)
MovieSceneCaptureSettings.bUseCustomFrameRate = 0x4c // bool (Size: 0x1)
MovieSceneCaptureSettings.CustomFrameRate = 0x50 // FFrameRate (Size: 0x8)
MovieSceneCaptureSettings.Resolution = 0x58 // FCaptureResolution (Size: 0x8)
MovieSceneCaptureSettings.bEnableTextureStreaming = 0x60 // bool (Size: 0x1)
MovieSceneCaptureSettings.bCinematicEngineScalability = 0x61 // bool (Size: 0x1)
MovieSceneCaptureSettings.bCinematicMode = 0x62 // bool (Size: 0x1)
MovieSceneCaptureSettings.bAllowMovement = 0x63 // bool (Size: 0x1)
MovieSceneCaptureSettings.bAllowTurning = 0x64 // bool (Size: 0x1)
MovieSceneCaptureSettings.bShowPlayer = 0x65 // bool (Size: 0x1)
MovieSceneCaptureSettings.bShowHUD = 0x66 // bool (Size: 0x1)
MovieSceneCaptureSettings.bUsePathTracer = 0x67 // bool (Size: 0x1)
MovieSceneCaptureSettings.PathTracerSamplePerPixel = 0x68 // int32_t (Size: 0x4)
UserDefinedCaptureProtocol.World = 0x58 // World* (Size: 0x8)
UserDefinedImageCaptureProtocol.Format = 0xd8 // EEDesiredImageFormat (Size: 0x1)
UserDefinedImageCaptureProtocol.bEnableCompression = 0xd9 // bool (Size: 0x1)
UserDefinedImageCaptureProtocol.CompressionQuality = 0xdc // int32_t (Size: 0x4)
VideoCaptureProtocol.bUseCompression = 0x68 // bool (Size: 0x1)
VideoCaptureProtocol.CompressionQuality = 0x6c // float (Size: 0x4)
BoolParameterNameAndCurve.ParameterName = 0x0 // FName (Size: 0x8)
BoolParameterNameAndCurve.ParameterCurve = 0x8 // FMovieSceneBoolChannel (Size: 0x90)
ColorParameterNameAndCurves.ParameterName = 0x0 // FName (Size: 0x8)
ColorParameterNameAndCurves.RedCurve = 0x8 // FMovieSceneFloatChannel (Size: 0xa0)
ColorParameterNameAndCurves.GreenCurve = 0xa8 // FMovieSceneFloatChannel (Size: 0xa0)
ColorParameterNameAndCurves.BlueCurve = 0x148 // FMovieSceneFloatChannel (Size: 0xa0)
ColorParameterNameAndCurves.AlphaCurve = 0x1e8 // FMovieSceneFloatChannel (Size: 0xa0)
EventPayload.EventName = 0x0 // FName (Size: 0x8)
EventPayload.Parameters = 0x8 // FMovieSceneEventParameters (Size: 0x28)
LevelVisibilityComponentData.Section = 0x0 // MovieSceneLevelVisibilitySection* (Size: 0x8)
MovieScene3DAttachSection.AttachSocketName = 0x118 // FName (Size: 0x8)
MovieScene3DAttachSection.AttachComponentName = 0x120 // FName (Size: 0x8)
MovieScene3DAttachSection.AttachmentLocationRule = 0x128 // EEAttachmentRule (Size: 0x1)
MovieScene3DAttachSection.AttachmentRotationRule = 0x129 // EEAttachmentRule (Size: 0x1)
MovieScene3DAttachSection.AttachmentScaleRule = 0x12a // EEAttachmentRule (Size: 0x1)
MovieScene3DAttachSection.DetachmentLocationRule = 0x12b // EEDetachmentRule (Size: 0x1)
MovieScene3DAttachSection.DetachmentRotationRule = 0x12c // EEDetachmentRule (Size: 0x1)
MovieScene3DAttachSection.DetachmentScaleRule = 0x12d // EEDetachmentRule (Size: 0x1)
MovieScene3DConstraintSection.ConstraintId = 0xe8 // FGuid (Size: 0x10)
MovieScene3DConstraintSection.ConstraintBindingID = 0xf8 // FMovieSceneObjectBindingID (Size: 0x18)
MovieScene3DConstraintTrack.ConstraintSections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieScene3DLocationKeyStruct.Location = 0x8 // FVector (Size: 0xc)
MovieScene3DLocationKeyStruct.Time = 0x14 // FFrameNumber (Size: 0x4)
MovieScene3DPathSection.TimingCurve = 0x110 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DPathSection.FrontAxisEnum = 0x1b0 // EMovieScene3DPathSection_Axis (Size: 0x1)
MovieScene3DPathSection.UpAxisEnum = 0x1b1 // EMovieScene3DPathSection_Axis (Size: 0x1)
MovieScene3DPathSection.bFollow = 0x1b4 // uint8_t (Size: 0x1)
MovieScene3DPathSection.bReverse = 0x1b4 // uint8_t (Size: 0x1)
MovieScene3DPathSection.bForceUpright = 0x1b4 // uint8_t (Size: 0x1)
MovieScene3DPathSectionTemplate.PathBindingID = 0x20 // FMovieSceneObjectBindingID (Size: 0x18)
MovieScene3DPathSectionTemplate.TimingCurve = 0x38 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DPathSectionTemplate.FrontAxisEnum = 0xd8 // EMovieScene3DPathSection_Axis (Size: 0x1)
MovieScene3DPathSectionTemplate.UpAxisEnum = 0xd9 // EMovieScene3DPathSection_Axis (Size: 0x1)
MovieScene3DPathSectionTemplate.bFollow = 0xdc // uint8_t (Size: 0x1)
MovieScene3DPathSectionTemplate.bReverse = 0xdc // uint8_t (Size: 0x1)
MovieScene3DPathSectionTemplate.bForceUpright = 0xdc // uint8_t (Size: 0x1)
MovieScene3DRotationKeyStruct.Rotation = 0x8 // FRotator (Size: 0xc)
MovieScene3DRotationKeyStruct.Time = 0x14 // FFrameNumber (Size: 0x4)
MovieScene3DScaleKeyStruct.Scale = 0x8 // FVector (Size: 0xc)
MovieScene3DScaleKeyStruct.Time = 0x14 // FFrameNumber (Size: 0x4)
MovieScene3DTransformKeyStruct.Location = 0x8 // FVector (Size: 0xc)
MovieScene3DTransformKeyStruct.Rotation = 0x14 // FRotator (Size: 0xc)
MovieScene3DTransformKeyStruct.Scale = 0x20 // FVector (Size: 0xc)
MovieScene3DTransformKeyStruct.Time = 0x2c // FFrameNumber (Size: 0x4)
MovieScene3DTransformSection.TransformMask = 0xf0 // FMovieSceneTransformMask (Size: 0x4)
MovieScene3DTransformSection.Translation = 0xf8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformSection.Rotation = 0x2d8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformSection.Scale = 0x4b8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformSection.ManualWeight = 0x698 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformSection.bUseQuaternionInterpolation = 0x738 // bool (Size: 0x1)
MovieScene3DTransformTemplateData.TranslationCurve = 0x0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformTemplateData.RotationCurve = 0x1e0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformTemplateData.ScaleCurve = 0x3c0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformTemplateData.ManualWeight = 0x5a0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene3DTransformTemplateData.BlendType = 0x640 // EEMovieSceneBlendType (Size: 0x1)
MovieScene3DTransformTemplateData.Mask = 0x644 // FMovieSceneTransformMask (Size: 0x4)
MovieScene3DTransformTemplateData.bUseQuaternionInterpolation = 0x648 // bool (Size: 0x1)
MovieSceneActorReferenceData.KeyTimes = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneActorReferenceData.KeyValues = 0x40 // TArray<FMovieSceneActorReferenceKey> (Size: 0x10)
MovieSceneActorReferenceKey.Object = 0x0 // FMovieSceneObjectBindingID (Size: 0x18)
MovieSceneActorReferenceKey.ComponentName = 0x18 // FName (Size: 0x8)
MovieSceneActorReferenceKey.SocketName = 0x20 // FName (Size: 0x8)
MovieSceneActorReferenceSection.ActorReferenceData = 0xe8 // FMovieSceneActorReferenceData (Size: 0xb0)
MovieSceneActorReferenceSection.ActorGuidIndexCurve = 0x198 // FIntegralCurve (Size: 0x80)
MovieSceneActorReferenceSection.ActorGuidStrings = 0x218 // TArray<FString> (Size: 0x10)
MovieSceneActorReferenceSectionTemplate.PropertyData = 0x20 // FMovieScenePropertySectionData (Size: 0x18)
MovieSceneActorReferenceSectionTemplate.ActorReferenceData = 0x38 // FMovieSceneActorReferenceData (Size: 0xb0)
MovieSceneAudioSection.Sound = 0xe8 // SoundBase* (Size: 0x8)
MovieSceneAudioSection.StartFrameOffset = 0xf0 // FFrameNumber (Size: 0x4)
MovieSceneAudioSection.StartOffset = 0xf4 // float (Size: 0x4)
MovieSceneAudioSection.AudioStartTime = 0xf8 // float (Size: 0x4)
MovieSceneAudioSection.AudioDilationFactor = 0xfc // float (Size: 0x4)
MovieSceneAudioSection.AudioVolume = 0x100 // float (Size: 0x4)
MovieSceneAudioSection.SoundVolume = 0x108 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneAudioSection.PitchMultiplier = 0x1a8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneAudioSection.AttachActorData = 0x248 // FMovieSceneActorReferenceData (Size: 0xb0)
MovieSceneAudioSection.bLooping = 0x2f8 // bool (Size: 0x1)
MovieSceneAudioSection.bSuppressSubtitles = 0x2f9 // bool (Size: 0x1)
MovieSceneAudioSection.bOverrideAttenuation = 0x2fa // bool (Size: 0x1)
MovieSceneAudioSection.AttenuationSettings = 0x300 // SoundAttenuation* (Size: 0x8)
MovieSceneAudioSection.OnQueueSubtitles = 0x308 // FDelegate (Size: 0x10)
MovieSceneAudioSection.OnAudioFinished = 0x318 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneAudioSection.OnAudioPlaybackPercent = 0x328 // FMulticastInlineDelegate (Size: 0x10)
MovieSceneAudioSectionTemplate.AudioSection = 0x20 // MovieSceneAudioSection* (Size: 0x8)
MovieSceneAudioTrack.AudioSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneBoolPropertySectionTemplate.BoolCurve = 0x38 // FMovieSceneBoolChannel (Size: 0x90)
MovieSceneBytePropertySectionTemplate.ByteCurve = 0x38 // FMovieSceneByteChannel (Size: 0x98)
MovieSceneByteSection.ByteCurve = 0xe8 // FMovieSceneByteChannel (Size: 0x98)
MovieSceneByteTrack.Enum = 0xb0 // Enum* (Size: 0x8)
MovieSceneCameraAnimSection.AnimData = 0xe8 // FMovieSceneCameraAnimSectionData (Size: 0x20)
MovieSceneCameraAnimSection.CameraAnim = 0x108 // CameraAnim* (Size: 0x8)
MovieSceneCameraAnimSection.PlayRate = 0x110 // float (Size: 0x4)
MovieSceneCameraAnimSection.PlayScale = 0x114 // float (Size: 0x4)
MovieSceneCameraAnimSection.BlendInTime = 0x118 // float (Size: 0x4)
MovieSceneCameraAnimSection.BlendOutTime = 0x11c // float (Size: 0x4)
MovieSceneCameraAnimSection.bLooping = 0x120 // bool (Size: 0x1)
MovieSceneCameraAnimSectionData.CameraAnim = 0x0 // CameraAnim* (Size: 0x8)
MovieSceneCameraAnimSectionData.PlayRate = 0x8 // float (Size: 0x4)
MovieSceneCameraAnimSectionData.PlayScale = 0xc // float (Size: 0x4)
MovieSceneCameraAnimSectionData.BlendInTime = 0x10 // float (Size: 0x4)
MovieSceneCameraAnimSectionData.BlendOutTime = 0x14 // float (Size: 0x4)
MovieSceneCameraAnimSectionData.bLooping = 0x18 // bool (Size: 0x1)
MovieSceneCameraAnimSectionTemplate.SourceData = 0x20 // FMovieSceneCameraAnimSectionData (Size: 0x20)
MovieSceneCameraAnimSectionTemplate.SectionStartTime = 0x40 // FFrameNumber (Size: 0x4)
MovieSceneCameraAnimTrack.CameraAnimSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneCameraCutSection.bLockPreviousCamera = 0xf0 // bool (Size: 0x1)
MovieSceneCameraCutSection.CameraGuid = 0xf4 // FGuid (Size: 0x10)
MovieSceneCameraCutSection.CameraBindingID = 0x104 // FMovieSceneObjectBindingID (Size: 0x18)
MovieSceneCameraCutSection.InitialCameraCutTransform = 0x120 // FTransform (Size: 0x30)
MovieSceneCameraCutSection.bHasInitialCameraCutTransform = 0x150 // bool (Size: 0x1)
MovieSceneCameraCutTrack.bCanBlend = 0x78 // bool (Size: 0x1)
MovieSceneCameraCutTrack.Sections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneCameraShakeSection.ShakeData = 0xe8 // FMovieSceneCameraShakeSectionData (Size: 0x20)
MovieSceneCameraShakeSection.ShakeClass = 0x108 // ClassProperty (Size: 0x8)
MovieSceneCameraShakeSection.PlayScale = 0x110 // float (Size: 0x4)
MovieSceneCameraShakeSection.PlaySpace = 0x114 // EECameraShakePlaySpace (Size: 0x1)
MovieSceneCameraShakeSection.UserDefinedPlaySpace = 0x118 // FRotator (Size: 0xc)
MovieSceneCameraShakeSectionData.ShakeClass = 0x0 // ClassProperty (Size: 0x8)
MovieSceneCameraShakeSectionData.PlayScale = 0x8 // float (Size: 0x4)
MovieSceneCameraShakeSectionData.PlaySpace = 0xc // EECameraShakePlaySpace (Size: 0x1)
MovieSceneCameraShakeSectionData.UserDefinedPlaySpace = 0x10 // FRotator (Size: 0xc)
MovieSceneCameraShakeSectionTemplate.SourceData = 0x20 // FMovieSceneCameraShakeSectionData (Size: 0x20)
MovieSceneCameraShakeSectionTemplate.SectionStartTime = 0x40 // FFrameNumber (Size: 0x4)
MovieSceneCameraShakeSourceShakeSection.ShakeData = 0xe8 // FMovieSceneCameraShakeSectionData (Size: 0x20)
MovieSceneCameraShakeSourceShakeSectionTemplate.SourceData = 0x20 // FMovieSceneCameraShakeSectionData (Size: 0x20)
MovieSceneCameraShakeSourceShakeSectionTemplate.SectionStartTime = 0x40 // FFrameNumber (Size: 0x4)
MovieSceneCameraShakeSourceShakeSectionTemplate.SectionEndTime = 0x44 // FFrameNumber (Size: 0x4)
MovieSceneCameraShakeSourceShakeTrack.CameraShakeSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneCameraShakeSourceTrigger.ShakeClass = 0x0 // ClassProperty (Size: 0x8)
MovieSceneCameraShakeSourceTrigger.PlayScale = 0x8 // float (Size: 0x4)
MovieSceneCameraShakeSourceTrigger.PlaySpace = 0xc // EECameraShakePlaySpace (Size: 0x1)
MovieSceneCameraShakeSourceTrigger.UserDefinedPlaySpace = 0x10 // FRotator (Size: 0xc)
MovieSceneCameraShakeSourceTriggerChannel.KeyTimes = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneCameraShakeSourceTriggerChannel.KeyValues = 0x18 // TArray<FMovieSceneCameraShakeSourceTrigger> (Size: 0x10)
MovieSceneCameraShakeSourceTriggerSection.Channel = 0xe8 // FMovieSceneCameraShakeSourceTriggerChannel (Size: 0x88)
MovieSceneCameraShakeSourceTriggerSectionTemplate.triggertimes = 0x20 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneCameraShakeSourceTriggerSectionTemplate.TriggerValues = 0x30 // TArray<FMovieSceneCameraShakeSourceTrigger> (Size: 0x10)
MovieSceneCameraShakeSourceTriggerTrack.Sections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneCameraShakeTrack.CameraShakeSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneCinematicShotSection.ShotDisplayName = 0x160 // FString (Size: 0x10)
MovieSceneCinematicShotSection.DisplayName = 0x170 // FText (Size: 0x18)
MovieSceneColorKeyStruct.Color = 0x8 // FLinearColor (Size: 0x10)
MovieSceneColorKeyStruct.Time = 0x18 // FFrameNumber (Size: 0x4)
MovieSceneColorSection.RedCurve = 0xe8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneColorSection.GreenCurve = 0x188 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneColorSection.BlueCurve = 0x228 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneColorSection.AlphaCurve = 0x2c8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneColorSectionTemplate.Curves = 0x38 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneColorSectionTemplate.BlendType = 0x2b8 // EEMovieSceneBlendType (Size: 0x1)
MovieSceneColorTrack.bIsSlateColor = 0xb0 // bool (Size: 0x1)
MovieSceneComponentMaterialSectionTemplate.MaterialIndex = 0x80 // int32_t (Size: 0x4)
MovieSceneComponentMaterialTrack.MaterialIndex = 0x90 // int32_t (Size: 0x4)
MovieSceneEnumPropertySectionTemplate.EnumCurve = 0x38 // FMovieSceneByteChannel (Size: 0x98)
MovieSceneEnumSection.EnumCurve = 0xe8 // FMovieSceneByteChannel (Size: 0x98)
MovieSceneEnumTrack.Enum = 0xb0 // Enum* (Size: 0x8)
MovieSceneEvent.Ptrs = 0x0 // FMovieSceneEventPtrs (Size: 0x28)
MovieSceneEventChannel.KeyTimes = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneEventChannel.KeyValues = 0x18 // TArray<FMovieSceneEvent> (Size: 0x10)
MovieSceneEventPayloadVariable.Value = 0x0 // FString (Size: 0x10)
MovieSceneEventPtrs.Function = 0x0 // Function* (Size: 0x8)
MovieSceneEventPtrs.BoundObjectProperty = 0x8 // FieldPathProperty (Size: 0x20)
MovieSceneEventRepeaterSection.Event = 0xf0 // FMovieSceneEvent (Size: 0x28)
MovieSceneEventSection.Events = 0xe8 // FNameCurve (Size: 0x78)
MovieSceneEventSection.EventData = 0x160 // FMovieSceneEventSectionData (Size: 0x88)
MovieSceneEventSectionData.Times = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneEventSectionData.KeyValues = 0x18 // TArray<FEventPayload> (Size: 0x10)
MovieSceneEventSectionTemplate.EventData = 0x20 // FMovieSceneEventSectionData (Size: 0x88)
MovieSceneEventSectionTemplate.bFireEventsWhenForwards = 0xa8 // uint8_t (Size: 0x1)
MovieSceneEventSectionTemplate.bFireEventsWhenBackwards = 0xa8 // uint8_t (Size: 0x1)
MovieSceneEventTrack.bFireEventsWhenForwards = 0x80 // uint8_t (Size: 0x1)
MovieSceneEventTrack.bFireEventsWhenBackwards = 0x80 // uint8_t (Size: 0x1)
MovieSceneEventTrack.EventPosition = 0x84 // EEFireEventsAtPosition (Size: 0x1)
MovieSceneEventTrack.Sections = 0x88 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneEventTriggerData.Ptrs = 0x0 // FMovieSceneEventPtrs (Size: 0x28)
MovieSceneEventTriggerData.ObjectBindingID = 0x28 // FGuid (Size: 0x10)
MovieSceneEventTriggerSection.EventChannel = 0xf0 // FMovieSceneEventChannel (Size: 0x88)
MovieSceneFadeSection.FloatCurve = 0xe8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneFadeSection.FadeColor = 0x188 // FLinearColor (Size: 0x10)
MovieSceneFadeSection.bFadeAudio = 0x198 // uint8_t (Size: 0x1)
MovieSceneFadeSectionTemplate.FadeCurve = 0x20 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneFadeSectionTemplate.FadeColor = 0xc0 // FLinearColor (Size: 0x10)
MovieSceneFadeSectionTemplate.bFadeAudio = 0xd0 // uint8_t (Size: 0x1)
MovieSceneFloatSection.FloatCurve = 0xf0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneIntegerPropertySectionTemplate.IntegerCurve = 0x38 // FMovieSceneIntegerChannel (Size: 0x90)
MovieSceneIntegerPropertySectionTemplate.BlendType = 0xc8 // EEMovieSceneBlendType (Size: 0x1)
MovieSceneIntegerSection.IntegerCurve = 0xe8 // FMovieSceneIntegerChannel (Size: 0x90)
MovieSceneLevelVisibilitySection.Visibility = 0xf0 // EELevelVisibility (Size: 0x1)
MovieSceneLevelVisibilitySection.LevelNames = 0xf8 // TArray<FName> (Size: 0x10)
MovieSceneLevelVisibilityTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneMaterialParameterCollectionTemplate.MPC = 0x80 // MaterialParameterCollection* (Size: 0x8)
MovieSceneMaterialParameterCollectionTrack.MPC = 0x90 // MaterialParameterCollection* (Size: 0x8)
MovieSceneMaterialTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneObjectPropertySection.ObjectChannel = 0xe8 // FMovieSceneObjectPathChannel (Size: 0xc0)
MovieSceneObjectPropertyTemplate.ObjectChannel = 0x38 // FMovieSceneObjectPathChannel (Size: 0xc0)
MovieSceneObjectPropertyTrack.PropertyClass = 0xb0 // ClassProperty (Size: 0x8)
MovieSceneParameterSection.BoolParameterNamesAndCurves = 0xe8 // TArray<FBoolParameterNameAndCurve> (Size: 0x10)
MovieSceneParameterSection.ScalarParameterNamesAndCurves = 0xf8 // TArray<FScalarParameterNameAndCurve> (Size: 0x10)
MovieSceneParameterSection.Vector2DParameterNamesAndCurves = 0x108 // TArray<FVector2DParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSection.VectorParameterNamesAndCurves = 0x118 // TArray<FVectorParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSection.ColorParameterNamesAndCurves = 0x128 // TArray<FColorParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSection.TransformParameterNamesAndCurves = 0x138 // TArray<FTransformParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSectionTemplate.Scalars = 0x20 // TArray<FScalarParameterNameAndCurve> (Size: 0x10)
MovieSceneParameterSectionTemplate.Bools = 0x30 // TArray<FBoolParameterNameAndCurve> (Size: 0x10)
MovieSceneParameterSectionTemplate.Vector2Ds = 0x40 // TArray<FVector2DParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSectionTemplate.Vectors = 0x50 // TArray<FVectorParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSectionTemplate.Colors = 0x60 // TArray<FColorParameterNameAndCurves> (Size: 0x10)
MovieSceneParameterSectionTemplate.Transforms = 0x70 // TArray<FTransformParameterNameAndCurves> (Size: 0x10)
MovieSceneParticleParameterTrack.Sections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneParticleSection.ParticleKeys = 0xe8 // FMovieSceneParticleChannel (Size: 0x98)
MovieSceneParticleSectionTemplate.ParticleKeys = 0x20 // FMovieSceneParticleChannel (Size: 0x98)
MovieSceneParticleTrack.ParticleSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieScenePrimitiveMaterialSection.MaterialChannel = 0xe8 // FMovieSceneObjectPathChannel (Size: 0xc0)
MovieScenePrimitiveMaterialTemplate.MaterialIndex = 0x20 // int32_t (Size: 0x4)
MovieScenePrimitiveMaterialTemplate.MaterialChannel = 0x28 // FMovieSceneObjectPathChannel (Size: 0xc0)
MovieScenePrimitiveMaterialTrack.MaterialIndex = 0xb0 // int32_t (Size: 0x4)
MovieScenePropertySystem.InstantiatorSystem = 0x40 // MovieScenePropertyInstantiatorSystem* (Size: 0x8)
MovieScenePropertyTrack.SectionToKey = 0x78 // MovieSceneSection* (Size: 0x8)
MovieScenePropertyTrack.PropertyBinding = 0x80 // FMovieScenePropertyBinding (Size: 0x14)
MovieScenePropertyTrack.Sections = 0x98 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneSkeletalAnimationParams.Animation = 0x0 // AnimSequenceBase* (Size: 0x8)
MovieSceneSkeletalAnimationParams.FirstLoopStartFrameOffset = 0x8 // FFrameNumber (Size: 0x4)
MovieSceneSkeletalAnimationParams.StartFrameOffset = 0xc // FFrameNumber (Size: 0x4)
MovieSceneSkeletalAnimationParams.EndFrameOffset = 0x10 // FFrameNumber (Size: 0x4)
MovieSceneSkeletalAnimationParams.PlayRate = 0x14 // float (Size: 0x4)
MovieSceneSkeletalAnimationParams.bReverse = 0x18 // uint8_t (Size: 0x1)
MovieSceneSkeletalAnimationParams.SlotName = 0x1c // FName (Size: 0x8)
MovieSceneSkeletalAnimationParams.Weight = 0x28 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneSkeletalAnimationParams.bSkipAnimNotifiers = 0xc8 // bool (Size: 0x1)
MovieSceneSkeletalAnimationParams.bForceCustomMode = 0xc9 // bool (Size: 0x1)
MovieSceneSkeletalAnimationParams.StartOffset = 0xcc // float (Size: 0x4)
MovieSceneSkeletalAnimationParams.EndOffset = 0xd0 // float (Size: 0x4)
MovieSceneSkeletalAnimationSection.Params = 0xe8 // FMovieSceneSkeletalAnimationParams (Size: 0xd8)
MovieSceneSkeletalAnimationSection.AnimSequence = 0x1c0 // AnimSequence* (Size: 0x8)
MovieSceneSkeletalAnimationSection.Animation = 0x1c8 // AnimSequenceBase* (Size: 0x8)
MovieSceneSkeletalAnimationSection.StartOffset = 0x1d0 // float (Size: 0x4)
MovieSceneSkeletalAnimationSection.EndOffset = 0x1d4 // float (Size: 0x4)
MovieSceneSkeletalAnimationSection.PlayRate = 0x1d8 // float (Size: 0x4)
MovieSceneSkeletalAnimationSection.bReverse = 0x1dc // uint8_t (Size: 0x1)
MovieSceneSkeletalAnimationSection.SlotName = 0x1e0 // FName (Size: 0x8)
MovieSceneSkeletalAnimationSection.StartLocationOffset = 0x1e8 // FVector (Size: 0xc)
MovieSceneSkeletalAnimationSection.StartRotationOffset = 0x1f4 // FRotator (Size: 0xc)
MovieSceneSkeletalAnimationSection.bMatchWithPrevious = 0x200 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSection.MatchedBoneName = 0x204 // FName (Size: 0x8)
MovieSceneSkeletalAnimationSection.MatchedLocationOffset = 0x20c // FVector (Size: 0xc)
MovieSceneSkeletalAnimationSection.MatchedRotationOffset = 0x218 // FRotator (Size: 0xc)
MovieSceneSkeletalAnimationSection.bMatchTranslation = 0x224 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSection.bMatchIncludeZHeight = 0x225 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSection.bMatchRotationYaw = 0x226 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSection.bMatchRotationPitch = 0x227 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSection.bMatchRotationRoll = 0x228 // bool (Size: 0x1)
MovieSceneSkeletalAnimationSectionTemplate.Params = 0x20 // FMovieSceneSkeletalAnimationSectionTemplateParameters (Size: 0xe0)
MovieSceneSkeletalAnimationSectionTemplateParameters.SectionStartTime = 0xd8 // FFrameNumber (Size: 0x4)
MovieSceneSkeletalAnimationSectionTemplateParameters.SectionEndTime = 0xdc // FFrameNumber (Size: 0x4)
MovieSceneSkeletalAnimationTrack.AnimationSections = 0x80 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneSkeletalAnimationTrack.bUseLegacySectionIndexBlend = 0x90 // bool (Size: 0x1)
MovieSceneSkeletalAnimationTrack.RootMotionParams = 0x98 // FMovieSceneSkeletalAnimRootMotionTrackParams (Size: 0x30)
MovieSceneSkeletalAnimationTrack.bBlendFirstChildOfRoot = 0xc8 // bool (Size: 0x1)
MovieSceneSlomoSection.FloatCurve = 0xe8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneSlomoSectionTemplate.SlomoCurve = 0x20 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneStringChannel.Times = 0x8 // TArray<FFrameNumber> (Size: 0x10)
MovieSceneStringChannel.Values = 0x18 // TArray<FString> (Size: 0x10)
MovieSceneStringChannel.DefaultValue = 0x28 // FString (Size: 0x10)
MovieSceneStringChannel.bHasDefaultValue = 0x38 // bool (Size: 0x1)
MovieSceneStringPropertySectionTemplate.StringCurve = 0x38 // FMovieSceneStringChannel (Size: 0xa0)
MovieSceneStringSection.StringCurve = 0xe8 // FMovieSceneStringChannel (Size: 0xa0)
MovieSceneTransformMask.Mask = 0x0 // uint32_t (Size: 0x4)
MovieSceneVector2DKeyStruct.Vector = 0x28 // FVector2D (Size: 0x8)
MovieSceneVector4KeyStruct.Vector = 0x30 // FVector4 (Size: 0x10)
MovieSceneVectorKeyStruct.Vector = 0x28 // FVector (Size: 0xc)
MovieSceneVectorKeyStructBase.Time = 0x8 // FFrameNumber (Size: 0x4)
MovieSceneVectorPropertySectionTemplate.ComponentCurves = 0x38 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneVectorPropertySectionTemplate.NumChannelsUsed = 0x2b8 // int32_t (Size: 0x4)
MovieSceneVectorPropertySectionTemplate.BlendType = 0x2bc // EEMovieSceneBlendType (Size: 0x1)
MovieSceneVectorSection.Curves = 0xe8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneVectorSection.ChannelsUsed = 0x368 // int32_t (Size: 0x4)
MovieSceneVectorTrack.NumChannelsUsed = 0xb0 // int32_t (Size: 0x4)
ScalarParameterNameAndCurve.ParameterName = 0x0 // FName (Size: 0x8)
ScalarParameterNameAndCurve.ParameterCurve = 0x8 // FMovieSceneFloatChannel (Size: 0xa0)
TransformParameterNameAndCurves.ParameterName = 0x0 // FName (Size: 0x8)
TransformParameterNameAndCurves.Translation = 0x8 // FMovieSceneFloatChannel (Size: 0xa0)
TransformParameterNameAndCurves.Rotation = 0x1e8 // FMovieSceneFloatChannel (Size: 0xa0)
TransformParameterNameAndCurves.Scale = 0x3c8 // FMovieSceneFloatChannel (Size: 0xa0)
Vector2DParameterNameAndCurves.ParameterName = 0x0 // FName (Size: 0x8)
Vector2DParameterNameAndCurves.XCurve = 0x8 // FMovieSceneFloatChannel (Size: 0xa0)
Vector2DParameterNameAndCurves.YCurve = 0xa8 // FMovieSceneFloatChannel (Size: 0xa0)
VectorParameterNameAndCurves.ParameterName = 0x0 // FName (Size: 0x8)
VectorParameterNameAndCurves.XCurve = 0x8 // FMovieSceneFloatChannel (Size: 0xa0)
VectorParameterNameAndCurves.YCurve = 0xa8 // FMovieSceneFloatChannel (Size: 0xa0)
VectorParameterNameAndCurves.ZCurve = 0x148 // FMovieSceneFloatChannel (Size: 0xa0)
NavArea.DefaultCost = 0x30 // float (Size: 0x4)
NavArea.FixedAreaEnteringCost = 0x34 // float (Size: 0x4)
NavArea.DrawColor = 0x38 // FColor (Size: 0x4)
NavArea.SupportedAgents = 0x3c // FNavAgentSelector (Size: 0x4)
NavArea.bSupportsAgent0 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent1 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent2 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent3 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent4 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent5 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent6 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent7 = 0x40 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent8 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent9 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent10 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent11 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent12 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent13 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent14 = 0x41 // uint8_t (Size: 0x1)
NavArea.bSupportsAgent15 = 0x41 // uint8_t (Size: 0x1)
NavAreaMeta_SwitchByAgent.Agent0Area = 0x48 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent1Area = 0x50 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent2Area = 0x58 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent3Area = 0x60 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent4Area = 0x68 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent5Area = 0x70 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent6Area = 0x78 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent7Area = 0x80 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent8Area = 0x88 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent9Area = 0x90 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent10Area = 0x98 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent11Area = 0xa0 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent12Area = 0xa8 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent13Area = 0xb0 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent14Area = 0xb8 // ClassProperty (Size: 0x8)
NavAreaMeta_SwitchByAgent.Agent15Area = 0xc0 // ClassProperty (Size: 0x8)
NavCollision.CylinderCollision = 0x80 // TArray<FNavCollisionCylinder> (Size: 0x10)
NavCollision.BoxCollision = 0x90 // TArray<FNavCollisionBox> (Size: 0x10)
NavCollision.AreaClass = 0xa0 // ClassProperty (Size: 0x8)
NavCollision.bGatherConvexGeometry = 0xa8 // uint8_t (Size: 0x1)
NavCollision.bCreateOnClient = 0xa8 // uint8_t (Size: 0x1)
NavCollisionBox.Offset = 0x0 // FVector (Size: 0xc)
NavCollisionBox.Extent = 0xc // FVector (Size: 0xc)
NavCollisionCylinder.Offset = 0x0 // FVector (Size: 0xc)
NavCollisionCylinder.Radius = 0xc // float (Size: 0x4)
NavCollisionCylinder.Height = 0x10 // float (Size: 0x4)
NavGraphNode.Owner = 0x0 // Object* (Size: 0x8)
NavLinkComponent.Links = 0x5d0 // TArray<FNavigationLink> (Size: 0x10)
NavLinkCustomComponent.NavLinkUserId = 0x130 // uint32_t (Size: 0x4)
NavLinkCustomComponent.EnabledAreaClass = 0x138 // ClassProperty (Size: 0x8)
NavLinkCustomComponent.DisabledAreaClass = 0x140 // ClassProperty (Size: 0x8)
NavLinkCustomComponent.SupportedAgents = 0x148 // FNavAgentSelector (Size: 0x4)
NavLinkCustomComponent.LinkRelativeStart = 0x14c // FVector (Size: 0xc)
NavLinkCustomComponent.LinkRelativeEnd = 0x158 // FVector (Size: 0xc)
NavLinkCustomComponent.LinkDirection = 0x164 // uint8_t (Size: 0x1)
NavLinkCustomComponent.bLinkEnabled = 0x168 // uint8_t (Size: 0x1)
NavLinkCustomComponent.bNotifyWhenEnabled = 0x168 // uint8_t (Size: 0x1)
NavLinkCustomComponent.bNotifyWhenDisabled = 0x168 // uint8_t (Size: 0x1)
NavLinkCustomComponent.bCreateBoxObstacle = 0x168 // uint8_t (Size: 0x1)
NavLinkCustomComponent.ObstacleOffset = 0x16c // FVector (Size: 0xc)
NavLinkCustomComponent.ObstacleExtent = 0x178 // FVector (Size: 0xc)
NavLinkCustomComponent.ObstacleAreaClass = 0x188 // ClassProperty (Size: 0x8)
NavLinkCustomComponent.BroadcastRadius = 0x190 // float (Size: 0x4)
NavLinkCustomComponent.BroadcastInterval = 0x194 // float (Size: 0x4)
NavLinkCustomComponent.BroadcastChannel = 0x198 // uint8_t (Size: 0x1)
NavLinkCustomInstanceData.NavLinkUserId = 0x68 // uint32_t (Size: 0x4)
NavMeshBoundsVolume.SupportedAgents = 0x348 // FNavAgentSelector (Size: 0x4)
NavModifierComponent.AreaClass = 0x128 // ClassProperty (Size: 0x8)
NavModifierComponent.FailsafeExtent = 0x130 // FVector (Size: 0xc)
NavModifierComponent.bIncludeAgentHeight = 0x13c // uint8_t (Size: 0x1)
NavModifierVolume.AreaClass = 0x350 // ClassProperty (Size: 0x8)
NavModifierVolume.bMaskFillCollisionUnderneathForNavmesh = 0x358 // bool (Size: 0x1)
NavRelevantComponent.bAttachToOwnersRoot = 0x11c // uint8_t (Size: 0x1)
NavRelevantComponent.CachedNavParent = 0x120 // Object* (Size: 0x8)
NavSystemConfigOverride.NavigationSystemConfig = 0x310 // NavigationSystemConfig* (Size: 0x8)
NavSystemConfigOverride.OverridePolicy = 0x318 // EENavSystemOverridePolicy (Size: 0x1)
NavSystemConfigOverride.bLoadOnClient = 0x319 // uint8_t (Size: 0x1)
NavigationData.RenderingComp = 0x318 // PrimitiveComponent* (Size: 0x8)
NavigationData.NavDataConfig = 0x320 // FNavDataConfig (Size: 0x78)
NavigationData.bEnableDrawing = 0x398 // uint8_t (Size: 0x1)
NavigationData.bForceRebuildOnLoad = 0x398 // uint8_t (Size: 0x1)
NavigationData.bAutoDestroyWhenNoNavigation = 0x398 // uint8_t (Size: 0x1)
NavigationData.bCanBeMainNavData = 0x398 // uint8_t (Size: 0x1)
NavigationData.bCanSpawnOnRebuild = 0x398 // uint8_t (Size: 0x1)
NavigationData.bRebuildAtRuntime = 0x398 // uint8_t (Size: 0x1)
NavigationData.RuntimeGeneration = 0x39c // EERuntimeGenerationType (Size: 0x1)
NavigationData.ObservedPathsTickInterval = 0x3a0 // float (Size: 0x4)
NavigationData.DataVersion = 0x3a4 // uint32_t (Size: 0x4)
NavigationData.SupportedAreas = 0x4b0 // TArray<FSupportedAreaData> (Size: 0x10)
NavigationFilterArea.AreaClass = 0x0 // ClassProperty (Size: 0x8)
NavigationFilterArea.TravelCostOverride = 0x8 // float (Size: 0x4)
NavigationFilterArea.EnteringCostOverride = 0xc // float (Size: 0x4)
NavigationFilterArea.bIsExcluded = 0x10 // uint8_t (Size: 0x1)
NavigationFilterArea.bOverrideTravelCost = 0x10 // uint8_t (Size: 0x1)
NavigationFilterArea.bOverrideEnteringCost = 0x10 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag0 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag1 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag2 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag3 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag4 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag5 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag6 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag7 = 0x0 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag8 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag9 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag10 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag11 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag12 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag13 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag14 = 0x1 // uint8_t (Size: 0x1)
NavigationFilterFlags.bNavFlag15 = 0x1 // uint8_t (Size: 0x1)
NavigationGraphNodeComponent.Node = 0x238 // FNavGraphNode (Size: 0x18)
NavigationGraphNodeComponent.NextNodeComponent = 0x250 // NavigationGraphNodeComponent* (Size: 0x8)
NavigationGraphNodeComponent.PrevNodeComponent = 0x258 // NavigationGraphNodeComponent* (Size: 0x8)
NavigationInvokerComponent.TileGenerationRadius = 0xf8 // float (Size: 0x4)
NavigationInvokerComponent.TileRemovalRadius = 0xfc // float (Size: 0x4)
NavigationPath.PathUpdatedNotifier = 0x28 // FMulticastInlineDelegate (Size: 0x10)
NavigationPath.PathPoints = 0x38 // TArray<FVector> (Size: 0x10)
NavigationPath.RecalculateOnInvalidation = 0x48 // uint8_t (Size: 0x1)
NavigationQueryFilter.Areas = 0x28 // TArray<FNavigationFilterArea> (Size: 0x10)
NavigationQueryFilter.IncludeFlags = 0x38 // FNavigationFilterFlags (Size: 0x4)
NavigationQueryFilter.ExcludeFlags = 0x3c // FNavigationFilterFlags (Size: 0x4)
NavigationSystemModuleConfig.bStrictlyStatic = 0x50 // uint8_t (Size: 0x1)
NavigationSystemModuleConfig.bCreateOnClient = 0x50 // uint8_t (Size: 0x1)
NavigationSystemModuleConfig.bAutoSpawnMissingNavData = 0x50 // uint8_t (Size: 0x1)
NavigationSystemModuleConfig.bSpawnNavDataInNavBoundsLevel = 0x50 // uint8_t (Size: 0x1)
NavigationSystemV1.MainNavData = 0x28 // NavigationData* (Size: 0x8)
NavigationSystemV1.AbstractNavData = 0x30 // NavigationData* (Size: 0x8)
NavigationSystemV1.DefaultAgentName = 0x38 // FName (Size: 0x8)
NavigationSystemV1.CrowdManagerClass = 0x40 // TSoftClassPtr<UObject> (Size: 0x28)
NavigationSystemV1.bAutoCreateNavigationData = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bSpawnNavDataInNavBoundsLevel = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bAllowClientSideNavigation = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bShouldDiscardSubLevelNavData = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bTickWhilePaused = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bSupportRebuilding = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bInitialBuildingLocked = 0x68 // uint8_t (Size: 0x1)
NavigationSystemV1.bSkipAgentHeightCheckWhenPickingNavData = 0x69 // uint8_t (Size: 0x1)
NavigationSystemV1.NavMeshQueryFindPathTimeLimit = 0x6c // float (Size: 0x4)
NavigationSystemV1.bGenerateNavigationOnlyAroundNavigationInvokers = 0x70 // uint8_t (Size: 0x1)
NavigationSystemV1.ActiveTilesUpdateInterval = 0x74 // float (Size: 0x4)
NavigationSystemV1.DataGatheringMode = 0x78 // EENavDataGatheringModeConfig (Size: 0x1)
NavigationSystemV1.DirtyAreaWarningSizeThreshold = 0x7c // float (Size: 0x4)
NavigationSystemV1.SupportedAgents = 0x80 // TArray<FNavDataConfig> (Size: 0x10)
NavigationSystemV1.SupportedAgentsMask = 0x90 // FNavAgentSelector (Size: 0x4)
NavigationSystemV1.NavDataSet = 0x98 // TArray<NavigationData*> (Size: 0x10)
NavigationSystemV1.NavDataRegistrationQueue = 0xa8 // TArray<NavigationData*> (Size: 0x10)
NavigationSystemV1.OnNavDataRegisteredEvent = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
NavigationSystemV1.OnNavigationGenerationFinishedDelegate = 0xd8 // FMulticastInlineDelegate (Size: 0x10)
NavigationSystemV1.OnNavigationGenerationBeginDelegate = 0xe8 // FMulticastInlineDelegate (Size: 0x10)
NavigationSystemV1.OperationMode = 0x1d4 // EFNavigationSystemRunMode (Size: 0x1)
NavigationSystemV1.DirtyAreasUpdateFreq = 0x15d4 // float (Size: 0x4)
NavigationTestingActor.CapsuleComponent = 0x320 // CapsuleComponent* (Size: 0x8)
NavigationTestingActor.InvokerComponent = 0x328 // NavigationInvokerComponent* (Size: 0x8)
NavigationTestingActor.bActAsNavigationInvoker = 0x330 // uint8_t (Size: 0x1)
NavigationTestingActor.NavAgentProps = 0x338 // FNavAgentProperties (Size: 0x30)
NavigationTestingActor.QueryingExtent = 0x368 // FVector (Size: 0xc)
NavigationTestingActor.MyNavData = 0x378 // NavigationData* (Size: 0x8)
NavigationTestingActor.ProjectedLocation = 0x380 // FVector (Size: 0xc)
NavigationTestingActor.bProjectedLocationValid = 0x38c // uint8_t (Size: 0x1)
NavigationTestingActor.bSearchStart = 0x38c // uint8_t (Size: 0x1)
NavigationTestingActor.CostLimitFactor = 0x390 // float (Size: 0x4)
NavigationTestingActor.MinimumCostLimit = 0x394 // float (Size: 0x4)
NavigationTestingActor.bBacktracking = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bUseHierarchicalPathfinding = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bGatherDetailedInfo = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bDrawDistanceToWall = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bShowNodePool = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bShowBestPath = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bShowDiffWithPreviousStep = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.bShouldBeVisibleInGame = 0x398 // uint8_t (Size: 0x1)
NavigationTestingActor.CostDisplayMode = 0x39c // uint8_t (Size: 0x1)
NavigationTestingActor.TextCanvasOffset = 0x3a0 // FVector2D (Size: 0x8)
NavigationTestingActor.bPathExist = 0x3a8 // uint8_t (Size: 0x1)
NavigationTestingActor.bPathIsPartial = 0x3a8 // uint8_t (Size: 0x1)
NavigationTestingActor.bPathSearchOutOfNodes = 0x3a8 // uint8_t (Size: 0x1)
NavigationTestingActor.PathfindingTime = 0x3ac // float (Size: 0x4)
NavigationTestingActor.PathCost = 0x3b0 // float (Size: 0x4)
NavigationTestingActor.PathfindingSteps = 0x3b4 // int32_t (Size: 0x4)
NavigationTestingActor.OtherActor = 0x3b8 // NavigationTestingActor* (Size: 0x8)
NavigationTestingActor.FilterClass = 0x3c0 // ClassProperty (Size: 0x8)
NavigationTestingActor.ShowStepIndex = 0x3c8 // int32_t (Size: 0x4)
NavigationTestingActor.OffsetFromCornersDistance = 0x3cc // float (Size: 0x4)
RecastNavMesh.bDrawTriangleEdges = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawPolyEdges = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawFilledPolys = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawNavMeshEdges = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawNavMeshClosedAngle = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawTileBounds = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawPathCollidingGeometry = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawTileLabels = 0x518 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawPolygonLabels = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawDefaultPolygonCost = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawLabelsOnPathNodes = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawNavLinks = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawFailedNavLinks = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawClusters = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawOctree = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawOctreeDetails = 0x519 // uint8_t (Size: 0x1)
RecastNavMesh.bDrawMarkedForbiddenPolys = 0x51a // uint8_t (Size: 0x1)
RecastNavMesh.bDistinctlyDrawTilesBeingBuilt = 0x51a // uint8_t (Size: 0x1)
RecastNavMesh.DrawOffset = 0x51c // float (Size: 0x4)
RecastNavMesh.bFixedTilePoolSize = 0x520 // uint8_t (Size: 0x1)
RecastNavMesh.TilePoolSize = 0x524 // int32_t (Size: 0x4)
RecastNavMesh.TileSizeUU = 0x528 // float (Size: 0x4)
RecastNavMesh.CellSize = 0x52c // float (Size: 0x4)
RecastNavMesh.CellHeight = 0x530 // float (Size: 0x4)
RecastNavMesh.AgentRadius = 0x534 // float (Size: 0x4)
RecastNavMesh.AgentHeight = 0x538 // float (Size: 0x4)
RecastNavMesh.AgentMaxSlope = 0x53c // float (Size: 0x4)
RecastNavMesh.AgentMaxStepHeight = 0x540 // float (Size: 0x4)
RecastNavMesh.MinRegionArea = 0x544 // float (Size: 0x4)
RecastNavMesh.MergeRegionSize = 0x548 // float (Size: 0x4)
RecastNavMesh.MaxSimplificationError = 0x54c // float (Size: 0x4)
RecastNavMesh.MaxSimultaneousTileGenerationJobsCount = 0x550 // int32_t (Size: 0x4)
RecastNavMesh.TileNumberHardLimit = 0x554 // int32_t (Size: 0x4)
RecastNavMesh.PolyRefTileBits = 0x558 // int32_t (Size: 0x4)
RecastNavMesh.PolyRefNavPolyBits = 0x55c // int32_t (Size: 0x4)
RecastNavMesh.PolyRefSaltBits = 0x560 // int32_t (Size: 0x4)
RecastNavMesh.NavMeshOriginOffset = 0x564 // FVector (Size: 0xc)
RecastNavMesh.DefaultDrawDistance = 0x570 // float (Size: 0x4)
RecastNavMesh.DefaultMaxSearchNodes = 0x574 // float (Size: 0x4)
RecastNavMesh.DefaultMaxHierarchicalSearchNodes = 0x578 // float (Size: 0x4)
RecastNavMesh.RegionPartitioning = 0x57c // uint8_t (Size: 0x1)
RecastNavMesh.LayerPartitioning = 0x57d // uint8_t (Size: 0x1)
RecastNavMesh.RegionChunkSplits = 0x580 // int32_t (Size: 0x4)
RecastNavMesh.LayerChunkSplits = 0x584 // int32_t (Size: 0x4)
RecastNavMesh.bSortNavigationAreasByCost = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bPerformVoxelFiltering = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bMarkLowHeightAreas = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bUseExtraTopCellWhenMarkingAreas = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bFilterLowSpanSequences = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bFilterLowSpanFromTileCache = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bDoFullyAsyncNavDataGathering = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bUseBetterOffsetsFromCorners = 0x588 // uint8_t (Size: 0x1)
RecastNavMesh.bStoreEmptyTileLayers = 0x589 // uint8_t (Size: 0x1)
RecastNavMesh.bUseVirtualFilters = 0x589 // uint8_t (Size: 0x1)
RecastNavMesh.bAllowNavLinkAsPathEnd = 0x589 // uint8_t (Size: 0x1)
RecastNavMesh.bUseVoxelCache = 0x589 // uint8_t (Size: 0x1)
RecastNavMesh.TileSetUpdateInterval = 0x58c // float (Size: 0x4)
RecastNavMesh.HeuristicScale = 0x590 // float (Size: 0x4)
RecastNavMesh.VerticalDeviationFromGroundCompensation = 0x594 // float (Size: 0x4)
RecastNavMeshGenerationProperties.TilePoolSize = 0x0 // int32_t (Size: 0x4)
RecastNavMeshGenerationProperties.TileSizeUU = 0x4 // float (Size: 0x4)
RecastNavMeshGenerationProperties.CellSize = 0x8 // float (Size: 0x4)
RecastNavMeshGenerationProperties.CellHeight = 0xc // float (Size: 0x4)
RecastNavMeshGenerationProperties.AgentRadius = 0x10 // float (Size: 0x4)
RecastNavMeshGenerationProperties.AgentHeight = 0x14 // float (Size: 0x4)
RecastNavMeshGenerationProperties.AgentMaxSlope = 0x18 // float (Size: 0x4)
RecastNavMeshGenerationProperties.AgentMaxStepHeight = 0x1c // float (Size: 0x4)
RecastNavMeshGenerationProperties.MinRegionArea = 0x20 // float (Size: 0x4)
RecastNavMeshGenerationProperties.MergeRegionSize = 0x24 // float (Size: 0x4)
RecastNavMeshGenerationProperties.MaxSimplificationError = 0x28 // float (Size: 0x4)
RecastNavMeshGenerationProperties.TileNumberHardLimit = 0x2c // int32_t (Size: 0x4)
RecastNavMeshGenerationProperties.RegionPartitioning = 0x30 // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.LayerPartitioning = 0x31 // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.RegionChunkSplits = 0x34 // int32_t (Size: 0x4)
RecastNavMeshGenerationProperties.LayerChunkSplits = 0x38 // int32_t (Size: 0x4)
RecastNavMeshGenerationProperties.bSortNavigationAreasByCost = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bPerformVoxelFiltering = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bMarkLowHeightAreas = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bUseExtraTopCellWhenMarkingAreas = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bFilterLowSpanSequences = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bFilterLowSpanFromTileCache = 0x3c // uint8_t (Size: 0x1)
RecastNavMeshGenerationProperties.bFixedTilePoolSize = 0x3c // uint8_t (Size: 0x1)
SupportedAreaData.AreaClassName = 0x0 // FString (Size: 0x10)
SupportedAreaData.AreaID = 0x10 // int32_t (Size: 0x4)
SupportedAreaData.AreaClass = 0x18 // ClassProperty (Size: 0x8)
NetAnalyticsAggregatorConfig.NetAnalyticsData = 0x28 // TArray<FNetAnalyticsDataConfig> (Size: 0x10)
NetAnalyticsDataConfig.DataName = 0x0 // FName (Size: 0x8)
NetAnalyticsDataConfig.bEnabled = 0x8 // bool (Size: 0x1)
BasicParticleData.position = 0x0 // FVector (Size: 0xc)
BasicParticleData.Size = 0xc // float (Size: 0x4)
BasicParticleData.Velocity = 0x10 // FVector (Size: 0xc)
MeshTriCoordinate.Tri = 0x0 // int32_t (Size: 0x4)
MeshTriCoordinate.BaryCoord = 0x4 // FVector (Size: 0xc)
MovieSceneNiagaraBoolParameterSectionTemplate.BoolChannel = 0x40 // FMovieSceneBoolChannel (Size: 0x90)
MovieSceneNiagaraColorParameterSectionTemplate.RedChannel = 0x40 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraColorParameterSectionTemplate.GreenChannel = 0xe0 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraColorParameterSectionTemplate.BlueChannel = 0x180 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraColorParameterSectionTemplate.AlphaChannel = 0x220 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraFloatParameterSectionTemplate.FloatChannel = 0x40 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraIntegerParameterSectionTemplate.IntegerChannel = 0x40 // FMovieSceneIntegerChannel (Size: 0x90)
MovieSceneNiagaraParameterSectionTemplate.Parameter = 0x20 // FNiagaraVariable (Size: 0x20)
MovieSceneNiagaraParameterTrack.Parameter = 0x88 // FNiagaraVariable (Size: 0x20)
MovieSceneNiagaraSystemSpawnSection.SectionStartBehavior = 0xe8 // EENiagaraSystemSpawnSectionStartBehavior (Size: 0x4)
MovieSceneNiagaraSystemSpawnSection.SectionEvaluateBehavior = 0xec // EENiagaraSystemSpawnSectionEvaluateBehavior (Size: 0x4)
MovieSceneNiagaraSystemSpawnSection.SectionEndBehavior = 0xf0 // EENiagaraSystemSpawnSectionEndBehavior (Size: 0x4)
MovieSceneNiagaraSystemSpawnSection.AgeUpdateMode = 0xf4 // EENiagaraAgeUpdateMode (Size: 0x1)
MovieSceneNiagaraSystemTrackImplementation.SpawnSectionStartFrame = 0x10 // FFrameNumber (Size: 0x4)
MovieSceneNiagaraSystemTrackImplementation.SpawnSectionEndFrame = 0x14 // FFrameNumber (Size: 0x4)
MovieSceneNiagaraSystemTrackImplementation.SpawnSectionStartBehavior = 0x18 // EENiagaraSystemSpawnSectionStartBehavior (Size: 0x4)
MovieSceneNiagaraSystemTrackImplementation.SpawnSectionEvaluateBehavior = 0x1c // EENiagaraSystemSpawnSectionEvaluateBehavior (Size: 0x4)
MovieSceneNiagaraSystemTrackImplementation.SpawnSectionEndBehavior = 0x20 // EENiagaraSystemSpawnSectionEndBehavior (Size: 0x4)
MovieSceneNiagaraSystemTrackImplementation.AgeUpdateMode = 0x24 // EENiagaraAgeUpdateMode (Size: 0x1)
MovieSceneNiagaraTrack.Sections = 0x78 // TArray<MovieSceneSection*> (Size: 0x10)
MovieSceneNiagaraVectorParameterSectionTemplate.VectorChannels = 0x40 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneNiagaraVectorParameterSectionTemplate.ChannelsUsed = 0x2c0 // int32_t (Size: 0x4)
MovieSceneNiagaraVectorParameterTrack.ChannelsUsed = 0xb0 // int32_t (Size: 0x4)
NCPool.FreeElements = 0x0 // TArray<FNCPoolElement> (Size: 0x10)
NCPool.InUseComponents_Auto = 0x10 // TArray<NiagaraComponent*> (Size: 0x10)
NCPool.InUseComponents_Manual = 0x20 // TArray<NiagaraComponent*> (Size: 0x10)
NCPoolElement.Component = 0x0 // NiagaraComponent* (Size: 0x8)
NDIStaticMeshSectionFilter.AllowedMaterialSlots = 0x0 // TArray<int32_t> (Size: 0x10)
NiagaraActor.NiagaraComponent = 0x310 // NiagaraComponent* (Size: 0x8)
NiagaraActor.bDestroyOnSystemFinish = 0x318 // uint8_t (Size: 0x1)
NiagaraBool.Value = 0x0 // int32_t (Size: 0x4)
NiagaraBoundParameter.Parameter = 0x0 // FNiagaraVariable (Size: 0x20)
NiagaraBoundParameter.SrcOffset = 0x20 // int32_t (Size: 0x4)
NiagaraBoundParameter.DestOffset = 0x24 // int32_t (Size: 0x4)
NiagaraCollisionEventPayload.CollisionPos = 0x0 // FVector (Size: 0xc)
NiagaraCollisionEventPayload.CollisionNormal = 0xc // FVector (Size: 0xc)
NiagaraCollisionEventPayload.CollisionVelocity = 0x18 // FVector (Size: 0xc)
NiagaraCollisionEventPayload.ParticleIndex = 0x24 // int32_t (Size: 0x4)
NiagaraCollisionEventPayload.PhysicalMaterialIndex = 0x28 // int32_t (Size: 0x4)
NiagaraCompileHashVisitorDebugInfo.Object = 0x0 // FString (Size: 0x10)
NiagaraCompileHashVisitorDebugInfo.PropertyKeys = 0x10 // TArray<FString> (Size: 0x10)
NiagaraCompileHashVisitorDebugInfo.PropertyValues = 0x20 // TArray<FString> (Size: 0x10)
NiagaraComponent.Asset = 0x5c8 // NiagaraSystem* (Size: 0x8)
NiagaraComponent.TickBehavior = 0x5d0 // EENiagaraTickBehavior (Size: 0x1)
NiagaraComponent.OverrideParameters = 0x5d8 // FNiagaraUserRedirectionParameterStore (Size: 0xc8)
NiagaraComponent.bForceSolo = 0x6a0 // uint8_t (Size: 0x1)
NiagaraComponent.bEnableGpuComputeDebug = 0x6a0 // uint8_t (Size: 0x1)
NiagaraComponent.bAutoDestroy = 0x6cc // uint8_t (Size: 0x1)
NiagaraComponent.bRenderingEnabled = 0x6cc // uint8_t (Size: 0x1)
NiagaraComponent.bAutoManageAttachment = 0x6cc // uint8_t (Size: 0x1)
NiagaraComponent.bAutoAttachWeldSimulatedBodies = 0x6cc // uint8_t (Size: 0x1)
NiagaraComponent.MaxTimeBeforeForceUpdateTransform = 0x6d0 // float (Size: 0x4)
NiagaraComponent.EmitterMaterials = 0x6d8 // TArray<FNiagaraMaterialOverride> (Size: 0x10)
NiagaraComponent.OnSystemFinished = 0x6f0 // FMulticastInlineDelegate (Size: 0x10)
NiagaraComponent.AutoAttachParent = 0x700 // TWeakObjectPtr<UObject> (Size: 0x8)
NiagaraComponent.AutoAttachSocketName = 0x708 // FName (Size: 0x8)
NiagaraComponent.AutoAttachLocationRule = 0x710 // EEAttachmentRule (Size: 0x1)
NiagaraComponent.AutoAttachRotationRule = 0x711 // EEAttachmentRule (Size: 0x1)
NiagaraComponent.AutoAttachScaleRule = 0x712 // EEAttachmentRule (Size: 0x1)
NiagaraComponentPool.WorldParticleSystemPools = 0x28 // TMap<...> (Size: 0x50)
NiagaraComponentPropertyBinding.AttributeBinding = 0x0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraComponentPropertyBinding.PropertyName = 0x58 // FName (Size: 0x8)
NiagaraComponentPropertyBinding.PropertyType = 0x60 // FNiagaraTypeDefinition (Size: 0x10)
NiagaraComponentPropertyBinding.MetadataSetterName = 0x70 // FName (Size: 0x8)
NiagaraComponentPropertyBinding.WritableValue = 0x78 // FNiagaraVariable (Size: 0x20)
NiagaraComponentRendererProperties.ComponentType = 0x80 // ClassProperty (Size: 0x8)
NiagaraComponentRendererProperties.ComponentCountLimit = 0x88 // uint32_t (Size: 0x4)
NiagaraComponentRendererProperties.EnabledBinding = 0x90 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraComponentRendererProperties.bAssignComponentsOnParticleID = 0xe8 // bool (Size: 0x1)
NiagaraComponentRendererProperties.bOnlyCreateComponentsOnParticleSpawn = 0xe9 // bool (Size: 0x1)
NiagaraComponentRendererProperties.TemplateComponent = 0xf0 // SceneComponent* (Size: 0x8)
NiagaraComponentRendererProperties.PropertyBindings = 0xf8 // TArray<FNiagaraComponentPropertyBinding> (Size: 0x10)
NiagaraComponentSettings.SuppressActivationList = 0x28 // TSet<...> (Size: 0x50)
NiagaraComponentSettings.ForceAutoPooolingList = 0x78 // TSet<...> (Size: 0x50)
NiagaraComponentSettings.SuppressEmitterList = 0xc8 // TSet<...> (Size: 0x50)
NiagaraDataInterface2DArrayTexture.Texture = 0x38 // Texture2DArray* (Size: 0x8)
NiagaraDataInterfaceArray.MaxElements = 0x40 // int32_t (Size: 0x4)
NiagaraDataInterfaceArrayBool.BoolData = 0x50 // TArray<bool> (Size: 0x10)
NiagaraDataInterfaceArrayColor.ColorData = 0x50 // TArray<FLinearColor> (Size: 0x10)
NiagaraDataInterfaceArrayFloat.FloatData = 0x50 // TArray<float> (Size: 0x10)
NiagaraDataInterfaceArrayFloat2.FloatData = 0x50 // TArray<FVector2D> (Size: 0x10)
NiagaraDataInterfaceArrayFloat3.FloatData = 0x50 // TArray<FVector> (Size: 0x10)
NiagaraDataInterfaceArrayFloat4.FloatData = 0x50 // TArray<FVector4> (Size: 0x10)
NiagaraDataInterfaceArrayInt32.IntData = 0x50 // TArray<int32_t> (Size: 0x10)
NiagaraDataInterfaceArrayQuat.QuatData = 0x50 // TArray<FQuat> (Size: 0x10)
NiagaraDataInterfaceAudioOscilloscope.Submix = 0x38 // SoundSubmix* (Size: 0x8)
NiagaraDataInterfaceAudioOscilloscope.Resolution = 0x40 // int32_t (Size: 0x4)
NiagaraDataInterfaceAudioOscilloscope.ScopeInMilliseconds = 0x44 // float (Size: 0x4)
NiagaraDataInterfaceAudioPlayer.SoundToPlay = 0x38 // SoundBase* (Size: 0x8)
NiagaraDataInterfaceAudioPlayer.Attenuation = 0x40 // SoundAttenuation* (Size: 0x8)
NiagaraDataInterfaceAudioPlayer.Concurrency = 0x48 // SoundConcurrency* (Size: 0x8)
NiagaraDataInterfaceAudioPlayer.ParameterNames = 0x50 // TArray<FName> (Size: 0x10)
NiagaraDataInterfaceAudioPlayer.bLimitPlaysPerTick = 0x60 // bool (Size: 0x1)
NiagaraDataInterfaceAudioPlayer.MaxPlaysPerTick = 0x64 // int32_t (Size: 0x4)
NiagaraDataInterfaceAudioPlayer.bStopWhenComponentIsDestroyed = 0x68 // bool (Size: 0x1)
NiagaraDataInterfaceAudioSpectrum.Resolution = 0x40 // int32_t (Size: 0x4)
NiagaraDataInterfaceAudioSpectrum.MinimumFrequency = 0x44 // float (Size: 0x4)
NiagaraDataInterfaceAudioSpectrum.MaximumFrequency = 0x48 // float (Size: 0x4)
NiagaraDataInterfaceAudioSpectrum.NoiseFloorDb = 0x4c // float (Size: 0x4)
NiagaraDataInterfaceAudioSubmix.Submix = 0x38 // SoundSubmix* (Size: 0x8)
NiagaraDataInterfaceCamera.PlayerControllerIndex = 0x38 // int32_t (Size: 0x4)
NiagaraDataInterfaceCamera.bRequireCurrentFrameData = 0x3c // bool (Size: 0x1)
NiagaraDataInterfaceColorCurve.RedCurve = 0x70 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceColorCurve.GreenCurve = 0xf0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceColorCurve.BlueCurve = 0x170 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceColorCurve.AlphaCurve = 0x1f0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceCurlNoise.Seed = 0x38 // uint32_t (Size: 0x4)
NiagaraDataInterfaceCurve.Curve = 0x70 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceCurveBase.ShaderLUT = 0x38 // TArray<float> (Size: 0x10)
NiagaraDataInterfaceCurveBase.LUTMinTime = 0x48 // float (Size: 0x4)
NiagaraDataInterfaceCurveBase.LUTMaxTime = 0x4c // float (Size: 0x4)
NiagaraDataInterfaceCurveBase.LUTInvTimeRange = 0x50 // float (Size: 0x4)
NiagaraDataInterfaceCurveBase.LUTNumSamplesMinusOne = 0x54 // float (Size: 0x4)
NiagaraDataInterfaceCurveBase.bUseLUT = 0x58 // uint8_t (Size: 0x1)
NiagaraDataInterfaceCurveBase.bExposeCurve = 0x58 // uint8_t (Size: 0x1)
NiagaraDataInterfaceCurveBase.ExposedName = 0x5c // FName (Size: 0x8)
NiagaraDataInterfaceCurveBase.ExposedTexture = 0x68 // Texture2D* (Size: 0x8)
NiagaraDataInterfaceExport.CallbackHandlerParameter = 0x38 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceExport.GPUAllocationMode = 0x58 // EENDIExport_GPUAllocationMode (Size: 0x1)
NiagaraDataInterfaceExport.GPUAllocationFixedSize = 0x5c // int32_t (Size: 0x4)
NiagaraDataInterfaceExport.GPUAllocationPerParticleSize = 0x60 // float (Size: 0x4)
NiagaraDataInterfaceGrid2D.NumCellsX = 0xd8 // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid2D.NumCellsY = 0xdc // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid2D.NumCellsMaxAxis = 0xe0 // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid2D.NumAttributes = 0xe4 // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid2D.SetGridFromMaxAxis = 0xe8 // bool (Size: 0x1)
NiagaraDataInterfaceGrid2D.WorldBBoxSize = 0xec // FVector2D (Size: 0x8)
NiagaraDataInterfaceGrid2DCollection.RenderTargetUserParameter = 0xf8 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceGrid2DCollection.OverrideBufferFormat = 0x118 // EENiagaraGpuBufferFormat (Size: 0x1)
NiagaraDataInterfaceGrid2DCollection.bOverrideFormat = 0x119 // uint8_t (Size: 0x1)
NiagaraDataInterfaceGrid2DCollection.ManagedRenderTargets = 0x170 // TMap<...> (Size: 0x50)
NiagaraDataInterfaceGrid2DCollectionReader.EmitterName = 0xf8 // FString (Size: 0x10)
NiagaraDataInterfaceGrid2DCollectionReader.DIName = 0x108 // FString (Size: 0x10)
NiagaraDataInterfaceGrid3D.NumCells = 0xd8 // FIntVector (Size: 0xc)
NiagaraDataInterfaceGrid3D.CellSize = 0xe4 // float (Size: 0x4)
NiagaraDataInterfaceGrid3D.NumCellsMaxAxis = 0xe8 // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid3D.SetResolutionMethod = 0xec // EESetResolutionMethod (Size: 0x4)
NiagaraDataInterfaceGrid3D.WorldBBoxSize = 0xf0 // FVector (Size: 0xc)
NiagaraDataInterfaceGrid3DCollection.NumAttributes = 0x100 // int32_t (Size: 0x4)
NiagaraDataInterfaceGrid3DCollection.RenderTargetUserParameter = 0x108 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceGrid3DCollection.BufferFormat = 0x128 // EENiagaraGpuBufferFormat (Size: 0x1)
NiagaraDataInterfaceLandscape.SourceLandscape = 0x38 // Actor* (Size: 0x8)
NiagaraDataInterfaceNeighborGrid3D.MaxNeighborsPerCell = 0x100 // uint32_t (Size: 0x4)
NiagaraDataInterfaceParticleRead.EmitterName = 0xd8 // FString (Size: 0x10)
NiagaraDataInterfacePlatformSet.Platforms = 0x38 // FNiagaraPlatformSet (Size: 0x30)
NiagaraDataInterfaceRWBase.OutputShaderStages = 0x38 // TSet<...> (Size: 0x50)
NiagaraDataInterfaceRWBase.IterationShaderStages = 0x88 // TSet<...> (Size: 0x50)
NiagaraDataInterfaceRenderTarget2D.Size = 0xd8 // FIntPoint (Size: 0x8)
NiagaraDataInterfaceRenderTarget2D.OverrideRenderTargetFormat = 0xe0 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTarget2D.bOverrideFormat = 0xe1 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTarget2D.RenderTargetUserParameter = 0xe8 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceRenderTarget2D.ManagedRenderTargets = 0x108 // TMap<...> (Size: 0x50)
NiagaraDataInterfaceRenderTarget2DArray.Size = 0xd8 // FIntVector (Size: 0xc)
NiagaraDataInterfaceRenderTarget2DArray.OverrideRenderTargetFormat = 0xe4 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTarget2DArray.bOverrideFormat = 0xe5 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTarget2DArray.RenderTargetUserParameter = 0xe8 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceRenderTarget2DArray.ManagedRenderTargets = 0x108 // TMap<...> (Size: 0x50)
NiagaraDataInterfaceRenderTargetVolume.Size = 0xd8 // FIntVector (Size: 0xc)
NiagaraDataInterfaceRenderTargetVolume.OverrideRenderTargetFormat = 0xe4 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTargetVolume.bOverrideFormat = 0xe5 // uint8_t (Size: 0x1)
NiagaraDataInterfaceRenderTargetVolume.RenderTargetUserParameter = 0xe8 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceRenderTargetVolume.ManagedRenderTargets = 0x108 // TMap<...> (Size: 0x50)
NiagaraDataInterfaceSkeletalMesh.SourceMode = 0x38 // EENDISkeletalMesh_SourceMode (Size: 0x1)
NiagaraDataInterfaceSkeletalMesh.Source = 0x40 // Actor* (Size: 0x8)
NiagaraDataInterfaceSkeletalMesh.MeshUserParameter = 0x48 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraDataInterfaceSkeletalMesh.SourceComponent = 0x68 // SkeletalMeshComponent* (Size: 0x8)
NiagaraDataInterfaceSkeletalMesh.SkinningMode = 0x70 // EENDISkeletalMesh_SkinningMode (Size: 0x1)
NiagaraDataInterfaceSkeletalMesh.SamplingRegions = 0x78 // TArray<FName> (Size: 0x10)
NiagaraDataInterfaceSkeletalMesh.WholeMeshLOD = 0x88 // int32_t (Size: 0x4)
NiagaraDataInterfaceSkeletalMesh.FilteredBones = 0x90 // TArray<FName> (Size: 0x10)
NiagaraDataInterfaceSkeletalMesh.FilteredSockets = 0xa0 // TArray<FName> (Size: 0x10)
NiagaraDataInterfaceSkeletalMesh.ExcludeBoneName = 0xb0 // FName (Size: 0x8)
NiagaraDataInterfaceSkeletalMesh.bExcludeBone = 0xb8 // uint8_t (Size: 0x1)
NiagaraDataInterfaceSkeletalMesh.bRequireCurrentFrameData = 0xb9 // bool (Size: 0x1)
NiagaraDataInterfaceSpline.Source = 0x38 // Actor* (Size: 0x8)
NiagaraDataInterfaceStaticMesh.SourceMode = 0x38 // EENDIStaticMesh_SourceMode (Size: 0x1)
NiagaraDataInterfaceStaticMesh.DefaultMesh = 0x40 // StaticMesh* (Size: 0x8)
NiagaraDataInterfaceStaticMesh.Source = 0x48 // Actor* (Size: 0x8)
NiagaraDataInterfaceStaticMesh.SourceComponent = 0x50 // StaticMeshComponent* (Size: 0x8)
NiagaraDataInterfaceStaticMesh.SectionFilter = 0x58 // FNDIStaticMeshSectionFilter (Size: 0x10)
NiagaraDataInterfaceStaticMesh.bUsePhysicsBodyVelocity = 0x68 // bool (Size: 0x1)
NiagaraDataInterfaceStaticMesh.FilteredSockets = 0x70 // TArray<FName> (Size: 0x10)
NiagaraDataInterfaceTexture.Texture = 0x38 // Texture* (Size: 0x8)
NiagaraDataInterfaceVector2DCurve.XCurve = 0x70 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVector2DCurve.YCurve = 0xf0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVector4Curve.XCurve = 0x70 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVector4Curve.YCurve = 0xf0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVector4Curve.ZCurve = 0x170 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVector4Curve.WCurve = 0x1f0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVectorCurve.XCurve = 0x70 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVectorCurve.YCurve = 0xf0 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVectorCurve.ZCurve = 0x170 // FRichCurve (Size: 0x80)
NiagaraDataInterfaceVectorField.Field = 0x38 // VectorField* (Size: 0x8)
NiagaraDataInterfaceVectorField.bTileX = 0x40 // bool (Size: 0x1)
NiagaraDataInterfaceVectorField.bTileY = 0x41 // bool (Size: 0x1)
NiagaraDataInterfaceVectorField.bTileZ = 0x42 // bool (Size: 0x1)
NiagaraDataInterfaceVolumeTexture.Texture = 0x38 // VolumeTexture* (Size: 0x8)
NiagaraDataSetCompiledData.Variables = 0x0 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraDataSetCompiledData.VariableLayouts = 0x10 // TArray<FNiagaraVariableLayoutInfo> (Size: 0x10)
NiagaraDataSetCompiledData.ID = 0x20 // FNiagaraDataSetID (Size: 0xc)
NiagaraDataSetCompiledData.TotalFloatComponents = 0x2c // uint32_t (Size: 0x4)
NiagaraDataSetCompiledData.TotalInt32Components = 0x30 // uint32_t (Size: 0x4)
NiagaraDataSetCompiledData.TotalHalfComponents = 0x34 // uint32_t (Size: 0x4)
NiagaraDataSetCompiledData.bRequiresPersistentIDs = 0x38 // uint8_t (Size: 0x1)
NiagaraDataSetCompiledData.SimTarget = 0x3c // EENiagaraSimTarget (Size: 0x1)
NiagaraDataSetID.Name = 0x0 // FName (Size: 0x8)
NiagaraDataSetID.Type = 0x8 // EENiagaraDataSetType (Size: 0x1)
NiagaraDataSetProperties.ID = 0x0 // FNiagaraDataSetID (Size: 0xc)
NiagaraDataSetProperties.Variables = 0x10 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraDetailsLevelScaleOverrides.Low = 0x0 // float (Size: 0x4)
NiagaraDetailsLevelScaleOverrides.Medium = 0x4 // float (Size: 0x4)
NiagaraDetailsLevelScaleOverrides.High = 0x8 // float (Size: 0x4)
NiagaraDetailsLevelScaleOverrides.Epic = 0xc // float (Size: 0x4)
NiagaraDetailsLevelScaleOverrides.Cine = 0x10 // float (Size: 0x4)
NiagaraDeviceProfileStateEntry.ProfileName = 0x0 // FName (Size: 0x8)
NiagaraDeviceProfileStateEntry.QualityLevelMask = 0x8 // uint32_t (Size: 0x4)
NiagaraDeviceProfileStateEntry.SetQualityLevelMask = 0xc // uint32_t (Size: 0x4)
NiagaraEffectType.UpdateFrequency = 0x28 // EENiagaraScalabilityUpdateFrequency (Size: 0x4)
NiagaraEffectType.CullReaction = 0x2c // EENiagaraCullReaction (Size: 0x4)
NiagaraEffectType.SignificanceHandler = 0x30 // NiagaraSignificanceHandler* (Size: 0x8)
NiagaraEffectType.DetailLevelScalabilitySettings = 0x38 // TArray<FNiagaraSystemScalabilitySettings> (Size: 0x10)
NiagaraEffectType.SystemScalabilitySettings = 0x48 // FNiagaraSystemScalabilitySettingsArray (Size: 0x10)
NiagaraEffectType.EmitterScalabilitySettings = 0x58 // FNiagaraEmitterScalabilitySettingsArray (Size: 0x10)
NiagaraEmitter.bLocalSpace = 0x28 // bool (Size: 0x1)
NiagaraEmitter.bDeterminism = 0x29 // bool (Size: 0x1)
NiagaraEmitter.RandomSeed = 0x2c // int32_t (Size: 0x4)
NiagaraEmitter.AllocationMode = 0x30 // EEParticleAllocationMode (Size: 0x1)
NiagaraEmitter.PreAllocationCount = 0x34 // int32_t (Size: 0x4)
NiagaraEmitter.UpdateScriptProps = 0x38 // FNiagaraEmitterScriptProperties (Size: 0x28)
NiagaraEmitter.SpawnScriptProps = 0x60 // FNiagaraEmitterScriptProperties (Size: 0x28)
NiagaraEmitter.SimTarget = 0x88 // EENiagaraSimTarget (Size: 0x1)
NiagaraEmitter.FixedBounds = 0x8c // FBox (Size: 0x1c)
NiagaraEmitter.MinDetailLevel = 0xa8 // int32_t (Size: 0x4)
NiagaraEmitter.MaxDetailLevel = 0xac // int32_t (Size: 0x4)
NiagaraEmitter.GlobalSpawnCountScaleOverrides = 0xb0 // FNiagaraDetailsLevelScaleOverrides (Size: 0x14)
NiagaraEmitter.Platforms = 0xc8 // FNiagaraPlatformSet (Size: 0x30)
NiagaraEmitter.ScalabilityOverrides = 0xf8 // FNiagaraEmitterScalabilityOverrides (Size: 0x10)
NiagaraEmitter.bInterpolatedSpawning = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bFixedBounds = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bUseMinDetailLevel = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bUseMaxDetailLevel = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bOverrideGlobalSpawnCountScale = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bRequiresPersistentIDs = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.bCombineEventSpawn = 0x108 // uint8_t (Size: 0x1)
NiagaraEmitter.MaxDeltaTimePerTick = 0x10c // float (Size: 0x4)
NiagaraEmitter.DefaultShaderStageIndex = 0x110 // uint32_t (Size: 0x4)
NiagaraEmitter.MaxUpdateIterations = 0x114 // uint32_t (Size: 0x4)
NiagaraEmitter.SpawnStages = 0x118 // TSet<...> (Size: 0x50)
NiagaraEmitter.bSimulationStagesEnabled = 0x168 // uint8_t (Size: 0x1)
NiagaraEmitter.bDeprecatedShaderStagesEnabled = 0x168 // uint8_t (Size: 0x1)
NiagaraEmitter.bLimitDeltaTime = 0x168 // uint8_t (Size: 0x1)
NiagaraEmitter.UniqueEmitterName = 0x170 // FString (Size: 0x10)
NiagaraEmitter.RendererProperties = 0x180 // TArray<NiagaraRendererProperties*> (Size: 0x10)
NiagaraEmitter.EventHandlerScriptProps = 0x190 // TArray<FNiagaraEventScriptProperties> (Size: 0x10)
NiagaraEmitter.SimulationStages = 0x1a0 // TArray<NiagaraSimulationStageBase*> (Size: 0x10)
NiagaraEmitter.GPUComputeScript = 0x1b0 // NiagaraScript* (Size: 0x8)
NiagaraEmitter.SharedEventGeneratorIds = 0x1b8 // TArray<FName> (Size: 0x10)
NiagaraEmitterCompiledData.SpawnAttributes = 0x0 // TArray<FName> (Size: 0x10)
NiagaraEmitterCompiledData.EmitterSpawnIntervalVar = 0x10 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterInterpSpawnStartDTVar = 0x30 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterSpawnGroupVar = 0x50 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterAgeVar = 0x70 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterRandomSeedVar = 0x90 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterInstanceSeedVar = 0xb0 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.EmitterTotalSpawnedParticlesVar = 0xd0 // FNiagaraVariable (Size: 0x20)
NiagaraEmitterCompiledData.DataSetCompiledData = 0xf0 // FNiagaraDataSetCompiledData (Size: 0x40)
NiagaraEmitterHandle.ID = 0x0 // FGuid (Size: 0x10)
NiagaraEmitterHandle.IdName = 0x10 // FName (Size: 0x8)
NiagaraEmitterHandle.bIsEnabled = 0x18 // bool (Size: 0x1)
NiagaraEmitterHandle.Name = 0x1c // FName (Size: 0x8)
NiagaraEmitterHandle.Instance = 0x28 // NiagaraEmitter* (Size: 0x8)
NiagaraEmitterNameSettingsRef.SystemName = 0x0 // FName (Size: 0x8)
NiagaraEmitterNameSettingsRef.EmitterName = 0x8 // FString (Size: 0x10)
NiagaraEmitterScalabilityOverride.bOverrideSpawnCountScale = 0x38 // uint8_t (Size: 0x1)
NiagaraEmitterScalabilityOverrides.Overrides = 0x0 // TArray<FNiagaraEmitterScalabilityOverride> (Size: 0x10)
NiagaraEmitterScalabilitySettings.Platforms = 0x0 // FNiagaraPlatformSet (Size: 0x30)
NiagaraEmitterScalabilitySettings.bScaleSpawnCount = 0x30 // uint8_t (Size: 0x1)
NiagaraEmitterScalabilitySettings.SpawnCountScale = 0x34 // float (Size: 0x4)
NiagaraEmitterScalabilitySettingsArray.Settings = 0x0 // TArray<FNiagaraEmitterScalabilitySettings> (Size: 0x10)
NiagaraEmitterScriptProperties.Script = 0x0 // NiagaraScript* (Size: 0x8)
NiagaraEmitterScriptProperties.EventReceivers = 0x8 // TArray<FNiagaraEventReceiverProperties> (Size: 0x10)
NiagaraEmitterScriptProperties.EventGenerators = 0x18 // TArray<FNiagaraEventGeneratorProperties> (Size: 0x10)
NiagaraEventGeneratorProperties.MaxEventsPerFrame = 0x0 // int32_t (Size: 0x4)
NiagaraEventGeneratorProperties.ID = 0x4 // FName (Size: 0x8)
NiagaraEventGeneratorProperties.DataSetCompiledData = 0x10 // FNiagaraDataSetCompiledData (Size: 0x40)
NiagaraEventReceiverEmitterAction_SpawnParticles.NumParticles = 0x28 // uint32_t (Size: 0x4)
NiagaraEventReceiverProperties.Name = 0x0 // FName (Size: 0x8)
NiagaraEventReceiverProperties.SourceEventGenerator = 0x8 // FName (Size: 0x8)
NiagaraEventReceiverProperties.SourceEmitter = 0x10 // FName (Size: 0x8)
NiagaraEventScriptProperties.ExecutionMode = 0x28 // EEScriptExecutionMode (Size: 0x1)
NiagaraEventScriptProperties.SpawnNumber = 0x2c // uint32_t (Size: 0x4)
NiagaraEventScriptProperties.MaxEventsPerFrame = 0x30 // uint32_t (Size: 0x4)
NiagaraEventScriptProperties.SourceEmitterID = 0x34 // FGuid (Size: 0x10)
NiagaraEventScriptProperties.SourceEventName = 0x44 // FName (Size: 0x8)
NiagaraEventScriptProperties.bRandomSpawnNumber = 0x4c // bool (Size: 0x1)
NiagaraEventScriptProperties.MinSpawnNumber = 0x50 // uint32_t (Size: 0x4)
NiagaraFloat.Value = 0x0 // float (Size: 0x4)
NiagaraFunctionSignature.Name = 0x0 // FName (Size: 0x8)
NiagaraFunctionSignature.Inputs = 0x8 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraFunctionSignature.Outputs = 0x18 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraFunctionSignature.OwnerName = 0x28 // FName (Size: 0x8)
NiagaraFunctionSignature.bRequiresContext = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bRequiresExecPin = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bMemberFunction = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bExperimental = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bSupportsCPU = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bSupportsGPU = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bWriteFunction = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.bSoftDeprecatedFunction = 0x30 // uint8_t (Size: 0x1)
NiagaraFunctionSignature.ModuleUsageBitmask = 0x34 // int32_t (Size: 0x4)
NiagaraFunctionSignature.ContextStageMinIndex = 0x38 // int32_t (Size: 0x4)
NiagaraFunctionSignature.ContextStageMaxIndex = 0x3c // int32_t (Size: 0x4)
NiagaraFunctionSignature.FunctionSpecifiers = 0x40 // TMap<...> (Size: 0x50)
NiagaraGraphViewSettings.Location = 0x0 // FVector2D (Size: 0x8)
NiagaraGraphViewSettings.Zoom = 0x8 // float (Size: 0x4)
NiagaraGraphViewSettings.bIsValid = 0xc // bool (Size: 0x1)
NiagaraHalf.Value = 0x0 // uint16_t (Size: 0x2)
NiagaraHalfVector2.X = 0x0 // uint16_t (Size: 0x2)
NiagaraHalfVector2.Y = 0x2 // uint16_t (Size: 0x2)
NiagaraHalfVector3.X = 0x0 // uint16_t (Size: 0x2)
NiagaraHalfVector3.Y = 0x2 // uint16_t (Size: 0x2)
NiagaraHalfVector3.Z = 0x4 // uint16_t (Size: 0x2)
NiagaraHalfVector4.X = 0x0 // uint16_t (Size: 0x2)
NiagaraHalfVector4.Y = 0x2 // uint16_t (Size: 0x2)
NiagaraHalfVector4.Z = 0x4 // uint16_t (Size: 0x2)
NiagaraHalfVector4.W = 0x6 // uint16_t (Size: 0x2)
NiagaraID.Index = 0x0 // int32_t (Size: 0x4)
NiagaraID.AcquireTag = 0x4 // int32_t (Size: 0x4)
NiagaraInputConditionMetadata.InputName = 0x0 // FName (Size: 0x8)
NiagaraInputConditionMetadata.TargetValues = 0x8 // TArray<FString> (Size: 0x10)
NiagaraInt32.Value = 0x0 // int32_t (Size: 0x4)
NiagaraLightRendererProperties.bUseInverseSquaredFalloff = 0x80 // uint8_t (Size: 0x1)
NiagaraLightRendererProperties.bAffectsTranslucency = 0x80 // uint8_t (Size: 0x1)
NiagaraLightRendererProperties.RadiusScale = 0x84 // float (Size: 0x4)
NiagaraLightRendererProperties.ColorAdd = 0x88 // FVector (Size: 0xc)
NiagaraLightRendererProperties.LightRenderingEnabledBinding = 0x98 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraLightRendererProperties.LightExponentBinding = 0xf0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraLightRendererProperties.PositionBinding = 0x148 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraLightRendererProperties.ColorBinding = 0x1a0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraLightRendererProperties.RadiusBinding = 0x1f8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraLightRendererProperties.VolumetricScatteringBinding = 0x250 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMaterialAttributeBinding.MaterialParameterName = 0x0 // FName (Size: 0x8)
NiagaraMaterialAttributeBinding.NiagaraVariable = 0x8 // FNiagaraVariableBase (Size: 0xc)
NiagaraMaterialAttributeBinding.ResolvedNiagaraVariable = 0x14 // FNiagaraVariableBase (Size: 0xc)
NiagaraMaterialAttributeBinding.NiagaraChildVariable = 0x20 // FNiagaraVariableBase (Size: 0xc)
NiagaraMaterialOverride.Material = 0x0 // MaterialInterface* (Size: 0x8)
NiagaraMaterialOverride.MaterialSubIndex = 0x8 // uint32_t (Size: 0x4)
NiagaraMaterialOverride.EmitterRendererProperty = 0x10 // NiagaraRendererProperties* (Size: 0x8)
NiagaraMatrix.Row0 = 0x0 // FVector4 (Size: 0x10)
NiagaraMatrix.Row1 = 0x10 // FVector4 (Size: 0x10)
NiagaraMatrix.Row2 = 0x20 // FVector4 (Size: 0x10)
NiagaraMatrix.Row3 = 0x30 // FVector4 (Size: 0x10)
NiagaraMeshMaterialOverride.ExplicitMat = 0x0 // MaterialInterface* (Size: 0x8)
NiagaraMeshMaterialOverride.UserParamBinding = 0x8 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraMeshRendererProperties.ParticleMesh = 0x80 // StaticMesh* (Size: 0x8)
NiagaraMeshRendererProperties.SortMode = 0x88 // EENiagaraSortMode (Size: 0x1)
NiagaraMeshRendererProperties.bOverrideMaterials = 0x8c // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.bSortOnlyWhenTranslucent = 0x8c // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.OverrideMaterials = 0x90 // TArray<FNiagaraMeshMaterialOverride> (Size: 0x10)
NiagaraMeshRendererProperties.SubImageSize = 0xa0 // FVector2D (Size: 0x8)
NiagaraMeshRendererProperties.bSubImageBlend = 0xa8 // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.FacingMode = 0xac // EENiagaraMeshFacingMode (Size: 0x1)
NiagaraMeshRendererProperties.bLockedAxisEnable = 0xb0 // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.LockedAxis = 0xb4 // FVector (Size: 0xc)
NiagaraMeshRendererProperties.LockedAxisSpace = 0xc0 // EENiagaraMeshLockedAxisSpace (Size: 0x1)
NiagaraMeshRendererProperties.PivotOffset = 0xc4 // FVector (Size: 0xc)
NiagaraMeshRendererProperties.PivotOffsetSpace = 0xd0 // EENiagaraMeshPivotOffsetSpace (Size: 0x1)
NiagaraMeshRendererProperties.bEnableFrustumCulling = 0xd4 // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.bEnableCameraDistanceCulling = 0xd4 // uint8_t (Size: 0x1)
NiagaraMeshRendererProperties.MinCameraDistance = 0xd8 // float (Size: 0x4)
NiagaraMeshRendererProperties.MaxCameraDistance = 0xdc // float (Size: 0x4)
NiagaraMeshRendererProperties.RendererVisibility = 0xe0 // uint32_t (Size: 0x4)
NiagaraMeshRendererProperties.PositionBinding = 0xe8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.ColorBinding = 0x140 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.VelocityBinding = 0x198 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.MeshOrientationBinding = 0x1f0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.ScaleBinding = 0x248 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.SubImageIndexBinding = 0x2a0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.DynamicMaterialBinding = 0x2f8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.DynamicMaterial1Binding = 0x350 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.DynamicMaterial2Binding = 0x3a8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.DynamicMaterial3Binding = 0x400 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.MaterialRandomBinding = 0x458 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.CustomSortingBinding = 0x4b0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.NormalizedAgeBinding = 0x508 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.CameraOffsetBinding = 0x560 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraMeshRendererProperties.RendererVisibilityTagBinding = 0x5b8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraModuleDependency.ID = 0x0 // FName (Size: 0x8)
NiagaraModuleDependency.Type = 0x8 // EENiagaraModuleDependencyType (Size: 0x1)
NiagaraModuleDependency.ScriptConstraint = 0x9 // EENiagaraModuleDependencyScriptConstraint (Size: 0x1)
NiagaraModuleDependency.Description = 0x10 // FText (Size: 0x18)
NiagaraParameterCollection.Namespace = 0x28 // FName (Size: 0x8)
NiagaraParameterCollection.Parameters = 0x30 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraParameterCollection.SourceMaterialCollection = 0x40 // MaterialParameterCollection* (Size: 0x8)
NiagaraParameterCollection.DefaultInstance = 0x48 // NiagaraParameterCollectionInstance* (Size: 0x8)
NiagaraParameterCollection.CompileId = 0x50 // FGuid (Size: 0x10)
NiagaraParameterCollectionInstance.Collection = 0x28 // NiagaraParameterCollection* (Size: 0x8)
NiagaraParameterCollectionInstance.OverridenParameters = 0x30 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraParameterCollectionInstance.ParameterStorage = 0x40 // FNiagaraParameterStore (Size: 0x78)
NiagaraParameterDataSetBinding.ParameterOffset = 0x0 // int32_t (Size: 0x4)
NiagaraParameterDataSetBinding.DataSetComponentOffset = 0x4 // int32_t (Size: 0x4)
NiagaraParameterDataSetBindingCollection.FloatOffsets = 0x0 // TArray<FNiagaraParameterDataSetBinding> (Size: 0x10)
NiagaraParameterDataSetBindingCollection.Int32Offsets = 0x10 // TArray<FNiagaraParameterDataSetBinding> (Size: 0x10)
NiagaraParameterScopeInfo.Scope = 0x0 // EENiagaraParameterScope (Size: 0x4)
NiagaraParameterScopeInfo.NamespaceString = 0x8 // FString (Size: 0x10)
NiagaraParameterStore.Owner = 0x8 // Object* (Size: 0x8)
NiagaraParameterStore.SortedParameterOffsets = 0x10 // TArray<FNiagaraVariableWithOffset> (Size: 0x10)
NiagaraParameterStore.ParameterData = 0x20 // TArray<uint8_t> (Size: 0x10)
NiagaraParameterStore.DataInterfaces = 0x30 // TArray<NiagaraDataInterface*> (Size: 0x10)
NiagaraParameterStore.UObjects = 0x40 // TArray<Object*> (Size: 0x10)
NiagaraParameters.Parameters = 0x0 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraPlatformSet.QualityLevelMask = 0x0 // int32_t (Size: 0x4)
NiagaraPlatformSet.DeviceProfileStates = 0x8 // TArray<FNiagaraDeviceProfileStateEntry> (Size: 0x10)
NiagaraPlatformSet.CVarConditions = 0x18 // TArray<FNiagaraPlatformSetCVarCondition> (Size: 0x10)
NiagaraPlatformSetCVarCondition.CVarName = 0x0 // FName (Size: 0x8)
NiagaraPlatformSetCVarCondition.Value = 0x8 // bool (Size: 0x1)
NiagaraPlatformSetCVarCondition.MinInt = 0xc // int32_t (Size: 0x4)
NiagaraPlatformSetCVarCondition.MaxInt = 0x10 // int32_t (Size: 0x4)
NiagaraPlatformSetCVarCondition.MinFloat = 0x14 // float (Size: 0x4)
NiagaraPlatformSetCVarCondition.MaxFloat = 0x18 // float (Size: 0x4)
NiagaraPlatformSetCVarCondition.bUseMinInt = 0x1c // uint8_t (Size: 0x1)
NiagaraPlatformSetCVarCondition.bUseMaxInt = 0x1c // uint8_t (Size: 0x1)
NiagaraPlatformSetCVarCondition.bUseMinFloat = 0x1c // uint8_t (Size: 0x1)
NiagaraPlatformSetCVarCondition.bUseMaxFloat = 0x1c // uint8_t (Size: 0x1)
NiagaraPlatformSetConflictEntry.ProfileName = 0x0 // FName (Size: 0x8)
NiagaraPlatformSetConflictEntry.QualityLevelMask = 0x8 // int32_t (Size: 0x4)
NiagaraPlatformSetConflictInfo.SetAIndex = 0x0 // int32_t (Size: 0x4)
NiagaraPlatformSetConflictInfo.SetBIndex = 0x4 // int32_t (Size: 0x4)
NiagaraPlatformSetConflictInfo.Conflicts = 0x8 // TArray<FNiagaraPlatformSetConflictEntry> (Size: 0x10)
NiagaraPrecompileContainer.Scripts = 0x28 // TArray<NiagaraScript*> (Size: 0x10)
NiagaraPrecompileContainer.System = 0x38 // NiagaraSystem* (Size: 0x8)
NiagaraPreviewAxis_InterpParamBase.Param = 0x28 // FName (Size: 0x8)
NiagaraPreviewAxis_InterpParamBase.Count = 0x30 // int32_t (Size: 0x4)
NiagaraPreviewAxis_InterpParamFloat.Min = 0x38 // float (Size: 0x4)
NiagaraPreviewAxis_InterpParamFloat.Max = 0x3c // float (Size: 0x4)
NiagaraPreviewAxis_InterpParamInt32.Min = 0x38 // int32_t (Size: 0x4)
NiagaraPreviewAxis_InterpParamInt32.Max = 0x3c // int32_t (Size: 0x4)
NiagaraPreviewAxis_InterpParamLinearColor.Min = 0x38 // FLinearColor (Size: 0x10)
NiagaraPreviewAxis_InterpParamLinearColor.Max = 0x48 // FLinearColor (Size: 0x10)
NiagaraPreviewAxis_InterpParamVector.Min = 0x38 // FVector (Size: 0xc)
NiagaraPreviewAxis_InterpParamVector.Max = 0x44 // FVector (Size: 0xc)
NiagaraPreviewAxis_InterpParamVector2D.Min = 0x38 // FVector2D (Size: 0x8)
NiagaraPreviewAxis_InterpParamVector2D.Max = 0x40 // FVector2D (Size: 0x8)
NiagaraPreviewAxis_InterpParamVector4.Min = 0x40 // FVector4 (Size: 0x10)
NiagaraPreviewAxis_InterpParamVector4.Max = 0x50 // FVector4 (Size: 0x10)
NiagaraPreviewGrid.System = 0x310 // NiagaraSystem* (Size: 0x8)
NiagaraPreviewGrid.ResetMode = 0x318 // EENiagaraPreviewGridResetMode (Size: 0x1)
NiagaraPreviewGrid.PreviewAxisX = 0x320 // NiagaraPreviewAxis* (Size: 0x8)
NiagaraPreviewGrid.PreviewAxisY = 0x328 // NiagaraPreviewAxis* (Size: 0x8)
NiagaraPreviewGrid.PreviewClass = 0x330 // ClassProperty (Size: 0x8)
NiagaraPreviewGrid.SpacingX = 0x338 // float (Size: 0x4)
NiagaraPreviewGrid.SpacingY = 0x33c // float (Size: 0x4)
NiagaraPreviewGrid.NumX = 0x340 // int32_t (Size: 0x4)
NiagaraPreviewGrid.NumY = 0x344 // int32_t (Size: 0x4)
NiagaraPreviewGrid.PreviewComponents = 0x348 // TArray<ChildActorComponent*> (Size: 0x10)
NiagaraRandInfo.Seed1 = 0x0 // int32_t (Size: 0x4)
NiagaraRandInfo.Seed2 = 0x4 // int32_t (Size: 0x4)
NiagaraRandInfo.Seed3 = 0x8 // int32_t (Size: 0x4)
NiagaraRendererProperties.Platforms = 0x28 // FNiagaraPlatformSet (Size: 0x30)
NiagaraRendererProperties.SortOrderHint = 0x58 // int32_t (Size: 0x4)
NiagaraRendererProperties.bIsEnabled = 0x5c // bool (Size: 0x1)
NiagaraRendererProperties.bMotionBlurEnabled = 0x5d // bool (Size: 0x1)
NiagaraRibbonRendererProperties.Material = 0x80 // MaterialInterface* (Size: 0x8)
NiagaraRibbonRendererProperties.MaterialUserParamBinding = 0x88 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraRibbonRendererProperties.FacingMode = 0xa8 // EENiagaraRibbonFacingMode (Size: 0x1)
NiagaraRibbonRendererProperties.UV0Settings = 0xac // FNiagaraRibbonUVSettings (Size: 0x24)
NiagaraRibbonRendererProperties.UV1Settings = 0xd0 // FNiagaraRibbonUVSettings (Size: 0x24)
NiagaraRibbonRendererProperties.DrawDirection = 0xf4 // EENiagaraRibbonDrawDirection (Size: 0x1)
NiagaraRibbonRendererProperties.CurveTension = 0xf8 // float (Size: 0x4)
NiagaraRibbonRendererProperties.TessellationMode = 0xfc // EENiagaraRibbonTessellationMode (Size: 0x1)
NiagaraRibbonRendererProperties.TessellationFactor = 0x100 // int32_t (Size: 0x4)
NiagaraRibbonRendererProperties.bUseConstantFactor = 0x104 // bool (Size: 0x1)
NiagaraRibbonRendererProperties.TessellationAngle = 0x108 // float (Size: 0x4)
NiagaraRibbonRendererProperties.bScreenSpaceTessellation = 0x10c // bool (Size: 0x1)
NiagaraRibbonRendererProperties.PositionBinding = 0x110 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.ColorBinding = 0x168 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.VelocityBinding = 0x1c0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.NormalizedAgeBinding = 0x218 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.RibbonTwistBinding = 0x270 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.RibbonWidthBinding = 0x2c8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.RibbonFacingBinding = 0x320 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.RibbonIdBinding = 0x378 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.RibbonLinkOrderBinding = 0x3d0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.MaterialRandomBinding = 0x428 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.DynamicMaterialBinding = 0x480 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.DynamicMaterial1Binding = 0x4d8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.DynamicMaterial2Binding = 0x530 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.DynamicMaterial3Binding = 0x588 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.U0OverrideBinding = 0x5e0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.V0RangeOverrideBinding = 0x638 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.U1OverrideBinding = 0x690 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonRendererProperties.V1RangeOverrideBinding = 0x6e8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraRibbonUVSettings.LeadingEdgeMode = 0x0 // EENiagaraRibbonUVEdgeMode (Size: 0x4)
NiagaraRibbonUVSettings.TrailingEdgeMode = 0x4 // EENiagaraRibbonUVEdgeMode (Size: 0x4)
NiagaraRibbonUVSettings.DistributionMode = 0x8 // EENiagaraRibbonUVDistributionMode (Size: 0x4)
NiagaraRibbonUVSettings.TilingLength = 0xc // float (Size: 0x4)
NiagaraRibbonUVSettings.Offset = 0x10 // FVector2D (Size: 0x8)
NiagaraRibbonUVSettings.Scale = 0x18 // FVector2D (Size: 0x8)
NiagaraRibbonUVSettings.bEnablePerParticleUOverride = 0x20 // bool (Size: 0x1)
NiagaraRibbonUVSettings.bEnablePerParticleVRangeOverride = 0x21 // bool (Size: 0x1)
NiagaraScalabilityManager.EffectType = 0x0 // NiagaraEffectType* (Size: 0x8)
NiagaraScalabilityManager.ManagedComponents = 0x8 // TArray<NiagaraComponent*> (Size: 0x10)
NiagaraScript.Usage = 0x28 // EENiagaraScriptUsage (Size: 0x1)
NiagaraScript.UsageIndex = 0x2c // int32_t (Size: 0x4)
NiagaraScript.UsageId = 0x30 // FGuid (Size: 0x10)
NiagaraScript.RapidIterationParameters = 0x40 // FNiagaraParameterStore (Size: 0x78)
NiagaraScript.ScriptExecutionParamStore = 0xb8 // FNiagaraScriptExecutionParameterStore (Size: 0x98)
NiagaraScript.ScriptExecutionBoundParameters = 0x150 // TArray<FNiagaraBoundParameter> (Size: 0x10)
NiagaraScript.CachedScriptVMId = 0x160 // FNiagaraVMExecutableDataId (Size: 0x48)
NiagaraScript.CachedScriptVM = 0x1b8 // FNiagaraVMExecutableData (Size: 0xe0)
NiagaraScript.CachedParameterCollectionReferences = 0x298 // TArray<NiagaraParameterCollection*> (Size: 0x10)
NiagaraScript.CachedDefaultDataInterfaces = 0x2a8 // TArray<FNiagaraScriptDataInterfaceInfo> (Size: 0x10)
NiagaraScriptDataInterfaceCompileInfo.Name = 0x0 // FName (Size: 0x8)
NiagaraScriptDataInterfaceCompileInfo.UserPtrIdx = 0x8 // int32_t (Size: 0x4)
NiagaraScriptDataInterfaceCompileInfo.Type = 0x10 // FNiagaraTypeDefinition (Size: 0x10)
NiagaraScriptDataInterfaceCompileInfo.RegisteredParameterMapRead = 0x20 // FName (Size: 0x8)
NiagaraScriptDataInterfaceCompileInfo.RegisteredParameterMapWrite = 0x28 // FName (Size: 0x8)
NiagaraScriptDataInterfaceCompileInfo.bIsPlaceholder = 0x30 // bool (Size: 0x1)
NiagaraScriptDataInterfaceInfo.DataInterface = 0x0 // NiagaraDataInterface* (Size: 0x8)
NiagaraScriptDataInterfaceInfo.Name = 0x8 // FName (Size: 0x8)
NiagaraScriptDataInterfaceInfo.UserPtrIdx = 0x10 // int32_t (Size: 0x4)
NiagaraScriptDataInterfaceInfo.Type = 0x18 // FNiagaraTypeDefinition (Size: 0x10)
NiagaraScriptDataInterfaceInfo.RegisteredParameterMapRead = 0x28 // FName (Size: 0x8)
NiagaraScriptDataInterfaceInfo.RegisteredParameterMapWrite = 0x30 // FName (Size: 0x8)
NiagaraScriptDataUsageInfo.bReadsAttributeData = 0x0 // bool (Size: 0x1)
NiagaraScriptExecutionPaddingInfo.SrcOffset = 0x0 // uint16_t (Size: 0x2)
NiagaraScriptExecutionPaddingInfo.DestOffset = 0x2 // uint16_t (Size: 0x2)
NiagaraScriptExecutionPaddingInfo.SrcSize = 0x4 // uint16_t (Size: 0x2)
NiagaraScriptExecutionPaddingInfo.DestSize = 0x6 // uint16_t (Size: 0x2)
NiagaraScriptExecutionParameterStore.ParameterSize = 0x78 // int32_t (Size: 0x4)
NiagaraScriptExecutionParameterStore.PaddedParameterSize = 0x7c // uint32_t (Size: 0x4)
NiagaraScriptExecutionParameterStore.PaddingInfo = 0x80 // TArray<FNiagaraScriptExecutionPaddingInfo> (Size: 0x10)
NiagaraScriptExecutionParameterStore.bInitialized = 0x90 // uint8_t (Size: 0x1)
NiagaraScriptHighlight.Color = 0x0 // FLinearColor (Size: 0x10)
NiagaraScriptHighlight.DisplayName = 0x10 // FText (Size: 0x18)
NiagaraScriptVariableBinding.Name = 0x0 // FName (Size: 0x8)
NiagaraSettings.DefaultEffectType = 0x38 // FSoftObjectPath (Size: 0x18)
NiagaraSettings.QualityLevels = 0x50 // TArray<FText> (Size: 0x10)
NiagaraSettings.ComponentRendererWarningsPerClass = 0x60 // TMap<...> (Size: 0x50)
NiagaraSettings.DefaultRenderTargetFormat = 0xb0 // uint8_t (Size: 0x1)
NiagaraSettings.DefaultGridFormat = 0xb1 // EENiagaraGpuBufferFormat (Size: 0x1)
NiagaraSettings.DefaultEffectTypePtr = 0xb8 // NiagaraEffectType* (Size: 0x8)
NiagaraSimulationStageBase.Script = 0x28 // NiagaraScript* (Size: 0x8)
NiagaraSimulationStageBase.SimulationStageName = 0x30 // FName (Size: 0x8)
NiagaraSimulationStageBase.bEnabled = 0x38 // uint8_t (Size: 0x1)
NiagaraSimulationStageGeneric.IterationSource = 0x40 // EENiagaraIterationSource (Size: 0x1)
NiagaraSimulationStageGeneric.Iterations = 0x44 // int32_t (Size: 0x4)
NiagaraSimulationStageGeneric.bSpawnOnly = 0x48 // uint8_t (Size: 0x1)
NiagaraSimulationStageGeneric.bDisablePartialParticleUpdate = 0x48 // uint8_t (Size: 0x1)
NiagaraSimulationStageGeneric.DataInterface = 0x50 // FNiagaraVariableDataInterfaceBinding (Size: 0x20)
NiagaraSpawnInfo.Count = 0x0 // int32_t (Size: 0x4)
NiagaraSpawnInfo.InterpStartDt = 0x4 // float (Size: 0x4)
NiagaraSpawnInfo.IntervalDt = 0x8 // float (Size: 0x4)
NiagaraSpawnInfo.SpawnGroup = 0xc // int32_t (Size: 0x4)
NiagaraSpriteRendererProperties.Material = 0x80 // MaterialInterface* (Size: 0x8)
NiagaraSpriteRendererProperties.SourceMode = 0x88 // EENiagaraRendererSourceDataMode (Size: 0x1)
NiagaraSpriteRendererProperties.MaterialUserParamBinding = 0x90 // FNiagaraUserParameterBinding (Size: 0x20)
NiagaraSpriteRendererProperties.Alignment = 0xb0 // EENiagaraSpriteAlignment (Size: 0x1)
NiagaraSpriteRendererProperties.FacingMode = 0xb1 // EENiagaraSpriteFacingMode (Size: 0x1)
NiagaraSpriteRendererProperties.PivotInUVSpace = 0xb4 // FVector2D (Size: 0x8)
NiagaraSpriteRendererProperties.SortMode = 0xbc // EENiagaraSortMode (Size: 0x1)
NiagaraSpriteRendererProperties.SubImageSize = 0xc0 // FVector2D (Size: 0x8)
NiagaraSpriteRendererProperties.bSubImageBlend = 0xc8 // uint8_t (Size: 0x1)
NiagaraSpriteRendererProperties.bRemoveHMDRollInVR = 0xc8 // uint8_t (Size: 0x1)
NiagaraSpriteRendererProperties.bSortOnlyWhenTranslucent = 0xc8 // uint8_t (Size: 0x1)
NiagaraSpriteRendererProperties.bGpuLowLatencyTranslucency = 0xc8 // uint8_t (Size: 0x1)
NiagaraSpriteRendererProperties.MinFacingCameraBlendDistance = 0xcc // float (Size: 0x4)
NiagaraSpriteRendererProperties.MaxFacingCameraBlendDistance = 0xd0 // float (Size: 0x4)
NiagaraSpriteRendererProperties.bEnableCameraDistanceCulling = 0xd4 // uint8_t (Size: 0x1)
NiagaraSpriteRendererProperties.MinCameraDistance = 0xd8 // float (Size: 0x4)
NiagaraSpriteRendererProperties.MaxCameraDistance = 0xdc // float (Size: 0x4)
NiagaraSpriteRendererProperties.RendererVisibility = 0xe0 // uint32_t (Size: 0x4)
NiagaraSpriteRendererProperties.PositionBinding = 0xe8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.ColorBinding = 0x140 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.VelocityBinding = 0x198 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.SpriteRotationBinding = 0x1f0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.SpriteSizeBinding = 0x248 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.SpriteFacingBinding = 0x2a0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.SpriteAlignmentBinding = 0x2f8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.SubImageIndexBinding = 0x350 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.DynamicMaterialBinding = 0x3a8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.DynamicMaterial1Binding = 0x400 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.DynamicMaterial2Binding = 0x458 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.DynamicMaterial3Binding = 0x4b0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.CameraOffsetBinding = 0x508 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.UVScaleBinding = 0x560 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.MaterialRandomBinding = 0x5b8 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.CustomSortingBinding = 0x610 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.NormalizedAgeBinding = 0x668 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.RendererVisibilityTagBinding = 0x6c0 // FNiagaraVariableAttributeBinding (Size: 0x58)
NiagaraSpriteRendererProperties.MaterialParameterBindings = 0x718 // TArray<FNiagaraMaterialAttributeBinding> (Size: 0x10)
NiagaraStatScope.FullName = 0x0 // FName (Size: 0x8)
NiagaraStatScope.FriendlyName = 0x8 // FName (Size: 0x8)
NiagaraSystem.bDumpDebugSystemInfo = 0x30 // bool (Size: 0x1)
NiagaraSystem.bDumpDebugEmitterInfo = 0x31 // bool (Size: 0x1)
NiagaraSystem.bRequireCurrentFrameData = 0x32 // bool (Size: 0x1)
NiagaraSystem.bFixedBounds = 0x34 // uint8_t (Size: 0x1)
NiagaraSystem.EffectType = 0x38 // NiagaraEffectType* (Size: 0x8)
NiagaraSystem.bOverrideScalabilitySettings = 0x40 // bool (Size: 0x1)
NiagaraSystem.ScalabilityOverrides = 0x48 // TArray<FNiagaraSystemScalabilityOverride> (Size: 0x10)
NiagaraSystem.SystemScalabilityOverrides = 0x58 // FNiagaraSystemScalabilityOverrides (Size: 0x10)
NiagaraSystem.EmitterHandles = 0x68 // TArray<FNiagaraEmitterHandle> (Size: 0x10)
NiagaraSystem.ParameterCollectionOverrides = 0x78 // TArray<NiagaraParameterCollectionInstance*> (Size: 0x10)
NiagaraSystem.SystemSpawnScript = 0x88 // NiagaraScript* (Size: 0x8)
NiagaraSystem.SystemUpdateScript = 0x90 // NiagaraScript* (Size: 0x8)
NiagaraSystem.SystemCompiledData = 0xa8 // FNiagaraSystemCompiledData (Size: 0x218)
NiagaraSystem.ExposedParameters = 0x2c0 // FNiagaraUserRedirectionParameterStore (Size: 0xc8)
NiagaraSystem.FixedBounds = 0x388 // FBox (Size: 0x1c)
NiagaraSystem.bAutoDeactivate = 0x3a4 // bool (Size: 0x1)
NiagaraSystem.WarmupTime = 0x3a8 // float (Size: 0x4)
NiagaraSystem.WarmupTickCount = 0x3ac // int32_t (Size: 0x4)
NiagaraSystem.WarmupTickDelta = 0x3b0 // float (Size: 0x4)
NiagaraSystem.bHasSystemScriptDIsWithPerInstanceData = 0x3b4 // bool (Size: 0x1)
NiagaraSystem.UserDINamesReadInSystemScripts = 0x3b8 // TArray<FName> (Size: 0x10)
NiagaraSystemCompileRequest.RootObjects = 0x8 // TArray<Object*> (Size: 0x10)
NiagaraSystemCompiledData.InstanceParamStore = 0x0 // FNiagaraParameterStore (Size: 0x78)
NiagaraSystemCompiledData.DataSetCompiledData = 0x78 // FNiagaraDataSetCompiledData (Size: 0x40)
NiagaraSystemCompiledData.SpawnInstanceParamsDataSetCompiledData = 0xb8 // FNiagaraDataSetCompiledData (Size: 0x40)
NiagaraSystemCompiledData.UpdateInstanceParamsDataSetCompiledData = 0xf8 // FNiagaraDataSetCompiledData (Size: 0x40)
NiagaraSystemCompiledData.SpawnInstanceGlobalBinding = 0x138 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.SpawnInstanceSystemBinding = 0x158 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.SpawnInstanceOwnerBinding = 0x178 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.SpawnInstanceEmitterBindings = 0x198 // TArray<FNiagaraParameterDataSetBindingCollection> (Size: 0x10)
NiagaraSystemCompiledData.UpdateInstanceGlobalBinding = 0x1a8 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.UpdateInstanceSystemBinding = 0x1c8 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.UpdateInstanceOwnerBinding = 0x1e8 // FNiagaraParameterDataSetBindingCollection (Size: 0x20)
NiagaraSystemCompiledData.UpdateInstanceEmitterBindings = 0x208 // TArray<FNiagaraParameterDataSetBindingCollection> (Size: 0x10)
NiagaraSystemScalabilityOverride.bOverrideDistanceSettings = 0x48 // uint8_t (Size: 0x1)
NiagaraSystemScalabilityOverride.bOverrideInstanceCountSettings = 0x48 // uint8_t (Size: 0x1)
NiagaraSystemScalabilityOverride.bOverridePerSystemInstanceCountSettings = 0x48 // uint8_t (Size: 0x1)
NiagaraSystemScalabilityOverride.bOverrideTimeSinceRendererSettings = 0x48 // uint8_t (Size: 0x1)
NiagaraSystemScalabilityOverrides.Overrides = 0x0 // TArray<FNiagaraSystemScalabilityOverride> (Size: 0x10)
NiagaraSystemScalabilitySettings.Platforms = 0x0 // FNiagaraPlatformSet (Size: 0x30)
NiagaraSystemScalabilitySettings.bCullByDistance = 0x30 // uint8_t (Size: 0x1)
NiagaraSystemScalabilitySettings.bCullMaxInstanceCount = 0x30 // uint8_t (Size: 0x1)
NiagaraSystemScalabilitySettings.bCullPerSystemMaxInstanceCount = 0x30 // uint8_t (Size: 0x1)
NiagaraSystemScalabilitySettings.bCullByMaxTimeWithoutRender = 0x30 // uint8_t (Size: 0x1)
NiagaraSystemScalabilitySettings.MaxDistance = 0x34 // float (Size: 0x4)
NiagaraSystemScalabilitySettings.MaxInstances = 0x38 // int32_t (Size: 0x4)
NiagaraSystemScalabilitySettings.MaxSystemInstances = 0x3c // int32_t (Size: 0x4)
NiagaraSystemScalabilitySettings.MaxTimeWithoutRender = 0x40 // float (Size: 0x4)
NiagaraSystemScalabilitySettingsArray.Settings = 0x0 // TArray<FNiagaraSystemScalabilitySettings> (Size: 0x10)
NiagaraSystemUpdateContext.ComponentsToReset = 0x0 // TArray<NiagaraComponent*> (Size: 0x10)
NiagaraSystemUpdateContext.ComponentsToReInit = 0x10 // TArray<NiagaraComponent*> (Size: 0x10)
NiagaraSystemUpdateContext.ComponentsToNotifySimDestroy = 0x20 // TArray<NiagaraComponent*> (Size: 0x10)
NiagaraSystemUpdateContext.SystemSimsToDestroy = 0x30 // TArray<NiagaraSystem*> (Size: 0x10)
NiagaraTypeDefinition.ClassStructOrEnum = 0x0 // Object* (Size: 0x8)
NiagaraTypeDefinition.UnderlyingType = 0x8 // uint16_t (Size: 0x2)
NiagaraTypeDefinitionHandle.RegisteredTypeIndex = 0x0 // int32_t (Size: 0x4)
NiagaraTypeLayoutInfo.FloatComponentByteOffsets = 0x0 // TArray<uint32_t> (Size: 0x10)
NiagaraTypeLayoutInfo.FloatComponentRegisterOffsets = 0x10 // TArray<uint32_t> (Size: 0x10)
NiagaraTypeLayoutInfo.Int32ComponentByteOffsets = 0x20 // TArray<uint32_t> (Size: 0x10)
NiagaraTypeLayoutInfo.Int32ComponentRegisterOffsets = 0x30 // TArray<uint32_t> (Size: 0x10)
NiagaraTypeLayoutInfo.HalfComponentByteOffsets = 0x40 // TArray<uint32_t> (Size: 0x10)
NiagaraTypeLayoutInfo.HalfComponentRegisterOffsets = 0x50 // TArray<uint32_t> (Size: 0x10)
NiagaraUserParameterBinding.Parameter = 0x0 // FNiagaraVariable (Size: 0x20)
NiagaraUserRedirectionParameterStore.UserParameterRedirects = 0x78 // TMap<...> (Size: 0x50)
NiagaraVMExecutableData.ByteCode = 0x0 // TArray<uint8_t> (Size: 0x10)
NiagaraVMExecutableData.OptimizedByteCode = 0x10 // TArray<uint8_t> (Size: 0x10)
NiagaraVMExecutableData.NumTempRegisters = 0x20 // int32_t (Size: 0x4)
NiagaraVMExecutableData.NumUserPtrs = 0x24 // int32_t (Size: 0x4)
NiagaraVMExecutableData.ScriptLiterals = 0x28 // TArray<uint8_t> (Size: 0x10)
NiagaraVMExecutableData.Attributes = 0x38 // TArray<FNiagaraVariable> (Size: 0x10)
NiagaraVMExecutableData.DataUsage = 0x48 // FNiagaraScriptDataUsageInfo (Size: 0x1)
NiagaraVMExecutableData.DataInterfaceInfo = 0x50 // TArray<FNiagaraScriptDataInterfaceCompileInfo> (Size: 0x10)
NiagaraVMExecutableData.CalledVMExternalFunctions = 0x60 // TArray<FVMExternalFunctionBindingInfo> (Size: 0x10)
NiagaraVMExecutableData.ReadDataSets = 0x80 // TArray<FNiagaraDataSetID> (Size: 0x10)
NiagaraVMExecutableData.WriteDataSets = 0x90 // TArray<FNiagaraDataSetProperties> (Size: 0x10)
NiagaraVMExecutableData.StatScopes = 0xa0 // TArray<FNiagaraStatScope> (Size: 0x10)
NiagaraVMExecutableData.DIParamInfo = 0xb0 // TArray<FNiagaraDataInterfaceGPUParamInfo> (Size: 0x10)
NiagaraVMExecutableData.LastCompileStatus = 0xc0 // EENiagaraScriptCompileStatus (Size: 0x1)
NiagaraVMExecutableData.SimulationStageMetaData = 0xc8 // TArray<FSimulationStageMetaData> (Size: 0x10)
NiagaraVMExecutableData.bReadsSignificanceIndex = 0xd8 // uint8_t (Size: 0x1)
NiagaraVMExecutableDataId.CompilerVersionID = 0x0 // FGuid (Size: 0x10)
NiagaraVMExecutableDataId.ScriptUsageType = 0x10 // EENiagaraScriptUsage (Size: 0x1)
NiagaraVMExecutableDataId.ScriptUsageTypeID = 0x14 // FGuid (Size: 0x10)
NiagaraVMExecutableDataId.bUsesRapidIterationParams = 0x24 // uint8_t (Size: 0x1)
NiagaraVMExecutableDataId.bInterpolatedSpawn = 0x24 // uint8_t (Size: 0x1)
NiagaraVMExecutableDataId.bRequiresPersistentIDs = 0x24 // uint8_t (Size: 0x1)
NiagaraVMExecutableDataId.BaseScriptID = 0x28 // FGuid (Size: 0x10)
NiagaraVMExecutableDataId.BaseScriptCompileHash = 0x38 // FNiagaraCompileHash (Size: 0x10)
NiagaraVariable.VarData = 0x10 // TArray<uint8_t> (Size: 0x10)
NiagaraVariableAttributeBinding.ParamMapVariable = 0x0 // FNiagaraVariableBase (Size: 0xc)
NiagaraVariableAttributeBinding.DataSetVariable = 0x10 // FNiagaraVariable (Size: 0x20)
NiagaraVariableAttributeBinding.RootVariable = 0x30 // FNiagaraVariable (Size: 0x20)
NiagaraVariableAttributeBinding.BindingSourceMode = 0x50 // uint8_t (Size: 0x1)
NiagaraVariableAttributeBinding.bBindingExistsOnSource = 0x54 // uint8_t (Size: 0x1)
NiagaraVariableAttributeBinding.bIsCachedParticleValue = 0x54 // uint8_t (Size: 0x1)
NiagaraVariableBase.Name = 0x0 // FName (Size: 0x8)
NiagaraVariableBase.TypeDefHandle = 0x8 // FNiagaraTypeDefinitionHandle (Size: 0x4)
NiagaraVariableDataInterfaceBinding.BoundVariable = 0x0 // FNiagaraVariable (Size: 0x20)
NiagaraVariableInfo.Variable = 0x0 // FNiagaraVariable (Size: 0x20)
NiagaraVariableInfo.Definition = 0x20 // FText (Size: 0x18)
NiagaraVariableInfo.DataInterface = 0x38 // NiagaraDataInterface* (Size: 0x8)
NiagaraVariableLayoutInfo.FloatComponentStart = 0x0 // uint32_t (Size: 0x4)
NiagaraVariableLayoutInfo.Int32ComponentStart = 0x4 // uint32_t (Size: 0x4)
NiagaraVariableLayoutInfo.HalfComponentStart = 0x8 // uint32_t (Size: 0x4)
NiagaraVariableLayoutInfo.LayoutInfo = 0x10 // FNiagaraTypeLayoutInfo (Size: 0x60)
NiagaraVariableMetaData.Description = 0x0 // FText (Size: 0x18)
NiagaraVariableMetaData.CategoryName = 0x18 // FText (Size: 0x18)
NiagaraVariableMetaData.bAdvancedDisplay = 0x30 // bool (Size: 0x1)
NiagaraVariableMetaData.EditorSortPriority = 0x34 // int32_t (Size: 0x4)
NiagaraVariableMetaData.bInlineEditConditionToggle = 0x38 // bool (Size: 0x1)
NiagaraVariableMetaData.EditCondition = 0x40 // FNiagaraInputConditionMetadata (Size: 0x18)
NiagaraVariableMetaData.VisibleCondition = 0x58 // FNiagaraInputConditionMetadata (Size: 0x18)
NiagaraVariableMetaData.PropertyMetaData = 0x70 // TMap<...> (Size: 0x50)
NiagaraVariableMetaData.ParentAttribute = 0xc0 // FName (Size: 0x8)
NiagaraVariableMetaData.ScopeName = 0xc8 // FName (Size: 0x8)
NiagaraVariableMetaData.Usage = 0xd0 // EENiagaraScriptParameterUsage (Size: 0x4)
NiagaraVariableMetaData.bIsStaticSwitch = 0xd4 // bool (Size: 0x1)
NiagaraVariableMetaData.StaticSwitchDefaultValue = 0xd8 // int32_t (Size: 0x4)
NiagaraVariableMetaData.bAddedToNodeGraphDeepCopy = 0xdc // bool (Size: 0x1)
NiagaraVariableMetaData.bOutputIsPersistent = 0xdd // bool (Size: 0x1)
NiagaraVariableMetaData.CachedNamespacelessVariableName = 0xe0 // FName (Size: 0x8)
NiagaraVariableMetaData.bCreatedInSystemEditor = 0xe8 // bool (Size: 0x1)
NiagaraVariableMetaData.bUseLegacyNameString = 0xe9 // bool (Size: 0x1)
NiagaraVariableWithOffset.Offset = 0xc // int32_t (Size: 0x4)
NiagaraVariant.Object = 0x0 // Object* (Size: 0x8)
NiagaraVariant.DataInterface = 0x8 // NiagaraDataInterface* (Size: 0x8)
NiagaraVariant.Bytes = 0x10 // TArray<uint8_t> (Size: 0x10)
NiagaraVariant.CurrentMode = 0x20 // EENiagaraVariantMode (Size: 0x4)
VMExternalFunctionBindingInfo.Name = 0x0 // FName (Size: 0x8)
VMExternalFunctionBindingInfo.OwnerName = 0x8 // FName (Size: 0x8)
VMExternalFunctionBindingInfo.InputParamLocations = 0x10 // TArray<bool> (Size: 0x10)
VMExternalFunctionBindingInfo.NumOutputs = 0x20 // int32_t (Size: 0x4)
VMExternalFunctionBindingInfo.FunctionSpecifiers = 0x28 // TArray<FVMFunctionSpecifier> (Size: 0x10)
VMFunctionSpecifier.Key = 0x0 // FName (Size: 0x8)
VMFunctionSpecifier.Value = 0x8 // FName (Size: 0x8)
AnimNotifyState_TimedNiagaraEffect.Template = 0x30 // NiagaraSystem* (Size: 0x8)
AnimNotifyState_TimedNiagaraEffect.SocketName = 0x38 // FName (Size: 0x8)
AnimNotifyState_TimedNiagaraEffect.LocationOffset = 0x40 // FVector (Size: 0xc)
AnimNotifyState_TimedNiagaraEffect.RotationOffset = 0x4c // FRotator (Size: 0xc)
AnimNotifyState_TimedNiagaraEffect.bDestroyAtEnd = 0x58 // bool (Size: 0x1)
AnimNotify_PlayNiagaraEffect.Template = 0x38 // NiagaraSystem* (Size: 0x8)
AnimNotify_PlayNiagaraEffect.LocationOffset = 0x40 // FVector (Size: 0xc)
AnimNotify_PlayNiagaraEffect.RotationOffset = 0x4c // FRotator (Size: 0xc)
AnimNotify_PlayNiagaraEffect.Scale = 0x58 // FVector (Size: 0xc)
AnimNotify_PlayNiagaraEffect.bAbsoluteScale = 0x64 // bool (Size: 0x1)
AnimNotify_PlayNiagaraEffect.Attached = 0x80 // uint8_t (Size: 0x1)
AnimNotify_PlayNiagaraEffect.SocketName = 0x84 // FName (Size: 0x8)
NiagaraCompileHash.DataHash = 0x0 // TArray<uint8_t> (Size: 0x10)
NiagaraCompileEvent.Severity = 0x0 // EFNiagaraCompileEventSeverity (Size: 0x1)
NiagaraCompileEvent.Message = 0x8 // FString (Size: 0x10)
NiagaraCompileEvent.NodeGuid = 0x18 // FGuid (Size: 0x10)
NiagaraCompileEvent.PinGuid = 0x28 // FGuid (Size: 0x10)
NiagaraCompileEvent.StackGuids = 0x38 // TArray<FGuid> (Size: 0x10)
NiagaraDataInterfaceGPUParamInfo.DataInterfaceHLSLSymbol = 0x0 // FString (Size: 0x10)
NiagaraDataInterfaceGPUParamInfo.DIClassName = 0x10 // FString (Size: 0x10)
NiagaraDataInterfaceGPUParamInfo.GeneratedFunctions = 0x20 // TArray<FNiagaraDataInterfaceGeneratedFunction> (Size: 0x10)
SimulationStageMetaData.SimulationStageName = 0x0 // FName (Size: 0x8)
SimulationStageMetaData.IterationSource = 0x8 // FName (Size: 0x8)
SimulationStageMetaData.bSpawnOnly = 0x10 // uint8_t (Size: 0x1)
SimulationStageMetaData.bWritesParticles = 0x10 // uint8_t (Size: 0x1)
SimulationStageMetaData.bPartialParticleUpdate = 0x10 // uint8_t (Size: 0x1)
SimulationStageMetaData.OutputDestinations = 0x18 // TArray<FName> (Size: 0x10)
SimulationStageMetaData.MinStage = 0x28 // int32_t (Size: 0x4)
SimulationStageMetaData.MaxStage = 0x2c // int32_t (Size: 0x4)
NiagaraSystemWidget.NiagaraSystemReference = 0x130 // NiagaraSystem* (Size: 0x8)
NiagaraSystemWidget.MaterialRemapList = 0x138 // TMap<...> (Size: 0x50)
NiagaraSystemWidget.AutoActivate = 0x188 // bool (Size: 0x1)
NiagaraSystemWidget.TickWhenPaused = 0x189 // bool (Size: 0x1)
NiagaraSystemWidget.FakeDepthScale = 0x18a // bool (Size: 0x1)
NiagaraSystemWidget.FakeDepthScaleDistance = 0x18c // float (Size: 0x4)
NiagaraSystemWidget.ShowDebugSystemInWorld = 0x190 // bool (Size: 0x1)
NiagaraSystemWidget.DisableWarnings = 0x191 // bool (Size: 0x1)
NiagaraSystemWidget.bFillWidget = 0x192 // bool (Size: 0x1)
NiagaraSystemWidget.OpacityParameterName = 0x198 // FString (Size: 0x10)
NiagaraSystemWidget.OverrideMaterialParameters = 0x1a8 // TMap<...> (Size: 0x50)
NiagaraSystemWidget.NiagaraActorTemplate = 0x1f8 // NiagaraUIActor* (Size: 0x8)
NiagaraSystemWidget.NiagaraActor = 0x210 // NiagaraUIActor* (Size: 0x8)
NiagaraSystemWidget.NiagaraComponent = 0x218 // NiagaraUIComponent* (Size: 0x8)
NiagaraUIActor.NiagaraUIComponent = 0x310 // NiagaraUIComponent* (Size: 0x8)
CharacterPool.Pool = 0xf8 // TArray<PooledCharacter*> (Size: 0x10)
CharacterPool.TemplateClass = 0x108 // ClassProperty (Size: 0x8)
CharacterPool.PoolSize = 0x110 // int32_t (Size: 0x4)
CharacterPool.AutoInitialize = 0x114 // bool (Size: 0x1)
ObjectPool.Pool = 0xf8 // TArray<PooledActor*> (Size: 0x10)
ObjectPool.TemplateClass = 0x108 // ClassProperty (Size: 0x8)
ObjectPool.PoolSize = 0x110 // int32_t (Size: 0x4)
ObjectPool.AutoInitialize = 0x114 // bool (Size: 0x1)
ObjectPool.bAlwaysUseOldestObject = 0x115 // bool (Size: 0x1)
ObjectPool.bInstantiateOnDemand = 0x116 // bool (Size: 0x1)
PawnPool.Pool = 0xf8 // TArray<PooledPawn*> (Size: 0x10)
PawnPool.TemplateClass = 0x108 // ClassProperty (Size: 0x8)
PawnPool.PoolSize = 0x110 // int32_t (Size: 0x4)
PawnPool.AutoInitialize = 0x114 // bool (Size: 0x1)
PoolSettings.ReinitializeInstances = 0x28 // bool (Size: 0x1)
PoolSettings.InstantiateOnDemand = 0x29 // bool (Size: 0x1)
PoolSettings.NeverFailDeferredSpawn = 0x2a // bool (Size: 0x1)
PoolSettings.KeepOrphanActorsAlive = 0x2b // bool (Size: 0x1)
PoolSpawnOptions.CollisionType = 0x0 // EEPoolCollisionType (Size: 0x1)
PoolSpawnOptions.EnableCollision = 0x1 // bool (Size: 0x1)
PoolSpawnOptions.SimulatePhysics = 0x2 // bool (Size: 0x1)
PoolSpawnOptions.ActorTickEnabled = 0x3 // bool (Size: 0x1)
PooledActor.Spawned = 0x310 // bool (Size: 0x1)
PooledActor.OwningPool = 0x318 // ObjectPool* (Size: 0x8)
PooledActor.SharedPool = 0x320 // SharedObjectPool* (Size: 0x8)
PooledActor.LifeSpanHandle = 0x328 // FTimerHandle (Size: 0x8)
PooledActor.SpawnTimeSeconds = 0x330 // float (Size: 0x4)
PooledActor.LifeSpanPool = 0x334 // float (Size: 0x4)
PooledActor.OnPoolBeginPlay = 0x338 // FMulticastInlineDelegate (Size: 0x10)
PooledActor.OnPoolEndPlay = 0x348 // FMulticastInlineDelegate (Size: 0x10)
PooledCharacter.OwningPool = 0x5d8 // CharacterPool* (Size: 0x8)
PooledCharacter.Spawned = 0x5e0 // bool (Size: 0x1)
PooledCharacter.LifeSpanHandle = 0x5e8 // FTimerHandle (Size: 0x8)
PooledCharacter.LifeSpanPool = 0x5f0 // float (Size: 0x4)
PooledCharacter.OnPoolBeginPlay = 0x5f8 // FMulticastInlineDelegate (Size: 0x10)
PooledCharacter.OnPoolEndPlay = 0x608 // FMulticastInlineDelegate (Size: 0x10)
PooledPawn.OwningPool = 0x380 // PawnPool* (Size: 0x8)
PooledPawn.Spawned = 0x388 // bool (Size: 0x1)
PooledPawn.LifeSpanHandle = 0x390 // FTimerHandle (Size: 0x8)
PooledPawn.LifeSpanPool = 0x398 // float (Size: 0x4)
PooledPawn.OnPoolBeginPlay = 0x3a0 // FMulticastInlineDelegate (Size: 0x10)
PooledPawn.OnPoolEndPlay = 0x3b0 // FMulticastInlineDelegate (Size: 0x10)
PooledProjectile.Movement = 0xf8 // ProjectileMovementComponent* (Size: 0x8)
PooledProjectile.AOwner = 0x100 // PooledActor* (Size: 0x8)
PooledProjectile.POwner = 0x108 // PooledPawn* (Size: 0x8)
PooledProjectile.Primitive = 0x110 // PrimitiveComponent* (Size: 0x8)
PooledProjectile.Direction = 0x118 // FVector (Size: 0xc)
PooledProjectile.InitialSpeed = 0x124 // float (Size: 0x4)
PooledProjectile.MaxSpeed = 0x128 // float (Size: 0x4)
PooledProjectile.UpdateOnlyIfRendered = 0x12c // bool (Size: 0x1)
PooledProjectile.RotationFollowsVelocity = 0x130 // uint8_t (Size: 0x1)
PooledProjectile.InitialVelocityInLocalSpace = 0x130 // uint8_t (Size: 0x1)
PooledProjectile.ProjectileGravityScale = 0x134 // float (Size: 0x4)
PooledProjectile.ShouldBounce = 0x138 // uint8_t (Size: 0x1)
PooledProjectile.BounceAngleAffectsFriction = 0x138 // uint8_t (Size: 0x1)
PooledProjectile.Bounciness = 0x13c // float (Size: 0x4)
PooledProjectile.Friction = 0x140 // float (Size: 0x4)
PooledProjectile.BounceVelocityStopSimulatingThreshold = 0x144 // float (Size: 0x4)
PooledProjectile.ForceSubStepping = 0x148 // uint8_t (Size: 0x1)
PooledProjectile.MaxSimulationIterations = 0x14c // int32_t (Size: 0x4)
PooledProjectile.MaxSimulationTimeStep = 0x150 // float (Size: 0x4)
PooledProjectile.IsHomingProjectile = 0x154 // uint8_t (Size: 0x1)
PooledProjectile.OnProjectileBounce = 0x158 // FMulticastInlineDelegate (Size: 0x10)
PooledProjectile.OnProjectileStop = 0x168 // FMulticastInlineDelegate (Size: 0x10)
PooledProjectile.HomingTarget = 0x178 // Actor* (Size: 0x8)
PooledProjectile.HomingTargetComponent = 0x180 // TWeakObjectPtr<UObject> (Size: 0x8)
PooledProjectile.HomingAccelerationMagnitude = 0x188 // float (Size: 0x4)
PooledSplineProjectile.POwner = 0x198 // PooledPawn* (Size: 0x8)
PooledSplineProjectile.AOwner = 0x1a0 // PooledActor* (Size: 0x8)
PooledSplineProjectile.Primitive = 0x1a8 // PrimitiveComponent* (Size: 0x8)
PooledSplineProjectile.SplineComponent = 0x1b0 // SplineComponent* (Size: 0x8)
PooledSplineProjectile.PathWidth = 0x1b8 // float (Size: 0x4)
PooledSplineProjectile.Speed = 0x1bc // float (Size: 0x4)
PooledSplineProjectile.PathCollisionQueryTypes = 0x1c0 // TArray<uint8_t> (Size: 0x10)
PooledSplineProjectile.IgnoredActorsOnCollisionQuery = 0x1d0 // TArray<Actor*> (Size: 0x10)
PooledSplineProjectile.CollisionQueryDebugMode = 0x1e0 // uint8_t (Size: 0x1)
PooledSplineProjectile.OnProjectileHit = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
SharedObjectPool.Pool = 0xf8 // TArray<PooledActor*> (Size: 0x10)
SharedObjectPool.AutoInitialize = 0x108 // bool (Size: 0x1)
SharedObjectPool.TemplateClasses = 0x110 // TMap<...> (Size: 0x50)
InAppPurchaseProductInfo.Identifier = 0x0 // FString (Size: 0x10)
InAppPurchaseProductInfo.TransactionIdentifier = 0x10 // FString (Size: 0x10)
InAppPurchaseProductInfo.DisplayName = 0x20 // FString (Size: 0x10)
InAppPurchaseProductInfo.DisplayDescription = 0x30 // FString (Size: 0x10)
InAppPurchaseProductInfo.DisplayPrice = 0x40 // FString (Size: 0x10)
InAppPurchaseProductInfo.RawPrice = 0x50 // float (Size: 0x4)
InAppPurchaseProductInfo.CurrencyCode = 0x58 // FString (Size: 0x10)
InAppPurchaseProductInfo.CurrencySymbol = 0x68 // FString (Size: 0x10)
InAppPurchaseProductInfo.DecimalSeparator = 0x78 // FString (Size: 0x10)
InAppPurchaseProductInfo.GroupingSeparator = 0x88 // FString (Size: 0x10)
InAppPurchaseProductInfo.ReceiptData = 0x98 // FString (Size: 0x10)
InAppPurchaseProductRequest.ProductIdentifier = 0x0 // FString (Size: 0x10)
InAppPurchaseProductRequest.bIsConsumable = 0x10 // bool (Size: 0x1)
InAppPurchaseRestoreInfo.Identifier = 0x0 // FString (Size: 0x10)
InAppPurchaseRestoreInfo.ReceiptData = 0x10 // FString (Size: 0x10)
InAppPurchaseRestoreInfo.TransactionIdentifier = 0x20 // FString (Size: 0x10)
NamedInterface.InterfaceName = 0x0 // FName (Size: 0x8)
NamedInterface.InterfaceObject = 0x8 // Object* (Size: 0x8)
NamedInterfaceDef.InterfaceName = 0x0 // FName (Size: 0x8)
NamedInterfaceDef.InterfaceClassName = 0x8 // FString (Size: 0x10)
NamedInterfaces.NamedInterfaces = 0x28 // TArray<FNamedInterface> (Size: 0x10)
NamedInterfaces.NamedInterfaceDefs = 0x38 // TArray<FNamedInterfaceDef> (Size: 0x10)
SteamNetConnection.bIsPassthrough = 0x1c48 // bool (Size: 0x1)
AchievementQueryCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AchievementQueryCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
AchievementWriteCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AchievementWriteCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
ConnectionCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
ConnectionCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
CreateSessionCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
CreateSessionCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
DestroySessionCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
DestroySessionCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
EndMatchCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
EndMatchCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
EndTurnCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
EndTurnCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
FindSessionsCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
FindSessionsCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
FindTurnBasedMatchCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
FindTurnBasedMatchCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseCallbackProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseCallbackProxy.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseCallbackProxy2.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseCallbackProxy2.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseProductInfo2.Identifier = 0x0 // FString (Size: 0x10)
InAppPurchaseProductInfo2.TransactionIdentifier = 0x10 // FString (Size: 0x10)
InAppPurchaseProductInfo2.DisplayName = 0x20 // FString (Size: 0x10)
InAppPurchaseProductInfo2.DisplayDescription = 0x30 // FString (Size: 0x10)
InAppPurchaseProductInfo2.DisplayPrice = 0x40 // FString (Size: 0x10)
InAppPurchaseProductInfo2.RawPrice = 0x50 // float (Size: 0x4)
InAppPurchaseProductInfo2.CurrencyCode = 0x58 // FString (Size: 0x10)
InAppPurchaseProductInfo2.CurrencySymbol = 0x68 // FString (Size: 0x10)
InAppPurchaseProductInfo2.DecimalSeparator = 0x78 // FString (Size: 0x10)
InAppPurchaseProductInfo2.GroupingSeparator = 0x88 // FString (Size: 0x10)
InAppPurchaseProductInfo2.ReceiptData = 0x98 // FString (Size: 0x10)
InAppPurchaseProductInfo2.DynamicFields = 0xa8 // TMap<...> (Size: 0x50)
InAppPurchaseProductRequest2.ProductIdentifier = 0x0 // FString (Size: 0x10)
InAppPurchaseProductRequest2.bIsConsumable = 0x10 // bool (Size: 0x1)
InAppPurchaseQueryCallbackProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseQueryCallbackProxy.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseQueryCallbackProxy2.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseQueryCallbackProxy2.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseReceiptInfo.ItemName = 0x0 // FString (Size: 0x10)
InAppPurchaseReceiptInfo.ItemId = 0x10 // FString (Size: 0x10)
InAppPurchaseReceiptInfo.ValidationInfo = 0x20 // FString (Size: 0x10)
InAppPurchaseReceiptInfo2.ItemName = 0x0 // FString (Size: 0x10)
InAppPurchaseReceiptInfo2.ItemId = 0x10 // FString (Size: 0x10)
InAppPurchaseReceiptInfo2.ValidationInfo = 0x20 // FString (Size: 0x10)
InAppPurchaseRestoreCallbackProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseRestoreCallbackProxy.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseRestoreCallbackProxy2.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseRestoreCallbackProxy2.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
InAppPurchaseRestoreInfo2.ItemName = 0x0 // FString (Size: 0x10)
InAppPurchaseRestoreInfo2.ItemId = 0x10 // FString (Size: 0x10)
InAppPurchaseRestoreInfo2.ValidationInfo = 0x20 // FString (Size: 0x10)
IpConnection.SocketErrorDisconnectDelay = 0x1bf8 // float (Size: 0x4)
IpNetDriver.LogPortUnreach = 0x7e8 // uint8_t (Size: 0x1)
IpNetDriver.AllowPlayerPortUnreach = 0x7e8 // uint8_t (Size: 0x1)
IpNetDriver.MaxPortCountToTry = 0x7ec // uint32_t (Size: 0x4)
IpNetDriver.MaxSecondsInReceive = 0x800 // double (Size: 0x8)
IpNetDriver.MaxSecondsInReceiveForDS = 0x808 // double (Size: 0x8)
IpNetDriver.ServerDesiredSocketReceiveBufferBytes = 0x810 // uint32_t (Size: 0x4)
IpNetDriver.ServerDesiredSocketSendBufferBytes = 0x814 // uint32_t (Size: 0x4)
IpNetDriver.ClientDesiredSocketReceiveBufferBytes = 0x818 // uint32_t (Size: 0x4)
IpNetDriver.ClientDesiredSocketSendBufferBytes = 0x81c // uint32_t (Size: 0x4)
IpNetDriver.NbPacketsBetweenReceiveTimeTest = 0x820 // int32_t (Size: 0x4)
IpNetDriver.ResolutionConnectionTimeout = 0x824 // float (Size: 0x4)
JoinSessionCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
JoinSessionCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
LeaderboardFlushCallbackProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
LeaderboardFlushCallbackProxy.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
LeaderboardQueryCallbackProxy.OnSuccess = 0x28 // FMulticastInlineDelegate (Size: 0x10)
LeaderboardQueryCallbackProxy.OnFailure = 0x38 // FMulticastInlineDelegate (Size: 0x10)
LogoutCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
LogoutCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
OnlineBeacon.BeaconConnectionInitialTimeout = 0x318 // float (Size: 0x4)
OnlineBeacon.BeaconConnectionTimeout = 0x31c // float (Size: 0x4)
OnlineBeacon.NetDriver = 0x320 // NetDriver* (Size: 0x8)
OnlineBeaconClient.BeaconOwner = 0x340 // OnlineBeaconHostObject* (Size: 0x8)
OnlineBeaconClient.BeaconConnection = 0x348 // NetConnection* (Size: 0x8)
OnlineBeaconClient.ConnectionState = 0x350 // EEBeaconConnectionState (Size: 0x1)
OnlineBeaconHost.ListenPort = 0x340 // int32_t (Size: 0x4)
OnlineBeaconHost.ClientActors = 0x348 // TArray<OnlineBeaconClient*> (Size: 0x10)
OnlineBeaconHostObject.BeaconTypeName = 0x310 // FString (Size: 0x10)
OnlineBeaconHostObject.ClientBeaconActorClass = 0x320 // ClassProperty (Size: 0x8)
OnlineBeaconHostObject.ClientActors = 0x328 // TArray<OnlineBeaconClient*> (Size: 0x10)
OnlineEngineInterfaceImpl.VoiceSubsystemNameOverride = 0x28 // FName (Size: 0x8)
OnlinePIESettings.bOnlinePIEEnabled = 0x38 // bool (Size: 0x1)
OnlinePIESettings.Logins = 0x40 // TArray<FPIELoginSettingsInternal> (Size: 0x10)
OnlineProxyStoreOffer.OfferId = 0x0 // FString (Size: 0x10)
OnlineProxyStoreOffer.Title = 0x10 // FText (Size: 0x18)
OnlineProxyStoreOffer.Description = 0x28 // FText (Size: 0x18)
OnlineProxyStoreOffer.LongDescription = 0x40 // FText (Size: 0x18)
OnlineProxyStoreOffer.RegularPriceText = 0x58 // FText (Size: 0x18)
OnlineProxyStoreOffer.RegularPrice = 0x70 // int32_t (Size: 0x4)
OnlineProxyStoreOffer.PriceText = 0x78 // FText (Size: 0x18)
OnlineProxyStoreOffer.NumericPrice = 0x90 // int32_t (Size: 0x4)
OnlineProxyStoreOffer.CurrencyCode = 0x98 // FString (Size: 0x10)
OnlineProxyStoreOffer.ReleaseDate = 0xa8 // FDateTime (Size: 0x8)
OnlineProxyStoreOffer.ExpirationDate = 0xb0 // FDateTime (Size: 0x8)
OnlineProxyStoreOffer.DiscountType = 0xb8 // EEOnlineProxyStoreOfferDiscountType (Size: 0x1)
OnlineProxyStoreOffer.DynamicFields = 0xc0 // TMap<...> (Size: 0x50)
OnlineSessionClient.bIsFromInvite = 0x1d8 // bool (Size: 0x1)
OnlineSessionClient.bHandlingDisconnect = 0x1d9 // bool (Size: 0x1)
PIELoginSettingsInternal.ID = 0x0 // FString (Size: 0x10)
PIELoginSettingsInternal.Token = 0x10 // FString (Size: 0x10)
PIELoginSettingsInternal.Type = 0x20 // FString (Size: 0x10)
PIELoginSettingsInternal.TokenBytes = 0x30 // TArray<uint8_t> (Size: 0x10)
PartyBeaconClient.DestSessionId = 0x3d0 // FString (Size: 0x10)
PartyBeaconClient.PendingReservation = 0x3e0 // FPartyReservation (Size: 0x50)
PartyBeaconClient.RequestType = 0x430 // EEClientRequestType (Size: 0x1)
PartyBeaconClient.bPendingReservationSent = 0x431 // bool (Size: 0x1)
PartyBeaconClient.bCancelReservation = 0x432 // bool (Size: 0x1)
PartyBeaconHost.State = 0x338 // PartyBeaconState* (Size: 0x8)
PartyBeaconHost.bLogoutOnSessionTimeout = 0x3a0 // bool (Size: 0x1)
PartyBeaconHost.SessionTimeoutSecs = 0x3a4 // float (Size: 0x4)
PartyBeaconHost.TravelSessionTimeoutSecs = 0x3a8 // float (Size: 0x4)
PartyBeaconState.SessionName = 0x28 // FName (Size: 0x8)
PartyBeaconState.NumConsumedReservations = 0x30 // int32_t (Size: 0x4)
PartyBeaconState.MaxReservations = 0x34 // int32_t (Size: 0x4)
PartyBeaconState.NumTeams = 0x38 // int32_t (Size: 0x4)
PartyBeaconState.NumPlayersPerTeam = 0x3c // int32_t (Size: 0x4)
PartyBeaconState.TeamAssignmentMethod = 0x40 // FName (Size: 0x8)
PartyBeaconState.ReservedHostTeamNum = 0x48 // int32_t (Size: 0x4)
PartyBeaconState.ForceTeamNum = 0x4c // int32_t (Size: 0x4)
PartyBeaconState.bRestrictCrossConsole = 0x50 // bool (Size: 0x1)
PartyBeaconState.bEnableRemovalRequests = 0x51 // bool (Size: 0x1)
PartyBeaconState.Reservations = 0x58 // TArray<FPartyReservation> (Size: 0x10)
PartyReservation.TeamNum = 0x0 // int32_t (Size: 0x4)
PartyReservation.PartyLeader = 0x8 // FUniqueNetIdRepl (Size: 0x28)
PartyReservation.PartyMembers = 0x30 // TArray<FPlayerReservation> (Size: 0x10)
PartyReservation.RemovedPartyMembers = 0x40 // TArray<FPlayerReservation> (Size: 0x10)
PlayerReservation.UniqueID = 0x0 // FUniqueNetIdRepl (Size: 0x28)
PlayerReservation.ValidationStr = 0x28 // FString (Size: 0x10)
PlayerReservation.Platform = 0x38 // FString (Size: 0x10)
PlayerReservation.bAllowCrossplay = 0x48 // bool (Size: 0x1)
PlayerReservation.ElapsedTime = 0x4c // float (Size: 0x4)
QuitMatchCallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
QuitMatchCallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
ShowLoginUICallbackProxy.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
ShowLoginUICallbackProxy.OnFailure = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SpectatorBeaconClient.DestSessionId = 0x3d0 // FString (Size: 0x10)
SpectatorBeaconClient.PendingReservation = 0x3e0 // FSpectatorReservation (Size: 0x78)
SpectatorBeaconClient.RequestType = 0x458 // EESpectatorClientRequestType (Size: 0x1)
SpectatorBeaconClient.bPendingReservationSent = 0x459 // bool (Size: 0x1)
SpectatorBeaconClient.bCancelReservation = 0x45a // bool (Size: 0x1)
SpectatorBeaconHost.State = 0x338 // SpectatorBeaconState* (Size: 0x8)
SpectatorBeaconHost.bLogoutOnSessionTimeout = 0x3a0 // bool (Size: 0x1)
SpectatorBeaconHost.SessionTimeoutSecs = 0x3a4 // float (Size: 0x4)
SpectatorBeaconHost.TravelSessionTimeoutSecs = 0x3a8 // float (Size: 0x4)
SpectatorBeaconState.SessionName = 0x28 // FName (Size: 0x8)
SpectatorBeaconState.NumConsumedReservations = 0x30 // int32_t (Size: 0x4)
SpectatorBeaconState.MaxReservations = 0x34 // int32_t (Size: 0x4)
SpectatorBeaconState.bRestrictCrossConsole = 0x38 // bool (Size: 0x1)
SpectatorBeaconState.Reservations = 0x40 // TArray<FSpectatorReservation> (Size: 0x10)
SpectatorReservation.SpectatorId = 0x0 // FUniqueNetIdRepl (Size: 0x28)
SpectatorReservation.Spectator = 0x28 // FPlayerReservation (Size: 0x50)
OodleNetworkTrainerCommandlet.bCompressionTest = 0x80 // bool (Size: 0x1)
OodleNetworkTrainerCommandlet.HashTableSize = 0x84 // int32_t (Size: 0x4)
OodleNetworkTrainerCommandlet.DictionarySize = 0x88 // int32_t (Size: 0x4)
OodleNetworkTrainerCommandlet.DictionaryTrials = 0x8c // int32_t (Size: 0x4)
OodleNetworkTrainerCommandlet.TrialRandomness = 0x90 // int32_t (Size: 0x4)
OodleNetworkTrainerCommandlet.TrialGenerations = 0x94 // int32_t (Size: 0x4)
OodleNetworkTrainerCommandlet.bNoTrials = 0x98 // bool (Size: 0x1)
OpacityMicroMapAsset.Collection = 0x28 // OpacityMicroMapCollection* (Size: 0x8)
OpacityMicroMapCollection.Collection = 0x28 // TMap<...> (Size: 0x50)
OpacityMicroMapData.ArrayData = 0x28 // TArray<uint8_t> (Size: 0x10)
OpacityMicroMapData.DescArrayData = 0x38 // TArray<uint8_t> (Size: 0x10)
OpacityMicroMapData.DescArrayHistogram = 0x48 // TArray<FOpacityMicroMapUsageCount> (Size: 0x10)
OpacityMicroMapData.IndexBuffer = 0x58 // TArray<uint8_t> (Size: 0x10)
OpacityMicroMapData.Is16BitIndexBuffer = 0x68 // bool (Size: 0x1)
OpacityMicroMapData.IndexHistogram = 0x70 // TArray<FOpacityMicroMapUsageCount> (Size: 0x10)
OpacityMicroMapData.MaxSubdivisionLevel = 0x80 // uint32_t (Size: 0x4)
OpacityMicroMapData.Flags = 0x84 // EEOpacityMicromapFlags (Size: 0x1)
OpacityMicroMapData.IsTwoState = 0x85 // bool (Size: 0x1)
OpacityMicroMapData.VersionHash = 0x88 // uint64_t (Size: 0x8)
OpacityMicroMapUsageCount.Count = 0x0 // uint32_t (Size: 0x4)
OpacityMicroMapUsageCount.SubdivisionLevel = 0x4 // uint32_t (Size: 0x4)
OpacityMicroMapUsageCount.Format = 0x8 // uint32_t (Size: 0x4)
OpacityMicromapDesc.Offset = 0x0 // uint32_t (Size: 0x4)
OpacityMicromapDesc.SubdivisionLevel = 0x4 // uint16_t (Size: 0x2)
OpacityMicromapDesc.Format = 0x6 // uint16_t (Size: 0x2)
OpacityMicromapPluginSettings.bEnableOpacityMicromaps = 0x38 // bool (Size: 0x1)
OpacityMicromapPluginSettings.bUseOMMSDKBaker = 0x39 // bool (Size: 0x1)
OpacityMicromapPluginSettings.bBuildOMMsOnUIChanges = 0x3a // bool (Size: 0x1)
BasicOverlays.Overlays = 0x28 // TArray<FOverlayItem> (Size: 0x10)
LocalizedOverlays.DefaultOverlays = 0x28 // BasicOverlays* (Size: 0x8)
LocalizedOverlays.LocaleToOverlaysMap = 0x30 // TMap<...> (Size: 0x50)
OverlayItem.StartTime = 0x0 // FTimespan (Size: 0x8)
OverlayItem.EndTime = 0x8 // FTimespan (Size: 0x8)
OverlayItem.Text = 0x10 // FString (Size: 0x10)
OverlayItem.position = 0x20 // FVector2D (Size: 0x8)
PacketHandlerProfileConfig.Components = 0x28 // TArray<FString> (Size: 0x10)
IntMargin.Left = 0x0 // int32_t (Size: 0x4)
IntMargin.Top = 0x4 // int32_t (Size: 0x4)
IntMargin.Right = 0x8 // int32_t (Size: 0x4)
IntMargin.Bottom = 0xc // int32_t (Size: 0x4)
MaterialExpressionSpriteTextureSampler.bSampleAdditionalTextures = 0x80 // bool (Size: 0x1)
MaterialExpressionSpriteTextureSampler.AdditionalSlotIndex = 0x84 // int32_t (Size: 0x4)
MaterialExpressionSpriteTextureSampler.SlotDisplayName = 0x88 // FText (Size: 0x18)
PaperCharacter.Sprite = 0x5d8 // PaperFlipbookComponent* (Size: 0x8)
PaperFlipbook.FramesPerSecond = 0x28 // float (Size: 0x4)
PaperFlipbook.KeyFrames = 0x30 // TArray<FPaperFlipbookKeyFrame> (Size: 0x10)
PaperFlipbook.DefaultMaterial = 0x40 // MaterialInterface* (Size: 0x8)
PaperFlipbook.CollisionSource = 0x48 // uint8_t (Size: 0x1)
PaperFlipbookActor.RenderComponent = 0x310 // PaperFlipbookComponent* (Size: 0x8)
PaperFlipbookComponent.SourceFlipbook = 0x600 // PaperFlipbook* (Size: 0x8)
PaperFlipbookComponent.Material = 0x608 // MaterialInterface* (Size: 0x8)
PaperFlipbookComponent.PlayRate = 0x610 // float (Size: 0x4)
PaperFlipbookComponent.bLooping = 0x614 // uint8_t (Size: 0x1)
PaperFlipbookComponent.bReversePlayback = 0x614 // uint8_t (Size: 0x1)
PaperFlipbookComponent.bPlaying = 0x614 // uint8_t (Size: 0x1)
PaperFlipbookComponent.AccumulatedTime = 0x618 // float (Size: 0x4)
PaperFlipbookComponent.CachedFrameIndex = 0x61c // int32_t (Size: 0x4)
PaperFlipbookComponent.SpriteColor = 0x620 // FLinearColor (Size: 0x10)
PaperFlipbookComponent.CachedBodySetup = 0x630 // BodySetup* (Size: 0x8)
PaperFlipbookComponent.OnFinishedPlaying = 0x638 // FMulticastInlineDelegate (Size: 0x10)
PaperFlipbookKeyFrame.Sprite = 0x0 // PaperSprite* (Size: 0x8)
PaperFlipbookKeyFrame.FrameRun = 0x8 // int32_t (Size: 0x4)
PaperGroupedSpriteActor.RenderComponent = 0x310 // PaperGroupedSpriteComponent* (Size: 0x8)
PaperGroupedSpriteComponent.InstanceMaterials = 0x600 // TArray<MaterialInterface*> (Size: 0x10)
PaperGroupedSpriteComponent.PerInstanceSpriteData = 0x610 // TArray<FSpriteInstanceData> (Size: 0x10)
PaperRuntimeSettings.bEnableSpriteAtlasGroups = 0x28 // bool (Size: 0x1)
PaperRuntimeSettings.bEnableTerrainSplineEditing = 0x29 // bool (Size: 0x1)
PaperRuntimeSettings.bResizeSpriteDataToMatchTextures = 0x2a // bool (Size: 0x1)
PaperSprite.AdditionalSourceTextures = 0x38 // TArray<Texture*> (Size: 0x10)
PaperSprite.BakedSourceUV = 0x48 // FVector2D (Size: 0x8)
PaperSprite.BakedSourceDimension = 0x50 // FVector2D (Size: 0x8)
PaperSprite.BakedSourceTexture = 0x58 // Texture2D* (Size: 0x8)
PaperSprite.DefaultMaterial = 0x60 // MaterialInterface* (Size: 0x8)
PaperSprite.AlternateMaterial = 0x68 // MaterialInterface* (Size: 0x8)
PaperSprite.Sockets = 0x70 // TArray<FPaperSpriteSocket> (Size: 0x10)
PaperSprite.SpriteCollisionDomain = 0x80 // uint8_t (Size: 0x1)
PaperSprite.PixelsPerUnrealUnit = 0x84 // float (Size: 0x4)
PaperSprite.BodySetup = 0x88 // BodySetup* (Size: 0x8)
PaperSprite.AlternateMaterialSplitIndex = 0x90 // int32_t (Size: 0x4)
PaperSprite.BakedRenderData = 0x98 // TArray<FVector4> (Size: 0x10)
PaperSpriteActor.RenderComponent = 0x310 // PaperSpriteComponent* (Size: 0x8)
PaperSpriteAtlasSlot.SpriteRef = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
PaperSpriteAtlasSlot.AtlasIndex = 0x28 // int32_t (Size: 0x4)
PaperSpriteAtlasSlot.X = 0x2c // int32_t (Size: 0x4)
PaperSpriteAtlasSlot.Y = 0x30 // int32_t (Size: 0x4)
PaperSpriteAtlasSlot.Width = 0x34 // int32_t (Size: 0x4)
PaperSpriteAtlasSlot.Height = 0x38 // int32_t (Size: 0x4)
PaperSpriteComponent.SourceSprite = 0x600 // PaperSprite* (Size: 0x8)
PaperSpriteComponent.MaterialOverride = 0x608 // MaterialInterface* (Size: 0x8)
PaperSpriteComponent.SpriteColor = 0x610 // FLinearColor (Size: 0x10)
PaperSpriteSocket.LocalTransform = 0x0 // FTransform (Size: 0x30)
PaperSpriteSocket.SocketName = 0x30 // FName (Size: 0x8)
PaperTerrainActor.DummyRoot = 0x310 // SceneComponent* (Size: 0x8)
PaperTerrainActor.SplineComponent = 0x318 // PaperTerrainSplineComponent* (Size: 0x8)
PaperTerrainActor.RenderComponent = 0x320 // PaperTerrainComponent* (Size: 0x8)
PaperTerrainComponent.TerrainMaterial = 0x5c8 // PaperTerrainMaterial* (Size: 0x8)
PaperTerrainComponent.bClosedSpline = 0x5d0 // bool (Size: 0x1)
PaperTerrainComponent.bFilledSpline = 0x5d1 // bool (Size: 0x1)
PaperTerrainComponent.AssociatedSpline = 0x5d8 // PaperTerrainSplineComponent* (Size: 0x8)
PaperTerrainComponent.RandomSeed = 0x5e0 // int32_t (Size: 0x4)
PaperTerrainComponent.SegmentOverlapAmount = 0x5e4 // float (Size: 0x4)
PaperTerrainComponent.TerrainColor = 0x5e8 // FLinearColor (Size: 0x10)
PaperTerrainComponent.ReparamStepsPerSegment = 0x5f8 // int32_t (Size: 0x4)
PaperTerrainComponent.SpriteCollisionDomain = 0x5fc // uint8_t (Size: 0x1)
PaperTerrainComponent.CollisionThickness = 0x600 // float (Size: 0x4)
PaperTerrainComponent.CachedBodySetup = 0x608 // BodySetup* (Size: 0x8)
PaperTerrainMaterial.rules = 0x30 // TArray<FPaperTerrainMaterialRule> (Size: 0x10)
PaperTerrainMaterial.InteriorFill = 0x40 // PaperSprite* (Size: 0x8)
PaperTerrainMaterialRule.StartCap = 0x0 // PaperSprite* (Size: 0x8)
PaperTerrainMaterialRule.Body = 0x8 // TArray<PaperSprite*> (Size: 0x10)
PaperTerrainMaterialRule.EndCap = 0x18 // PaperSprite* (Size: 0x8)
PaperTerrainMaterialRule.MinimumAngle = 0x20 // float (Size: 0x4)
PaperTerrainMaterialRule.MaximumAngle = 0x24 // float (Size: 0x4)
PaperTerrainMaterialRule.bEnableCollision = 0x28 // bool (Size: 0x1)
PaperTerrainMaterialRule.CollisionOffset = 0x2c // float (Size: 0x4)
PaperTerrainMaterialRule.DrawOrder = 0x30 // int32_t (Size: 0x4)
PaperTileInfo.TileSet = 0x0 // PaperTileSet* (Size: 0x8)
PaperTileInfo.PackedTileIndex = 0x8 // int32_t (Size: 0x4)
PaperTileLayer.LayerName = 0x28 // FText (Size: 0x18)
PaperTileLayer.LayerWidth = 0x40 // int32_t (Size: 0x4)
PaperTileLayer.LayerHeight = 0x44 // int32_t (Size: 0x4)
PaperTileLayer.bHiddenInGame = 0x48 // uint8_t (Size: 0x1)
PaperTileLayer.bLayerCollides = 0x48 // uint8_t (Size: 0x1)
PaperTileLayer.bOverrideCollisionThickness = 0x48 // uint8_t (Size: 0x1)
PaperTileLayer.bOverrideCollisionOffset = 0x48 // uint8_t (Size: 0x1)
PaperTileLayer.CollisionThicknessOverride = 0x4c // float (Size: 0x4)
PaperTileLayer.CollisionOffsetOverride = 0x50 // float (Size: 0x4)
PaperTileLayer.LayerColor = 0x54 // FLinearColor (Size: 0x10)
PaperTileLayer.AllocatedWidth = 0x64 // int32_t (Size: 0x4)
PaperTileLayer.AllocatedHeight = 0x68 // int32_t (Size: 0x4)
PaperTileLayer.AllocatedCells = 0x70 // TArray<FPaperTileInfo> (Size: 0x10)
PaperTileLayer.TileSet = 0x80 // PaperTileSet* (Size: 0x8)
PaperTileLayer.AllocatedGrid = 0x88 // TArray<int32_t> (Size: 0x10)
PaperTileMap.MapWidth = 0x28 // int32_t (Size: 0x4)
PaperTileMap.MapHeight = 0x2c // int32_t (Size: 0x4)
PaperTileMap.TileWidth = 0x30 // int32_t (Size: 0x4)
PaperTileMap.TileHeight = 0x34 // int32_t (Size: 0x4)
PaperTileMap.PixelsPerUnrealUnit = 0x38 // float (Size: 0x4)
PaperTileMap.SeparationPerTileX = 0x3c // float (Size: 0x4)
PaperTileMap.SeparationPerTileY = 0x40 // float (Size: 0x4)
PaperTileMap.SeparationPerLayer = 0x44 // float (Size: 0x4)
PaperTileMap.SelectedTileSet = 0x48 // TSoftObjectPtr<UObject> (Size: 0x28)
PaperTileMap.Material = 0x70 // MaterialInterface* (Size: 0x8)
PaperTileMap.TileLayers = 0x78 // TArray<PaperTileLayer*> (Size: 0x10)
PaperTileMap.CollisionThickness = 0x88 // float (Size: 0x4)
PaperTileMap.SpriteCollisionDomain = 0x8c // uint8_t (Size: 0x1)
PaperTileMap.ProjectionMode = 0x8d // uint8_t (Size: 0x1)
PaperTileMap.HexSideLength = 0x90 // int32_t (Size: 0x4)
PaperTileMap.BodySetup = 0x98 // BodySetup* (Size: 0x8)
PaperTileMap.LayerNameIndex = 0xa0 // int32_t (Size: 0x4)
PaperTileMapActor.RenderComponent = 0x310 // PaperTileMapComponent* (Size: 0x8)
PaperTileMapComponent.MapWidth = 0x600 // int32_t (Size: 0x4)
PaperTileMapComponent.MapHeight = 0x604 // int32_t (Size: 0x4)
PaperTileMapComponent.TileWidth = 0x608 // int32_t (Size: 0x4)
PaperTileMapComponent.TileHeight = 0x60c // int32_t (Size: 0x4)
PaperTileMapComponent.DefaultLayerTileSet = 0x610 // PaperTileSet* (Size: 0x8)
PaperTileMapComponent.Material = 0x618 // MaterialInterface* (Size: 0x8)
PaperTileMapComponent.TileLayers = 0x620 // TArray<PaperTileLayer*> (Size: 0x10)
PaperTileMapComponent.TileMapColor = 0x630 // FLinearColor (Size: 0x10)
PaperTileMapComponent.UseSingleLayerIndex = 0x640 // int32_t (Size: 0x4)
PaperTileMapComponent.bUseSingleLayer = 0x644 // bool (Size: 0x1)
PaperTileMapComponent.TileMap = 0x648 // PaperTileMap* (Size: 0x8)
PaperTileMetadata.UserDataName = 0x0 // FName (Size: 0x8)
PaperTileMetadata.CollisionData = 0x8 // FSpriteGeometryCollection (Size: 0x30)
PaperTileMetadata.TerrainMembership = 0x38 // uint8_t (Size: 0x1)
PaperTileSet.TileSize = 0x28 // FIntPoint (Size: 0x8)
PaperTileSet.TileSheet = 0x30 // Texture2D* (Size: 0x8)
PaperTileSet.AdditionalSourceTextures = 0x38 // TArray<Texture*> (Size: 0x10)
PaperTileSet.BorderMargin = 0x48 // FIntMargin (Size: 0x10)
PaperTileSet.PerTileSpacing = 0x58 // FIntPoint (Size: 0x8)
PaperTileSet.DrawingOffset = 0x60 // FIntPoint (Size: 0x8)
PaperTileSet.WidthInTiles = 0x68 // int32_t (Size: 0x4)
PaperTileSet.HeightInTiles = 0x6c // int32_t (Size: 0x4)
PaperTileSet.AllocatedWidth = 0x70 // int32_t (Size: 0x4)
PaperTileSet.AllocatedHeight = 0x74 // int32_t (Size: 0x4)
PaperTileSet.PerTileData = 0x78 // TArray<FPaperTileMetadata> (Size: 0x10)
PaperTileSet.Terrains = 0x88 // TArray<FPaperTileSetTerrain> (Size: 0x10)
PaperTileSet.TileWidth = 0x98 // int32_t (Size: 0x4)
PaperTileSet.TileHeight = 0x9c // int32_t (Size: 0x4)
PaperTileSet.Margin = 0xa0 // int32_t (Size: 0x4)
PaperTileSet.Spacing = 0xa4 // int32_t (Size: 0x4)
PaperTileSetTerrain.TerrainName = 0x0 // FString (Size: 0x10)
PaperTileSetTerrain.CenterTileIndex = 0x10 // int32_t (Size: 0x4)
SpriteDrawCallRecord.Destination = 0x0 // FVector (Size: 0xc)
SpriteDrawCallRecord.BaseTexture = 0x10 // Texture* (Size: 0x8)
SpriteDrawCallRecord.Color = 0x48 // FColor (Size: 0x4)
SpriteGeometryCollection.Shapes = 0x0 // TArray<FSpriteGeometryShape> (Size: 0x10)
SpriteGeometryCollection.GeometryType = 0x10 // uint8_t (Size: 0x1)
SpriteGeometryCollection.PixelsPerSubdivisionX = 0x14 // int32_t (Size: 0x4)
SpriteGeometryCollection.PixelsPerSubdivisionY = 0x18 // int32_t (Size: 0x4)
SpriteGeometryCollection.bAvoidVertexMerging = 0x1c // bool (Size: 0x1)
SpriteGeometryCollection.AlphaThreshold = 0x20 // float (Size: 0x4)
SpriteGeometryCollection.DetailAmount = 0x24 // float (Size: 0x4)
SpriteGeometryCollection.SimplifyEpsilon = 0x28 // float (Size: 0x4)
SpriteGeometryShape.ShapeType = 0x0 // EESpriteShapeType (Size: 0x1)
SpriteGeometryShape.Vertices = 0x8 // TArray<FVector2D> (Size: 0x10)
SpriteGeometryShape.BoxSize = 0x18 // FVector2D (Size: 0x8)
SpriteGeometryShape.BoxPosition = 0x20 // FVector2D (Size: 0x8)
SpriteGeometryShape.Rotation = 0x28 // float (Size: 0x4)
SpriteGeometryShape.bNegativeWinding = 0x2c // bool (Size: 0x1)
SpriteInstanceData.Transform = 0x0 // FMatrix (Size: 0x40)
SpriteInstanceData.SourceSprite = 0x40 // PaperSprite* (Size: 0x8)
SpriteInstanceData.VertexColor = 0x48 // FColor (Size: 0x4)
SpriteInstanceData.MaterialIndex = 0x4c // int32_t (Size: 0x4)
ReplicatedVehicleState.SteeringInput = 0x0 // float (Size: 0x4)
ReplicatedVehicleState.ThrottleInput = 0x4 // float (Size: 0x4)
ReplicatedVehicleState.BrakeInput = 0x8 // float (Size: 0x4)
ReplicatedVehicleState.HandbrakeInput = 0xc // float (Size: 0x4)
ReplicatedVehicleState.CurrentGear = 0x10 // int32_t (Size: 0x4)
TireConfig.FrictionScale = 0x30 // float (Size: 0x4)
TireConfig.TireFrictionScales = 0x38 // TArray<FTireConfigMaterialFriction> (Size: 0x10)
TireConfigMaterialFriction.PhysicalMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
TireConfigMaterialFriction.FrictionScale = 0x8 // float (Size: 0x4)
VehicleAnimInstance.WheeledVehicleMovementComponent = 0xb40 // WheeledVehicleMovementComponent* (Size: 0x8)
VehicleDifferential4WData.DifferentialType = 0x0 // uint8_t (Size: 0x1)
VehicleDifferential4WData.FrontRearSplit = 0x4 // float (Size: 0x4)
VehicleDifferential4WData.FrontLeftRightSplit = 0x8 // float (Size: 0x4)
VehicleDifferential4WData.RearLeftRightSplit = 0xc // float (Size: 0x4)
VehicleDifferential4WData.CentreBias = 0x10 // float (Size: 0x4)
VehicleDifferential4WData.FrontBias = 0x14 // float (Size: 0x4)
VehicleDifferential4WData.RearBias = 0x18 // float (Size: 0x4)
VehicleEngineData.TorqueCurve = 0x0 // FRuntimeFloatCurve (Size: 0x88)
VehicleEngineData.MaxRPM = 0x88 // float (Size: 0x4)
VehicleEngineData.MOI = 0x8c // float (Size: 0x4)
VehicleEngineData.DampingRateFullThrottle = 0x90 // float (Size: 0x4)
VehicleEngineData.DampingRateZeroThrottleClutchEngaged = 0x94 // float (Size: 0x4)
VehicleEngineData.DampingRateZeroThrottleClutchDisengaged = 0x98 // float (Size: 0x4)
VehicleGearData.Ratio = 0x0 // float (Size: 0x4)
VehicleGearData.DownRatio = 0x4 // float (Size: 0x4)
VehicleGearData.UpRatio = 0x8 // float (Size: 0x4)
VehicleInputRate.RiseRate = 0x0 // float (Size: 0x4)
VehicleInputRate.FallRate = 0x4 // float (Size: 0x4)
VehicleTransmissionData.bUseGearAutoBox = 0x0 // bool (Size: 0x1)
VehicleTransmissionData.GearSwitchTime = 0x4 // float (Size: 0x4)
VehicleTransmissionData.GearAutoBoxLatency = 0x8 // float (Size: 0x4)
VehicleTransmissionData.FinalRatio = 0xc // float (Size: 0x4)
VehicleTransmissionData.ForwardGears = 0x10 // TArray<FVehicleGearData> (Size: 0x10)
VehicleTransmissionData.ReverseGearRatio = 0x20 // float (Size: 0x4)
VehicleTransmissionData.NeutralGearUpRatio = 0x24 // float (Size: 0x4)
VehicleTransmissionData.ClutchStrength = 0x28 // float (Size: 0x4)
VehicleWheel.CollisionMesh = 0x28 // StaticMesh* (Size: 0x8)
VehicleWheel.bDontCreateShape = 0x30 // bool (Size: 0x1)
VehicleWheel.bAutoAdjustCollisionSize = 0x31 // bool (Size: 0x1)
VehicleWheel.Offset = 0x34 // FVector (Size: 0xc)
VehicleWheel.ShapeRadius = 0x40 // float (Size: 0x4)
VehicleWheel.ShapeWidth = 0x44 // float (Size: 0x4)
VehicleWheel.Mass = 0x48 // float (Size: 0x4)
VehicleWheel.DampingRate = 0x4c // float (Size: 0x4)
VehicleWheel.SteerAngle = 0x50 // float (Size: 0x4)
VehicleWheel.bAffectedByHandbrake = 0x54 // bool (Size: 0x1)
VehicleWheel.TireType = 0x58 // TireType* (Size: 0x8)
VehicleWheel.TireConfig = 0x60 // TireConfig* (Size: 0x8)
VehicleWheel.LatStiffMaxLoad = 0x68 // float (Size: 0x4)
VehicleWheel.LatStiffValue = 0x6c // float (Size: 0x4)
VehicleWheel.LongStiffValue = 0x70 // float (Size: 0x4)
VehicleWheel.SuspensionForceOffset = 0x74 // float (Size: 0x4)
VehicleWheel.SuspensionMaxRaise = 0x78 // float (Size: 0x4)
VehicleWheel.SuspensionMaxDrop = 0x7c // float (Size: 0x4)
VehicleWheel.SuspensionNaturalFrequency = 0x80 // float (Size: 0x4)
VehicleWheel.SuspensionDampingRatio = 0x84 // float (Size: 0x4)
VehicleWheel.SweepType = 0x88 // uint8_t (Size: 0x1)
VehicleWheel.MaxBrakeTorque = 0x8c // float (Size: 0x4)
VehicleWheel.MaxHandBrakeTorque = 0x90 // float (Size: 0x4)
VehicleWheel.VehicleSim = 0x98 // WheeledVehicleMovementComponent* (Size: 0x8)
VehicleWheel.WheelIndex = 0xa0 // int32_t (Size: 0x4)
VehicleWheel.DebugLongSlip = 0xa4 // float (Size: 0x4)
VehicleWheel.DebugLatSlip = 0xa8 // float (Size: 0x4)
VehicleWheel.DebugNormalizedTireLoad = 0xac // float (Size: 0x4)
VehicleWheel.DebugWheelTorque = 0xb4 // float (Size: 0x4)
VehicleWheel.DebugLongForce = 0xb8 // float (Size: 0x4)
VehicleWheel.DebugLatForce = 0xbc // float (Size: 0x4)
VehicleWheel.Location = 0xc0 // FVector (Size: 0xc)
VehicleWheel.OldLocation = 0xcc // FVector (Size: 0xc)
VehicleWheel.Velocity = 0xd8 // FVector (Size: 0xc)
WheelSetup.WheelClass = 0x0 // ClassProperty (Size: 0x8)
WheelSetup.BoneName = 0x8 // FName (Size: 0x8)
WheelSetup.AdditionalOffset = 0x10 // FVector (Size: 0xc)
WheelSetup.bDisableSteering = 0x1c // bool (Size: 0x1)
WheeledVehicle.Mesh = 0x380 // SkeletalMeshComponent* (Size: 0x8)
WheeledVehicle.VehicleMovement = 0x388 // WheeledVehicleMovementComponent* (Size: 0x8)
WheeledVehicleMovementComponent.bDeprecatedSpringOffsetMode = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bReverseAsBrake = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bUseRVOAvoidance = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bRawHandbrakeInput = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bRawGearUpInput = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bRawGearDownInput = 0x188 // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.bWasAvoidanceUpdated = 0x18c // uint8_t (Size: 0x1)
WheeledVehicleMovementComponent.Mass = 0x190 // float (Size: 0x4)
WheeledVehicleMovementComponent.WheelSetups = 0x198 // TArray<FWheelSetup> (Size: 0x10)
WheeledVehicleMovementComponent.DragCoefficient = 0x1a8 // float (Size: 0x4)
WheeledVehicleMovementComponent.ChassisWidth = 0x1ac // float (Size: 0x4)
WheeledVehicleMovementComponent.ChassisHeight = 0x1b0 // float (Size: 0x4)
WheeledVehicleMovementComponent.DragArea = 0x1b4 // float (Size: 0x4)
WheeledVehicleMovementComponent.EstimatedMaxEngineSpeed = 0x1b8 // float (Size: 0x4)
WheeledVehicleMovementComponent.MaxEngineRPM = 0x1bc // float (Size: 0x4)
WheeledVehicleMovementComponent.DebugDragMagnitude = 0x1c0 // float (Size: 0x4)
WheeledVehicleMovementComponent.InertiaTensorScale = 0x1c4 // FVector (Size: 0xc)
WheeledVehicleMovementComponent.MinNormalizedTireLoad = 0x1d0 // float (Size: 0x4)
WheeledVehicleMovementComponent.MinNormalizedTireLoadFiltered = 0x1d4 // float (Size: 0x4)
WheeledVehicleMovementComponent.MaxNormalizedTireLoad = 0x1d8 // float (Size: 0x4)
WheeledVehicleMovementComponent.MaxNormalizedTireLoadFiltered = 0x1dc // float (Size: 0x4)
WheeledVehicleMovementComponent.ThresholdLongitudinalSpeed = 0x1e0 // float (Size: 0x4)
WheeledVehicleMovementComponent.LowForwardSpeedSubStepCount = 0x1e4 // int32_t (Size: 0x4)
WheeledVehicleMovementComponent.HighForwardSpeedSubStepCount = 0x1e8 // int32_t (Size: 0x4)
WheeledVehicleMovementComponent.Wheels = 0x1f0 // TArray<VehicleWheel*> (Size: 0x10)
WheeledVehicleMovementComponent.RVOAvoidanceRadius = 0x218 // float (Size: 0x4)
WheeledVehicleMovementComponent.RVOAvoidanceHeight = 0x21c // float (Size: 0x4)
WheeledVehicleMovementComponent.AvoidanceConsiderationRadius = 0x220 // float (Size: 0x4)
WheeledVehicleMovementComponent.RVOSteeringStep = 0x224 // float (Size: 0x4)
WheeledVehicleMovementComponent.RVOThrottleStep = 0x228 // float (Size: 0x4)
WheeledVehicleMovementComponent.AvoidanceUID = 0x22c // int32_t (Size: 0x4)
WheeledVehicleMovementComponent.AvoidanceGroup = 0x230 // FNavAvoidanceMask (Size: 0x4)
WheeledVehicleMovementComponent.GroupsToAvoid = 0x234 // FNavAvoidanceMask (Size: 0x4)
WheeledVehicleMovementComponent.GroupsToIgnore = 0x238 // FNavAvoidanceMask (Size: 0x4)
WheeledVehicleMovementComponent.AvoidanceWeight = 0x23c // float (Size: 0x4)
WheeledVehicleMovementComponent.PendingLaunchVelocity = 0x240 // FVector (Size: 0xc)
WheeledVehicleMovementComponent.ReplicatedState = 0x24c // FReplicatedVehicleState (Size: 0x14)
WheeledVehicleMovementComponent.RawSteeringInput = 0x264 // float (Size: 0x4)
WheeledVehicleMovementComponent.RawThrottleInput = 0x268 // float (Size: 0x4)
WheeledVehicleMovementComponent.RawBrakeInput = 0x26c // float (Size: 0x4)
WheeledVehicleMovementComponent.SteeringInput = 0x270 // float (Size: 0x4)
WheeledVehicleMovementComponent.ThrottleInput = 0x274 // float (Size: 0x4)
WheeledVehicleMovementComponent.BrakeInput = 0x278 // float (Size: 0x4)
WheeledVehicleMovementComponent.HandbrakeInput = 0x27c // float (Size: 0x4)
WheeledVehicleMovementComponent.IdleBrakeInput = 0x280 // float (Size: 0x4)
WheeledVehicleMovementComponent.StopThreshold = 0x284 // float (Size: 0x4)
WheeledVehicleMovementComponent.WrongDirectionThreshold = 0x288 // float (Size: 0x4)
WheeledVehicleMovementComponent.ThrottleInputRate = 0x28c // FVehicleInputRate (Size: 0x8)
WheeledVehicleMovementComponent.BrakeInputRate = 0x294 // FVehicleInputRate (Size: 0x8)
WheeledVehicleMovementComponent.HandbrakeInputRate = 0x29c // FVehicleInputRate (Size: 0x8)
WheeledVehicleMovementComponent.SteeringInputRate = 0x2a4 // FVehicleInputRate (Size: 0x8)
WheeledVehicleMovementComponent.OverrideController = 0x2d0 // Controller* (Size: 0x8)
WheeledVehicleMovementComponent4W.EngineSetup = 0x2d8 // FVehicleEngineData (Size: 0xa0)
WheeledVehicleMovementComponent4W.DifferentialSetup = 0x378 // FVehicleDifferential4WData (Size: 0x1c)
WheeledVehicleMovementComponent4W.AckermannAccuracy = 0x394 // float (Size: 0x4)
WheeledVehicleMovementComponent4W.TransmissionSetup = 0x398 // FVehicleTransmissionData (Size: 0x30)
WheeledVehicleMovementComponent4W.SteeringCurve = 0x3c8 // FRuntimeFloatCurve (Size: 0x88)
BodyInstanceCore.bSimulatePhysics = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bOverrideMass = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bEnableGravity = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bAutoWeld = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bStartAwake = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bGenerateWakeEvents = 0x10 // uint8_t (Size: 0x1)
BodyInstanceCore.bUpdateMassWhenScaleChanges = 0x10 // uint8_t (Size: 0x1)
BodySetupCore.BoneName = 0x28 // FName (Size: 0x8)
BodySetupCore.PhysicsType = 0x30 // uint8_t (Size: 0x1)
BodySetupCore.CollisionTraceFlag = 0x31 // uint8_t (Size: 0x1)
BodySetupCore.CollisionReponse = 0x32 // uint8_t (Size: 0x1)
ChaosPhysicalMaterial.Friction = 0x28 // float (Size: 0x4)
ChaosPhysicalMaterial.StaticFriction = 0x2c // float (Size: 0x4)
ChaosPhysicalMaterial.Restitution = 0x30 // float (Size: 0x4)
ChaosPhysicalMaterial.LinearEtherDrag = 0x34 // float (Size: 0x4)
ChaosPhysicalMaterial.AngularEtherDrag = 0x38 // float (Size: 0x4)
ChaosPhysicalMaterial.SleepingLinearVelocityThreshold = 0x3c // float (Size: 0x4)
ChaosPhysicalMaterial.SleepingAngularVelocityThreshold = 0x40 // float (Size: 0x4)
PhysicalMaterial.Friction = 0x28 // float (Size: 0x4)
PhysicalMaterial.StaticFriction = 0x2c // float (Size: 0x4)
PhysicalMaterial.FrictionCombineMode = 0x30 // uint8_t (Size: 0x1)
PhysicalMaterial.bOverrideFrictionCombineMode = 0x31 // bool (Size: 0x1)
PhysicalMaterial.Restitution = 0x34 // float (Size: 0x4)
PhysicalMaterial.RestitutionCombineMode = 0x38 // uint8_t (Size: 0x1)
PhysicalMaterial.bOverrideRestitutionCombineMode = 0x39 // bool (Size: 0x1)
PhysicalMaterial.Density = 0x3c // float (Size: 0x4)
PhysicalMaterial.SleepLinearVelocityThreshold = 0x40 // float (Size: 0x4)
PhysicalMaterial.SleepAngularVelocityThreshold = 0x44 // float (Size: 0x4)
PhysicalMaterial.SleepCounterThreshold = 0x48 // int32_t (Size: 0x4)
PhysicalMaterial.RaiseMassToPower = 0x4c // float (Size: 0x4)
PhysicalMaterial.DestructibleDamageThresholdScale = 0x50 // float (Size: 0x4)
PhysicalMaterial.PhysicalMaterialProperty = 0x58 // PhysicalMaterialPropertyBase* (Size: 0x8)
PhysicalMaterial.SurfaceType = 0x60 // uint8_t (Size: 0x1)
PhysicsSettingsCore.DefaultGravityZ = 0x38 // float (Size: 0x4)
PhysicsSettingsCore.DefaultTerminalVelocity = 0x3c // float (Size: 0x4)
PhysicsSettingsCore.DefaultFluidFriction = 0x40 // float (Size: 0x4)
PhysicsSettingsCore.SimulateScratchMemorySize = 0x44 // int32_t (Size: 0x4)
PhysicsSettingsCore.RagdollAggregateThreshold = 0x48 // int32_t (Size: 0x4)
PhysicsSettingsCore.TriangleMeshTriangleMinAreaThreshold = 0x4c // float (Size: 0x4)
PhysicsSettingsCore.bEnableShapeSharing = 0x50 // bool (Size: 0x1)
PhysicsSettingsCore.bEnablePCM = 0x51 // bool (Size: 0x1)
PhysicsSettingsCore.bEnableStabilization = 0x52 // bool (Size: 0x1)
PhysicsSettingsCore.bWarnMissingLocks = 0x53 // bool (Size: 0x1)
PhysicsSettingsCore.bEnable2DPhysics = 0x54 // bool (Size: 0x1)
PhysicsSettingsCore.bDefaultHasComplexCollision = 0x55 // bool (Size: 0x1)
PhysicsSettingsCore.BounceThresholdVelocity = 0x58 // float (Size: 0x4)
PhysicsSettingsCore.FrictionCombineMode = 0x5c // uint8_t (Size: 0x1)
PhysicsSettingsCore.RestitutionCombineMode = 0x5d // uint8_t (Size: 0x1)
PhysicsSettingsCore.MaxAngularVelocity = 0x60 // float (Size: 0x4)
PhysicsSettingsCore.MaxDepenetrationVelocity = 0x64 // float (Size: 0x4)
PhysicsSettingsCore.ContactOffsetMultiplier = 0x68 // float (Size: 0x4)
PhysicsSettingsCore.MinContactOffset = 0x6c // float (Size: 0x4)
PhysicsSettingsCore.MaxContactOffset = 0x70 // float (Size: 0x4)
PhysicsSettingsCore.bSimulateSkeletalMeshOnDedicatedServer = 0x74 // bool (Size: 0x1)
PhysicsSettingsCore.DefaultShapeComplexity = 0x75 // uint8_t (Size: 0x1)
PhysicsSettingsCore.SolverOptions = 0x78 // FChaosSolverConfiguration (Size: 0x68)
PixUIInput.DelegateActivateInput = 0x28 // FDelegate (Size: 0x10)
PixUIInput.DelegateDeactivateInput = 0x38 // FDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnCreate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnClose = 0x38 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnDestroy = 0x48 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnLoaded = 0x58 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnScriptStateInit = 0x68 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnScriptStateDone = 0x78 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnInternalError = 0x88 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnExternalOpen = 0x98 // FDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnExternalClose = 0xa8 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnMessage = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnAlert = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnConfirm = 0xd8 // FDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnPrompt = 0xe8 // FDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnAppForeground = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.DelegateOnAppBackground = 0x108 // FMulticastInlineDelegate (Size: 0x10)
PixUIRenderTarget.pxLibVersionTag = 0x118 // int32_t (Size: 0x4)
PixUIScriptVM.DelegateOnCreate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnClose = 0x38 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnDestroy = 0x48 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnLoaded = 0x58 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnScriptStateInit = 0x68 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnScriptStateDone = 0x78 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnInternalError = 0x88 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnExternalOpen = 0x98 // FDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnExternalClose = 0xa8 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnMessage = 0xb8 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnAppForeground = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.DelegateOnAppBackground = 0xd8 // FMulticastInlineDelegate (Size: 0x10)
PixUIScriptVM.pxLibVersionTag = 0xe8 // int32_t (Size: 0x4)
PixUIViewPortWidget.PixUIWidgetOpenDelegate = 0x290 // FDelegate (Size: 0x10)
PixUIViewPortWidget.PixUIWidgetConfirmDelegate = 0x2a0 // FDelegate (Size: 0x10)
PixUIViewPortWidget.PixUIWidgetPromptDelegate = 0x2b0 // FDelegate (Size: 0x10)
PixUIWidget.DelegateOnCreate = 0x160 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnClose = 0x170 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnDestroy = 0x180 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnLoaded = 0x190 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnScriptStateInit = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnScriptStateDone = 0x1b0 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnInternalError = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnExternalOpen = 0x1d0 // FDelegate (Size: 0x10)
PixUIWidget.DelegateOnExternalClose = 0x1e0 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnMessage = 0x1f0 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnAlert = 0x200 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnConfirm = 0x210 // FDelegate (Size: 0x10)
PixUIWidget.DelegateOnPrompt = 0x220 // FDelegate (Size: 0x10)
PixUIWidget.DelegateOnTransform = 0x230 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnAppForeground = 0x240 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateOnAppBackground = 0x250 // FMulticastInlineDelegate (Size: 0x10)
PixUIWidget.DelegateHookKeyEvent = 0x260 // FDelegate (Size: 0x10)
PixUIWidget.bIsAsync = 0x270 // bool (Size: 0x1)
PixUIWidget.bIsForcePaint = 0x271 // bool (Size: 0x1)
PixUIWidget.bIsLazyReleaseMode = 0x272 // bool (Size: 0x1)
PixUIWidget.batchType = 0x273 // EEPxWidgetBatchType (Size: 0x1)
PixUIWidget.TextDefaultUrl = 0x278 // FText (Size: 0x18)
PixUIWidget.bIsStateNodeMode = 0x290 // bool (Size: 0x1)
PixUIWidget.bIsRHIRender = 0x291 // bool (Size: 0x1)
PixUIWidget.bIsRHIRenderAntiAliasing = 0x292 // bool (Size: 0x1)
PixUIWidget.bPxSlotTopHit = 0x293 // bool (Size: 0x1)
PixUIWidget.bIsRetainMode = 0x294 // bool (Size: 0x1)
PixUIWidget.bNoPixelSnapping = 0x295 // bool (Size: 0x1)
PixUIWidget.pxLibVersionTag = 0x298 // int32_t (Size: 0x4)
PxLogMgr.LogDelegate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
PortalRpcLocateServer.ProductId = 0x0 // FGuid (Size: 0x10)
PortalRpcLocateServer.ProductVersion = 0x10 // FString (Size: 0x10)
PortalRpcLocateServer.HostMacAddress = 0x20 // FString (Size: 0x10)
PortalRpcLocateServer.HostUserId = 0x30 // FString (Size: 0x10)
PortalRpcServer.ServerAddress = 0x0 // FString (Size: 0x10)
PortalUserDetails.DisplayName = 0x0 // FText (Size: 0x18)
PortalUserDetails.Email = 0x18 // FText (Size: 0x18)
PortalUserDetails.RealName = 0x30 // FText (Size: 0x18)
PortalUserDetails.IsSignedIn = 0x48 // bool (Size: 0x1)
PortalUserIsEntitledToItemResult.ItemId = 0x0 // FString (Size: 0x10)
PortalUserIsEntitledToItemResult.IsEntitled = 0x10 // bool (Size: 0x1)
PortalUserIsEntitledToItemResult.RetrievedFromCacheLevel = 0x11 // EEEntitlementCacheLevelRetrieved (Size: 0x1)
ProcMeshSection.ProcVertexBuffer = 0x0 // TArray<FProcMeshVertex> (Size: 0x10)
ProcMeshSection.ProcIndexBuffer = 0x10 // TArray<uint32_t> (Size: 0x10)
ProcMeshSection.SectionLocalBox = 0x20 // FBox (Size: 0x1c)
ProcMeshSection.bEnableCollision = 0x3c // bool (Size: 0x1)
ProcMeshSection.bSectionVisible = 0x3d // bool (Size: 0x1)
ProcMeshTangent.TangentX = 0x0 // FVector (Size: 0xc)
ProcMeshTangent.bFlipTangentY = 0xc // bool (Size: 0x1)
ProcMeshVertex.position = 0x0 // FVector (Size: 0xc)
ProcMeshVertex.Normal = 0xc // FVector (Size: 0xc)
ProcMeshVertex.Tangent = 0x18 // FProcMeshTangent (Size: 0x10)
ProcMeshVertex.Color = 0x28 // FColor (Size: 0x4)
ProcMeshVertex.UV0 = 0x2c // FVector2D (Size: 0x8)
ProcMeshVertex.UV1 = 0x34 // FVector2D (Size: 0x8)
ProcMeshVertex.UV2 = 0x3c // FVector2D (Size: 0x8)
ProcMeshVertex.UV3 = 0x44 // FVector2D (Size: 0x8)
ProceduralMeshComponent.bUseComplexAsSimpleCollision = 0x608 // bool (Size: 0x1)
ProceduralMeshComponent.bUseAsyncCooking = 0x609 // bool (Size: 0x1)
ProceduralMeshComponent.ProcMeshBodySetup = 0x610 // BodySetup* (Size: 0x8)
ProceduralMeshComponent.ProcMeshSections = 0x618 // TArray<FProcMeshSection> (Size: 0x10)
ProceduralMeshComponent.CollisionConvexElems = 0x628 // TArray<FKConvexElem> (Size: 0x10)
ProceduralMeshComponent.LocalBounds = 0x638 // FBoxSphereBounds (Size: 0x1c)
ProceduralMeshComponent.AsyncBodySetupQueue = 0x658 // TArray<BodySetup*> (Size: 0x10)
PropertyAccessCopy.AccessIndex = 0x0 // int32_t (Size: 0x4)
PropertyAccessCopy.DestAccessStartIndex = 0x4 // int32_t (Size: 0x4)
PropertyAccessCopy.DestAccessEndIndex = 0x8 // int32_t (Size: 0x4)
PropertyAccessCopy.Type = 0xc // EEPropertyAccessCopyType (Size: 0x1)
PropertyAccessCopyBatch.Copies = 0x0 // TArray<FPropertyAccessCopy> (Size: 0x10)
PropertyAccessIndirection.ArrayProperty = 0x0 // FieldPathProperty (Size: 0x20)
PropertyAccessIndirection.Function = 0x20 // Function* (Size: 0x8)
PropertyAccessIndirection.ReturnBufferSize = 0x28 // int32_t (Size: 0x4)
PropertyAccessIndirection.ReturnBufferAlignment = 0x2c // int32_t (Size: 0x4)
PropertyAccessIndirection.ArrayIndex = 0x30 // int32_t (Size: 0x4)
PropertyAccessIndirection.Offset = 0x34 // uint32_t (Size: 0x4)
PropertyAccessIndirection.ObjectType = 0x38 // EEPropertyAccessObjectType (Size: 0x1)
PropertyAccessIndirection.Type = 0x39 // EEPropertyAccessIndirectionType (Size: 0x1)
PropertyAccessIndirectionChain.Property = 0x0 // FieldPathProperty (Size: 0x20)
PropertyAccessIndirectionChain.IndirectionStartIndex = 0x20 // int32_t (Size: 0x4)
PropertyAccessIndirectionChain.IndirectionEndIndex = 0x24 // int32_t (Size: 0x4)
PropertyAccessIndirectionChain.eventId = 0x28 // int32_t (Size: 0x4)
PropertyAccessLibrary.PathSegments = 0x0 // TArray<FPropertyAccessSegment> (Size: 0x10)
PropertyAccessLibrary.SrcPaths = 0x10 // TArray<FPropertyAccessPath> (Size: 0x10)
PropertyAccessLibrary.DestPaths = 0x20 // TArray<FPropertyAccessPath> (Size: 0x10)
PropertyAccessLibrary.CopyBatches = 0x30 // FPropertyAccessCopyBatch (Size: 0x10)
PropertyAccessLibrary.SrcAccesses = 0x70 // TArray<FPropertyAccessIndirectionChain> (Size: 0x10)
PropertyAccessLibrary.DestAccesses = 0x80 // TArray<FPropertyAccessIndirectionChain> (Size: 0x10)
PropertyAccessLibrary.Indirections = 0x90 // TArray<FPropertyAccessIndirection> (Size: 0x10)
PropertyAccessLibrary.EventAccessIndices = 0xa0 // TArray<int32_t> (Size: 0x10)
PropertyAccessPath.PathSegmentStartIndex = 0x0 // int32_t (Size: 0x4)
PropertyAccessPath.PathSegmentCount = 0x4 // int32_t (Size: 0x4)
PropertyAccessPath.bHasEvents = 0x8 // uint8_t (Size: 0x1)
PropertyAccessSegment.Name = 0x0 // FName (Size: 0x8)
PropertyAccessSegment.Struct = 0x8 // Struct* (Size: 0x8)
PropertyAccessSegment.Property = 0x10 // FieldPathProperty (Size: 0x20)
PropertyAccessSegment.Function = 0x30 // Function* (Size: 0x8)
PropertyAccessSegment.ArrayIndex = 0x38 // int32_t (Size: 0x4)
PropertyAccessSegment.Flags = 0x3c // uint16_t (Size: 0x2)
CachedPropertyPath.Segments = 0x0 // TArray<FPropertyPathSegment> (Size: 0x10)
CachedPropertyPath.CachedFunction = 0x18 // Function* (Size: 0x8)
PropertyPathSegment.Name = 0x0 // FName (Size: 0x8)
PropertyPathSegment.ArrayIndex = 0x8 // int32_t (Size: 0x4)
PropertyPathSegment.Struct = 0x10 // Struct* (Size: 0x8)
ReliefMapUserData.ReliefMapType = 0x28 // uint8_t (Size: 0x1)
ReliefMapUserData.HeightMap = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
ReliefMapUserData.HeightMapChannel = 0x58 // uint8_t (Size: 0x1)
ReliefMapUserData.CommonResolutions = 0x59 // uint8_t (Size: 0x1)
ReliefMapUserData.Resolution = 0x5c // FIntPoint (Size: 0x8)
ReliefMapUserData.IterationBucketSize = 0x64 // int32_t (Size: 0x4)
ReliefMapUserData.BlackPoint = 0x68 // float (Size: 0x4)
ReliefMapUserData.WhitePoint = 0x6c // float (Size: 0x4)
ReliefMapUserData.Floor = 0x70 // float (Size: 0x4)
ReliefMapUserData.Ceiling = 0x74 // float (Size: 0x4)
ReliefMapUserData.Bias = 0x78 // float (Size: 0x4)
ReliefMapUserData.MinHeight = 0x7c // float (Size: 0x4)
ReliefMappingGeneratorInput.HeightMap = 0x0 // Texture2D* (Size: 0x8)
ReliefMappingGeneratorRCSM.Input = 0x30 // FReliefMappingGeneratorInput (Size: 0x40)
ReliefMappingGeneratorRCSM.Output = 0x70 // TextureRenderTarget2D* (Size: 0x8)
ReliefMappingTestActor.Input = 0x310 // Texture2D* (Size: 0x8)
ReliefMappingTestActor.InputChannel = 0x318 // uint8_t (Size: 0x1)
ReliefMappingTestActor.Output = 0x320 // TextureRenderTarget2D* (Size: 0x8)
LightPropagationVolumeSettings.bOverride_LPVIntensity = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVDirectionalOcclusionIntensity = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVDirectionalOcclusionRadius = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVDiffuseOcclusionExponent = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVSpecularOcclusionExponent = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVDiffuseOcclusionIntensity = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVSpecularOcclusionIntensity = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVSize = 0x0 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVSecondaryOcclusionIntensity = 0x1 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVSecondaryBounceIntensity = 0x1 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVGeometryVolumeBias = 0x1 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVVplInjectionBias = 0x1 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.bOverride_LPVEmissiveInjectionIntensity = 0x1 // uint8_t (Size: 0x1)
LightPropagationVolumeSettings.LPVIntensity = 0x4 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVVplInjectionBias = 0x8 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVSize = 0xc // float (Size: 0x4)
LightPropagationVolumeSettings.LPVSecondaryOcclusionIntensity = 0x10 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVSecondaryBounceIntensity = 0x14 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVGeometryVolumeBias = 0x18 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVEmissiveInjectionIntensity = 0x1c // float (Size: 0x4)
LightPropagationVolumeSettings.LPVDirectionalOcclusionIntensity = 0x20 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVDirectionalOcclusionRadius = 0x24 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVDiffuseOcclusionExponent = 0x28 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVSpecularOcclusionExponent = 0x2c // float (Size: 0x4)
LightPropagationVolumeSettings.LPVDiffuseOcclusionIntensity = 0x30 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVSpecularOcclusionIntensity = 0x34 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVFadeRange = 0x38 // float (Size: 0x4)
LightPropagationVolumeSettings.LPVDirectionalOcclusionFadeRange = 0x3c // float (Size: 0x4)
ShadowCaptureParameters.ESMConstant = 0x0 // float (Size: 0x4)
ShadowCaptureParameters.ESMBlurSize = 0x4 // float (Size: 0x4)
ShadowCaptureParameters.KernelSigmaScale = 0x8 // float (Size: 0x4)
ShadowCaptureParameters.bESMUseNoise = 0xc // bool (Size: 0x1)
ShadowCaptureParameters.ESMNoiseFrequency = 0x10 // float (Size: 0x4)
ShadowCaptureParameters.bESMUseOBB = 0x14 // bool (Size: 0x1)
ShadowCaptureParameters.ESMTextureFormat = 0x18 // int32_t (Size: 0x4)
ShadowCaptureParameters.ESMFadeStartDistance = 0x1c // float (Size: 0x4)
ShadowCaptureParameters.ESMFadeEndDistance = 0x20 // float (Size: 0x4)
ShadowCaptureParameters.Method = 0x24 // EEShadowCaptureMethod (Size: 0x1)
RenderingHookerSettings.Materials = 0x28 // TArray<FString> (Size: 0x10)
AlwaysRelevantActorInfo.Connection = 0x0 // NetConnection* (Size: 0x8)
AlwaysRelevantActorInfo.LastViewer = 0x8 // Actor* (Size: 0x8)
AlwaysRelevantActorInfo.LastViewTarget = 0x10 // Actor* (Size: 0x8)
BasicReplicationGraph.GridNode = 0x4b0 // ReplicationGraphNode_GridSpatialization2D* (Size: 0x8)
BasicReplicationGraph.AlwaysRelevantNode = 0x4b8 // ReplicationGraphNode_ActorList* (Size: 0x8)
BasicReplicationGraph.AlwaysRelevantForConnectionList = 0x4c0 // TArray<FConnectionAlwaysRelevantNodePair> (Size: 0x10)
BasicReplicationGraph.ActorsWithoutNetConnection = 0x4d0 // TArray<Actor*> (Size: 0x10)
ClassReplicationInfo.DistancePriorityScale = 0x0 // float (Size: 0x4)
ClassReplicationInfo.StarvationPriorityScale = 0x4 // float (Size: 0x4)
ClassReplicationInfo.AccumulatedNetPriorityBias = 0x8 // float (Size: 0x4)
ClassReplicationInfo.ReplicationPeriodFrame = 0xc // uint16_t (Size: 0x2)
ClassReplicationInfo.FastPath_ReplicationPeriodFrame = 0xe // uint16_t (Size: 0x2)
ClassReplicationInfo.ActorChannelFrameTimeout = 0x10 // uint16_t (Size: 0x2)
ClassReplicationInfo.CullDistance = 0x68 // float (Size: 0x4)
ClassReplicationInfo.CullDistanceSquared = 0x6c // float (Size: 0x4)
ConnectionAlwaysRelevantNodePair.NetConnection = 0x0 // NetConnection* (Size: 0x8)
ConnectionAlwaysRelevantNodePair.Node = 0x8 // ReplicationGraphNode_AlwaysRelevant_ForConnection* (Size: 0x8)
DynamicCharacterRepInfo.Actor = 0x0 // Actor* (Size: 0x8)
DynamicCharacterRepInfo.ReplicationPeriodFrame = 0x8 // uint32_t (Size: 0x4)
DynamicCharacterRepInfo.FastPath_ReplicationPeriodFrame = 0xc // uint32_t (Size: 0x4)
DynamicCharacterRepInfo.FastShare_ReplicationIndex = 0x10 // uint32_t (Size: 0x4)
DynamicCharacterRepInfo.Default_ReplicationIndex = 0x14 // uint32_t (Size: 0x4)
DynamicCharacterRepInfo.NetPriority = 0x18 // float (Size: 0x4)
DynamicCharacterRepInfo.ExtraNetPriority = 0x1c // float (Size: 0x4)
DynamicCharacterRepInfo.bReplicate_FastShare = 0x20 // bool (Size: 0x1)
LastLocationGatherInfo.Connection = 0x0 // NetConnection* (Size: 0x8)
LastLocationGatherInfo.LastLocation = 0x8 // FVector (Size: 0xc)
LastLocationGatherInfo.LastOutOfRangeLocationCheck = 0x14 // FVector (Size: 0xc)
NetReplicationGraphConnection.NetConnection = 0x28 // NetConnection* (Size: 0x8)
NetReplicationGraphConnection.DebugActor = 0x170 // ReplicationGraphDebugActor* (Size: 0x8)
NetReplicationGraphConnection.LastGatherLocations = 0x188 // TArray<FLastLocationGatherInfo> (Size: 0x10)
NetReplicationGraphConnection.ConnectionGraphNodes = 0x1a0 // TArray<ReplicationGraphNode*> (Size: 0x10)
NetReplicationGraphConnection.TearOffNode = 0x1b0 // ReplicationGraphNode_TearOff_ForConnection* (Size: 0x8)
NetReplicationGraphConnection.OwnerReplicationGraph = 0x238 // ReplicationGraph* (Size: 0x8)
ReplicationGraph.ReplicationConnectionManagerClass = 0x28 // ClassProperty (Size: 0x8)
ReplicationGraph.NetDriver = 0x30 // NetDriver* (Size: 0x8)
ReplicationGraph.Connections = 0x38 // TArray<NetReplicationGraphConnection*> (Size: 0x10)
ReplicationGraph.PendingConnections = 0x48 // TArray<NetReplicationGraphConnection*> (Size: 0x10)
ReplicationGraph.GlobalGraphNodes = 0x98 // TArray<ReplicationGraphNode*> (Size: 0x10)
ReplicationGraph.PrepareForReplicationNodes = 0xa8 // TArray<ReplicationGraphNode*> (Size: 0x10)
ReplicationGraphDebugActor.ReplicationGraph = 0x310 // ReplicationGraph* (Size: 0x8)
ReplicationGraphDebugActor.ConnectionManager = 0x318 // NetReplicationGraphConnection* (Size: 0x8)
ReplicationGraphDebugActor.DynamicCharacterRepInfos = 0x320 // TArray<FDynamicCharacterRepInfo> (Size: 0x10)
ReplicationGraphNode.AllChildNodes = 0x28 // TArray<ReplicationGraphNode*> (Size: 0x10)
ReplicationGraphNode_AlwaysRelevant.ChildNode = 0x50 // ReplicationGraphNode* (Size: 0x8)
ReplicationGraphNode_AlwaysRelevant_ForConnection.PastRelevantActors = 0x110 // TArray<FAlwaysRelevantActorInfo> (Size: 0x10)
ReplicationGraphNode_GridCell.DynamicNode = 0x180 // ReplicationGraphNode* (Size: 0x8)
ReplicationGraphNode_GridCell.DormancyNode = 0x188 // ReplicationGraphNode_DormancyNode* (Size: 0x8)
ReplicationGraphNode_TearOff_ForConnection.TearOffActors = 0x50 // TArray<FTearOffActorInfo> (Size: 0x10)
TearOffActorInfo.Actor = 0x8 // Actor* (Size: 0x8)
DynamicRichTextBlockDecorator.bReveal = 0x28 // bool (Size: 0x1)
DynamicRichTextBlockDecorator.RevealedIndex = 0x2c // int32_t (Size: 0x4)
DynamicRichTextBlockDecorator.ParentRichTextBox = 0x30 // RichTextBox* (Size: 0x8)
DynamicRichTextBlockDecorator.m_UObjectRefArray = 0x38 // TArray<Object*> (Size: 0x10)
RichTextBox.Text = 0x150 // FText (Size: 0x18)
RichTextBox.TextDelegate = 0x168 // FDelegate (Size: 0x10)
RichTextBox.Font = 0x178 // FSlateFontInfo (Size: 0x60)
RichTextBox.Color = 0x1d8 // FLinearColor (Size: 0x10)
RichTextBox.Decorators = 0x1e8 // TArray<DynamicRichTextBlockDecorator*> (Size: 0x10)
RichTextBox.OnHyperlinkClicked = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
RichTextBox.OnDynamicTextAppended = 0x208 // FMulticastInlineDelegate (Size: 0x10)
RichTextBox.HighLightText = 0x218 // FText (Size: 0x18)
RichTextBox.LocalizationFeature = 0x230 // int32_t (Size: 0x4)
RichTextBox.LocalizationUpper = 0x234 // bool (Size: 0x1)
RichTextBox.bShowDetail = 0x235 // bool (Size: 0x1)
RichTextBox.bHandleLongText = 0x236 // bool (Size: 0x1)
RichTextBox.MaxTextLength = 0x238 // int32_t (Size: 0x4)
RichTextBox.bEnableAutoTruncate = 0x23d // bool (Size: 0x1)
CoordinateSystem.XAxis = 0x0 // EEDirection (Size: 0x1)
CoordinateSystem.YAxis = 0x1 // EEDirection (Size: 0x1)
CoordinateSystem.ZAxis = 0x2 // EEDirection (Size: 0x1)
DNAAsset.DNAFileName = 0x28 // FString (Size: 0x10)
MeshBlendShapeChannelMapping.MeshIndex = 0x0 // int32_t (Size: 0x4)
MeshBlendShapeChannelMapping.BlendShapeChannelIndex = 0x4 // int32_t (Size: 0x4)
RigUnit_RigLogic.Data = 0x68 // FRigUnit_RigLogic_Data (Size: 0x80)
RigUnit_RigLogic_Data.SkelMeshComponent = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
RigUnit_RigLogic_Data.InputCurveIndices = 0x18 // TArray<int32_t> (Size: 0x10)
RigUnit_RigLogic_Data.HierarchyBoneIndices = 0x28 // TArray<int32_t> (Size: 0x10)
RigUnit_RigLogic_Data.MorphTargetCurveIndices = 0x38 // TArray<FRigUnit_RigLogic_IntArray> (Size: 0x10)
RigUnit_RigLogic_Data.BlendShapeIndices = 0x48 // TArray<FRigUnit_RigLogic_IntArray> (Size: 0x10)
RigUnit_RigLogic_Data.CurveContainerIndicesForAnimMaps = 0x58 // TArray<FRigUnit_RigLogic_IntArray> (Size: 0x10)
RigUnit_RigLogic_Data.RigLogicIndicesForAnimMaps = 0x68 // TArray<FRigUnit_RigLogic_IntArray> (Size: 0x10)
RigUnit_RigLogic_Data.CurrentLOD = 0x78 // uint32_t (Size: 0x4)
RigUnit_RigLogic_IntArray.Values = 0x0 // TArray<int32_t> (Size: 0x10)
TextureCoordinate.U = 0x0 // float (Size: 0x4)
TextureCoordinate.V = 0x4 // float (Size: 0x4)
VertexLayout.position = 0x0 // int32_t (Size: 0x4)
VertexLayout.TextureCoordinate = 0x4 // int32_t (Size: 0x4)
VertexLayout.Normal = 0x8 // int32_t (Size: 0x4)
RigVM.WorkMemoryStorage = 0x28 // FRigVMMemoryContainer (Size: 0xa0)
RigVM.LiteralMemoryStorage = 0xd0 // FRigVMMemoryContainer (Size: 0xa0)
RigVM.ByteCodeStorage = 0x178 // FRigVMByteCode (Size: 0x30)
RigVM.Instructions = 0x1b0 // FRigVMInstructionArray (Size: 0x10)
RigVM.Context = 0x1c0 // FRigVMExecuteContext (Size: 0x58)
RigVM.FunctionNamesStorage = 0x218 // TArray<FName> (Size: 0x10)
RigVM.Parameters = 0x248 // TArray<FRigVMParameter> (Size: 0x10)
RigVM.ParametersNameMap = 0x258 // TMap<...> (Size: 0x50)
RigVM.DeferredVMToCopy = 0x2f0 // RigVM* (Size: 0x8)
RigVMByteCode.ByteCode = 0x0 // TArray<uint8_t> (Size: 0x10)
RigVMByteCode.NumInstructions = 0x10 // int32_t (Size: 0x4)
RigVMByteCode.Entries = 0x18 // TArray<FRigVMByteCodeEntry> (Size: 0x10)
RigVMByteCodeEntry.Name = 0x0 // FName (Size: 0x8)
RigVMByteCodeEntry.InstructionIndex = 0x8 // int32_t (Size: 0x4)
RigVMByteCodeStatistics.InstructionCount = 0x0 // uint32_t (Size: 0x4)
RigVMByteCodeStatistics.DataBytes = 0x4 // uint32_t (Size: 0x4)
RigVMInstruction.ByteCodeIndex = 0x0 // uint64_t (Size: 0x8)
RigVMInstruction.OpCode = 0x8 // EERigVMOpCode (Size: 0x1)
RigVMInstruction.OperandAlignment = 0x9 // uint8_t (Size: 0x1)
RigVMInstructionArray.Instructions = 0x0 // TArray<FRigVMInstruction> (Size: 0x10)
RigVMMemoryContainer.bUseNameMap = 0x0 // bool (Size: 0x1)
RigVMMemoryContainer.MemoryType = 0x1 // EERigVMMemoryType (Size: 0x1)
RigVMMemoryContainer.Registers = 0x8 // TArray<FRigVMRegister> (Size: 0x10)
RigVMMemoryContainer.RegisterOffsets = 0x18 // TArray<FRigVMRegisterOffset> (Size: 0x10)
RigVMMemoryContainer.Data = 0x28 // TArray<uint8_t> (Size: 0x10)
RigVMMemoryContainer.ScriptStructs = 0x38 // TArray<ScriptStruct*> (Size: 0x10)
RigVMMemoryContainer.NameMap = 0x48 // TMap<...> (Size: 0x50)
RigVMMemoryContainer.bEncounteredErrorDuringLoad = 0x98 // bool (Size: 0x1)
RigVMMemoryStatistics.RegisterCount = 0x0 // uint32_t (Size: 0x4)
RigVMMemoryStatistics.DataBytes = 0x4 // uint32_t (Size: 0x4)
RigVMMemoryStatistics.TotalBytes = 0x8 // uint32_t (Size: 0x4)
RigVMOperand.MemoryType = 0x0 // EERigVMMemoryType (Size: 0x1)
RigVMOperand.RegisterIndex = 0x2 // uint16_t (Size: 0x2)
RigVMOperand.RegisterOffset = 0x4 // uint16_t (Size: 0x2)
RigVMParameter.Type = 0x0 // EERigVMParameterType (Size: 0x1)
RigVMParameter.Name = 0x4 // FName (Size: 0x8)
RigVMParameter.RegisterIndex = 0xc // int32_t (Size: 0x4)
RigVMParameter.CPPType = 0x10 // FString (Size: 0x10)
RigVMParameter.ScriptStruct = 0x20 // ScriptStruct* (Size: 0x8)
RigVMParameter.ScriptStructPath = 0x28 // FName (Size: 0x8)
RigVMRegister.Type = 0x0 // EERigVMRegisterType (Size: 0x1)
RigVMRegister.ByteIndex = 0x4 // uint32_t (Size: 0x4)
RigVMRegister.ElementSize = 0x8 // uint16_t (Size: 0x2)
RigVMRegister.ElementCount = 0xa // uint16_t (Size: 0x2)
RigVMRegister.SliceCount = 0xc // uint16_t (Size: 0x2)
RigVMRegister.AlignmentBytes = 0xe // uint8_t (Size: 0x1)
RigVMRegister.TrailingBytes = 0x10 // uint16_t (Size: 0x2)
RigVMRegister.Name = 0x14 // FName (Size: 0x8)
RigVMRegister.ScriptStructIndex = 0x1c // int32_t (Size: 0x4)
RigVMRegister.bIsArray = 0x20 // bool (Size: 0x1)
RigVMRegister.bIsDynamic = 0x21 // bool (Size: 0x1)
RigVMRegisterOffset.Segments = 0x0 // TArray<int32_t> (Size: 0x10)
RigVMRegisterOffset.Type = 0x10 // EERigVMRegisterType (Size: 0x1)
RigVMRegisterOffset.CPPType = 0x14 // FName (Size: 0x8)
RigVMRegisterOffset.ScriptStruct = 0x20 // ScriptStruct* (Size: 0x8)
RigVMRegisterOffset.ParentScriptStruct = 0x28 // ScriptStruct* (Size: 0x8)
RigVMRegisterOffset.ArrayIndex = 0x30 // int32_t (Size: 0x4)
RigVMRegisterOffset.ElementSize = 0x34 // uint16_t (Size: 0x2)
RigVMRegisterOffset.CachedSegmentPath = 0x38 // FString (Size: 0x10)
RigVMStatistics.BytesForCDO = 0x0 // uint32_t (Size: 0x4)
RigVMStatistics.BytesPerInstance = 0x4 // uint32_t (Size: 0x4)
RigVMStatistics.LiteralMemory = 0x8 // FRigVMMemoryStatistics (Size: 0xc)
RigVMStatistics.WorkMemory = 0x14 // FRigVMMemoryStatistics (Size: 0xc)
RigVMStatistics.BytesForCaching = 0x20 // uint32_t (Size: 0x4)
RigVMStatistics.ByteCode = 0x24 // FRigVMByteCodeStatistics (Size: 0x8)
AICausePVPMessage.AIID = 0x0 // int64_t (Size: 0x8)
AICausePVPMessage.PGID = 0x8 // int64_t (Size: 0x8)
AICausePVPMessage.TimePartA = 0x10 // float (Size: 0x4)
AICausePVPMessage.DistancePartA1 = 0x14 // float (Size: 0x4)
AICausePVPMessage.DistancePartA2 = 0x18 // float (Size: 0x4)
AICausePVPMessage.TimePartB = 0x1c // float (Size: 0x4)
AICausePVPMessage.DistancePartB1 = 0x20 // float (Size: 0x4)
AICausePVPMessage.DistancePartB2 = 0x24 // float (Size: 0x4)
AICommonStatis.bAIRLUsed = 0x0 // bool (Size: 0x1)
AICommonStatis.SpawnTime = 0x4 // float (Size: 0x4)
AICommonStatis.SpawnTime_GameTime = 0x8 // float (Size: 0x4)
AICommonStatis.ReadyTime = 0xc // float (Size: 0x4)
AICommonStatis.ReadyTime_GameTime = 0x10 // float (Size: 0x4)
AICommonStatis.LeaveTime = 0x14 // float (Size: 0x4)
AICommonStatis.LeaveTime_GameTime = 0x18 // float (Size: 0x4)
AICommonStatis.LeaveReason = 0x1c // EELeaveGameReason (Size: 0x1)
AICommonStatis.FireTimes = 0x20 // TArray<float> (Size: 0x10)
AICommonStatis.HitInfos = 0x30 // TArray<FAICommonStatis_HitInfo> (Size: 0x10)
AICommonStatis.MarkBattleInfos = 0x40 // TArray<FAICommonStatis_MarkBattleInfo> (Size: 0x10)
AICommonStatis_HitInfo.ID = 0x0 // int64_t (Size: 0x8)
AICommonStatis_HitInfo.Time = 0x8 // float (Size: 0x4)
AICommonStatis_HitInfo.ArmorDamage = 0xc // float (Size: 0x4)
AICommonStatis_HitInfo.RealDamage = 0x10 // float (Size: 0x4)
AICommonStatis_HitInfo.CharacterType = 0x14 // EECharacterType (Size: 0x1)
AICommonStatis_HitInfo.bKilled = 0x15 // bool (Size: 0x1)
AIDebugDrawStyleTableRow.Color = 0x8 // FLinearColor (Size: 0x10)
AIDebugDrawStyleTableRow.Thickness = 0x18 // float (Size: 0x4)
AIDebugDrawStyleTableRow.Radius = 0x1c // float (Size: 0x4)
AIDebugInfoDetail.AICharacterPtr = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
AIDebugInfoDetail.bAllBlackboardKeysConcerned = 0x8 // bool (Size: 0x1)
AIDebugInfoDetail.TreeActiveInstanceIndex = 0xc // int32_t (Size: 0x4)
AIDebugInfoDetail.TaskExecutionIndex = 0x10 // int32_t (Size: 0x4)
AIDebugInfoDetail.LastBlackboardChangeTime = 0x14 // float (Size: 0x4)
AIDebugInfoDetail.LastDistanceChangeTime = 0x18 // float (Size: 0x4)
AIDebugInfoDetail.LastTickTime = 0x1c // float (Size: 0x4)
AIDebugInfoDetail.bDisplayable = 0x20 // bool (Size: 0x1)
AIDebugInfoDetail.bSelected = 0x21 // bool (Size: 0x1)
AIDebugInfoDetail.HitGroupRate = 0x28 // TArray<int32_t> (Size: 0x10)
AIDebugInfoDetail.AIName = 0x38 // FString (Size: 0x10)
AIDebugInfoDetail.AIID = 0x48 // int64_t (Size: 0x8)
AIDebugInfoDetail.PathGroupID = 0x50 // int64_t (Size: 0x8)
AIDebugInfoDetail.EquipPoolID = 0x58 // int64_t (Size: 0x8)
AIDebugInfoDetail.CampID = 0x60 // int64_t (Size: 0x8)
AIDebugInfoDetail.FactionType = 0x68 // EEFactionType (Size: 0x1)
AIDebugInfoDetail.HpTotal = 0x6c // float (Size: 0x4)
AIDebugInfoDetail.HpHead = 0x70 // float (Size: 0x4)
AIDebugInfoDetail.HpChest = 0x74 // float (Size: 0x4)
AIDebugInfoDetail.HpStomach = 0x78 // float (Size: 0x4)
AIDebugInfoDetail.HpLeftArm = 0x7c // float (Size: 0x4)
AIDebugInfoDetail.HpRightArm = 0x80 // float (Size: 0x4)
AIDebugInfoDetail.HpLeftLeg = 0x84 // float (Size: 0x4)
AIDebugInfoDetail.HpRightLeg = 0x88 // float (Size: 0x4)
AIDebugInfoDetail.ElapsedAimingTime = 0x8c // float (Size: 0x4)
AIDebugInfoDetail.RequiredAimingTime = 0x90 // float (Size: 0x4)
AIDebugInfoDetail.AimStatus = 0x94 // int32_t (Size: 0x4)
AIDebugInfoDetail.TextColor = 0x98 // FColor (Size: 0x4)
AIDebugInfoDetail.BehaviorTreeName = 0xa0 // FString (Size: 0x10)
AIDebugInfoDetail.CurrentWork = 0xb0 // FString (Size: 0x10)
AIDebugInfoDetail.NextDecision = 0xc0 // EENPCAIDecision (Size: 0x1)
AIDebugInfoDetail.PreviousTaskNames = 0xc8 // FString (Size: 0x10)
AIDebugInfoDetail.ActiveTaskNames = 0xd8 // FString (Size: 0x10)
AIDebugInfoDetail.BlackboardKeys = 0xe8 // TArray<FName> (Size: 0x10)
AIDebugInfoDetail.BlackboardValues = 0xf8 // TArray<FString> (Size: 0x10)
AIDebugInfoDetail.ShootPartName = 0x108 // FString (Size: 0x10)
AIDebugInfoDetail.HitRatePredestined = 0x118 // float (Size: 0x4)
AIDebugInfoDetail.HitRateNormal = 0x11c // float (Size: 0x4)
AIDebugInfoDetail.HitRateAverage = 0x120 // float (Size: 0x4)
AIDebugInfoDetail.NotHitRatePresist = 0x124 // float (Size: 0x4)
AIDebugInfoDetail.bInHitInterval = 0x128 // bool (Size: 0x1)
AIDebugInfoDetail.HitIntervalCount = 0x12c // int32_t (Size: 0x4)
AIDebugInfoDetail.FirstTimeSeenScore = 0x130 // float (Size: 0x4)
AIDebugInfoDetail.FirstTimeSeenTotalUse = 0x134 // float (Size: 0x4)
AIDebugInfoDetail.bInBombRange = 0x138 // bool (Size: 0x1)
AIDebugInfoDetail.DelayFrames = 0x13c // int32_t (Size: 0x4)
AIDebugInfoDetail.SpawnPointCheckResult = 0x140 // FString (Size: 0x10)
AIDebugInfoDetail.bIsCasual = 0x150 // bool (Size: 0x1)
AIDebugInfoDetail.CachedBehaviorTreeComponent = 0x158 // BehaviorTreeComponent* (Size: 0x8)
AIDebugInfoDetail.SpawnPointName = 0x160 // FString (Size: 0x10)
AIDebugInfoDetail.SpawnPointLoc = 0x170 // FVector (Size: 0xc)
AIDebugInfoDetail.SpawnVolumeName = 0x180 // FString (Size: 0x10)
AIDebugInfoDetail.SpawnSquad = 0x190 // int32_t (Size: 0x4)
AIDebugInfoDetail.DecisionList_Patrol = 0x198 // TArray<EENPCAIDecision> (Size: 0x10)
AIDebugInfoDetail.DecisionList_Caution = 0x1a8 // TArray<EENPCAIDecision> (Size: 0x10)
AIDebugInfoDetail.DecisionList_Crossfire = 0x1b8 // TArray<EENPCAIDecision> (Size: 0x10)
AIDebugInfoDetail.AIMemory = 0x1c8 // FString (Size: 0x10)
AIDieOrKillBattleInfo.KillerElapsedTimeSinceReady = 0x0 // float (Size: 0x4)
AIDieOrKillBattleInfo.KillerBattleDuration = 0x4 // float (Size: 0x4)
AIDieOrKillBattleInfo.KillerFoundTargetDuration = 0x8 // float (Size: 0x4)
AIDieOrKillBattleInfo.KillerShootTargetDuration = 0xc // float (Size: 0x4)
AIDieOrKillBattleInfo.KillerFirstHitDuration = 0x10 // float (Size: 0x4)
AIDieOrKillBattleInfo.KillerCumulativeHitTimes = 0x14 // int32_t (Size: 0x4)
AIDieOrKillBattleInfo.KillerTeamCumulativeHitTimes = 0x18 // int32_t (Size: 0x4)
AIDieOrKillBattleInfo.KillerHasGoal = 0x1c // bool (Size: 0x1)
AIDieOrKillBattleInfo.KillerIsKilledMyGoal = 0x1d // bool (Size: 0x1)
AIDieOrKillBattleInfo.KilledFirstTakeHitDuration = 0x20 // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledCumulativeTakeHitTimes = 0x24 // int32_t (Size: 0x4)
AIDieOrKillBattleInfo.KilledElapsedTimeSinceReady = 0x28 // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledBattleDuration = 0x2c // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledFoundTargetDuration = 0x30 // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledShootTargetDuration = 0x34 // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledFirstHitDuration = 0x38 // float (Size: 0x4)
AIDieOrKillBattleInfo.KilledCumulativeHitTimes = 0x3c // int32_t (Size: 0x4)
AIDieOrKillBattleInfo.KilledHasGoal = 0x40 // bool (Size: 0x1)
AIDieOrKillBattleInfo.KilledIsKillerMyGoal = 0x41 // bool (Size: 0x1)
AIDossExitGameMessage.AIID = 0x0 // int64_t (Size: 0x8)
AIDossExitGameMessage.DeadTime = 0x8 // int32_t (Size: 0x4)
AIDossExitGameMessage.AliveFollowerNum = 0xc // int32_t (Size: 0x4)
AIDossExitGameMessage.SpawnPointName = 0x10 // FString (Size: 0x10)
AIDossExitGameMessage.KillerPlayerID = 0x20 // int64_t (Size: 0x8)
AIDossExitGameMessage.KillerPlayerSpawnPointId = 0x28 // int32_t (Size: 0x4)
AIDossExitGameMessage.ThrowProjectileSmokeNum = 0x2c // int32_t (Size: 0x4)
AIDossExitGameMessage.DossInSection = 0x30 // int32_t (Size: 0x4)
AIGameAchieveMessage.AIID = 0x0 // int64_t (Size: 0x8)
AIGameAchieveMessage.PGID = 0x8 // int64_t (Size: 0x8)
AIGameAchieveMessage.ReadyTime = 0x10 // float (Size: 0x4)
AIGameAchieveMessage.LeaveTime = 0x14 // float (Size: 0x4)
AIGameAchieveMessage.SurvivalTime = 0x18 // float (Size: 0x4)
AIGameAchieveMessage.LeaveReason = 0x1c // int32_t (Size: 0x4)
AIGameAchieveMessage.BattleCount = 0x20 // int32_t (Size: 0x4)
AIGameAchieveMessage.FireCount = 0x24 // int32_t (Size: 0x4)
AIGameAchieveMessage.HitCount = 0x28 // int32_t (Size: 0x4)
AIGameAchieveMessage.RealDamage = 0x2c // float (Size: 0x4)
AIGameAchieveMessage.ArmorDamage = 0x30 // float (Size: 0x4)
AIGameAchieveMessage.KillPlayerNum = 0x34 // int32_t (Size: 0x4)
AIGameAchieveMessage.HitPlayerNum = 0x38 // int32_t (Size: 0x4)
AIGameAchieveMessage.PeekCount = 0x3c // int32_t (Size: 0x4)
AIGameAchieveMessage.CallUpReason = 0x40 // int32_t (Size: 0x4)
AIGameAchieveMessage.CallUpResult = 0x44 // int32_t (Size: 0x4)
AIIDNum.Handle = 0x0 // int32_t (Size: 0x4)
AIIDNum.AIID = 0x8 // int64_t (Size: 0x8)
AIIDNum.AIState = 0x10 // int32_t (Size: 0x4)
AIIDNum.AIPriority = 0x14 // int32_t (Size: 0x4)
AIIDNum.RemoveReason = 0x18 // int32_t (Size: 0x4)
AIIDNum.PriorityContextString = 0x20 // FString (Size: 0x10)
AIIDNum.RemoveContextString = 0x30 // FString (Size: 0x10)
AIIDNum.bIsPending = 0x40 // bool (Size: 0x1)
AIPoolInfo.ID = 0x0 // FString (Size: 0x10)
AIPoolInfo.Equip = 0x10 // int32_t (Size: 0x4)
AIPoolInfo.Weight = 0x14 // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.AIID = 0x0 // int64_t (Size: 0x8)
AIProtectSafeBoxMessage.PGID = 0x8 // int64_t (Size: 0x8)
AIProtectSafeBoxMessage.bAIRLUsed = 0x10 // bool (Size: 0x1)
AIProtectSafeBoxMessage.bSurvived = 0x11 // bool (Size: 0x1)
AIProtectSafeBoxMessage.ProtectionDuration = 0x14 // float (Size: 0x4)
AIProtectSafeBoxMessage.EnterBattleTimes = 0x18 // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.LeaveBattleTimes_TargetLost = 0x1c // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.TotalBattleDuration = 0x20 // float (Size: 0x4)
AIProtectSafeBoxMessage.TotalFireCount = 0x24 // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.TotalHitCount = 0x28 // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.TotalHitPlayerCount = 0x2c // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.TotalKillPlayerCount = 0x30 // int32_t (Size: 0x4)
AIProtectSafeBoxMessage.TotalMoveDuration = 0x34 // float (Size: 0x4)
AIRLReportData.AIID = 0x0 // int64_t (Size: 0x8)
AIRLReportData.PGID = 0x8 // int64_t (Size: 0x8)
AIRLReportData.AIRL_SumTime = 0x10 // float (Size: 0x4)
AIRLReportData.AIRL_SwitchToNormal = 0x14 // bool (Size: 0x1)
AIRLReportData.AIRL_Survival = 0x15 // bool (Size: 0x1)
AIRankData.ranking = 0x0 // int32_t (Size: 0x4)
AIRankData.pranking = 0x4 // int32_t (Size: 0x4)
AIRankData.ranked_rd = 0x8 // int32_t (Size: 0x4)
AISoundRepInfo.SoundType = 0x0 // EEAISoundType (Size: 0x1)
AISoundRepInfo.Count = 0x4 // int32_t (Size: 0x4)
AIWeaponDefaultBulletClassInfo.DefaultBulletClassPtr = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
AIWeaponDefaultBulletClassInfo.DefaultBulletClass = 0x28 // ClassProperty (Size: 0x8)
APIEquipmentInfo.ItemId = 0x0 // uint32_t (Size: 0x4)
APIEquipmentInfo.ItemValue = 0x4 // int32_t (Size: 0x4)
APIEquipmentInfo.ItemNum = 0x8 // uint32_t (Size: 0x4)
APIPlayerDynamicInfo.GID = 0x0 // uint64_t (Size: 0x8)
APIPlayerDynamicInfo.TakeOutAllValue = 0x8 // uint64_t (Size: 0x8)
APIPlayerDynamicInfo.HarvestValue = 0x10 // uint64_t (Size: 0x8)
APIPlayerDynamicInfo.AliveState = 0x18 // EESGCompetitionStatusType (Size: 0x1)
APIPlayerDynamicInfo.KillPMCNum = 0x1c // uint32_t (Size: 0x4)
APIPlayerDynamicInfo.AllTakeEquipmentArray = 0x20 // TArray<FAPIEquipmentInfo> (Size: 0x10)
APIPlayerStaticInfo.GID = 0x0 // uint64_t (Size: 0x8)
APIPlayerStaticInfo.TeamID = 0x8 // uint32_t (Size: 0x4)
APIPlayerStaticInfo.TeamIndex = 0xc // uint32_t (Size: 0x4)
APIPlayerStaticInfo.TeamName = 0x10 // FString (Size: 0x10)
APIReportInfo.GID = 0x0 // uint64_t (Size: 0x8)
APIReportInfo.ReportType = 0x8 // EEAPIReportTypes (Size: 0x1)
APIReportInfo.KillInfo = 0x10 // FCompetitionKillInfo (Size: 0x58)
APIReportInfo.ItemId = 0x68 // uint32_t (Size: 0x4)
AbilitySlot.InstancedAbilityKey = 0x0 // FGameplayTag (Size: 0x8)
AbilitySlot.InstancedAbilityHandle = 0x8 // FGameplayAbilitySpecHandle (Size: 0x4)
ActivityInfo.ActivityID = 0x0 // int32_t (Size: 0x4)
ActivityInfo.DisplayOrder = 0x4 // int32_t (Size: 0x4)
ActivityInfo.ActivityType = 0x8 // int32_t (Size: 0x4)
ActivityInventoryStateChangeInfo.PreviousState = 0x0 // EEActivityInventoryState (Size: 0x1)
ActivityInventoryStateChangeInfo.CurrentState = 0x1 // EEActivityInventoryState (Size: 0x1)
ActivityItemUpgradeInfo.FromPlayerGID = 0x0 // uint64_t (Size: 0x8)
ActivityItemUpgradeInfo.FromItemInstID = 0x8 // uint64_t (Size: 0x8)
ActivityItemUpgradeInfo.FromItemID = 0x10 // uint64_t (Size: 0x8)
ActivityItemUpgradeInfo.FromItemNum = 0x18 // uint32_t (Size: 0x4)
ActivityItemUpgradeInfo.ToItemInstID = 0x20 // uint64_t (Size: 0x8)
ActivityItemUpgradeInfo.ToItemID = 0x28 // uint64_t (Size: 0x8)
ActivityItemUpgradeInfo.ToItemNum = 0x30 // uint32_t (Size: 0x4)
ActivityReportConfig.ReportType = 0x0 // EEReportType (Size: 0x1)
ActivityReportConfig.ReportCondition = 0x1 // EEChaseActivityReportCondition (Size: 0x1)
ActivityReportConfig.OptionalMessageID = 0x4 // int32_t (Size: 0x4)
ActivityReportConfig.OptionalText = 0x8 // FText (Size: 0x18)
ActivityReportConfig.CheckServerTimeIndex = 0x20 // int32_t (Size: 0x4)
ActivityReportConfigArray.ReportInfos = 0x0 // TArray<FActivityReportConfig> (Size: 0x10)
ActivityRequireComponentInfo.ActivityGameStateComponent = 0x0 // ClassProperty (Size: 0x8)
ActivityRequireComponentInfo.ActivityPlayerStateComponent = 0x8 // ClassProperty (Size: 0x8)
ActivityTableRowBase.ActivityID = 0x8 // int32_t (Size: 0x4)
AdapterInfo.X = 0x0 // int32_t (Size: 0x4)
AdapterInfo.Y = 0x8 // FString (Size: 0x10)
AircraftRotorSetup.ForceMax = 0x0 // float (Size: 0x4)
AircraftRotorSetup.RotationMax = 0x4 // FRotator (Size: 0xc)
AircraftRotorSetup.CurrentForce = 0x10 // FVector (Size: 0xc)
AircraftRotorSetup.CurrentTorqueForce = 0x1c // FVector (Size: 0xc)
AircraftRotorSetup.BoneName = 0x28 // FName (Size: 0x8)
AircraftRotorSetup.AdditionalOffset = 0x30 // FVector (Size: 0xc)
AlternativeMaterialInfo.SoftRefMaterialList = 0x0 // TMap<...> (Size: 0x50)
AlternativeMaterialInfo.MaterialList = 0x50 // TMap<...> (Size: 0x50)
AnimInstanceEvaluator.AnimInstanceClass = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
AnimInstanceEvaluator.bAsyncLoading = 0x50 // bool (Size: 0x1)
AnimNode_AnimMotionSource.BoneToModify = 0xd0 // FBoneReference (Size: 0x10)
AnimNode_AnimMotionSource.TranslationAnimMotionNames = 0xe0 // TArray<FName> (Size: 0x10)
AnimNode_AnimMotionSource.TranslationMode = 0xf0 // uint8_t (Size: 0x1)
AnimNode_AnimMotionSource.TranslationSpace = 0xf1 // uint8_t (Size: 0x1)
AnimNode_AnimMotionSource.RotationAnimMotionNames = 0xf8 // TArray<FName> (Size: 0x10)
AnimNode_AnimMotionSource.RotationMode = 0x108 // uint8_t (Size: 0x1)
AnimNode_AnimMotionSource.RotationSpace = 0x109 // uint8_t (Size: 0x1)
AnimNode_AnimMotionSource.RotatePivot = 0x10c // FName (Size: 0x8)
AnimNode_AnimMotionSource.bWeaponPivot = 0x114 // bool (Size: 0x1)
AnimNotifyState_CameraFade_HD.Color = 0x30 // FLinearColor (Size: 0x10)
AnimNotifyState_CameraFade_HD.FadeInDuration = 0x40 // float (Size: 0x4)
AnimNotifyState_CameraFade_HD.FadeOutDuration = 0x44 // float (Size: 0x4)
AnimNotifyState_DisableAddRootBoneRotation.ResetRootBoneRotationOnBegin = 0x30 // bool (Size: 0x1)
AnimNotifyState_HideWeapon.WeaponToHide = 0x30 // TArray<EEWeaponPosition> (Size: 0x10)
AnimNotifyState_HideWeapon.NotifyStateID = 0x40 // FString (Size: 0x10)
AnimNotifyState_HideWeapon.DelayShowWeapon = 0x50 // float (Size: 0x4)
AnimNotifyState_NoBlendUpperBody.DynamicPlayRate = 0x30 // bool (Size: 0x1)
AnimNotifyState_NoBlendUpperBody.PlayRate = 0x34 // float (Size: 0x4)
AnimNotifyState_PPMaterial.Material = 0x30 // MaterialInterface* (Size: 0x8)
AnimNotifyState_PPMaterial.ParamName = 0x38 // FName (Size: 0x8)
AnimNotifyState_PPMaterial.NotifyTimeToParamValue = 0x40 // CurveFloat* (Size: 0x8)
AnimNotifyState_PPMaterial.PPVolumeName = 0x48 // FName (Size: 0x8)
AnimNotifyState_PPMaterial.NotifyStateID = 0x50 // FString (Size: 0x10)
AnimNotifyState_PPMaterial.IDToData = 0x60 // TMap<...> (Size: 0x50)
AnimNotifyState_PlayAnimWithMesh.Mesh = 0x30 // SkeletalMesh* (Size: 0x8)
AnimNotifyState_PlayAnimWithMesh.bCastShadow = 0x38 // bool (Size: 0x1)
AnimNotifyState_PlayAnimWithMesh.MeshAnimation = 0x40 // AnimSequenceBase* (Size: 0x8)
AnimNotifyState_PlayAnimWithMesh.AttachSocket = 0x48 // FName (Size: 0x8)
AnimNotifyState_PlayAnimWithMesh.StartTime = 0x50 // float (Size: 0x4)
AnimNotifyState_PlayAnimWithMesh.bSyncAnim = 0x54 // bool (Size: 0x1)
AnimNotifyState_PlayAnimWithMesh.TagForCacheMeshComp = 0x58 // FName (Size: 0x8)
AnimNotifyState_PlayAnimWithMesh.MeshMatCreateTimeParamIndex = 0x60 // int32_t (Size: 0x4)
AnimNotifyState_PlayAnimWithMesh.MeshMatCreateTimeParamName = 0x64 // FName (Size: 0x8)
AnimNotifyState_PlayAnimWithMesh.MeshMatParamAry = 0x70 // TArray<FPlayAnimWithMeshMatOperateInfo> (Size: 0x10)
AnimNotifyState_PlayAnimWithMesh.ShowMeshMinWeight = 0x80 // float (Size: 0x4)
AnimNotify_AnimatedMesh_HD.Mesh = 0x38 // SkeletalMesh* (Size: 0x8)
AnimNotify_AnimatedMesh_HD.bCastShadow = 0x40 // bool (Size: 0x1)
AnimNotify_AnimatedMesh_HD.AnimationToPlay = 0x48 // AnimSequenceBase* (Size: 0x8)
AnimNotify_AnimatedMesh_HD.AttachSocket = 0x50 // FName (Size: 0x8)
AnimNotify_BoreSwitch.bBoreOpen = 0x38 // bool (Size: 0x1)
AnimNotify_CaptureCharacterConfig.CaptureLight = 0x38 // ClassProperty (Size: 0x8)
AnimNotify_CaptureCharacterConfig.CameraTransform = 0x40 // FTransform (Size: 0x30)
AnimNotify_CaptureCharacterConfig.FOV = 0x70 // float (Size: 0x4)
AnimNotify_CaptureCharacterConfig.TextureTarget = 0x78 // TextureRenderTarget2D* (Size: 0x8)
AnimNotify_CaptureCharacterConfig.bIsCasual = 0x80 // bool (Size: 0x1)
AnimNotify_CaptureCharacterConfig.HairSpecularLight = 0x84 // FLinearColor (Size: 0x10)
AnimNotify_CustomMessageEvent.EventType = 0x38 // FString (Size: 0x10)
AnimNotify_CustomMessageEvent.Param1 = 0x48 // FString (Size: 0x10)
AnimNotify_CustomMessageEvent.Param2 = 0x58 // FString (Size: 0x10)
AnimNotify_CustomMessageEvent.Param3 = 0x68 // FString (Size: 0x10)
AnimNotify_EjectBulletShell.bOnFire = 0x38 // bool (Size: 0x1)
AnimNotify_EjectBulletShell.LaunchDelay = 0x3c // float (Size: 0x4)
AnimNotify_EnterAnimRecovery.ServerLatencyCompensation = 0x38 // float (Size: 0x4)
AnimNotify_FootStepCrouchWalk.CachedOriginAudioEvent = 0xa8 // AkAudioEvent* (Size: 0x8)
AnimNotify_FootStepCrouchWalk.CrouchWalkEvent = 0xb0 // AkAudioEvent* (Size: 0x8)
AnimNotify_FootStepCrouchWalk.CrouchRunEvent = 0xb8 // AkAudioEvent* (Size: 0x8)
AnimNotify_FootstepSound.FoostepDirType = 0xa0 // EEFootEffectDir (Size: 0x1)
AnimNotify_HUDShake.StartShakeEvents = 0x38 // TArray<EEHUDShakeEvents> (Size: 0x10)
AnimNotify_HUDShake.EndShakeEvents = 0x48 // TArray<EEHUDShakeEvents> (Size: 0x10)
AnimNotify_InventoryAnimNotify.NotifyName = 0x38 // FString (Size: 0x10)
AnimNotify_MeleeHit.StrikeRoll = 0x38 // float (Size: 0x4)
AnimNotify_MeleeHit.bCustomStrikeRoll = 0x3c // bool (Size: 0x1)
AnimNotify_MeleeHit.ImpactDecalStyle = 0x40 // int32_t (Size: 0x4)
AnimNotify_MeleeHitCanReenter.TargetNextPhase = 0x38 // int32_t (Size: 0x4)
AnimNotify_OrnamentAddForce.ForceScale = 0x38 // FVector (Size: 0xc)
AnimNotify_OrnamentAddForce.bAccelChange = 0x44 // bool (Size: 0x1)
AnimNotify_OrnamentAddForce.BoneName = 0x48 // FName (Size: 0x8)
AnimNotify_PlayAudio_HD.bUpdateStance = 0xa0 // bool (Size: 0x1)
AnimNotify_PlayAudio_HD.bUpdateMaterial = 0xa1 // bool (Size: 0x1)
AnimNotify_PlayCameraShake.CSTemplate = 0x38 // ClassProperty (Size: 0x8)
AnimNotify_PlayCameraShake.SocketName = 0x40 // FName (Size: 0x8)
AnimNotify_PlayCameraShake.LocationOffset = 0x48 // FVector (Size: 0xc)
AnimNotify_PlayCameraShake.ShakeInnerRadius = 0x54 // float (Size: 0x4)
AnimNotify_PlayCameraShake.ShakeOuterRadius = 0x58 // float (Size: 0x4)
AnimNotify_PushBulletAnimState.State = 0x38 // EEPushBulletAnimState (Size: 0x1)
AnimNotify_Ragdoll_HD.BodyInitSpeeds = 0x38 // TMap<...> (Size: 0x50)
AnimNotify_ReloadBoresAnimState.State = 0x38 // EEReloadBoresAnimState (Size: 0x1)
AnimNotify_ReloadBoresAnimState.HandSocket = 0x3c // FName (Size: 0x8)
AnimNotify_SGPlayAudio.bPlayAudioOnly1P = 0xa0 // bool (Size: 0x1)
AnimNotify_SGPlayAudioLobby.AudioEvent = 0x38 // AkAudioEvent* (Size: 0x8)
AnimNotify_SGPlayAudioLobby.AudioNotifyName = 0x40 // FName (Size: 0x8)
AnimNotify_SGPlayAudioLobby.AnimInstance = 0x48 // TWeakObjectPtr<UObject> (Size: 0x8)
AnimNotify_SetAvatarMaterial.AvatarType = 0x38 // EESGAvatarType (Size: 0x1)
AnimNotify_SetAvatarMaterial.MaterialSlotName = 0x3c // FName (Size: 0x8)
AnimNotify_SetAvatarMaterial.OverrideMaterial = 0x48 // MaterialInterface* (Size: 0x8)
AnimNotify_SetMeshMatParam.MatSlotIndex = 0x38 // int32_t (Size: 0x4)
AnimNotify_SetMeshMatParam.MatParamName = 0x3c // FName (Size: 0x8)
AnimNotify_SetMeshMatParam.MatParamValue = 0x44 // float (Size: 0x4)
AnimNotify_SetWeaponAttachPosInTacticalState.ForwardPlaying_HideRifle = 0x38 // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ForwardPlaying_HidePistol = 0x39 // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ForwardPlaying_ShowRifle = 0x3a // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ForwardPlaying_ShowPistol = 0x3b // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ReversePlaying_HideRifle = 0x3c // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ReversePlaying_HidePistol = 0x3d // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ReversePlaying_ShowRifle = 0x3e // bool (Size: 0x1)
AnimNotify_SetWeaponAttachPosInTacticalState.ReversePlaying_ShowPistol = 0x3f // bool (Size: 0x1)
AnimNotify_TriggerSoundIndicator.SoundType = 0x38 // EESoundSourceType (Size: 0x1)
AnimNotify_TryJumpToSection.SectionName = 0x38 // FName (Size: 0x8)
AnimNotify_TryJumpToSection.VelocityThreshold = 0x40 // float (Size: 0x4)
AnimPositionAccumulator.CurrentTime = 0x0 // float (Size: 0x4)
AnimPositionTracker.CurrentTime = 0x0 // float (Size: 0x4)
AnimationSpring.Stiffness = 0x10 // FVector4 (Size: 0x10)
AnimationSpring.Damping = 0x20 // FVector4 (Size: 0x10)
AnimationSpring.RotationStability = 0x30 // float (Size: 0x4)
AnimationSpring.MinError = 0x40 // FVector4 (Size: 0x10)
AnimationSpring.MaxError = 0x50 // FVector4 (Size: 0x10)
AnimationSpring.ZeroPoint = 0x60 // FVector4 (Size: 0x10)
AnimationSpring.WaveformRange = 0x70 // float (Size: 0x4)
AnimationSpringOverrideParams.Stiffness = 0x0 // float (Size: 0x4)
AnimationSpringOverrideParams.Damping = 0x4 // float (Size: 0x4)
AnimationSpringOverrideParams.BlendIn = 0x8 // float (Size: 0x4)
AnimationSpringOverrideParams.BlendOut = 0xc // float (Size: 0x4)
AnimationSpringOverrideParamsV4.Stiffness = 0x0 // FVector4 (Size: 0x10)
AnimationSpringOverrideParamsV4.Damping = 0x10 // FVector4 (Size: 0x10)
AnimationSpringOverrideParamsV4.BlendIn = 0x20 // float (Size: 0x4)
AnimationSpringOverrideParamsV4.BlendOut = 0x24 // float (Size: 0x4)
AreaPointInfo.CenterLocation = 0x0 // FVector (Size: 0xc)
AreaPointInfo.Radius = 0xc // int32_t (Size: 0x4)
AreaPointInfo.WavePicking = 0x10 // int32_t (Size: 0x4)
ArmorConsumeStruct.ArmorConsume = 0x0 // float (Size: 0x4)
ArmorConsumeStruct.BlockDamage = 0x4 // float (Size: 0x4)
ArmorConsumeStruct.WeaponId = 0x8 // int64_t (Size: 0x8)
ArmorConsumeStruct.BodyPart = 0x10 // int32_t (Size: 0x4)
ArmorConsumeStruct.BulletID = 0x18 // int64_t (Size: 0x8)
ArmorDamageStruct.BlockDamage = 0x0 // float (Size: 0x4)
ArmorDamageStruct.DamageTime = 0x8 // int64_t (Size: 0x8)
ArmorDamageStruct.TakerId = 0x10 // int64_t (Size: 0x8)
AssembleParentInfo.ParentItem = 0x0 // Actor* (Size: 0x8)
AssembleParentInfo.OffsetIndex = 0x8 // int32_t (Size: 0x4)
AssembleSocketInfo.SocketName = 0x0 // FName (Size: 0x8)
AssembleSocketInfo.SupportAdapterTagList = 0x8 // FGameplayTagContainer (Size: 0x20)
AssembleSocketInfo.bDisplaySocket = 0x28 // bool (Size: 0x1)
AssembleSocketInfo.UIStartOffest = 0x2c // FVector (Size: 0xc)
AssembleSocketInfo.UIEndOffest = 0x38 // FVector (Size: 0xc)
AssembleSocketInfo.UIPartName = 0x48 // FText (Size: 0x18)
AssembleSocketInfo.AttachedInventory = 0x60 // SGInventory* (Size: 0x8)
AssembleSocketInfo.SocketOffsetInfo = 0x68 // TArray<FSocketOffsetInfo> (Size: 0x10)
AssembleSocketInfo.bPlaceHolderInventory = 0x78 // bool (Size: 0x1)
AssembleSocketInfo.FakeID = 0x7c // uint32_t (Size: 0x4)
AssembleSocketOffset.ChildInventoryID = 0x0 // uint64_t (Size: 0x8)
AssembleSocketOffset.LocationOffset = 0x8 // FVector (Size: 0xc)
AssistKillInfo.AssistKillerController = 0x0 // Controller* (Size: 0x8)
AssistKillInfo.KilledController = 0x8 // Controller* (Size: 0x8)
AssistKillInfo.AssistKillerGID = 0x10 // uint64_t (Size: 0x8)
AssistKillInfo.KilledGID = 0x18 // uint64_t (Size: 0x8)
AssistKillInfo.CauseDamage = 0x20 // float (Size: 0x4)
AssistKillInfo.TotalDamage = 0x24 // float (Size: 0x4)
AssistKillInfo.bKillFriend = 0x28 // int32_t (Size: 0x4)
AttachInvInfo.AttachmentClass = 0x0 // ClassProperty (Size: 0x8)
AttachInvInfo.Num = 0x8 // int32_t (Size: 0x4)
AttachInvInfo.SkinID = 0xc // int32_t (Size: 0x4)
AttachInventoryInfo.CurrentInventory = 0x28 // ClassProperty (Size: 0x8)
AttachInventoryInfo.SocketAttachmentMap = 0x30 // TMap<...> (Size: 0x50)
AttachWithNum.Attach = 0x28 // AttachInventoryInfo* (Size: 0x8)
AttachWithNum.Num = 0x30 // int32_t (Size: 0x4)
AutoAimAntiHackStatis.MaxRange = 0x0 // float (Size: 0x4)
AutoAimAntiHackStatis.MaxAngularSpeed = 0x4 // float (Size: 0x4)
AutoAimContext.bFiring = 0x0 // bool (Size: 0x1)
AutoAimContext.bADS = 0x1 // bool (Size: 0x1)
AutoAimContext.bSlidingScreen = 0x2 // bool (Size: 0x1)
AutoAimContext.SlideScreenDirAvg = 0x4 // FVector2D (Size: 0x8)
AutoAimContext.ViewLocation = 0xc // FVector (Size: 0xc)
AutoAimContext.ViewDirection = 0x18 // FVector (Size: 0xc)
AutoAimContext.CurrentTime = 0x24 // float (Size: 0x4)
AutoAimContext.CurrentFOV = 0x28 // float (Size: 0x4)
AutoAimDebugDataAsset.bShowViewDirection = 0x30 // bool (Size: 0x1)
AutoAimDebugDataAsset.bShowViewPoint = 0x31 // bool (Size: 0x1)
AutoAimDebugDataAsset.ViewPointColor = 0x34 // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowSnapTargetPoint = 0x38 // bool (Size: 0x1)
AutoAimDebugDataAsset.SnapTargetPointColor = 0x3c // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowBoneCapsule = 0x40 // bool (Size: 0x1)
AutoAimDebugDataAsset.BoneCapsuleColor = 0x44 // FColor (Size: 0x4)
AutoAimDebugDataAsset.BoneCapsuleStartRangeColor = 0x48 // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowBaseStateRectangles = 0x4c // bool (Size: 0x1)
AutoAimDebugDataAsset.bShowSlideStateRectangles = 0x4d // bool (Size: 0x1)
AutoAimDebugDataAsset.bShowFireStateRectangles = 0x4e // bool (Size: 0x1)
AutoAimDebugDataAsset.bShowADSStateRectangles = 0x4f // bool (Size: 0x1)
AutoAimDebugDataAsset.bAutoRectangleStatesOverride = 0x50 // bool (Size: 0x1)
AutoAimDebugDataAsset.ShowRangeDuration = 0x54 // float (Size: 0x4)
AutoAimDebugDataAsset.bShowStartRange = 0x58 // bool (Size: 0x1)
AutoAimDebugDataAsset.StartRangeColor = 0x5c // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowEndRange = 0x60 // bool (Size: 0x1)
AutoAimDebugDataAsset.EndRangeColor = 0x64 // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowLowerTurnSensitivityRange = 0x68 // bool (Size: 0x1)
AutoAimDebugDataAsset.LowerTurnSensitivityColor = 0x6c // FColor (Size: 0x4)
AutoAimDebugDataAsset.bShowMoveCompensateRange = 0x70 // bool (Size: 0x1)
AutoAimDebugDataAsset.MoveCompensateColor = 0x74 // FColor (Size: 0x4)
AutoAimFloat.BaseValue = 0x0 // float (Size: 0x4)
AutoAimFloat.FireStateValue = 0x4 // float (Size: 0x4)
AutoAimFloat.bFireStateOverride = 0x8 // bool (Size: 0x1)
AutoAimFloat.SlideScreenValue = 0xc // float (Size: 0x4)
AutoAimFloat.bSlideScreenOverride = 0x10 // bool (Size: 0x1)
AutoAimFloat.AdsValue = 0x14 // float (Size: 0x4)
AutoAimFloat.bAdsOverride = 0x18 // bool (Size: 0x1)
AutoAimFloatCurve.BaseCurve = 0x0 // CurveFloat* (Size: 0x8)
AutoAimFloatCurve.FireCurve = 0x8 // CurveFloat* (Size: 0x8)
AutoAimFloatCurve.bFireStateOverride = 0x10 // bool (Size: 0x1)
AutoAimFloatCurve.SlideScreenCurve = 0x18 // CurveFloat* (Size: 0x8)
AutoAimFloatCurve.bSlideScreenOverride = 0x20 // bool (Size: 0x1)
AutoAimFloatCurve.AdsCurve = 0x28 // CurveFloat* (Size: 0x8)
AutoAimFloatCurve.bAdsOverride = 0x30 // bool (Size: 0x1)
AutoAimFrameRecord.Distance = 0x0 // float (Size: 0x4)
AutoAimFrameRecord.FOV = 0x4 // float (Size: 0x4)
AutoAimFrameRecord.BaseStartRangeH = 0x8 // float (Size: 0x4)
AutoAimFrameRecord.Distance2StartRangeScaleH = 0xc // float (Size: 0x4)
AutoAimFrameRecord.FOV2StartRangeScaleH = 0x10 // float (Size: 0x4)
AutoAimFrameRecord.ModifiedStartRangeH = 0x14 // float (Size: 0x4)
AutoAimFrameRecord.BaseEndRangeH = 0x18 // float (Size: 0x4)
AutoAimFrameRecord.Distance2EndRangeScaleH = 0x1c // float (Size: 0x4)
AutoAimFrameRecord.FOV2EndRangeScaleH = 0x20 // float (Size: 0x4)
AutoAimFrameRecord.ModifiedEndRangeH = 0x24 // float (Size: 0x4)
AutoAimFrameRecord.BaseSpeedH = 0x28 // float (Size: 0x4)
AutoAimFrameRecord.BaseAngularSpeedH = 0x2c // float (Size: 0x4)
AutoAimFrameRecord.Distance2SpeedScaleH = 0x30 // float (Size: 0x4)
AutoAimFrameRecord.FOV2SpeedScaleH = 0x34 // float (Size: 0x4)
AutoAimFrameRecord.RecoilTime2SpeedScaleH = 0x38 // float (Size: 0x4)
AutoAimFrameRecord.RectDist2SpeedScaleH = 0x3c // float (Size: 0x4)
AutoAimFrameRecord.HorizontalRecoil2SpeedScaleH = 0x40 // float (Size: 0x4)
AutoAimFrameRecord.SpeedDampingScale = 0x44 // float (Size: 0x4)
AutoAimFrameRecord.SlideScreenSpeedDamp = 0x48 // float (Size: 0x4)
AutoAimFrameRecord.FireCount2SpeedScale = 0x4c // float (Size: 0x4)
AutoAimFrameRecord.SelfMovePenaltyScale = 0x50 // float (Size: 0x4)
AutoAimFrameRecord.TargetMovePenaltyScale = 0x54 // float (Size: 0x4)
AutoAimFrameRecord.ModifiedAngularSpeedH = 0x58 // float (Size: 0x4)
AutoAimFrameRecord.ModifiedAngularSpeedV = 0x5c // float (Size: 0x4)
AutoAimFrameRecord.TargetVelocity = 0x60 // FVector (Size: 0xc)
AutoAimFrameRecord.MoveCompensateRatioScale = 0x6c // float (Size: 0x4)
AutoAimFrameRecord.TargetMovingCompensateRatioScaled = 0x70 // float (Size: 0x4)
AutoAimFrameRecord.MoveCompensateVelocityScaled = 0x74 // FVector (Size: 0xc)
AutoAimFrameRecord.MoveCompensateAngularSpeedH = 0x80 // float (Size: 0x4)
AutoAimParamsSet.bBoneBasedSpeedDamping = 0x30 // bool (Size: 0x1)
AutoAimParamsSet.AutoAimingStartRange = 0x34 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingEndRange = 0x50 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingLowerBoundHeightScale = 0x6c // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingUpperBoundHeightScale = 0x88 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingConstantFollowSpeed = 0xa4 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingDistanceMax = 0xc0 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingDistanceMin = 0xdc // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingMaxAngleSpeed = 0xf8 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.AutoAimingMaxStartRange = 0x114 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.LowerTurnSensitivityRange = 0x130 // float (Size: 0x4)
AutoAimParamsSet.ConfigLimitedRotateXRateScaleMax = 0x134 // float (Size: 0x4)
AutoAimParamsSet.ConfigLimitedRotateXRateScaleMin = 0x138 // float (Size: 0x4)
AutoAimParamsSet.ConfigLimitedRotateYRateScale = 0x13c // float (Size: 0x4)
AutoAimParamsSet.TurnAmountToLimitRotate = 0x140 // float (Size: 0x4)
AutoAimParamsSet.bRestrainWhenTargetMoving = 0x144 // bool (Size: 0x1)
AutoAimParamsSet.AutoAimingCheckInterval = 0x148 // float (Size: 0x4)
AutoAimParamsSet.Distance2StartRangeScaleHorizontal = 0x150 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.Distance2EndRangeScaleHorizontal = 0x1d8 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.Distance2RangeScaleVertical = 0x260 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.Distance2SpeedScaleHorizontal = 0x2e8 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.Distance2SpeedScaleVertical = 0x2f0 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.FOV2StartRangeScaleHorizontal = 0x2f8 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.FOV2EndRangeScaleHorizontal = 0x380 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.FOV2RangeScaleVertical = 0x408 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.FOV2SpeedScaleHorizontal = 0x490 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.FOV2SpeedScaleVertical = 0x518 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.AutoAimingMoveStartRangeCompensateScale = 0x5a0 // float (Size: 0x4)
AutoAimParamsSet.AutoAimingMoveCompensateRatio = 0x5a4 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.MoveCompensateStartRange = 0x5c0 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.NormalizedDistance2MoveCompensateScaleCurve = 0x5e0 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.AutoAimingCompensateMaxAngleSpeed = 0x5e8 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.NormalizedDistance2FollowSpeedScaleCurve = 0x608 // FAutoAimFloatCurve (Size: 0x38)
AutoAimParamsSet.RecoilTime2FollowSpeedScaleCurve = 0x640 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.HorizontalRecoilValue2FollowSpeedScaleCurve = 0x648 // FAutoAimFloatCurve (Size: 0x38)
AutoAimParamsSet.FireCount2HorizontalRecoilValueWeight = 0x680 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.SelfMovePenaltyScaleCurve = 0x688 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.TargetMovePenaltyScaleCurve = 0x690 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.AutoAimingConstantFollowSpeedVerti = 0x698 // FAutoAimFloat (Size: 0x1c)
AutoAimParamsSet.SlideScreenDirectionSensitivity = 0x6b4 // float (Size: 0x4)
AutoAimParamsSet.SlideScreenDirectionDampCurve = 0x6b8 // FRuntimeFloatCurve (Size: 0x88)
AutoAimParamsSet.ADSSnapSpeed = 0x740 // float (Size: 0x4)
AutoAimParamsSet.ADSBlendTime = 0x744 // float (Size: 0x4)
AutoAimParamsSet.TargetBoneList = 0x748 // FAutoAimTargetBoneList (Size: 0x28)
AutoAimParamsSet.FireCount2FollowSpeedScale = 0x770 // CurveFloat* (Size: 0x8)
AutoAimParamsSet.ResetFireCountDelay = 0x778 // float (Size: 0x4)
AutoAimParamsSet.ExitFireStateDelay = 0x77c // float (Size: 0x4)
AutoAimRangeCheckResult.TargetNotInFollowRangeReason = 0x0 // EETargetNotInRangeReason (Size: 0x1)
AutoAimRangeCheckResult.MoveCompensateScale = 0x4 // float (Size: 0x4)
AutoAimTargetBone.BoneName = 0x0 // FName (Size: 0x8)
AutoAimTargetBone.RadiusBias = 0x8 // float (Size: 0x4)
AutoAimTargetBone.HalfLengthBias = 0xc // float (Size: 0x4)
AutoAimTargetBone.StartRange = 0x10 // FAutoAimFloat (Size: 0x1c)
AutoAimTargetBoneList.BaseConfigs = 0x0 // TArray<FAutoAimTargetBone> (Size: 0x10)
AutoAimTargetBoneList.FireStateConfigs = 0x10 // TArray<FAutoAimTargetBone> (Size: 0x10)
AutoAimTargetBoneList.bFireStateOverride = 0x20 // bool (Size: 0x1)
AvatarMergeMeshShareInfo.ModularMeshList = 0x0 // TArray<FString> (Size: 0x10)
AvatarMergeMeshShareInfo.MergedMesh = 0x10 // SkeletalMesh* (Size: 0x8)
AvatarPreloadAsset.bStaticMesh = 0x0 // bool (Size: 0x1)
AvatarPreloadAsset.StaticAsset = 0x8 // StreamableRenderAsset* (Size: 0x8)
AvatarPreloadAsset.MaleAsset = 0x10 // StreamableRenderAsset* (Size: 0x8)
AvatarPreloadAsset.FemaleAsset = 0x18 // StreamableRenderAsset* (Size: 0x8)
BackAttachSocketOffset.AttachSocketName = 0x0 // FString (Size: 0x10)
BackAttachSocketOffset.AttachSocketOffset = 0x10 // FTransform (Size: 0x30)
BadgeAttachInfo.AttachEquipMeshComp = 0x0 // SGInventoryEquipMeshComponent* (Size: 0x8)
BadgeAttachInfo.AttachOffset = 0x10 // FTransform (Size: 0x30)
BattleTestAreaInfo.MaxAINum = 0x0 // int32_t (Size: 0x4)
BattleTestAreaInfo.AIPool = 0x8 // TArray<FAIPoolInfo> (Size: 0x10)
BattleTestRoomInfo.AreaNames = 0x0 // TArray<FString> (Size: 0x10)
BattleTestTeamInfo.TeamInfo = 0x0 // TArray<FBattleTestAreaInfo> (Size: 0x10)
BeUsedRecord.User = 0x0 // Actor* (Size: 0x8)
BeUsedRecord.UsedTimes = 0x8 // int32_t (Size: 0x4)
BehaviorControlData.bLockInput = 0x0 // bool (Size: 0x1)
BehaviorControlData.bLockMove = 0x1 // bool (Size: 0x1)
BenchmarkQualityLevels.ResolutionQuality = 0x0 // int32_t (Size: 0x4)
BenchmarkQualityLevels.ViewDistanceQuality = 0x4 // int32_t (Size: 0x4)
BenchmarkQualityLevels.AntiAliasingQuality = 0x8 // int32_t (Size: 0x4)
BenchmarkQualityLevels.ShadowQuality = 0xc // int32_t (Size: 0x4)
BenchmarkQualityLevels.LightingQuality = 0x10 // int32_t (Size: 0x4)
BenchmarkQualityLevels.WorldDetailQuality = 0x14 // int32_t (Size: 0x4)
BenchmarkQualityLevels.PostProcessQuality = 0x18 // int32_t (Size: 0x4)
BenchmarkQualityLevels.TextureQuality = 0x1c // int32_t (Size: 0x4)
BenchmarkQualityLevels.EffectsQuality = 0x20 // int32_t (Size: 0x4)
BenchmarkQualityLevels.FoliageQuality = 0x24 // int32_t (Size: 0x4)
BenchmarkQualityLevels.ShadingQuality = 0x28 // int32_t (Size: 0x4)
BenchmarkQualityLevels.CPUBenchmarkResults = 0x2c // float (Size: 0x4)
BenchmarkQualityLevels.GPUBenchmarkResults = 0x30 // float (Size: 0x4)
BigGoldRaidBoxSpawnInfo.ItemId = 0x0 // uint32_t (Size: 0x4)
BigGoldRaidBoxSpawnInfo.Weight = 0x4 // int32_t (Size: 0x4)
BlackStoreAlreadyBuyInfo.ItemId = 0x0 // int32_t (Size: 0x4)
BlackStoreAlreadyBuyInfo.CurrentBuyNum = 0x4 // int32_t (Size: 0x4)
BlackStoreItem.ItemId = 0x0 // uint64_t (Size: 0x8)
BlackStoreItem.MaxBuyNum = 0x8 // int32_t (Size: 0x4)
BlackStoreItem.CurrentNum = 0xc // int32_t (Size: 0x4)
BlackStoreItem.UniqueID = 0x10 // int32_t (Size: 0x4)
BlackStoreItem.bUseCoinPrice = 0x14 // bool (Size: 0x1)
BlackStoreItem.Price = 0x18 // int32_t (Size: 0x4)
BlackStoreItem.CoinPrice = 0x1c // int32_t (Size: 0x4)
BlackStorePlanInfo.PlanId = 0x0 // int64_t (Size: 0x8)
BlackStorePlanInfo.RandomWeight = 0x8 // int32_t (Size: 0x4)
BloodDecalInfo.Material = 0x0 // MaterialInterface* (Size: 0x8)
BloodDecalInfo.BaseScale = 0x8 // FVector2D (Size: 0x8)
BloodDecalInfo.ScaleMultRange = 0x10 // FVector2D (Size: 0x8)
BloodRandomConfig.NumMin = 0x0 // int32_t (Size: 0x4)
BloodRandomConfig.NumMax = 0x4 // int32_t (Size: 0x4)
BloodRandomConfig.DurationMin = 0x8 // int32_t (Size: 0x4)
BloodRandomConfig.DurationMax = 0xc // int32_t (Size: 0x4)
BloodRandomConfig.PosX_Min_1 = 0x10 // float (Size: 0x4)
BloodRandomConfig.PosX_Max_1 = 0x14 // float (Size: 0x4)
BloodRandomConfig.PosX_Min_2 = 0x18 // float (Size: 0x4)
BloodRandomConfig.PosX_Max_2 = 0x1c // float (Size: 0x4)
BloodRandomConfig.PosY_Min_1 = 0x20 // float (Size: 0x4)
BloodRandomConfig.PosY_Max_1 = 0x24 // float (Size: 0x4)
BloodRandomConfig.PosY_Min_2 = 0x28 // float (Size: 0x4)
BloodRandomConfig.PosY_Max_2 = 0x2c // float (Size: 0x4)
BloodRandomConfig.ScaleMin = 0x30 // float (Size: 0x4)
BloodRandomConfig.ScaleMax = 0x34 // float (Size: 0x4)
BloodRandomConfig.RotatingAngleMin = 0x38 // float (Size: 0x4)
BloodRandomConfig.RotatingAngleMax = 0x3c // float (Size: 0x4)
BodyBounds.Origin = 0x0 // FVector (Size: 0xc)
BodyBounds.BoxExtent = 0xc // FVector (Size: 0xc)
BodyBounds.SphereRadius = 0x18 // float (Size: 0x4)
BodyPartBuffInfo.EnduranceType = 0x0 // EECharacterEnduranceType (Size: 0x1)
BodyPartBuffInfo.BuffList = 0x8 // TArray<int32_t> (Size: 0x10)
BodyPartEndurance.HeadEndurance = 0x0 // float (Size: 0x4)
BodyPartEndurance.ChestEndurance = 0x4 // float (Size: 0x4)
BodyPartEndurance.StomachEndurance = 0x8 // float (Size: 0x4)
BodyPartEndurance.LeftArmEndurance = 0xc // float (Size: 0x4)
BodyPartEndurance.RightArmEndurance = 0x10 // float (Size: 0x4)
BodyPartEndurance.LeftLegEndurance = 0x14 // float (Size: 0x4)
BodyPartEndurance.RightLegEndurance = 0x18 // float (Size: 0x4)
BoneModifyInfo.BoneName = 0x0 // FName (Size: 0x8)
BoneModifyInfo.BoneScale = 0x8 // float (Size: 0x4)
BoreInfo.BoreBullet = 0x0 // ClassProperty (Size: 0x8)
BoreInfo.bCurrent = 0x8 // bool (Size: 0x1)
BoreInfo.bTriggered = 0x9 // bool (Size: 0x1)
BoreInfo.FromPlayerInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
BoreListFakeBullets.Bullets = 0x0 // TArray<StaticMeshComponent*> (Size: 0x10)
BreakInfo.bBroken = 0x0 // bool (Size: 0x1)
BreakInfo.Dir = 0x4 // FVector (Size: 0xc)
BreakInfo.Count = 0x10 // int32_t (Size: 0x4)
BrilliantTimeReplayInfo.TypeIndexList = 0x0 // TArray<int32_t> (Size: 0x10)
BrilliantTimeReplayInfo.StartTimeList = 0x10 // TArray<FDateTime> (Size: 0x10)
BrilliantTimeReplayInfo.EndTimeList = 0x20 // TArray<FDateTime> (Size: 0x10)
BroadcastOnGameHUDConfig.ReportType = 0x0 // EEReportType (Size: 0x1)
BroadcastOnGameHUDConfig.OptionalMessageID = 0x4 // int32_t (Size: 0x4)
BroadcastOnGameHUDConfig.OptionalText = 0x8 // FText (Size: 0x18)
BroadcastOnGameHUDConfig.bNotClearQueue = 0x20 // bool (Size: 0x1)
BroadcastOnGameHUDConfig.CheckServerTimeIndex = 0x24 // int32_t (Size: 0x4)
BroadcastOnGameHUDConfig.bCheckOutOfTime = 0x28 // bool (Size: 0x1)
BulletContainerInfo.BulletItemID = 0x0 // uint64_t (Size: 0x8)
BulletContainerInfo.StackCount = 0x8 // int32_t (Size: 0x4)
BulletDisplayInfoOB.SimpleDisplayName = 0x0 // FString (Size: 0x10)
BulletDisplayInfoOB.PenetrateLevel = 0x10 // int32_t (Size: 0x4)
BulletHolesInfo.TakerGID = 0x0 // int64_t (Size: 0x8)
BulletHolesInfo.CauserGID = 0x8 // int64_t (Size: 0x8)
BulletHolesInfo.ArmorReduceDamage = 0x10 // float (Size: 0x4)
BulletHolesInfo.RealDamage = 0x14 // float (Size: 0x4)
BulletHolesInfo.BodyPart = 0x18 // EEHitGroupType (Size: 0x1)
BulletHolesInfo.HeadSubGroupPart = 0x19 // EEHeadHitSubGroupType (Size: 0x1)
BulletHolesInfo.Timestamp = 0x1c // int32_t (Size: 0x4)
BulletHolesInfo.BeforeEndurance = 0x20 // FBodyPartEndurance (Size: 0x1c)
BulletHolesInfo.CurrentEndurance = 0x3c // FBodyPartEndurance (Size: 0x1c)
BulletHolesInfo.MaxEndurance = 0x58 // FBodyPartEndurance (Size: 0x1c)
BulletHolesInfo.BuffList = 0x78 // TArray<FBodyPartBuffInfo> (Size: 0x10)
BulletHolesInfo.ArmorId = 0x88 // uint64_t (Size: 0x8)
BulletHolesInfo.CurrentArmorDurability = 0x90 // int32_t (Size: 0x4)
BulletHolesInfo.CurrentArmorDurabilityMax = 0x94 // int32_t (Size: 0x4)
BulletHolesInfo.CosumeArmorDurability = 0x98 // int32_t (Size: 0x4)
BulletHolesInfo.PenetrateArmorProbability = 0x9c // float (Size: 0x4)
BulletHolesInfo.bPenetrateArmor = 0xa0 // bool (Size: 0x1)
BulletHolesInfo.bBodyHitThrough = 0xa1 // bool (Size: 0x1)
BulletHolesInfo.bRicochet = 0xa2 // bool (Size: 0x1)
BulletInfo.CurSpeed = 0x0 // float (Size: 0x4)
BulletInfo.DropDistance = 0x4 // float (Size: 0x4)
BulletInfo.SpawnLocation = 0x8 // FVector (Size: 0xc)
BulletInfo.FlyDistance = 0x14 // float (Size: 0x4)
BulletInfo.FlyTime = 0x18 // float (Size: 0x4)
BulletInfo.DamageScale = 0x1c // float (Size: 0x4)
BulletMeshInfo.SocketName = 0x0 // FName (Size: 0x8)
BulletMeshInfo.Mesh = 0x8 // StaticMeshComponent* (Size: 0x8)
BulletMeshInfo.BeltMesh = 0x10 // StaticMeshComponent* (Size: 0x8)
BulletMeshInfo.CacheMesh = 0x18 // StaticMesh* (Size: 0x8)
BulletMeshInfo.BulletClass = 0x20 // FSoftObjectPath (Size: 0x18)
BulletPassStruct.PassDir = 0x0 // FVector (Size: 0xc)
BulletPassStruct.PassLocation = 0xc // FVector (Size: 0xc)
BulletPassStruct.BulletPassAngle = 0x18 // float (Size: 0x4)
BulletPassStruct.TimeToReach = 0x1c // float (Size: 0x4)
BulletPassStruct.EnterPoint = 0x20 // FVector (Size: 0xc)
BulletPassStruct.LeavePoint = 0x2c // FVector (Size: 0xc)
BulletPassStruct.SoundEmitterIDs = 0x38 // TArray<int64_t> (Size: 0x10)
BulletPassStructDeprecated.Velocity = 0x0 // float (Size: 0x4)
BulletPassStructDeprecated.PassDir = 0x4 // FVector (Size: 0xc)
BulletPassStructDeprecated.PassLocation = 0x10 // FVector (Size: 0xc)
BulletPassStructDeprecated.BulletPassAngle = 0x1c // float (Size: 0x4)
BulletPassStructDeprecated.TimeToReach = 0x20 // float (Size: 0x4)
BulletPassStructDeprecated.EnterPoint = 0x34 // FVector (Size: 0xc)
BulletPassStructDeprecated.LeavePoint = 0x40 // FVector (Size: 0xc)
BulletTraceDataAsset.BulletTraceParams = 0x30 // FBulletTraceParams (Size: 0x10)
BulletTraceParams.BaseTraceRadius = 0x0 // float (Size: 0x4)
BulletTraceParams.TraceRadiusScaleByDistanceCurve = 0x8 // CurveFloat* (Size: 0x8)
BurningInfo.bIsBurning = 0x0 // bool (Size: 0x1)
BurningInfo.Count = 0x4 // int32_t (Size: 0x4)
BurningMaterialParamInfo.ParamName = 0x0 // FName (Size: 0x8)
BurningMaterialParamInfo.MaxValue = 0x8 // float (Size: 0x4)
BurningMaterialParamInfo.CurrValue = 0xc // float (Size: 0x4)
BurningMaterialParamInfo.ValuePerSec = 0x10 // float (Size: 0x4)
CAIndoorSpatialVolume.FloorID = 0x348 // int32_t (Size: 0x4)
CachePSCQueueInfo.AlivePSCQueue = 0x0 // TArray<ParticleSystemComponent*> (Size: 0x10)
CachePooledEffectActorQueueInfo.AlivePooledEffectActorsQueue = 0x0 // TArray<SGPooledFireEffect*> (Size: 0x10)
CachedDamageInfo.DamageTaker = 0x0 // Actor* (Size: 0x8)
CachedDamageInfo.HitDistance = 0x8 // float (Size: 0x4)
CachedDamageInfo.ProjileLocation = 0xc // FVector (Size: 0xc)
CachedDeadCharacterInfo.DeadCharacterGID = 0x0 // int64_t (Size: 0x8)
CachedDeadCharacterInfo.channelType = 0x8 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.PlatId = 0xc // int32_t (Size: 0x4)
CachedDeadCharacterInfo.PlayerLevel = 0x10 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.RankLevel = 0x14 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.CurSeason_ID = 0x18 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.DeadCharacterType = 0x1c // EECharacterType (Size: 0x1)
CachedDeadCharacterInfo.DeadCharacterTeamID = 0x20 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.Area_ID = 0x24 // uint32_t (Size: 0x4)
CachedDeadCharacterInfo.TeamType = 0x28 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.KilledPlayerName = 0x30 // FString (Size: 0x10)
CachedDeadCharacterInfo.KillerPlayerName = 0x40 // FString (Size: 0x10)
CachedDeadCharacterInfo.DeathType = 0x50 // EECharacterDeathType (Size: 0x1)
CachedDeadCharacterInfo.KilledTime = 0x54 // float (Size: 0x4)
CachedDeadCharacterInfo.KillerBulletId = 0x58 // int64_t (Size: 0x8)
CachedDeadCharacterInfo.KillerCharacterGID = 0x60 // int64_t (Size: 0x8)
CachedDeadCharacterInfo.KillerCharacterType = 0x68 // EECharacterType (Size: 0x1)
CachedDeadCharacterInfo.KillerWeaponId = 0x70 // int64_t (Size: 0x8)
CachedDeadCharacterInfo.EnterDsZone = 0x78 // int32_t (Size: 0x4)
CachedDeadCharacterInfo.IdealDsZone = 0x7c // int32_t (Size: 0x4)
CachedDeadCharacterInfo.DeadCharacterFactionType = 0x80 // EEFactionType (Size: 0x1)
CachedDeadCharacterInfo.DeathPart = 0x81 // EECharacterEnduranceType (Size: 0x1)
CachedDeadCharacterInfo.RelationType = 0x82 // EEBetweenRelationType (Size: 0x1)
CachedDeadCharacterInfo.DeathTime = 0x88 // FDateTime (Size: 0x8)
CachedFirePassByInfo.CachedActors = 0x10 // TSet<...> (Size: 0x50)
CachedRTInfo.MaterialInst = 0x0 // MaterialInstanceDynamic* (Size: 0x8)
CachedRTInfo.ReferenceCount = 0x8 // int32_t (Size: 0x4)
CachedRTInfo.LastAddReferenceTime = 0xc // float (Size: 0x4)
CameraFocusPointParams.FocusActor = 0x0 // Actor* (Size: 0x8)
CameraFocusPointParams.FocusBoneName = 0x8 // FName (Size: 0x8)
CameraFocusPointParams.FocusWorldLoc = 0x10 // FVector (Size: 0xc)
CameraFocusPointParams.CameraFOV = 0x1c // float (Size: 0x4)
CameraFocusPointParams.InterpSpeedRange = 0x20 // FVector2D (Size: 0x8)
CameraFocusPointParams.InFocusFOV = 0x28 // FVector2D (Size: 0x8)
CameraFocusPointParams.bAlwaysFocus = 0x30 // bool (Size: 0x1)
CameraFocusPointParams.bAdjustCamera = 0x31 // bool (Size: 0x1)
CameraFocusPointParams.bIgnoreTrace = 0x32 // bool (Size: 0x1)
CameraFocusPointParams.FocusPitchOffsetDeg = 0x34 // float (Size: 0x4)
CaptureActorSpecialMeshInfo.Inv = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
CaptureActorSpecialMeshInfo.MeshComp = 0x8 // MeshComponent* (Size: 0x8)
CharacterAbilityDebugInfo.ActiveAbiltiyNameList = 0x0 // TArray<FString> (Size: 0x10)
CharacterAbilityDebugInfo.ActiveGameEffectNameList = 0x10 // TArray<FString> (Size: 0x10)
CharacterAbilityDebugInfo.OwnedTagsList = 0x20 // TArray<FString> (Size: 0x10)
CharacterAbilityDebugInfo.BlockedTagsStringList = 0x30 // TArray<FString> (Size: 0x10)
CharacterAbilityDebugInfo.MinimalTagsList = 0x40 // TArray<FString> (Size: 0x10)
CharacterBuffInfo.EnduranceType = 0x0 // int32_t (Size: 0x4)
CharacterBuffInfo.BuffList = 0x8 // TArray<int32_t> (Size: 0x10)
CharacterDeathInfo.bIsDead = 0x0 // bool (Size: 0x1)
CharacterDeathInfo.bForceDied = 0x1 // bool (Size: 0x1)
CharacterDeathInfo.Timestamp = 0x4 // float (Size: 0x4)
CharacterDeathInfo.DeathCount = 0x8 // int32_t (Size: 0x4)
CharacterDeathInfo.DeathLocation = 0xc // FVector (Size: 0xc)
CharacterDeathInfo.DeathRotation = 0x18 // FRotator (Size: 0xc)
CharacterDeathInfo.DamageCauser = 0x28 // Actor* (Size: 0x8)
CharacterDeathInfo.DamageCauserType = 0x30 // EESGDamageCauserType (Size: 0x1)
CharacterDeathInfo.DeathBodyPart = 0x31 // EECharacterEnduranceType (Size: 0x1)
CharacterDeathInfo.Momentum = 0x34 // FVector (Size: 0xc)
CharacterDeathInfo.bPenetrateArmor = 0x40 // bool (Size: 0x1)
CharacterDeathInfo.DeathAnimationState = 0x41 // EEAnimStance (Size: 0x1)
CharacterDeathInfo.HitGroup = 0x42 // EEHitGroupType (Size: 0x1)
CharacterDeathInfo.DeathAnimation = 0x48 // AnimMontage* (Size: 0x8)
CharacterDeathMurderStatics.MurderPS = 0x0 // SGPlayerState* (Size: 0x8)
CharacterDeathMurderStatics.MurderTeamType = 0x8 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderTeamIndex = 0xc // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderName = 0x10 // FString (Size: 0x10)
CharacterDeathMurderStatics.MurderID = 0x20 // int64_t (Size: 0x8)
CharacterDeathMurderStatics.MurderLevel = 0x28 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderRanking = 0x2c // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderPRanking = 0x30 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderRanked_Rd = 0x34 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderRankLevel = 0x38 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderRankScore = 0x3c // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderRank = 0x40 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderPVPRanking = 0x44 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderWeaponId = 0x48 // int64_t (Size: 0x8)
CharacterDeathMurderStatics.MurderWeapon = 0x50 // TArray<FSGClientShowItemInfo> (Size: 0x10)
CharacterDeathMurderStatics.MurderIsAI = 0x60 // bool (Size: 0x1)
CharacterDeathMurderStatics.MurderCharacterType = 0x61 // EECharacterType (Size: 0x1)
CharacterDeathMurderStatics.MurderNetGUIDForReplay = 0x64 // int32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderPos = 0x68 // FVector (Size: 0xc)
CharacterDeathMurderStatics.MurderNationalFlagIso = 0x74 // uint32_t (Size: 0x4)
CharacterDeathMurderStatics.MurderIconInfo = 0x78 // FSGPlayerIconInfo (Size: 0x58)
CharacterDeathMurderStatics.MurderBannerInfo = 0xd0 // FSGPlayerBannerInfo (Size: 0x28)
CharacterDeathStatics.DeathType = 0x0 // EECharacterDeathType (Size: 0x1)
CharacterDeathStatics.WeaponId = 0x8 // int64_t (Size: 0x8)
CharacterDeathStatics.Distance = 0x10 // float (Size: 0x4)
CharacterDeathStatics.EnduranceType = 0x14 // int32_t (Size: 0x4)
CharacterDeathStatics.SpreadEnduranceType = 0x18 // int32_t (Size: 0x4)
CharacterDeathStatics.DeathCauserId = 0x20 // int64_t (Size: 0x8)
CharacterDeathStatics.Damage = 0x28 // float (Size: 0x4)
CharacterDeathStatics.bPenetrateArmor = 0x2c // int32_t (Size: 0x4)
CharacterDeathStatics.PenetrateArmorProbability = 0x30 // float (Size: 0x4)
CharacterDeathStatics.CauserName = 0x38 // FString (Size: 0x10)
CharacterDeathStatics.DeathTime = 0x48 // int64_t (Size: 0x8)
CharacterDeathStatics.HitLocationDireciton = 0x50 // FVector (Size: 0xc)
CharacterDeathStatics.HitArmorId = 0x60 // int64_t (Size: 0x8)
CharacterDeathStatics.TeamTypeId = 0x68 // int32_t (Size: 0x4)
CharacterDeathStatics.TeamID = 0x6c // int32_t (Size: 0x4)
CharacterDeathStatics.FactionType = 0x70 // EEFactionType (Size: 0x1)
CharacterDeathStatics.KillerTeamTypeId = 0x74 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerFactionType = 0x78 // EEFactionType (Size: 0x1)
CharacterDeathStatics.bHitFace = 0x79 // int8_t (Size: 0x1)
CharacterDeathStatics.bDiedFromDBNO = 0x7a // int8_t (Size: 0x1)
CharacterDeathStatics.DBNOGID = 0x80 // uint64_t (Size: 0x8)
CharacterDeathStatics.CurrentArmorDurability = 0x88 // int32_t (Size: 0x4)
CharacterDeathStatics.CurrentArmorDurabilityMax = 0x8c // int32_t (Size: 0x4)
CharacterDeathStatics.DetailBodyPart = 0x90 // int32_t (Size: 0x4)
CharacterDeathStatics.LastHitDamage = 0x94 // float (Size: 0x4)
CharacterDeathStatics.LastHitArmorDamage = 0x98 // float (Size: 0x4)
CharacterDeathStatics.Endurance = 0x9c // float (Size: 0x4)
CharacterDeathStatics.MainWeapon = 0xa0 // int32_t (Size: 0x4)
CharacterDeathStatics.AssistWeapon = 0xa4 // int32_t (Size: 0x4)
CharacterDeathStatics.AliveTime = 0xa8 // float (Size: 0x4)
CharacterDeathStatics.DeathPos = 0xac // FVector (Size: 0xc)
CharacterDeathStatics.KillerPos = 0xb8 // FVector (Size: 0xc)
CharacterDeathStatics.KillerLevel = 0xc4 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerRankLevel = 0xc8 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerID = 0xd0 // uint64_t (Size: 0x8)
CharacterDeathStatics.KillerTeamID = 0xd8 // int32_t (Size: 0x4)
CharacterDeathStatics.SightName = 0xe0 // FString (Size: 0x10)
CharacterDeathStatics.Killer = 0xf0 // Character* (Size: 0x8)
CharacterDeathStatics.HitGroup = 0xf8 // int32_t (Size: 0x4)
CharacterDeathStatics.HitSubHeadPart = 0xfc // int32_t (Size: 0x4)
CharacterDeathStatics.LastAimEnemyGID = 0x100 // int64_t (Size: 0x8)
CharacterDeathStatics.LastAimEnemyCauseDamage = 0x108 // int32_t (Size: 0x4)
CharacterDeathStatics.LastAimEnemyCauseArmorReduceDamage = 0x10c // int32_t (Size: 0x4)
CharacterDeathStatics.DeathVestID = 0x110 // int64_t (Size: 0x8)
CharacterDeathStatics.DeathHelmetID = 0x118 // int64_t (Size: 0x8)
CharacterDeathStatics.DeathFaceShieldID = 0x120 // int64_t (Size: 0x8)
CharacterDeathStatics.KillerVestID = 0x128 // int64_t (Size: 0x8)
CharacterDeathStatics.KillerHelmetID = 0x130 // int64_t (Size: 0x8)
CharacterDeathStatics.KillerFaceShieldID = 0x138 // int64_t (Size: 0x8)
CharacterDeathStatics.KillerWeaponValue = 0x140 // int32_t (Size: 0x4)
CharacterDeathStatics.CauseDBNOWeaponID = 0x144 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerWeaponItemInfo = 0x148 // SGPlayerItemInfoBase* (Size: 0x8)
CharacterDeathStatics.OnFlash = 0x150 // int32_t (Size: 0x4)
CharacterDeathStatics.ByHoldGrenade = 0x154 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerNetGUIDForReplay = 0x158 // int32_t (Size: 0x4)
CharacterDeathStatics.OnInventoryFlash = 0x15c // int32_t (Size: 0x4)
CharacterDeathStatics.OnTinnitus = 0x160 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerNameCardAvatar = 0x164 // int32_t (Size: 0x4)
CharacterDeathStatics.KillerVehicleID = 0x168 // int64_t (Size: 0x8)
CharacterDeathStatics.LastHitByOtherInfo = 0x170 // FSGLastHitByInfo (Size: 0x30)
CharacterDeathStatics.bSuicideWithoutCauser = 0x1a0 // bool (Size: 0x1)
CharacterDeathStatics.bKillerFlashLightOpen = 0x1a1 // int8_t (Size: 0x1)
CharacterDeathStatics.bFromHitThroughBody = 0x1a2 // bool (Size: 0x1)
CharacterDeathVictimStatics.VictimGID = 0x0 // int32_t (Size: 0x4)
CharacterDeathVictimStatics.VictimName = 0x8 // FString (Size: 0x10)
CharacterDeathVictimStatics.DieTimestamp = 0x18 // int32_t (Size: 0x4)
CharacterDeathVictimStatics.BulletHoles = 0x20 // TArray<FBulletHolesInfo> (Size: 0x10)
CharacterDeathVictimStatics.DeathStatics = 0x30 // FCharacterDeathStatics (Size: 0x1a8)
CharacterDeathVictimStatics.AllHealthStaticsWhenDead = 0x1d8 // TArray<FCharacterHealthStaticsWhenDead> (Size: 0x10)
CharacterDeathVictimStatics.VictimIconInfo = 0x1e8 // FSGPlayerIconInfo (Size: 0x58)
CharacterDeathVictimStatics.VictimBannerInfo = 0x240 // FSGPlayerBannerInfo (Size: 0x28)
CharacterDeathVictimStatics.PlayerShowInfo = 0x268 // FSGPlayerShowInfo (Size: 0x40)
CharacterDeathVictimStatics.MurderInfo = 0x2a8 // FCharacterDeathMurderStatics (Size: 0xf8)
CharacterDefaultInventoryList.DefaultPickupInventories = 0x0 // TArray<ClassProperty> (Size: 0x10)
CharacterDefaultInventoryList.DefaultPickupToBagInventories = 0x10 // TArray<ClassProperty> (Size: 0x10)
CharacterEnduranceAbility.BleedDebuffAbilitiesByChance = 0x0 // FCharacterEnduranceDebuffAbility_Bleed (Size: 0x30)
CharacterEnduranceAbility.PainDebuffAbilitiesByChance = 0x30 // FCharacterEnduranceDebuffAbility (Size: 0x28)
CharacterEnduranceAbility.BoneBreakDebuffAbilitiesByChance = 0x58 // FCharacterEnduranceDebuffAbility (Size: 0x28)
CharacterEnduranceAbility.TunnelVisonDebuffAbilitiesByChance = 0x80 // FCharacterEnduranceDebuffAbility (Size: 0x28)
CharacterEnduranceAbility.FreshWoundDebuffAbilitiesByChance = 0xa8 // FCharacterEnduranceDebuffAbility (Size: 0x28)
CharacterEnduranceAbility.TinnitusDebuffAbilities = 0xd0 // FCharacterEnduranceDebuffAbility_Tinnitus (Size: 0x28)
CharacterEnduranceAbility.StunDebuffAbilities = 0xf8 // FCharacterEnduranceDebuffAbility_Stun (Size: 0x28)
CharacterEnduranceAbility.AutoRecoverAbilityClass = 0x120 // ClassProperty (Size: 0x8)
CharacterEnduranceAbility.ForbiddenAutoRecoverByTakeDamageAbilityClass = 0x128 // ClassProperty (Size: 0x8)
CharacterEnduranceAbility.InfiniteForbiddenAutoRecoverByTakeDamageAbilityClass = 0x130 // ClassProperty (Size: 0x8)
CharacterEnduranceAbility.OutOfEnduranceAbilityClass = 0x138 // ClassProperty (Size: 0x8)
CharacterEnduranceAbility.bSpreadDamageToOthersWhenOutOfEndurance = 0x140 // bool (Size: 0x1)
CharacterEnduranceAbility.SpreadDamageScale = 0x144 // float (Size: 0x4)
CharacterEnduranceAbility.EffectDuration = 0x148 // float (Size: 0x4)
CharacterEnduranceDebuffAbility.ChanceToTrigger = 0x0 // float (Size: 0x4)
CharacterEnduranceDebuffAbility.DebuffAbilityClass = 0x8 // ClassProperty (Size: 0x8)
CharacterEnduranceDebuffAbility.TriggerChanceCurve = 0x10 // CurveFloat* (Size: 0x8)
CharacterEnduranceDebuffAbility.DurationTimeCurve = 0x18 // CurveFloat* (Size: 0x8)
CharacterEnduranceDebuffAbility_Bleed.TrapTriggerChance = 0x28 // float (Size: 0x4)
CharacterEnduranceDebuffAbility_Bleed.BurnTriggerChance = 0x2c // float (Size: 0x4)
CharacterGameEffectTags.AnyTag = 0x0 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.HeadTag = 0x8 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.ChestTag = 0x10 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.StomachTag = 0x18 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.LeftArmTag = 0x20 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.RightArmTag = 0x28 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.LeftLegTag = 0x30 // FGameplayTag (Size: 0x8)
CharacterGameEffectTags.RightLegTag = 0x38 // FGameplayTag (Size: 0x8)
CharacterHealthStaticsWhenDead.PlayerId = 0x0 // int64_t (Size: 0x8)
CharacterHealthStaticsWhenDead.EnduranceType = 0x8 // int32_t (Size: 0x4)
CharacterHealthStaticsWhenDead.Health = 0xc // float (Size: 0x4)
CharacterHealthStaticsWhenDead.MaxHealth = 0x10 // float (Size: 0x4)
CharacterHealthStaticsWhenDead.BuffList = 0x18 // TArray<int32_t> (Size: 0x10)
CharacterHealthStaticsWhenDeads.CharacterHealthStaticsWhenDeadArray = 0x0 // TArray<FCharacterHealthStaticsWhenDead> (Size: 0x10)
CharacterLeanParams.LeanRollOffset = 0x0 // float (Size: 0x4)
CharacterLeanParams.LeanLOffset = 0x4 // FVector (Size: 0xc)
CharacterLeanParams.LeanROffset = 0x10 // FVector (Size: 0xc)
CharacterLeanParams.LeanInterpSpeedLRToCenter = 0x1c // float (Size: 0x4)
CharacterLeanParams.LeanInterpSpeedCenterToLR = 0x20 // float (Size: 0x4)
CharacterLeanParams.LeanInterpSpeedLRToOtherSide = 0x24 // float (Size: 0x4)
CharacterLootBoxExternalData.LootPointID = 0x0 // int32_t (Size: 0x4)
CharacterLootBoxItemExternalData.LootPointID = 0x0 // int32_t (Size: 0x4)
CharacterLootBoxItemExternalData.LootItemID = 0x4 // int32_t (Size: 0x4)
CharacterLootPlayerBoxExternalData.PlayerGid = 0x0 // uint64_t (Size: 0x8)
CharacterLootPlayerBoxItemExternalData.PlayerGid = 0x0 // uint64_t (Size: 0x8)
CharacterLootPlayerBoxItemExternalData.ItemId = 0x8 // int32_t (Size: 0x4)
CharacterLootPlayerBoxItemExternalData.ItemValue = 0xc // int32_t (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.F_Speed = 0x0 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.L_Speed = 0x4 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.R_Speed = 0x8 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.B_Speed = 0xc // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.LF_Speed = 0x10 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.RF_Speed = 0x14 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.LB_Speed = 0x18 // float (Size: 0x4)
CharacterSpeedWarpingBaseSpeed.RB_Speed = 0x1c // float (Size: 0x4)
CharacterVehicleRepData.Vehicle = 0x0 // Pawn* (Size: 0x8)
CharacterVehicleRepData.SeatIndex = 0x8 // int32_t (Size: 0x4)
CharacterVehicleRepData.ExitLocation = 0xc // FVector (Size: 0xc)
CharacterVehicleRepData.ExitFaceRotation = 0x18 // FRotator (Size: 0xc)
CharacterVehicleRepData.bIsSwitchSeatSync = 0x24 // bool (Size: 0x1)
CharacterVehicleRepData.LastVehicle = 0x28 // Pawn* (Size: 0x8)
ChaseActivityAvatarInfo.AvatarItemID = 0x0 // int32_t (Size: 0x4)
ChaseActivityAvatarInfo.ScanningRange = 0x4 // float (Size: 0x4)
ChaseActivityAvatarInfo.ScanningInterval = 0x8 // float (Size: 0x4)
ChaseActivityAvatarInfo.ScanningIntervalScale = 0xc // int32_t (Size: 0x4)
ChaseActivityStateChangeInfo.PreviousState = 0x0 // EEChaseActivityState (Size: 0x1)
ChaseActivityStateChangeInfo.CurrentState = 0x1 // EEChaseActivityState (Size: 0x1)
ChaseActivityStateChangeInfo.ServerTime = 0x4 // float (Size: 0x4)
ClientQueueBunchReportData.PathName = 0x0 // FString (Size: 0x10)
ClientQueueBunchReportData.QueueTime = 0x10 // float (Size: 0x4)
ClientQueueBunchReportData.EventTime = 0x14 // float (Size: 0x4)
ClientQueueBunchReportData.PCFlowState = 0x18 // FString (Size: 0x10)
ClientQueueBunchReportData.ClassName = 0x28 // FString (Size: 0x10)
ColorLUTConf.Name = 0x8 // FString (Size: 0x10)
ColorLUTConf.Image = 0x18 // Texture2D* (Size: 0x8)
CombatDamageInfo_HD.BulletID = 0x0 // FSGBulletID (Size: 0x10)
CombatDamageInfo_HD.TargetName = 0x10 // FName (Size: 0x8)
CombatDamageInfo_HD.bTargetDead = 0x18 // bool (Size: 0x1)
CombatDamageInfo_HD.HitGroup = 0x19 // EEHitGroupType (Size: 0x1)
CombatDamageInfo_HD.HeadHitSubGroup = 0x1a // EEHeadHitSubGroupType (Size: 0x1)
CombatDamageInfo_HD.ArmorLevel = 0x1c // int32_t (Size: 0x4)
CombatDamageInfo_HD.ArmorDurability = 0x20 // float (Size: 0x4)
CombatDamageInfo_HD.ArmorDurabilityMax = 0x24 // float (Size: 0x4)
CombatDamageInfo_HD.bPenetrateArmor = 0x28 // bool (Size: 0x1)
CombatDamageInfo_HD.bBrokenBullet = 0x29 // bool (Size: 0x1)
CombatDamageInfo_HD.Damage = 0x2c // float (Size: 0x4)
CombatDamageInfo_HD.HeadEndurance = 0x30 // float (Size: 0x4)
CombatDamageInfo_HD.ChestEndurance = 0x34 // float (Size: 0x4)
CombatDamageInfo_HD.StomachEndurance = 0x38 // float (Size: 0x4)
CombatDamageInfo_HD.LeftArmEndurance = 0x3c // float (Size: 0x4)
CombatDamageInfo_HD.RightArmEndurance = 0x40 // float (Size: 0x4)
CombatDamageInfo_HD.LeftLegEndurance = 0x44 // float (Size: 0x4)
CombatDamageInfo_HD.RightLegEndurance = 0x48 // float (Size: 0x4)
CombatDamageInfo_HD.bThroughBody = 0x4c // bool (Size: 0x1)
CombatRecord_HD.FireInfo = 0x0 // FSGFireRepInfo (Size: 0x70)
CombatRecord_HD.Timestamp = 0x70 // float (Size: 0x4)
CombatRecord_HD.DamageInfo = 0x78 // FCombatDamageInfo_HD (Size: 0x50)
CombatRecord_HD.ThroughBodyDamageInfo = 0xc8 // FCombatDamageInfo_HD (Size: 0x50)
CombatRecord_HD.bValidationFailed = 0x118 // bool (Size: 0x1)
CombatTargetInfo_HD.TargetName = 0x0 // FName (Size: 0x8)
CombatTargetInfo_HD.FireCount = 0x8 // int32_t (Size: 0x4)
CombatTargetInfo_HD.HitCount = 0xc // int32_t (Size: 0x4)
CombatTargetInfo_HD.FirstHitTime = 0x10 // float (Size: 0x4)
CombatTargetInfo_HD.DeadlyHitTime = 0x14 // float (Size: 0x4)
CommandAlias.Name = 0x0 // FString (Size: 0x10)
CommandAlias.Description = 0x10 // FString (Size: 0x10)
CommandAlias.Commands = 0x20 // TArray<FString> (Size: 0x10)
CommandAliasGroup.GroupName = 0x0 // FString (Size: 0x10)
CommandAliasGroup.CommandAliases = 0x10 // TArray<FCommandAlias> (Size: 0x10)
CompetitionBossDataInfo.AICharacter = 0x0 // Character* (Size: 0x8)
CompetitionBossDataInfo.PlayerResult = 0x8 // EESGPlayerCondition (Size: 0x1)
CompetitionBossDataInfo.BossPosition = 0xc // FVector (Size: 0xc)
CompetitionEscapeReportData.EscapePlayerTeamId = 0x0 // uint32_t (Size: 0x4)
CompetitionEscapeReportData.EscapePlayerTeamIndex = 0x4 // uint32_t (Size: 0x4)
CompetitionEscapeReportData.EscapeTeamLogo = 0x8 // int32_t (Size: 0x4)
CompetitionEscapeReportData.EscapeTeamName = 0x10 // FString (Size: 0x10)
CompetitionEscapeReportData.EscapePlayerName = 0x20 // FString (Size: 0x10)
CompetitionEscapeReportData.EscapePointID = 0x30 // int32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.PC = 0x0 // SGPlayerController* (Size: 0x8)
CompetitionGamePlayerDataInfo.PS = 0x8 // PlayerState* (Size: 0x8)
CompetitionGamePlayerDataInfo.GID = 0x10 // uint64_t (Size: 0x8)
CompetitionGamePlayerDataInfo.PlayerName = 0x18 // FString (Size: 0x10)
CompetitionGamePlayerDataInfo.PlayerKillNum = 0x28 // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.PlayerCurAllEndurance = 0x2c // float (Size: 0x4)
CompetitionGamePlayerDataInfo.PlayerCurAllEnduranceMax = 0x30 // float (Size: 0x4)
CompetitionGamePlayerDataInfo.PlayerTakeOutAllValue = 0x38 // int64_t (Size: 0x8)
CompetitionGamePlayerDataInfo.PlayerResult = 0x40 // EESGPlayerCondition (Size: 0x1)
CompetitionGamePlayerDataInfo.PlayerPosition = 0x44 // FVector (Size: 0xc)
CompetitionGamePlayerDataInfo.PlayerYaw = 0x50 // float (Size: 0x4)
CompetitionGamePlayerDataInfo.KillPlayerNum = 0x54 // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.KillScavNum = 0x58 // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.KillBossNum = 0x5c // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.TakeGrenadeCount = 0x60 // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.TakeThrowableCount = 0x64 // uint32_t (Size: 0x4)
CompetitionGamePlayerDataInfo.PlayerTakeInAllValue = 0x68 // int64_t (Size: 0x8)
CompetitionGamePlayerDataInfo.HasHelmet = 0x70 // uint8_t (Size: 0x1)
CompetitionGamePlayerDataInfo.HelmetDurabilityPercent = 0x74 // float (Size: 0x4)
CompetitionGamePlayerDataInfo.HasVest = 0x78 // uint8_t (Size: 0x1)
CompetitionGamePlayerDataInfo.VestDurabilityPercent = 0x7c // float (Size: 0x4)
CompetitionKillInfo.KilledGID = 0x0 // uint64_t (Size: 0x8)
CompetitionKillInfo.KilledName = 0x8 // FString (Size: 0x10)
CompetitionKillInfo.KilledPlayerType = 0x18 // EEPlayerTeamType (Size: 0x1)
CompetitionKillInfo.RankedLevel = 0x1c // uint32_t (Size: 0x4)
CompetitionKillInfo.Score = 0x20 // uint32_t (Size: 0x4)
CompetitionKillInfo.Level = 0x24 // uint32_t (Size: 0x4)
CompetitionKillInfo.KilledTime = 0x28 // uint32_t (Size: 0x4)
CompetitionKillInfo.KillWeaponId = 0x30 // uint64_t (Size: 0x8)
CompetitionKillInfo.KillPart = 0x38 // EECharacterEnduranceType (Size: 0x1)
CompetitionKillInfo.KillAllDamage = 0x3c // int32_t (Size: 0x4)
CompetitionKillInfo.KillAllArmorDamage = 0x40 // int32_t (Size: 0x4)
CompetitionKillInfo.HitNum = 0x44 // int32_t (Size: 0x4)
CompetitionKillInfo.ArmorId = 0x48 // int64_t (Size: 0x8)
CompetitionKillInfo.PlayerTypeDetail = 0x50 // EECharacterType (Size: 0x1)
CompetitionOBGlobalDataInfo.LeftPMCNumber = 0x0 // uint32_t (Size: 0x4)
CompetitionOBGlobalDataInfo.LeftScavNumber = 0x4 // uint32_t (Size: 0x4)
CompetitionOBGlobalDataInfo.AllTeamInfoList = 0x8 // TArray<FCompetitionTeamDataInfo> (Size: 0x10)
CompetitionOBGlobalDataInfo.AllBossInfoList = 0x18 // TArray<FCompetitionBossDataInfo> (Size: 0x10)
CompetitionOBGlobalDateComponent.SynchronizationInterval = 0xf8 // float (Size: 0x4)
CompetitionOBGlobalDateComponent.CompetitionOBGlobalDataInfo = 0x100 // FCompetitionOBGlobalDataInfo (Size: 0x28)
CompetitionOBGlobalDateComponent.SynchronizationHandle = 0x128 // FTimerHandle (Size: 0x8)
CompetitionOBGlobalDateComponent.TempPlayerDataInfo = 0x130 // FCompetitionGamePlayerDataInfo (Size: 0x80)
CompetitionOBGlobalDateComponent.GrenadeIDList = 0x1b0 // TArray<int32_t> (Size: 0x10)
CompetitionOBHUDManageComponent.Components = 0xf8 // TArray<SGUserWidget*> (Size: 0x10)
CompetitionOBHUDManageComponent.ComponentClasses = 0x108 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
CompetitionOBPersonCtlComponent.CompetitionPlayerArray = 0xf8 // TArray<SGPlayerController*> (Size: 0x10)
CompetitionOBPersonCtlComponent.OBPlayerArray = 0x108 // TArray<SGPlayerController*> (Size: 0x10)
CompetitionOBPersonCtlComponent.CacheCompetitionPC = 0x118 // TArray<SGPlayerController*> (Size: 0x10)
CompetitionOBPersonCtlComponent.CacheOBPC = 0x128 // TArray<SGPlayerController*> (Size: 0x10)
CompetitionPlayerFallReportData.KillerTeamID = 0x0 // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KillerTeamIndex = 0x4 // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KillerTeamLogo = 0x8 // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KillerTeamName = 0x10 // FString (Size: 0x10)
CompetitionPlayerFallReportData.KillerPlayerName = 0x20 // FString (Size: 0x10)
CompetitionPlayerFallReportData.KillerPlayerWeaponID = 0x30 // uint64_t (Size: 0x8)
CompetitionPlayerFallReportData.KilledTeamID = 0x38 // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KilledTeamIndex = 0x3c // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KilledTeamLogo = 0x40 // int32_t (Size: 0x4)
CompetitionPlayerFallReportData.KilledTeamName = 0x48 // FString (Size: 0x10)
CompetitionPlayerFallReportData.KilledPlayerName = 0x58 // FString (Size: 0x10)
CompetitionPlayerFallReportData.BTeamAce = 0x68 // bool (Size: 0x1)
CompetitionPlayerFallReportData.KilledCharacterType = 0x69 // EECharacterType (Size: 0x1)
CompetitionPlayerFallReportData.FallResult = 0x6a // EESGPlayerFailCondition (Size: 0x1)
CompetitionPlayerKillList.KillerGID = 0x0 // uint64_t (Size: 0x8)
CompetitionPlayerKillList.PS = 0x8 // PlayerState* (Size: 0x8)
CompetitionPlayerKillList.KillInfoArray = 0x10 // TArray<FCompetitionKillInfo> (Size: 0x10)
CompetitionTeamDataInfo.TeamID = 0x0 // uint32_t (Size: 0x4)
CompetitionTeamDataInfo.TeamName = 0x8 // FText (Size: 0x18)
CompetitionTeamDataInfo.TeamLogo = 0x20 // uint32_t (Size: 0x4)
CompetitionTeamDataInfo.AllPlayerList = 0x28 // TArray<FCompetitionGamePlayerDataInfo> (Size: 0x10)
CompetitionVerticalMoveComponent.bPressBtnUp = 0xf8 // bool (Size: 0x1)
CompetitionVerticalMoveComponent.bPressBtnDown = 0xf9 // bool (Size: 0x1)
CompetitionVerticalMoveComponent.bPressBtnRight = 0xfa // bool (Size: 0x1)
CompetitionVerticalMoveComponent.bPressBtnLeft = 0xfb // bool (Size: 0x1)
CompetitionVerticalMoveComponent.RightLeftRate = 0xfc // float (Size: 0x4)
CompetitionVerticalMoveComponent.PlayerController = 0x100 // PlayerController* (Size: 0x8)
ConfigUpdateItem.ConfigType = 0x0 // int32_t (Size: 0x4)
ConfigUpdateItem.ConfigOperate = 0x4 // int32_t (Size: 0x4)
ConfigUpdateItem.ConfigName = 0x8 // FString (Size: 0x10)
ConfigUpdateItem.ConfigSection = 0x18 // FString (Size: 0x10)
ConfigUpdateItem.ConfigKeyValues = 0x28 // TArray<FConfigUpdateItemKeyValue> (Size: 0x10)
ConfigUpdateItemKeyValue.ValueType = 0x0 // int32_t (Size: 0x4)
ConfigUpdateItemKeyValue.Key = 0x8 // FString (Size: 0x10)
ConfigUpdateItemKeyValue.Value = 0x18 // FString (Size: 0x10)
ContainerInfo.ContainActorClass = 0x0 // ClassProperty (Size: 0x8)
ContainerInfo.MaxStackCount = 0x8 // int32_t (Size: 0x4)
ContainerInfo.StackCount = 0xc // int32_t (Size: 0x4)
ContainerInfo.AttachPos = 0x10 // EEAttachPosition (Size: 0x1)
ContainerSearchingInfo.ContainerSearchingCom = 0x0 // SGInventoryContainerSearchingComponent* (Size: 0x8)
ContainerSearchingInfo.IsPendingStartAutoSearch = 0x8 // bool (Size: 0x1)
ContainerSearchingInfo.IsInAutoSearching = 0x9 // bool (Size: 0x1)
ContainerSearchingInfo.RoughSearchFinishTime = 0xc // float (Size: 0x4)
ContainerSearchingInfo.CurAutoSearchingInventorySearchCom = 0x10 // SGInventorySearchComponent* (Size: 0x8)
ContainerSearchingInfo.DetailSearchFinishTime = 0x18 // float (Size: 0x4)
ContainerSearchingInfo.BeginSeachTimeStamp = 0x20 // int64_t (Size: 0x8)
ContextMenuSlotSetting.SlotType = 0x8 // EESlotEnum (Size: 0x1)
ContextMenuSlotSetting.TextName = 0x10 // FText (Size: 0x18)
ContextMenuSlotSetting.SlotIcon = 0x28 // Texture2D* (Size: 0x8)
ContextMenuSlotType.SlotType = 0x8 // EESlotEnum (Size: 0x1)
ConversionContainerInfo.ChildActorClass = 0x0 // ClassProperty (Size: 0x8)
ConversionContainerInfo.StackCount = 0x8 // int32_t (Size: 0x4)
CooperateQTECharacterInfo.Character = 0x0 // Character* (Size: 0x8)
CooperateQTECharacterInfo.TargetAnimMontage = 0x8 // AnimMontage* (Size: 0x8)
CreateCompetitionActorComponent.ManageActorClass = 0xf8 // ClassProperty (Size: 0x8)
CrossHairTexInfo.Tex = 0x0 // Texture2D* (Size: 0x8)
CrossHairTexInfo.Scale = 0x8 // float (Size: 0x4)
CrossHairTexInfo.CrosshairLumen = 0xc // float (Size: 0x4)
CrossHairTexInfo.SwitchMagnificationAnim = 0x10 // AnimSequenceBase* (Size: 0x8)
DBNOStatis.DBNOCount = 0x0 // int32_t (Size: 0x4)
DBNOStatis.RescuedCount = 0x4 // int32_t (Size: 0x4)
DBNOStatis.RescueCount = 0x8 // int32_t (Size: 0x4)
DBNOStatis.RescuerGIDList = 0x10 // TArray<uint64_t> (Size: 0x10)
DPSStructInfo.DPS = 0x0 // float (Size: 0x4)
DPSStructInfo.DBNO_DPS = 0x4 // float (Size: 0x4)
DSSwitchConfig.nGetAttachLoopMaxNum = 0x0 // int32_t (Size: 0x4)
DSSwitchConfig.CheckLimitTime = 0x4 // float (Size: 0x4)
DSSwitchConfig.bTouchCheckSwitcher = 0x8 // bool (Size: 0x1)
DSWeaponValidateFail.WeaponId = 0x0 // FString (Size: 0x10)
DSWeaponValidateFail.WeaponType = 0x10 // int32_t (Size: 0x4)
DSWeaponValidateFail.FailType = 0x18 // FString (Size: 0x10)
DSWeaponValidateFail.ReasonStr = 0x28 // FString (Size: 0x10)
DamageBlackborad.DamageCauser = 0x0 // Actor* (Size: 0x8)
DamageBlackborad.DamageTypeEnum = 0x8 // EEDamageTypeEnum (Size: 0x1)
DamageBlackborad.HitGroup = 0x9 // EEHitGroupType (Size: 0x1)
DamageBlackborad.HitHeadPart = 0xa // EEHeadHitSubGroupType (Size: 0x1)
DamageBlackborad.HitChestPart = 0xb // EEChestHitSubGroupType (Size: 0x1)
DamageBlackborad.Momentum = 0xc // FVector (Size: 0xc)
DamageBlackborad.HitLocation = 0x18 // FVector (Size: 0xc)
DamageBlackborad.FireCounter = 0x28 // int64_t (Size: 0x8)
DamageBlackborad.HitArmor = 0x30 // Actor* (Size: 0x8)
DamageBlackborad.HitBoneName = 0x38 // FName (Size: 0x8)
DamageBlackborad.bPenetrateArmor = 0x40 // bool (Size: 0x1)
DamageBlackborad.bRicochet = 0x41 // bool (Size: 0x1)
DamageBlackborad.bFromHitThroughBody = 0x42 // bool (Size: 0x1)
DamageBlackborad.PenetrateArmorProbability = 0x44 // float (Size: 0x4)
DamageBlackborad.Damage = 0x48 // float (Size: 0x4)
DamageBlackborad.BulletID = 0x50 // int64_t (Size: 0x8)
DamageBlackborad.DamageCauserType = 0x58 // int32_t (Size: 0x4)
DamageBlackborad.bHitFace = 0x5c // int8_t (Size: 0x1)
DamageBlackborad.BeforeArmorDurability = 0x60 // int32_t (Size: 0x4)
DamageBlackborad.bDamagedWhenDBNO = 0x64 // bool (Size: 0x1)
DamageBlackborad.BeforeEndurance = 0x68 // FBodyPartEndurance (Size: 0x1c)
DamageBlackborad.BullentName = 0x90 // FString (Size: 0x10)
DamageBlackborad.BulletItemID = 0xa0 // uint32_t (Size: 0x4)
DamageEventObject.DamageTypeClass = 0x28 // ClassProperty (Size: 0x8)
DebuffInfoStruct.CauserId = 0x0 // int64_t (Size: 0x8)
DebuffInfoStruct.TakerId = 0x8 // int64_t (Size: 0x8)
DebuffInfoStruct.EventTime = 0x10 // int64_t (Size: 0x8)
DebuffInfoStruct.BodyPart = 0x18 // int32_t (Size: 0x4)
DebuffInfoStruct.DebuffType = 0x1c // int32_t (Size: 0x4)
DebuffInfoStruct.GrantedFlag = 0x20 // int32_t (Size: 0x4)
DebuffInfoStruct.EffectDuration = 0x24 // float (Size: 0x4)
DebugBoxBodyInfo.Center = 0x0 // FVector (Size: 0xc)
DebugBoxBodyInfo.Rotation = 0x10 // FQuat (Size: 0x10)
DebugBoxBodyInfo.BoxExtent = 0x20 // FVector (Size: 0xc)
DebugCapsuleBodyInfo.Center = 0x0 // FVector (Size: 0xc)
DebugCapsuleBodyInfo.Rotation = 0x10 // FQuat (Size: 0x10)
DebugCapsuleBodyInfo.Radius = 0x20 // float (Size: 0x4)
DebugCapsuleBodyInfo.HalfHeight = 0x24 // float (Size: 0x4)
DebugInfoForMapRadar.ExtraInfo = 0x0 // FString (Size: 0x10)
DebugInfoForMapRadar.AIList = 0x10 // TArray<FSpawnedAIInfoForDebug> (Size: 0x10)
DebugPhysicsBodyInfos.bEnable = 0x0 // bool (Size: 0x1)
DebugPhysicsBodyInfos.BoxBodies = 0x8 // TArray<FDebugBoxBodyInfo> (Size: 0x10)
DebugPhysicsBodyInfos.CapsuleBodies = 0x18 // TArray<FDebugCapsuleBodyInfo> (Size: 0x10)
DebugPhysicsBodyInfos.ServerLocation = 0x28 // FVector (Size: 0xc)
DebugPhysicsBodyInfos.ServerRotation = 0x34 // FRotator (Size: 0xc)
DecalImpactEffectResource.DecalMaterial = 0x0 // MaterialInterface* (Size: 0x8)
DecalImpactEffectResource.RandomFrameIndex = 0x8 // FInt32Range (Size: 0x10)
DecalImpactEffectResource.RandomSize = 0x18 // FFloatRange (Size: 0x10)
DecalImpactEffectResource.RandomRotation = 0x28 // FFloatRange (Size: 0x10)
DecalImpactEffectResource.RandomAlpha = 0x38 // FFloatRange (Size: 0x10)
DecalImpactEffectResource.DecalRandomTextureParamName = 0x48 // FName (Size: 0x8)
DecalImpactEffectResource.DecalRandomRotationParamName = 0x50 // FName (Size: 0x8)
DecalImpactEffectResource.DecalRandomAlphaParamName = 0x58 // FName (Size: 0x8)
DeferDestroyActorInFrameInfo.SpawningActor = 0x0 // Actor* (Size: 0x8)
DeferDestroyCharacterInFrameInfo.SpawningCharacter = 0x0 // Actor* (Size: 0x8)
DeferDestroyCharacterInFrameInfo.DeathLocation = 0x8 // FVector (Size: 0xc)
DeferUnreplicateActorInFrameInfo.UnreplicateActor = 0x0 // Actor* (Size: 0x8)
DeferredExecCmd.ExecWorld = 0x0 // World* (Size: 0x8)
DeliverCargosAnimConfTableRow.DeliverCargosAnimInfo = 0x8 // FDeliverCargosRelevantAnimInfo (Size: 0xd8)
DeliverCargosAnimInfo.CharacterMontage = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
DeliverCargosAnimInfo.InventoryMontage = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
DeliverCargosAnimInfo.InventoryMesh = 0x50 // TSoftObjectPtr<UObject> (Size: 0x28)
DeliverCargosAnimInfo.AnimInstanceClass = 0x78 // TSoftClassPtr<UObject> (Size: 0x28)
DeliverCargosAnimInfo.InventoryAttachSocket = 0xa0 // FName (Size: 0x8)
DeliverCargosAnimInfo.InPlayRate = 0xa8 // float (Size: 0x4)
DeliverCargosAnimInfo.StartSectionName = 0xac // FName (Size: 0x8)
DeliverCargosAnimInfo.StartTimeSeconds = 0xb4 // float (Size: 0x4)
DeliverCargosAnimInfo.BlendInTime = 0xb8 // float (Size: 0x4)
DeliverCargosAnimInfo.BlendOutTime = 0xbc // float (Size: 0x4)
DeliverCargosAnimInfo.bEnableAutoBlendOut = 0xc0 // bool (Size: 0x1)
DeliverCargosAnimInfo.bStopAllMontages = 0xc1 // bool (Size: 0x1)
DeliverCargosRelevantAnimInfo.RelevantIDArr = 0x0 // TArray<int32_t> (Size: 0x10)
DeliverCargosRelevantAnimInfo.AnimInfo = 0x10 // FDeliverCargosAnimInfo (Size: 0xc8)
DistortRandomConfig.NumMin = 0x0 // int32_t (Size: 0x4)
DistortRandomConfig.NumMax = 0x4 // int32_t (Size: 0x4)
DistortRandomConfig.DurationMin = 0x8 // int32_t (Size: 0x4)
DistortRandomConfig.DurationMax = 0xc // int32_t (Size: 0x4)
DistortRandomConfig.PosX_Min = 0x10 // float (Size: 0x4)
DistortRandomConfig.PosX_Max = 0x14 // float (Size: 0x4)
DistortRandomConfig.PosY_Min = 0x18 // float (Size: 0x4)
DistortRandomConfig.PosY_Max = 0x1c // float (Size: 0x4)
DogTagCreateInfo.PlayerName = 0x0 // FString (Size: 0x10)
DogTagCreateInfo.PlayerLevel = 0x10 // int32_t (Size: 0x4)
DogTagCreateInfo.DeathTime = 0x18 // uint64_t (Size: 0x8)
DogTagCreateInfo.KillerPlayerName = 0x20 // FString (Size: 0x10)
DogTagCreateInfo.KillerPlayerWeaponID = 0x30 // uint64_t (Size: 0x8)
DogTagCreateInfo.KillerCharacterType = 0x38 // EECharacterType (Size: 0x1)
DogTagCreateInfo.IsSameTeam = 0x39 // bool (Size: 0x1)
DogTagCreateInfo.MapName = 0x40 // FString (Size: 0x10)
DogTagCreateInfo.DeathReason = 0x50 // int32_t (Size: 0x4)
DogTagCreateInfo.PlayerRank = 0x54 // int32_t (Size: 0x4)
DogTagCreateInfo.GOpenID = 0x58 // uint32_t (Size: 0x4)
DogTagCreateInfo.GID = 0x60 // uint64_t (Size: 0x8)
DogTagCreateInfo.NationalFlagIso = 0x68 // int32_t (Size: 0x4)
DoorActionInfo.ActionActor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
DoorActionInfo.Action = 0x8 // EEDoorAction (Size: 0x1)
DoorDeferUpdateInfo.DoorWeakPtr = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
DoorDeferUpdateInfo.TwoWayDoorPlankRotator = 0x8 // FRotator (Size: 0xc)
DoorDeferUpdateInfo.DynamicLightingFactor = 0x14 // float (Size: 0x4)
DropTransformInfo.DropTransform = 0x0 // FTransform (Size: 0x30)
DropTransformInfo.bShouldDrop = 0x30 // bool (Size: 0x1)
DropTransformInfo.Count = 0x34 // int32_t (Size: 0x4)
DropTransformInfo.Momentum = 0x38 // FVector (Size: 0xc)
DropTransformInfo.bWithPhysics = 0x44 // bool (Size: 0x1)
DuplicatedInventoryMesh.DupInventoryMesh = 0x0 // PrimitiveComponent* (Size: 0x8)
EffectDistanceConfArray.MinDistance = 0x0 // float (Size: 0x4)
EffectDistanceConfArray.MaxDistance = 0x4 // float (Size: 0x4)
EffectDistanceConfArray.StunEffectIns = 0x8 // MaterialInstance* (Size: 0x8)
EffectDistanceConfArray.DurationTime = 0x10 // float (Size: 0x4)
EffectParticleInfo.PSTemplate = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
EffectParticleInfo.SocketName = 0x28 // FName (Size: 0x8)
EffectParticleInfo.PSRotation = 0x30 // FRotator (Size: 0xc)
EffectParticleInfo.PSScale = 0x3c // float (Size: 0x4)
EffectParticleInfo.PSScaleCurveByDistance = 0x40 // CurveFloat* (Size: 0x8)
EffectParticleInfo.PSLifeTime = 0x48 // float (Size: 0x4)
EjectionSystem.ShellCache = 0x0 // TArray<ClassProperty> (Size: 0x10)
EjectionSystem.EjectingShell = 0x10 // ClassProperty (Size: 0x8)
EliminateInventoryGridInfo.GID = 0x0 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.ItemId = 0x8 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.ItemNum = 0x10 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.GridInfo = 0x18 // FInventoryGridInfo (Size: 0x48)
EliminateInventoryGridInfo.EliminateGID = 0x60 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.EliminateItemID = 0x68 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.EliminateItemNum = 0x70 // uint64_t (Size: 0x8)
EliminateInventoryGridInfo.EliminateGridInfo = 0x78 // FInventoryGridInfo (Size: 0x48)
EndurancePartInfo.EndurancePart = 0x0 // EECharacterEnduranceType (Size: 0x1)
EndurancePartInfo.NowEndurance = 0x4 // float (Size: 0x4)
EndurancePartInfo.MaxEndurance = 0x8 // float (Size: 0x4)
EndurancePartInfo.EndurancePercent = 0xc // float (Size: 0x4)
EnterDBNOBackupData.KillDistance = 0x0 // float (Size: 0x4)
EnterDBNOBackupData.bHitArmor = 0x4 // bool (Size: 0x1)
EnterDBNOBackupData.bPenetrateArmor = 0x5 // bool (Size: 0x1)
EnterDBNOBackupData.EnduranceType = 0x6 // EECharacterEnduranceType (Size: 0x1)
EnterDBNOBackupData.KillerBulletPenetrateFactor = 0x8 // int32_t (Size: 0x4)
EnterDBNOBackupData.DeathType = 0xc // EECharacterDeathType (Size: 0x1)
EnvInfo.ActorsNearBy = 0x0 // TArray<Actor*> (Size: 0x10)
EnvInfo.DetectRadius = 0x10 // float (Size: 0x4)
EquipMeshMorphTargetOffsetUserData.MorphTargetOffset = 0x28 // TMap<...> (Size: 0x50)
EquipmentItemInfo.ActorClass = 0x10 // ClassProperty (Size: 0x8)
EquipmentSkinInfo.SkinID = 0x0 // int32_t (Size: 0x4)
EquipmentSkinInfo.ItemId = 0x4 // int32_t (Size: 0x4)
EquipmentSkinInfo.bIsStaticMesh = 0x8 // bool (Size: 0x1)
EquipmentSkinInfo.bIsSwitchSexuality = 0x9 // bool (Size: 0x1)
EquipmentSkinInfo.MeshPath_Game = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
EquipmentSkinInfo.MeshPath_Lobby = 0x38 // TSoftObjectPtr<UObject> (Size: 0x28)
EquipmentSkinInfo.MeshPath_Game_Female = 0x60 // TSoftObjectPtr<UObject> (Size: 0x28)
EquipmentSkinInfo.MeshPath_Lobby_Female = 0x88 // TSoftObjectPtr<UObject> (Size: 0x28)
EquipmentSkinInfo.OverrideMaterials_Game = 0xb0 // TArray<FOverrideMaterialInfo> (Size: 0x10)
EquipmentSkinInfo.OverrideMaterials_Lobby = 0xc0 // TArray<FOverrideMaterialInfo> (Size: 0x10)
EscapeInfo.TeamID = 0x0 // int32_t (Size: 0x4)
EscapeInfo.EscapeVolumes = 0x8 // TArray<SGVolume*> (Size: 0x10)
EventAnnihilateKillInfo.SuitID = 0x0 // int32_t (Size: 0x4)
ExhibitionShowTime.StartTime = 0x0 // FDateTime (Size: 0x8)
ExhibitionShowTime.EndTime = 0x8 // FDateTime (Size: 0x8)
ExplosionInfoContainer.Items = 0x110 // TArray<FExplosionInfoItem> (Size: 0x10)
ExplosionInfoContainer.OwnerComponent = 0x120 // SGProjectileExplosionManager* (Size: 0x8)
ExplosionInfoItem.ItemId = 0xc // int32_t (Size: 0x4)
ExplosionInfoItem.ExplodeTrans = 0x10 // FTransform (Size: 0x30)
ExplosionInfoItem.ServerStartTime = 0x40 // float (Size: 0x4)
ExplosionInfoItem.LifeTime = 0x44 // float (Size: 0x4)
ExplosionInfoItem.bAirBlast = 0x48 // bool (Size: 0x1)
ExtraHitDeltaRotators.Rotators = 0x0 // TArray<FRotator> (Size: 0x10)
FHostedInteractAnimConfTableRow.ID = 0x8 // int32_t (Size: 0x4)
FHostedInteractAnimConfTableRow.Describe = 0x10 // FString (Size: 0x10)
FHostedInteractAnimConfTableRow.HostedInteractAnimInfo = 0x20 // FHostedInteractAnimInfo (Size: 0x58)
FHostedInteractAnimConfTableRow.Duration = 0x78 // float (Size: 0x4)
FHostedInteractAnimConfTableRow.HostedInteractRule = 0x7c // EEHostedInteractRule (Size: 0x1)
FHostedInteractAnimConfTableRow.MaxHostedInteractCount = 0x80 // int32_t (Size: 0x4)
FHostedInteractAnimConfTableRow.InteractIconResource = 0x88 // FSoftObjectPath (Size: 0x18)
FHostedInteractAnimConfTableRow.InteractingIconResource = 0xa0 // FSoftObjectPath (Size: 0x18)
FHostedInteractAnimConfTableRow.InteractDisplay = 0xb8 // FText (Size: 0x18)
FHostedInteractAnimConfTableRow.InteractingDisplay = 0xd0 // FText (Size: 0x18)
FHostedInteractAnimConfTableRow.CostInventoryInfos = 0xe8 // TArray<FInteractInventoryInfo> (Size: 0x10)
FHostedInteractAnimConfTableRow.CostInventoryDeficiencyTips = 0xf8 // FText (Size: 0x18)
FactionmemberBaseInfo.PlayerName = 0x0 // FString (Size: 0x10)
FactionmemberBaseInfo.GID = 0x10 // uint64_t (Size: 0x8)
FactionmemberBaseInfo.TeamIndex = 0x18 // uint64_t (Size: 0x8)
FactionmemberBaseInfo.CharacterType = 0x20 // EEFactionMemberType (Size: 0x1)
FactionmemberBaseInfo.Character = 0x28 // SGCharacter* (Size: 0x8)
FactionmemberBaseInfo.Condition = 0x30 // EESGPlayerCondition (Size: 0x1)
FactionmemberBaseInfo.TransientLocation = 0x34 // FVector (Size: 0xc)
FactionmemberBaseInfo.DeathTimeStamp = 0x40 // int64_t (Size: 0x8)
FightTaskConfRewardItemTableRow.main_mode_id = 0x8 // int32_t (Size: 0x4)
FightTaskConfRewardItemTableRow.sub_mode_id = 0xc // int32_t (Size: 0x4)
FightTaskConfRewardItemTableRow.map_id = 0x10 // int32_t (Size: 0x4)
FightTaskConfRewardItemTableRow.special_id = 0x14 // int32_t (Size: 0x4)
FightTaskConfRewardItemTableRow.Difficulty = 0x18 // int32_t (Size: 0x4)
FightTaskConfRewardItemTableRow.RewardItems = 0x20 // TArray<FRewardItemConfig> (Size: 0x10)
FillMagazineAnimSet.FillMagazineMontage = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
FillMagazineAnimSet.FillMagazineAnimInstance = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
FireIdInfo.FireIds = 0x0 // TArray<int64_t> (Size: 0x10)
FireIntervalPostfix.FireInterval = 0x0 // float (Size: 0x4)
FireIntervalPostfix.Postfix = 0x8 // FString (Size: 0x10)
FireRequireInfo.FireTag = 0x0 // FGameplayTag (Size: 0x8)
FireRequireInfo.TagInv = 0x8 // SGInventory* (Size: 0x8)
FixedSizeFloatCacheArray.Length = 0x0 // int32_t (Size: 0x4)
FixedSizeFloatCacheArray.Data = 0x8 // TArray<float> (Size: 0x10)
FlashData.EffectInfulenceFactor = 0x0 // float (Size: 0x4)
FlashData.FlashDurationTime = 0x4 // float (Size: 0x4)
FlashData.FadeOutTime = 0x8 // float (Size: 0x4)
FlashData.FlashLightCircleFadeoutTime = 0xc // float (Size: 0x4)
FlashData.DistortionFadeoutTime = 0x10 // float (Size: 0x4)
FlashData.FlashBangWorldLocation = 0x14 // FVector (Size: 0xc)
FlashData.ThrowSubType = 0x20 // EESGThrowSubType (Size: 0x1)
FlashData.TimeSeconds = 0x24 // float (Size: 0x4)
FlashDisConf.MinDistance = 0x0 // float (Size: 0x4)
FlashDisConf.MaxDistance = 0x4 // float (Size: 0x4)
FlashDisConf.DurationTime = 0x8 // float (Size: 0x4)
FlashDisConf.FadeOutTime = 0xc // float (Size: 0x4)
FlashDisConf.FlashLightCircleFadeoutTime = 0x10 // float (Size: 0x4)
FlashDisConf.DistortionFadeoutTime = 0x14 // float (Size: 0x4)
FlashDistanceCurveSet.MinDistance = 0x0 // float (Size: 0x4)
FlashDistanceCurveSet.MaxDistance = 0x4 // float (Size: 0x4)
FlashDistanceCurveSet.OpacityCurveSet = 0x8 // CurveFloat* (Size: 0x8)
FlashDistanceCurveSet.InnerFlareStrengthCurveSet = 0x10 // CurveFloat* (Size: 0x8)
FlashDistanceCurveSet.EdgeFlareStrengthCurveSet = 0x18 // CurveFloat* (Size: 0x8)
FlashDistanceCurveSet.FlashWhiteCurveSet = 0x20 // CurveFloat* (Size: 0x8)
FlashlightInfo_HD.LightComponent = 0x0 // LightComponent* (Size: 0x8)
FlashlightInfo_HD.LocationOffset = 0x8 // FVector (Size: 0xc)
FocusPartConfig.FocusRot = 0x0 // FRotator (Size: 0xc)
FocusPartConfig.TouchRotateSpeed = 0xc // float (Size: 0x4)
FocusPartConfig.MaxPitch = 0x10 // float (Size: 0x4)
FocusPartConfig.MaxYaw = 0x14 // float (Size: 0x4)
FocusPartConfig.MaxRoll = 0x18 // float (Size: 0x4)
FocusPartConfig.MinPitch = 0x1c // float (Size: 0x4)
FocusPartConfig.MinYaw = 0x20 // float (Size: 0x4)
FocusPartConfig.MinRoll = 0x24 // float (Size: 0x4)
FocusPartConfig.PinchSpeed = 0x28 // float (Size: 0x4)
FocusPartConfig.MinPinchDisPercent = 0x2c // float (Size: 0x4)
FocusPartConfig.MaxPinchDisPercent = 0x30 // float (Size: 0x4)
FollowCharacterWidgetInfo.WidgetIndex = 0x0 // int32_t (Size: 0x4)
FollowCharacterWidgetInfo.PlayerName = 0x8 // FString (Size: 0x10)
FollowCharacterWidgetInfo.MentorPupilType = 0x18 // int32_t (Size: 0x4)
FollowCharacterWidgetInfo.bIsTeammate = 0x1c // bool (Size: 0x1)
FootAudioSettings.FootstepInterval = 0x0 // float (Size: 0x4)
FootAudioSettings.FootstepAudioEvent = 0x8 // AkAudioEvent* (Size: 0x8)
FootAudioSettings.FoleyDelay = 0x10 // float (Size: 0x4)
FootAudioSettings.FoleyAudioEvent = 0x18 // AkAudioEvent* (Size: 0x8)
FootPrintBrightness.SurfaceType = 0x0 // uint8_t (Size: 0x1)
FootPrintBrightness.Brightness = 0x4 // float (Size: 0x4)
FootPrintBrightness.FootPrintType = 0x8 // EEFootPrintType (Size: 0x1)
FootPrintClusterInfo.GID = 0x0 // uint64_t (Size: 0x8)
FootPrintClusterInfo.bAlreadyHandled = 0x8 // uint8_t (Size: 0x1)
FootPrintClusterInfo.bValidPath = 0x8 // uint8_t (Size: 0x1)
FootPrintClusterInfo.OcclusionRate = 0xc // float (Size: 0x4)
FootPrintClusterInfo.LastOnRepTime = 0x10 // float (Size: 0x4)
FootPrintClusterInfo.FootPrintType = 0x14 // EEFootPrintType (Size: 0x1)
FootPrintClusterInfo.LastAddedTime = 0x18 // float (Size: 0x4)
FootPrintClusterInfo.Location = 0x1c // FVector_NetQuantize (Size: 0xc)
FootPrintClusterInfo.FootPrints = 0x28 // TArray<FFootPrintInfo> (Size: 0x10)
FootPrintClusterInfoArray.FootPrintClusterInfos = 0x0 // TArray<FFootPrintClusterInfo> (Size: 0x10)
FootPrintClusterInfoArray.FirstValidIndex = 0x10 // int32_t (Size: 0x4)
FootPrintClusterInfoArray.LastValidIndex = 0x14 // int32_t (Size: 0x4)
FootPrintClusterInfoArray.MaxClusterNum = 0x18 // int32_t (Size: 0x4)
FootStepMakerTriggerEventTlog.PosX = 0x0 // float (Size: 0x4)
FootStepMakerTriggerEventTlog.PosY = 0x4 // float (Size: 0x4)
FootStepMakerTriggerEventTlog.PosZ = 0x8 // float (Size: 0x4)
FootStepMakerTriggerEventTlog.GID = 0x10 // uint64_t (Size: 0x8)
FootStepMakerTriggerEventTlog.RoleType = 0x18 // uint32_t (Size: 0x4)
FootStepMakerTriggerEventTlog.VestLv = 0x1c // int32_t (Size: 0x4)
FootStepMakerTriggerEventTlog.HelmetLv = 0x20 // int32_t (Size: 0x4)
FootprintInstanceMap.FootPrintTypeTextureIndex = 0x0 // TMap<...> (Size: 0x50)
FootprintInstanceMap.FootPrintScaleMap = 0x50 // TMap<...> (Size: 0x50)
FootprintInstanceMap.ISM = 0xa0 // InstancedStaticMeshComponent* (Size: 0x8)
FootprintInstanceMap.MaxFootPrintNum = 0xa8 // int32_t (Size: 0x4)
FootprintInstanceMap.FadeOutTime = 0xac // float (Size: 0x4)
FootprintInstanceMap.FootPrintBrightnessSettings = 0xb0 // TArray<FFootPrintBrightness> (Size: 0x10)
FootprintInstanceMap.FootPrintBrightnessMap = 0xc0 // TMap<...> (Size: 0x50)
FootprintInstanceMap.Set = 0x110 // TSet<...> (Size: 0x50)
FootprintInstanceMap.Heap = 0x160 // TArray<FFootPrintInfo> (Size: 0x10)
FootprintInstanceMap.Map = 0x170 // TMap<...> (Size: 0x50)
FootprintInstanceMap.DecalMaterial = 0x1c0 // MaterialInterface* (Size: 0x8)
FootprintInstanceMap.DecalSize = 0x1c8 // FVector (Size: 0xc)
FootprintInstanceMap.FadeOutCurveLUT = 0x1d8 // TArray<float> (Size: 0x10)
FootprintInstanceMap.FirstVisibleInstanceIndex = 0x1e8 // int32_t (Size: 0x4)
FootprintInstanceMap.WeatherDefaultFootPrintType = 0x1ec // EEFootPrintType (Size: 0x1)
ForceModifier.AdsScale = 0x0 // FVector4 (Size: 0x10)
ForceModifier.NonAdsScale = 0x10 // FVector4 (Size: 0x10)
ForceModifier.bAdsScale = 0x20 // bool (Size: 0x1)
ForceModifier.StandPoseScale = 0x30 // FVector4 (Size: 0x10)
ForceModifier.CrouchPoseScale = 0x40 // FVector4 (Size: 0x10)
ForceModifier.PronePoseScale = 0x50 // FVector4 (Size: 0x10)
ForceModifier.bPoseScale = 0x60 // bool (Size: 0x1)
ForceModifier.SilentWalkScale = 0x70 // FVector4 (Size: 0x10)
ForceModifier.RunScale = 0x80 // FVector4 (Size: 0x10)
ForceModifier.SprintScale = 0x90 // FVector4 (Size: 0x10)
ForceModifier.bMovementScale = 0xa0 // bool (Size: 0x1)
ForceProgressInfo.ServerStartTimeStamp = 0x0 // FDateTime (Size: 0x8)
ForceProgressInfo.InitProgress = 0x8 // float (Size: 0x4)
ForceProgressInfo.MaxProgress = 0xc // float (Size: 0x4)
ForceProgressInfo.ProgressTime = 0x10 // float (Size: 0x4)
ForceScoreInfo.ForceIndex = 0x0 // int32_t (Size: 0x4)
ForceScoreInfo.ForceName = 0x8 // FString (Size: 0x10)
ForceScoreInfo.FactionType = 0x18 // EEFactionType (Size: 0x1)
ForceScoreInfo.Score = 0x1c // int32_t (Size: 0x4)
ForceScoreInfo.ProgressInfo = 0x20 // FForceProgressInfo (Size: 0x18)
ForceScoreInfo.PlayerNum = 0x38 // int32_t (Size: 0x4)
ForceScoreInfo.AlivePlayerNum = 0x3c // int32_t (Size: 0x4)
ForceScoreInfo.DBNOPlayerNum = 0x40 // int32_t (Size: 0x4)
GMCommandMap.CommandMap = 0x0 // TMap<...> (Size: 0x50)
GMCommandMap.TooltipMap = 0x50 // TMap<...> (Size: 0x50)
GMCommandMap.OptionalParamsMap = 0xa0 // TMap<...> (Size: 0x50)
GMMC_AttributeQuery.QueryAttribute = 0x40 // FGameplayAttribute (Size: 0x38)
GMMC_EnduranceLossNonlethal.ModifyEnduranceType = 0x40 // EECharacterEnduranceType (Size: 0x1)
GMMC_EnergyAutoRecover.Recovercoefficient = 0x40 // float (Size: 0x4)
GMMC_EnergyAutoRecover.AimStandReduceCoefficient = 0x44 // float (Size: 0x4)
GMMC_EnergyAutoRecover.AimCrouchReduceCoefficient = 0x48 // float (Size: 0x4)
GMMC_EnergyAutoRecover.AimProneReduceCoefficient = 0x4c // float (Size: 0x4)
GMMC_EnergyAutoRecover.HoldingBreathCoefficient = 0x50 // float (Size: 0x4)
GMMC_HearingAutoRecover.Recovercoefficient = 0x40 // float (Size: 0x4)
GMMC_LowEnergyAutoRecover.Recovercoefficient = 0x40 // float (Size: 0x4)
GMMC_LowEnergyAutoRecover.AimStandRecoverCoefficient = 0x44 // float (Size: 0x4)
GMMC_LowEnergyAutoRecover.AimCrouchRecoverCoefficient = 0x48 // float (Size: 0x4)
GMMC_LowEnergyAutoRecover.AimProneRecoverCoefficient = 0x4c // float (Size: 0x4)
GMMC_LowEnergyAutoRecover.ReduceSprintCoefficient = 0x50 // float (Size: 0x4)
GMMC_SignalValueChange.SignalAffectAttribute = 0x40 // EESignalAffectAttribute (Size: 0x1)
GMMC_SignalValueChange.bAffectDBNOHealthWhenBeRescuingByTeammate = 0x41 // bool (Size: 0x1)
GameEffectExecutor.Handle = 0x0 // FActiveGameplayEffectHandle (Size: 0x8)
GameEffectExecutor.bAdd = 0x8 // bool (Size: 0x1)
GameEffectExecutor.ActiveEffect = 0x10 // FActiveGameplayEffect (Size: 0x368)
GameUserDefaultSettings.Name = 0x8 // FName (Size: 0x8)
GameUserDefaultSettings.Type = 0x10 // EESettingValueType (Size: 0x1)
GameUserDefaultSettings.Value = 0x18 // FString (Size: 0x10)
GameplayAbilityRepAdvancedAnimMontage.bHasPlay = 0x0 // bool (Size: 0x1)
GameplayAbilityRepAdvancedAnimMontage.CharacterMontage = 0x8 // AnimMontage* (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.MeshComponent = 0x10 // SkeletalMeshComponentBudgeted* (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.InventoryMesh = 0x18 // SkeletalMesh* (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.InventoryMontage = 0x20 // AnimMontage* (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.InventoryAnimInstanceClass = 0x28 // ClassProperty (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.InventoryAttachSocket = 0x30 // FName (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.Timestamp = 0x38 // float (Size: 0x4)
GameplayAbilityRepAdvancedAnimMontage.StopMontagesByGroupName = 0x3c // FName (Size: 0x8)
GameplayAbilityRepAdvancedAnimMontage.StopMontagesBlendOutTime = 0x44 // float (Size: 0x4)
GameplayAbilityRepAdvancedAnimMontage.b3PShouldKeepLastFrame = 0x48 // bool (Size: 0x1)
GameplayAbilityRepAdvancedAnimMontage.SectionLoopCountKeys = 0x50 // TArray<FName> (Size: 0x10)
GameplayAbilityRepAdvancedAnimMontage.SectionLoopCountValues = 0x60 // TArray<int32_t> (Size: 0x10)
GameplayAbilityRepAdvancedAnimMontage.CanTriggerSoundWithGrass = 0x70 // bool (Size: 0x1)
GameplayAbilityRepEquipAnimMontage.bHasPlay = 0x0 // bool (Size: 0x1)
GameplayAbilityRepEquipAnimMontage.EquipInv = 0x8 // SGInventory* (Size: 0x8)
GameplayAbilityRepEquipAnimMontage.InventoryMontage = 0x10 // AnimMontage* (Size: 0x8)
GameplayAbilityRepEquipAnimMontage.CharacterMontage = 0x18 // AnimMontage* (Size: 0x8)
GameplayAbilityRepEquipAnimMontage.PlayRate = 0x20 // float (Size: 0x4)
GameplayAbilityRepEquipAnimMontage.StartSectionName = 0x24 // FName (Size: 0x8)
GameplayAbilityRepInteractMontage.bPlayBit = 0x0 // bool (Size: 0x1)
GameplayAbilityRepInteractMontage.CharacterMontageParams = 0x8 // FSGMontagePlayParams (Size: 0x48)
GameplayAbilityRepInteractMontage.InteractObjectMontageParams = 0x50 // FSGMontagePlayParams (Size: 0x48)
GameplayAbilityRepInteractMontage.InteractObjectMeshComponent = 0x98 // SkeletalMeshComponent* (Size: 0x8)
GameplayAbilityRepInteractMontage.PlayConfig = 0xa0 // FSGMontagePlayConfig (Size: 0x18)
GameplayAbilityRepInteractMontage.Timestamp = 0xb8 // float (Size: 0x4)
GameplayAbilityRepInventoryMontage.bPlayBit = 0x0 // bool (Size: 0x1)
GameplayAbilityRepInventoryMontage.bStopped = 0x1 // bool (Size: 0x1)
GameplayAbilityRepInventoryMontage.CharacterMontageParams = 0x8 // FSGMontagePlayParams (Size: 0x48)
GameplayAbilityRepInventoryMontage.InventoryMontageParams = 0x50 // FSGMontagePlayParams (Size: 0x48)
GameplayAbilityRepInventoryMontage.InventoryMesh = 0x98 // SkeletalMesh* (Size: 0x8)
GameplayAbilityRepInventoryMontage.InventoryStaticMesh = 0xa0 // StaticMesh* (Size: 0x8)
GameplayAbilityRepInventoryMontage.InventoryAnimInstanceClass = 0xa8 // ClassProperty (Size: 0x8)
GameplayAbilityRepInventoryMontage.InventoryAttachSocket = 0xb0 // FName (Size: 0x8)
GameplayAbilityRepInventoryMontage.SectionLoopCountKeys = 0xb8 // TArray<FName> (Size: 0x10)
GameplayAbilityRepInventoryMontage.SectionLoopCountValues = 0xc8 // TArray<int32_t> (Size: 0x10)
GameplayAbilityRepInventoryMontage.DataHandle = 0xd8 // FSGAnimTargetDataHandle (Size: 0x10)
GameplayAbilityRepInventoryMontage.PlayConfig = 0xe8 // FSGMontagePlayConfig (Size: 0x18)
GameplayAbilityRepInventoryMontage.Timestamp = 0x100 // float (Size: 0x4)
GameplayAbilityRepInventoryMontage.bJumpSection = 0x104 // bool (Size: 0x1)
GameplayAbilityRepInventoryMontage.Dependencies = 0x108 // TArray<FRepDependency> (Size: 0x10)
GameplayAbilityRepStopAdvancedAnimMontage.Timestamp = 0x0 // float (Size: 0x4)
GameplayAbilityRepStopAdvancedAnimMontage.StopMontagesByGroupName = 0x4 // FName (Size: 0x8)
GameplayAbilityRepStopAdvancedAnimMontage.StopMontagesBlendOutTime = 0xc // float (Size: 0x4)
GameplayAbility_Duration.GameplayEffectClasses = 0x560 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Duration.AppliedEffectHandles = 0x570 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
GameplayAbility_Duration.GameplayEffectClassesWhileEnded = 0x580 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Duration.Duration = 0x590 // float (Size: 0x4)
GameplayAbility_Duration.icon = 0x598 // Object* (Size: 0x8)
GameplayAbility_Duration.bShowProgressUIButton = 0x5a0 // bool (Size: 0x1)
GameplayAbility_Duration.bScaleIconToFit = 0x5a1 // bool (Size: 0x1)
GameplayAbility_Instant.ActivateGameplayEffectClasses = 0x3d0 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Instant.EndGameplayEffectClasses = 0x3e0 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Persistent.CauserGID = 0x3d0 // int32_t (Size: 0x4)
GameplayAbility_Persistent.CauserTeamId = 0x3d4 // int32_t (Size: 0x4)
GameplayAbility_Persistent.CauserTeamType = 0x3d8 // uint8_t (Size: 0x1)
GameplayAbility_Persistent.CauserWeaponId = 0x3e0 // int64_t (Size: 0x8)
GameplayAbility_Persistent.CauserBulletId = 0x3e8 // int64_t (Size: 0x8)
GameplayAbility_Persistent.Distance = 0x3f0 // float (Size: 0x4)
GameplayAbility_Persistent.CauserName = 0x3f8 // FString (Size: 0x10)
GameplayAbility_Persistent.GameplayEffectClasses = 0x408 // TArray<ClassProperty> (Size: 0x10)
GameplayAbility_Persistent.GameplayEffectHandles = 0x418 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
GameplayEffectArrayWrap.GameplayEffectList = 0x0 // TArray<ClassProperty> (Size: 0x10)
GameplayEffectHandleArrayWrap.GameplayEffectHandleList = 0x0 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
GashaponSpawnInfo.SpawnItemList = 0x0 // TArray<FGashaponSpawnItemInfo> (Size: 0x10)
GashaponSpawnInfo.Weight = 0x10 // int32_t (Size: 0x4)
GashaponSpawnItemInfo.SpawnItemID = 0x0 // int32_t (Size: 0x4)
GashaponSpawnItemInfo.SpawnCount = 0x4 // int32_t (Size: 0x4)
GashaponSpawnPoint.SpawnLocation = 0x0 // FVector (Size: 0xc)
GashaponSpawnPoint.SpawnRotation = 0xc // FRotator (Size: 0xc)
GestureAnim.bOneHand = 0x0 // bool (Size: 0x1)
GestureAnim.bFullBody = 0x1 // bool (Size: 0x1)
GestureAnim.GestureType = 0x2 // EEGestureType (Size: 0x1)
GestureAnim.GestureRifle = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
GestureAnim.GesturePistol = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
GestureAnim.GestureEmptyHand = 0x58 // TSoftObjectPtr<UObject> (Size: 0x28)
GestureAnim.GestureTwoHandsMelee = 0x80 // TSoftObjectPtr<UObject> (Size: 0x28)
GlobalEventMessage_AIActived.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_AIEscaped.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_AIEscaped.EscapeVolume = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_ActorBeBroken.Instigator = 0x0 // Controller* (Size: 0x8)
GlobalEventMessage_ActorBeBroken.BrokenActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_AssistKill.AssistKiller = 0x0 // PlayerState* (Size: 0x8)
GlobalEventMessage_AssistKill.Killer = 0x8 // Controller* (Size: 0x8)
GlobalEventMessage_AssistKill.KilledPlayer = 0x10 // Controller* (Size: 0x8)
GlobalEventMessage_AssistKill.KillerWeapon = 0x18 // Actor* (Size: 0x8)
GlobalEventMessage_AssistKill.KillDistance = 0x20 // float (Size: 0x4)
GlobalEventMessage_AssistKill.EnduranceType = 0x24 // EECharacterEnduranceType (Size: 0x1)
GlobalEventMessage_AssistKill.DamageInfo = 0x28 // DamageEventObject* (Size: 0x8)
GlobalEventMessage_AttachPositionChanged.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_AttachPositionChanged.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_AttractAI.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_AttractAI.Trigger = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_AttractAI.AttractAI = 0x10 // Character* (Size: 0x8)
GlobalEventMessage_BagStateChange.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_BagStateChange.bool = 0x8 // bool (Size: 0x1)
GlobalEventMessage_BagStateChange.BagType = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_BagStateChange.Container = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_BagTabClick.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_BagTabClick.BagTabType = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_BigMapDetailBoardShow.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_BigMapDetailBoardShow.DetailBoardType = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_BigMapDetailBoardShow.ItemId = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_BigMapDetailBoardShow.TaskId = 0x10 // int32_t (Size: 0x4)
GlobalEventMessage_BigMapDetailBoardShow.bool = 0x14 // bool (Size: 0x1)
GlobalEventMessage_CapturePointReportPlayer.CapturePointVolume = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_CapturePointReportPlayer.Character = 0x8 // SGCharacter* (Size: 0x8)
GlobalEventMessage_CapturePointReportPlayer.IntervalTime = 0x10 // float (Size: 0x4)
GlobalEventMessage_CapturePointVolumeBelongChange.CapturePointVolume = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_CapturePointVolumeBelongChange.NewFactionType = 0x8 // EEFactionType (Size: 0x1)
GlobalEventMessage_CapturePointVolumeBelongChange.OldFactionType = 0x9 // EEFactionType (Size: 0x1)
GlobalEventMessage_CharacterCostBullet.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_CharacterCostBullet.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_CharacterCostBullet.FromPlayerInfos = 0x20 // TArray<FStackableItemSourceInfo> (Size: 0x10)
GlobalEventMessage_CharacterDestroyActor.Character = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_CharacterDestroyActor.Target = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_ClickItem.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_ClickItem.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_ContainerInteractChanged.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_ContainerInteractChanged.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_ContainerInteractChanged.bInteract = 0x10 // bool (Size: 0x1)
GlobalEventMessage_EnduranceChanged.Instigator = 0x0 // SGCharacter* (Size: 0x8)
GlobalEventMessage_EnduranceChanged.EnduranceChange = 0x8 // float (Size: 0x4)
GlobalEventMessage_EnduranceChanged.NewEndurance = 0xc // float (Size: 0x4)
GlobalEventMessage_EnduranceChanged.EnduranceType = 0x10 // EECharacterEnduranceType (Size: 0x1)
GlobalEventMessage_FSMStateChange.Instigator = 0x0 // SGGameState* (Size: 0x8)
GlobalEventMessage_FSMStateChange.Target = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_FSMStateChange.NewFlowState = 0x10 // FString (Size: 0x10)
GlobalEventMessage_FSMStateChange.OldFlowState = 0x20 // FString (Size: 0x10)
GlobalEventMessage_FactionLevelUpdate.Instigator = 0x0 // SGFaction* (Size: 0x8)
GlobalEventMessage_FactionLevelUpdate.FactionType = 0x8 // EEFactionType (Size: 0x1)
GlobalEventMessage_FactionLevelUpdate.IntLevel = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_FactionScoreUpdate.Instigator = 0x0 // SGFaction* (Size: 0x8)
GlobalEventMessage_FactionScoreUpdate.FactionType = 0x8 // EEFactionType (Size: 0x1)
GlobalEventMessage_FactionScoreUpdate.IntCount = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_FinishRescueTeammate.Rescuer = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_FinishRescueTeammate.Weaker = 0x8 // Character* (Size: 0x8)
GlobalEventMessage_FlowStateChange.Instigator = 0x0 // PlayerController* (Size: 0x8)
GlobalEventMessage_FlowStateChange.NewFlowState = 0x8 // FName (Size: 0x8)
GlobalEventMessage_FlowStateChange.OldFlowState = 0x10 // FName (Size: 0x8)
GlobalEventMessage_GameBegin.EventTag = 0x0 // FMFGlobalEventTag (Size: 0x8)
GlobalEventMessage_GameBegin.Instigator = 0x8 // GameState* (Size: 0x8)
GlobalEventMessage_GameplayEffectApplied.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_GameplayEffectApplied.EnduranceType = 0x8 // EECharacterEnduranceType (Size: 0x1)
GlobalEventMessage_GameplayEffectApplied.GameEffectType = 0x9 // EECharacterGameEffectType (Size: 0x1)
GlobalEventMessage_HitTarget.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_HitTarget.DamageTakePlayer = 0x8 // Character* (Size: 0x8)
GlobalEventMessage_HitTarget.AttemptedDamage = 0x10 // float (Size: 0x4)
GlobalEventMessage_HitTarget.ActuralDamage = 0x14 // float (Size: 0x4)
GlobalEventMessage_HitTarget.DamageCauser = 0x18 // Actor* (Size: 0x8)
GlobalEventMessage_HitTarget.ArmorType = 0x20 // EESGArmorType (Size: 0x1)
GlobalEventMessage_HitTarget.EnduranceType = 0x21 // EECharacterEnduranceType (Size: 0x1)
GlobalEventMessage_HitTarget.DamageInfo = 0x28 // DamageEventObject* (Size: 0x8)
GlobalEventMessage_InspectItemClick.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_Instigator.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_Interact.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_Interact.InteractActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_Interact.InteractEventType = 0x10 // EEInteractEventType (Size: 0x1)
GlobalEventMessage_InteractActor.InteractCharacter = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_InteractActor.InteractActorConfigID = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_InteractActor.InteractActorGID = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_InteractActor.InteractActor = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_InventoryAdded.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_InventoryAdded.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_InventoryAdded.StackableItemSourceInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_InventoryDestroyed.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_InventoryDestroyed.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_InventoryDestroyed.StackableItemSourceInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_InventoryDurabilityChange.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_InventoryDurabilityChange.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_InventoryDurabilityChange.StackableItemSourceInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_InventoryDurabilityChange.NewDurability = 0x28 // float (Size: 0x4)
GlobalEventMessage_InventoryDurabilityChange.OldDurability = 0x2c // float (Size: 0x4)
GlobalEventMessage_InventoryRemoved.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_InventoryRemoved.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_InventoryRemoved.StackableItemSourceInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_Killed.Instigator = 0x0 // Controller* (Size: 0x8)
GlobalEventMessage_Killed.KilledPlayer = 0x8 // Controller* (Size: 0x8)
GlobalEventMessage_Killed.KillerWeapon = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_Killed.KillDistance = 0x18 // float (Size: 0x4)
GlobalEventMessage_Killed.EnduranceType = 0x1c // EECharacterEnduranceType (Size: 0x1)
GlobalEventMessage_Killed.DamageInfo = 0x20 // DamageEventObject* (Size: 0x8)
GlobalEventMessage_LimitAreaPlanDataInfo.PlanStatusType = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_LimitAreaPlanDataInfo.CurAreaPointWavePicking = 0x4 // int32_t (Size: 0x4)
GlobalEventMessage_LimitAreaPlanDataInfo.TargetAreaPointWavePicking = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_LimitAreaPlanDataInfo.CurAreaPointLocation = 0xc // FVector (Size: 0xc)
GlobalEventMessage_LimitAreaPlanDataInfo.TargetAreaPointLocation = 0x18 // FVector (Size: 0xc)
GlobalEventMessage_LocationReport.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_LocationReport.MoveDistance = 0x8 // float (Size: 0x4)
GlobalEventMessage_LootContainer.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_LootContainer.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_LootCorpseOrDeathBox.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_LootCorpseOrDeathBox.CorpseOrBox = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_MComHappenUpLoad.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_MComHappenUpLoad.InteractActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_MPCheatMessage.RoundTime = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_MapSign.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_MapSign.SignType = 0x8 // EEMapSignType (Size: 0x1)
GlobalEventMessage_MapSign.Sign_EscapePointPos = 0xc // FVector2D (Size: 0x8)
GlobalEventMessage_MapSign.Sign_EscapePointID = 0x14 // int32_t (Size: 0x4)
GlobalEventMessage_MapSign.TaskId = 0x18 // int32_t (Size: 0x4)
GlobalEventMessage_MapSign.Sign_PlayerPos = 0x1c // FVector2D (Size: 0x8)
GlobalEventMessage_MissionFlowFinished.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_MissionFlowFinished.MissionFlowName = 0x8 // FString (Size: 0x10)
GlobalEventMessage_MissionFlowFinished.FinishedSuccess = 0x18 // bool (Size: 0x1)
GlobalEventMessage_MissionFlowStatusChanged.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_MissionFlowStatusChanged.MissionFlowStatus = 0x8 // EEMissionStatus (Size: 0x1)
GlobalEventMessage_MissionFlowStatusChanged.MissionFlowName = 0x10 // FString (Size: 0x10)
GlobalEventMessage_ModifyInventoryTotalCount.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_ModifyInventoryTotalCount.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_ModifyInventoryTotalCount.IntCount = 0x10 // int32_t (Size: 0x4)
GlobalEventMessage_ModifyInventoryTotalCount.StackableItemSourceInfo = 0x18 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_MoveInventory.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_MoveInventory.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_MoveInventory.AttachPosition = 0x10 // EEAttachPosition (Size: 0x1)
GlobalEventMessage_MultiInventoryInteraction.InteractCharacter = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_MultiInventoryInteraction.InteractActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_MultiInventoryInteraction.SpawnInventoryList = 0x10 // TArray<SGInventory*> (Size: 0x10)
GlobalEventMessage_OnOneShotEnd.Character = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_OnOneShotEnd.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_OnOneShotEnd.StackableItemSourceInfo = 0x18 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_OnVehicleBeginPlay.Vehicle = 0x0 // Pawn* (Size: 0x8)
GlobalEventMessage_OnVehicleDestroyed.Vehicle = 0x0 // Pawn* (Size: 0x8)
GlobalEventMessage_OpenItemDetail.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_OpenItemDetail.bool = 0x8 // bool (Size: 0x1)
GlobalEventMessage_OpenItemDetail.ItemId = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_OpenPPT.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_OpenPPT.bool = 0x8 // bool (Size: 0x1)
GlobalEventMessage_OpenPPT.WidgetID = 0xc // int32_t (Size: 0x4)
GlobalEventMessage_Pair.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_Pair.Target = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_ParadropStateChange.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_ParadropStateChange.Target = 0x8 // SGParadropBase* (Size: 0x8)
GlobalEventMessage_ParadropStateChange.ParadropState = 0x10 // EESGParadropState (Size: 0x1)
GlobalEventMessage_PlayerBeginGame.Instigator = 0x0 // PlayerController* (Size: 0x8)
GlobalEventMessage_PrePlayerFinishGame.Instigator = 0x0 // PlayerController* (Size: 0x8)
GlobalEventMessage_PrePlayerFinishGame.EndGameType = 0x8 // EEPlayerEndGameType (Size: 0x1)
GlobalEventMessage_PrePlayerFinishGame.EscapeVolume = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_PushBullet.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_PushBullet.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_PushBullet.InventoryMag = 0x10 // SGInventory* (Size: 0x8)
GlobalEventMessage_PushBullet.IntCount = 0x18 // int32_t (Size: 0x4)
GlobalEventMessage_PushBullet.StackableItemSourceInfos = 0x20 // TArray<FStackableItemSourceInfo> (Size: 0x10)
GlobalEventMessage_ReadyToPlay.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_RecalTakeOutItemVale.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_RoundEndForPlay.CurrRound = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_RoundGamePrepare.CurrRound = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_SceneEventCompleted.Instigator = 0x0 // SGGameState* (Size: 0x8)
GlobalEventMessage_SceneEventCompleted.AISceneEvent = 0x8 // AISceneEventMessage* (Size: 0x8)
GlobalEventMessage_SceneEventCompleted.Character = 0x10 // Character* (Size: 0x8)
GlobalEventMessage_SceneEventExpired.Instigator = 0x0 // SGGameState* (Size: 0x8)
GlobalEventMessage_SceneEventExpired.AISceneEvent = 0x8 // AISceneEventMessage* (Size: 0x8)
GlobalEventMessage_SceneEventRemoved.Instigator = 0x0 // SGGameState* (Size: 0x8)
GlobalEventMessage_SceneEventRemoved.AISceneEvent = 0x8 // AISceneEventMessage* (Size: 0x8)
GlobalEventMessage_SceneEventTrigger.Instigator = 0x0 // SGGameState* (Size: 0x8)
GlobalEventMessage_SceneEventTrigger.AISceneEvent = 0x8 // AISceneEventMessage* (Size: 0x8)
GlobalEventMessage_StartChase.PlayerState = 0x0 // PlayerState* (Size: 0x8)
GlobalEventMessage_StartInvDetecting.Character = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_StartInvDetecting.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_StartLoot.Character = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_StartLoot.Container = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_StartSearchingContainer.SearchingPlayer = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_StartSearchingContainer.Container = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_StatisDataChange.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_StatisDataChange.Int64Count = 0x8 // int64_t (Size: 0x8)
GlobalEventMessage_StatisDataChange.IntOldCount = 0x10 // int32_t (Size: 0x4)
GlobalEventMessage_StatisDataChange.IntNewCount = 0x14 // int32_t (Size: 0x4)
GlobalEventMessage_SwitchWeaponCompleted.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_SwitchWeaponCompleted.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_TDMExtraRound.CurrRound = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_TakeFlashed.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_TakeFlashed.DamageTakePlayer = 0x8 // Character* (Size: 0x8)
GlobalEventMessage_TakeFlashed.DamageCauser = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_TakeFlashed.ThrowType = 0x18 // EESGThrowSubType (Size: 0x1)
GlobalEventMessage_TakeInItem.Instigator = 0x0 // PlayerController* (Size: 0x8)
GlobalEventMessage_TakeInItem.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_TakeInItemEscapeMap.Instigator = 0x0 // PlayerController* (Size: 0x8)
GlobalEventMessage_TakeInItemEscapeMap.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_TakeInItemEscapeMap.EndGameType = 0x10 // EEPlayerEndGameType (Size: 0x1)
GlobalEventMessage_Target.Target = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_ThrowableProjectileSpawn.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_ThrowableProjectileSpawn.ThrowableProjectile = 0x8 // SGThrowableProjectile* (Size: 0x8)
GlobalEventMessage_ThrowableProjectileSpawn.Inventory = 0x10 // SGInventory* (Size: 0x8)
GlobalEventMessage_UnfillContainer.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_UnfillContainer.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_UnfillContainer.InventoryMag = 0x10 // SGInventory* (Size: 0x8)
GlobalEventMessage_UnfillContainer.IntCount = 0x18 // int32_t (Size: 0x4)
GlobalEventMessage_UnfillContainer.StackableItemSourceInfos = 0x20 // TArray<FStackableItemSourceInfo> (Size: 0x10)
GlobalEventMessage_UseInventory.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_UseInventory.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_UseRecoveryInventory.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_UseRecoveryInventory.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_UseRecoveryInventory.UseInventoryPhase = 0x10 // EEUseInventoryPhase (Size: 0x1)
GlobalEventMessage_ValidCharacterNumberInfo.IntOldCount = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_ValidCharacterNumberInfo.IntNewCount = 0x4 // int32_t (Size: 0x4)
GlobalEventMessage_ValidTeamNumberInfo.IntOldCount = 0x0 // int32_t (Size: 0x4)
GlobalEventMessage_ValidTeamNumberInfo.IntNewCount = 0x4 // int32_t (Size: 0x4)
GlobalEventMessage_VolumeActorChanged.EventTag = 0x0 // FMFGlobalEventTag (Size: 0x8)
GlobalEventMessage_VolumeActorChanged.VolumeID = 0x8 // int64_t (Size: 0x8)
GlobalEventMessage_VolumeBeginOverlap.VolumeID = 0x0 // int64_t (Size: 0x8)
GlobalEventMessage_VolumeBeginOverlap.InteractActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_WeaponAssemble.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_WeaponAssemble.Weapon = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_WeaponAssemble.ChildInventory = 0x10 // SGInventory* (Size: 0x8)
GlobalEventMessage_WeaponCheck.Instigator = 0x0 // Character* (Size: 0x8)
GoldInventorySpawnConfig.InventoryClass = 0x0 // ClassProperty (Size: 0x8)
GoldInventorySpawnConfig.Weight = 0x8 // float (Size: 0x4)
GoldInventoryStateInfo.State = 0x0 // EESGGoldInventoryState (Size: 0x1)
GoldInventoryStateInfo.StateBeginTime = 0x4 // float (Size: 0x4)
GrenadeBlurData.DurationGrenade = 0x0 // float (Size: 0x4)
GrenadeBlurData.GrenadeExplosionThreshold = 0x4 // float (Size: 0x4)
GrenadeBlurData.BlurStrengthGrenadeCurve = 0x8 // CurveFloat* (Size: 0x8)
GrenadeBlurData.GrenadeDistanceCurve = 0x10 // CurveFloat* (Size: 0x8)
GridPreOccupiedInfo.OccupyKeyInventory = 0x0 // Actor* (Size: 0x8)
GridPreOccupiedInfo.GridOccupyInfo = 0x8 // FSGGridOccupyInfo (Size: 0x18)
GunSilencerInfluenceParams.SilencerType = 0x0 // EESGGunSilencerType (Size: 0x1)
GunSilencerInfluenceParams.InfluenceFactor = 0x4 // FSoundInfluenceFactor (Size: 0x8)
GunSilencerInfluenceParamsArray.GunSilencerInfluenceArray = 0x0 // TArray<FGunSilencerInfluenceParams> (Size: 0x10)
GuranteedItemLimitInfo.GuranteedTotalNum = 0x0 // uint32_t (Size: 0x4)
GuranteedItemLimitInfo.CurGuranteedProgress = 0x4 // int32_t (Size: 0x4)
GuranteedItemLimitInfo.CurGuranteedStage = 0x8 // int32_t (Size: 0x4)
HUDReportTableRow.HUDReportID = 0x8 // int32_t (Size: 0x4)
HUDReportTableRow.AnnounceRange = 0xc // EEAnnounceRangeType (Size: 0x1)
HUDReportTableRow.TitleText = 0x10 // FText (Size: 0x18)
HUDReportTableRow.ContentText = 0x28 // FText (Size: 0x18)
HUDReportTableRow.CanvasPanelName = 0x40 // FName (Size: 0x8)
HUDShakeConfig.HUDShakeDamping = 0x30 // float (Size: 0x4)
HUDShakeConfig.MaxOffset = 0x34 // FVector (Size: 0xc)
HUDShakeConfig.HeavyWalkShakeScale = 0x40 // FVector2D (Size: 0x8)
HUDShakeConfig.HeavyCrouchShakeScale = 0x48 // FVector2D (Size: 0x8)
HUDShakeConfig.HeavyCrouchTime = 0x50 // float (Size: 0x4)
HUDShakeConfig.HeavyCrouchDownProportion = 0x54 // float (Size: 0x4)
HUDShakeConfig.HeavyProneShakeScale = 0x58 // FVector2D (Size: 0x8)
HUDShakeConfig.HeavyProneTime = 0x60 // float (Size: 0x4)
HUDShakeConfig.HeavyProneDownProportion = 0x64 // float (Size: 0x4)
HUDShakeConfig.HeavyStandUpShakeScale = 0x68 // FVector2D (Size: 0x8)
HUDShakeConfig.HeavyStandUpTime = 0x70 // float (Size: 0x4)
HUDShakeConfig.RunShakeScale = 0x74 // FVector2D (Size: 0x8)
HUDShakeConfig.RunShakeFadeInTime = 0x7c // float (Size: 0x4)
HUDShakeConfig.RunRollOffset = 0x80 // float (Size: 0x4)
HUDShakeConfig.JumpShakeScale = 0x84 // FVector2D (Size: 0x8)
HUDShakeConfig.JumpTime = 0x8c // float (Size: 0x4)
HUDShakeConfig.LandedTime = 0x90 // float (Size: 0x4)
HUDShakeConfig.LeanShakeScale = 0x94 // FVector2D (Size: 0x8)
HUDShakeConfig.RotateViewShakeScale = 0x9c // FVector2D (Size: 0x8)
HUDShakeConfig.RotateViewShakeDamping = 0xa4 // float (Size: 0x4)
HUDShakeConfig.DartleFireScale = 0xa8 // FVector2D (Size: 0x8)
HUDShakeConfig.SingleFireShakeScale = 0xb0 // FVector2D (Size: 0x8)
HUDShakeConfig.RecoilShakeScales = 0xb8 // TMap<...> (Size: 0x50)
HUDShakeConfig.MeleeShakeScale = 0x108 // FVector2D (Size: 0x8)
HUDShakeConfig.MeleeShakeDamping = 0x110 // float (Size: 0x4)
HUDShakeConfig.UseItemShakeScale = 0x114 // FVector2D (Size: 0x8)
HUDShakeConfig.CheckMagazineShakeScale = 0x11c // FVector2D (Size: 0x8)
HUDShakeConfig.CheckMagazineShakeDamping = 0x124 // float (Size: 0x4)
HUDShakeConfig.AttachMagazineShakeScale = 0x128 // FVector2D (Size: 0x8)
HUDShakeConfig.AttachMagazineShakeDamping = 0x130 // float (Size: 0x4)
HUDShakeConfig.AttachMagazineTime = 0x134 // float (Size: 0x4)
HUDShakeConfig.ChangeClipShakeScale = 0x138 // FVector2D (Size: 0x8)
HUDShakeConfig.ChangeClipShakeDamping = 0x140 // float (Size: 0x4)
HUDShakeConfig.TakeDamageShakeScale = 0x144 // FVector (Size: 0xc)
HUDShakeConfig.TakeDamageTime = 0x150 // float (Size: 0x4)
HUDShakeConfig.ExplodeShakeScale = 0x154 // FVector2D (Size: 0x8)
HUDShakeConfig.ExplodeShakeSmallMultiplier = 0x15c // float (Size: 0x4)
HUDShakeConfig.ExplodeShakeDistanceMultiplier = 0x160 // float (Size: 0x4)
HUDShakeConfig.ExplodeShakeFurthestDistance = 0x164 // float (Size: 0x4)
HUDShakeConfig.ExplodeTime = 0x168 // float (Size: 0x4)
HUDShakeConfig.ExplodeCount = 0x16c // int32_t (Size: 0x4)
HUDShakeConfig.ExplodeViewAngle = 0x170 // float (Size: 0x4)
HUDShakeConfig.HeadTakeDamageShakeScale = 0x174 // float (Size: 0x4)
HUDShakeConfig.HeadTakeDamageShakeCount = 0x178 // int32_t (Size: 0x4)
HUDShakeConfig.HeadTakeDamageTime = 0x17c // float (Size: 0x4)
HeadSubGroupInfo.SocketName = 0x0 // FName (Size: 0x8)
HeadSubGroupInfo.HeadHitSubGroupType = 0x8 // EEHeadHitSubGroupType (Size: 0x1)
HeroAbilityConfig.HeroAbilityName = 0x0 // FString (Size: 0x10)
HeroAbilityConfig.AbilityModuleClassList = 0x10 // TArray<ClassProperty> (Size: 0x10)
HighOutputGameEndReportData.WeaponBoxIsOpened = 0x0 // bool (Size: 0x1)
HighOutputGameEndReportData.MovingTriggered = 0x1 // bool (Size: 0x1)
HighOutputGameEndReportData.StaticTriggered = 0x2 // bool (Size: 0x1)
HighOutputGameEndReportData.ScavOrderDelivered = 0x3 // bool (Size: 0x1)
HighOutputGameEndReportData.ScavOrderSigned = 0x4 // bool (Size: 0x1)
HighOutputGameEndReportData.PMCOrderDelivered = 0x5 // bool (Size: 0x1)
HighOutputGameEndReportData.PMCOrderSigned = 0x6 // bool (Size: 0x1)
HighOutputGameEndReportData.MediateOrderSigned = 0x7 // bool (Size: 0x1)
HighOutputGameEndReportData.CloseForNoWeapon = 0x8 // bool (Size: 0x1)
HighOutputGameEndReportData.CloseScavOrder = 0x9 // bool (Size: 0x1)
HighOutputGameEndReportData.CloseMovingTheater = 0xa // bool (Size: 0x1)
HighOutputGameEndReportData.ScavRefreshTimes = 0xc // int32_t (Size: 0x4)
HighOutputGameEndReportData.PMC_FeedActions = 0x10 // int32_t (Size: 0x4)
HighOutputGameEndReportData.MediateStopReason = 0x14 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.MediateTriggeredTime = 0x0 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.SinglePMCTriggeredTime = 0x4 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.SingleScavTriggeredTime = 0x8 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.GroupOneTriggered = 0xc // bool (Size: 0x1)
HighOutputMultiPlayerGameEndReportInfo.GroupTwoTriggered = 0xd // bool (Size: 0x1)
HighOutputMultiPlayerGameEndReportInfo.MediateSignedTime = 0x10 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.SinglePMCSignedTime = 0x14 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.SingleScavSignedTime = 0x18 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.GroupOneSigned = 0x1c // bool (Size: 0x1)
HighOutputMultiPlayerGameEndReportInfo.GroupTwoSigned = 0x1d // bool (Size: 0x1)
HighOutputMultiPlayerGameEndReportInfo.GroupGetLastHitNumber = 0x20 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.GroupFinalReceiveNumber = 0x24 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.SubsistanceTriggered = 0x28 // bool (Size: 0x1)
HighOutputMultiPlayerGameEndReportInfo.PlayerNumber = 0x2c // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.ScavRefreshTime = 0x30 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.PMC_FeedActions = 0x34 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.MediateStopReason = 0x38 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.EscapeBefore10Min = 0x3c // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.EscapeBefore20Min = 0x40 // int32_t (Size: 0x4)
HighOutputMultiPlayerGameEndReportInfo.Backup = 0x44 // int32_t (Size: 0x4)
HighOutput_PlayerInfo.TeamMate = 0x0 // TArray<Pawn*> (Size: 0x10)
HighOutput_PlayerInfo.DistanceToOthers = 0x10 // TArray<float> (Size: 0x10)
HighOutput_PlayerInfo.StartLoc = 0x20 // FVector (Size: 0xc)
HighOutput_PlayerInfo.HasWeapon = 0x2c // bool (Size: 0x1)
HighOutput_PlayerInfo.ScripState = 0x2d // EENPCCourierOrderState (Size: 0x1)
HighOutput_PlayerInfo.DistanceState = 0x30 // int32_t (Size: 0x4)
HighOutput_PlayerInfo.CourierMap = 0x38 // TMap<...> (Size: 0x50)
HighOutput_PlayerInfo.LootScore = 0x88 // float (Size: 0x4)
HighOutput_PlayerInfo.PathIDsIn5m = 0x90 // TArray<int32_t> (Size: 0x10)
HighOutput_PlayerInfo.PathIDsIn10m = 0xa0 // TArray<int32_t> (Size: 0x10)
HitBulletHolesInfo.TakerName = 0x0 // FString (Size: 0x10)
HitBulletHolesInfo.BulletID = 0x10 // int64_t (Size: 0x8)
HitBulletHolesInfo.bBodyHitThrough = 0x18 // int32_t (Size: 0x4)
HitBulletHolesInfo.ShootDistance = 0x1c // float (Size: 0x4)
HitBulletHolesInfo.WeaponId = 0x20 // int32_t (Size: 0x4)
HitPartInfo.HitMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
HitPartInfo.DamageScale = 0x8 // float (Size: 0x4)
HitPartInfo.HitGroup = 0xc // EEHitGroupType (Size: 0x1)
HitStatis.HitTime = 0x0 // float (Size: 0x4)
HitStatis.HitCount = 0x4 // int32_t (Size: 0x4)
HitStatis.IsAI = 0x8 // bool (Size: 0x1)
HitStatis.TakerId = 0x10 // uint64_t (Size: 0x8)
HostedInteractAnimInfo.ForwardDis = 0x0 // float (Size: 0x4)
HostedInteractAnimInfo.RightDis = 0x4 // float (Size: 0x4)
HostedInteractAnimInfo.DurationOnceTime = 0x8 // float (Size: 0x4)
HostedInteractAnimInfo.MoveToTargetOverTime = 0xc // float (Size: 0x4)
HostedInteractAnimInfo.RotationInterpSpeed = 0x10 // float (Size: 0x4)
HostedInteractAnimInfo.PlayRate = 0x14 // float (Size: 0x4)
HostedInteractAnimInfo.StartSectionName = 0x18 // FName (Size: 0x8)
HostedInteractAnimInfo.StartTimeSeconds = 0x20 // float (Size: 0x4)
HostedInteractAnimInfo.BlendInTime = 0x24 // float (Size: 0x4)
HostedInteractAnimInfo.BlendOutTime = 0x28 // float (Size: 0x4)
HostedInteractAnimInfo.bEnableAutoBlendOut = 0x2c // bool (Size: 0x1)
HostedInteractAnimInfo.bStopAllMontages = 0x2d // bool (Size: 0x1)
HostedInteractAnimInfo.StartMontage = 0x30 // AnimMontage* (Size: 0x8)
HostedInteractAnimInfo.LoopMontage = 0x38 // AnimMontage* (Size: 0x8)
HostedInteractAnimInfo.EndMontage = 0x40 // AnimMontage* (Size: 0x8)
HostedInteractAnimInfo.InventoryLoopMontage = 0x48 // AnimMontage* (Size: 0x8)
HostedInteractAnimInfo.InventoryAnimInstance = 0x50 // ClassProperty (Size: 0x8)
HostedInteractInfo.HostedInteracteRuleID = 0x0 // int64_t (Size: 0x8)
HostedInteractInfo.HostedInteractCount = 0x8 // int32_t (Size: 0x4)
HoverVehicleCheckLocationRepData.ActorLocation = 0x0 // FVector (Size: 0xc)
HoverVehicleCheckLocationRepData.ActorRotation = 0xc // FRotator (Size: 0xc)
HoverVehicleMovementComponentBase.ClosedRigidBodyState = 0x2e0 // FRigidBodyState (Size: 0x40)
HoverVehicleMovementComponentBase.ReplicatedInputData = 0x324 // FHoverVehicleMovementRepData (Size: 0xc)
HoverVehicleMovementComponentBase.ReplicatedServerLocationData = 0x330 // FHoverVehicleCheckLocationRepData (Size: 0x18)
HoverVehicleMovementComponentBase.Acceleration = 0x348 // float (Size: 0x4)
HoverVehicleMovementComponentBase.MaxAcceleration = 0x34c // float (Size: 0x4)
HoverVehicleMovementComponentBase.MaxSpeed = 0x350 // float (Size: 0x4)
HoverVehicleMovementComponentBase.DragScale = 0x354 // float (Size: 0x4)
HoverVehicleMovementComponentBase.AngleDragScale = 0x358 // float (Size: 0x4)
HoverVehicleMovementComponentBase.AngleAdditiveScale = 0x35c // float (Size: 0x4)
HoverVehicleMovementComponentBase.MoveBackSpeedScale = 0x360 // float (Size: 0x4)
HoverVehicleMovementComponentBase.ForceBoneName = 0x364 // FName (Size: 0x8)
HoverVehicleMovementComponentBase.TorqueBoneName = 0x36c // FName (Size: 0x8)
HoverVehicleMovementComponentBase.AdjustForceValue = 0x374 // float (Size: 0x4)
HoverVehicleMovementComponentBase.SubAdjustDeltaTimeForceValue = 0x378 // float (Size: 0x4)
HoverVehicleMovementComponentBase.IntervalSyncLocationTime = 0x37c // float (Size: 0x4)
HoverVehicleMovementComponentBase.TorqueCurve = 0x380 // CurveFloat* (Size: 0x8)
HoverVehicleMovementComponentBase.CurrentAcceleration = 0x388 // FVector (Size: 0xc)
HoverVehicleMovementComponentBase.CurrentVelocity = 0x394 // FVector (Size: 0xc)
HoverVehicleMovementComponentBase.IsInSpeedUpMode = 0x3a0 // bool (Size: 0x1)
HoverVehicleMovementComponentBase.IsBraking = 0x3a1 // bool (Size: 0x1)
HoverVehicleMovementComponentBase.ForwardForce = 0x3b0 // float (Size: 0x4)
HoverVehicleMovementComponentBase.RightTorque = 0x3b4 // float (Size: 0x4)
HoverVehicleMovementComponentBase.SpeedUpScale = 0x3b8 // float (Size: 0x4)
HoverVehicleMovementRepData.ForwardVal = 0x0 // float (Size: 0x4)
HoverVehicleMovementRepData.RightVal = 0x4 // float (Size: 0x4)
HoverVehicleMovementRepData.IsSpeedUp = 0x8 // bool (Size: 0x1)
HttpDeathReplayInfo.SessionName = 0x0 // FString (Size: 0x10)
HttpDeathReplayInfo.DeathOrDBNODemoTime = 0x10 // float (Size: 0x4)
HttpDeathReplayInfo.KillEventInfo = 0x18 // FSGKillEventInfo (Size: 0xc8)
ImageToSet.TargetImage = 0x0 // Image* (Size: 0x8)
ImageToSet.LocalTexture = 0x8 // Object* (Size: 0x8)
ImageToSet.UniqueID = 0x10 // FString (Size: 0x10)
ImageWaitCap.Images = 0x0 // TArray<Object*> (Size: 0x10)
ImageWaitCap.TargetRot = 0x14 // FRotator (Size: 0xc)
ImapctRepInfo.Hit = 0x0 // FHitResult (Size: 0x98)
ImapctRepInfo.DecalRollOffset = 0x98 // float (Size: 0x4)
ImpactAudioResource_HD.AudioEvent = 0x0 // AkAudioEvent* (Size: 0x8)
ImpactAudioResource_HD.AudioEvent_3P = 0x8 // AkAudioEvent* (Size: 0x8)
ImpactAudioResource_HD.MaterialAudioCoolDown = 0x10 // float (Size: 0x4)
ImpactDecalResource_HD.DecalMaterial = 0x0 // MaterialInterface* (Size: 0x8)
ImpactDecalResource_HD.RandomFrameIndex = 0x8 // FInt32Range (Size: 0x10)
ImpactDecalResource_HD.RandomSize = 0x18 // FFloatRange (Size: 0x10)
ImpactDecalResource_HD.RandomRotation = 0x28 // FFloatRange (Size: 0x10)
ImpactDecalResource_HD.RandomAlpha = 0x38 // FFloatRange (Size: 0x10)
ImpactDecalResource_HD.DepthSize = 0x48 // float (Size: 0x4)
ImpactDecalResource_HD.LifeSpan = 0x4c // float (Size: 0x4)
ImpactDecalResource_HD.bTransparentSurface = 0x50 // bool (Size: 0x1)
ImpactEffectNamedParameters.ParticleParams = 0x0 // TArray<FParticleSysParam> (Size: 0x10)
ImpactEffectResource_HD.ParticleResource = 0x0 // FImpactParticleResource_HD (Size: 0x38)
ImpactEffectResource_HD.DecalResource = 0x38 // FImpactDecalResource_HD (Size: 0x58)
ImpactMaterialAndAudioEvent.MaterialName = 0x0 // FText (Size: 0x18)
ImpactParticleResource_HD.ParticleTemplate = 0x0 // FXSystemAsset* (Size: 0x8)
ImpactParticleResource_HD.ParticleTemplate_SaaS = 0x8 // FXSystemAsset* (Size: 0x8)
ImpactParticleResource_HD.SaaSNiagaraComponents = 0x10 // TArray<NiagaraComponent*> (Size: 0x10)
ImpactParticleResource_HD.BatchThresholdDistSquared = 0x20 // float (Size: 0x4)
ImpactParticleResource_HD.ScaleCurveByDistance = 0x28 // CurveFloat* (Size: 0x8)
ImpactParticleResource_HD.ScaleCurveByFOV = 0x30 // CurveFloat* (Size: 0x8)
ImpactResultWrapper.HitResult = 0x0 // FHitResult (Size: 0x98)
ImpactResultWrapper.bFirstCreate = 0x98 // bool (Size: 0x1)
ImpactResultWrapper.bEffectLifeExpired = 0x99 // bool (Size: 0x1)
InteractConfig.KeyAttachDelayTime = 0x0 // float (Size: 0x4)
InteractConfig.KeyDetachDelayTime = 0x4 // float (Size: 0x4)
InteractConfig.TriggerFinishTime = 0x8 // float (Size: 0x4)
InteractConfig.KeyItemID = 0x10 // int64_t (Size: 0x8)
InteractConfig.AnimMontageName = 0x18 // FString (Size: 0x10)
InteractInventoryInfo.ItemId = 0x0 // int64_t (Size: 0x8)
InteractInventoryInfo.Count = 0x8 // int32_t (Size: 0x4)
InteractInventoryInfo.CostType = 0xc // EESGInteractCostType (Size: 0x1)
InteractInventoryInfo.OnlyCheck = 0xd // bool (Size: 0x1)
InteractableItemTable.ID = 0x8 // int32_t (Size: 0x4)
InteractableItemTable.Name = 0x10 // FString (Size: 0x10)
InteractableItemTable.exe_func = 0x20 // FString (Size: 0x10)
InteractionTriggerPosInfo.StartPos = 0x0 // FVector (Size: 0xc)
InteractionTriggerPosInfo.EndPos = 0xc // FVector (Size: 0xc)
InterpSpeedOverride.PrevCameraModeClass = 0x0 // ClassProperty (Size: 0x8)
InterpSpeedOverride.OriginLocInterpSpeed = 0x8 // float (Size: 0x4)
InterpSpeedOverride.PerAxisOriginLocInterpSpeed = 0xc // FVector (Size: 0xc)
InvBulletInfo.BulletMeshInfos = 0x0 // TArray<FBulletMeshInfo> (Size: 0x10)
InvBulletInfo.WaitInsertBulletNum = 0x10 // int32_t (Size: 0x4)
InvGiveExtraParams.Pos = 0x0 // EEAttachPosition (Size: 0x1)
InvGiveExtraParams.ParentInv = 0x8 // SGInventory* (Size: 0x8)
InvGiveExtraParams.ContainerIndex = 0x10 // int32_t (Size: 0x4)
InvGiveExtraParams.SocketName = 0x14 // FName (Size: 0x8)
InvGiveExtraParams.bDestroyItem = 0x1c // bool (Size: 0x1)
InvGiveExtraParams.DropPosition = 0x20 // FItemGridInfo (Size: 0x8)
InvGiveExtraParams.Durability = 0x28 // int32_t (Size: 0x4)
InvGiveExtraParams.InstId = 0x30 // int64_t (Size: 0x8)
InvGiveExtraParams.TakeInPlayerGID = 0x38 // int64_t (Size: 0x8)
InvGiveExtraParams.InsureType = 0x40 // int32_t (Size: 0x4)
InvGiveExtraParams.SkinID = 0x44 // int32_t (Size: 0x4)
InvGiveExtraParams.MergeTargetInventory = 0x48 // SGInventory* (Size: 0x8)
InvGiveExtraParams.PendantID = 0x50 // int32_t (Size: 0x4)
InvGiveExtraParams.ItemSourceInfo = 0x58 // TArray<FStackableItemSourceInfo> (Size: 0x10)
InventoryActivityItemExtraInfo.InitialOwnerName = 0x0 // FString (Size: 0x10)
InventoryActivityItemExtraInfo.BornTimestamp = 0x10 // uint64_t (Size: 0x8)
InventoryActivityItemExtraInfo.LevelupTimestamp = 0x18 // uint64_t (Size: 0x8)
InventoryActivityItemExtraInfo.ExpValue = 0x20 // uint64_t (Size: 0x8)
InventoryActivityItemExtraInfo.OldItemID = 0x28 // uint64_t (Size: 0x8)
InventoryActivityItemExtraInfo.TakeinPlayerName = 0x30 // FString (Size: 0x10)
InventoryActivityItemExtraInfo.TakeinPlayerLevel = 0x40 // uint32_t (Size: 0x4)
InventoryActivityItemExtraInfo.TakeinPlayerRankLevel = 0x44 // uint32_t (Size: 0x4)
InventoryAnimPoseInfo.bHasInitialized = 0x0 // bool (Size: 0x1)
InventoryAnimPoseInfo.AnimMontage = 0x8 // AnimMontage* (Size: 0x8)
InventoryAnimPoseInfo.PositionToStay = 0x10 // float (Size: 0x4)
InventoryContainer.InventoryArray = 0x0 // TArray<SGInventory*> (Size: 0x10)
InventoryContainerBase.RowNum = 0x0 // int32_t (Size: 0x4)
InventoryContainerBase.ColumnNum = 0x4 // int32_t (Size: 0x4)
InventoryContainerBase.RuleID = 0x8 // int32_t (Size: 0x4)
InventoryContainerBase.GridList = 0x10 // TArray<FSGBagGridInfo> (Size: 0x10)
InventoryContainerBase.ContainerIndex = 0x20 // int32_t (Size: 0x4)
InventoryContainerBase.ChildActorList = 0x28 // TArray<Actor*> (Size: 0x10)
InventoryContainerBase.Inventory = 0x38 // SGInventory* (Size: 0x8)
InventoryContainerBase_PreOccupiedActorInfoMap.PreOccupiedActorInfoMap = 0x0 // TArray<FGridPreOccupiedInfo> (Size: 0x10)
InventoryDetectorInfo.bIsActivated = 0x0 // bool (Size: 0x1)
InventoryDetectorInfo.Power = 0x4 // float (Size: 0x4)
InventoryDetectorInfo.DetectionValue = 0x8 // float (Size: 0x4)
InventoryDetectorInfo.DetectedDirection = 0xc // EEDetectedDirection (Size: 0x1)
InventoryDetectorInfo.DetectedInventory = 0x10 // Actor* (Size: 0x8)
InventoryDogTagInfo.RecordedDeathCharacterName = 0x0 // FString (Size: 0x10)
InventoryDogTagInfo.RecordedDeathCharacterLevel = 0x10 // int32_t (Size: 0x4)
InventoryDogTagInfo.RecordedDeathCharacterGOpenID = 0x14 // uint32_t (Size: 0x4)
InventoryDogTagInfo.RecordedDeathCharacterGID = 0x18 // uint64_t (Size: 0x8)
InventoryDogTagInfo.RecordedDeathCharacterTime = 0x20 // uint64_t (Size: 0x8)
InventoryDogTagInfo.RecordedDeathCauserName = 0x28 // FString (Size: 0x10)
InventoryDogTagInfo.RecordedDeathCauserWeaponID = 0x38 // uint64_t (Size: 0x8)
InventoryDogTagInfo.RecordedDeathMapName = 0x40 // FString (Size: 0x10)
InventoryDogTagInfo.RecordedDeathCauserCharacterType = 0x50 // int32_t (Size: 0x4)
InventoryDogTagInfo.RecordedDeathReason = 0x54 // int32_t (Size: 0x4)
InventoryDogTagInfo.RecordedDeathCauserIsTeamMate = 0x58 // bool (Size: 0x1)
InventoryDogTagInfo.RecordedDeathCharacterRankLevel = 0x5c // int32_t (Size: 0x4)
InventoryDogTagInfo.RecordedDeathCharacterNationalFlagIso = 0x60 // int32_t (Size: 0x4)
InventoryExtraMeshInfo.BaseItemID = 0x0 // int32_t (Size: 0x4)
InventoryExtraMeshInfo.AssembleItemID = 0x4 // int32_t (Size: 0x4)
InventoryExtraMeshInfo.ExtraMeshComp = 0x8 // MeshComponent* (Size: 0x8)
InventoryForcedInteractInfo.InteractCharacter = 0x0 // SGCharacter* (Size: 0x8)
InventoryForcedInteractInfo.RemainDuration = 0x8 // float (Size: 0x4)
InventoryForcedInteractInfo.CurInventoryForcedInteractType = 0xc // EEInventoryForcedInteractType (Size: 0x1)
InventoryForcedInteractInfo.HostedInteractInfoList = 0x10 // TArray<FHostedInteractInfo> (Size: 0x10)
InventoryGAData.ItemId = 0x8 // uint32_t (Size: 0x4)
InventoryGAData.InventoryTagType = 0x10 // FGameplayTagContainer (Size: 0x20)
InventoryGAData.MeshAsset = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
InventoryGAData.MeshAnimInstace = 0x58 // TSoftClassPtr<UObject> (Size: 0x28)
InventoryGAData.MeshMontageToPlay = 0x80 // TSoftObjectPtr<UObject> (Size: 0x28)
InventoryGAData.CharMontageToPlay = 0xa8 // TSoftObjectPtr<UObject> (Size: 0x28)
InventoryGAData.MontageStartSection = 0xd0 // FName (Size: 0x8)
InventoryGAData.PlayRate = 0xd8 // float (Size: 0x4)
InventoryGAData.bUseDynamicLoopCount = 0xdc // bool (Size: 0x1)
InventoryGAData.Period = 0xe0 // float (Size: 0x4)
InventoryGAData.CureValueOncePeriod = 0xe4 // float (Size: 0x4)
InventoryGAData.AbilityGameplayTag = 0xe8 // FGameplayTag (Size: 0x8)
InventoryGAData.GA_LoopEffect_DelayApplyTime = 0xf0 // float (Size: 0x4)
InventoryGAData.bApplyGEOneByOne = 0xf4 // bool (Size: 0x1)
InventoryGAData.GameplayEffectEndTime = 0xf8 // float (Size: 0x4)
InventoryGAData.AttachSocket = 0xfc // FName (Size: 0x8)
InventoryGAData.GA_PreGamePlayEffectsRefList = 0x108 // TArray<FSGGEDataLookupDT> (Size: 0x10)
InventoryGAData.GA_LoopGamePlayEffectsRefList = 0x118 // TArray<FSGGEDataLookupDT> (Size: 0x10)
InventoryGAData.GA_EndGamePlayEffectsRefList = 0x128 // TArray<FSGGEDataLookupDT> (Size: 0x10)
InventoryGAData.PassivePriority = 0x138 // int32_t (Size: 0x4)
InventoryGAData.PassiveGameplayEffectsConfigMap = 0x140 // TMap<...> (Size: 0x50)
InventoryGAData.AttachSetupDuration = 0x190 // float (Size: 0x4)
InventoryGAData.DetachSetupDuration = 0x194 // float (Size: 0x4)
InventoryGAData.bShowCancelButton = 0x198 // bool (Size: 0x1)
InventoryGAData.SubInventoryProbabilityConfigMap = 0x1a0 // TMap<...> (Size: 0x50)
InventoryGAData.SetupGERef = 0x1f0 // FSGGEDataLookupDT (Size: 0x18)
InventoryGEAttributeModifier.ModifyAttribute = 0x0 // FGameplayAttribute (Size: 0x38)
InventoryGEAttributeModifier.ModifyValue = 0x38 // float (Size: 0x4)
InventoryGEAttributeModifier.ModifierOp = 0x3c // uint8_t (Size: 0x1)
InventoryGEAttributeModifier.CalculationClassMagnitude = 0x40 // ClassProperty (Size: 0x8)
InventoryGEAttributeModifier.Coefficient = 0x48 // float (Size: 0x4)
InventoryGEAttributeModifier.Priority = 0x4c // uint8_t (Size: 0x1)
InventoryGEAttributeModifier.ModsSelector = 0x4d // uint8_t (Size: 0x1)
InventoryGEAttributeModifier.ModChannel = 0x4e // EEGameplayModEvaluationChannel (Size: 0x1)
InventoryGEAttributeModifier.SourceTags = 0x50 // FGameplayTagRequirements (Size: 0x40)
InventoryGEAttributeModifier.TargetTags = 0x90 // FGameplayTagRequirements (Size: 0x40)
InventoryGridInfo.OwnerActor = 0x0 // Actor* (Size: 0x8)
InventoryGridInfo.ParentActor = 0x8 // Actor* (Size: 0x8)
InventoryGridInfo.ParentType = 0x10 // EESGInventoryParentType (Size: 0x1)
InventoryGridInfo.GridInfo = 0x14 // FItemGridInfo (Size: 0x8)
InventoryGridInfo.CurGridInfo = 0x1c // FItemGridInfo (Size: 0x8)
InventoryGridInfo.StartGridPosition = 0x24 // FItemGridInfo (Size: 0x8)
InventoryGridInfo.GridPosition = 0x2c // FItemGridInfo (Size: 0x8)
InventoryGridInfo.ContainerIndex = 0x34 // int32_t (Size: 0x4)
InventoryGridInfo.AttachPosition = 0x38 // EEAttachPosition (Size: 0x1)
InventoryGridInfo.IsRotated = 0x39 // bool (Size: 0x1)
InventoryGridInfo.ServerFrameCounter = 0x40 // uint64_t (Size: 0x8)
InventoryIdClass.ID = 0x0 // uint64_t (Size: 0x8)
InventoryIdClass.Class = 0x8 // TSoftClassPtr<UObject> (Size: 0x28)
InventoryIdClass.TempleteClass = 0x30 // TSoftClassPtr<UObject> (Size: 0x28)
InventoryInteractionRepInfo.InvInteractType = 0x0 // EEInventoryInteractionType (Size: 0x1)
InventoryInteractionRepInfo.InteractInvList = 0x8 // TArray<SGInventory*> (Size: 0x10)
InventoryLoadQueueInfoStruct.Inventory = 0x0 // SGInventory* (Size: 0x8)
InventoryLockInfo.LockedByCharacter = 0x0 // SGCharacter* (Size: 0x8)
InventoryLockInfo.LockTypeArray = 0x8 // TArray<EEInventoryLockType> (Size: 0x10)
InventoryOperationRepInfo.OldParentInvRuntimeID = 0x0 // int32_t (Size: 0x4)
InventoryOperationRepInfo.NewParentInvRuntimeID = 0x4 // int32_t (Size: 0x4)
InventoryOperationRepInfo.NewContainerIndex = 0x8 // int32_t (Size: 0x4)
InventoryOperationRepInfo.OldParentGridBaseTraceList = 0x10 // TArray<ActorComponent*> (Size: 0x10)
InventoryOperationRepInfo.OldParentInv = 0x20 // Actor* (Size: 0x8)
InventoryOperationRepInfo.NewParentInv = 0x28 // Actor* (Size: 0x8)
InventoryOperationRepInfo.OldAttachPosition = 0x30 // EEAttachPosition (Size: 0x1)
InventoryOperationRepInfo.AttachPosition = 0x31 // EEAttachPosition (Size: 0x1)
InventoryOperationRepInfo.StartGridPosition = 0x34 // FItemGridInfo (Size: 0x8)
InventoryOperationRepInfo.Count = 0x3c // int32_t (Size: 0x4)
InventoryOperationRepInfo.OperationLoc = 0x40 // FVector (Size: 0xc)
InventoryPassiveGEContainer.MaxUsageNum = 0x0 // int32_t (Size: 0x4)
InventoryPassiveGEContainer.DurabilityPerUsage = 0x4 // int32_t (Size: 0x4)
InventoryPassiveGEContainer.GameplayEffectsRefConfigList = 0x8 // TArray<FSGGEDataLookupDT> (Size: 0x10)
InventorySourceInfo.InventoryID = 0x0 // int32_t (Size: 0x4)
InventorySourceInfo.FromPlayerGID = 0x8 // int64_t (Size: 0x8)
InventorySourceInfo.FromTeamIndex = 0x10 // int32_t (Size: 0x4)
InventorySourceInfo.InventoryCount = 0x14 // int32_t (Size: 0x4)
InventorySourceInfo.LootLimitPoolID = 0x18 // int32_t (Size: 0x4)
InventorySourceInfo.FromCharacterType = 0x1c // EECharacterType (Size: 0x1)
InventorySourceInfo.InventorySourceType = 0x1d // EESGInventorySpawnSourceType (Size: 0x1)
InventorySourceInfo.ItemValueParams = 0x20 // FItemValueParams (Size: 0x1c)
InventorySpawnSourceInfo.SpawnSourceType = 0x0 // EESGInventorySpawnSourceType (Size: 0x1)
InventorySpawnSourceInfo.FromCharacterType = 0x1 // EECharacterType (Size: 0x1)
InventorySpawnSourceInfo.FromPlayerGID = 0x8 // int64_t (Size: 0x8)
InventorySpawnSourceInfo.FromTeamIndex = 0x10 // int32_t (Size: 0x4)
InventorySpawnSourceInfo.SpawnLocation = 0x14 // FVector (Size: 0xc)
InventorySpawnSourceInfo.SpawnRotation = 0x20 // FRotator (Size: 0xc)
InventoryStaticsTask.TaskId = 0x28 // int32_t (Size: 0x4)
InventoryStaticsTask.loadCount = 0x2c // int32_t (Size: 0x4)
InventoryStaticsTask.CurInventory = 0x30 // SGInventory* (Size: 0x8)
InventoryStaticsTask.rootItemGid = 0x38 // uint64_t (Size: 0x8)
InventoryStaticsTask.ItemInfos = 0x40 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
InventoryStaticsTask.IsHelmetDisabled = 0x50 // bool (Size: 0x1)
InventoryStaticsTask.IsFoldButt = 0x51 // bool (Size: 0x1)
InventoryStaticsTask.AsyncID = 0x54 // int32_t (Size: 0x4)
InventoryTempleteClass.TempleteClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
InventoryValueInfo.InventoryID = 0x0 // int32_t (Size: 0x4)
InventoryValueInfo.InventoryCount = 0x4 // int32_t (Size: 0x4)
InventoryValueInfo.ItemValueParams = 0x8 // FItemValueParams (Size: 0x1c)
InvokeAnnounceConfig.AnnounceRange = 0x0 // EEAnnounceRangeType (Size: 0x1)
InvokeAnnounceConfig.AnnounceID = 0x4 // int32_t (Size: 0x4)
InvokeAnnounceConfig.ExternParams = 0x8 // TArray<int32_t> (Size: 0x10)
ItemDetailKeyInfo.SpawnTypeID = 0x0 // int32_t (Size: 0x4)
ItemDetailKeyInfo.FactionType = 0x4 // int32_t (Size: 0x4)
ItemDetailedSourceInfo.DetailedNumMap = 0x0 // TMap<...> (Size: 0x50)
ItemGridInfo.Row = 0x0 // int32_t (Size: 0x4)
ItemGridInfo.Column = 0x4 // int32_t (Size: 0x4)
ItemRotatorConf.ID = 0x8 // int32_t (Size: 0x4)
ItemRotatorConf.Rotator = 0xc // FRotator (Size: 0xc)
ItemRotatorConf.WeaponBuildOverviewRotator = 0x18 // FRotator (Size: 0xc)
ItemRotatorConf.MaxRotator = 0x24 // FRotator (Size: 0xc)
ItemRotatorConf.MinRotator = 0x30 // FRotator (Size: 0xc)
ItemSizeModifyInfo.Up = 0x0 // int32_t (Size: 0x4)
ItemSizeModifyInfo.Down = 0x4 // int32_t (Size: 0x4)
ItemSizeModifyInfo.Left = 0x8 // int32_t (Size: 0x4)
ItemSizeModifyInfo.Right = 0xc // int32_t (Size: 0x4)
ItemSkinInfo.SkinID = 0x0 // int32_t (Size: 0x4)
ItemSkinInfo.ItemId = 0x4 // int32_t (Size: 0x4)
ItemSkinInfo.bIsStaticMesh = 0x8 // bool (Size: 0x1)
ItemSkinInfo.MeshPath = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
ItemSkinInfo.MeshPath_Game = 0x38 // TSoftObjectPtr<UObject> (Size: 0x28)
ItemSkinInfo.MeshPath_Lobby = 0x60 // TSoftObjectPtr<UObject> (Size: 0x28)
ItemSkinInfo.AnimSetSoftClass = 0x88 // TSoftClassPtr<UObject> (Size: 0x28)
ItemSkinInfo.InvAnimBPSoftClass = 0xb0 // TSoftClassPtr<UObject> (Size: 0x28)
ItemSkinInfo.OverrideMaterials = 0xd8 // TArray<FOverrideMaterialInfo> (Size: 0x10)
ItemSkinInfo.OverrideMaterials_Game = 0xe8 // TArray<FOverrideMaterialInfo> (Size: 0x10)
ItemSkinInfo.OverrideMaterials_Lobby = 0xf8 // TArray<FOverrideMaterialInfo> (Size: 0x10)
ItemSkinInfo.bHasOverrideAdapterAnimation = 0x108 // bool (Size: 0x1)
ItemSkinInfo.bHasAdditionMeshAnimInfo = 0x109 // bool (Size: 0x1)
ItemSkinInfo.CueClass = 0x110 // TSoftClassPtr<UObject> (Size: 0x28)
ItemValueParams.Durability = 0x0 // int32_t (Size: 0x4)
ItemValueParams.MaxDurability = 0x4 // int32_t (Size: 0x4)
ItemValueParams.DefaultMaxDurability = 0x8 // int32_t (Size: 0x4)
ItemValueParams.ArmorMaterialID = 0xc // int32_t (Size: 0x4)
ItemValueParams.ArmorLevel = 0x10 // int32_t (Size: 0x4)
ItemValueParams.StandardPrice = 0x14 // int32_t (Size: 0x4)
ItemValueParams.SellPrice = 0x18 // int32_t (Size: 0x4)
JamBreakSoundConfig.Type = 0x0 // EESGGunWeaponSubType (Size: 0x1)
JamBreakSoundConfig.SoundEvent = 0x8 // AkAudioEvent* (Size: 0x8)
KdaData.GID = 0x0 // uint64_t (Size: 0x8)
KdaData.KillNum = 0x8 // int32_t (Size: 0x4)
KdaData.DeathNum = 0xc // int32_t (Size: 0x4)
KdaData.AssistNum = 0x10 // int32_t (Size: 0x4)
KdaData.Damage = 0x14 // int32_t (Size: 0x4)
KeyDoorIKInfo.EnableIK = 0x0 // bool (Size: 0x1)
KeyDoorIKInfo.IsDetach = 0x1 // bool (Size: 0x1)
KeyDoorIKInfo.KeyAttachDelayTime = 0x4 // float (Size: 0x4)
KeyDoorIKInfo.KeyDetachDelayTime = 0x8 // float (Size: 0x4)
KeyDoorIKInfo.LockLocation = 0xc // FVector (Size: 0xc)
KeyDoorIKInfo.ShoulderLocation = 0x18 // FVector (Size: 0xc)
KeyDoorIKInfo.ShoulderRotator = 0x24 // FRotator (Size: 0xc)
KeyDoorIKInfo.KeySkeletalMeshTemplate = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
KeyDoorTagetInfo.DoorLocation = 0x0 // FVector (Size: 0xc)
KeyDoorTagetInfo.FaceDirection = 0xc // FVector (Size: 0xc)
KeyDoorTagetInfo.LockLocation = 0x18 // FVector (Size: 0xc)
KeyDoorTagetInfo.ForceBreakLocation = 0x24 // FVector (Size: 0xc)
KeyDoorTagetInfo.MoveDuration = 0x30 // float (Size: 0x4)
KeyDoorTagetInfo.ForceBreakMoveDuration = 0x34 // float (Size: 0x4)
KillInfo.KillerController = 0x0 // Controller* (Size: 0x8)
KillInfo.KilledController = 0x8 // Controller* (Size: 0x8)
KillInfo.KillerGID = 0x10 // uint64_t (Size: 0x8)
KillInfo.KilledGID = 0x18 // uint64_t (Size: 0x8)
KillInfo.KillerPlayerName = 0x20 // FString (Size: 0x10)
KillInfo.KillerDirectorName = 0x30 // FString (Size: 0x10)
KillInfo.KillerPawn = 0x40 // Pawn* (Size: 0x8)
KillInfo.KilledPawn = 0x48 // Pawn* (Size: 0x8)
KillInfo.KilledCharacterType = 0x50 // EECharacterType (Size: 0x1)
KillInfo.KillerFaction = 0x51 // EEFactionType (Size: 0x1)
KillInfo.KilledFaction = 0x52 // EEFactionType (Size: 0x1)
KillInfo.KillerIsAI = 0x53 // bool (Size: 0x1)
KillInfo.KilledIsAI = 0x54 // bool (Size: 0x1)
KillInfo.KillerTeamID = 0x58 // int32_t (Size: 0x4)
KillInfo.KilledTeamID = 0x5c // int32_t (Size: 0x4)
KillInfo.KillerWeapon = 0x60 // Actor* (Size: 0x8)
KillInfo.DamageEventObject = 0x68 // DamageEventObject* (Size: 0x8)
KillInfo.KillerWeaponId = 0x70 // int64_t (Size: 0x8)
KillInfo.KilledWeaponId = 0x78 // int64_t (Size: 0x8)
KillInfo.KillerBulletPenetrateFactor = 0x80 // int32_t (Size: 0x4)
KillInfo.KilledBulletPenetrateFactor = 0x84 // int32_t (Size: 0x4)
KillInfo.KillDistance = 0x88 // int32_t (Size: 0x4)
KillInfo.bDBNO = 0x8c // bool (Size: 0x1)
KillInfo.bForceDied = 0x8d // bool (Size: 0x1)
KillInfo.bHitArmor = 0x8e // bool (Size: 0x1)
KillInfo.bPenetrateArmor = 0x8f // bool (Size: 0x1)
KillInfo.EnduranceType = 0x90 // EECharacterEnduranceType (Size: 0x1)
KillInfo.KillTime = 0x98 // FDateTime (Size: 0x8)
KillInfo.DeathType = 0xa0 // EECharacterDeathType (Size: 0x1)
KillInfo.bRevengeKill = 0xa1 // bool (Size: 0x1)
KillInfo.AIPerformanceID = 0xa4 // int32_t (Size: 0x4)
KillInfo.AssistKillInfos = 0xa8 // TArray<FAssistKillInfo> (Size: 0x10)
KillOtherStatis.AllDamage = 0x0 // float (Size: 0x4)
KillOtherStatis.HitCount = 0x4 // int32_t (Size: 0x4)
KillOtherStatis.AllArmorReduceDamage = 0x8 // float (Size: 0x4)
KillOtherStatis.ArmorId = 0x10 // int64_t (Size: 0x8)
KillOtherStatis.DeathType = 0x18 // EECharacterDeathType (Size: 0x1)
KillStatis.KillTime = 0x0 // float (Size: 0x4)
KillStatis.IsAI = 0x4 // bool (Size: 0x1)
KilledStaticData.Causer = 0x0 // Actor* (Size: 0x8)
KilledStaticData.KillDistance = 0x8 // float (Size: 0x4)
KilledStaticData.bHitArmor = 0xc // bool (Size: 0x1)
KilledStaticData.HitArmorId = 0x10 // int64_t (Size: 0x8)
KilledStaticData.bPenetrateArmor = 0x18 // bool (Size: 0x1)
KilledStaticData.CurrentArmorDurability = 0x1c // int32_t (Size: 0x4)
KilledStaticData.CurrentArmorDurabilityMax = 0x20 // int32_t (Size: 0x4)
KilledStaticData.BeforeArmorDurability = 0x24 // int32_t (Size: 0x4)
KilledStaticData.bForceDied = 0x28 // bool (Size: 0x1)
KilledStaticData.EnduranceType = 0x29 // EECharacterEnduranceType (Size: 0x1)
KilledStaticData.KillerBulletPenetrateFactor = 0x2c // int32_t (Size: 0x4)
KilledStaticData.KilledTime = 0x30 // FDateTime (Size: 0x8)
KilledStaticData.DeathType = 0x38 // EECharacterDeathType (Size: 0x1)
KilledStaticData.LastHitByOtherInfo = 0x40 // FSGLastHitByInfo (Size: 0x30)
KilledStaticData.bSuicideWithoutCauser = 0x70 // bool (Size: 0x1)
KilledStaticData.AssistKillerGIDs = 0x78 // TArray<uint64_t> (Size: 0x10)
KillerStaticData.Killer = 0x0 // Character* (Size: 0x8)
KillerStaticData.KillerPS = 0x8 // SGPlayerState* (Size: 0x8)
KillerStaticData.KillerName = 0x10 // FString (Size: 0x10)
KillerStaticData.KillerCharacterName = 0x20 // FString (Size: 0x10)
KillerStaticData.KillerWeaponId = 0x30 // int64_t (Size: 0x8)
KillerStaticData.KillerIconInfo = 0x38 // FSGPlayerIconInfo (Size: 0x58)
KillerStaticData.KillerBannerInfo = 0x90 // FSGPlayerBannerInfo (Size: 0x28)
KillerStaticData.KillerRankrd = 0xb8 // uint32_t (Size: 0x4)
KillerStaticData.KillerRankScore = 0xbc // uint32_t (Size: 0x4)
KillerStaticData.KillerRank = 0xc0 // uint32_t (Size: 0x4)
KillerStaticData.KillerRanking = 0xc4 // uint32_t (Size: 0x4)
KillerStaticData.KillerPranking = 0xc8 // uint32_t (Size: 0x4)
KillerStaticData.KillerPVPranking = 0xcc // uint32_t (Size: 0x4)
KillerStaticData.KillerGID = 0xd0 // uint64_t (Size: 0x8)
KillerStaticData.KillerTeamTypeId = 0xd8 // int32_t (Size: 0x4)
KillerStaticData.KillerTeamID = 0xdc // int32_t (Size: 0x4)
KillerStaticData.KillerFaction = 0xe0 // EEFactionType (Size: 0x1)
KillerStaticData.KillerCharacterType = 0xe1 // EECharacterType (Size: 0x1)
KillerStaticData.KillerPos = 0xe4 // FVector (Size: 0xc)
KillerStaticData.SightName = 0xf0 // FString (Size: 0x10)
KillerStaticData.KillerVestID = 0x100 // int64_t (Size: 0x8)
KillerStaticData.KillerHelmetID = 0x108 // int64_t (Size: 0x8)
KillerStaticData.KillerFaceShieldID = 0x110 // int64_t (Size: 0x8)
KillerStaticData.KillerWeaponValue = 0x118 // int32_t (Size: 0x4)
KillerStaticData.bIsAICharacter = 0x11c // bool (Size: 0x1)
KillerStaticData.AllHealthStatics = 0x120 // TArray<FCharacterHealthStaticsWhenDead> (Size: 0x10)
KillerStaticData.PlayerItemInfo = 0x130 // SGPlayerItemInfoBase* (Size: 0x8)
KillerStaticData.KillerWeapon = 0x138 // TArray<FSGClientShowItemInfo> (Size: 0x10)
KillerStaticData.PlayerShowInfo = 0x148 // FSGPlayerShowInfo (Size: 0x40)
KillerStaticData.KillerNetGUIDForReplay = 0x188 // int32_t (Size: 0x4)
KillerStaticData.KillerNationalFlagIso = 0x18c // uint32_t (Size: 0x4)
KillerStaticData.bKillerFlashLightOpen = 0x190 // bool (Size: 0x1)
LadderClimbingBaseState.NextStates = 0x28 // TArray<LadderClimbingBaseState*> (Size: 0x10)
LadderClimbingBaseState.OwnerChar = 0x38 // SGCharacter* (Size: 0x8)
LadderClimbingBaseState.LadderClimbComponent = 0x40 // SGCharacterMovementLadderClimbComponent* (Size: 0x8)
LadderClimbingBaseState.LadderClimbingMontageTask = 0x48 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
LadderClimbingBaseState.TargetLadderClimbingMontage = 0x50 // TArray<FLadderClimbingMontage> (Size: 0x10)
LadderClimbingMontage.InputType = 0x0 // EELadderClimbingInputType (Size: 0x1)
LadderClimbingMontage.DirectionType = 0x1 // EELadderClimbingDirectionType (Size: 0x1)
LadderClimbingMontage.CharacterMontage = 0x8 // AnimMontage* (Size: 0x8)
LadderClimbingNetInfo.DirectionType = 0x0 // EELadderClimbingDirectionType (Size: 0x1)
LadderClimbingNetInfo.InputType = 0x1 // EELadderClimbingInputType (Size: 0x1)
LadderClimbingNetInfo.StateType = 0x2 // EELadderClimbingStateType (Size: 0x1)
LastCharacterOwnerInfo.LastOwner = 0x0 // SGCharacter* (Size: 0x8)
LastCharacterOwnerInfo.RemoveFrame = 0x8 // int64_t (Size: 0x8)
LastHitPlayerInfo.Character = 0x0 // SGCharacter* (Size: 0x8)
LastHitPlayerInfo.TakerGID = 0x8 // int64_t (Size: 0x8)
LastHitPlayerInfo.bPenetrateArmor = 0x10 // int32_t (Size: 0x4)
LastHitPlayerInfo.PenetrateArmorProbability = 0x14 // float (Size: 0x4)
LastHitPlayerInfo.TakerName = 0x18 // FString (Size: 0x10)
LastHitPlayerInfo.BulletID = 0x28 // int64_t (Size: 0x8)
LastHitPlayerInfo.ArmorId = 0x30 // uint64_t (Size: 0x8)
LastHitPlayerInfo.CurrentArmorDurability = 0x38 // int32_t (Size: 0x4)
LastHitPlayerInfo.CurrentArmorDurabilityMax = 0x3c // int32_t (Size: 0x4)
LastHitPlayerInfo.TotalDamage = 0x40 // float (Size: 0x4)
LastHitPlayerInfo.TotalArmorReduceDamage = 0x44 // float (Size: 0x4)
LastHitPlayerInfo.bIsDBNO = 0x48 // bool (Size: 0x1)
LastHitPlayerInfo.bIsDead = 0x49 // bool (Size: 0x1)
LastHitPlayerInfo.bBodyHitThrough = 0x4c // int32_t (Size: 0x4)
LastHitPlayerInfo.ShootDistance = 0x50 // float (Size: 0x4)
LastHitPlayerInfo.WeaponId = 0x54 // int32_t (Size: 0x4)
LastHitPlayerInfo.PlayerIconInfo = 0x58 // FSGPlayerIconInfo (Size: 0x58)
LastHitPlayerInfo.PlayerBannerInfo = 0xb0 // FSGPlayerBannerInfo (Size: 0x28)
LastHitPlayerInfo.PlayerShowInfo = 0xd8 // FSGPlayerShowInfo (Size: 0x40)
LastHitPlayerInfo.LastDamage = 0x118 // float (Size: 0x4)
LastHitPlayerInfo.bRicochet = 0x11c // bool (Size: 0x1)
LastHitPlayerInfo.CosumeArmorDurability = 0x120 // float (Size: 0x4)
LastHitPlayerInfo.LastHitReduceDamage = 0x124 // float (Size: 0x4)
LifeDetectorInfo.DetectorState = 0x0 // EEDetectorState (Size: 0x1)
LifeDetectorInfo.Power = 0x4 // float (Size: 0x4)
LifeDetectorInfo.NearestItemDistance = 0x8 // float (Size: 0x4)
LifeDetectorInfo.ItemsInfo = 0x10 // TArray<int32_t> (Size: 0x10)
LimitRandomAreaPlanDataInfo.BeginDateTime = 0x0 // FDateTime (Size: 0x8)
LimitRandomAreaPlanDataInfo.bRunning = 0x8 // bool (Size: 0x1)
LimitRandomAreaPlanDataInfo.CurAreaPointInfo = 0xc // FAreaPointInfo (Size: 0x14)
LimitRandomAreaPlanDataInfo.TargetAreaPointInfo = 0x20 // FAreaPointInfo (Size: 0x14)
LimitRandomAreaPlanDataInfo.PlanStatusType = 0x34 // EELimitRandomAreaPlanStatusType (Size: 0x1)
LoadedAIFactionProfiles.LoadedProfiles = 0x0 // TArray<NPCAIPropertyProfile*> (Size: 0x10)
LoadedAIFactionProfiles.LoadedSwitchProfiles = 0x10 // TArray<NPCAIPropertyProfile*> (Size: 0x10)
LoadedAIFactionProfilesOfFactionClass.LoadedProfilesMap = 0x0 // TMap<...> (Size: 0x50)
LoadingAnimation.Animation = 0x48 // WidgetAnimation* (Size: 0x8)
LoadingAnimation.UserWidget = 0x50 // UserWidget* (Size: 0x8)
LoadingScreenTickableGameObject.UMGLoadingScreenWidget = 0x38 // UserWidget* (Size: 0x8)
LoadingScreenTickableGameObject.bFinishTickAnimation = 0x40 // bool (Size: 0x1)
LockAIData.VoiceKeys = 0x0 // TArray<FName> (Size: 0x10)
LockAIData.VoiceValues = 0x10 // TArray<FString> (Size: 0x10)
LongEffectInfo.GrenadeFXSC = 0x0 // FXSystemComponent* (Size: 0x8)
LoopMaterialForSpecialTime.StartTime = 0x0 // FDateTime (Size: 0x8)
LoopMaterialForSpecialTime.EndTime = 0x8 // FDateTime (Size: 0x8)
LoopMaterialForSpecialTime.LoopTime = 0x10 // float (Size: 0x4)
LoopMaterialForSpecialTime.LoopMaterialIDs = 0x18 // TArray<int32_t> (Size: 0x10)
LoosePointInfo.LoosePointName = 0x0 // FString (Size: 0x10)
LoosePointInfo.LoosePointDetailID = 0x10 // uint32_t (Size: 0x4)
LootContainerUnLockInfo.LootPointID = 0x0 // int32_t (Size: 0x4)
LootContainerUnLockInfo.Whitelist_Playergid = 0x8 // TArray<uint64_t> (Size: 0x10)
LootContainerUnLockInfo.ProtectTakeEffectTime = 0x18 // FDateTime (Size: 0x8)
LootContainerUnLockInfo.LootExtendTime = 0x20 // float (Size: 0x4)
LootContainerUnLockInfo.LootExtendValidTime = 0x24 // float (Size: 0x4)
LootContainerUnLockInfo.ForbidInteractProtectTime = 0x28 // float (Size: 0x4)
LootContainerUnLockInfo.ProtectActorInteractStrategy = 0x2c // EEProtectActorInteractStrategy (Size: 0x1)
LootContainerUnLockInfo.bIsBlock = 0x2d // bool (Size: 0x1)
LootLimitEquipmentDate.EquipmentMap = 0x0 // TMap<...> (Size: 0x50)
LootPointUnLockInfo.LootPointID = 0x0 // int32_t (Size: 0x4)
LootPointUnLockInfo.UnLockPlayerGIDs = 0x8 // TArray<uint64_t> (Size: 0x10)
LootPointUnLockInfo.UnLockTime = 0x18 // float (Size: 0x4)
LootPointUnLockInfo.LootProtectTime = 0x1c // float (Size: 0x4)
LootPointUnLockInfo.bIsBlock = 0x20 // bool (Size: 0x1)
MPGameEndingInfo.bEnding = 0x0 // bool (Size: 0x1)
MPGameEndingInfo.SelfFactionScore = 0x4 // int32_t (Size: 0x4)
MPGameEndingInfo.EnemyFactionScore = 0x8 // int32_t (Size: 0x4)
MPGameEndingInfo.VictoryFactionType = 0xc // EEFactionType (Size: 0x1)
MagFOVRaw.MagType = 0x0 // EESGMagType (Size: 0x1)
MagFOVRaw.FOV = 0x4 // float (Size: 0x4)
MagnificationSensitivitySetting.SensitivityNormal = 0x0 // TMap<...> (Size: 0x50)
MagnificationSensitivitySetting.SensitivityOnFire = 0x50 // TMap<...> (Size: 0x50)
MagnificationSensitivitySetting.SensitivityGyro = 0xa0 // TMap<...> (Size: 0x50)
ManualNetRelevantFollowOnwerInfo.CachedOwner = 0x8 // Actor* (Size: 0x8)
MaterialParamValue.Type = 0x0 // EEMaterialParamType (Size: 0x1)
MaterialParamValue.FloatValue = 0x4 // float (Size: 0x4)
MaterialParamValue.BoolValue = 0x8 // bool (Size: 0x1)
MaterialParamValue.ColorValue = 0xc // FLinearColor (Size: 0x10)
MeleeAudioEvent.BluntMeleeAudioEvent = 0x0 // AkAudioEvent* (Size: 0x8)
MeleeAudioEvent.SharpMeleeAudioEvent = 0x8 // AkAudioEvent* (Size: 0x8)
MeleeImpactProperty.MeleeHitTargetResult = 0x0 // FHitResult (Size: 0x98)
MeleeImpactProperty.MeleeHitVector = 0x98 // FVector (Size: 0xc)
MeleeTraceConf.TraceDis = 0x0 // float (Size: 0x4)
MeleeTraceConf.TraceRotationAdjustment = 0x4 // FRotator (Size: 0xc)
MeshMaterialOverrideInfoForPlayMontage.Index = 0x0 // int32_t (Size: 0x4)
MeshMaterialOverrideInfoForPlayMontage.OverrideMaterial = 0x8 // MaterialInterface* (Size: 0x8)
MeshPaintAssetUserData.AlternativeMaterial = 0x28 // FAlternativeMaterialInfo (Size: 0xa0)
MeshSkinMaterialInfo.OwnerInventory = 0x0 // SGInventory* (Size: 0x8)
MeshSkinMaterialInfo.SkinMaterialList = 0x8 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
MinimalPlayerItemInfoBase.ItemId = 0x0 // uint64_t (Size: 0x8)
MinimalPlayerItemInfoBase.AttachPosition = 0x8 // EEAttachPosition (Size: 0x1)
MinimalPlayerItemInfoBase.ItemNum = 0xc // int32_t (Size: 0x4)
MinimalPlayerItemsInfo.WeaponAccessoryInfoList = 0x0 // TArray<FMinimalPlayerItemInfoBase> (Size: 0x10)
MinimalPlayerItemsInfo.EquipItemsInfoList = 0x10 // TArray<FMinimalPlayerItemInfoBase> (Size: 0x10)
MinimalPlayerItemsInfo.InventoryItemsInfoList = 0x20 // TArray<FMinimalPlayerItemInfoBase> (Size: 0x10)
MissionActorReference.RefStr = 0x0 // FName (Size: 0x8)
MissionActorReference.RefActor = 0x8 // Actor* (Size: 0x8)
MissionActorReference.RefLevelName = 0x10 // FName (Size: 0x8)
MissionActorReferenceButton.Placeholder = 0x0 // int32_t (Size: 0x4)
MissionFlowReplicateDataChangedEvent.ChangeType = 0x0 // EEMFMissionDataChangeType (Size: 0x1)
MissionFlowReplicateDataChangedEvent.ReplicateData = 0x8 // FMFMissionFlowReplicateData (Size: 0x20)
MissionFlowReplicateDataChangedEvent.MissionReplicateDataList = 0x28 // TArray<FMFMissionReplicateData> (Size: 0x10)
MissionObjectiveSpawnInventoryInfoItem.ContainerClass = 0x0 // ClassProperty (Size: 0x8)
MissionObjectiveSpawnInventoryInfoItem.ItemIDs = 0x8 // TArray<int64_t> (Size: 0x10)
MissionObjectiveSpawnInventoryInfoItem.Weight = 0x18 // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfoItem.ConfigID = 0x1c // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfoItem.LootPointType = 0x20 // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfoItem.RelatedTargetTypes = 0x28 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
MissionObjectiveSpawnInventoryInfoRow.Items = 0x8 // TArray<FMissionObjectiveSpawnInventoryInfoItem> (Size: 0x10)
MissionObjectiveSpawnInventoryInfoRow.Comment = 0x18 // FString (Size: 0x10)
MissionReplicateDataChangedEvent.ChangeType = 0x0 // EEMFMissionDataChangeType (Size: 0x1)
MissionReplicateDataChangedEvent.ReplicateData = 0x8 // FMFMissionReplicateData (Size: 0x58)
MissionReplicateDataChangedEvent.SharerCharacter = 0x60 // Character* (Size: 0x8)
MissionStatisData.DataMap = 0x0 // TMap<...> (Size: 0x50)
MobileInputData.FingerIndex = 0x0 // uint8_t (Size: 0x1)
MobileInputData.Phase = 0x1 // uint8_t (Size: 0x1)
MobileInputData.BeginLocation = 0x4 // FVector2D (Size: 0x8)
MobileInputData.Location = 0xc // FVector2D (Size: 0x8)
MobileInputData.LastLocation = 0x14 // FVector2D (Size: 0x8)
MobileInputData.LastFrameLocation = 0x1c // FVector2D (Size: 0x8)
MobileInputData.BeginTime = 0x24 // float (Size: 0x4)
MobileInputData.UpdateTime = 0x28 // float (Size: 0x4)
MobileInputData.ForceValue = 0x2c // float (Size: 0x4)
MobileInputData.DeltaLocation = 0x30 // FVector2D (Size: 0x8)
MobileInputData.DeltaLocationX = 0x38 // float (Size: 0x4)
MobileInputData.DeltaLocationY = 0x3c // float (Size: 0x4)
MobileInputData.SampleCount = 0x40 // int32_t (Size: 0x4)
MobileInputData.bIgnore = 0x44 // bool (Size: 0x1)
MobileInputData.bPendingDelete = 0x45 // bool (Size: 0x1)
ModeTableRowBase.MainModeID = 0x8 // int32_t (Size: 0x4)
ModeTableRowBase.SubModeID = 0xc // int32_t (Size: 0x4)
ModeTableRowBase.MapID = 0x10 // int32_t (Size: 0x4)
ModeTableRowBase.SpecialID = 0x14 // int32_t (Size: 0x4)
ModeTableRowBase.Difficulty = 0x18 // int32_t (Size: 0x4)
ModeThunderTimeInfo.ThunderTypeIndexWeightArray = 0x0 // TArray<int32_t> (Size: 0x10)
ModeThunderTimeInfo.MinPlayTime = 0x10 // float (Size: 0x4)
ModeThunderTimeInfo.MaxPlayTime = 0x14 // float (Size: 0x4)
MonitorToggleInputAfterThrow.ToggleSprint = 0x0 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleCrouch = 0x10 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleProne = 0x20 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleJump = 0x30 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleLean = 0x40 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleUseItem = 0x50 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputAfterThrow.ToggleAds = 0x60 // TArray<int32_t> (Size: 0x10)
MonitorToggleInputSimple.ToggleSprint = 0x0 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleCrouch = 0x10 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleProne = 0x20 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleJump = 0x30 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleLean = 0x40 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleUseItem = 0x50 // FString (Size: 0x10)
MonitorToggleInputSimple.ToggleAds = 0x60 // FString (Size: 0x10)
MontageTickCondition.bShouldTickPose = 0x0 // bool (Size: 0x1)
MontageTickCondition.bNoSkeletonUpdate = 0x1 // bool (Size: 0x1)
MontageTickCondition.AnimScriptInstanceName = 0x8 // FString (Size: 0x10)
MontageTickCondition.VisibilityBasedAnimTickOptionName = 0x18 // FString (Size: 0x10)
MorphDeltaInfo.PositionOffset = 0x0 // FVector (Size: 0xc)
MorphDeltaInfo.TangentZDelta = 0xc // FVector (Size: 0xc)
MorphTargetPositionOffsetInfo.BadgeIndex = 0x0 // int32_t (Size: 0x4)
MorphTargetPositionOffsetInfo.MorphTargetDeltaList = 0x8 // TMap<...> (Size: 0x50)
MotionWarpingNetSyncPoint.Name = 0x0 // FName (Size: 0x8)
MotionWarpingNetSyncPoint.SyncPoint = 0x10 // FMotionWarpingSyncPoint (Size: 0x20)
MovieCameraFocusPointParams.FocusActor = 0x0 // Actor* (Size: 0x8)
MovieCameraFocusPointParams.FocusBoneName = 0x8 // FName (Size: 0x8)
MovieCameraFocusPointParams.FocusWorldLoc = 0x10 // FVector (Size: 0xc)
MovieCameraFocusPointParams.CameraFOV = 0x1c // float (Size: 0x4)
MovieCameraFocusPointParams.InterpSpeedRange = 0x20 // FVector2D (Size: 0x8)
MovieCameraFocusPointParams.InFocusFOV = 0x28 // FVector2D (Size: 0x8)
MovieCameraFocusPointParams.bAlwaysFocus = 0x30 // bool (Size: 0x1)
MovieCameraFocusPointParams.bAdjustCamera = 0x31 // bool (Size: 0x1)
MovieCameraFocusPointParams.bIgnoreTrace = 0x32 // bool (Size: 0x1)
MovieCameraFocusPointParams.FocusPitchOffsetDeg = 0x34 // float (Size: 0x4)
MovieCameraParams.fFocusOffset = 0x0 // FVector (Size: 0xc)
MovieCameraParams.fFOVScale = 0xc // float (Size: 0x4)
MovieCameraParams.fYawScale = 0x10 // float (Size: 0x4)
MovieCameraParams.fPitchScale = 0x14 // float (Size: 0x4)
MovieCameraParams.fViewOffsetDistanceScale = 0x18 // float (Size: 0x4)
MovieCameraParams.fSurroundingSpeed = 0x1c // float (Size: 0x4)
MovieCameraParams.bSurroundingClockwise = 0x20 // bool (Size: 0x1)
MovieCameraParams.bFPPMode = 0x21 // bool (Size: 0x1)
MovieCameraParams.iCamera3PMode = 0x24 // int32_t (Size: 0x4)
MovieCameraParams.bManual = 0x28 // bool (Size: 0x1)
MovieCameraParams.OrbitingOffset = 0x2c // FVector (Size: 0xc)
MovieCameraParams.OrbitingViewRotation = 0x38 // FRotator (Size: 0xc)
MovieCameraParams.ManualMoveSpeedBias = 0x44 // float (Size: 0x4)
NPCFireBodyPartBoneNameMap.BoneName = 0x0 // FName (Size: 0x8)
NPCFireBodyPartBoneNameMap.bIsSocketBone = 0x8 // bool (Size: 0x1)
ObjReplicatorActorInfo.Comps = 0x0 // TArray<FObjReplicatorObjInfo> (Size: 0x10)
ObjReplicatorActorInfo.ClassName = 0x10 // FString (Size: 0x10)
ObjReplicatorActorInfo.Loc = 0x20 // FVector (Size: 0xc)
ObjReplicatorActorInfo.CullDist = 0x2c // int32_t (Size: 0x4)
ObjReplicatorGlobalInfo.Actors = 0x0 // TArray<FObjReplicatorActorInfo> (Size: 0x10)
ObjReplicatorGlobalInfo.TotalIlegalSize = 0x10 // int32_t (Size: 0x4)
ObjReplicatorGlobalInfo.TotalIlegalMax = 0x14 // int32_t (Size: 0x4)
ObjReplicatorGlobalInfo.TotalIlegalCount = 0x18 // int32_t (Size: 0x4)
ObjReplicatorObjInfo.Mem = 0x0 // int32_t (Size: 0x4)
ObjReplicatorObjInfo.MemMax = 0x4 // int32_t (Size: 0x4)
ObjReplicatorObjInfo.Count = 0x8 // int32_t (Size: 0x4)
ObjReplicatorObjInfo.ClassName = 0x10 // FString (Size: 0x10)
ObjReplicatorObjInfo.LastReplicateFrameNum = 0x20 // int32_t (Size: 0x4)
ObjReplicatorObjInfo.LastReplicateDirtyFrameNum = 0x24 // int32_t (Size: 0x4)
OneSeatData.SeatCharacter = 0x0 // SGCharacter* (Size: 0x8)
OscillatorInfo.ShakeAxis = 0x0 // EECameraShakeAxis (Size: 0x1)
OscillatorInfo.OscillatorSetting = 0x8 // FSineOscillator (Size: 0x40)
OverrideMaterialInfo.Index = 0x0 // int32_t (Size: 0x4)
OverrideMaterialInfo.OverrideMaterial = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
OwnedActivityInventoryInfo.Inventories = 0x0 // TArray<SGInventory*> (Size: 0x10)
OwnedActivityInventoryInfo.InventoryHandles = 0x10 // TArray<int32_t> (Size: 0x10)
OwnedActivityInventoryInfo.LastReportInventoryCount = 0x20 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientReconnectTimes = 0x0 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientMaxFps = 0x4 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientMinFps = 0x8 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientAverFps = 0xc // int32_t (Size: 0x4)
PCReportStatisInfo.ClientPingTimes = 0x10 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientPingLoseTimes = 0x14 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientPullTimes = 0x18 // int32_t (Size: 0x4)
PCReportStatisInfo.ClientPullDiffDistance = 0x1c // int32_t (Size: 0x4)
PCReportStatisInfo.ClientPullAvgPing = 0x20 // int32_t (Size: 0x4)
PMCAIProfileInfo.TitleInfo = 0x0 // FSGPlayerTitleInfo (Size: 0x1c)
PMCAIProfileInfo.HeadBoxID = 0x1c // int32_t (Size: 0x4)
PMCAIProfileInfo.HeadPicID = 0x20 // int32_t (Size: 0x4)
PMCAIProfileInfo.bIsReturnPlayer = 0x24 // bool (Size: 0x1)
PMCAIProfileInfo.NameCard = 0x28 // int32_t (Size: 0x4)
PMCAIProfileInfo.PrivilegeLevel = 0x2c // uint32_t (Size: 0x4)
PMCAIProfileInfo.NationalFlagIso = 0x30 // int32_t (Size: 0x4)
PMCAIProfileInfo.PictureFlag = 0x34 // uint32_t (Size: 0x4)
PMCAIProfileInfo.PlayerBannerInfo = 0x38 // FSGPlayerBannerInfo (Size: 0x28)
PPMaterialNotifyData.Time = 0x0 // float (Size: 0x4)
PPMaterialNotifyData.MaterialInstance = 0x4 // TWeakObjectPtr<UObject> (Size: 0x8)
PSCInfo.Template = 0x0 // ParticleSystem* (Size: 0x8)
ParticleVolumeActor.DynamicMaterial = 0x358 // MaterialInstanceDynamic* (Size: 0x8)
ParticleVolumeActor.DynamicMaterialFog = 0x360 // MaterialInstanceDynamic* (Size: 0x8)
ParticleVolumeActor.GridSize = 0x368 // float (Size: 0x4)
ParticleVolumeActor.MaxEffectPlayerDistance = 0x36c // float (Size: 0x4)
ParticleVolumeActor.FallBackSphereSize = 0x370 // float (Size: 0x4)
ParticleVolumeActor.OverrideSmokeMaterial = 0x378 // MaterialInterface* (Size: 0x8)
ParticleVolumeActor.OverrideSmokeFogMaterial = 0x380 // MaterialInterface* (Size: 0x8)
ParticleVolumeActor.StartPositionOffset = 0x388 // FVector (Size: 0xc)
ParticleVolumeActor.VolumeType = 0x394 // EEVolumeType (Size: 0x4)
ParticleVolumeActor.HalfExtent = 0x398 // FVector (Size: 0xc)
ParticleVolumeActor.Radius = 0x3a4 // float (Size: 0x4)
ParticleVolumeActor.InnerRadius = 0x3a8 // float (Size: 0x4)
ParticleVolumeActor.SmokeFadeStep = 0x3ac // float (Size: 0x4)
ParticleVolumeActor.SpawnTimeOffset = 0x3b0 // float (Size: 0x4)
ParticleVolumeActor.EffectTime = 0x3b4 // float (Size: 0x4)
ParticleVolumeActor.bGenerateOnServer = 0x3b8 // bool (Size: 0x1)
ParticleVolumeActor.GenerateTime = 0x3bc // float (Size: 0x4)
ParticleVolumeActor.OwnerProjectile = 0x510 // Actor* (Size: 0x8)
ParticleVolumeActor.ParticleMaskTexture = 0x630 // VolumeTexture* (Size: 0x8)
PasswordDoorMappingInfo.LetterNumber = 0x0 // int32_t (Size: 0x4)
PasswordDoorMappingInfo.Number = 0x4 // int32_t (Size: 0x4)
PendingAttachData.ChildComponent = 0x0 // SceneComponent* (Size: 0x8)
PendingAttachData.ParentComponent = 0x8 // SceneComponent* (Size: 0x8)
PendingLoadHUDClassInfo.Class = 0x18 // ClassProperty (Size: 0x8)
PendingSpawnAIDebugInfo.PendingIndex = 0x0 // int32_t (Size: 0x4)
PendingSpawnAIDebugInfo.AIID = 0x4 // FName (Size: 0x8)
PendingSpawnAIDebugInfo.SpawnArea = 0x10 // FString (Size: 0x10)
PendingSpawnAIDebugInfo.SpawnPoint = 0x20 // FString (Size: 0x10)
PendingSpawnAIDebugInfo.ContextString = 0x30 // FString (Size: 0x10)
PendingSpawnAIDebugInfo.bSpawned = 0x40 // bool (Size: 0x1)
PendingSpawnInfo.SpawnRecord = 0x10 // FSpawnRecord (Size: 0x80)
PendingSpawnInfo.bIsPMCAI = 0x90 // bool (Size: 0x1)
PendingSpawnInfo.DelayFrame = 0x9c // int32_t (Size: 0x4)
PendingSpawnInfo.AICharacterClass = 0xb8 // ClassProperty (Size: 0x8)
PendingSpawnInfo.AIControllerClass = 0xc0 // ClassProperty (Size: 0x8)
PendingSpawnInfo.ArchetypeTemplate = 0xc8 // BehaviorTree* (Size: 0x8)
PendingSpawnInfo.FactionClass = 0xd0 // ClassProperty (Size: 0x8)
PendingSpawnInfo.RoleClass = 0xd8 // ClassProperty (Size: 0x8)
PendingSpawnInfo.AvatarInventories = 0xf8 // TArray<ClassProperty> (Size: 0x10)
PendingSpawnInfo.EventAvatarInventories = 0x108 // TArray<ClassProperty> (Size: 0x10)
PendingSpawnInfo.AvatarIDs = 0x118 // TArray<int64_t> (Size: 0x10)
PendingSpawnInfo.EventAvatarIDs = 0x128 // TArray<int64_t> (Size: 0x10)
PendingSpawnInfo.SoundData = 0x138 // DataTable* (Size: 0x8)
PendingSpawnInfo.DeathBoxClass = 0x140 // ClassProperty (Size: 0x8)
PendingSpawnInfo.Gender = 0x150 // EECharacterSex (Size: 0x1)
PendingSpawnInfo.DefaultPickupInventories = 0x158 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
PenetrationAvoidanceFeeler.AdjustmentRot = 0x0 // FRotator (Size: 0xc)
PenetrationAvoidanceFeeler.WorldWeight = 0xc // float (Size: 0x4)
PenetrationAvoidanceFeeler.PawnWeight = 0x10 // float (Size: 0x4)
PenetrationAvoidanceFeeler.Extent = 0x14 // FVector (Size: 0xc)
PenetrationAvoidanceFeeler.TraceInterval = 0x20 // int32_t (Size: 0x4)
PenetrationAvoidanceFeeler.FramesUntilNextTrace = 0x24 // int32_t (Size: 0x4)
PlayAnimWithMeshMatOperateInfo.MatIndex = 0x0 // int32_t (Size: 0x4)
PlayAnimWithMeshMatOperateInfo.MatParamName = 0x4 // FName (Size: 0x8)
PlayAnimWithMeshMatOperateInfo.MatParamValue = 0xc // float (Size: 0x4)
PlayModeKeyDurationCostTableRow.SubModeID = 0x8 // int32_t (Size: 0x4)
PlayModeKeyDurationCostTableRow.SpecialID = 0xc // int32_t (Size: 0x4)
PlayModeKeyDurationCostTableRow.CostDuration = 0x10 // int32_t (Size: 0x4)
PlayerAuthInfo.GID = 0x0 // int64_t (Size: 0x8)
PlayerAuthInfo.Token = 0x8 // FString (Size: 0x10)
PlayerAuthInfo.Level = 0x18 // int32_t (Size: 0x4)
PlayerFallReportData.KillerPlayerName = 0x0 // FString (Size: 0x10)
PlayerFallReportData.KillerPlayerGid = 0x10 // int64_t (Size: 0x8)
PlayerFallReportData.KillerPlayerFaction = 0x18 // EEFactionType (Size: 0x1)
PlayerFallReportData.KillerPlayerWeaponID = 0x20 // uint64_t (Size: 0x8)
PlayerFallReportData.ContinuousKillNum = 0x28 // int32_t (Size: 0x4)
PlayerFallReportData.KilledPlayerName = 0x30 // FString (Size: 0x10)
PlayerFallReportData.KilledPlayerGid = 0x40 // int64_t (Size: 0x8)
PlayerFallReportData.KilledPlayerFaction = 0x48 // EEFactionType (Size: 0x1)
PlayerFallReportData.KilledCharacterType = 0x49 // EECharacterType (Size: 0x1)
PlayerFallReportData.FallResult = 0x4a // EESGPlayerFailResult (Size: 0x1)
PlayerFallReportData.ReportCreateTime = 0x4c // float (Size: 0x4)
PlayerFallReportData.EnduranceType = 0x50 // EECharacterEnduranceType (Size: 0x1)
PlayerFightInfo.LastTimeFightAgainstOtherPlayer = 0x0 // float (Size: 0x4)
PlayerFightInfo.LastLocationFightAgainstOtherPlayer = 0x4 // FVector (Size: 0xc)
PlayerFightInfo.KilledAIs = 0x10 // TArray<FPlayerFightInfo_KilledAIInfo> (Size: 0x10)
PlayerFightInfo_KilledAIInfo.AIID = 0x0 // int64_t (Size: 0x8)
PlayerFightInfo_KilledAIInfo.PGID = 0x8 // int64_t (Size: 0x8)
PlayerFightInfo_KilledAIInfo.Time = 0x10 // float (Size: 0x4)
PlayerFightInfo_KilledAIInfo.AILocation = 0x14 // FVector (Size: 0xc)
PlayerFightInfo_KilledAIInfo.PlayerLocation = 0x20 // FVector (Size: 0xc)
PlayerInvDetectConfig.CurDetectTargetType = 0x0 // EEDetectTargetType (Size: 0x1)
PlayerInvDetectConfig.DetectingWatchItemID = 0x4 // int32_t (Size: 0x4)
PlayerInvDetectConfig.DetectingInvItemIDSet = 0x8 // TSet<...> (Size: 0x50)
PlayerInvDetectConfig.DetectingContainerLootTypeSet = 0x58 // TSet<...> (Size: 0x50)
PlayerInvDetectConfig.InvDetectRadius = 0xa8 // float (Size: 0x4)
PlayerInvDetectConfig.MaxDetectInvNum = 0xac // int32_t (Size: 0x4)
PlayerInvDetectConfig.InvDetectInterval = 0xb0 // float (Size: 0x4)
PlayerInvDetectConfig.bFindByAICharacter = 0xb4 // bool (Size: 0x1)
PlayerInvDetectConfig.ActivityIDs = 0xb8 // TArray<int32_t> (Size: 0x10)
PlayerInvDetectInfo.PlayerDetectedInvPosList = 0x0 // TArray<FVector> (Size: 0x10)
PlayerInvDetectInfo.IsInvDetecting = 0x10 // bool (Size: 0x1)
PlayerSkinInfo.PlayerGid = 0x0 // int64_t (Size: 0x8)
PlayerSkinInfo.ItemId = 0x8 // int32_t (Size: 0x4)
PlayerSkinInfo.SkinID = 0xc // int32_t (Size: 0x4)
PlayerStartGroup.GroupIndex = 0x0 // int32_t (Size: 0x4)
PlayerStartGroup.PlayerStarts = 0x8 // TArray<Actor*> (Size: 0x10)
PlayerStatisData.JoinInFaction = 0x0 // uint32_t (Size: 0x4)
PlayerStatusInfo.PlayerGid = 0x0 // uint64_t (Size: 0x8)
PlayerStatusInfo.StatusValue = 0x8 // int32_t (Size: 0x4)
PlayerTags.Tags = 0x0 // TSet<...> (Size: 0x50)
PointDamageEventObject.Damage = 0x30 // float (Size: 0x4)
PointDamageEventObject.ShotDirection = 0x34 // FVector_NetQuantizeNormal (Size: 0xc)
PointDamageEventObject.HitInfo = 0x40 // FHitResult (Size: 0x98)
PoolActorInfo.PoolActorClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
PoolActorInfo.MaxPoolCount = 0x28 // int32_t (Size: 0x4)
PoolActorInfo.CurrPoolCount = 0x2c // int32_t (Size: 0x4)
PoolActorInfo.Priority = 0x30 // int32_t (Size: 0x4)
PoolActorInfo.LimitFlag = 0x34 // int32_t (Size: 0x4)
PoolInventoryInfo.MaxPoolCount = 0x0 // int32_t (Size: 0x4)
PoolInventoryInfo.CurrPoolCount = 0x4 // int32_t (Size: 0x4)
PoolInventoryInfo.Priority = 0x8 // int32_t (Size: 0x4)
PoolInventoryInfo.bIsUsing = 0xc // bool (Size: 0x1)
PoolInventoryInfo.LimitFlag = 0x10 // int32_t (Size: 0x4)
PooledImpactEffectBind.PhysicalMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
PooledImpactEffectBind.EffectResouce = 0x8 // FPooledImpactEffectResource (Size: 0xe0)
PooledImpactEffectBind.EffectResouce_3P = 0xe8 // FPooledImpactEffectResource (Size: 0xe0)
PooledImpactEffectBind.MeleeEffectResource = 0x1c8 // FPooledImpactEffectResource (Size: 0xe0)
PooledImpactEffectBind.MeleeEffectResource_3P = 0x2a8 // FPooledImpactEffectResource (Size: 0xe0)
PooledImpactEffectResource.ParticleTemplate = 0x0 // FXSystemAsset* (Size: 0x8)
PooledImpactEffectResource.ParticleTemplate_SaaS = 0x8 // FXSystemAsset* (Size: 0x8)
PooledImpactEffectResource.ParticleNegagiveTemplate = 0x10 // ParticleSystem* (Size: 0x8)
PooledImpactEffectResource.AudioEvent = 0x18 // AkAudioEvent* (Size: 0x8)
PooledImpactEffectResource.MeleeAudioEvent = 0x20 // FMeleeAudioEvent (Size: 0x10)
PooledImpactEffectResource.StaticMeshTemplate = 0x30 // StaticMesh* (Size: 0x8)
PooledImpactEffectResource.NegagiveStaticMeshTemplate = 0x38 // StaticMesh* (Size: 0x8)
PooledImpactEffectResource.DecalOverridenMaterial = 0x40 // MaterialInterface* (Size: 0x8)
PooledImpactEffectResource.NegagiveDecalOverridenMaterial = 0x48 // MaterialInterface* (Size: 0x8)
PooledImpactEffectResource.DecalResource = 0x50 // FDecalImpactEffectResource (Size: 0x60)
PooledImpactEffectResource.DecalScale = 0xb0 // FVector (Size: 0xc)
PooledImpactEffectResource.ScaleCurveByDistance = 0xc0 // CurveFloat* (Size: 0x8)
PooledImpactEffectResource.ScaleCurveByFOV = 0xc8 // CurveFloat* (Size: 0x8)
PooledImpactEffectResource.LifeSpan = 0xdc // float (Size: 0x4)
PoseTransition.FromPose = 0x0 // EEAIPose (Size: 0x1)
PoseTransition.ToPose = 0x1 // EEAIPose (Size: 0x1)
PoseTransition.TransitionState = 0x2 // EEAnimTransitionState (Size: 0x1)
PoseTransition.bForceStopMovement = 0x3 // bool (Size: 0x1)
PreOccupiedContainerList.ContainerInvList = 0x0 // TArray<SGInventory*> (Size: 0x10)
PredictDurabilityInfo.DurabilityValue = 0x0 // float (Size: 0x4)
PredictDurabilityInfo.DamageCauser = 0x8 // Actor* (Size: 0x8)
PreloadActorSubsystem.ObjPoolMap = 0x30 // TMap<...> (Size: 0x50)
PreloadActorSubsystem.FailedMap = 0x80 // TMap<...> (Size: 0x50)
PreloadObjectPool.ObjPool = 0x0 // TArray<Object*> (Size: 0x10)
PreviewAdapterInfo.X = 0x0 // int32_t (Size: 0x4)
PreviewAdapterInfo.Y = 0x8 // FString (Size: 0x10)
ProgressAbilitySimulationInfo.Type = 0x0 // EESGSimulatedProgressAbilityType (Size: 0x1)
ProgressAbilitySimulationInfo.TargetInv = 0x8 // SGInventory* (Size: 0x8)
ProgressAbilitySimulationInfo.OptionalActor1 = 0x10 // Actor* (Size: 0x8)
ProgressAbilitySimulationInfo.ProgressStartServerTimeStamp = 0x18 // float (Size: 0x4)
ProgressAbilitySimulationInfo.Duration = 0x1c // float (Size: 0x4)
ProgressAbilitySimulationInfo.Magnitude = 0x20 // float (Size: 0x4)
ProjectileHitInfo.MinDamage = 0x0 // float (Size: 0x4)
ProjectileHitInfo.MaxDamage = 0x4 // float (Size: 0x4)
ProjectileHitInfo.DamageRange = 0x8 // float (Size: 0x4)
ProjectileHitInfo.Momentum = 0xc // float (Size: 0x4)
ProtectCacheComponent.HiddenComponent = 0x0 // ActorComponent* (Size: 0x8)
ProtectCacheComponent.bCastShadow = 0x8 // bool (Size: 0x1)
ProtectCacheComponent.bHiddenInGame = 0x9 // bool (Size: 0x1)
ProtectCacheComponent.bVisible = 0xa // bool (Size: 0x1)
PushMagazineAbilityInfo.FillingBulletID = 0x0 // int64_t (Size: 0x8)
PushMagazineAbilityInfo.FillingMagazineID = 0x8 // int64_t (Size: 0x8)
PushMagazineAbilityInfo.BulletsInMagazine = 0x10 // TArray<int64_t> (Size: 0x10)
PushMagazineAbilityInfo.DepProvider = 0x20 // FRepDependency (Size: 0x18)
RPCS_ClientAddToCharacter.bAutoActivateInput = 0x0 // bool (Size: 0x1)
RPCS_ClientAddToCharacter.ReplicateIndex = 0x4 // int32_t (Size: 0x4)
RPCS_ClientRemoved.ReplicateIndex = 0x0 // int32_t (Size: 0x4)
RadialDamageEventObject.Params = 0x30 // FRadialDamageParams (Size: 0x14)
RadialDamageEventObject.Origin = 0x44 // FVector (Size: 0xc)
RadialDamageEventObject.ComponentHits = 0x50 // TArray<FHitResult> (Size: 0x10)
RandomAreaPointStructData.Radius = 0x0 // int32_t (Size: 0x4)
RandomAreaPointStructData.EdgeDistanceInterval = 0x4 // int32_t (Size: 0x4)
RandomAreaPointStructData.MaxInvalidRatio = 0x8 // int32_t (Size: 0x4)
RandomAreaPointStructData.ExternalCurve = 0x10 // CurveFloat* (Size: 0x8)
RandomAreaPointStructData.SamplingPrecision = 0x18 // int32_t (Size: 0x4)
RandomAreaPointStructData.AreaCenterWorldLocationPos = 0x1c // FVector (Size: 0xc)
RandomAreaPointStructData.ShowDelayTime = 0x28 // float (Size: 0x4)
RandomAreaPointStructData.ShowWaitTime = 0x2c // float (Size: 0x4)
RandomAreaPointStructData.ShowMoveTime = 0x30 // float (Size: 0x4)
RandomAreaPointStructData.DPS = 0x34 // float (Size: 0x4)
RandomAreaPointStructData.DBNO_DPS = 0x38 // float (Size: 0x4)
RandomAreaPointStructData.PointIsInNavigationExtern = 0x3c // FVector (Size: 0xc)
RandomAreaPointStructData.ArrayIndex = 0x48 // int32_t (Size: 0x4)
RandomDyingCurveSet.CloseEyeCurve = 0x0 // CurveFloat* (Size: 0x8)
RandomDyingCurveSet.DesaturationCurve = 0x8 // CurveFloat* (Size: 0x8)
RandomDyingCurveSet.LightIntensityCurve = 0x10 // CurveFloat* (Size: 0x8)
RandomNumberGenerationParam.FlipSideChance = 0x0 // float (Size: 0x4)
RandomNumberGenerationParam.Seed2DistributionMap = 0x8 // CurveFloat* (Size: 0x8)
RealDamageOnBodyPartForTlog.BodyPart = 0x0 // int32_t (Size: 0x4)
RealDamageOnBodyPartForTlog.RealDamage = 0x4 // float (Size: 0x4)
RealDamageOnBodyPartForTlog.ExtraFlag = 0x8 // int32_t (Size: 0x4)
RealDamageOnBodyPartForTlog.TakerTeamType = 0xc // uint8_t (Size: 0x1)
RealDamageOnBodyPartForTlog.CauserTeamType = 0xd // uint8_t (Size: 0x1)
RealDamageOnBodyPartForTlog.BulletID = 0x10 // uint32_t (Size: 0x4)
RealDamageOnBodyPartForTlog.DamageCauserType = 0x14 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.CauserId = 0x0 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.TakerId = 0x8 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.CauserTeamId = 0x10 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.TeamID = 0x14 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.CauserTeamType = 0x18 // uint8_t (Size: 0x1)
RealDamageOnBodyPartStruct.TakerTeamType = 0x19 // uint8_t (Size: 0x1)
RealDamageOnBodyPartStruct.DamageTime = 0x20 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.AttackDamage = 0x28 // float (Size: 0x4)
RealDamageOnBodyPartStruct.RealDamage = 0x2c // float (Size: 0x4)
RealDamageOnBodyPartStruct.FireCounter = 0x30 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.BodyPart = 0x38 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.DetailBodyPart = 0x3c // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.DamageCauserID = 0x40 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.DamagePosition = 0x48 // FVector (Size: 0xc)
RealDamageOnBodyPartStruct.DamagedPosition = 0x54 // FVector (Size: 0xc)
RealDamageOnBodyPartStruct.DamageDistance = 0x60 // float (Size: 0x4)
RealDamageOnBodyPartStruct.DamageCauserType = 0x64 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.DamageTypeEnum = 0x68 // uint8_t (Size: 0x1)
RealDamageOnBodyPartStruct.BulletID = 0x70 // int64_t (Size: 0x8)
RealDamageOnBodyPartStruct.bPenetrateArmor = 0x78 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.PenetrateArmorProbability = 0x7c // float (Size: 0x4)
RealDamageOnBodyPartStruct.ExtraFlag = 0x80 // int32_t (Size: 0x4)
RealDamageOnBodyPartStruct.CauserName = 0x88 // FString (Size: 0x10)
RealDamageOnBodyPartStruct.CauseArmorReduceDamage = 0x98 // float (Size: 0x4)
RealDamageOnBodyPartStruct.bFromHitThroughBody = 0x9c // bool (Size: 0x1)
RelightingPortalData.Transfrom = 0x0 // FTransform (Size: 0x30)
RepCustomizeAnimation.InCustomizeMontageName = 0x0 // FString (Size: 0x10)
RepCustomizeAnimation.InCustomizeMontageSectionName = 0x10 // FName (Size: 0x8)
RepCustomizeAnimation.bReplayWhileIsPlaying = 0x18 // bool (Size: 0x1)
RepCustomizeAnimation.bPlayFlag = 0x19 // uint8_t (Size: 0x1)
RepDependency.Version = 0x0 // uint32_t (Size: 0x4)
RepDependency.DepName = 0x4 // FName (Size: 0x8)
RepDependency.Info = 0xc // FRepDependencyOptionalInfo (Size: 0xc)
RepDependencyOptionalInfo.Value = 0x0 // int32_t (Size: 0x4)
RepDependencyOptionalInfo.Tag = 0x4 // FGameplayTag (Size: 0x8)
RepInfo.GridNodes = 0x0 // TArray<FVectorAndDist> (Size: 0x10)
RepInfo.MinCoord = 0x10 // FIntVector (Size: 0xc)
RepInfo.MaxCoord = 0x1c // FIntVector (Size: 0xc)
RepInfo.InMaxDistanceColor = 0x28 // float (Size: 0x4)
RepTakeHitInfo.TakeHitInfo = 0x0 // FTakeHitInfo (Size: 0x60)
RepTakeHitInfo.TakeHitResult = 0x60 // FHitResult (Size: 0x98)
RepTurnInPlaceAnimMontage.AnimMontage = 0x0 // AnimMontage* (Size: 0x8)
RepTurnInPlaceAnimMontage.ForcePlayBit = 0x8 // uint8_t (Size: 0x1)
ReplicationVaultInfo.bIsVaulting = 0x0 // bool (Size: 0x1)
ReplicationVaultInfo.PackedMovementMode = 0x1 // uint8_t (Size: 0x1)
ReplicationVaultInfo.VaultVersion = 0x4 // int32_t (Size: 0x4)
ReplicationVaultInfo.CharacterForwardDiretion = 0x8 // FVector_NetQuantize100 (Size: 0xc)
ReplicationVaultInfo.PathNodes = 0x18 // TArray<FRepPathNode> (Size: 0x10)
ReplicationVaultInfo.VaultAnimation = 0x28 // FSoftObjectPath (Size: 0x18)
RewardItemConfig.ItemId = 0x0 // int64_t (Size: 0x8)
RewardItemConfig.Weight = 0x8 // float (Size: 0x4)
RicochetConfig_HD.MinIncidenceAngle = 0x0 // float (Size: 0x4)
RicochetConfig_HD.ProbabilityRange = 0x4 // FVector2D (Size: 0x8)
RoomSettleSiteInfo.svr_id = 0x0 // uint64_t (Size: 0x8)
RoomSettleSiteInfo.cmd_begin = 0x8 // uint32_t (Size: 0x4)
RoomSettleSiteInfo.cmd_over = 0xc // uint32_t (Size: 0x4)
RoomSettleSiteInfo.room_id = 0x10 // uint32_t (Size: 0x4)
RoomSettleSiteInfo.room_type = 0x14 // uint32_t (Size: 0x4)
RoomSettleSiteInfo.team_id = 0x18 // uint32_t (Size: 0x4)
RoomSettleSiteInfo.GID = 0x20 // uint64_t (Size: 0x8)
RoomSettleSiteInfo.ZoneId = 0x28 // uint32_t (Size: 0x4)
RotorcraftMovementComponent.RotorSetups = 0x180 // TArray<FAircraftRotorSetup> (Size: 0x10)
RoundStateInfo.CurrState = 0x0 // EEUAPlayerRoundState (Size: 0x1)
RoundStateInfo.CurrRound = 0x4 // int32_t (Size: 0x4)
RoundStateInfo.LastRoundReulst = 0x8 // EEUAPlayerRoundReulst (Size: 0x1)
RoundStateInfo.bSwitchSides = 0x9 // bool (Size: 0x1)
RoundStateInfo.bEnding = 0xa // bool (Size: 0x1)
SG1PRelaxAnimationSet.RelaxAnimationMapByType = 0x0 // TMap<...> (Size: 0x50)
SG1PRelaxAnimationSet.DefaultRelaxAnimation = 0x50 // TArray<AnimSequence*> (Size: 0x10)
SG1PRelaxAnimationSetByGrip.GripRelaxAnimationMap = 0x0 // TMap<...> (Size: 0x50)
SG1PRelaxAnimationSetByGrip.DefaultRelaxAnimation = 0x50 // TArray<AnimSequence*> (Size: 0x10)
SGAIAreaVolume.ParentVolume = 0x3a0 // SGAIVolume* (Size: 0x8)
SGAIAvatarInventories.AvatarInventoryID = 0x0 // TArray<int64_t> (Size: 0x10)
SGAIBTService_CalcHealthPercentage.HeadEnduranceNow = 0x98 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.ChestEnduranceNow = 0x9c // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.StomachEnduranceNow = 0xa0 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.LArmEnduranceNow = 0xa4 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.RArmEnduranceNow = 0xa8 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.LLegEnduranceNow = 0xac // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.RLegEnduranceNow = 0xb0 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.TotalEnduranceNow = 0xb4 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.StomachEnduranceLast = 0xb8 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.LArmEnduranceLast = 0xbc // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.RArmEnduranceLast = 0xc0 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.LLegEnduranceLast = 0xc4 // float (Size: 0x4)
SGAIBTService_CalcHealthPercentage.RLegEnduranceLast = 0xc8 // float (Size: 0x4)
SGAIBTTask_FastThrowProjectile.ProjectileID = 0xb0 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_FastThrowProjectile.ProjectileInitSpeed = 0xd8 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_FastThrowProjectile.TargetLocation = 0x100 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_FastThrowProjectile.ClassWeaponMissile = 0x128 // ClassProperty (Size: 0x8)
SGAIBTTask_FastThrowProjectile.bMustThrow = 0x130 // bool (Size: 0x1)
SGAIBTTask_FastThrowProjectile.bHigherFirst = 0x131 // bool (Size: 0x1)
SGAIBTTask_FastThrowProjectile.AICharacter = 0x158 // SGAICharacter* (Size: 0x8)
SGAIBTTask_FastThrowProjectile.OriginalWeapon = 0x160 // SGInventory* (Size: 0x8)
SGAIBTTask_FastThrowProjectile.ProjectileWeapon = 0x168 // SGInventory* (Size: 0x8)
SGAIBTTask_FastThrowProjectile.WeaponManagerComponent = 0x170 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGAIBTTask_FillBullets.ReplacedMagazine = 0xb8 // SGInventory* (Size: 0x8)
SGAIBTTask_FillBullets.WeaponProperty = 0xc0 // NPCAIPropertyComponent_Weapon* (Size: 0x8)
SGAIBTTask_ThrowProjectile.ProjectileID = 0xb0 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_ThrowProjectile.ProjectileInitSpeed = 0xd8 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_ThrowProjectile.TargetLocation = 0x100 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_ThrowProjectile.NavModifier = 0x128 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_ThrowProjectile.bUseFastThrow = 0x150 // bool (Size: 0x1)
SGAIBTTask_ThrowProjectile.bMustThrow = 0x151 // bool (Size: 0x1)
SGAIBTTask_ThrowProjectile.bMaybeHolding = 0x152 // bool (Size: 0x1)
SGAIBTTask_ThrowProjectile.bHigherFirst = 0x154 // bool (Size: 0x1)
SGAIBTTask_ThrowProjectile.bEmplaceTypeExploder = 0x155 // bool (Size: 0x1)
SGAIBTTask_ThrowProjectile.AICharacter = 0x180 // SGAICharacter* (Size: 0x8)
SGAIBTTask_ThrowProjectile.OriginalWeapon = 0x188 // SGInventory* (Size: 0x8)
SGAIBTTask_ThrowProjectile.GivenInventory = 0x190 // SGInventory* (Size: 0x8)
SGAIBTTask_ThrowProjectile.ProjectileWeapon = 0x198 // SGInventory* (Size: 0x8)
SGAIBTTask_ThrowProjectile.WeaponManagerComponent = 0x1a0 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGAIBTTask_ThrowProjectile.NavModifierActor = 0x1a8 // NPCAINavModifierVolume* (Size: 0x8)
SGAIBTTask_UseInventory.InventoryID = 0xb0 // FBlackboardKeySelector (Size: 0x28)
SGAIBTTask_UseInventory.bFullRecovery = 0xd8 // bool (Size: 0x1)
SGAIBTTask_UseInventory.AICharacter = 0xf0 // SGAICharacter* (Size: 0x8)
SGAIBTTask_UseInventory.RecoveryInventory = 0xf8 // SGInventory* (Size: 0x8)
SGAIBattleVolume.bShouldSaveNavSkeletonPointsInVolume = 0x3e0 // bool (Size: 0x1)
SGAIBattleVolume.bUseAreaVolumes = 0x3e1 // bool (Size: 0x1)
SGAIBattleVolume.OverriddenVisiblityMaxRangeInVolume = 0x3e4 // float (Size: 0x4)
SGAIBattleVolume.AreaVolumes = 0x3e8 // TArray<TScriptInterface<IInterface>> (Size: 0x10)
SGAIBattleVolume.NavSkeletonPointIDs = 0x3f8 // TArray<int32_t> (Size: 0x10)
SGAIBotZoneVolume.bTriggerSpawnVolume = 0x398 // bool (Size: 0x1)
SGAICampPerformances.AIPerformances = 0x0 // TMap<...> (Size: 0x50)
SGAICharacter.RankData = 0x1b30 // FAIRankData (Size: 0xc)
SGAICharacter.PatrolRadius = 0x1b3c // float (Size: 0x4)
SGAICharacter.CautionRadius = 0x1b40 // float (Size: 0x4)
SGAICharacter.CrossFireRadius = 0x1b44 // float (Size: 0x4)
SGAICharacter.Kill_PMCAI_Count = 0x1b48 // int32_t (Size: 0x4)
SGAICharacter.Kill_ScavAI_Count = 0x1b4c // int32_t (Size: 0x4)
SGAICharacter.Kill_PMCPlayer_Count = 0x1b50 // int32_t (Size: 0x4)
SGAICharacter.Kill_ScavPlayer_Count = 0x1b54 // int32_t (Size: 0x4)
SGAICharacter.loot_count = 0x1b58 // int32_t (Size: 0x4)
SGAICharacter.SpawnedGroupID = 0x1b5c // FName (Size: 0x8)
SGAICharacter.EquipmentPoolID = 0x1b64 // int32_t (Size: 0x4)
SGAICharacter.AIID = 0x1b68 // int64_t (Size: 0x8)
SGAICharacter.AIUID = 0x1b70 // int64_t (Size: 0x8)
SGAICharacter.PathGroupID = 0x1b78 // int64_t (Size: 0x8)
SGAICharacter.AILevel = 0x1b80 // int32_t (Size: 0x4)
SGAICharacter.BattleVolumesIn = 0x1b88 // TArray<int32_t> (Size: 0x10)
SGAICharacter.GrenadeThrowAngle = 0x1b98 // float (Size: 0x4)
SGAICharacter.GrenadeInitSpeed = 0x1b9c // float (Size: 0x4)
SGAICharacter.GrenadeFlyingTime = 0x1ba0 // float (Size: 0x4)
SGAICharacter.GrenadeHoldedTime = 0x1ba4 // float (Size: 0x4)
SGAICharacter.GrenadeNavModifier = 0x1ba8 // NPCAINavModifierVolume* (Size: 0x8)
SGAICharacter.LastBattleEnterTime = 0x1bb0 // float (Size: 0x4)
SGAICharacter.OnAICharacterReady = 0x1bb8 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnAICharacterGoalEnemyDied = 0x1bc8 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnPathSegmentBecomeDanger = 0x1bd8 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnAIAimingStartOneRound = 0x1be8 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnAIFireStartOneRound = 0x1bf8 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnAIFireStopOneRound = 0x1c08 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.OnAIExitRLModeEvt = 0x1c18 // FMulticastInlineDelegate (Size: 0x10)
SGAICharacter.SoundData = 0x1c28 // DataTable* (Size: 0x8)
SGAICharacter.bActive = 0x1c30 // bool (Size: 0x1)
SGAICharacter.bInDSLODControlled = 0x1c31 // bool (Size: 0x1)
SGAICharacter.IsSafeKeeper = 0x1c32 // bool (Size: 0x1)
SGAICharacter.DeathNetCullDistanceSquared = 0x1c3c // float (Size: 0x4)
SGAICharacter.EQSDataInstances = 0x1c40 // TMap<...> (Size: 0x50)
SGAICharacter.bAIReady = 0x1c90 // bool (Size: 0x1)
SGAICharacter.bCanStartAI = 0x1c91 // bool (Size: 0x1)
SGAICharacter.AIName = 0x1c98 // FString (Size: 0x10)
SGAICharacter.AIAvatarUrl = 0x1ca8 // FString (Size: 0x10)
SGAICharacter.Handle = 0x1cbc // int32_t (Size: 0x4)
SGAICharacter.MySpawnRecord = 0x1cc0 // FSpawnRecord (Size: 0x80)
SGAICharacter.AIStaticsComponent = 0x1d40 // SGCharacterAIStaticsComponent* (Size: 0x8)
SGAICharacter.TempCloseTickComps = 0x1d48 // TSet<...> (Size: 0x50)
SGAICharacter.bNeedShowTeammateInfo = 0x1d98 // bool (Size: 0x1)
SGAICharacter.AimingComponent = 0x1da0 // SGCharacterAIAimingComponent* (Size: 0x8)
SGAICharacter.AIProfileInfo = 0x1da8 // FPMCAIProfileInfo (Size: 0x60)
SGAIController.BehaviorTreeTemplate = 0x428 // BehaviorTree* (Size: 0x8)
SGAIController.BehaviorTreeComp = 0x430 // BehaviorTreeComponent* (Size: 0x8)
SGAIController.OnProcessPawn = 0x438 // FMulticastInlineDelegate (Size: 0x10)
SGAIController.AIPropComponents = 0x448 // TArray<NPCAIPropertyComponent*> (Size: 0x10)
SGAIController.AIPropClassMap = 0x458 // TMap<...> (Size: 0x50)
SGAIController.MemoryComponent = 0x4a8 // NPCAIMemorySystemComponent* (Size: 0x8)
SGAIController.MultiTargetComponent = 0x4b0 // NPCAIMultiTargetSelectorComponent* (Size: 0x8)
SGAIController.AIRecoilComponent = 0x4b8 // SGCharacterAIRecoilComponent* (Size: 0x8)
SGAIController.AIMoverComponent = 0x4c0 // NPCAIMoverSystemComponent* (Size: 0x8)
SGAIController.AIGlobalComponent = 0x4c8 // SGAIGlobalManagerComponent* (Size: 0x8)
SGAIController.AIAimingComponent = 0x4d0 // SGCharacterAIAimingComponent* (Size: 0x8)
SGAIController.LastControlRotation = 0x4d8 // FRotator (Size: 0xc)
SGAIController.bControlInterpCompleted = 0x4f0 // bool (Size: 0x1)
SGAIController.bInitAIPropClassMapCompleted = 0x4f1 // bool (Size: 0x1)
SGAIController.RotationInterval = 0x4f4 // float (Size: 0x4)
SGAIController.DontVaultNavigationFilterClass = 0x4f8 // ClassProperty (Size: 0x8)
SGAIController.RotationIntervalCache = 0x500 // float (Size: 0x4)
SGAIController.UpdatingRotation = 0x504 // bool (Size: 0x1)
SGAIController.FocalPointPredictionTime = 0x508 // float (Size: 0x4)
SGAIDebugInfoDisplayComponent.AIDebugEvents_LockOnAI = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGAIDebugInfoDisplayComponent.AIDebugEvents_UpdateLockAIData = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGAIDebugInfoDisplayComponent.bToggleAIDebugDraw = 0x121 // bool (Size: 0x1)
SGAIDebugInfoDisplayComponent.ConcernedBlackboardKeys_SimpleInfo = 0x128 // TArray<FName> (Size: 0x10)
SGAIDebugInfoDisplayComponent.ConcernedBlackboardKeys = 0x138 // TArray<FName> (Size: 0x10)
SGAIDebugInfoDisplayComponent.DebugAIInfoList = 0x158 // FDebugInfoForMapRadar (Size: 0x20)
SGAIDebugInfoDisplayComponent.AICharacterList = 0x178 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGAIDebugInfoDisplayComponent.AIDebugInfoDetailList = 0x188 // TArray<FAIDebugInfoDetail> (Size: 0x10)
SGAIDebugInfoDisplayComponent.SpawnManager = 0x1a0 // SGAISpawnManagerComponent* (Size: 0x8)
SGAIDebugInfoDisplayComponent.bIsAIDirectorEnabled = 0x1bc // uint8_t (Size: 0x1)
SGAIDebugInfoDisplayComponent.bToggleAIDirectorDebugInfo = 0x1bc // uint8_t (Size: 0x1)
SGAIDebugInfoDisplayComponent.MaxDisplayedInfoCount = 0x1c0 // int32_t (Size: 0x4)
SGAIDebugInfoDisplayComponent.LockAIData = 0x1c8 // FLockAIData (Size: 0x20)
SGAIDebugInfoDisplayComponent.TrackAIRoute = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
SGAIDebugInfoDisplayComponent.MarkAITrackKey = 0x200 // FInputChord (Size: 0x20)
SGAIDebugInfoDisplayComponent.SwitchAIInfoModeKey = 0x220 // FInputChord (Size: 0x20)
SGAIDebugInfoDisplayComponent.ToggleAIDetailedInfoKey = 0x240 // FInputChord (Size: 0x20)
SGAIDebugInfoDisplayComponent.ToggleAIInfoMainMenuKey = 0x260 // FInputChord (Size: 0x20)
SGAIDebugInfoDisplayComponent.AITrackLogList = 0x280 // TArray<SGAICharacter*> (Size: 0x10)
SGAIDebugInfoDisplayComponent.ToClientTrackType = 0x290 // TArray<EEAITrackLOGType> (Size: 0x10)
SGAIDebugInfoHUDWidget.VPawn = 0x2f0 // Actor* (Size: 0x8)
SGAIDebugInfoTextColor.BTNameSuffix = 0x0 // FString (Size: 0x10)
SGAIDebugInfoTextColor.DisplayColor = 0x10 // FColor (Size: 0x4)
SGAIEquipInfo.Items = 0x28 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGAIEquipInfo.RandomNpcName = 0x38 // FString (Size: 0x10)
SGAIEquipInfo.NpcSex = 0x48 // EECharacterSex (Size: 0x1)
SGAIEquipInfo.AvatarItemIds = 0x50 // TArray<uint64_t> (Size: 0x10)
SGAIEquipInfo.DropItems = 0x68 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGAIEquipmentPool.Equipments = 0x48 // TArray<SGAIEquipInfo*> (Size: 0x10)
SGAIEquipmentSettings.PullCountLimitationAtOpening = 0x0 // int32_t (Size: 0x4)
SGAIEquipmentSettings.PullCountLimitation = 0x4 // int32_t (Size: 0x4)
SGAIEquipmentSettings.PoolEquipmentCountLimitation = 0x8 // int32_t (Size: 0x4)
SGAIEquipmentSettings.EquipmentUsageCheckInterval = 0xc // float (Size: 0x4)
SGAIEquipmentSettings.PoolUsageWarningLine = 0x10 // float (Size: 0x4)
SGAIEquipmentSettings.PoolCapacityGrowthScale = 0x14 // float (Size: 0x4)
SGAIEquipmentSubsystem.EquipmentPools = 0x100 // TMap<...> (Size: 0x50)
SGAIEventAvatarTableRow.eventId = 0x8 // int32_t (Size: 0x4)
SGAIEventAvatarTableRow.AIIDs = 0x10 // TArray<int32_t> (Size: 0x10)
SGAIEventAvatarTableRow.SoundData = 0x20 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAIEventAvatarTableRow.AvatarInventoryID = 0x48 // TArray<int64_t> (Size: 0x10)
SGAIGlobalManagerComponent.PerceptionAssistActor = 0x110 // NPCAIPerceptionAssistActor* (Size: 0x8)
SGAIGlobalManagerComponent.PerceptionDynamicActor = 0x118 // NPCAIPerceptionDynamicActor* (Size: 0x8)
SGAIGlobalManagerComponent.CoverSystemActor = 0x120 // CoverSystemActor* (Size: 0x8)
SGAIGlobalManagerComponent.TacticSystemActor = 0x128 // TacticSystemActor* (Size: 0x8)
SGAIGlobalManagerComponent.AISceneEventsTriggerManager = 0x130 // AISceneEventsTriggerManager* (Size: 0x8)
SGAIGlobalManagerComponent.AISGDoorManager = 0x138 // AISGDoorManager* (Size: 0x8)
SGAIGlobalManagerComponent.SharedVariables = 0x140 // NPCAIGlobalSharedInfo* (Size: 0x8)
SGAIGlobalManagerComponent.AsyncTaskSystem = 0x148 // NPCAIAsyncTaskSystem* (Size: 0x8)
SGAIGlobalManagerComponent.HeightFogSystem = 0x150 // ExponentialHeightFog* (Size: 0x8)
SGAIGlobalManagerComponent.PmcRelativeMaxLevel = 0x168 // int32_t (Size: 0x4)
SGAIGlobalManagerComponent.DefaultPmcMinLevel = 0x16c // int32_t (Size: 0x4)
SGAIGlobalManagerComponent.DefaultPmcMaxLevel = 0x170 // int32_t (Size: 0x4)
SGAIGlobalManagerComponent.PMCEquipLevel = 0x1e8 // TMap<...> (Size: 0x50)
SGAIGlobalManagerComponent.AIEquipmentSettings = 0x238 // FSGAIEquipmentSettings (Size: 0x18)
SGAIGlobalManagerComponent.AIWeaponDefaultBulletClassInfo = 0x250 // TMap<...> (Size: 0x50)
SGAIGlobalManagerComponent.LockPickUpInventorysList = 0x2a0 // TArray<Actor*> (Size: 0x10)
SGAIGlobalManagerComponent.LastTimeFindCropseCanPickUpInWorld = 0x2b0 // float (Size: 0x4)
SGAIGlobalManagerComponent.CacheCropseCanPickUpInWorld = 0x2b8 // TArray<Actor*> (Size: 0x10)
SGAIGlobalManagerComponent.DelayTimeReportSpawnedInventoryValue = 0x2c8 // float (Size: 0x4)
SGAIGlobalManagerComponent.GrenadeMinLifeTime = 0x324 // float (Size: 0x4)
SGAIGlobalManagerComponent.PrevLoadBehaviorTreesList = 0x328 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGAIGlobalManagerComponent.PrevLoadBehaviorTreesList_Tutorial = 0x338 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGAIGlobalManagerComponent.AIRuntimeMonitor = 0x348 // AIRuntimeMonitor* (Size: 0x8)
SGAIGlobalManagerComponent.PerceptionDynamicActorClass = 0x350 // ClassProperty (Size: 0x8)
SGAIPathNode.NextPathNodeArray = 0x310 // TArray<SGAIPathNode*> (Size: 0x10)
SGAIPathNode.WaitTimeAtThisNode = 0x320 // float (Size: 0x4)
SGAIPerformanceTableRow.AIPerformance = 0x8 // EEAIPerformance (Size: 0x1)
SGAIPerformanceTableRow.SoundDatas = 0x10 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGAIPerformanceTableRow.DeathBoxClass = 0x20 // TSoftClassPtr<UObject> (Size: 0x28)
SGAIPerformanceTableRow.AvatarInventoriesGroup = 0x48 // TArray<FSGAIAvatarInventories> (Size: 0x10)
SGAIPerformanceTableRow.FemalePercentage = 0x58 // int32_t (Size: 0x4)
SGAISpawnController.OnLimitChangedDelegate = 0x310 // FMulticastInlineDelegate (Size: 0x10)
SGAISpawnController.bEnableTestData = 0x320 // bool (Size: 0x1)
SGAISpawnController.PlayerScavAIDelayTime = 0x33c // float (Size: 0x4)
SGAISpawnController.BlackboardKeyLog_CoolDown = 0x344 // float (Size: 0x4)
SGAISpawnController.BlackboardKeyLog_Key = 0x348 // FString (Size: 0x10)
SGAISpawnController.GroupInfoClassMap = 0x358 // TMap<...> (Size: 0x50)
SGAISpawnController.SquadInfo = 0x3a8 // TMap<...> (Size: 0x50)
SGAISpawnController.MyMapID = 0x3f8 // int32_t (Size: 0x4)
SGAISpawnController.MySpawnConfID = 0x3fc // int32_t (Size: 0x4)
SGAISpawnController.PMCDelayTime = 0x404 // float (Size: 0x4)
SGAISpawnController.EquipIDCounter = 0x408 // TMap<...> (Size: 0x50)
SGAISpawnController.AISpawnProcess = 0x460 // TArray<EEAISpawnStep> (Size: 0x10)
SGAISpawnController.CurrentSpawnSquadIndex = 0x470 // int32_t (Size: 0x4)
SGAISpawnController.PMCSquadIDCounter = 0x474 // int32_t (Size: 0x4)
SGAISpawnManagerComponent.SpawnCD = 0x100 // double (Size: 0x8)
SGAISpawnManagerComponent.MaxAINum = 0x120 // int32_t (Size: 0x4)
SGAISpawnManagerComponent.AllSpawnPointInfos = 0x128 // TArray<SpawnPointInfo*> (Size: 0x10)
SGAISpawnManagerComponent.DefaultsFactionClass = 0x150 // TSoftClassPtr<UObject> (Size: 0x28)
SGAISpawnManagerComponent.SpawnAtUnderGround = 0x178 // bool (Size: 0x1)
SGAISpawnManagerComponent.SpawnAtUnderGroundOffset = 0x17c // int32_t (Size: 0x4)
SGAISpawnManagerComponent.UpdateAIPriorityDistSquared1 = 0x180 // float (Size: 0x4)
SGAISpawnManagerComponent.UpdateAIPriorityDistSquared2 = 0x184 // float (Size: 0x4)
SGAISpawnManagerComponent.UpdateAIPriorityDataValidTime = 0x188 // double (Size: 0x8)
SGAISpawnManagerComponent.UpdateAIPrioritySeenTime = 0x190 // double (Size: 0x8)
SGAISpawnManagerComponent.UpdateAIPriorityMaxFactTo = 0x198 // int32_t (Size: 0x4)
SGAISpawnManagerComponent.UpdateAIPriorityMaxBeSeenTime = 0x1a0 // double (Size: 0x8)
SGAISpawnManagerComponent.bSkipSpawnPointValidation = 0x1a9 // bool (Size: 0x1)
SGAISpawnManagerComponent.MaxHeightDiff = 0x1ac // float (Size: 0x4)
SGAISpawnManagerComponent.QueryExtent = 0x1b0 // FVector (Size: 0xc)
SGAISpawnManagerComponent.ReadyDelayFrame = 0x1bc // int32_t (Size: 0x4)
SGAISpawnManagerComponent.MaxAISpawnPerFrame = 0x1c0 // int32_t (Size: 0x4)
SGAISpawnManagerComponent.PriorityExpiredSeconds = 0x1c8 // double (Size: 0x8)
SGAISpawnManagerComponent.PolysPathingDistance = 0x1d0 // float (Size: 0x4)
SGAISpawnManagerComponent.SpawnPointCheckRadius = 0x1d4 // float (Size: 0x4)
SGAISpawnManagerComponent.PendingSpawnPoints = 0x1d8 // TArray<FPendingSpawnInfo> (Size: 0x10)
SGAISpawnManagerComponent.PendingAICharacters = 0x1e8 // TArray<SGAICharacter*> (Size: 0x10)
SGAISpawnManagerComponent.WeaponReadyAICharacters = 0x1f8 // TArray<SGAICharacter*> (Size: 0x10)
SGAISpawnManagerComponent.SpawnedAIInfos = 0x208 // TArray<FSpawnedAIInfo> (Size: 0x10)
SGAISpawnManagerComponent.AISpawnController = 0x270 // SGAISpawnController* (Size: 0x8)
SGAISpawnManagerComponent.HighPriorityReason = 0x278 // TSet<...> (Size: 0x50)
SGAISpawnManagerComponent.LoadedFactions = 0x2c8 // TMap<...> (Size: 0x50)
SGAISpawnManagerComponent.SpawnCDList = 0x320 // TMap<...> (Size: 0x50)
SGAISpawnManagerComponent.SecurityMonitors = 0x378 // TArray<SGSecurityMonitor*> (Size: 0x10)
SGAISpawnPoint.bGenerateSubPoints = 0x340 // bool (Size: 0x1)
SGAISpawnPoint.bUseRandomEquip = 0x341 // uint8_t (Size: 0x1)
SGAISpawnPoint.FactionClass = 0x348 // ClassProperty (Size: 0x8)
SGAISpawnPoint.RoleClass = 0x350 // ClassProperty (Size: 0x8)
SGAISpawnPoint.SpawnPointID = 0x358 // int32_t (Size: 0x4)
SGAISpawnPoint.AICharacterClass = 0x360 // ClassProperty (Size: 0x8)
SGAISpawnPoint.AIControllerClass = 0x368 // ClassProperty (Size: 0x8)
SGAISpawnPoint.ArchetypeTemplate = 0x370 // BehaviorTree* (Size: 0x8)
SGAISpawnPoint.LastUsedSpawnGroupID = 0x37c // FName (Size: 0x8)
SGAISpawnPoint.CampID = 0x384 // int32_t (Size: 0x4)
SGAISpawnPoint.ExtraInitPathNodes = 0x388 // TArray<SGAIPathNode*> (Size: 0x10)
SGAISpawnPoint.bRespawnAIWhenDied = 0x398 // bool (Size: 0x1)
SGAISpawnPoint.LastUsedEquipPoolID = 0x39c // int32_t (Size: 0x4)
SGAISpawnPoint.SpawnGroupWeights = 0x3a0 // TArray<FSGNPCSpawnGroupWeight> (Size: 0x10)
SGAISpawnPoint.AIPatrolRadius = 0x3b0 // float (Size: 0x4)
SGAISpawnPoint.AICautionRadius = 0x3b4 // float (Size: 0x4)
SGAISpawnPoint.AICrossFireRadius = 0x3b8 // float (Size: 0x4)
SGAISpawnPoint.NPCProfile = 0x3c0 // NPCAIProfile* (Size: 0x8)
SGAISpawnPoint.InitPathNode = 0x3c8 // SGAIPathNode* (Size: 0x8)
SGAISpawnPoint.bShouldSpawnAtBeginPlay = 0x3d0 // bool (Size: 0x1)
SGAISpawnPoint.SpawnDelayTime = 0x3d4 // float (Size: 0x4)
SGAISpawnPoint.bCanSpawnAI = 0x3d8 // bool (Size: 0x1)
SGAISpawnPoint.CheckAITimeSeconds = 0x3dc // float (Size: 0x4)
SGAISpawnPoint.NextAvailableTime = 0x3e0 // float (Size: 0x4)
SGAISpawnPoint.WatchingAICharacter = 0x3e4 // TWeakObjectPtr<UObject> (Size: 0x8)
SGAISpawnPoint.SpawnSquadID = 0x3ec // int32_t (Size: 0x4)
SGAISpawnPoint.PlayerAroundRadius = 0x3f0 // float (Size: 0x4)
SGAISpawnPoint.PlayerLineOfSightDistance = 0x3f4 // float (Size: 0x4)
SGAISpawnPoint.PlayerViewAngle = 0x3f8 // float (Size: 0x4)
SGAISpawnStuff.OnAIDiedDelegate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
SGAISpawnStuff.OnRemoveRedundantAIDelegate = 0x38 // FMulticastInlineDelegate (Size: 0x10)
SGAISpawnStuff.BlackboardKeyLog = 0x48 // TMap<...> (Size: 0x50)
SGAISpawnStuff.ZoneVolumeList = 0xb0 // TArray<SGAIBotZoneVolume*> (Size: 0x10)
SGAISpawnStuff.SpawnPointsCandidates = 0xc0 // TArray<Actor*> (Size: 0x10)
SGAISpawnStuff.SpawnController = 0xe0 // SGAISpawnController* (Size: 0x8)
SGAISpawnStuff.GroupClass = 0xe8 // ClassProperty (Size: 0x8)
SGAISpawnStuff.GroupType = 0xf4 // int32_t (Size: 0x4)
SGAISpawnStuff.GroupInfo = 0xf8 // NPCAIZoneGroupInfo* (Size: 0x8)
SGAISpawnStuff.CurrentWave = 0x104 // int32_t (Size: 0x4)
SGAISpawnStuff.TeamLeader = 0x108 // TWeakObjectPtr<UObject> (Size: 0x8)
SGAISpawnStuff.TeamMembers = 0x110 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGAISpawnStuff.GoalEnemys = 0x120 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGAISpawnStuff.AddEnemyEvent = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGAISpawnStuff.RemoveEnemyEvent = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGAISpawnStuff.SquadMembers = 0x150 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGAbilitySystemComponent.ActionAbilities = 0x14a8 // ClassProperty (Size: 0x8)
SGAbilitySystemComponent.ActionAbilitySpecHandles = 0x16d8 // FGameplayAbilitySpecHandle (Size: 0x4)
SGAbilitySystemComponent.DefaultAttributeSets = 0x17f0 // TArray<ClassProperty> (Size: 0x10)
SGAbilitySystemComponent.RepAdvancedAnimMontageInfo = 0x1818 // FGameplayAbilityRepAdvancedAnimMontage (Size: 0x78)
SGAbilitySystemComponent.RepStopAdvancedAnimMontageInfo = 0x1890 // FGameplayAbilityRepStopAdvancedAnimMontage (Size: 0x10)
SGAbilitySystemComponent.LocalAdvancedAnimMontageInfo = 0x18a0 // FGameplayAbilityRepAdvancedAnimMontage (Size: 0x78)
SGAbilitySystemComponent.RepEquipAnimMontageInfo = 0x1918 // FGameplayAbilityRepEquipAnimMontage (Size: 0x30)
SGAbilitySystemComponent.LocalEquipAnimMontageInfo = 0x1948 // FGameplayAbilityRepEquipAnimMontage (Size: 0x30)
SGAbilitySystemComponent.MeshComponent = 0x1978 // SkeletalMeshComponentBudgeted* (Size: 0x8)
SGAbilitySystemComponent.RepInteractAnimMontageInfo = 0x1990 // FGameplayAbilityRepInteractMontage (Size: 0xc0)
SGAbilitySystemComponent.RepInventoryAnimMontageInfo = 0x1a50 // FGameplayAbilityRepInventoryMontage (Size: 0x118)
SGAbilitySystemComponent.ProgressLocalTimeStampOnRep = 0x1b98 // float (Size: 0x4)
SGAbilitySystemComponent.ProgressRemainingDurationOnRep = 0x1b9c // float (Size: 0x4)
SGAbilitySystemComponent.SimulateFullProgressThreshold = 0x1ba0 // float (Size: 0x4)
SGAbilitySystemComponent.AbortProgressSimulationThreshold = 0x1ba4 // float (Size: 0x4)
SGAbilitySystemComponent.ProgressAbilitySimulationInfo = 0x1ba8 // FProgressAbilitySimulationInfo (Size: 0x28)
SGAbilitySystemComponent.DefaultAbilities = 0x1bd8 // TMap<...> (Size: 0x50)
SGAbilitySystemComponent.InstancedAbilities = 0x1c28 // TArray<FAbilitySlot> (Size: 0x10)
SGAbilitySystemComponent.OnClientTryActivateAbilityFailed = 0x1c38 // FMulticastInlineDelegate (Size: 0x10)
SGAbilitySystemComponent.CachedAbilityWithEmptyHand = 0x1c58 // SGGameplayAbility* (Size: 0x8)
SGAbilitySystemComponent.CachedWeaponToTakeUpAfterAbilityWithEmptyHand = 0x1c60 // SGInventory* (Size: 0x8)
SGAbilitySystemComponent.OnPerformQuickFillMagazineTask = 0x1c70 // FMulticastInlineDelegate (Size: 0x10)
SGAbilitySystemComponent.OnQuickFillMagazineTaskFinish = 0x1c80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilitySystemComponent.PushMagazineAbilityInfo = 0x1c90 // FPushMagazineAbilityInfo (Size: 0x38)
SGAbilitySystemComponent.RepPushMagazineAbilityInfo = 0x1cd8 // FPushMagazineAbilityInfo (Size: 0x38)
SGAbilitySystemGlobals.SimpleModifyAttributeGE = 0x260 // GameplayEffect* (Size: 0x8)
SGAbilityTaskFireTickFunction.Target = 0x38 // SGAbilityTask_Fire* (Size: 0x8)
SGAbilityTaskPrepareToFireTickFunction.Target = 0x38 // SGAbilityTask_PrepareToFire* (Size: 0x8)
SGAbilityTask_ApplyRootMotionMoveToTarget.AccumulateMode = 0x108 // EERootMotionAccumulateMode (Size: 0x1)
SGAbilityTask_ApplyRootMotionMoveToTarget.SettingsFlag = 0x109 // EERootMotionSourceSettingsFlags (Size: 0x1)
SGAbilityTask_AsyncLoad.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_AsyncLoad.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_AsyncLoad.Assets = 0xb0 // TArray<Object*> (Size: 0x10)
SGAbilityTask_BoresPump.OnTaskFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_BoresPump.Weapon = 0x90 // SGInventory* (Size: 0x8)
SGAbilityTask_BoresPump.Character = 0x98 // Character* (Size: 0x8)
SGAbilityTask_BoresPump.BoreComp = 0xa0 // SGWeaponBoreComponent* (Size: 0x8)
SGAbilityTask_BoresPump.PlayBoresPumpMontageTask = 0xa8 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGAbilityTask_DelayActivateAbilityAction.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_DelayActivateAbilityAction.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_DelayActivateAbilityAction.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_DelayActivateAbilityAction.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_DelayActivateAbilityAction.CharacterMontageParams = 0xc0 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_DelayActivateAbilityAction.WeaponMontageParams = 0x108 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_DelayActivateAbilityAction.DelayReason = 0x150 // EEDelayReason (Size: 0x1)
SGAbilityTask_DelayActivateAbilityAction.TacticalTransType = 0x151 // EETacticalPistolAnimationType (Size: 0x1)
SGAbilityTask_DelayActivateAbilityAction.SGCharacter = 0x158 // SGCharacter* (Size: 0x8)
SGAbilityTask_Fire.OnFireEnd = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_Fire.FireTickFunction = 0x110 // FSGAbilityTaskFireTickFunction (Size: 0x40)
SGAbilityTask_LeaveTacticalState.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_LeaveTacticalState.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.OnStopFireEvent = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.DoFireEvent = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.OnCanNotFireEvent = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.JumpToNextPhaseEvent = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.ResetFirePhaseEvent = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_MeleeFire.EnterAnimRecovery = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInteractAnim.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInteractAnim.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInteractAnim.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInteractAnim.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInteractAnim.CharacterMontageParams = 0xc0 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayInteractAnim.InteractObjectMontageParams = 0x108 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayInteractAnim.InteractObjectMeshComponent = 0x150 // SkeletalMeshComponent* (Size: 0x8)
SGAbilityTask_PlayInteractAnim.PlayConfig = 0x158 // FSGMontagePlayConfig (Size: 0x18)
SGAbilityTask_PlayInteractAnim.bStopWhenAbilityEnds = 0x170 // bool (Size: 0x1)
SGAbilityTask_PlayInteractAnim.bStopWhenAbilityCancelled = 0x171 // bool (Size: 0x1)
SGAbilityTask_PlayInventoryAnimHD.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.CharacterMontageParams = 0xc0 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayInventoryAnimHD.InventoryMontageParams = 0x108 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayInventoryAnimHD.InventoryMesh = 0x150 // SkeletalMesh* (Size: 0x8)
SGAbilityTask_PlayInventoryAnimHD.InventoryStaticMesh = 0x158 // StaticMesh* (Size: 0x8)
SGAbilityTask_PlayInventoryAnimHD.InventoryAnimInstanceClass = 0x160 // ClassProperty (Size: 0x8)
SGAbilityTask_PlayInventoryAnimHD.InventoryAttachSocket = 0x168 // FName (Size: 0x8)
SGAbilityTask_PlayInventoryAnimHD.SectionLoopCountMap = 0x170 // TMap<...> (Size: 0x50)
SGAbilityTask_PlayInventoryAnimHD.PlayConfig = 0x1c0 // FSGMontagePlayConfig (Size: 0x18)
SGAbilityTask_PlayInventoryAnimHD.DataHandle = 0x1d8 // FSGAnimTargetDataHandle (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.Dependencies = 0x1e8 // TArray<FRepDependency> (Size: 0x10)
SGAbilityTask_PlayInventoryAnimHD.bStopWhenAbilityEnds = 0x1f8 // bool (Size: 0x1)
SGAbilityTask_PlayInventoryAnimHD.bStopWhenAbilityCancelled = 0x1f9 // bool (Size: 0x1)
SGAbilityTask_PlayInventoryMontage.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayInventoryMontage.CharacterMontage = 0x90 // AnimMontage* (Size: 0x8)
SGAbilityTask_PlayInventoryMontage.InventoryMontage = 0x98 // AnimMontage* (Size: 0x8)
SGAbilityTask_PlayInventoryMontage.InventoryMesh = 0xa0 // SkeletalMesh* (Size: 0x8)
SGAbilityTask_PlayWeaponMontage.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayWeaponMontage.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayWeaponMontage.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayWeaponMontage.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PlayWeaponMontage.CharacterMontageParams = 0xc8 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayWeaponMontage.WeaponMontageParams = 0x110 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_PlayWeaponMontage.AdapterAnimType = 0x158 // EEAdapterAnimationType (Size: 0x1)
SGAbilityTask_PlayWeaponMontage.CanTriggerSoundWithGrass = 0x15a // bool (Size: 0x1)
SGAbilityTask_PlayWeaponMontage.bReplayWhileIsPlaying = 0x15b // bool (Size: 0x1)
SGAbilityTask_PlayWeaponMontage.bIsPlayMontageLocal = 0x15c // bool (Size: 0x1)
SGAbilityTask_PlayWeaponMontage.Dependencies = 0x168 // TArray<FRepDependency> (Size: 0x10)
SGAbilityTask_PrepareToFire.OnPrepareToFireEnd = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PrepareToFire.OnAbortFire = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PrepareToFire.PrepareToFireTickFunction = 0xb0 // FSGAbilityTaskPrepareToFireTickFunction (Size: 0x40)
SGAbilityTask_PreviewPlace.OwnerAbility = 0x80 // SGGameplayAbility_PreviewPlace* (Size: 0x8)
SGAbilityTask_PullBolt.OnTaskFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_PullBolt.Weapon = 0x90 // SGInventory* (Size: 0x8)
SGAbilityTask_PullBolt.Character = 0x98 // Character* (Size: 0x8)
SGAbilityTask_PullBolt.BoreComp = 0xa0 // SGWeaponBoreComponent* (Size: 0x8)
SGAbilityTask_PullBolt.StateComp = 0xa8 // SGWeaponStateComponent* (Size: 0x8)
SGAbilityTask_PullBolt.PlayPullBoltMontageTask = 0xb0 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGAbilityTask_QuickFillMagazine.OnFillMagazine = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_QuickFillMagazine.OnFinish = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_QuickFillMagazine.CurrentLoadingMagazine = 0xb8 // SGInventory* (Size: 0x8)
SGAbilityTask_QuickFillMagazine.CurrentLoadingBullet = 0xc0 // SGInventory* (Size: 0x8)
SGAbilityTask_QuickFillMagazine.LastLoadingMagazine = 0xc8 // SGInventory* (Size: 0x8)
SGAbilityTask_QuickFillMagazine.LastLoadingBullet = 0xd0 // SGInventory* (Size: 0x8)
SGAbilityTask_ReleaseHoldOpen.OnTaskFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_ReleaseHoldOpen.Weapon = 0x90 // SGInventory* (Size: 0x8)
SGAbilityTask_ReleaseHoldOpen.Character = 0x98 // Character* (Size: 0x8)
SGAbilityTask_ReleaseHoldOpen.BoreComp = 0xa0 // SGWeaponBoreComponent* (Size: 0x8)
SGAbilityTask_ReleaseHoldOpen.StateComp = 0xa8 // SGWeaponStateComponent* (Size: 0x8)
SGAbilityTask_ReleaseHoldOpen.PlayReleaseHoldOpenMontageTask = 0xb0 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGAbilityTask_SwitchWeapon.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeapon.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponHD.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponHD.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponWithPlayMontage.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponWithPlayMontage.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponWithPlayMontage.OnInterrupted = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponWithPlayMontage.OnCancelled = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_SwitchWeaponWithPlayMontage.CharacterMontageParams = 0xc0 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_SwitchWeaponWithPlayMontage.WeaponMontageParams = 0x108 // FSGMontagePlayParams (Size: 0x48)
SGAbilityTask_SwitchWeaponWithPlayMontage.AdapterAnimType = 0x150 // EEAdapterAnimationType (Size: 0x1)
SGAbilityTask_ThrowFire_HD.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_ThrowFire_HD.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitAmmoChange.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitAmmoChange.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitAmmoChange.Timeout = 0xa0 // float (Size: 0x4)
SGAbilityTask_WaitAmmoChange.Weapon = 0xa8 // SGWeapon* (Size: 0x8)
SGAbilityTask_WaitAmmoChange.Character = 0xb0 // SGCharacter* (Size: 0x8)
SGAbilityTask_WaitBoxOpen.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitBoxOpen.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitBulletSync.OnFinished = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitBulletSync.OnFailed = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitBulletSync.Timeout = 0xa0 // float (Size: 0x4)
SGAbilityTask_WaitBulletSync.Weapon = 0xa8 // SGWeapon* (Size: 0x8)
SGAbilityTask_WaitBulletSync.Character = 0xb0 // Character* (Size: 0x8)
SGAbilityTask_WaitMeshCompleted.OnCompleted = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitMeshCompleted.OnFail = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitMeshCompleted.WaitInventory = 0xa0 // SGInventory* (Size: 0x8)
SGAbilityTask_WaitNextTick.OnFinish = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitUntilAnimationSetReady.OnReady = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitUntilAnimationSetReady.Targets = 0x90 // TArray<SGInventory*> (Size: 0x10)
SGAbilityTask_WaitUntilAnimationSetReady.WaitingTargets = 0xa0 // TArray<SGInventory*> (Size: 0x10)
SGAbilityTask_WaitWeaponMontage.OnEnded = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitWeaponMontage.OnBlendOut = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitWeaponMontage.OnNotPlaying = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGAbilityTask_WaitWeaponMontage.MontageToWait = 0xb0 // AnimMontage* (Size: 0x8)
SGAbility_ThrowProjectile.AfterHittedAbility = 0x9a8 // ClassProperty (Size: 0x8)
SGActivityDataTableManager.ActivityIDs = 0x28 // TArray<int32_t> (Size: 0x10)
SGActivityDataTableManager.DataTableArr = 0x40 // TArray<DataTable*> (Size: 0x10)
SGActivityItemExpCalculationRaw.KillExpValue = 0x20 // float (Size: 0x4)
SGActivityItemExpCalculationRaw.KillDifficultFactor = 0x24 // float (Size: 0x4)
SGActivityItemExpCalculationRaw.TakeoutExpVal = 0x28 // float (Size: 0x4)
SGActivityItemExpCalculationRaw.TakeoutDifficultFactor = 0x2c // float (Size: 0x4)
SGActivityItemTakeOutReplaceTable.ReplaceRuleArr = 0x20 // TArray<FSGTakeOutReplaceRaw> (Size: 0x10)
SGActorBeUsedComponent.UserActor = 0x100 // Actor* (Size: 0x8)
SGActorBeUsedComponent.UseInBodyPart = 0x108 // EECharacterEnduranceType (Size: 0x1)
SGActorBeUsedComponent.UserActors = 0x110 // TArray<Actor*> (Size: 0x10)
SGActorBeUsedComponent.TickTimer = 0x120 // FTimerHandle (Size: 0x8)
SGActorBeUsedComponent.CharacterUsingAnim = 0x138 // AnimMontage* (Size: 0x8)
SGActorBeUsedComponent.CharacterUnUsingAnim = 0x140 // AnimMontage* (Size: 0x8)
SGActorDeathComponent.DeferEventInstigator = 0xf8 // Controller* (Size: 0x8)
SGActorDeathComponent.DeferEffectCauser = 0x100 // Actor* (Size: 0x8)
SGActorDeathComponent.DeferDamageEventObject = 0x108 // DamageEventObject* (Size: 0x8)
SGActorDeathComponent.DeferbForceDied = 0x110 // bool (Size: 0x1)
SGActorEnduranceComponent.MaxEndurance = 0xf8 // float (Size: 0x4)
SGActorEnduranceComponent.CurrentEndurance = 0xfc // float (Size: 0x4)
SGActorEnduranceComponent.ActorEnduranceChangedEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGActorFactionComponent.Faction = 0x100 // SGFaction* (Size: 0x8)
SGActorHealthAttributeSet.Health = 0x48 // float (Size: 0x4)
SGActorHealthAttributeSet.HealthMax = 0x4c // float (Size: 0x4)
SGActorHealthComponent.AttributeSetClass = 0xf8 // ClassProperty (Size: 0x8)
SGActorInventoryFactoryComponent.InventoryClass = 0x238 // TSoftClassPtr<UObject> (Size: 0x28)
SGActorInventoryFactoryComponent.EditorEmptyMesh = 0x260 // StaticMesh* (Size: 0x8)
SGActorInventoryFactoryComponent.EditorClusterScatterMesh = 0x268 // StaticMesh* (Size: 0x8)
SGActorInventoryFactoryComponent.OnLootPointSpawnCompleted = 0x270 // FMulticastInlineDelegate (Size: 0x10)
SGActorInventoryFactoryComponent.ConfigDataTable = 0x280 // DataTable* (Size: 0x8)
SGActorInventoryFactoryComponent.LootContainer = 0x288 // SGInventory* (Size: 0x8)
SGActorInventoryFactoryComponent.SpawnedRootInventories = 0x290 // TArray<SGInventory*> (Size: 0x10)
SGActorInventoryFactoryComponent.SpawnedInventories = 0x2a0 // TArray<SGInventory*> (Size: 0x10)
SGActorInventoryFactoryComponent.OffsetRange = 0x2b0 // float (Size: 0x4)
SGActorInventoryFactoryComponent.bRandomRotation = 0x2b4 // bool (Size: 0x1)
SGActorInventoryFactoryComponent.bContainerAutoCheckPlacement = 0x2b5 // bool (Size: 0x1)
SGActorInventoryFactoryComponent.bAutoCheckPlacement = 0x2b6 // bool (Size: 0x1)
SGActorInventoryFactoryComponent.CheckPlacementZOffset = 0x2b8 // float (Size: 0x4)
SGActorInventoryFactoryComponent.bDisableRegistToGameMode = 0x2bc // bool (Size: 0x1)
SGActorRadiusCheckComp.RadiusCheckType = 0x238 // EESGRadiusCheckType (Size: 0x1)
SGActorRadiusCheckComp.CheckRadius = 0x23c // float (Size: 0x4)
SGActorRadiusCheckComp.CheckInterval = 0x240 // float (Size: 0x4)
SGActorRadiusCheckComp.SphereComponentInstance = 0x248 // SphereComponent* (Size: 0x8)
SGActorRadiusCheckComp.OverrideCheckVolume = 0x250 // SGVolume* (Size: 0x8)
SGActorRadiusCheckComp.ActorRadiusCheckOverlap = 0x258 // FMulticastInlineDelegate (Size: 0x10)
SGActorRotationComponent.TargetComponent = 0x128 // SceneComponent* (Size: 0x8)
SGActorSoundComponent.SoundInfoMap = 0xf8 // TMap<...> (Size: 0x50)
SGActorUseComponent.CachedActor = 0x100 // Actor* (Size: 0x8)
SGActorUseComponent.UsingActorCache = 0x118 // Actor* (Size: 0x8)
SGActorUseComponent.UsingActors = 0x120 // TArray<Actor*> (Size: 0x10)
SGActorUseComponent.InteractBoxInventoryHistory = 0x130 // TArray<Actor*> (Size: 0x10)
SGActorWeatherComponent.Sunny = 0xf8 // bool (Size: 0x1)
SGActorWeatherComponent.Rainy = 0xf9 // bool (Size: 0x1)
SGActorWeatherComponent.Cloudy = 0xfa // bool (Size: 0x1)
SGAdapterAnimInstance.Sequence_BipOn = 0x2b8 // AnimSequence* (Size: 0x8)
SGAdapterAnimInstance.LocalProxy = 0x2c0 // FSGAdapterAnimInstanceProxy (Size: 0x870)
SGAdapterAnimInstanceProxy.AnimInstance = 0x860 // SGAdapterAnimInstance* (Size: 0x8)
SGAdapterAnimInstanceProxy.BipOnAlpha = 0x868 // float (Size: 0x4)
SGAdapterAnimSet.AdapterAnimMontages = 0x0 // TMap<...> (Size: 0x50)
SGAdapterAnimSet.AdapterHandAnimMontages = 0x50 // TMap<...> (Size: 0x50)
SGAdapterDataAsset.IsCanPickup = 0x2e0 // bool (Size: 0x1)
SGAdapterDataAsset.AttachSocketName = 0x2e4 // FName (Size: 0x8)
SGAdapterDataAsset.bEnableErgonomicsModify = 0x2ec // bool (Size: 0x1)
SGAdapterDataAsset.ErgonomicsValue = 0x2f0 // int32_t (Size: 0x4)
SGAdapterDataAsset.bEnableRecoilModify = 0x2f4 // bool (Size: 0x1)
SGAdapterDataAsset.VerticalRecoilValue_Multiplier = 0x2f8 // float (Size: 0x4)
SGAdapterDataAsset.HorizentalRecoilValue_Multiplier = 0x2fc // float (Size: 0x4)
SGAdapterDataAsset.bEnableSpreadModify = 0x300 // bool (Size: 0x1)
SGAdapterDataAsset.AccuracyValue_Multiplier = 0x304 // float (Size: 0x4)
SGAdapterDataAsset.MoaScaleX_Multiplier = 0x308 // float (Size: 0x4)
SGAdapterDataAsset.MoaScaleY_Multiplier = 0x30c // float (Size: 0x4)
SGAdapterDataAsset.bEnableFireInitSpeedModify = 0x310 // bool (Size: 0x1)
SGAdapterDataAsset.FireInitSpeedScale = 0x314 // float (Size: 0x4)
SGAdapterDataAsset.BulletZeroDropDistance = 0x318 // float (Size: 0x4)
SGAdapterDataAsset.AdapterAdjustDamage = 0x31c // float (Size: 0x4)
SGAdapterDataAsset.bEnableChangeClipSpeedModify = 0x320 // bool (Size: 0x1)
SGAdapterDataAsset.ChangeClipSpeedScale = 0x324 // float (Size: 0x4)
SGAdapterDataAsset.bEnableSwitchToADSTimeModify = 0x328 // bool (Size: 0x1)
SGAdapterDataAsset.SwitchToADSTimeScale = 0x32c // float (Size: 0x4)
SGAdapterDataAsset.WeaponEquipTimeTimeModify = 0x330 // bool (Size: 0x1)
SGAdapterDataAsset.WeaponEquipTimeScale = 0x334 // float (Size: 0x4)
SGAdapterDataAsset.bEnableHoldBreathEnergyCostModify = 0x338 // bool (Size: 0x1)
SGAdapterDataAsset.HoldBreathEnergyCostScale = 0x33c // float (Size: 0x4)
SGAdapterDataAsset.FPMergeFireHDRTemplate = 0x340 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.FPMergeFireLDRTemplate = 0x390 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.TPMergeFireHDRTemplate = 0x3e0 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.TPMergeFireLDRTemplate = 0x430 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.bEnableFlameModify = 0x480 // bool (Size: 0x1)
SGAdapterDataAsset.Flame1PTemplate = 0x488 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.Flame3PTemplate = 0x4d8 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.bEnableFogModify = 0x528 // bool (Size: 0x1)
SGAdapterDataAsset.FogTemplate = 0x530 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.bEnableFireLightModify = 0x580 // bool (Size: 0x1)
SGAdapterDataAsset.FireLightTemplate = 0x588 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.IntensityOfFireLight = 0x5d8 // float (Size: 0x4)
SGAdapterDataAsset.FireLightSize = 0x5dc // float (Size: 0x4)
SGAdapterDataAsset.FireLightTemplate_LDR = 0x5e0 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.IntensityColorOfFireLight_LDR = 0x630 // FVector (Size: 0xc)
SGAdapterDataAsset.FireLightSize_LDR = 0x63c // FVector (Size: 0xc)
SGAdapterDataAsset.FireLightTemplate3P = 0x648 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.IntensityOfFireLight3P = 0x698 // float (Size: 0x4)
SGAdapterDataAsset.FireLightSize3P = 0x69c // float (Size: 0x4)
SGAdapterDataAsset.FireLightTemplate3P_LDR = 0x6a0 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.IntensityColorOfFireLight3P_LDR = 0x6f0 // FVector (Size: 0xc)
SGAdapterDataAsset.FireLightSize3P_LDR = 0x6fc // FVector (Size: 0xc)
SGAdapterDataAsset.CompositeFireTemplate = 0x708 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.CompositeFireLightSize = 0x758 // FVector (Size: 0xc)
SGAdapterDataAsset.CompositeFireLightColor = 0x764 // FVector (Size: 0xc)
SGAdapterDataAsset.CompositeFireTemplate3P = 0x770 // FEffectParticleInfo (Size: 0x50)
SGAdapterDataAsset.CompositeFireLightSize3P = 0x7c0 // FVector (Size: 0xc)
SGAdapterDataAsset.CompositeFireLightColor3P = 0x7cc // FVector (Size: 0xc)
SGAdapterDataAsset.bEnableSoundModify = 0x7d8 // bool (Size: 0x1)
SGAdapterDataAsset.bOnlyModifyWhenSwitchOn = 0x7d9 // bool (Size: 0x1)
SGAdapterDataAsset.RaceStrategy = 0x7dc // int32_t (Size: 0x4)
SGAdapterDataAsset.PreCheckEnduranceLoss = 0x7e0 // bool (Size: 0x1)
SGAdapterDataAsset.PreCheckBoneBreak = 0x7e1 // bool (Size: 0x1)
SGAdapterDataAsset.PreCheckBleed = 0x7e2 // bool (Size: 0x1)
SGAdapterDataAsset.PreCheckOutOfEndurance = 0x7e3 // bool (Size: 0x1)
SGAdapterExtDataAsset.AbilityClass = 0x30 // ClassProperty (Size: 0x8)
SGAdapterExtDataAsset.ActiveAttachPosition = 0x38 // EEAttachPosition (Size: 0x1)
SGAdapterExtDataAsset.bPassive = 0x39 // bool (Size: 0x1)
SGAdapterExtDataAsset.bCancelAbilityWhileMoving = 0x3a // bool (Size: 0x1)
SGAdapterExtDataAsset.CancelAbilityMovingThreshold = 0x3c // float (Size: 0x4)
SGAdapterExtDataAsset.AuxiliaryCurve1 = 0x40 // CurveFloat* (Size: 0x8)
SGAdapterExtDataAsset.AuxiliaryCurve2 = 0x48 // CurveFloat* (Size: 0x8)
SGAdapterExtDataAsset.CaliberClass = 0x50 // ClassProperty (Size: 0x8)
SGAdapterExtDataAsset.DefaultBulletClass = 0x58 // ClassProperty (Size: 0x8)
SGAdapterExtDataAsset.BulletClassFilledWhenBeginPlay = 0x60 // TArray<FBulletContainerInfo> (Size: 0x10)
SGAdapterExtDataAsset.MaxStackCount = 0x70 // int32_t (Size: 0x4)
SGAdapterExtDataAsset.bFillOneByOne = 0x74 // bool (Size: 0x1)
SGAdapterExtDataAsset.bNeedAmmoInBeforeReloading = 0x75 // bool (Size: 0x1)
SGAdapterExtDataAsset.bAlwaysShowBullets = 0x76 // bool (Size: 0x1)
SGAdapterExtDataAsset.ShowBulletNum = 0x78 // int32_t (Size: 0x4)
SGAdapterExtDataAsset.FillContainerBasicTime = 0x7c // float (Size: 0x4)
SGAdapterExtDataAsset.FillMagazineTimeDefaultPerBullet = 0x80 // float (Size: 0x4)
SGAdapterExtDataAsset.FillMagazineTimeInBagPerBullet = 0x84 // float (Size: 0x4)
SGAdapterExtDataAsset.FillMagazineTimeInVestBagPerBullet = 0x88 // float (Size: 0x4)
SGAdapterExtDataAsset.FillMagazineTimeInGunPerBullet = 0x8c // float (Size: 0x4)
SGAdapterExtDataAsset.UnfillContainerBasicTime = 0x90 // float (Size: 0x4)
SGAdapterExtDataAsset.UnfillMagazineTimeDefaultPerBullet = 0x94 // float (Size: 0x4)
SGAdapterExtDataAsset.UnfillMagazineTimeInBagPerBullet = 0x98 // float (Size: 0x4)
SGAdapterExtDataAsset.UnfillMagazineTimeInVestBagPerBullet = 0x9c // float (Size: 0x4)
SGAdapterExtDataAsset.UnfillMagazineTimeInGunPerBullet = 0xa0 // float (Size: 0x4)
SGAdapterExtDataAsset.BulletSockets = 0xa8 // TArray<FBulletMeshInfo> (Size: 0x10)
SGAdapterExtDataAsset.FillMagazineMontage = 0xb8 // FSoftObjectPath (Size: 0x18)
SGAdapterExtDataAsset.UnfillMagazineMontage = 0xd0 // FSoftObjectPath (Size: 0x18)
SGAdapterExtDataAsset.bBelt = 0xe8 // bool (Size: 0x1)
SGAdapterExtDataAsset.bOnlyEnableAnimWhenAssembled = 0xe9 // bool (Size: 0x1)
SGAdapterExtDataAsset.AdapterAnimSet = 0xf0 // FSGAdapterAnimSet (Size: 0xa0)
SGAdapterExtDataAsset.FoldStockAnimSeq = 0x190 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.UnFoldStockAnimSeq = 0x1b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.LaserTraceCollisionChannel = 0x1e0 // uint8_t (Size: 0x1)
SGAdapterExtDataAsset.LaserBeamParticleSystemTemplate = 0x1e8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.LaserBeamParticleSystemTemplate_Lobby = 0x210 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.LaserBeamMaxDistance = 0x238 // float (Size: 0x4)
SGAdapterExtDataAsset.bCameraBasedZeroingWhenHipFire = 0x23c // bool (Size: 0x1)
SGAdapterExtDataAsset.BeamSocketName = 0x240 // FName (Size: 0x8)
SGAdapterExtDataAsset.BeamColor = 0x248 // FLinearColor (Size: 0x10)
SGAdapterExtDataAsset.LaserDotParticleSystemTemplate = 0x258 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.LaserDotParticleSystemTemplate_Lobby = 0x280 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAdapterExtDataAsset.bAlwaysShowLaserDot = 0x2a8 // bool (Size: 0x1)
SGAdapterExtDataAsset.DistBtwnLaserDotAndWallMaxRatio = 0x2ac // float (Size: 0x4)
SGAdapterExtDataAsset.DistBtwnLaserDotAndWallMaxValue = 0x2b0 // float (Size: 0x4)
SGAdapterExtDataAsset.ScaleWithDistanceCurve = 0x2b8 // CurveFloat* (Size: 0x8)
SGAdapterExtDataAsset.DotColor = 0x2c0 // FLinearColor (Size: 0x10)
SGAdapterExtDataAsset.bAdjustBeamSource = 0x2d0 // bool (Size: 0x1)
SGAdapterExtDataAsset.bAdjustTraceStart = 0x2d1 // bool (Size: 0x1)
SGAdapterExtDataAsset.TraceDirLerpSpeed = 0x2d4 // float (Size: 0x4)
SGAdapterExtDataAsset.TacticTag = 0x2d8 // FGameplayTag (Size: 0x8)
SGAdapterInfo.AdapterItemID = 0x0 // FName (Size: 0x8)
SGAdapterInfo.AdapterType = 0x8 // FSGWeaponAdapterInfo (Size: 0x20)
SGAdapterInfo.AdapterClass = 0x28 // ClassProperty (Size: 0x8)
SGAdapterRefManager.AdapterReferenceList = 0x28 // TArray<FSGAdapterInfo> (Size: 0x10)
SGAdditionMeshAnimInstance.LocalProxy = 0x2c0 // FSGAdditionMeshAnimInstanceProxy (Size: 0x880)
SGAdditionMeshAnimInstance.BasePose = 0xb40 // AnimSequence* (Size: 0x8)
SGAdditionMeshAnimInstanceProxy.AnimInstance = 0x860 // SGAdditionMeshAnimInstance* (Size: 0x8)
SGAdditionMeshAnimInstanceProxy.BasePose = 0x868 // AnimSequence* (Size: 0x8)
SGAdditionMeshAnimInstanceProxy.bIs1P = 0x870 // bool (Size: 0x1)
SGAirVehicle.MaxHealth = 0x388 // int32_t (Size: 0x4)
SGAirVehicle.DamageScale = 0x390 // TArray<FVehicleDamageScale> (Size: 0x10)
SGAirVehicle.Health = 0x3a0 // int32_t (Size: 0x4)
SGAirVehicle.Driver = 0x3a8 // Pawn* (Size: 0x8)
SGAirVehicle.Mesh = 0x3b0 // SkeletalMeshComponent* (Size: 0x8)
SGAirVehicle.VehicleMovement = 0x3b8 // AirVehicleMovementComponentBase* (Size: 0x8)
SGAirVehicle.SpringArm = 0x3c0 // SpringArmComponent* (Size: 0x8)
SGAirVehicle.Camera = 0x3c8 // CameraComponent* (Size: 0x8)
SGAirVehicle.FuelComponent = 0x3d0 // VehicleFuelComponent* (Size: 0x8)
SGAirVehicle.BoxCollisionForPawn = 0x3d8 // BoxComponent* (Size: 0x8)
SGAirVehicle.PassengersSockets = 0x3e0 // TArray<FName> (Size: 0x10)
SGAlarm.AlarmMarker = 0x310 // SphereComponent* (Size: 0x8)
SGAlarm.LockMarker = 0x318 // SphereComponent* (Size: 0x8)
SGAlarm.ParticleSystemLock = 0x320 // ParticleSystemComponent* (Size: 0x8)
SGAlarm.ParticleSystemUnlock = 0x328 // ParticleSystemComponent* (Size: 0x8)
SGAlarm.AlarmState = 0x330 // EESGAlarmState (Size: 0x1)
SGAlarm.KeyItemID = 0x338 // int64_t (Size: 0x8)
SGAnimMetaData_EscapeInteract.CharacterMoveToTargetSocketName = 0x28 // FName (Size: 0x8)
SGAnimMetaData_FoldScope.ReferenceOffset = 0x28 // FVector (Size: 0xc)
SGAnimMetaData_HandLockAbsoluteLocation.LeftHandLockSocketName = 0x28 // FName (Size: 0x8)
SGAnimMetaData_HandLockAbsoluteLocation.RightHandLockSocketName = 0x30 // FName (Size: 0x8)
SGAnimMetaData_Weapon.WeaponAnimType = 0x28 // FGameplayTag (Size: 0x8)
SGAnimMetaData_Weapon.WeaponName = 0x30 // FGameplayTag (Size: 0x8)
SGAnimMotionConfig.LinearMotionFunction = 0x0 // FSGAnimMotionFunctionSelector_Vector (Size: 0xb8)
SGAnimMotionConfig.AngularMotionFunction = 0xb8 // FSGAnimMotionFunctionSelector_Rotator (Size: 0xb8)
SGAnimMotionConfig.AtanPitchYawBase = 0x170 // float (Size: 0x4)
SGAnimMotionConfig.bAtanPitchYaw = 0x174 // bool (Size: 0x1)
SGAnimMotionFunctionSelector_Rotator.FunctionType = 0x0 // EESGAnimMotionFunctionType (Size: 0x1)
SGAnimMotionFunctionSelector_Rotator.Function_Instant = 0x8 // FSGAnimMotionFunction_RInstant (Size: 0x8)
SGAnimMotionFunctionSelector_Rotator.Function_Interp = 0x10 // FSGAnimMotionFunction_RInterp (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_InterpConstant = 0x20 // FSGAnimMotionFunction_RInterpConstant (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_Spring = 0x30 // FSGAnimMotionFunction_RSpring (Size: 0x18)
SGAnimMotionFunctionSelector_Rotator.Function_SpringLite = 0x48 // FSGAnimMotionFunction_RSpringLite (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_SpringSmoothing = 0x58 // FSGAnimMotionFunction_RSpringSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_Damping = 0x68 // FSGAnimMotionFunction_RDamping (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_Smoothing = 0x78 // FSGAnimMotionFunction_RSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_CriticallyDampedSmoothing = 0x88 // FSGAnimMotionFunction_RCriticallyDampedSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_SpringDamper = 0x98 // FSGAnimMotionFunction_RSpringDamper (Size: 0x10)
SGAnimMotionFunctionSelector_Rotator.Function_SpringDamperSmoothing = 0xa8 // FSGAnimMotionFunction_RSpringDamperSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.FunctionType = 0x0 // EESGAnimMotionFunctionType (Size: 0x1)
SGAnimMotionFunctionSelector_Vector.Function_Instant = 0x8 // FSGAnimMotionFunction_VInstant (Size: 0x8)
SGAnimMotionFunctionSelector_Vector.Function_Interp = 0x10 // FSGAnimMotionFunction_VInterp (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_InterpConstant = 0x20 // FSGAnimMotionFunction_VInterpConstant (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_Spring = 0x30 // FSGAnimMotionFunction_VSpring (Size: 0x18)
SGAnimMotionFunctionSelector_Vector.Function_SpringLite = 0x48 // FSGAnimMotionFunction_VSpringLite (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_SpringSmoothing = 0x58 // FSGAnimMotionFunction_VSpringSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_Damping = 0x68 // FSGAnimMotionFunction_VDamping (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_Smoothing = 0x78 // FSGAnimMotionFunction_VSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_CriticallyDampedSmoothing = 0x88 // FSGAnimMotionFunction_VCriticallyDampedSmoothing (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_SpringDamper = 0x98 // FSGAnimMotionFunction_VSpringDamper (Size: 0x10)
SGAnimMotionFunctionSelector_Vector.Function_SpringDamperSmoothing = 0xa8 // FSGAnimMotionFunction_VSpringDamperSmoothing (Size: 0x10)
SGAnimMotionFunction_RCriticallyDampedSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RDamping.Damping = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RInterp.InterpSpeed = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RInterpConstant.InterpSpeed = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSmoothing.Duration = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpring.Stiffness = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpring.Damping = 0xc // float (Size: 0x4)
SGAnimMotionFunction_RSpring.Mass = 0x10 // float (Size: 0x4)
SGAnimMotionFunction_RSpringDamper.UndampedFrequency = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpringDamper.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_RSpringDamperSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpringDamperSmoothing.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_RSpringLite.NaturalFrequency = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpringLite.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_RSpringSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_RSpringSmoothing.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_VCriticallyDampedSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VDamping.Damping = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VInterp.InterpSpeed = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VInterpConstant.InterpSpeed = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSmoothing.Duration = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpring.Stiffness = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpring.Damping = 0xc // float (Size: 0x4)
SGAnimMotionFunction_VSpring.Mass = 0x10 // float (Size: 0x4)
SGAnimMotionFunction_VSpringDamper.UndampedFrequency = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpringDamper.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_VSpringDamperSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpringDamperSmoothing.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_VSpringLite.NaturalFrequency = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpringLite.DampingRatio = 0xc // float (Size: 0x4)
SGAnimMotionFunction_VSpringSmoothing.SmoothingTime = 0x8 // float (Size: 0x4)
SGAnimMotionFunction_VSpringSmoothing.DampingRatio = 0xc // float (Size: 0x4)
SGAnimTakeCoverInfo.bIsTakingCover = 0x0 // bool (Size: 0x1)
SGAnimTakeCoverInfo.bLastTimeCrouchState = 0x1 // bool (Size: 0x1)
SGAnimTakeCoverInfo.CharacterLeanType = 0x2 // EETakeCoverLeanAnimType (Size: 0x1)
SGAnimTakeCoverInfo.CharacterCoverState = 0x3 // EESGCharacterCoverState (Size: 0x1)
SGAnimTakeCoverInfo.TranslationAnimProcess = 0x4 // float (Size: 0x4)
SGAnimTakeCoverInfo.CoverAimingState = 0x8 // EESGCharacterCoverAimingState (Size: 0x1)
SGAnimTakeCoverInfo.CoverHeightValue = 0xc // float (Size: 0x4)
SGAnimTakeCoverInfo.ToCoverPercent = 0x10 // float (Size: 0x4)
SGAnimTakeCoverInfo.CoverType = 0x14 // EESGCoverType (Size: 0x1)
SGAnimTakeCoverInfo.CoverHeightType = 0x15 // EESGCoverHeight (Size: 0x1)
SGAnimWeaponInfo.FinalRecoilAlpha = 0x0 // float (Size: 0x4)
SGAnimWeaponInfo.MeleeRecoilRotation = 0x4 // FRotator (Size: 0xc)
SGAnimWeaponInfo.WeaponStabilityAlpha = 0x10 // float (Size: 0x4)
SGAnimWeaponInfo.AimingScale = 0x14 // float (Size: 0x4)
SGAnimWeaponInfo.ForegripType = 0x18 // EESGWeaponForegripType (Size: 0x1)
SGAnimWeaponInfo.WeaponSwayAlpha_Yaw = 0x1c // float (Size: 0x4)
SGAnimWeaponInfo.WeaponSwayAlpha_Pitch = 0x20 // float (Size: 0x4)
SGAnimWeaponInfo.WeaponSwayDelay_Yaw = 0x24 // float (Size: 0x4)
SGAnimWeaponInfo.WeaponSwayDelay_Pitch = 0x28 // float (Size: 0x4)
SGAnimWeaponInfo.WeaponWithStockHoldingOffset = 0x2c // FVector (Size: 0xc)
SGAnimWeaponInfo.WeaponGunTranslation = 0x38 // FVector (Size: 0xc)
SGAnimWeaponInfo.GunRotator = 0x44 // FRotator (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceLocationOffset_RightHand = 0x50 // FVector (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceRotationOffset_RightHand = 0x5c // FRotator (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceLocationOffset_LeftHand = 0x68 // FVector (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceRotationOffset_LeftHand = 0x74 // FRotator (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceRUpperArmRot = 0x80 // FRotator (Size: 0xc)
SGAnimWeaponInfo.WeaponTraceRForeArm1Rot = 0x8c // FRotator (Size: 0xc)
SGAnimationBoneModifierInfo.BoneTranslation = 0x0 // FVector (Size: 0xc)
SGAnimationBoneModifierInfo.BoneRotation = 0xc // FRotator (Size: 0xc)
SGAnimationBoneModifierInfo.ShoeBoneScaleList = 0x18 // TArray<float> (Size: 0x10)
SGAnimationBreathInfo.BreathTranslation = 0x0 // FVector (Size: 0xc)
SGAnimationBreathInfo.BreathRotation = 0xc // FRotator (Size: 0xc)
SGAnimationDebugLogContainer.Logs = 0x0 // TArray<FSGAnimationDebugLogLine> (Size: 0x10)
SGAnimationDebugLogLine.Data = 0x0 // FString (Size: 0x10)
SGAnimationDebugLogLine.Color = 0x10 // FLinearColor (Size: 0x10)
SGAssembleBase.AssembleInfoArray = 0x310 // TArray<FWeaponAssembleEnvironmentInfo> (Size: 0x10)
SGAssembleBase.BaseSkeletalMeshComp = 0x320 // SkeletalMeshComponent* (Size: 0x8)
SGAssembleBase.BaseStaticMeshComp = 0x328 // StaticMeshComponent* (Size: 0x8)
SGAssembleBase.Config = 0x330 // SGConfigUtil* (Size: 0x8)
SGAssembleBase.Bounds = 0x338 // FBox (Size: 0x1c)
SGAssembleBase.BaseBounds = 0x354 // FBox (Size: 0x1c)
SGAssembleBase.InvBulletInfos = 0x370 // TMap<...> (Size: 0x50)
SGAssembleBase.CachedInv = 0x3c0 // SGInventory* (Size: 0x8)
SGAssembleBase.ConfigClass = 0x3c8 // ClassProperty (Size: 0x8)
SGAssembleBase.ILCQ_Type = 0x3d0 // uint8_t (Size: 0x1)
SGAssembleBase.LightChannel = 0x3d4 // int32_t (Size: 0x4)
SGAssembleBase.Margin = 0x3d8 // float (Size: 0x4)
SGAssembleBase.AnimInstance = 0x3e0 // ClassProperty (Size: 0x8)
SGAssembleBase.LoadedMesh = 0x3e8 // TMap<...> (Size: 0x50)
SGAssembleBase.AdditionalCameraPosXForAdapter = 0x438 // TMap<...> (Size: 0x50)
SGAssembleBase.AdditionalCameraPosXsInCollapseForAdapter = 0x488 // TMap<...> (Size: 0x50)
SGAssembleBase.AdditionalRenderCalcZInCollapseForAdapter = 0x4d8 // TMap<...> (Size: 0x50)
SGAssembleBase.AsStatic = 0x528 // bool (Size: 0x1)
SGAssembleBase.CollapseInvIDAnimMap = 0x560 // TMap<...> (Size: 0x50)
SGAssembleBase.CurrentAssembleInv = 0x5b0 // SGInventory* (Size: 0x8)
SGAssembleBase.CachedInvSkinMatInfo = 0x5b8 // FMeshSkinMaterialInfo (Size: 0x18)
SGAssembleBase.LoadedExtraMeshs = 0x5d8 // TMap<...> (Size: 0x50)
SGAssembleBase.LoadedShelfMesh = 0x630 // Object* (Size: 0x8)
SGAssembleBase.CueSpawnedComponents = 0x640 // TArray<PrimitiveComponent*> (Size: 0x10)
SGAudioGameSettings_HD.PhysicalSurfaceSwitches = 0x48 // FString (Size: 0x10)
SGAutoTestNote.NoteIndex = 0x310 // int32_t (Size: 0x4)
SGAvatarAnimRetargetData.bEnableRetarget = 0x0 // bool (Size: 0x1)
SGAvatarAnimRetargetData.RetargetTargetMesh = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGAvatarAnimRetargetData.bEnableRetargetLegIK = 0x30 // bool (Size: 0x1)
SGAvatarAnimRetargetData.RetargetLegIKAlpha = 0x34 // float (Size: 0x4)
SGAvatarAnimRetargetData.PelvisAdditiveTranslation = 0x38 // FVector (Size: 0xc)
SGAvatarAnimRetargetData.PelvisAdditiveRotation = 0x44 // FRotator (Size: 0xc)
SGAvatarAnimRetargetData.LeftFootIKBoneScaleValue = 0x50 // FVector (Size: 0xc)
SGAvatarAnimRetargetData.LeftFootIKBoneTranslationOffset = 0x5c // FVector (Size: 0xc)
SGAvatarAnimRetargetData.LeftFootIKBoneRotationOffset = 0x68 // FRotator (Size: 0xc)
SGAvatarAnimRetargetData.RightFootIKBoneScaleValue = 0x74 // FVector (Size: 0xc)
SGAvatarAnimRetargetData.RightFootIKBoneTranslationOffset = 0x80 // FVector (Size: 0xc)
SGAvatarAnimRetargetData.RightFootIKBoneRotationOffset = 0x8c // FRotator (Size: 0xc)
SGAvatarData.AvatarID = 0x8 // int64_t (Size: 0x8)
SGAvatarData.AvatarClass = 0x10 // ClassProperty (Size: 0x8)
SGAvatarData.bPutOnOrTakeOff = 0x18 // int32_t (Size: 0x4)
SGAvatarData.bIsIgnoredAvatar3P = 0x1c // bool (Size: 0x1)
SGAvatarInfo.ItemId = 0x0 // uint64_t (Size: 0x8)
SGAvatarInfo.EnableState = 0x8 // bool (Size: 0x1)
SGAvatarInfo.bIsHeadAvatar = 0x9 // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.WearableMesh = 0x0 // FWearableMesh (Size: 0x458)
SGAvatarInventoryEquipMeshComponentTemplateData.AdditionalWearableInventories = 0x458 // TArray<int64_t> (Size: 0x10)
SGAvatarInventoryEquipMeshComponentTemplateData.LayerIndex = 0x468 // int32_t (Size: 0x4)
SGAvatarInventoryEquipMeshComponentTemplateData.bDefaultPutOnOrTakeOffState = 0x46c // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.ItemLevel = 0x470 // int32_t (Size: 0x4)
SGAvatarInventoryEquipMeshComponentTemplateData.TranslucencySortPriority = 0x474 // int32_t (Size: 0x4)
SGAvatarInventoryEquipMeshComponentTemplateData.BoneModifyInfoList = 0x478 // TArray<FBoneModifyInfo> (Size: 0x10)
SGAvatarInventoryEquipMeshComponentTemplateData.ForceUseLobbyMesh = 0x488 // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.HideBackPistol = 0x489 // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.BadgeAttachOffset = 0x48c // FVector (Size: 0xc)
SGAvatarInventoryEquipMeshComponentTemplateData.bIsAdapter = 0x498 // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.bCanPlayAnimation = 0x499 // bool (Size: 0x1)
SGAvatarInventoryEquipMeshComponentTemplateData.SGKawaiiPhysicsParams = 0x4a0 // FSGKawaiiPhysicsParam (Size: 0x20)
SGAvatarInventoryEquipMeshComponentTemplateData.SGKawaiiPhysicsParams_Game = 0x4c0 // FSGKawaiiPhysicsParam (Size: 0x20)
SGAvatarInventoryEquipMeshComponentTemplateData.RetargetOptionsInLobby = 0x4e0 // FSGAvatarAnimRetargetData (Size: 0x98)
SGAvatarRuntimeInstanced.AvatarID = 0x0 // int64_t (Size: 0x8)
SGAvatarRuntimeInstanced.bPutOnOrTakeOff = 0x8 // int32_t (Size: 0x4)
SGAvatarRuntimeInstanced.ParentAvatarID = 0x10 // int64_t (Size: 0x8)
SGAvatarRuntimeInstanced.bIsIgnoredAvatar3P = 0x18 // bool (Size: 0x1)
SGAvatarRuntimeInstanced.bIsFriendly = 0x19 // bool (Size: 0x1)
SGAvatarRuntimeInstanced.EquipMeshComponent = 0x20 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGAvatarTemplateData.ItemId = 0x8 // int64_t (Size: 0x8)
SGAvatarTemplateData.AvatarType = 0x10 // EESGAvatarType (Size: 0x1)
SGAvatarTemplateData.AvatarSize = 0x11 // EEWearableMeshSizeType (Size: 0x1)
SGAvatarTemplateData.bIsMergedAvatar3P = 0x28 // bool (Size: 0x1)
SGAvatarTemplateData.IsNoMesh = 0x29 // bool (Size: 0x1)
SGAvatarTemplateData.AvatarInventoryEquipMeshComponentTemplateData = 0x30 // FSGAvatarInventoryEquipMeshComponentTemplateData (Size: 0x578)
SGAvatarTemplateData.Priority = 0x5a8 // int32_t (Size: 0x4)
SGBackpackAnimInstance.LocalProxy = 0x2c0 // FSGBackpackAnimInstanceProxy (Size: 0x8a0)
SGBackpackAnimInstanceProxy.AnimInstance = 0x890 // SGBackpackAnimInstance* (Size: 0x8)
SGBadgeInfo.ItemId = 0x0 // uint64_t (Size: 0x8)
SGBadgeInfo.Index = 0x8 // uint32_t (Size: 0x4)
SGBagGridInfo.ItemId = 0x0 // int32_t (Size: 0x4)
SGBagGridInfo.Inventory = 0x8 // Actor* (Size: 0x8)
SGBaseItemInfo.ItemId = 0x0 // uint64_t (Size: 0x8)
SGBaseItemInfo.ItemNum = 0x8 // int32_t (Size: 0x4)
SGBlackStore.InteractableBox = 0x310 // BoxComponent* (Size: 0x8)
SGBlackStore.TraceConfigID = 0x318 // int32_t (Size: 0x4)
SGBlackStore.NormalBlackStoreItemPlanList = 0x320 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBlackStore.BlockadeBlackStoreItemPlanList = 0x330 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBlackStore.StrongBlockadeBlackStoreItemPlanList = 0x340 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBlackStore.BlackStoreItems = 0x350 // TArray<FBlackStoreItem> (Size: 0x10)
SGBlackStoreSpawnGroup.RandomSpawnPoint = 0x310 // TArray<Actor*> (Size: 0x10)
SGBlackStoreSpawnGroup.BlackStoreClass = 0x320 // ClassProperty (Size: 0x8)
SGBlackStoreSpawnGroup.NormalBlackStoreItemPlan = 0x328 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBlackStoreSpawnGroup.BlockadeBlackStoreItemPlanList = 0x338 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBlackStoreSpawnGroup.StrongBlockadeBlackStoreItemPlanList = 0x348 // TArray<FBlackStorePlanInfo> (Size: 0x10)
SGBloodSplatterData_HD.DecalResource = 0x30 // FImpactDecalResource_HD (Size: 0x58)
SGBloodSplatterData_HD.SplatterDistance = 0x88 // float (Size: 0x4)
SGBloodSplatterData_HD.DeflectionRange = 0x8c // float (Size: 0x4)
SGBloodSplatterData_HD.ScaleCurveByDamage = 0x90 // FRuntimeFloatCurve (Size: 0x88)
SGBloodSplatterData_HD.TriggerProbability = 0x118 // float (Size: 0x4)
SGBreakableItem.BreakableMesh = 0x310 // StaticMeshComponent* (Size: 0x8)
SGBreakableItem.BrokenPSTemplateList = 0x318 // TArray<ParticleSystem*> (Size: 0x10)
SGBreakableItem.BreakInfo = 0x328 // FBreakInfo (Size: 0x14)
SGBringOutTeamItemInfo.TeammateGID = 0x0 // uint64_t (Size: 0x8)
SGBringOutTeamItemInfo.EquipPlayeritemList = 0x8 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGBulletID.FireID = 0x0 // int64_t (Size: 0x8)
SGBulletID.ShotIndex = 0x8 // uint8_t (Size: 0x1)
SGBulletInMagazine.MeshComponent = 0x0 // StaticMeshComponent* (Size: 0x8)
SGBulletMovementComponent.FlyVelocityToDistanceCurve = 0x230 // CurveFloat* (Size: 0x8)
SGBulletMovementComponent.XAxis = 0x238 // float (Size: 0x4)
SGBulletMovementComponent.LastXAxis = 0x23c // float (Size: 0x4)
SGBulletMovementComponent.InitSpeed = 0x240 // float (Size: 0x4)
SGBulletMovementComponent.InitFlyDir = 0x244 // FVector (Size: 0xc)
SGBulletMovementComponent_HD.ProjectileGravityScale = 0x138 // float (Size: 0x4)
SGBulletMovementComponent_HD.MaxSimulationTimeStep = 0x13c // float (Size: 0x4)
SGBulletMovementComponent_HD.MaxSimulationIterations = 0x140 // int32_t (Size: 0x4)
SGBulletMovementComponent_HD.DebugBulletTrace = 0x1a8 // uint8_t (Size: 0x1)
SGBulletMovementComponent_HD.RicochetData = 0x1c0 // SGImpactRicochetData_HD* (Size: 0x8)
SGBulletPath.InitDirection = 0x0 // FVector (Size: 0xc)
SGBulletPath.PathPoints = 0x10 // TArray<FSGPointDamageEvent> (Size: 0x10)
SGBulletShellEffect_HD.MeshComponent = 0x358 // StaticMeshComponent* (Size: 0x8)
SGBulletShellEffect_HD.CustomFovComponent = 0x360 // SGCustomFOVRenderMatrixComponent* (Size: 0x8)
SGBulletShellEffect_HD.MotionBlurComponent = 0x368 // MaterialBillboardComponent* (Size: 0x8)
SGBulletShellEffect_HD.MotionBlurStrengthCurve = 0x370 // CurveFloat* (Size: 0x8)
SGBurnableItem.BurningMesh = 0x310 // StaticMeshComponent* (Size: 0x8)
SGBurnableItem.BurningMaterial = 0x318 // MaterialInstance* (Size: 0x8)
SGBurnableItem.BurningMaterialParamsInfo = 0x320 // TArray<FTempBurningMaterialParamInfo> (Size: 0x10)
SGBurnableItem.BurningMaterialParamDuration = 0x330 // float (Size: 0x4)
SGBurnableItem.SpreadCheckInterval = 0x334 // float (Size: 0x4)
SGBurnableItem.BurningPSC = 0x338 // ParticleSystemComponent* (Size: 0x8)
SGBurnableItem.Damage = 0x340 // float (Size: 0x4)
SGBurnableItem.DamageSphere = 0x348 // SphereComponent* (Size: 0x8)
SGBurnableItem.BurningInfo = 0x350 // FTempBurningInfo (Size: 0x8)
SGBurnableItem.BurningMaterialRuntime = 0x358 // MaterialInstanceDynamic* (Size: 0x8)
SGBurnableItem.EnvSystem = 0x368 // MFEnvSystem* (Size: 0x8)
SGBurnableItemComponent.BurningMaterial = 0x238 // MaterialInstance* (Size: 0x8)
SGBurnableItemComponent.BurningMaterialParamsInfo = 0x240 // TArray<FBurningMaterialParamInfo> (Size: 0x10)
SGBurnableItemComponent.BurningMaterialParamDuration = 0x250 // float (Size: 0x4)
SGBurnableItemComponent.SpreadCheckInterval = 0x254 // float (Size: 0x4)
SGBurnableItemComponent.SetFireCheckInterval = 0x258 // float (Size: 0x4)
SGBurnableItemComponent.BurningPS = 0x260 // ParticleSystem* (Size: 0x8)
SGBurnableItemComponent.BurningPSC = 0x268 // ParticleSystemComponent* (Size: 0x8)
SGBurnableItemComponent.Damage = 0x270 // float (Size: 0x4)
SGBurnableItemComponent.DamageSphere = 0x278 // SphereComponent* (Size: 0x8)
SGBurnableItemComponent.BurningInfo = 0x280 // FBurningInfo (Size: 0x8)
SGBurnableItemComponent.BurningMaterialRuntime = 0x288 // MaterialInstanceDynamic* (Size: 0x8)
SGBurnableItemComponent.EnvSystem = 0x2a0 // MFEnvSystem* (Size: 0x8)
SGBusinessmanInfo.BusinessmanID = 0x0 // int32_t (Size: 0x4)
SGBusinessmanInfo.Reputation = 0x4 // int32_t (Size: 0x4)
SGBusinessmanInfo.Level = 0x8 // int32_t (Size: 0x4)
SGBusinessmanInfo.bisUnlock = 0xc // bool (Size: 0x1)
SGBusinessmanInfo.StageId = 0x10 // int32_t (Size: 0x4)
SGCachedWeaponSpecialSpecAnimList.AnimList = 0x0 // TArray<FSGWeaponSpecialSpecAnimationRow> (Size: 0x10)
SGCameraDOF.bAdjustDOF = 0x28 // bool (Size: 0x1)
SGCameraDOF.bForceChooseThisDOF = 0x29 // bool (Size: 0x1)
SGCameraDOF.RelativeForwardOffset = 0x2c // float (Size: 0x4)
SGCameraDOF.DepthOfFieldFstop = 0x30 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldMinFstop = 0x34 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldBladeCount = 0x38 // int32_t (Size: 0x4)
SGCameraDOF.DepthOfFieldSensorWidth = 0x3c // float (Size: 0x4)
SGCameraDOF.DepthOfFieldFocalDistance = 0x40 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldDepthBlurAmount = 0x44 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldDepthBlurRadius = 0x48 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldMaxBackgroundRadius = 0x4c // float (Size: 0x4)
SGCameraDOF.DepthOfFieldFocalRegion = 0x50 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldNearTransitionRegion = 0x54 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldFarTransitionRegion = 0x58 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldScale = 0x5c // float (Size: 0x4)
SGCameraDOF.DepthOfFieldNearBlurSize = 0x60 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldFarBlurSize = 0x64 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldOcclusion = 0x68 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldSkyFocusDistance = 0x6c // float (Size: 0x4)
SGCameraDOF.DepthOfFieldVignetteSize = 0x70 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldDistanceInterpSpeed = 0x74 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldRadiusFalloff = 0x78 // float (Size: 0x4)
SGCameraDOF.DepthOfFieldRadiusRange = 0x7c // FVector2D (Size: 0x8)
SGCameraDOF.DepthOfFieldRadiusDistRange = 0x84 // FVector2D (Size: 0x8)
SGCameraDOF.EnableForegroundOnlyDOF = 0x8c // bool (Size: 0x1)
SGCameraDOF.PlayerCameraManager = 0x98 // PlayerCameraManager* (Size: 0x8)
SGCameraDOF_ADS.DebugComponent = 0xa0 // SGCameraDebugComponent* (Size: 0x8)
SGCameraDOF_ADS.ScopeLevel = 0xa8 // int32_t (Size: 0x4)
SGCameraDOF_ADS.UABlurScopeTexture = 0xb0 // Texture* (Size: 0x8)
SGCameraDOF_ADS.UABlurIntensity = 0xb8 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurScopeInnerEdge = 0xbc // float (Size: 0x4)
SGCameraDOF_ADS.UABlurScopeOutterEdge = 0xc0 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurDepthBlackPoint = 0xc4 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurDepthWhitePoint = 0xc8 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurDepthGamma = 0xcc // float (Size: 0x4)
SGCameraDOF_ADS.UAScopeRadiusMul = 0xd0 // float (Size: 0x4)
SGCameraDOF_ADS.UAScopeRadiusAdd = 0xd4 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurReticleCenter = 0xd8 // FVector2D (Size: 0x8)
SGCameraDOF_ADS.UABlurReticleSize = 0xe0 // float (Size: 0x4)
SGCameraDOF_ADS.UABlurReticleRotation = 0xf0 // FVector4 (Size: 0x10)
SGCameraDOF_ADS.bUABlurUseBranching = 0x100 // bool (Size: 0x1)
SGCameraDOF_ADS.ReticleCenterMoveScale_Yaw = 0x104 // float (Size: 0x4)
SGCameraDOF_ADS.ReticleCenterMoveScale_Pitch = 0x108 // float (Size: 0x4)
SGCameraDOF_ADS.ReticleBeforeActiveTime = 0x10c // float (Size: 0x4)
SGCameraDOF_ADS.bEnableReticleSway = 0x110 // bool (Size: 0x1)
SGCameraDOF_ADS.bEnableReticleBreath = 0x111 // bool (Size: 0x1)
SGCameraDOF_ADS.bEnableDebug = 0x112 // bool (Size: 0x1)
SGCameraDOF_ADS.SwayInterpSpeed = 0x114 // float (Size: 0x4)
SGCameraDOF_ADS.SwayScale_Horizontal = 0x118 // float (Size: 0x4)
SGCameraDOF_ADS.SwayScale_Vertical = 0x11c // float (Size: 0x4)
SGCameraDOF_ADS.MaxSwayAmount_Horizontal = 0x120 // float (Size: 0x4)
SGCameraDOF_ADS.MaxSwayAmount_Vertical = 0x124 // float (Size: 0x4)
SGCameraDebugComponent.bDrawWorstLocation = 0x100 // bool (Size: 0x1)
SGCameraDebugComponent.bDrawLineTrace = 0x101 // bool (Size: 0x1)
SGCameraDebugComponent.bDrawDesireLocationBeforeAfter = 0x102 // bool (Size: 0x1)
SGCameraDebugComponent.bDrawDOFFocalPoint = 0x103 // bool (Size: 0x1)
SGCameraFOV.FOV = 0x28 // float (Size: 0x4)
SGCameraFOV.BlendTime = 0x2c // float (Size: 0x4)
SGCameraMaterial.MaterialTemplate = 0x30 // MaterialInterface* (Size: 0x8)
SGCameraMaterial.MaterialTemplate_Harmonization = 0x38 // MaterialInterface* (Size: 0x8)
SGCameraMaterial.MaterialInstance = 0x40 // MaterialInstanceDynamic* (Size: 0x8)
SGCameraMaterial.GameplayToListenList = 0x48 // TArray<FGameplayTag> (Size: 0x10)
SGCameraMaterial.bStopOnDeath = 0x61 // bool (Size: 0x1)
SGCameraMaterial.bStopImmediatelyOnDeath = 0x62 // bool (Size: 0x1)
SGCameraMaterial.FadeInTime = 0x64 // float (Size: 0x4)
SGCameraMaterial.FadeOutTime = 0x68 // float (Size: 0x4)
SGCameraMaterial.MaxBlendWeight = 0x6c // float (Size: 0x4)
SGCameraMaterial.PostProcessSettings = 0x70 // FPostProcessSettings (Size: 0x690)
SGCameraMaterial.OwnedTag = 0x700 // FGameplayTag (Size: 0x8)
SGCameraMaterial.BlockedByTags = 0x708 // FGameplayTagContainer (Size: 0x20)
SGCameraMaterial.Priority = 0x728 // int32_t (Size: 0x4)
SGCameraMaterialAfterHeatTickFunction.Target = 0x38 // SGCameraMaterial_AfterHeat* (Size: 0x8)
SGCameraMaterialCrossHairTickFunction.Target = 0x38 // SGCameraMaterial_CrossHair* (Size: 0x8)
SGCameraMaterialLensDistortTickFunction.Target = 0x38 // SGCameraMaterial_LensDistort* (Size: 0x8)
SGCameraMaterialSpec.CameraMaterial = 0x0 // SGCameraMaterial* (Size: 0x8)
SGCameraMaterial_AfterHeat.CurvePeriod = 0x730 // float (Size: 0x4)
SGCameraMaterial_AfterHeat.AfterHeatCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_AfterHeat.AfterHeatThreshold = 0x740 // float (Size: 0x4)
SGCameraMaterial_AfterHeat.AfterHeatDecreaseRate = 0x744 // float (Size: 0x4)
SGCameraMaterial_AfterHeat.TickFunction = 0x760 // FSGCameraMaterialAfterHeatTickFunction (Size: 0x40)
SGCameraMaterial_AidRoulette.MaterialTemplateBlurX = 0x730 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_AidRoulette.MaterialTemplateBlurY = 0x738 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_AidRoulette.MaterialInstances = 0x740 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGCameraMaterial_AidRoulette.QuadBlueParamName = 0x750 // FName (Size: 0x8)
SGCameraMaterial_BanZone.FlickEffectStrengthCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BanZone.FlickEffectStrength = 0x738 // float (Size: 0x4)
SGCameraMaterial_BanZone.FadeParam = 0x73c // FName (Size: 0x8)
SGCameraMaterial_BanZone.FlickParam = 0x744 // FName (Size: 0x8)
SGCameraMaterial_BanZone.CameraShakeRatioCurve = 0x750 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BanZone.CameraShakeRatioParam = 0x758 // FName (Size: 0x8)
SGCameraMaterial_Bleed.WireCoolDownTime = 0x730 // float (Size: 0x4)
SGCameraMaterial_Bleed.BloodDropMaxCount = 0x738 // int32_t (Size: 0x4)
SGCameraMaterial_Bleed.TriggeredByTagConfig = 0x73c // FBloodRandomConfig (Size: 0x40)
SGCameraMaterial_Bleed.TriggeredByWireConfig = 0x77c // FBloodRandomConfig (Size: 0x40)
SGCameraMaterial_Bleed.TriggeredBySelfConfig = 0x7bc // FBloodRandomConfig (Size: 0x40)
SGCameraMaterial_Bleed.TriggeredPenetrateArmorConfig = 0x7fc // FBloodRandomConfig (Size: 0x40)
SGCameraMaterial_Bleed.BloodFadeParamName = 0x83c // FName (Size: 0x8)
SGCameraMaterial_Bleed.AlphaParamName = 0x844 // FName (Size: 0x8)
SGCameraMaterial_Bleed.BloodScaleParamName = 0x84c // FName (Size: 0x8)
SGCameraMaterial_Bleed.PositionXParamName = 0x854 // FName (Size: 0x8)
SGCameraMaterial_Bleed.PositionYParamName = 0x85c // FName (Size: 0x8)
SGCameraMaterial_Bleed.RotationAngleParamName = 0x864 // FName (Size: 0x8)
SGCameraMaterial_Bleed.BloodDropParamsList = 0x870 // TArray<FBloodDropParams> (Size: 0x10)
SGCameraMaterial_BloodScreen.EffectDuration = 0x730 // float (Size: 0x4)
SGCameraMaterial_BloodScreen.EffectStrengthCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BloodScreen.BrokeBoneRunCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BloodScreen.GrenadeCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BloodScreen.StrengthParamName = 0x750 // FName (Size: 0x8)
SGCameraMaterial_BloodScreen.DefaultEffectStrength = 0x758 // float (Size: 0x4)
SGCameraMaterial_BrokenLeg.ClearRadiusCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BrokenLeg.DarkRadiusCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BrokenLeg.ClearParamName = 0x740 // FName (Size: 0x8)
SGCameraMaterial_BrokenLeg.DarkParamName = 0x748 // FName (Size: 0x8)
SGCameraMaterial_BrokenLeg.EffectDuration = 0x750 // float (Size: 0x4)
SGCameraMaterial_BulletDeflected.Duration = 0x730 // float (Size: 0x4)
SGCameraMaterial_BulletDeflected.GhostStrengthCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BulletDeflected.BlurStrengthCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BulletDeflected.OpacityCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_BulletDeflected.GhostStrengthParamName = 0x750 // FName (Size: 0x8)
SGCameraMaterial_BulletDeflected.BlurStrengthParamName = 0x758 // FName (Size: 0x8)
SGCameraMaterial_BulletDeflected.OpacityParamName = 0x760 // FName (Size: 0x8)
SGCameraMaterial_Clear.Saturation = 0x730 // float (Size: 0x4)
SGCameraMaterial_Clear.Gain = 0x734 // float (Size: 0x4)
SGCameraMaterial_Clear.Offset = 0x738 // float (Size: 0x4)
SGCameraMaterial_Clear.BaseSaturation = 0x73c // float (Size: 0x4)
SGCameraMaterial_Clear.BaseGain = 0x740 // float (Size: 0x4)
SGCameraMaterial_Clear.Shaperness = 0x744 // float (Size: 0x4)
SGCameraMaterial_Clear.ShapernessParamName = 0x748 // FName (Size: 0x8)
SGCameraMaterial_CrossHair.WeaponGlobal = 0x730 // MaterialParameterCollection* (Size: 0x8)
SGCameraMaterial_CrossHair.SwitchProgressThreshold = 0x738 // float (Size: 0x4)
SGCameraMaterial_CrossHair.ScopeMaterialTemplate = 0x740 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_CrossHair.ScopeMaterialInstance = 0x748 // MaterialInstanceDynamic* (Size: 0x8)
SGCameraMaterial_CrossHair.bEnableScopeMaskShelter = 0x750 // bool (Size: 0x1)
SGCameraMaterial_CrossHair.RangeScope = 0x7a8 // SGInventory* (Size: 0x8)
SGCameraMaterial_CrossHair.TickFunction = 0x7b0 // FSGCameraMaterialCrossHairTickFunction (Size: 0x40)
SGCameraMaterial_Drought.PercentThresholdShowingDrought = 0x730 // float (Size: 0x4)
SGCameraMaterial_Dying.PercentThresholdShowingDying = 0x730 // float (Size: 0x4)
SGCameraMaterial_Dying.FadeOutDurationAfterDeath = 0x734 // float (Size: 0x4)
SGCameraMaterial_Dying.BlendWeight = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Dying.DyingWhiteTemp = 0x740 // float (Size: 0x4)
SGCameraMaterial_Dying.DyingContrast = 0x750 // FVector4 (Size: 0x10)
SGCameraMaterial_Dying.DyingSaturation = 0x760 // FVector4 (Size: 0x10)
SGCameraMaterial_Dying.DyingColorGain = 0x770 // FVector4 (Size: 0x10)
SGCameraMaterial_Dying.DyingColorOffset = 0x780 // FVector4 (Size: 0x10)
SGCameraMaterial_Dying.EyeCloseCurveList = 0x790 // TArray<FRandomDyingCurveSet> (Size: 0x10)
SGCameraMaterial_Dying.TDMEyeCloseCurveList = 0x7a0 // TArray<FRandomDyingCurveSet> (Size: 0x10)
SGCameraMaterial_Dying.EyeCloseAudio = 0x7c0 // AkAudioEvent* (Size: 0x8)
SGCameraMaterial_Dying.HeadPercentThresholdShowingDying = 0x7cc // float (Size: 0x4)
SGCameraMaterial_Dying.ChestPercentThresholdShowingDying = 0x7d0 // float (Size: 0x4)
SGCameraMaterial_Dying.AllPercentThresholdShowingDying = 0x7d4 // float (Size: 0x4)
SGCameraMaterial_Dying.DyingPercentToBloodDropStrengthCurve = 0x7d8 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Dying.DyingPercentToBloodVesselStrengthCurve = 0x7e0 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Dying.DyingPercentToFractionCurve = 0x7e8 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Dying.DeathEffectDuration = 0x7f0 // float (Size: 0x4)
SGCameraMaterial_Dying.DeathEffectCurve = 0x7f8 // FRuntimeFloatCurve (Size: 0x88)
SGCameraMaterial_Dying.FractionParamName = 0x880 // FName (Size: 0x8)
SGCameraMaterial_Dying.DesaturationParamName = 0x888 // FName (Size: 0x8)
SGCameraMaterial_Dying.BloodDropStrengthParamName = 0x890 // FName (Size: 0x8)
SGCameraMaterial_Dying.VesselStrengthParamName = 0x898 // FName (Size: 0x8)
SGCameraMaterial_FaceShield.DurabilityPercentForOneCrack = 0x730 // float (Size: 0x4)
SGCameraMaterial_FaceShield.DistortionParam = 0x734 // float (Size: 0x4)
SGCameraMaterial_FaceShield.IntensityParam = 0x738 // float (Size: 0x4)
SGCameraMaterial_FaceShield.PullAnimDuration = 0x73c // float (Size: 0x4)
SGCameraMaterial_FaceShield.PullAnimCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FaceShield.CachedFaceShield = 0x748 // SGInventory* (Size: 0x8)
SGCameraMaterial_FaceShield.CachedFaceCover = 0x750 // SGInventory* (Size: 0x8)
SGCameraMaterial_FaceShield.CachedHelmet = 0x758 // SGInventory* (Size: 0x8)
SGCameraMaterial_FaceShield.SelectedInventory = 0x760 // SGInventory* (Size: 0x8)
SGCameraMaterial_Fatigue.PercentThresholdShowingFatigue = 0x730 // float (Size: 0x4)
SGCameraMaterial_FlashGrenade.MaterialTemplate_Flash = 0x730 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_FlashGrenade.MaterialTemplate_Zarya = 0x738 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_FlashGrenade.MaterialInstance_Flash = 0x740 // MaterialInstanceDynamic* (Size: 0x8)
SGCameraMaterial_FlashGrenade.MaterialInstance_Zarya = 0x748 // MaterialInstanceDynamic* (Size: 0x8)
SGCameraMaterial_FlashGrenade.FlashDuration = 0x750 // float (Size: 0x4)
SGCameraMaterial_FlashGrenade.FlashScaleX = 0x754 // float (Size: 0x4)
SGCameraMaterial_FlashGrenade.FlashScaleY = 0x758 // float (Size: 0x4)
SGCameraMaterial_FlashGrenade.OpacityCurve = 0x760 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.InnerFlareStrengthCurve = 0x768 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.EdgeFlareStrengthCurve = 0x770 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.FlashWhiteCurve = 0x778 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.GhostStrengthCurve = 0x780 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.StretchStrengthCurve = 0x788 // CurveFloat* (Size: 0x8)
SGCameraMaterial_FlashGrenade.FlashDisCurveArray_StunGrenade = 0x790 // TArray<FFlashDistanceCurveSet> (Size: 0x10)
SGCameraMaterial_FlashGrenade.FlashDisCurveArray_FlashGrenade = 0x7a0 // TArray<FFlashDistanceCurveSet> (Size: 0x10)
SGCameraMaterial_FlashGrenade.OpacityParamName = 0x7b0 // FName (Size: 0x8)
SGCameraMaterial_FlashGrenade.InnerParamName = 0x7b8 // FName (Size: 0x8)
SGCameraMaterial_FlashGrenade.EdgeParamName = 0x7c0 // FName (Size: 0x8)
SGCameraMaterial_FlashGrenade.PositionAndScaleParamName = 0x7c8 // FName (Size: 0x8)
SGCameraMaterial_FlashGrenade.FlashWhiteParamName = 0x7d0 // FName (Size: 0x8)
SGCameraMaterial_Flashlight.MaxLightCount = 0x730 // int32_t (Size: 0x4)
SGCameraMaterial_Flashlight.MaxRange = 0x734 // float (Size: 0x4)
SGCameraMaterial_Flashlight.IntensityScale = 0x738 // float (Size: 0x4)
SGCameraMaterial_Flashlight.MaterialParameterCollection = 0x740 // MaterialParameterCollection* (Size: 0x8)
SGCameraMaterial_Flashlight.MaterialParameterCollectionInst = 0x748 // MaterialParameterCollectionInstance* (Size: 0x8)
SGCameraMaterial_GunMotionBlur.FireIntensityCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Hearing.ColorOffsetCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Hearing.ScreenOffsetCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Hearing.OffsetCycleCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Hearing.ColorParamName = 0x748 // FName (Size: 0x8)
SGCameraMaterial_Hearing.ScreenParamName = 0x750 // FName (Size: 0x8)
SGCameraMaterial_Hearing.ShowEffectThreshold = 0x758 // float (Size: 0x4)
SGCameraMaterial_Hearing.CyclePeriod = 0x75c // float (Size: 0x4)
SGCameraMaterial_HeatDistort.CoolDownTime = 0x750 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.LimitNumberOnce = 0x754 // int32_t (Size: 0x4)
SGCameraMaterial_HeatDistort.Duration = 0x758 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.NextFireStartPosition = 0x75c // float (Size: 0x4)
SGCameraMaterial_HeatDistort.DistortStrengthRatioCurve = 0x760 // CurveFloat* (Size: 0x8)
SGCameraMaterial_HeatDistort.DistortStrength = 0x768 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.DistortScaleYCurve = 0x770 // CurveFloat* (Size: 0x8)
SGCameraMaterial_HeatDistort.DefaultDistortScaleY = 0x778 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.DistortScaleXCurve = 0x780 // CurveFloat* (Size: 0x8)
SGCameraMaterial_HeatDistort.DefaultDistortScaleX = 0x788 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.BlurStrengthRatioCurve = 0x790 // CurveFloat* (Size: 0x8)
SGCameraMaterial_HeatDistort.BlurStrength = 0x798 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.GaussianDiffusion = 0x7c0 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.XOffsetMin = 0x7c4 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.XOffsetMax = 0x7c8 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.YOffsetMin = 0x7cc // float (Size: 0x4)
SGCameraMaterial_HeatDistort.YOffsetMax = 0x7d0 // float (Size: 0x4)
SGCameraMaterial_HeatDistort.ScaleXParamName = 0x7d8 // FName (Size: 0x8)
SGCameraMaterial_HeatDistort.FirePositionParamName = 0x7e0 // FName (Size: 0x8)
SGCameraMaterial_HeatDistort.StrengthParamName = 0x7e8 // FName (Size: 0x8)
SGCameraMaterial_HeatDistort.ScaleYParamName = 0x7f0 // FName (Size: 0x8)
SGCameraMaterial_HeatDistort.BlurStrengthParamName = 0x7f8 // FName (Size: 0x8)
SGCameraMaterial_HeatDistort.MuzzleSocketName = 0x800 // FName (Size: 0x8)
SGCameraMaterial_InTrap.fSpeed = 0x730 // float (Size: 0x4)
SGCameraMaterial_LackofSupply.BlurStrengthCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_LackofSupply.SphereMaskCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_LackofSupply.LengthCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_LackofSupply.FunctionPeriod = 0x748 // float (Size: 0x4)
SGCameraMaterial_LackofSupply.BlurStrengthParamName = 0x74c // FName (Size: 0x8)
SGCameraMaterial_LackofSupply.SphereMaskParamName = 0x754 // FName (Size: 0x8)
SGCameraMaterial_LackofSupply.LengthParamName = 0x75c // FName (Size: 0x8)
SGCameraMaterial_LensDistort.ScopeGlobal = 0x730 // MaterialParameterCollection* (Size: 0x8)
SGCameraMaterial_LensDistort.TickFunction = 0x748 // FSGCameraMaterialLensDistortTickFunction (Size: 0x40)
SGCameraMaterial_NightVision.MaterialTemplateX = 0x730 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_NightVision.WhiteBalanceTemp = 0x738 // float (Size: 0x4)
SGCameraMaterial_NightVision.DefaultAutoExposureSpeedDown = 0x73c // float (Size: 0x4)
SGCameraMaterial_NightVision.AutoExposureSpeedDown = 0x740 // float (Size: 0x4)
SGCameraMaterial_NightVision.AutoExposureMinBrightness = 0x744 // float (Size: 0x4)
SGCameraMaterial_NightVision.AutoExposureMaxBrightness = 0x748 // float (Size: 0x4)
SGCameraMaterial_NightVision.FadeInDelay = 0x74c // float (Size: 0x4)
SGCameraMaterial_NightVision.FadeOutDelay = 0x750 // float (Size: 0x4)
SGCameraMaterial_NightVision.ThermalGlobal = 0x758 // MaterialParameterCollection* (Size: 0x8)
SGCameraMaterial_NightVision.ScopeMagnificationToDistance = 0x760 // TMap<...> (Size: 0x50)
SGCameraMaterial_NightVision.DefaultDistance = 0x7b0 // float (Size: 0x4)
SGCameraMaterial_NightVision.MaterialInstances = 0x7b8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGCameraMaterial_OperationResult.BlurStrengthCurve_Win = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_OperationResult.BlurStrengthCurve_Lose = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_OperationResult.SelectedBlurStrengthCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Pain.Density = 0x730 // float (Size: 0x4)
SGCameraMaterial_Pain.Radius = 0x734 // float (Size: 0x4)
SGCameraMaterial_Pain.ClearRadius = 0x738 // float (Size: 0x4)
SGCameraMaterial_Pain.MaxLength = 0x73c // float (Size: 0x4)
SGCameraMaterial_Pain.SampleTimes = 0x740 // float (Size: 0x4)
SGCameraMaterial_Pain.bFixedBlurStrength = 0x744 // bool (Size: 0x1)
SGCameraMaterial_Pain.FixedBlurStrength = 0x748 // float (Size: 0x4)
SGCameraMaterial_Pain.BlurStrengthBase = 0x74c // float (Size: 0x4)
SGCameraMaterial_Pain.BlurStrengthSineAmplitude = 0x750 // float (Size: 0x4)
SGCameraMaterial_Pain.BlurStrengthSinePeriod = 0x754 // float (Size: 0x4)
SGCameraMaterial_Pain.BlurStrengthParamName = 0x758 // FName (Size: 0x8)
SGCameraMaterial_Pain.ClearRadiusParamName = 0x760 // FName (Size: 0x8)
SGCameraMaterial_Pain.MaxLengthParamName = 0x768 // FName (Size: 0x8)
SGCameraMaterial_Pain.SampleTimesParamName = 0x770 // FName (Size: 0x8)
SGCameraMaterial_Pain.ColorOffsetParamName = 0x778 // FName (Size: 0x8)
SGCameraMaterial_Pain.EffectStrengthCurve = 0x780 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Pain.ColorOffsetCurve = 0x788 // CurveFloat* (Size: 0x8)
SGCameraMaterial_Pain.DefaultEffectStrength = 0x790 // float (Size: 0x4)
SGCameraMaterial_Pain.FunctionPeriod = 0x794 // float (Size: 0x4)
SGCameraMaterial_RadialBlur.EffectThresholdDistance = 0x730 // float (Size: 0x4)
SGCameraMaterial_RadialBlur.RadialEffectTime = 0x734 // float (Size: 0x4)
SGCameraMaterial_RadialBlur.M67OpacityCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RadialBlur.M67RadiusCurve = 0x740 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RadialBlur.StunOpacityCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RadialBlur.StunRadiusCurve = 0x750 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RadialBlur.OpacityCurve = 0x758 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RadialBlur.RadiusCurve = 0x760 // CurveFloat* (Size: 0x8)
SGCameraMaterial_RedScreen.HeadPercentThresholdShowingDying = 0x730 // float (Size: 0x4)
SGCameraMaterial_RedScreen.ChestPercentThresholdShowingDying = 0x734 // float (Size: 0x4)
SGCameraMaterial_RedScreen.DefaultRedAlpha = 0x738 // float (Size: 0x4)
SGCameraMaterial_RedScreen.CurvePeriod = 0x73c // float (Size: 0x4)
SGCameraMaterial_RedScreen.RedAlphaParamName = 0x740 // FName (Size: 0x8)
SGCameraMaterial_RedScreen.RedScreenFadeCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_ScopeBlur.ScopeGlobal = 0x730 // MaterialParameterCollection* (Size: 0x8)
SGCameraMaterial_SmokeGrenade.SmokeOpacityCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_SmokeGrenade.DefaultOpacity = 0x738 // float (Size: 0x4)
SGCameraMaterial_SmokeGrenade.TeargasOpacity = 0x73c // float (Size: 0x4)
SGCameraMaterial_SmokeGrenade.TeargasEffectColor = 0x740 // FLinearColor (Size: 0x10)
SGCameraMaterial_SmokeGrenade.DefaultEffectColor = 0x750 // FLinearColor (Size: 0x10)
SGCameraMaterial_StunGrenade.StunDuration = 0x730 // float (Size: 0x4)
SGCameraMaterial_StunGrenade.GhostParamName = 0x734 // FName (Size: 0x8)
SGCameraMaterial_StunGrenade.StretchParamName = 0x73c // FName (Size: 0x8)
SGCameraMaterial_StunGrenade.GhostStrengthCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_StunGrenade.StretchStrengthCurve = 0x750 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.FragGrenadeData = 0x730 // FGrenadeBlurData (Size: 0x18)
SGCameraMaterial_TakeHit.OffensiveGrenadeData = 0x748 // FGrenadeBlurData (Size: 0x18)
SGCameraMaterial_TakeHit.MolotovCocktailData = 0x760 // FGrenadeBlurData (Size: 0x18)
SGCameraMaterial_TakeHit.DurationGrenade = 0x778 // float (Size: 0x4)
SGCameraMaterial_TakeHit.GrenadeExplosionThreshold = 0x77c // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthGrenadeCurve = 0x780 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.GrenadeDistanceCurve = 0x788 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.DamageThresholdLow = 0x790 // float (Size: 0x4)
SGCameraMaterial_TakeHit.DamageThresholdHigh = 0x794 // float (Size: 0x4)
SGCameraMaterial_TakeHit.Duration = 0x798 // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthCurve = 0x7a0 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.DurationPenetrateArmorLow = 0x7a8 // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthPenetrateArmorLowCurve = 0x7b0 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.DurationPenetrateArmor = 0x7b8 // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthPenetrateArmorCurve = 0x7c0 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.DurationPenetrateArmorHigh = 0x7c8 // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthPenetrateArmorHighCurve = 0x7d0 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.SelectedBlurStrengthCurve = 0x7d8 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.BlurStrengthParamName = 0x7ec // FName (Size: 0x8)
SGCameraMaterial_TakeHit.DurationWire = 0x7f4 // float (Size: 0x4)
SGCameraMaterial_TakeHit.BlurStrengthWireCurve = 0x7f8 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TakeHit.WireCoolDownTime = 0x800 // float (Size: 0x4)
SGCameraMaterial_TakeHit.ApplyTimes = 0x814 // int32_t (Size: 0x4)
SGCameraMaterial_TakeHit.MaterialTemplateBlurX = 0x818 // MaterialInterface* (Size: 0x8)
SGCameraMaterial_TakeHit.MaterialInstances = 0x820 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGCameraMaterial_TakeHitRadialBlur.RadialBlurTime = 0x730 // float (Size: 0x4)
SGCameraMaterial_TakeHitRadialBlur.RadialBlurCD = 0x734 // float (Size: 0x4)
SGCameraMaterial_TakeHitRadialBlur.MaxRadialBlurSize = 0x738 // float (Size: 0x4)
SGCameraMaterial_TearGas.StrengthCurve = 0x730 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TearGas.CoughRTPCCurve = 0x738 // CurveFloat* (Size: 0x8)
SGCameraMaterial_TearGas.HeavyCoughRTPCThreshold = 0x740 // float (Size: 0x4)
SGCameraMaterial_TearGas.HeavyCoughEffectTime = 0x744 // float (Size: 0x4)
SGCameraMaterial_TearGas.SenseAbilityComponent = 0x748 // SGCharacterSenseAbilityComponent* (Size: 0x8)
SGCameraMaterial_TearGas.SoundComponent = 0x750 // SGCharacterSoundComponent* (Size: 0x8)
SGCameraMaterial_VisionPersistence.MaterialInstanceM67 = 0x730 // MaterialInstanceDynamic* (Size: 0x8)
SGCameraMaterial_VisionPersistence.EffectDistanceConfArray = 0x738 // TArray<FEffectDistanceConfArray> (Size: 0x10)
SGCameraMaterial_VisionPersistence.BasicEffectCurve = 0x748 // CurveFloat* (Size: 0x8)
SGCameraMaterial_VisionPersistence.WhiteEffectCurve = 0x750 // CurveFloat* (Size: 0x8)
SGCameraMaterial_VisionPersistence.MovingEffectCurve = 0x758 // CurveVector* (Size: 0x8)
SGCameraMode.bKeepLastViewLimitInTransition = 0x28 // bool (Size: 0x1)
SGCameraMode.OwnerCameraStyle = 0x30 // SGCameraStyle* (Size: 0x8)
SGCameraMode.NearClippingPlane = 0x38 // float (Size: 0x4)
SGCameraMode.BlendTime = 0x3c // float (Size: 0x4)
SGCameraMode.ViewOffsetInterpScale = 0x40 // float (Size: 0x4)
SGCameraMode.bInterpLocation = 0x44 // bool (Size: 0x1)
SGCameraMode.OriginLocInterpSpeed = 0x48 // float (Size: 0x4)
SGCameraMode.bUsePerAxisOriginLocInterp = 0x4c // bool (Size: 0x1)
SGCameraMode.PerAxisOriginLocInterpSpeed = 0x50 // FVector (Size: 0xc)
SGCameraMode.InterpSpeedOverrides = 0x60 // TArray<FInterpSpeedOverride> (Size: 0x10)
SGCameraMode.bInterpRotation = 0x70 // bool (Size: 0x1)
SGCameraMode.OriginRotInterpSpeed = 0x74 // float (Size: 0x4)
SGCameraMode.bRotInterpSpeedConstant = 0x78 // bool (Size: 0x1)
SGCameraMode.MinInterpSpeed = 0x7c // float (Size: 0x4)
SGCameraMode.bInterpViewOffsetOnlyForCamTransition = 0x80 // bool (Size: 0x1)
SGCameraMode.bInterpCameraLimited = 0x81 // bool (Size: 0x1)
SGCameraMode.CameraLimitedInterpSpeed = 0x84 // float (Size: 0x4)
SGCameraMode.MaxRoll = 0x88 // float (Size: 0x4)
SGCameraMode.MinRoll = 0x8c // float (Size: 0x4)
SGCameraMode.MaxYaw = 0x90 // float (Size: 0x4)
SGCameraMode.MinYaw = 0x94 // float (Size: 0x4)
SGCameraMode.MaxPitch = 0x98 // float (Size: 0x4)
SGCameraMode.MinPitch = 0x9c // float (Size: 0x4)
SGCameraMode.PrevMode = 0xa0 // SGCameraMode* (Size: 0x8)
SGCameraMode.bNextModeInterpCameraLimited = 0xb0 // bool (Size: 0x1)
SGCameraModifier_LookAround_HD.InterpSpeedWhileReplaying = 0x48 // float (Size: 0x4)
SGCameraModifier_LookAround_HD.InterpSpeedWhileBeingSpectated = 0x4c // float (Size: 0x4)
SGCameraShake.OscillationBlendCurve = 0x178 // CurveFloat* (Size: 0x8)
SGCameraShake.bUseCustomOscillator = 0x180 // bool (Size: 0x1)
SGCameraShake.bShowCameraShakeInfo = 0x181 // bool (Size: 0x1)
SGCameraShake.OscillatorInfoSettings = 0x188 // TArray<FOscillatorInfo> (Size: 0x10)
SGCameraShake.FOVToFOVAmplitudeCurve = 0x198 // CurveFloat* (Size: 0x8)
SGCameraShake.bUseFixedStep = 0x1a0 // bool (Size: 0x1)
SGCameraShake.bClampSineOffsetWhenOverPeak = 0x1a1 // bool (Size: 0x1)
SGCameraShake.bClampSineOffsetWhenExtremePoint = 0x1a2 // bool (Size: 0x1)
SGCameraShake.AmplitudeCurve = 0x1a8 // CurveFloat* (Size: 0x8)
SGCameraShake.CurveAdditiveMaxTime = 0x1b0 // float (Size: 0x4)
SGCameraShake.CurveBlnedOutTime = 0x1b4 // float (Size: 0x4)
SGCameraShakeBase.CameraShakeClass = 0x28 // ClassProperty (Size: 0x8)
SGCameraShakeBase.ADSCameraShakeClass = 0x30 // ClassProperty (Size: 0x8)
SGCameraShakeBase.ControllerCache = 0x38 // PlayerController* (Size: 0x8)
SGCameraShake_Animation.ConfigActiveAnimStateName = 0x40 // FName (Size: 0x8)
SGCameraShake_Animation.ConfigStateMachineName = 0x48 // FName (Size: 0x8)
SGCameraShake_Animation.CachedAnimInstance = 0x50 // AnimInstance* (Size: 0x8)
SGCameraShake_Landing.ConfigLandingType = 0x40 // EELandingTypes (Size: 0x1)
SGCameraShake_Landing_HD.LandSpeedScaleCurve = 0x40 // FRuntimeFloatCurve (Size: 0x88)
SGCameraShake_TakeHit.TrapHitCameraShakeClass = 0x40 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.TrapHitADSCameraShakeClass = 0x48 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_330_31 = 0x50 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_30_91 = 0x58 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_90_151 = 0x60 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_150_211 = 0x68 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_210_271 = 0x70 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_NormalTakeHit_270_331 = 0x78 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_330_31 = 0x80 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_30_91 = 0x88 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_90_151 = 0x90 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_150_211 = 0x98 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_210_271 = 0xa0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_TakeHit_270_331 = 0xa8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_330_31 = 0xb0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_30_91 = 0xb8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_90_151 = 0xc0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_150_211 = 0xc8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_210_271 = 0xd0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadChestTakeHit_270_331 = 0xd8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_330_31 = 0xe0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_30_91 = 0xe8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_90_151 = 0xf0 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_150_211 = 0xf8 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_210_271 = 0x100 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_HeadTakeHit_270_331 = 0x108 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.bStopLastShake = 0x110 // bool (Size: 0x1)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_330_31 = 0x118 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_30_91 = 0x120 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_90_151 = 0x128 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_150_211 = 0x130 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_210_271 = 0x138 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CS_OutOfEnduranceTakeHit_270_331 = 0x140 // ClassProperty (Size: 0x8)
SGCameraShake_TakeHit.CameraShake_TakeHit_Interval = 0x14c // float (Size: 0x4)
SGCameraShake_TakeHit.CachedDamageCauser = 0x150 // Actor* (Size: 0x8)
SGCameraShake_TakeHit.DamageRotScaleCurve = 0x158 // CurveFloat* (Size: 0x8)
SGCameraShake_TakeHit.DamageFOVScaleCurve = 0x160 // CurveFloat* (Size: 0x8)
SGCameraShake_TakeHit.CurCharacter = 0x168 // SGCharacter* (Size: 0x8)
SGCameraShake_TakeHit.CameraShakeClassToUse = 0x190 // ClassProperty (Size: 0x8)
SGCameraShake_WeaponBob.WeaponBobBeginSpeed = 0x40 // float (Size: 0x4)
SGCameraShake_WeaponBob.WeaponBobScaleBySpeed = 0x44 // float (Size: 0x4)
SGCameraShake_WeaponBob.CheckInterval = 0x48 // float (Size: 0x4)
SGCameraStyle.bDebugCamera = 0x28 // bool (Size: 0x1)
SGCameraStyle.PlayerCameraManager = 0x30 // PlayerCameraManager* (Size: 0x8)
SGCameraStyle.CameraModeClasses = 0x38 // TArray<ClassProperty> (Size: 0x10)
SGCameraStyle.CameraModes = 0x48 // TArray<SGCameraMode*> (Size: 0x10)
SGCameraStyle.DefaultCameraModeClass = 0x58 // ClassProperty (Size: 0x8)
SGCameraStyle.DefaultViewOffsetWhenActive = 0x60 // FVector (Size: 0xc)
SGCameraStyle.DefaultCameraMode = 0x70 // SGCameraMode* (Size: 0x8)
SGCameraStyle.CurrentCameraMode = 0x78 // SGCameraMode* (Size: 0x8)
SGCameraStyle.LastCameraMode = 0x80 // SGCameraMode* (Size: 0x8)
SGCameraStyle.bResetCameraInterpolation = 0x88 // bool (Size: 0x1)
SGCameraStyle.CameraRadius = 0x118 // float (Size: 0x4)
SGCameraStyle.CameraRadiusScale = 0x11c // float (Size: 0x4)
SGCameraStyle.WorstLocOffset = 0x120 // FVector (Size: 0xc)
SGCameraStyle.PenetrationAvoidanceFeelers = 0x130 // TArray<FPenetrationAvoidanceFeeler> (Size: 0x10)
SGCameraStyle.WorstLocBlockedPct = 0x140 // float (Size: 0x4)
SGCameraStyle.WorstLocPenetrationExtentScale = 0x144 // float (Size: 0x4)
SGCameraStyle.PenetrationBlendOutTime = 0x148 // float (Size: 0x4)
SGCameraStyle.PenetrationBlendInTime = 0x14c // float (Size: 0x4)
SGCameraStyle.PenetrationBlockedPct = 0x150 // float (Size: 0x4)
SGCameraStyle.PenetrationExtentScale = 0x154 // float (Size: 0x4)
SGCameraStyle.CameraLocatationClamp = 0x158 // float (Size: 0x4)
SGCameraStyle_Customize.CameraMeshComponent = 0x180 // SkeletalMeshComponent* (Size: 0x8)
SGCameraStyle_MovieThirdPerson.OriginOffsetInterpSpeed = 0x180 // float (Size: 0x4)
SGCameraStyle_MovieThirdPerson.FocusPoint = 0x210 // FMovieCameraFocusPointParams (Size: 0x38)
SGCameraStyle_MovieThirdPerson.StyleGeneralViewOffset = 0x28c // FVector (Size: 0xc)
SGCameraStyle_ThirdPerson.OriginOffsetInterpSpeed = 0x180 // float (Size: 0x4)
SGCameraStyle_ThirdPerson.FocusPoint = 0x210 // FCameraFocusPointParams (Size: 0x38)
SGCameraStyle_ThirdPerson.StyleGeneralViewOffset = 0x25c // FVector (Size: 0xc)
SGCameraStyle_UAMFirstPerson.DefaultOffsetInterpSpeed = 0x180 // float (Size: 0x4)
SGCameraStyle_UAMFirstPerson.InterpSpeedCurve = 0x188 // CurveFloat* (Size: 0x8)
SGCaptureCharacterLights.SkyLightComp = 0x310 // SkyLightComponent* (Size: 0x8)
SGCardReader.OwnedDoor = 0x310 // SGDoorBase* (Size: 0x8)
SGCardReader.ParticleSystemLock = 0x318 // ParticleSystemComponent* (Size: 0x8)
SGCardReader.ParticleSystemUnlockCoolDown = 0x320 // ParticleSystemComponent* (Size: 0x8)
SGCardReader.ParticleSystemUnlock = 0x328 // ParticleSystemComponent* (Size: 0x8)
SGCardReader.DoorUnlockSound = 0x330 // AkAudioEvent* (Size: 0x8)
SGCharacter.LandedEvent = 0x5f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.MoveBlockedByEvent = 0x608 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ContinuallyMoveBlockedByEvent = 0x618 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DeafEvent = 0x628 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LackInMoistureEvent = 0x638 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LackInFoodEvent = 0x648 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnduranceChangedEvent = 0x658 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.GameplayEffectExecuted = 0x668 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.HealthConditionChangedEvent = 0x678 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.HealthChangedEvent = 0x688 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnergyChangeEvent = 0x698 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnergyRecoverScaleEvent = 0x6a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnergyLowExhaustedChangedEvent = 0x6b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.MoistureChangeEvent = 0x6c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.FoodChangeEvent = 0x6d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.HearingChangedEvent = 0x6e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ReloadEvent = 0x6f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OutOfEnduranceEvent = 0x708 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DamageSpreadingRoundFinishEvent = 0x718 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.RecoverFromEnduranceEvent = 0x728 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PreTakeDamageEvent = 0x738 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TakeDamageEvent = 0x748 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PostTakeDamageEvent = 0x758 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TakeRealDamageEvent = 0x768 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TakeDamageByDebuffEvent = 0x778 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.FFPTakeHitEvent = 0x788 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CauseDamageEvent = 0x7c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CauseRealDamageEvent = 0x7d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ArmorTakeDamageEvent = 0x7e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CauseDebuffEvent = 0x7f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CauseArmorDurabilityReduce = 0x808 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PreDiedEvent = 0x818 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PostDiedEvent = 0x828 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.InteractFultonEvent = 0x838 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnDeathAnimationEndedEvent = 0x848 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnDoJumpFailed = 0x858 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.KillEvent = 0x868 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.AssistKillEvent = 0x878 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.BeKilledEvent = 0x888 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.BeKilledEquipmentEvent = 0x898 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PoseChangedEvent = 0x8a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LeanTypeChangedEvent = 0x8b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LeanRatioChangedEvent = 0x8c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnWeaponFireEvent = 0x8d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnWeaponHitEvent = 0x8e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterHoldingWeaponExtraMeshLoadCompleted = 0x8f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DamageBlackborad = 0x908 // FDamageBlackborad (Size: 0xa8)
SGCharacter.TornOffEvent = 0x9b0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterEnterTearGas = 0x9c0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.IsTouchGrassEvent = 0x9d0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPickUpPullBolt = 0x9e0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnDoPullBoltNotify = 0x9f0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnOperationResultOpen = 0xa00 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.StartInteractBoxInventoryEvent = 0xa10 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.FinishGameEvent = 0xa20 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.RotaterEvent = 0xa30 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OpenContextMenuEvent = 0xa40 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OpenContextMenuDTEvent = 0xa50 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.BoxInventoryOpenedEvent = 0xa60 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DoorEvent = 0xa70 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LootContainerEvent = 0xa80 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LootItemEvent = 0xa90 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LootCorpseOrDeathBoxEvent = 0xaa0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LootItemEventOnClient = 0xab0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.WalkEvent = 0xac0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LocationReport = 0xad0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.StuckLocationReport = 0xae0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.LastLocation = 0xaf0 // FVector (Size: 0xc)
SGCharacter.StartUsingRecoveryItemEvent = 0xb38 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.RecoveryItemActivatedEvent = 0xb48 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ReceiveRecoveryEffectEvent = 0xb58 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterInvEquipPositionChangedEvent = 0xb68 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.SwitchWeaponEvent = 0xb78 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.SwitchWeaponCompletedEvent = 0xb88 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.UseInventoryFlashEvent = 0xb98 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.InventoryFlashDebuffEvent = 0xba8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSetCurrentWeaponEvent = 0xbb8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSetCurrentWeaponAfterMontageEvent = 0xbc8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCurrentWeaponChange = 0xbd8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateWeaponAnimationSetsEvent = 0xbe8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.UnProne = 0xbf8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ProneToCrouch = 0xc08 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CrouchToProne = 0xc18 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.StandToProne = 0xc28 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnterDBNOStatusEvent = 0xc38 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ExitDBNOStatusEvent = 0xc48 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.AbortRescueTeammateEvent = 0xc58 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnClickAtk = 0xc68 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnClickStopAtk = 0xc78 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.PreAddInventoryEvent = 0xc88 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPeriodicGameplayEffectExecuteEvent = 0xc98 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnGameplayEffectAppliedEvent = 0xca8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAnyGameplayEffectRemovedEvent = 0xcb8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnGameplayDebuffStatusChangedEvent = 0xcc8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnStartSearchingContainerEvent = 0xcd8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnContainerRoughSearchEndEvent = 0xce8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnContainerSearchEnd = 0xcf8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnRecvMsg = 0xd08 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAvatarAddedEvent = 0xd18 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnNativeAvatarAddedEvent = 0xd28 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAvatarRemovedEvent = 0xd38 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnNativeAvatarRemovedEvent = 0xd48 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnBadgeUpdateEvent = 0xd58 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEnterCheckVolumeEvent = 0xd68 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnBecomeViewTarget = 0xd78 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEndViewTarget = 0xd88 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPossessedByController = 0xd98 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUnPossessedByController = 0xda8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnStartSpectatedByController = 0xdb8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnStopSpectatedByController = 0xdc8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateOnBackWeaponVisibility = 0xdd8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnGetViewedByController = 0xde8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnLockInventoriesInContainer = 0xdf8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUsingInventoryChanged = 0xe08 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.EnterDSSendWeaponAttri = 0xe18 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnKillQuestProgressAdd = 0xe28 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCollectQuestProgressChanged = 0xe38 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnKillMissionProgressAdd = 0xe48 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCollectMissionProgressChanged = 0xe58 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ClientLocationCorrectionEvent = 0xe68 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.FrameRateJitterEvent = 0xe78 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ThermalViewHackEvent = 0xe88 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CharacterPreAddInventoryEvent = 0xe98 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CharacterAddInventoryEvent = 0xea8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CharacterRemoveInventoryEvent = 0xeb8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ActivityInventoryAddedEvent = 0xec8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ActivityInventoryRemovedEvent = 0xed8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CharacterRemoveWeaponEvent = 0xee8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.CharacterInventoryMovedEvent = 0xef8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.Client_InventoryGridInfoChangedEvent = 0xf08 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterSexChanged = 0xf18 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAvatarDataChanged = 0xf28 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterRagdollPoseFinished = 0xf38 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterMeshChanged = 0xf48 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAvatarMeshLoaded = 0xf58 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAvatarMeshDressed = 0xf68 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAvatarMeshUnDressed = 0xf78 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAllAvatarMeshLoaded = 0xf88 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPrimaryWeaponAllMeshLoaded = 0xf98 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterAvatarListChanged = 0xfa8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnShowMergedAvatar = 0xfb8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSetNewOwner = 0xfc8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnOwnerOrRoleChanged = 0xfd8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnRepControllerEvent = 0xfe8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSetNewPlayerState = 0xff8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnChangeCustomFOV = 0x1008 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEnableCustomFOV = 0x1018 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSprintRequest = 0x1028 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSprintingChanged = 0x1038 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterScopeSceneCaptureStatusChanged = 0x1048 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterZoomChanged = 0x1058 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterSwitchScope = 0x1068 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterSwitchZoom = 0x1078 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterEnterSmoke = 0x1088 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterFlashed = 0x1098 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterStuned = 0x10a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.MedicineRoulette = 0x10b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnIsBleed = 0x10c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAbilityActivated = 0x10d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DBNOEndReport = 0x10e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.InventoryGiveComplete = 0x10f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.InventoryLoadComplete = 0x1108 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.DressInventoryLoadComplete = 0x1118 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInventorySkeletalMeshLoadComplete = 0x1128 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterSkeletalMeshLoadComplete = 0x1138 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInventoryStaticMeshLoadComplete = 0x1148 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterStaticMeshLoadComplete = 0x1158 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnBeforeCharacterUpdateAvatarLayers = 0x1168 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAfterCharacterUpdateAvatarLayers = 0x1178 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEnableHighPowerScope = 0x1188 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterBecomeCorpse = 0x1198 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterLoadProtectStateChanged = 0x11a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnAutoAimAntiHackStatisReceived = 0x11b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCarriedFaceShieldActivated = 0x11c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterCastShadow = 0x11d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnWeaponHarmVerifyFail = 0x11e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPickUpInventory = 0x11f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnActivateInteract = 0x1208 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSoundLevelInfluenceFactorChanged = 0x1218 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnSoundMaxDistanceInfluenceFactorChanged = 0x1228 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TinnitusDelegate = 0x1238 // FDelegate (Size: 0x10)
SGCharacter.FullBodyGestureDelegate = 0x1248 // FDelegate (Size: 0x10)
SGCharacter.OnDestroyActor = 0x1258 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterPreDestroyed = 0x1268 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterDestroyed = 0x1278 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnFSMEscapeStateChange = 0x1288 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnWeaponListChange = 0x1298 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnCharacterResetToLastSavedState = 0x12a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnActiveLongDistanceTacticalInv = 0x12b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEquipSkeletalMeshLoadCompleted = 0x12c8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEquipSkeletalMeshAvatarLoadCompleted = 0x12d8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPrePlayAdapterMontage = 0x12e8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInventoryEquipped = 0x12f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInventoryUnequipped = 0x1308 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEquipStaticMeshLoadCompleted = 0x1318 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnPreUpdateAvatars = 0x1328 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateAvatarsAddInventory = 0x1338 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateAvatarsAfterAddInventory = 0x1348 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnEquipMeshDecideLoadSkeletalMeshInLobby = 0x1358 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInvMeshDecideLoadSkeletalMeshInLobby = 0x1368 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnInvAnimInstanceLoad = 0x1378 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateAvatarsFinish = 0x1388 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnGrenadeKillMulti = 0x1398 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnHarmTeammate = 0x13a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.ASCRepPlayMontage = 0x13d0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateAvatarsAddConfData = 0x13e0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnUpdateAvatarsAfterAddConfData = 0x13f0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.AnnihilateBeginSuitSelect = 0x1400 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.AnnihilateBattleResult = 0x1410 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TDMTypeGameResult = 0x1420 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnRebornSaftyStateChanged = 0x1430 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnBulletOperation = 0x1440 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnActorHiddenInGame = 0x1450 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.OnWalkCameraSpringIntensitySettingChanged = 0x1490 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.TestDamageComponent = 0x14c8 // SGCharacterTestDamageComponent* (Size: 0x8)
SGCharacter.bShouldDeferConstructionAIC = 0x14d0 // bool (Size: 0x1)
SGCharacter.LocalDataComponent = 0x14d8 // SGCharacterLocalDataComponent* (Size: 0x8)
SGCharacter.CharacterCameraComponent = 0x14e0 // CameraComponent* (Size: 0x8)
SGCharacter.SoundVolumeOverlapComponent = 0x14e8 // ShapeComponent* (Size: 0x8)
SGCharacter.FPPCameraComponent = 0x14f0 // CameraComponent* (Size: 0x8)
SGCharacter.SmoothTargetViewRotationSpeed = 0x1510 // float (Size: 0x4)
SGCharacter.CurrentViewerPC = 0x1518 // SGPlayerController* (Size: 0x8)
SGCharacter.bIsTurning = 0x1520 // bool (Size: 0x1)
SGCharacter.bEnableBeAutoAimed = 0x1521 // bool (Size: 0x1)
SGCharacter.bEnableViewSignificance = 0x152d // bool (Size: 0x1)
SGCharacter.PlayerViewInfo = 0x1530 // uint32_t (Size: 0x4)
SGCharacter.PlayerViewPitch = 0x1534 // float (Size: 0x4)
SGCharacter.PlayerViewYaw = 0x1538 // float (Size: 0x4)
SGCharacter.PlayerTurnInfo = 0x153c // EETurnInfo (Size: 0x1)
SGCharacter.CachedCharacterType = 0x153d // EECharacterType (Size: 0x1)
SGCharacter.GID = 0x1540 // uint64_t (Size: 0x8)
SGCharacter.FactionType = 0x1548 // EEFactionType (Size: 0x1)
SGCharacter.CharacterSex = 0x1549 // EECharacterSex (Size: 0x1)
SGCharacter.LastPossessedController = 0x1550 // Controller* (Size: 0x8)
SGCharacter.bMeshTickThisFrame = 0x1558 // bool (Size: 0x1)
SGCharacter.RepVaultInfo = 0x1560 // FReplicationVaultInfo (Size: 0x40)
SGCharacter.bEnterSmoke = 0x15b4 // bool (Size: 0x1)
SGCharacter.UROLoadBalanceBudget = 0x15d8 // int32_t (Size: 0x4)
SGCharacter.SGCharacterMovement = 0x15e0 // SGCharacterMovementComponent* (Size: 0x8)
SGCharacter.ProxyCharacterCounter = 0x1610 // int64_t (Size: 0x8)
SGCharacter.OnReadyToPlay = 0x1628 // FMulticastInlineDelegate (Size: 0x10)
SGCharacter.AbilitySystemComponent = 0x1638 // AbilitySystemComponent* (Size: 0x8)
SGCharacter.Menu = 0x1640 // SGContextMenu* (Size: 0x8)
SGCharacter.LocationReportHandle = 0x1648 // FTimerHandle (Size: 0x8)
SGCharacter.CharacterMeshLocationOffset = 0x1658 // FVector (Size: 0xc)
SGCharacter.bReadyToPlay = 0x1664 // bool (Size: 0x1)
SGCharacter.WaitingForInitComponents = 0x1668 // TSet<...> (Size: 0x50)
SGCharacter.ActiveLongDistanceTacticalInvs = 0x16b8 // TSet<...> (Size: 0x50)
SGCharacter.bTickingOnDeath = 0x1708 // bool (Size: 0x1)
SGCharacter.LastHitByDamageCauser = 0x1710 // Actor* (Size: 0x8)
SGCharacter.LastHitByOtherInfo = 0x1718 // FSGLastHitByInfo (Size: 0x30)
SGCharacter.Acceleration = 0x174c // FVector_NetQuantize (Size: 0xc)
SGCharacter.PredictStopLocation = 0x1758 // FVector_NetQuantize (Size: 0xc)
SGCharacter.bIsReplayViewTarget = 0x1768 // bool (Size: 0x1)
SGCharacter.bSimulateNavWalkSnapFloor = 0x1769 // bool (Size: 0x1)
SGCharacter.LaserTraceCollisionChannel = 0x176a // uint8_t (Size: 0x1)
SGCharacter.CharacterSpawnTime = 0x176c // float (Size: 0x4)
SGCharacter.bRestarting = 0x1770 // bool (Size: 0x1)
SGCharacter.WeaponManagerComponent = 0x1778 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGCharacter.DeathComponent = 0x1780 // SGCharacterDeathComponent* (Size: 0x8)
SGCharacter.CorpseBeUsedComponent = 0x1788 // SGCharacterBeUsedCorpseComponent* (Size: 0x8)
SGCharacter.MovementAbilityComponent = 0x1790 // SGCharacterMovementAbilityComponent* (Size: 0x8)
SGCharacter.TurnComponent = 0x1798 // SGCharacterBaseTurnComponent* (Size: 0x8)
SGCharacter.InputProcessComponent = 0x17a0 // SGCharacterInputProcessComponent* (Size: 0x8)
SGCharacter.MovementProneComponent = 0x17a8 // SGCharacterMovementProneComponent* (Size: 0x8)
SGCharacter.MovementDBNOComponent = 0x17b0 // SGCharacterMovementDBNOComponent* (Size: 0x8)
SGCharacter.MovementVaultComponent = 0x17b8 // SGCharacterMovementVaultComponent* (Size: 0x8)
SGCharacter.DBNOComponent = 0x17c0 // SGCharacterDBNOComponent* (Size: 0x8)
SGCharacter.CharacterFallComponent = 0x17c8 // SGCharacterFallComponent* (Size: 0x8)
SGCharacter.LeanComponent = 0x17d0 // SGCharacterLeanWallComponent* (Size: 0x8)
SGCharacter.RagdollComponent = 0x17d8 // SGCharacterRagdollNewComponent* (Size: 0x8)
SGCharacter.AIComponent = 0x17e0 // SGCharacterAIComponent* (Size: 0x8)
SGCharacter.AIPoseComponent = 0x17e8 // SGCharacterAIPoseComponent* (Size: 0x8)
SGCharacter.WeaponSwayComponent = 0x17f0 // SGCharacterWeaponSwayComponent* (Size: 0x8)
SGCharacter.PoseCacheComponent = 0x17f8 // SGUAMCharacterPoseCacheComponent* (Size: 0x8)
SGCharacter.WetnessComponent = 0x1800 // MFClimateMovableRainWetnessComponent* (Size: 0x8)
SGCharacter.EnergyComponent = 0x1808 // SGCharacterEnergyComponent* (Size: 0x8)
SGCharacter.SprintComponent = 0x1810 // SGCharacterSprintComponent* (Size: 0x8)
SGCharacter.UseComponent = 0x1818 // SGActorUseComponent* (Size: 0x8)
SGCharacter.AnimationComponent = 0x1820 // SGCharacterAnimationComponent* (Size: 0x8)
SGCharacter.PreviewComponent = 0x1828 // SGCharacterPreviewComponent* (Size: 0x8)
SGCharacter.WeaponTraceComponent = 0x1830 // SGCharacterWeaponTraceComponent* (Size: 0x8)
SGCharacter.CurveBreathComponent = 0x1838 // SGCharacterCurveBreathComponent* (Size: 0x8)
SGCharacter.TakeHitEffectComponent = 0x1840 // SGCharacterTakeHitEffectComponent* (Size: 0x8)
SGCharacter.TakeCoverComponent = 0x1848 // SGCharacterTakeCoverComponent* (Size: 0x8)
SGCharacter.MovementLadderClimbComponent = 0x1850 // SGCharacterMovementLadderClimbComponent* (Size: 0x8)
SGCharacter.InteractionComponent = 0x1858 // SGCharacterInteractionComponent* (Size: 0x8)
SGCharacter.TeamRescueComponent = 0x1860 // SGCharacterTeamRescueComponent* (Size: 0x8)
SGCharacter.IKComponent = 0x1868 // SGCharacterIKComponent* (Size: 0x8)
SGCharacter.StunGrenadeEffectComponent = 0x1870 // SGCharacterStunGrenadeEffectComponent* (Size: 0x8)
SGCharacter.WeightComponent = 0x1878 // SGCharacterWeightComponent* (Size: 0x8)
SGCharacter.SenseAbilityComponent = 0x1880 // SGCharacterSenseAbilityComponent* (Size: 0x8)
SGCharacter.CastShadowComp = 0x1888 // SGCharacterCastShadowComponent* (Size: 0x8)
SGCharacter.AvatarComp = 0x1890 // SGCharacterAvatarComponent* (Size: 0x8)
SGCharacter.AvatarManagerComp = 0x1898 // SGCharacterAvatarManagerComponent* (Size: 0x8)
SGCharacter.CharacterMeshComp = 0x18a0 // SGCharacterMeshComponent* (Size: 0x8)
SGCharacter.AvatarMergeComp = 0x18a8 // SGCharacterAvatarMergeComponent* (Size: 0x8)
SGCharacter.CharacterBoneBreakComponent = 0x18b0 // SGCharacterBoneBreakComponent* (Size: 0x8)
SGCharacter.FootEffectComponent = 0x18b8 // SGCharacterFootEffectComponent* (Size: 0x8)
SGCharacter.FragEffectComponent = 0x18c0 // SGCharacterFragGrenadeEffectComponent* (Size: 0x8)
SGCharacter.CharacterDebugMovementComponent = 0x18c8 // SGCharacterDebugMovementComponent* (Size: 0x8)
SGCharacter.CharacterWeaponManagerComponent = 0x18d0 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGCharacter.CharacterLoadProtectComponent = 0x18d8 // SGCharacterLoadProtectComponent* (Size: 0x8)
SGCharacter.CharacterTLogComponent = 0x18e0 // SGCharacterTLogComponent* (Size: 0x8)
SGCharacter.CharacterInventoryManagerComponent = 0x18e8 // SGCharacterInventoryManagerComponent* (Size: 0x8)
SGCharacter.MotionWarpingComponent = 0x18f0 // SGMotionWarpingComponent* (Size: 0x8)
SGCharacter.CharacterInventoryComponent = 0x18f8 // SGCharacterInventoryComponent* (Size: 0x8)
SGCharacter.MoveBlockedAvoidanceComponent = 0x1900 // SGCharacterMoveBlockedAvoidanceComponent* (Size: 0x8)
SGCharacter.CharacterSoundComponent = 0x1908 // SGCharacterSoundComponent* (Size: 0x8)
SGCharacter.CharacterArmorManagerComponent = 0x1910 // SGCharacterArmorManagerComponent* (Size: 0x8)
SGCharacter.CharacterWeaponAttachComponent = 0x1918 // SGCharacterWeaponAttachComponent* (Size: 0x8)
SGCharacter.CharacterInventoryGiveComponent = 0x1920 // SGCharacterInventoryGiveComponent* (Size: 0x8)
SGCharacter.CharacterDeliverCargoComponent = 0x1928 // SGCharacterDeliverCargoComponent* (Size: 0x8)
SGCharacter.CharacterTacticalPistolComponent = 0x1930 // SGCharacterTacticalPistolComponent* (Size: 0x8)
SGCharacter.VehicleComponent = 0x1938 // SGCharacterVehicleComponent* (Size: 0x8)
SGCharacter.LagCompensationComp = 0x1940 // SGCharacterLagCompensationComponent* (Size: 0x8)
SGCharacter.CharacterSwimComponent = 0x1948 // SGCharacterSwimComponent* (Size: 0x8)
SGCharacter.CharacterHealthComponent = 0x1950 // SGCharacterHealthComponent* (Size: 0x8)
SGCharacter.CharacterFOVComponent = 0x1958 // SGCharacterFOVComponent* (Size: 0x8)
SGCharacter.CharacterTakeDamageComponent = 0x1960 // SGCharacterTakeDamageComponent* (Size: 0x8)
SGCharacter.CharacterLookAroundComponent = 0x1968 // SGCharacterLookAroundComponent* (Size: 0x8)
SGCharacter.MovingDirAngleCrossTolerance = 0x1a10 // float (Size: 0x4)
SGCharacter.ViewPointOffset = 0x1a14 // FVector (Size: 0xc)
SGCharacter.DesiredFOV = 0x1a20 // float (Size: 0x4)
SGCharacter.HeadLocation = 0x1a24 // FVector (Size: 0xc)
SGCharacter.CameraLocation = 0x1a30 // FVector (Size: 0xc)
SGCharacter.Health = 0x1a3c // float (Size: 0x4)
SGCharacter.GameDuration = 0x1a40 // float (Size: 0x4)
SGCharacter.CurrentTotalValue = 0x1a44 // int32_t (Size: 0x4)
SGCharacter.BodyBounds = 0x1a48 // FBodyBounds (Size: 0x1c)
SGCharacter.UsingHDMesh = 0x1ac0 // bool (Size: 0x1)
SGCharacter.LocalCapture = 0x1ac1 // bool (Size: 0x1)
SGCharacter.PhysicalAnimationComponent = 0x1af0 // PhysicalAnimationComponent* (Size: 0x8)
SGCharacter.RandomSeed = 0x1af8 // uint32_t (Size: 0x4)
SGCharacter.bIsContinuousWeaponChange = 0x1afc // bool (Size: 0x1)
SGCharacterAIAimingComponent.MAX_ANGLE_COEF = 0x108 // float (Size: 0x4)
SGCharacterAIAimingComponent.AimTimeReduce = 0x10c // float (Size: 0x4)
SGCharacterAIAimingComponent.AimAngleCoefCurve = 0x110 // CurveFloat* (Size: 0x8)
SGCharacterAIAimingComponent.PredestinedShootWeight = 0x118 // float (Size: 0x4)
SGCharacterAIAimingComponent.AimTimeMinDistance = 0x11c // float (Size: 0x4)
SGCharacterAIAimingComponent.AimTimeMaxDistance = 0x120 // float (Size: 0x4)
SGCharacterAIAimingComponent.bReachMaxShotCount = 0x15c // uint8_t (Size: 0x1)
SGCharacterAIAimingComponent.bNextShotMiss = 0x15c // uint8_t (Size: 0x1)
SGCharacterAIAimingComponent.bNextShotHit = 0x15c // uint8_t (Size: 0x1)
SGCharacterAIAimingComponent.MaxShotCount = 0x160 // int32_t (Size: 0x4)
SGCharacterAIAimingComponent.CurrentShotCount = 0x164 // int32_t (Size: 0x4)
SGCharacterAIAimingComponent.bHitChestInRound = 0x168 // bool (Size: 0x1)
SGCharacterAIAimingComponent.PresistNotHitCount = 0x16c // int32_t (Size: 0x4)
SGCharacterAIAimingComponent.PresistNotHitRate = 0x170 // float (Size: 0x4)
SGCharacterAIAimingComponent.bFakeRandomHit = 0x174 // bool (Size: 0x1)
SGCharacterAIAimingComponent.RequiredAimingTime = 0x178 // float (Size: 0x4)
SGCharacterAIAimingComponent.ElapsedAimingTime = 0x17c // float (Size: 0x4)
SGCharacterAIAimingComponent.StartAimingTimestamp = 0x180 // float (Size: 0x4)
SGCharacterAIAimingComponent.NextAimingDelayTime = 0x184 // float (Size: 0x4)
SGCharacterAIAimingComponent.AimingWaitEndtime = 0x188 // float (Size: 0x4)
SGCharacterAIAimingComponent.AimingWaitNTime = 0x18c // float (Size: 0x4)
SGCharacterAIAimingComponent.StopAimingTime = 0x190 // float (Size: 0x4)
SGCharacterAIAimingComponent.LastDist2Target = 0x194 // float (Size: 0x4)
SGCharacterAIAimingComponent.AimingPoint = 0x198 // FVector (Size: 0xc)
SGCharacterAIAimingComponent.LastAimingEnemyLocation = 0x1a4 // FVector (Size: 0xc)
SGCharacterAIAimingComponent.AimingOffset = 0x1b0 // FVector (Size: 0xc)
SGCharacterAIAimingComponent.LookDirection = 0x1bc // FVector (Size: 0xc)
SGCharacterAIAimingComponent.AimStatus = 0x1c8 // EEAIAimStatus (Size: 0x4)
SGCharacterAIAimingComponent.LastUpdateTimestamp = 0x1cc // float (Size: 0x4)
SGCharacterAIAimingComponent.HitResultArr = 0x1d0 // TArray<bool> (Size: 0x10)
SGCharacterAIAimingComponent.EnemyPawn = 0x1e0 // Actor* (Size: 0x8)
SGCharacterAIAimingComponent.EnemyInfo = 0x1e8 // NPCAITargetInfo* (Size: 0x8)
SGCharacterAIAimingComponent.bEnemyIsAI = 0x1f0 // bool (Size: 0x1)
SGCharacterAIAimingComponent.FirstGunFinalHitRate = 0x1f4 // float (Size: 0x4)
SGCharacterAIAimingComponent.TotalFireCount = 0x1f8 // int32_t (Size: 0x4)
SGCharacterAIAimingComponent.TotalHitCount = 0x1fc // int32_t (Size: 0x4)
SGCharacterAIAimingComponent.HitRateNormal = 0x200 // float (Size: 0x4)
SGCharacterAIAimingComponent.CoreProps = 0x210 // NPCAIPropertyComponent_Core* (Size: 0x8)
SGCharacterAIAimingComponent.AimingProps = 0x218 // NPCAIPropertyComponent_Aiming* (Size: 0x8)
SGCharacterAIAimingComponent.BlockProps = 0x220 // NPCAIPropertyComponent_Block* (Size: 0x8)
SGCharacterAIAimingComponent.MemoryComponent = 0x228 // NPCAIMemorySystemComponent* (Size: 0x8)
SGCharacterAIAimingComponent.TurnComponent = 0x230 // SGCharacterAITurnComponent* (Size: 0x8)
SGCharacterAIAimingComponent.AimingSocketOnCharacter = 0x244 // FName (Size: 0x8)
SGCharacterAIAimingComponent.CrossFireDecision_BBKey = 0x24c // FName (Size: 0x8)
SGCharacterAIAimingComponent.AIDecisionList_NeedAimingFocus = 0x258 // TArray<EENPCAIDecision> (Size: 0x10)
SGCharacterAIComponent.bForceShowHighPrecisionHead = 0x100 // bool (Size: 0x1)
SGCharacterAIComponent.bShowBagMesh = 0x101 // bool (Size: 0x1)
SGCharacterAIComponent.bShowVestMesh = 0x102 // bool (Size: 0x1)
SGCharacterAIComponent.bShowVestBagMesh = 0x103 // bool (Size: 0x1)
SGCharacterAIComponent.bShowHelmetMesh = 0x104 // bool (Size: 0x1)
SGCharacterAIDBNOComponent.bCheckDiedWipeOut = 0x250 // bool (Size: 0x1)
SGCharacterAIDBNOComponent.RescueDistance = 0x254 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.FarAwayFromDoorDistance = 0x108 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.CloseFromDoorDistance = 0x10c // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.DoorCheckDist = 0x110 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.FarAwayFromDoorHeight = 0x114 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.CloseFromDoorHeight = 0x118 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.DoorInFront = 0x120 // SGDoorBase* (Size: 0x8)
SGCharacterAIDoorOpenerComponent.WaitAgainstPointToGo = 0x128 // FVector (Size: 0xc)
SGCharacterAIDoorOpenerComponent.WaitSafetyPointToGo = 0x134 // FVector (Size: 0xc)
SGCharacterAIDoorOpenerComponent.WaitSafetyDoorNavLinkPoint = 0x140 // FVector (Size: 0xc)
SGCharacterAIDoorOpenerComponent.bWantToStopSafetyWaitOpen = 0x14c // bool (Size: 0x1)
SGCharacterAIDoorOpenerComponent.WaitSafetyOpenDoor = 0x150 // SGDoorBase* (Size: 0x8)
SGCharacterAIDoorOpenerComponent.SafetyDoorPointsInPath = 0x158 // TArray<FVector> (Size: 0x10)
SGCharacterAIDoorOpenerComponent.RandWaitRadius = 0x168 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.MinWaitRadius = 0x16c // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.MaxWaitRadius = 0x170 // float (Size: 0x4)
SGCharacterAIDoorOpenerComponent.LastPointToGo = 0x174 // FVector (Size: 0xc)
SGCharacterAIDoorOpenerComponent.AISGDoorManager = 0x190 // AISGDoorManager* (Size: 0x8)
SGCharacterAIDoorOpenerComponent.MoverSystemComponent = 0x198 // NPCAIMoverSystemComponent* (Size: 0x8)
SGCharacterAIDoorOpenerComponent.MemorySystemComponent = 0x1a0 // NPCAIMemorySystemComponent* (Size: 0x8)
SGCharacterAIDoorOpenerComponent.AITurnComponent = 0x1a8 // SGCharacterAITurnComponent* (Size: 0x8)
SGCharacterAIExplodeComponent.ExplodePS = 0x108 // ParticleSystem* (Size: 0x8)
SGCharacterAIExplodeComponent.DamageRange = 0x110 // float (Size: 0x4)
SGCharacterAIExplodeComponent.MinRadiusDamage = 0x114 // float (Size: 0x4)
SGCharacterAIExplodeComponent.MaxRadiusDamage = 0x118 // float (Size: 0x4)
SGCharacterAIExplodeComponent.DamageTypeClass = 0x120 // ClassProperty (Size: 0x8)
SGCharacterAIExplodeComponent.bExplodeAtDeath = 0x128 // bool (Size: 0x1)
SGCharacterAIFireComponent.AIBodyPartBoneNameMap = 0x128 // TMap<...> (Size: 0x50)
SGCharacterAIFireComponent.CheckHitTimeThreshold = 0x178 // float (Size: 0x4)
SGCharacterAIFireComponent.bEnableInstantBullet = 0x186 // bool (Size: 0x1)
SGCharacterAIFireComponent.InstantBullet = 0x190 // SGProjectile_InstantBullet* (Size: 0x8)
SGCharacterAIFireComponent.BulletFireEffectReplicateInterval = 0x198 // float (Size: 0x4)
SGCharacterAIFireComponent.LockAmmoCountAtPercentage = 0x1a0 // float (Size: 0x4)
SGCharacterAIFireComponent.WeaponAimMaxAngleProtectDegree = 0x1a4 // float (Size: 0x4)
SGCharacterAIFireComponent.FireSetting = 0x1b8 // FNPCAIFireSetting (Size: 0x40)
SGCharacterAIFireComponent.AimingComponent = 0x1f8 // SGCharacterAIAimingComponent* (Size: 0x8)
SGCharacterAIFireComponent.AIRecoilComponent = 0x200 // SGCharacterAIRecoilComponent* (Size: 0x8)
SGCharacterAIFireComponent.AIMemoryComponent = 0x208 // NPCAIMemorySystemComponent* (Size: 0x8)
SGCharacterAIFireComponent.AITurnComponent = 0x210 // SGCharacterAITurnComponent* (Size: 0x8)
SGCharacterAIFireComponent.ZoneGroupInfo = 0x218 // NPCAIZoneGroupInfo* (Size: 0x8)
SGCharacterAIFireComponent.ShootProps = 0x220 // NPCAIPropertyComponent_Shoot* (Size: 0x8)
SGCharacterAIFireComponent.AimingProps = 0x228 // NPCAIPropertyComponent_Aiming* (Size: 0x8)
SGCharacterAIFireComponent.DamageProps = 0x230 // NPCAIPropertyComponent_Damage* (Size: 0x8)
SGCharacterAIMoveComponent.bExitCasualIfSprintOrRun = 0x1d0d // bool (Size: 0x1)
SGCharacterAIMoveComponent.bDefaultIgnoreOtherPawn = 0x1d38 // bool (Size: 0x1)
SGCharacterAIMoveComponent.IsIgnoreOtherPawn = 0x1d39 // bool (Size: 0x1)
SGCharacterAIMoveComponent.IsEnabledRVOAvoidance = 0x1d3a // bool (Size: 0x1)
SGCharacterAIMoveComponent.TimeOfIgnorePawn = 0x1d3c // float (Size: 0x4)
SGCharacterAIMoveComponent.DistanceToDestinationStopIfOverlapOther = 0x1d40 // float (Size: 0x4)
SGCharacterAIMoveComponent.DISTANCE_TO_WALL_WANT_STOP = 0x1d44 // float (Size: 0x4)
SGCharacterAIMoveComponent.DestinationToGo = 0x1d48 // FVector (Size: 0xc)
SGCharacterAIMoveComponent.bCheckIsMovingToWall = 0x1d54 // bool (Size: 0x1)
SGCharacterAIMoveComponent.CheckKeepAwayWallTime = 0x1d58 // float (Size: 0x4)
SGCharacterAIMoveComponent.CachedDistanceToWall = 0x1d5c // float (Size: 0x4)
SGCharacterAIMoveComponent.LastTimeCheckDistanceToWall = 0x1d60 // float (Size: 0x4)
SGCharacterAIMoveComponent.MoverSysComponent = 0x1d68 // NPCAIMoverSystemComponent* (Size: 0x8)
SGCharacterAIPathNodeComponent.InitPathNode = 0x108 // SGAIPathNode* (Size: 0x8)
SGCharacterAIPathNodeComponent.CurrentPathNode = 0x110 // SGAIPathNode* (Size: 0x8)
SGCharacterAIPathNodeComponent.NextPathNode = 0x118 // SGAIPathNode* (Size: 0x8)
SGCharacterAIPickUpComponent.DistanceToInventoryForPickUp = 0x108 // float (Size: 0x4)
SGCharacterAIPickUpComponent.PickUpInterval = 0x10c // float (Size: 0x4)
SGCharacterAIPickUpComponent.NextPickUpTime = 0x110 // float (Size: 0x4)
SGCharacterAIPickUpComponent.IndexOfPickUpList = 0x114 // int32_t (Size: 0x4)
SGCharacterAIPickUpComponent.bCheckIsCanAdd = 0x118 // bool (Size: 0x1)
SGCharacterAIPickUpComponent.bHadCheckTryReplaceLow = 0x119 // bool (Size: 0x1)
SGCharacterAIPickUpComponent.bHasCollectInventoryItem = 0x11a // bool (Size: 0x1)
SGCharacterAIPickUpComponent.bPickUpFromContainer = 0x11b // bool (Size: 0x1)
SGCharacterAIPickUpComponent.WaitPickUpBoxContainer = 0x120 // Actor* (Size: 0x8)
SGCharacterAIPickUpComponent.WaitPickUpList = 0x128 // TArray<Actor*> (Size: 0x10)
SGCharacterAIPickUpComponent.PickUpNumInBox = 0x138 // int32_t (Size: 0x4)
SGCharacterAIPickUpComponent.PendingInventory = 0x148 // Actor* (Size: 0x8)
SGCharacterAIPickUpComponent.PickUpInventoryMemoryList = 0x158 // TMap<...> (Size: 0x50)
SGCharacterAIPickUpComponent.MemoryComp = 0x1a8 // NPCAIMemorySystemComponent* (Size: 0x8)
SGCharacterAIPickUpComponent.AIGlobalMgr = 0x1b0 // SGAIGlobalManagerComponent* (Size: 0x8)
SGCharacterAIPickUpComponent.SharedInfo = 0x1b8 // NPCAIGlobalSharedInfo* (Size: 0x8)
SGCharacterAIPoseComponent.bIsCasual = 0x17a // bool (Size: 0x1)
SGCharacterAIPoseComponent.JumpFlag = 0x17b // bool (Size: 0x1)
SGCharacterAIPoseComponent.LeanHorizontalOffset = 0x180 // TMap<...> (Size: 0x50)
SGCharacterAIPoseComponent.PoseTransitions = 0x1d0 // TArray<FPoseTransition> (Size: 0x10)
SGCharacterAIPoseComponent.CasualToStandMontage = 0x1e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterAIPoseComponent.StandToCasualMontage = 0x208 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterAIPoseComponent.CasualMontages = 0x230 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterAIPoseComponent.bDisableDSPoseSync = 0x240 // bool (Size: 0x1)
SGCharacterAIPoseComponent.LeanComponent = 0x248 // SGCharacterLeanWallComponent* (Size: 0x8)
SGCharacterAIPoseComponent.AIFireComponent = 0x250 // SGCharacterAIFireComponent* (Size: 0x8)
SGCharacterAIPoseComponent.ShareInfo = 0x258 // NPCAIGlobalSharedInfo* (Size: 0x8)
SGCharacterAIPoseComponent.WeaponAnimationCompnent = 0x260 // SGUAMWeaponAnimationComponent* (Size: 0x8)
SGCharacterAIPoseComponent.bSkipProneCheck = 0x268 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.bUseXYCorrection = 0x108 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.MIN_DIST_TO_TARGET = 0x10c // float (Size: 0x4)
SGCharacterAIRecoilComponent.bResetWhenEndRecoil = 0x110 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.EffectRemainTime = 0x114 // float (Size: 0x4)
SGCharacterAIRecoilComponent.EffectDuration = 0x118 // float (Size: 0x4)
SGCharacterAIRecoilComponent.EffectEndTimestamp = 0x11c // float (Size: 0x4)
SGCharacterAIRecoilComponent.CurrentOffset = 0x120 // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.EffectOffset = 0x12c // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.bEnabledSimulateRecoil = 0x138 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.bEnabledWeaponRecoil = 0x139 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.bEnabledAIRecoilControl = 0x13a // bool (Size: 0x1)
SGCharacterAIRecoilComponent.bEnabledExactAiming = 0x13b // bool (Size: 0x1)
SGCharacterAIRecoilComponent.WeaponRecoilInheritScale = 0x13c // float (Size: 0x4)
SGCharacterAIRecoilComponent.OriginalViewRotation = 0x140 // FRotator (Size: 0xc)
SGCharacterAIRecoilComponent.OriginalFocalPoint = 0x14c // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.DistToOriginalFocalPoint = 0x158 // float (Size: 0x4)
SGCharacterAIRecoilComponent.WeaponRecoilRotation = 0x15c // FRotator (Size: 0xc)
SGCharacterAIRecoilComponent.MultiFireShakeSpeed = 0x168 // FRotator (Size: 0xc)
SGCharacterAIRecoilComponent.bEnabledDrawPoint = 0x174 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.ModifyYawMax = 0x178 // float (Size: 0x4)
SGCharacterAIRecoilComponent.ModifyPitchMin = 0x17c // float (Size: 0x4)
SGCharacterAIRecoilComponent.ModifyPitchMax = 0x180 // float (Size: 0x4)
SGCharacterAIRecoilComponent.LastLosingRecoilTime = 0x184 // float (Size: 0x4)
SGCharacterAIRecoilComponent.WeaponMultiFireShakeWay = 0x188 // uint8_t (Size: 0x1)
SGCharacterAIRecoilComponent.Weapon = 0x190 // SGInventory* (Size: 0x8)
SGCharacterAIRecoilComponent.ExactAimingPoint = 0x198 // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.ExactAimingTurnTime = 0x1a4 // float (Size: 0x4)
SGCharacterAIRecoilComponent.PressureWeaponDimPoint = 0x1a8 // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.PressureWeaponTime = 0x1b4 // float (Size: 0x4)
SGCharacterAIRecoilComponent.PressureWeaponRecoverPowerXY = 0x1b8 // float (Size: 0x4)
SGCharacterAIRecoilComponent.PressureWeaponRecoverPowerZ = 0x1bc // float (Size: 0x4)
SGCharacterAIRecoilComponent.bIsReachLimitRecoil = 0x1c0 // bool (Size: 0x1)
SGCharacterAIRecoilComponent.FocalPointOffset = 0x1c4 // FVector (Size: 0xc)
SGCharacterAIRecoilComponent.AIFireComponent = 0x1d0 // SGCharacterAIFireComponent* (Size: 0x8)
SGCharacterAIRecoilComponent.AIAimingComponent = 0x1d8 // SGCharacterAIAimingComponent* (Size: 0x8)
SGCharacterAIRecoilComponent.ShootProps = 0x1e0 // NPCAIPropertyComponent_Shoot* (Size: 0x8)
SGCharacterAIRecoilComponent.AimingProps = 0x1e8 // NPCAIPropertyComponent_Aiming* (Size: 0x8)
SGCharacterAISoundComponent.DeathGruntPath = 0x680 // FString (Size: 0x10)
SGCharacterAISoundComponent.GetHitGruntPath = 0x690 // FString (Size: 0x10)
SGCharacterAISoundComponent.ConfirmTargetScream = 0x6a0 // AkAudioEvent* (Size: 0x8)
SGCharacterAISoundComponent.CurrSoundRepInfo = 0x6a8 // FAISoundRepInfo (Size: 0x8)
SGCharacterAIStaticsComponent.AIMainType = 0x108 // EEAIMainType (Size: 0x1)
SGCharacterAIStaticsComponent.WeaponShootingMovingScale = 0x10c // float (Size: 0x4)
SGCharacterAIStaticsComponent.BulletArmorPenetrationNotHurt = 0x110 // float (Size: 0x4)
SGCharacterAIStaticsComponent.ChangeFactionTime = 0x114 // float (Size: 0x4)
SGCharacterAIStaticsComponent.AmmoClassCache = 0x118 // ClassProperty (Size: 0x8)
SGCharacterAIStaticsComponent.AITypeProps = 0x120 // NPCAIPropertyComponent_AIType* (Size: 0x8)
SGCharacterAIStaticsComponent.MultiTargetSelectorComponent = 0x128 // NPCAIMultiTargetSelectorComponent* (Size: 0x8)
SGCharacterAITakeCoverComponent.bAITakeCover = 0x238 // bool (Size: 0x1)
SGCharacterAITurnComponent.ControllerInterpSpeed = 0x358 // float (Size: 0x4)
SGCharacterAITurnComponent.ControllerAcceleratedSpeed = 0x35c // float (Size: 0x4)
SGCharacterAITurnComponent.ControllerTurnSpeedMax = 0x360 // float (Size: 0x4)
SGCharacterAITurnComponent.ControllerTurnSpeedMin = 0x364 // float (Size: 0x4)
SGCharacterAITurnComponent.bTurnSpeedUp = 0x368 // bool (Size: 0x1)
SGCharacterAITurnComponent.bEnabledUseTurnComponent = 0x369 // bool (Size: 0x1)
SGCharacterAITurnComponent.ActualActorRTurnSpeed = 0x36c // float (Size: 0x4)
SGCharacterAITurnComponent.ActorLastRotation = 0x370 // FRotator (Size: 0xc)
SGCharacterAITurnComponent.bEnabledQuicklyTurnInPlace = 0x37c // bool (Size: 0x1)
SGCharacterAITurnComponent.MinRootBoneRotationYawThreshold_Quickly = 0x380 // float (Size: 0x4)
SGCharacterAITurnComponent.MaxRootBoneRotationYawThreshold_Quickly = 0x384 // float (Size: 0x4)
SGCharacterAITurnComponent.UpdateInterval = 0x390 // float (Size: 0x4)
SGCharacterAITurnComponent.ElapsedTimeFromLastUpdate = 0x394 // float (Size: 0x4)
SGCharacterAITurnComponent.WaitTimeForUpdate = 0x398 // float (Size: 0x4)
SGCharacterAITurnComponent.LookToPointLockTime = 0x39c // float (Size: 0x4)
SGCharacterAITurnComponent.LookPointMode = 0x3a0 // EEAILookPointMode (Size: 0x1)
SGCharacterAITurnComponent.LookDirection = 0x3a4 // FVector (Size: 0xc)
SGCharacterAITurnComponent.TurnTargetPoint = 0x3b0 // FVector (Size: 0xc)
SGCharacterAITurnComponent.bCompletedSegmentTurn = 0x3bc // bool (Size: 0x1)
SGCharacterAITurnComponent.TotalTurnRotateYaw = 0x3c0 // float (Size: 0x4)
SGCharacterAITurnComponent.CacheTurnTargetPoint = 0x3c4 // FVector (Size: 0xc)
SGCharacterAITurnComponent.CacheLookPointMode = 0x3d0 // EEAILookPointMode (Size: 0x1)
SGCharacterAITurnComponent.TurnSpeedScaleForCrossfire = 0x3d4 // float (Size: 0x4)
SGCharacterAITurnComponent.SmoothTurnAngleInterpSpeed = 0x3d8 // float (Size: 0x4)
SGCharacterAITurnComponent.SmoothedTurnAngle = 0x3dc // float (Size: 0x4)
SGCharacterAITurnComponent.MoveProps = 0x3e0 // NPCAIPropertyComponent_Move* (Size: 0x8)
SGCharacterAITurnComponent.AIMoverComponent = 0x3e8 // NPCAIMoverSystemComponent* (Size: 0x8)
SGCharacterAITurnComponent.MovementComponent = 0x3f0 // SGCharacterMovementComponent* (Size: 0x8)
SGCharacterAITurnComponent.AimingComponent = 0x3f8 // SGCharacterAIAimingComponent* (Size: 0x8)
SGCharacterAIWeaponManagerComponent.CheckWeaponSwitchInterval = 0x690 // float (Size: 0x4)
SGCharacterAIWeaponManagerComponent.NextCheckWeaponTime = 0x694 // float (Size: 0x4)
SGCharacterAIWeaponManagerComponent.GoalWeaponType = 0x698 // EEWeaponSwitchType (Size: 0x1)
SGCharacterAIWeaponManagerComponent.FromWeaponType = 0x699 // EEWeaponSwitchType (Size: 0x1)
SGCharacterAIWeaponManagerComponent.TimeHandler = 0x6a0 // FTimerHandle (Size: 0x8)
SGCharacterAIWeaponManagerComponent.bEnabledTimer = 0x6a8 // bool (Size: 0x1)
SGCharacterAIWeaponTraceComponent.HeadBone = 0x590 // FName (Size: 0x8)
SGCharacterAIWeaponTraceComponent.AIProne_Trace_OffsetZ = 0x598 // float (Size: 0x4)
SGCharacterAIWeaponTraceComponent.AI_WeaponTrace_StartPointOffset = 0x59c // FVector (Size: 0xc)
SGCharacterAIWeaponTraceComponent.AI_WeaponTrace_StartPointOffset_LeftLean = 0x5a8 // FVector (Size: 0xc)
SGCharacterAIWeaponTraceComponent.AI_WeaponTrace_StartPointOffset_RightLean = 0x5b4 // FVector (Size: 0xc)
SGCharacterActivityComponent.MarkEffectClass = 0x108 // ClassProperty (Size: 0x8)
SGCharacterActivityComponent.BeMarkedEffectClass = 0x110 // ClassProperty (Size: 0x8)
SGCharacterAnimInstance.LocalProxy = 0x700 // FSGCharacterAnimInstanceProxy (Size: 0x1790)
SGCharacterAnimInstanceBase.CharacterAnimationSetsClass = 0x2b8 // ClassProperty (Size: 0x8)
SGCharacterAnimInstanceBase.PerWeaponAnimationSetsClass = 0x2c0 // ClassProperty (Size: 0x8)
SGCharacterAnimInstanceBase.PerWeaponAnimationSetsClass_Left = 0x2c8 // ClassProperty (Size: 0x8)
SGCharacterAnimInstanceBase.Trigger_RunJump_Loop2End_LandPredicAlpha = 0x2d0 // float (Size: 0x4)
SGCharacterAnimInstanceBase.Trigger_IdleJump_Loop2End_LandPredicAlpha = 0x2d4 // float (Size: 0x4)
SGCharacterAnimInstanceBase.bUseOverrideAOInterpolationTime = 0x2d8 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.AOInterpolationDecreaseScalerByTurnInPlaceRootMotion = 0x2dc // float (Size: 0x4)
SGCharacterAnimInstanceBase.AOInterpolationTime = 0x2e0 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SpineOffsets = 0x2e4 // FSpineOffsetPreset (Size: 0x18)
SGCharacterAnimInstanceBase.LookAround_Head_AO_3P = 0x350 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceBase.ZoomingAlphaToCameraPosBlendRatio_1P = 0x358 // CurveFloat* (Size: 0x8)
SGCharacterAnimInstanceBase.RootYawOffsetClamp = 0x360 // FFloatRange (Size: 0x10)
SGCharacterAnimInstanceBase.RootYawOffsetBlendOutSpeed = 0x370 // float (Size: 0x4)
SGCharacterAnimInstanceBase.RootYawOffset = 0x374 // float (Size: 0x4)
SGCharacterAnimInstanceBase.RootYawOffsetBlendOutSpeed_High = 0x37c // float (Size: 0x4)
SGCharacterAnimInstanceBase.bUseCustomRootYawOffsetMode = 0x381 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.bEnableRootYawOffsetMode = 0x382 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.CustomRootYawOffsetMode = 0x383 // EERootYawOffsetMode (Size: 0x1)
SGCharacterAnimInstanceBase.SpeedWarpingRatioRange_3P = 0x384 // FFloatRange (Size: 0x10)
SGCharacterAnimInstanceBase.MovementPlayRateScaler_1PADS = 0x394 // float (Size: 0x4)
SGCharacterAnimInstanceBase.MovementPlayRateRange_1P = 0x398 // FFloatRange (Size: 0x10)
SGCharacterAnimInstanceBase.MovementPlayRateRange_3P = 0x3a8 // FFloatRange (Size: 0x10)
SGCharacterAnimInstanceBase.OverrideUpperBodyBlender = 0x3b8 // FAlphaBlend (Size: 0x30)
SGCharacterAnimInstanceBase.OverrideUpperBodyBlenderBlendInBias = 0x3e8 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SprintWeaponOffset_MaxAOPitch = 0x3ec // float (Size: 0x4)
SGCharacterAnimInstanceBase.AOPitchRatioToSprintWeaponOffsetRatio = 0x3f0 // CurveFloat* (Size: 0x8)
SGCharacterAnimInstanceBase.AOPitchRatioToProneMoveWeaponOffsetRatio = 0x3f8 // CurveFloat* (Size: 0x8)
SGCharacterAnimInstanceBase.DisableAOUpInterpSpeed = 0x400 // float (Size: 0x4)
SGCharacterAnimInstanceBase.LocomotionAnimInstanceTag = 0x404 // FName (Size: 0x8)
SGCharacterAnimInstanceBase.StandardSightPosition3P = 0x40c // float (Size: 0x4)
SGCharacterAnimInstanceBase.MovingRatioInterpSpeed = 0x410 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SprintRatioInterpSpeed = 0x414 // float (Size: 0x4)
SGCharacterAnimInstanceBase.ProneRatioInterpSpeed = 0x418 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SprintSharpTurnLeanAccumulateInterpSpeed = 0x41c // float (Size: 0x4)
SGCharacterAnimInstanceBase.bSprintSharpTurnLeanAccumulateConstantInterp = 0x420 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.SprintSharpTurnLeanFadeoutInterpSpeed = 0x424 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SprintSharpTurnLeanExitStateInterpSpeed = 0x428 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SprintSharpTurnLeanAmountRange = 0x42c // FFloatRange (Size: 0x10)
SGCharacterAnimInstanceBase.SprintSharpTurnLeanFullyBlendInThreshold = 0x43c // float (Size: 0x4)
SGCharacterAnimInstanceBase.AccVelSameDirAngleThreshold = 0x440 // float (Size: 0x4)
SGCharacterAnimInstanceBase.VelocityDirNotChangeAngleThreshold = 0x444 // float (Size: 0x4)
SGCharacterAnimInstanceBase.TacticalGripAdditive_3P = 0x448 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceBase.TacticalGripAdditive = 0x450 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceBase.TacticalPistolGripBase_3P = 0x458 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceBase.TacticalPistolGripBase = 0x460 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceBase.GroundDistance = 0x468 // float (Size: 0x4)
SGCharacterAnimInstanceBase.SGCharacterOwner = 0x470 // SGCharacter* (Size: 0x8)
SGCharacterAnimInstanceBase.bEnableSpring_3P = 0x479 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.RecoilSpring_3P = 0x480 // FAnimationSpring (Size: 0x110)
SGCharacterAnimInstanceBase.FilterLength = 0x590 // int32_t (Size: 0x4)
SGCharacterAnimInstanceBase.FilterPos = 0x594 // int32_t (Size: 0x4)
SGCharacterAnimInstanceBase.SmoothingFilter = 0x598 // TArray<float> (Size: 0x10)
SGCharacterAnimInstanceBase.RecoilSpring_MaxVal = 0x5a8 // float (Size: 0x4)
SGCharacterAnimInstanceBase.RecoilPlayer3P = 0x5b0 // FSGTPPRecoilConfig (Size: 0x48)
SGCharacterAnimInstanceBase.RecoilPlayer3P_MaxVal = 0x5f8 // float (Size: 0x4)
SGCharacterAnimInstanceBase.RecoilModifer_3P = 0x600 // FForceModifier (Size: 0xb0)
SGCharacterAnimInstanceBase.BaseFov = 0x6b8 // float (Size: 0x4)
SGCharacterAnimInstanceBase.FovCorrectionReferenceDepth = 0x6bc // float (Size: 0x4)
SGCharacterAnimInstanceBase.FovCorrectionValidRange = 0x6c0 // FVector2D (Size: 0x8)
SGCharacterAnimInstanceBase.bIsCrouchToStanding_cpp = 0x6c8 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.bIsStandToCrouching_cpp = 0x6c9 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.HandWeaponOffset_3P = 0x6cc // FVector (Size: 0xc)
SGCharacterAnimInstanceBase.bEnableLODLoadBalance = 0x6d8 // bool (Size: 0x1)
SGCharacterAnimInstanceBase.AnimDebugLogContainer = 0x6e0 // FSGAnimationDebugLogContainer (Size: 0x10)
SGCharacterAnimInstanceProxy.CachedCastShadowComponent = 0x1788 // SGCharacterCastShadowComponent* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Idle = 0x860 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CasualStandAnimations_3P = 0x868 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.StandAnimations_3P = 0x870 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Idle_FixUpRightHand = 0x878 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_IdleLeanLeft = 0x880 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_IdleLeanRight = 0x888 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Idle_AO = 0x890 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Idle_AO_LeanLeft = 0x898 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Idle_AO_LeanRight = 0x8a0 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Locomotion = 0x8a8 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_AimOffset = 0x8b0 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_AimOffsetLeanLeft = 0x8b8 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_AimOffsetLeanRight = 0x8c0 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stand_Locomotion_Type = 0x8c8 // EELocomotionType (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bHasLocomotion_Fracture = 0x8c9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Stand_AccelerationLeanBS = 0x8d0 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.StandSprint_AccelerationLeanBS = 0x8d8 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.AccelerationLeanBS = 0x8e0 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.SprintSharpTurnLeanBS = 0x8e8 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasStand_AccelerationLeanBS = 0x8f0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Crouch_Idle = 0x8f8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_IdleLeanLeft = 0x900 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_IdleLeanRight = 0x908 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_Idle_AO = 0x910 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_Idle_AO_LeanLeft = 0x918 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_Idle_AO_LeanRight = 0x920 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_Locomotion = 0x928 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_AimOffset = 0x930 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_AimOffsetLeanLeft = 0x938 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Crouch_AimOffsetLeanRight = 0x940 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_Idle = 0x948 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_IdleLeanLeft = 0x950 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_IdleLeanRight = 0x958 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_Idle_AO = 0x960 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_Idle_AO_LeanLeft = 0x968 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_Idle_AO_LeanRight = 0x970 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_AimOffset = 0x978 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_AimOffsetLeanLeft = 0x980 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone_AimOffsetLeanRight = 0x988 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_Idle = 0x990 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_IdleLeanLeft = 0x998 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_IdleLeanRight = 0x9a0 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_Idle_AO = 0x9a8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_Idle_AO_LeanLeft = 0x9b0 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_Idle_AO_LeanRight = 0x9b8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_AimOffset = 0x9c0 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_AimOffsetLeanLeft = 0x9c8 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DBNO_AimOffsetLeanRight = 0x9d0 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Current_Idle = 0x9d8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.DeathAnim = 0x9e0 // AnimSequenceBase* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Current_1PRelaxAnimation = 0x9e8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Dive_AimOffset = 0x9f0 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Prone360_AimOffset = 0x9f8 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CurrentProne_AimOffset = 0xa00 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Stance = 0xa08 // EEAnimStance (Size: 0x1)
SGCharacterAnimInstanceProxyBase.WeaponStance = 0xa09 // EEWeaponType (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsStand = 0xa0a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCasual = 0xa0b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCrouch = 0xa0c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsProne = 0xa0d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bProneChangeThisFrame = 0xa0e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LocomotionWeaponStance = 0xa0f // EELocomotionWeaponStance (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsDBNO = 0xa10 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLadderClimbing = 0xa11 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.PronePlayRate = 0xa14 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsMoving = 0xa18 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsNotMoving = 0xa19 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLocationChagned = 0xa1a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bILastLocationChagned = 0xa1b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsMovingForward = 0xa1c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsMovingOnGround = 0xa1d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsNotSprinting = 0xa1e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSprinting = 0xa1f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSprintingLastUpdate = 0xa20 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.MovingRatio = 0xa24 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.NotMovingRatio = 0xa28 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintingRatio = 0xa2c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.NotSprintingRatio = 0xa30 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bFullySprinting = 0xa34 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsShadow = 0xa35 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.ProneRatio = 0xa38 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bInVaultAnimation = 0xa3c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIs1PSprinting = 0xa3d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIs1PMeleeWeaponSprinting = 0xa3e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIs1PPistolSprinting = 0xa3f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSprintAddtive = 0xa40 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSprintingLastTime = 0xa41 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.MovementStance = 0xa44 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsLeaning = 0xa48 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLeaningLeft = 0xa49 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLeaningRight = 0xa4a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsDead = 0xa4b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LeanAimType = 0xa4c // EEWeaponLeanAimType (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LeftLeanAOAdditiveAlpha_3P = 0xa50 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RightLeanAOAdditiveAlpha_3P = 0xa54 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsFPP = 0xa58 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLocalPlayerControlled = 0xa59 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIs1P = 0xa5a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsNot1P = 0xa5b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CharacterSex = 0xa5c // EECharacterSex (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IdleBreathAlpha = 0xa60 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsAiming = 0xa64 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSwitchingScope = 0xa65 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsScoping = 0xa66 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsTwoHandsMeleeWeapon = 0xa67 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CurrentSightFov = 0xa68 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsScopingWithRearSight = 0xa6c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithGun = 0xa6d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithoutGun = 0xa6e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithThrown = 0xa6f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithTacticalGear = 0xa70 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithMelee = 0xa71 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithMainWeapon = 0xa72 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithAssistWeapon = 0xa73 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithDualHandWeapon = 0xa74 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsArmedWithGunAndNotInTacticalState = 0xa75 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsReloading = 0xa76 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsUpperbody = 0xa77 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsMirrorAnim = 0xa78 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsUsingItem = 0xa79 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCheckingWeapon = 0xa7a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldUseHandOffset = 0xa7b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bCanPlayIdleAnim = 0xa7c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IdleAnimIndex = 0xa80 // int32_t (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsFiring = 0xa84 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSilentWalk = 0xa85 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingSlotAnimation = 0xa86 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingSlotAnimation_UpperBody = 0xa87 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingAdditiveMontage_UpperBody = 0xa88 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bOverrideRightHandPostAdditive = 0xa89 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingFireMontage = 0xa8a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingSlotAnimation_LeftHand = 0xa8b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingSlotAnimation_TacticalPistol = 0xa8c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingAnimMontage = 0xa8d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bDisableAdditiveMontageBlendPerBone = 0xa8e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsEmptyHand = 0xa8f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPrviewCharacter = 0xa90 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FPPAnimWeight_Translation = 0xa94 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FPPAnimWeight_Rotation = 0xa98 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldBlendFPPAnimWeight = 0xa9c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldFPPWeaponSway = 0xa9d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bAnimSetReady = 0xa9e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bPlayingCustomAnimation = 0xa9f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsShadowMesh = 0xaa0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldModifyAOCurve = 0xaa1 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldModifyCopyHandGunIKBone = 0xaa4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldMovementSway = 0xaa8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldStandToCrouching = 0xaa9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldCrouchingToStand = 0xaaa // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsFPPAndAiming = 0xaab // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsFPPAndNotAiming = 0xaac // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.fIsFPPInEmptyScreen = 0xab0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.fIsFPPAndAiming = 0xab4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsLegOutOfEndurance = 0xab8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsDiving = 0xab9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsDivingOrProne = 0xaba // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldTick1PRelax = 0xabb // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bProne360AnimEnabled = 0xabc // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IsTransToProne = 0xac0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsDivingOrFullyProne = 0xac4 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bTacticalPistol = 0xad8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CurrentTacticalPisotlStatus = 0xadc // EETacticalPistolStatus (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bFPPAndNotInOrTransTacticalPistolState = 0xae0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bInOrTransTacticalPistolState = 0xae4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalLeftHandWeaponGripAlpha = 0xae8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalRightHandWeaponGripAlpha = 0xaec // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalPistolHandOffsetAlpha = 0xaf0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalPistolWeaponGripAlphaBeforeADS = 0xaf4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalPistolWeaponGripAlphaAfterADS = 0xaf8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bAdditiveTacticalPistolGrip = 0xafc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldTacticalPistolCopyItemr = 0xb00 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bTacticalPistolAiming = 0xb04 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bFPPTacticalPistolAiming = 0xb08 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsTacticalBallisticShieldGrip = 0xb0c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIs3PTacticalBallisticShieldGrip = 0xb10 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldCopyVB_root_ik_hand_r = 0xb14 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Tactical_IdleSeq_Additive = 0xb18 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Tactical_LeftHandGripBS = 0xb20 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.EnableBlendTacticaWeaponBaseGrip = 0xb28 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeftHandWeaponBaseGripPose = 0xb30 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalPistolBaseGripPose = 0xb38 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalPistolStandBasePose = 0xb40 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalPistolCrouchBasePose = 0xb48 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalRightHandGripPose = 0xb50 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalRightHandNegAdditiveSequence = 0xb58 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalLeftHandOffset = 0xb60 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.TacticalRightHandOffset = 0xb6c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.TacticalWeaponForegripType = 0xb78 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LastTacticalPistolStatus = 0xb7c // EETacticalPistolStatus (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Enable_BlendTacticaMontage_IKGun = 0xb80 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_BlendTacticaMontage_RightHand = 0xb84 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_BlendTacticaMontage_LeftHand = 0xb88 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UpperBodyBlendAlpha_LeftHand = 0xb8c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UpperBodyBlendAlpha_RightHand = 0xb90 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalZoomingAlpha = 0xb94 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalUnZoomingAlpha = 0xb98 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalLeftHandGunkickAlpha_Aiming = 0xb9c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalLeftHandGunkickAlpha_NotAiming = 0xba0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldOverrideLocomotionPelvis = 0xba4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.HandState = 0xba8 // EESGHandState (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bInTacticalState = 0xba9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bTacticalStateChangeThisUpdate = 0xbaa // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bNotInTacticalState = 0xbab // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.EnableTacticalGripAdditive = 0xbac // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalLeftHandRifleOffsetAlpha = 0xbb0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalGripAdditiveSeq = 0xbb8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalADSAdditiveSeq = 0xbc0 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalPistolIdleSeqAdditive = 0xbc8 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalHideHandRAlpha = 0xbd0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TacticalToPistolAlpha = 0xbd4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovementSpeedScale = 0xbd8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bWantStop = 0xbdc // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.MovingDirection = 0xbe0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovingDirectionClamped = 0xbe4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovingDirectionCompensation = 0xbe8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovingDirectionOrientationWarpCopyBoneAlpha = 0xbec // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WantToMoveDirAngle = 0xbf0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.PawnToCamerAngle = 0xbf4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.NormalizedSpeed = 0xbf8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.VerticalVelocity = 0xbfc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.HorizontalVelocity = 0xc00 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AccLength = 0xc04 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AccDirection = 0xc08 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.VelocityBeforStop = 0xc0c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AccDirBeforStop = 0xc10 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.DirectionBeforStop = 0xc14 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ProneRampRotationPitch = 0xc18 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ProneRampRotation = 0xc1c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovementPlayRate = 0xc20 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovementStartPosition = 0xc24 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MovementSpeedWarping = 0xc28 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsPlayingRootMotion = 0xc2c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FPPLowerBodyOffset = 0xc30 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.FPPJumpUpperBodyOffset = 0xc3c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentFloorSlope = 0xc50 // FQuat (Size: 0x10)
SGCharacterAnimInstanceProxyBase.bInsideFoliageBound = 0xc60 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bUseStaticWalk = 0xc61 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Acceleration = 0xc64 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Velocity = 0xc70 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.VelocityLastUpdate = 0xc7c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AccVelAngle = 0xc88 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.VelocityAngleDeltaSinceLastUpdate = 0xc8c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bMovingIntoWall = 0xc90 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CoachLookAtLocation = 0xc94 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CoachLookAtYaw = 0xca0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CoachLookAtPitch = 0xca4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CoachLookAtAlpha = 0xca8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.BreathTranslation = 0xcac // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.BreathTranslation_SilentWalk = 0xcb8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.BreathRotation = 0xcc4 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.RotationYaw = 0xcd0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RotationPitch = 0xcd4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Yaw = 0xcd8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Pitch = 0xcdc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Roll = 0xce0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ViewRotation_LastFrame = 0xce4 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ViewRotation = 0xcf0 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AORotation = 0xcfc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AORotationWithWeaponSway = 0xd08 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AORotationWithWeaponSway_OnlyYaw = 0xd14 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AORotationWithWeaponSway_OnlyPitch = 0xd20 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.SpineOffset = 0xd2c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.SpineOffsetWhenPitch = 0xd38 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponSwayAlpha_Yaw = 0xd44 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponSwayAlpha_Pitch = 0xd48 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponSwayDelay_Yaw = 0xd4c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponSwayDelay_Pitch = 0xd50 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bShouldUseAO = 0xd54 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.MeshRotationOffset = 0xd58 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.MeshLocationOffset = 0xd64 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.MeshLegsRotationOffset = 0xd70 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bUseOverrideInterpolationParam = 0xd7c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.OverrideInterpolationParam_X = 0xd80 // FInterpolationParameter (Size: 0x8)
SGCharacterAnimInstanceProxyBase.OverrideInterpolationParam_Y = 0xd88 // FInterpolationParameter (Size: 0x8)
SGCharacterAnimInstanceProxyBase.WeaponShakeAlpha = 0xd90 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponShakeType = 0xd94 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RootBoneRotationYaw = 0xd98 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RootYawOffsetMode = 0xd9c // EERootYawOffsetMode (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsJumping = 0xd9d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsFalling = 0xd9e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FallingAnimType = 0xda0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsInAir = 0xda4 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPreJump = 0xda5 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsNoneJumpState = 0xda6 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsNotInAir = 0xda7 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsLanding = 0xda8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsHighJump = 0xda9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSprintJumping = 0xdaa // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsRunJumping = 0xdab // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSliding = 0xdac // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.SlideAngle = 0xdb0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FallingAlpha = 0xdb4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LandingAlpha = 0xdb8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LandPredictionAlpha = 0xdbc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bTrigger_RunJump_Loop2End = 0xdc0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bTrigger_IdleJump_Loop2End = 0xdc1 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LandingTranslation_Ribcage = 0xdc4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LandingTranslation_RCollarBone = 0xdd0 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LandingRotation_RPalm = 0xddc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeanRollOffset = 0xde8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeanRotation_Ribcage = 0xdec // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeanOffset = 0xdf8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeanTranslation_Spine1 = 0xe04 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeanDuration = 0xe10 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bEnableAccelerationLean = 0xe14 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableRunningAccelerationLean = 0xe15 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSprintingAccelerationLean = 0xe16 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSprintSharpTurnAdditive = 0xe17 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.AccelerateLeanAmount_X = 0xe18 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AccelerateLeanAmount_Y = 0xe1c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeanLeftAOAdditiveRatio_3P = 0xe20 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeanRightAOAdditiveRatio_3P = 0xe24 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintSharpTurnLeanAmount = 0xe28 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TargetSprintSharpTurnLeanAmount = 0xe2c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LastMeshDirAccDirDiff = 0xe30 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintSharpTurnLeanAmountBlendIn = 0xe34 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.AccumulatedMeshDirAccDirDiff = 0xe38 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AccelerationVelocityAngle = 0xe3c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CharacterRotation = 0xe40 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CharacterRotationYawDelta = 0xe4c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsRagdoll = 0xe50 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.RagdollPose = 0xe58 // FPoseSnapshot (Size: 0x38)
SGCharacterAnimInstanceProxyBase.DeathDirection = 0xe90 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.DeathStance = 0xe94 // int32_t (Size: 0x4)
SGCharacterAnimInstanceProxyBase.DeathBodyPart = 0xe98 // int32_t (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SGAnimInstance = 0xea0 // SGCharacterAnimInstanceBase* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.SGLocomotionAnimInstance = 0xea8 // SGCharacterLocomotionAnimInstance* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CharacterAnimationComponent = 0xeb0 // SGCharacterAnimationComponent* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.SGCharacter = 0xeb8 // SGCharacter* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.SGWeapon = 0xec0 // SGWeapon* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TacticalWeapon = 0xec8 // SGWeapon* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.LastTacticalWeapon = 0xed0 // SGWeapon* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.SGOrnamentMesh = 0xed8 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bIsWeaponChange = 0xee0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.WeaponForLocomotion = 0xee8 // SGWeapon* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bStanceChanged = 0xef0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIs1PChanged = 0xef1 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bHasTransition = 0xef2 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.TransitionType = 0xef4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bHasAnimStanceTransition = 0xef8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.AnimStanceTransitionType = 0xefc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintTransitionOutPlayRate = 0xf00 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CopyPoseFrom = 0xf08 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Current1PRelaxRemaingTime = 0xf10 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Shared1PRelaxRemaingTime = 0xf14 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CurrentIdle1PRelaxTriggerTime = 0xf18 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Idle1PRelaxAccTime = 0xf1c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.MeleeRecoilRotation = 0xf20 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponStabilityAlpha = 0xf2c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AimingScale = 0xf30 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponSwayTranslation_RPalm = 0xf34 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponSwayRotation_RPalm = 0xf40 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponSwaySpringPivotOffset = 0xf4c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponADSRotation_Shake = 0xf58 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponADSLocation_Shake = 0xf64 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponADSLocation_Shake_Camera = 0xf70 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bShouldUseADSBreath = 0xf7c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldUseFPPBreathCurve = 0xf7d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bShouldUseFPPBreathAnimation = 0xf80 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FPPIdleBreathAnimation = 0xf88 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.WeaponWithStockHoldingOffset = 0xf90 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponGunTranslation = 0xf9c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponGunRotator = 0xfa8 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponShakePivotOffset = 0xfb4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSWeaponGunTranslation = 0xfc0 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSWeaponGunRotator = 0xfcc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSWeaponSightRotator = 0xfd8 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSWeaponShakePivotOffset = 0xfe4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSWeaponSightShakePivotOffset = 0xff0 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponSwayRotation_ADS_RPalm = 0xffc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponTraceLocationOffset_RightHand = 0x1008 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponTraceRotationOffset_RightHand = 0x1014 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponTraceLocationOffset_LeftHand = 0x1020 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponTraceRotationOffset_LeftHand = 0x102c // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponFoldWeight = 0x1038 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponTraceRUpperArmRot = 0x103c // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponTraceRForeArm1Rot = 0x1048 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CameraOffsetForWeaponTrace = 0x1054 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponMovementSwayRotation = 0x1060 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponZoomTime = 0x106c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponUnZoomTime = 0x1070 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponZoomAnimRate = 0x1074 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponUnZoomAnimRate = 0x1078 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ZoomingAlpha = 0x107c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UnZoomingAlpha = 0x1080 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ZoomingAnimTime = 0x1084 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UnZoomingAnimTime = 0x1088 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AlphaForZoomingBranch = 0x108c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.AlphaForUnzoomingBranch = 0x1090 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bCachedIsAiming = 0x1094 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bInitFromHipFiring = 0x1095 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bInitFromADS = 0x1096 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.HoldingWeaponAlpha = 0x1098 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ZoomingOffset_Location_3P = 0x109c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingLagPivotOffset = 0x10a8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingHandOffset = 0x10b4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingHandRotOffset = 0x10c0 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingIronSightOffset = 0x10e4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingIronSightRotOffset = 0x10f0 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentZoomingHandOffset = 0x10fc // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentZoomingHandRotOffset = 0x1108 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentZoomingCameraOffset = 0x1124 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ZoomingCameraOffset = 0x1130 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.UnZoomingHandOffset_X = 0x113c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bADSMoveCamera = 0x1148 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CameraPosBlendRatio = 0x114c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bExperimentalADS = 0x1150 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsWeaponCollapsed = 0x1151 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.BreathInfo = 0x1178 // FSGAnimationBreathInfo (Size: 0x18)
SGCharacterAnimInstanceProxyBase.TakeHitBlendSpace = 0x1190 // BlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.TakeHitAnimationPlayRate = 0x1198 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bBlendShapeSwitch = 0x119c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.TakeHitDirX = 0x11a0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TakeHitDirY = 0x11a4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.TakeHitAlpha = 0x11a8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsTakingHit = 0x11ac // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsProneTakingHit = 0x11ad // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.EnableTakeHitAdditive = 0x11b0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.StartPos = 0x11b4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsPoseCache = 0x11b8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.PoseCache = 0x11c0 // FPoseSnapshot (Size: 0x38)
SGCharacterAnimInstanceProxyBase.WeaponHandgripType = 0x11f8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bHasIdleSeqBasePose = 0x11fc // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IdleSeqBasePose = 0x1200 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasIdleSeq = 0x1208 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IdleSeq = 0x1210 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasIdleSeq_Additive = 0x1218 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.IdleSeq_Additive = 0x1220 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.IdleSeq_Additive_Prone = 0x1228 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.ADS_IdleSeq_Additive = 0x1230 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.ZoomInSeq_GripBased_Additive = 0x1238 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.ZoomOutSeq_GripBased_Additive = 0x1240 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bShouldUseZoomAnimation = 0x1248 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bHasCasualIdleSeq = 0x1249 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CasualIdleSeq = 0x1250 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.ForeGripOffset = 0x1258 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponShakeBS = 0x1268 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasWeaponShakeBS = 0x1270 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.HandWeaponOffset_LeftHand = 0x1274 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.HandWeaponOffset_RightHand_Location = 0x1280 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.HandWeaponOffset_RightHand_Rotation = 0x128c // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.HandOffset_L_Location = 0x1298 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Enable_HandOffset_L_Alpha = 0x12a4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.HandOffset_R_Location = 0x12a8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Enable_HandOffset_R_Alpha = 0x12b4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponReargripType = 0x12b8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RearGripIdleBS = 0x12c0 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CasualRearGripIdleBS = 0x12c8 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.Enable_RightHandGripPose = 0x12d0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bHasForegrip = 0x12d4 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.WeaponForegripType = 0x12d8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.GripPoseAdjustmentAlpha = 0x12dc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CasualGripAdjustmentBS = 0x12e0 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.EnableGestureArmRotWhenProne = 0x12e8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.HandWeaponOffset = 0x12ec // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.TPPWeaponOffsetCrouchMoving = 0x12f8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponOffsetSprintingViewWeapon = 0x1304 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.EnableTargetIK = 0x1310 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LeftHandTarget = 0x1314 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeftHandTargetOffset = 0x1320 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeftShoudlerLocation = 0x132c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LeftShoudlerRotation = 0x1338 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.SprintWeaponOffsetRatio = 0x1344 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ProneMoveWeaponOffsetRatio = 0x1348 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.ProneMoveWeaponOffset = 0x134c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.DBNOMeshRotationOffset = 0x1358 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponSprintLeftArmRot = 0x1364 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentWeaponRotOffsetInsideFoliage = 0x1370 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentWeaponLocOffsetInsideFoliage = 0x137c // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentWeaponOffsetInsideFoliage_UnZooming = 0x1388 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Enable_AdaptiveWeaponTriggerAlpha = 0x13b4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.HandOffset_R_AdaptiveWeaponTrigger = 0x13b8 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.AdjustGripIdleBS = 0x13c8 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.AICasualGripIdleBS = 0x13d0 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CasualGripIdleBS = 0x13d8 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.GripIdleBS = 0x13e0 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasReargrip = 0x13e8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LFingerAdaptiveBS = 0x13f0 // BlendSpace1D* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bEnableLFingerAdaptive = 0x13f8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LFingerAdaptiveAlpha = 0x13fc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FP_LeftHandADSAdditive = 0x1400 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bEnableLeftHandADSAdditive = 0x1408 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FP_GripBase_Pose = 0x1410 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bShouldUse1PForeGripPose = 0x1418 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.GripPoseAdditive3P = 0x1420 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.GripPoseBase3P = 0x1428 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bEnableGripPoseAdditive3P = 0x1430 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.LeftHandParentBoneSpaceAlpha = 0x1434 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RightHandParentBoneSpaceAlpha = 0x1438 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.IsTransitioning = 0x143c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.IsForbiddenFire = 0x1440 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.BlendLeftRightArmPose = 0x1444 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Override_BlendPerBone = 0x1448 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_UpperBody_MS = 0x144c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_UpperBody_LS = 0x1450 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_Stand_Clavicle_L = 0x1454 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_Clavicle_R = 0x1458 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_Clavicle_L = 0x145c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_WeaponGrip_HandIKGun = 0x1460 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_UpperBody = 0x1464 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_UpperBody3P = 0x1468 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_UpperBody_Spine = 0x146c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_RightHand = 0x1470 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_RightHand_PostAdditive = 0x1474 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_RightHand_PostAdditive_Force = 0x1478 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_RightHandIndex_PostAdditive = 0x147c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_LeftHand_PostAdditive = 0x1480 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_LeftHand_GripAdditive = 0x1484 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_CopyCameraIKBone = 0x1488 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_WeaponTrace = 0x148c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_WeaponTraceClamped = 0x1490 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_WeaponTraceSquard = 0x1494 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_AO = 0x1498 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_AO_1P = 0x149c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_HandIK = 0x14a0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_AdaptiveWeaponHandGripPose = 0x14a4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_AdditiveHandGripPose = 0x14a8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftHandGripPose = 0x14ac // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_BlendLeftHandGrip = 0x14b0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_BlendRightHandGrip = 0x14b4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeftHandIK_Offset = 0x14b8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RecoilUp = 0x14bc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RecoilBack = 0x14c0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_CameraAnimated_Rotation = 0x14c4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_UpperBodyClavicle = 0x14c8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CameraRotationOffset = 0x14cc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ScalableCameraRotationOffset = 0x14d8 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ScalableCameraTranslationOffset = 0x14e4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Enable_CopyBone_Item_R_To_IK_Hand_Gun = 0x14f0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Additive = 0x14f4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bEnable_AutoOverrideUpperbody = 0x14f8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bAutoOverrideUpperbody3P = 0x14f9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bInvalidAimingTM = 0x14fa // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Enable_Additive_BlendPerBone = 0x14fc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Pelvis_Additive = 0x1500 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Head_Additive = 0x1504 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightArm_Additive = 0x1508 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightHand_Additive = 0x150c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_IKHandGun_Additive = 0x1510 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightHandIK_Additive = 0x1514 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_IKHandGun_Additive = 0x1518 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftArm_Additive = 0x151c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftHand_Additive = 0x1520 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftHandIK_Additive = 0x1524 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Additive_Montage_BlendPerBone = 0x1528 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Pelvis_Additive_Montage = 0x152c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_Head_Additive_Montage = 0x1530 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightArm_Additive_Montage = 0x1534 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightHand_Additive_Montage = 0x1538 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_RightHandIK_Additive_Montage = 0x153c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftArm_Additive_Montage = 0x1540 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftHand_Additive_Montage = 0x1544 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeftHandIK_Additive_Montage = 0x1548 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Override_Stand_Spine_03 = 0x154c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_Montage = 0x1550 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FootLock_L = 0x1554 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FootLock_R = 0x1558 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LookAt = 0x155c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LookAt_RightHand = 0x1560 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LookAtClamp = 0x1564 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_ADS = 0x1568 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.OverrideRightHandToGrip = 0x156c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.OverrideRightHandIKToGrip = 0x1570 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.PostProcessHandTranslation = 0x1574 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.Spine_Montage_Blend_Ratio = 0x1580 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeftHandFollowMagazineRatio = 0x1584 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LeftHandFollowMagazineOffset = 0x1588 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.CurrentTurnYawWeight = 0x1594 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SmoothedEnableUpAORatio = 0x1598 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UpperBodyAnimRatio = 0x159c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bOverrideUpperBody = 0x15a0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.WeaponStanceAlpha_Throwable = 0x15a4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponStanceAlpha_Melle = 0x15a8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponStanceAlpha_Unarmed = 0x15ac // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponStanceAlpha_Rifle = 0x15b0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsProneMoving = 0x15b4 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSilentWalkMoving = 0x15b6 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsSprintAiming = 0x15b7 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.SprintADSTime = 0x15b8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintADSAlpha = 0x15bc // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintADSTranslation = 0x15c0 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.SprintADSRotation = 0x15cc // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.ADSBlendTime = 0x15d8 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bIsSprintingLastTime_3P = 0x15dc // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCrouchAndNotDBNO = 0x15dd // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsProneAndNotDBNO = 0x15de // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsPlayingSlotAnimation_UpperBody_WhenInAir = 0x15df // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bCanCallapseGun = 0x15e0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.DisableUpperbodyLocomotion_3P = 0x15e4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bEnableFPPWeaponLeanRotation = 0x15e8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.PostProcessHandTranslationRatio = 0x15ec // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bDecreaseUpperBodyAnimRatio_3P = 0x15f0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.PlayingUpperBodyAnimWithoutGunRatio = 0x15f4 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bMovingWithoutGunOrUpperbodyAnim = 0x15f8 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCrouchAndMoving = 0x15f9 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bSprintingWithoutDualHandWeaponOrUpperbodyAnim = 0x15fa // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bMovingWithoutUpperbodyAnim = 0x15fb // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bSprintingWithoutGunOrUpperbodyAnim = 0x15fc // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bMovingWithMainWeapon = 0x15fd // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bMovingWithMainWeaponWithoutUpperbodyAnim = 0x15fe // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.SprintingWithAssistWithoutOverrideUpperBody = 0x1600 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SuppressWeaponHandGripUnlessOverridUpperBody = 0x1604 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.SprintOverrideUpperbodyCompensationRatio = 0x1608 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bSprintingWithMeleeAndUpperbodyAnim = 0x160c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bSprintingWithoutUpperbodyAnim = 0x160d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bSprintingViewWeapon = 0x160e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Enable_UnZoomingHandOffsetX = 0x1610 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bSprintingNotIntoWall = 0x1614 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bProneUsingItem = 0x1615 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.ForceGripBasePoseFPProne = 0x1618 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bZoomingInsideFoliage = 0x161c // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bUnZoomingInsideFoliage = 0x161d // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSlopeAdaptationProne = 0x161e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSlopeAdaptationDBNO = 0x161f // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableSprintLArmRotation = 0x1620 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableAvoidSightNotSprinting = 0x1621 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableAvoidSightCrouchMoving = 0x1622 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.ZoomingAlphaWithGun = 0x1624 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UnZoomingAlphaWithGun = 0x1628 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.WeaponFoldAdjustOffsetAlpha = 0x162c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bEnableZoomingIronSightOffsetInTacticalState = 0x1630 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bEnableZoomingIronSightOffsetNotInTacticalState = 0x1631 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bStandCrouchWithTacticalGear = 0x1632 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CopyIKHandGunAfterMontageRatio = 0x1634 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.UpperarmL_Offset = 0x1638 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.UpperarmLMiddleSlider1_Offset = 0x1644 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bNoAdditiveMontage = 0x1650 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.UpperBodySlotAnimationRatio = 0x1654 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_AO_3P = 0x1658 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_ADS_3P = 0x165c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_ADS_HeadAdditive_3P = 0x1660 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.OverrideFootLWhenMovingStop = 0x1664 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.OverrideFootRWhenMovingStop = 0x1668 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_LeanPose_UpperBody = 0x166c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Disable_LeanPose_Spine = 0x1670 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LeanPose_TP = 0x1674 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bHasZoomInOutSeq = 0x1678 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bHasIdleAOSeq = 0x1679 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsStandAndNotMoving = 0x167a // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.bIsCrouchOrMoving = 0x167b // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.RecoilRatio3P = 0x167c // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.RecoilPlayerRatio3P = 0x1680 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FireAdditive_Seq = 0x1688 // AnimSequence* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.bHasFireAdditive_Seq = 0x1690 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.Enable_FireAdditiveTP = 0x1694 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.Enable_LookAroundHeadAOTP = 0x1698 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.LookAroundOffset = 0x169c // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.LookAround_Head_AO_3P = 0x16a8 // AimOffsetBlendSpace* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.FocalPointRatio = 0x16b0 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.FocalPoint = 0x16b4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponOffset3P = 0x16c0 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponOffsetSprinting1P = 0x16cc // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponRotOffsetSprinting1P = 0x16d8 // FRotator (Size: 0xc)
SGCharacterAnimInstanceProxyBase.WeaponOffset3PAvoidSight = 0x16e4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bEnableWeaponOffset3P = 0x16f0 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FovCorrection = 0x16f4 // FVector (Size: 0xc)
SGCharacterAnimInstanceProxyBase.bIsAI = 0x1700 // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.CurrentLOD = 0x1704 // int32_t (Size: 0x4)
SGCharacterAnimInstanceProxyBase.bPlayMontageAddjustAddjustGrip = 0x171e // bool (Size: 0x1)
SGCharacterAnimInstanceProxyBase.GripAdjustLeftHandBlendWeight = 0x1720 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.GripAdjustRightHandBlendWeight = 0x1724 // float (Size: 0x4)
SGCharacterAnimInstanceProxyBase.CurrentCharacterAnimationSetsPerCharacterSex = 0x1728 // SGCharacterAnimationSetsPerCharacterSex* (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CurrentPerWeaponAnimationSetsClass = 0x1730 // ClassProperty (Size: 0x8)
SGCharacterAnimInstanceProxyBase.CurrentPerWeaponAnimationSetsClass_Left = 0x1738 // ClassProperty (Size: 0x8)
SGCharacterAnimInstanceProxyBase.FromMovementStance = 0x1740 // EEMovementStance (Size: 0x1)
SGCharacterAnimInstanceProxyBase.ToMovementStance = 0x1741 // EEMovementStance (Size: 0x1)
SGCharacterAnimInstanceProxyBase.FromAnimStance = 0x1742 // EEAnimStance (Size: 0x1)
SGCharacterAnimInstanceProxyBase.ToAnimStance = 0x1743 // EEAnimStance (Size: 0x1)
SGCharacterAnimInstanceProxyLOD.LocomotionHandIK_CurveValue_Scaler = 0x1778 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.bIsSwitchingPose = 0x8 // bool (Size: 0x1)
SGCharacterAnimReducer_BasePose.CurrentBasePose = 0x10 // AnimSequence* (Size: 0x8)
SGCharacterAnimReducer_BasePose.TargetBasePose = 0x18 // AnimSequence* (Size: 0x8)
SGCharacterAnimReducer_BasePose.BodyAlpha = 0x20 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.LeftLegAlpha = 0x24 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.RightLegAlpha = 0x28 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.PelvisWeight = 0x2c // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.LeftFootWeight = 0x30 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.RightFootWeight = 0x34 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.HandAlpha = 0x38 // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.SwitchPoseTime = 0x3c // float (Size: 0x4)
SGCharacterAnimReducer_BasePose.BodyAlphaCurve = 0x40 // CurveFloat* (Size: 0x8)
SGCharacterAnimReducer_BasePose.LeftLegAlphaCurve = 0x48 // CurveFloat* (Size: 0x8)
SGCharacterAnimReducer_BasePose.RightLegAlphaCurve = 0x50 // CurveFloat* (Size: 0x8)
SGCharacterAnimReducer_BasePose.DistanceToMaxFootAdditiveWeightCurve = 0x58 // CurveFloat* (Size: 0x8)
SGCharacterAnimationComponent.DebugHandIkBonesMesh = 0x100 // StaticMesh* (Size: 0x8)
SGCharacterAnimationComponent.DebugHandIkBonesMeshMaterial = 0x108 // MaterialInterface* (Size: 0x8)
SGCharacterAnimationComponent.DebugHandIkBonesMeshSize = 0x110 // FVector (Size: 0xc)
SGCharacterAnimationComponent.BSAnimNormalizedSpeed = 0x11c // float (Size: 0x4)
SGCharacterAnimationComponent.BSAnimPlayingRate = 0x120 // float (Size: 0x4)
SGCharacterAnimationComponent.bLastFiringState = 0x124 // bool (Size: 0x1)
SGCharacterAnimationComponent.ToRestIdleTime = 0x128 // float (Size: 0x4)
SGCharacterAnimationComponent.PlayRestAnimTime = 0x12c // float (Size: 0x4)
SGCharacterAnimationComponent.bDisableZoomingInsideFoliage = 0x130 // bool (Size: 0x1)
SGCharacterAnimationComponent.bEnableWeaponOffsetInsideFoliage_UnZooming = 0x131 // bool (Size: 0x1)
SGCharacterAnimationComponent.WeaponOffsetInsideFoliage_UnZooming = 0x134 // FVector (Size: 0xc)
SGCharacterAnimationComponent.bEnableWeaponOffsetInsideFoliage = 0x140 // bool (Size: 0x1)
SGCharacterAnimationComponent.WeaponOffsetXRangeInsideFoliage = 0x144 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.WeaponOffsetYRangeInsideFoliage = 0x154 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.WeaponOffsetZRangeInsideFoliage = 0x164 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.WeaponOffsetPitchRangeInsideFoliage = 0x174 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.WeaponOffsetYawRangeInsideFoliage = 0x184 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.WeaponOffsetRollRangeInsideFoliage = 0x194 // FFloatRange (Size: 0x10)
SGCharacterAnimationComponent.YawDeltaThreshold_UpdateWeaponOffsetInsideFoliage = 0x1a4 // float (Size: 0x4)
SGCharacterAnimationComponent.MoveTimeThreshold_UpdateWeaponOffsetInsideFoliage = 0x1a8 // float (Size: 0x4)
SGCharacterAnimationComponent.WeaponOffsetInsideFoliage_LocInterpSpeed = 0x1ac // float (Size: 0x4)
SGCharacterAnimationComponent.WeaponOffsetInsideFoliage_RotInterpSpeed = 0x1b0 // float (Size: 0x4)
SGCharacterAnimationComponent.FPPRunJumpOffset = 0x1b4 // FVector (Size: 0xc)
SGCharacterAnimationComponent.SwitchStanceOffset = 0x1c0 // FVector (Size: 0xc)
SGCharacterAnimationComponent.JumpDistanceWeightCurveName = 0x1cc // FName (Size: 0x8)
SGCharacterAnimationComponent.SwitchStanceCurveName = 0x1d4 // FName (Size: 0x8)
SGCharacterAnimationComponent.DistanceCurveName = 0x1dc // FName (Size: 0x8)
SGCharacterAnimationComponent.bEnableDebugDrawDistanceCurve = 0x1e4 // bool (Size: 0x1)
SGCharacterAnimationComponent.CustomizeSequenceName = 0x1e8 // FString (Size: 0x10)
SGCharacterAnimationComponent.FacialSequenceName = 0x1f8 // FString (Size: 0x10)
SGCharacterAnimationComponent.DTCustomizeSequence = 0x208 // AnimSequence* (Size: 0x8)
SGCharacterAnimationComponent.DTFacialSequence = 0x210 // AnimSequence* (Size: 0x8)
SGCharacterAnimationComponent.BaseForeCharacterGrips = 0x218 // TSet<...> (Size: 0x50)
SGCharacterAnimationComponent.bShouldHandleNetTrans = 0x268 // bool (Size: 0x1)
SGCharacterAnimationComponent.bShouldCacheForeGripOffset = 0x269 // bool (Size: 0x1)
SGCharacterAnimationComponent.ForceLeftHandGripType = 0x26a // EESGWeaponForegripType (Size: 0x1)
SGCharacterAnimationComponent.bUseControlRigAim = 0x26b // bool (Size: 0x1)
SGCharacterAnimationComponent.EyeAimPosition = 0x26c // FVector (Size: 0xc)
SGCharacterAnimationComponent.FaceAimControl = 0x278 // FVector2D (Size: 0x8)
SGCharacterAnimationComponent.CoachLookAtTarget = 0x280 // SceneComponent* (Size: 0x8)
SGCharacterAnimationComponent.bRestMode = 0x288 // bool (Size: 0x1)
SGCharacterAnimationComponent.TestFirstPersonAnimInstanceClass = 0x290 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.TestThirdPersonAnimInstanceClass = 0x298 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.GesturePSC_LeftHand = 0x2a0 // ParticleSystemComponent* (Size: 0x8)
SGCharacterAnimationComponent.GesturePSC_RightHand = 0x2a8 // ParticleSystemComponent* (Size: 0x8)
SGCharacterAnimationComponent.FirstPersonAnimInstanceClass = 0x2c0 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.ThirdPersonAnimInstanceClass = 0x2c8 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.RagdollAnimInstanceClass = 0x2d0 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.FirstPersonAnimInstanceClass_Fallback = 0x2d8 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.ThirdPersonAnimInstanceClass_Fallback = 0x2e0 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.IsFPPDefaultIdleEmptyScreen = 0x2e8 // bool (Size: 0x1)
SGCharacterAnimationComponent.CustomizeMontageName = 0x2f0 // FString (Size: 0x10)
SGCharacterAnimationComponent.CustomizeMontageSectionName = 0x300 // FName (Size: 0x8)
SGCharacterAnimationComponent.FacialMontageName = 0x308 // FString (Size: 0x10)
SGCharacterAnimationComponent.FacialMontageSectionName = 0x318 // FName (Size: 0x8)
SGCharacterAnimationComponent.CharacterFacialAnimationSetsClass = 0x328 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.DeathAnimationSetClass = 0x330 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.DeathAnimationSetClass_RootMotion = 0x338 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.DeathAnimationSetClass1P = 0x340 // ClassProperty (Size: 0x8)
SGCharacterAnimationComponent.InventorySkeletalMeshComponent = 0x348 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterAnimationComponent.UsingInventoryInfo = 0x350 // FSGUsingInventoryRepAnimInfo (Size: 0x38)
SGCharacterAnimationComponent.CacheWeapon = 0x390 // SGWeapon* (Size: 0x8)
SGCharacterAnimationComponent.FPPAnimationEscaped = 0x398 // AnimMontage* (Size: 0x8)
SGCharacterAnimationComponent.EscapedUnEquipWeaponAnim_TimerHandle = 0x3a0 // FTimerHandle (Size: 0x8)
SGCharacterAnimationComponent.RepCustomizeAnimationInfo = 0x3b8 // FRepCustomizeAnimation (Size: 0x20)
SGCharacterAnimationComponent.MagazineFollowingBone = 0x3d8 // FName (Size: 0x8)
SGCharacterAnimationComponent.CheckMagazineAbilityTag = 0x3e0 // FGameplayTag (Size: 0x8)
SGCharacterAnimationComponent.ReloadMagazineAbilityTag = 0x3e8 // FGameplayTag (Size: 0x8)
SGCharacterAnimationComponent.PreJumpAnimTime = 0x3f0 // float (Size: 0x4)
SGCharacterAnimationComponent.JumpEndAnimTime = 0x3f4 // float (Size: 0x4)
SGCharacterAnimationComponent.JumpHighFallingTime = 0x3f8 // float (Size: 0x4)
SGCharacterAnimationComponent.StandToCrouchTime = 0x3fc // float (Size: 0x4)
SGCharacterAnimationComponent.CrouchToStandTime = 0x400 // float (Size: 0x4)
SGCharacterAnimationComponent.StandToProneTime = 0x404 // float (Size: 0x4)
SGCharacterAnimationComponent.ProneToStandTime = 0x408 // float (Size: 0x4)
SGCharacterAnimationComponent.CrouchToProneTime = 0x40c // float (Size: 0x4)
SGCharacterAnimationComponent.ProneToCrouchTime = 0x410 // float (Size: 0x4)
SGCharacterAnimationComponent.SpeedWarping_StandRunMinSpeed = 0x414 // float (Size: 0x4)
SGCharacterAnimationComponent.SpeedWarping_CrouchRunMinSpeed = 0x418 // float (Size: 0x4)
SGCharacterAnimationComponent.SpeedWarping_StandWalkBaseSpeed = 0x41c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandRunBaseSpeed = 0x43c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandSprintBaseSpeed = 0x45c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureWalkBaseSpeed = 0x47c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureRunBaseSpeed = 0x49c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureSprintBaseSpeed = 0x4bc // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureClearWalkBaseSpeed = 0x4dc // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureClearRunBaseSpeed = 0x4fc // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_StandFractureClearSprintBaseSpeed = 0x51c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchWalkBaseSpeed = 0x53c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchRunBaseSpeed = 0x55c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchFractureWalkBaseSpeed = 0x57c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchFractureRunBaseSpeed = 0x59c // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchFractureClearWalkBaseSpeed = 0x5bc // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.SpeedWarping_CrouchFractureClearRunBaseSpeed = 0x5dc // FCharacterSpeedWarpingBaseSpeed (Size: 0x20)
SGCharacterAnimationComponent.TemporallyUpdateAnimationDuration = 0x5fc // float (Size: 0x4)
SGCharacterAnimationComponent.bShouldTick1PRelax = 0x608 // bool (Size: 0x1)
SGCharacterAnimationComponent.RelaxType = 0x609 // EE1PRelaxType (Size: 0x1)
SGCharacterAnimationComponent.bEnable1PRelax = 0x60a // bool (Size: 0x1)
SGCharacterAnimationComponent.Shared1PRelaxTimeInterval = 0x60c // float (Size: 0x4)
SGCharacterAnimationComponent.Idle1PRelaxTimeRange = 0x610 // FVector2D (Size: 0x8)
SGCharacterAnimationComponent.Idle1PRelaxProbability = 0x618 // float (Size: 0x4)
SGCharacterAnimationComponent.WeaponSway1PRelaxAngleThreshold = 0x61c // float (Size: 0x4)
SGCharacterAnimationComponent.WeaponSway1PRelaxProbability = 0x620 // float (Size: 0x4)
SGCharacterAnimationComponent.CloseADS1PRelaxprobability = 0x624 // float (Size: 0x4)
SGCharacterAnimationComponent.HandTargetLoc = 0x628 // FVector (Size: 0xc)
SGCharacterAnimationComponent.AnimationSwitchValueMap = 0x638 // TMap<...> (Size: 0x50)
SGCharacterAnimationManagerComponent.AnimInstanceEvaluatorClasses = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGCharacterAnimationManagerComponent.DefaultAnimInstanceEvaluatorClass = 0x110 // ClassProperty (Size: 0x8)
SGCharacterAnimationManagerComponent.AnimInstanceEvaluators = 0x118 // TArray<AnimInstanceEvaluator*> (Size: 0x10)
SGCharacterAnimationManagerComponent.DefaultAnimInstanceEvaluator = 0x128 // AnimInstanceEvaluator* (Size: 0x8)
SGCharacterAnimationManagerComponent.CurrentEvaluator = 0x130 // AnimInstanceEvaluator* (Size: 0x8)
SGCharacterAnimationSets.Male = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
SGCharacterAnimationSets.Male_HD = 0x50 // TSoftClassPtr<UObject> (Size: 0x28)
SGCharacterAnimationSets.Female = 0x78 // TSoftClassPtr<UObject> (Size: 0x28)
SGCharacterAnimationSets.Female_HD = 0xa0 // TSoftClassPtr<UObject> (Size: 0x28)
SGCharacterAnimationSetsPerCharacterSex.UAMStandAnimations_1P = 0x28 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMStandAnimations_3P = 0x168 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMCrouchAnimations_1P = 0x2a8 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMCrouchAnimations_3P = 0x3e8 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMProneAnimations_1P = 0x528 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMProneAnimations_3P = 0x668 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMDBNOAnimations_1P = 0x7a8 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMDBNOAnimations_3P = 0x8e8 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMCasualAnimations_1P = 0xa28 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMCasualAnimations_3P = 0xb68 // FSGUAMLocomotionAnimationSet (Size: 0x140)
SGCharacterAnimationSetsPerCharacterSex.UAMJumpAnimations_1P = 0xca8 // FSGUAMJumpAnimationSet (Size: 0x90)
SGCharacterAnimationSetsPerCharacterSex.UAMJumpAnimations_3P = 0xd38 // FSGUAMJumpAnimationSet (Size: 0x90)
SGCharacterAnimationSetsPerCharacterSex.UAMDiveAnimations_1P = 0xdc8 // FSGUAMDiveAnimationSet (Size: 0x68)
SGCharacterAnimationSetsPerCharacterSex.UAMDiveAnimations_3P = 0xe30 // FSGUAMDiveAnimationSet (Size: 0x68)
SGCharacterAnimationSetsPerCharacterSex.UAMTransitionAnimations_1P = 0xe98 // FSGUAMTransitionAnimationSet (Size: 0xc0)
SGCharacterAnimationSetsPerCharacterSex.UAMTransitionAnimations_3P = 0xf58 // FSGUAMTransitionAnimationSet (Size: 0xc0)
SGCharacterAnimationSetsPerCharacterSex.UAMInteractionAnimations_1P = 0x1018 // FSGUAMInteractionAnimationSet (Size: 0x2f8)
SGCharacterAnimationSetsPerCharacterSex.UAMInteractionAnimations_3P = 0x1310 // FSGUAMInteractionAnimationSet (Size: 0x2f8)
SGCharacterAnimationSetsPerCharacterSex.TakeHitAnimationSet = 0x1608 // FSGUAMTakeHitAnimationSet (Size: 0x60)
SGCharacterAnimationSetsPerCharacterSex.UAMCustomAnimations = 0x1668 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.UAMDTAnimSequences = 0x16b8 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.UAM_DTMontages = 0x1708 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.UAM_DT_FacialMontages = 0x1758 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.UAM_CustomBS = 0x17a8 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.HeadwearAnimationSet = 0x17f8 // FSGHeadwearAnimationSet (Size: 0xa0)
SGCharacterAnimationSetsPerCharacterSex.VaultAnimationSet = 0x1898 // FSGVaultAnimationSet (Size: 0x20)
SGCharacterAnimationSetsPerCharacterSex.RelaxAnimationSet_1P = 0x18b8 // FSG1PRelaxAnimationSet (Size: 0x60)
SGCharacterAnimationSetsPerCharacterSex.IdleBreathAnimationSet = 0x1918 // FSGIdleBreathAnimationSet (Size: 0x10)
SGCharacterAnimationSetsPerCharacterSex.TacticalPistolAnimationSet = 0x1928 // FSGTacticalPistolAnimationSet (Size: 0x38)
SGCharacterAnimationSetsPerCharacterSex.InBattleCustomAnimations = 0x1960 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.InBattleCustomSequences = 0x19b0 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.PreviewAnimationSets = 0x1a00 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.JSAnimationSets = 0x1a50 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.PreviewRandomIdleAnimSets = 0x1aa0 // TMap<...> (Size: 0x50)
SGCharacterAnimationSetsPerCharacterSex.Tag = 0x1af0 // FName (Size: 0x8)
SGCharacterArmorAttributeSet.ErgonomicsFromArmor_Value = 0x48 // FGameplayAttributeData (Size: 0x10)
SGCharacterArmorAttributeSet.ImpactResistance = 0x58 // FGameplayAttributeData (Size: 0x10)
SGCharacterArmorManagerComponent.ArmorEvent = 0x108 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterArmorManagerComponent.PointsColorMap = 0x120 // TMap<...> (Size: 0x50)
SGCharacterArmorManagerComponent.PointsDrawDensity = 0x170 // float (Size: 0x4)
SGCharacterArmorManagerComponent.OutlineOffset = 0x174 // float (Size: 0x4)
SGCharacterArmorManagerComponent.DrawSocketSphereRadius = 0x178 // float (Size: 0x4)
SGCharacterArmorManagerComponent.bDrawSocketsInfo = 0x17c // bool (Size: 0x1)
SGCharacterArmorManagerComponent.bDrawColorSamples = 0x17d // bool (Size: 0x1)
SGCharacterArmorManagerComponent.DebugPanelClass = 0x180 // ClassProperty (Size: 0x8)
SGCharacterArmorManagerComponent.HeadSubgroupTextScale = 0x188 // float (Size: 0x4)
SGCharacterArmorManagerComponent.Config = 0x190 // SGConfigUtil* (Size: 0x8)
SGCharacterArmorManagerComponent.ConfigClass = 0x198 // ClassProperty (Size: 0x8)
SGCharacterArmorManagerComponent.HeadSubgroupDebugPanel = 0x1b0 // UserWidget* (Size: 0x8)
SGCharacterArmorManagerComponent.CachedArmorDamageCauserMap = 0x1c8 // TMap<...> (Size: 0x50)
SGCharacterArmorManagerComponent.LastArmorDamageMap = 0x218 // TMap<...> (Size: 0x50)
SGCharacterArmorManagerComponent.GasMaskDurabilityReduceInterval = 0x268 // float (Size: 0x4)
SGCharacterArmorManagerComponent.GasMaskDurabilityReduceValue = 0x26c // float (Size: 0x4)
SGCharacterArmorManagerComponent.ArmorList = 0x278 // TArray<SGInventory*> (Size: 0x10)
SGCharacterArmorManagerComponent.ProtectiveArmorList = 0x288 // TArray<SGInventory*> (Size: 0x10)
SGCharacterArmorManagerComponent.StaticHeadwearScreenEffectPtr = 0x2b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterArmorManagerComponent.MaterialHeadwearScreenEffectPtr = 0x2e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterArmorManagerComponent.ScreenEffectOwner = 0x308 // SGInventory* (Size: 0x8)
SGCharacterArmorManagerComponent.ArmorListStateCacheMapFor1P = 0x310 // TMap<...> (Size: 0x50)
SGCharacterArmorManagerComponent.bDebugArmor = 0x360 // bool (Size: 0x1)
SGCharacterArmorManagerComponent.HeadSubGroupInfos = 0x368 // TArray<FHeadSubGroupInfo> (Size: 0x10)
SGCharacterArmorManagerComponent.HitEarJudgeAngle = 0x378 // float (Size: 0x4)
SGCharacterAvatarComponent.SkinTypeParamCollection = 0x108 // MaterialParameterCollection* (Size: 0x8)
SGCharacterAvatarComponent.CachedPackBag = 0x110 // SGInventory* (Size: 0x8)
SGCharacterAvatarComponent.CachedVestBag = 0x118 // SGInventory* (Size: 0x8)
SGCharacterAvatarComponent.CachedEyeWear = 0x120 // SGInventory* (Size: 0x8)
SGCharacterAvatarComponent.CachedPocket = 0x128 // SGInventory* (Size: 0x8)
SGCharacterAvatarComponent.WearableInventoryList = 0x138 // TArray<Actor*> (Size: 0x10)
SGCharacterAvatarComponent.BodyMesh = 0x150 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGCharacterAvatarComponent.AvatarMergedMesh = 0x158 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGCharacterAvatarComponent.BagMeshInst = 0x160 // MeshComponent* (Size: 0x8)
SGCharacterAvatarComponent.BagWearableComponent = 0x168 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGCharacterAvatarComponent.bIsFPPMode = 0x170 // bool (Size: 0x1)
SGCharacterAvatarComponent.bCastingShadow = 0x171 // bool (Size: 0x1)
SGCharacterAvatarComponent.bAlwaysUseFPPMode = 0x172 // bool (Size: 0x1)
SGCharacterAvatarComponent.MeshLightChannels = 0x173 // FLightingChannels (Size: 0x1)
SGCharacterAvatarComponent.bForceCastShadow = 0x174 // bool (Size: 0x1)
SGCharacterAvatarComponent.bForceUse1PTexture = 0x175 // bool (Size: 0x1)
SGCharacterAvatarComponent.ArmorForceHiddenList = 0x178 // TArray<EESGArmorType> (Size: 0x10)
SGCharacterAvatarComponent.PendingWearableComponents = 0x198 // TArray<SGInventoryEquipMeshComponent*> (Size: 0x10)
SGCharacterAvatarComponent.DressedWearableComponents = 0x1a8 // TArray<SGInventoryEquipMeshComponent*> (Size: 0x10)
SGCharacterAvatarComponent.ShouldHiddenOnBackWeapons = 0x1b8 // TArray<EESGWeaponType> (Size: 0x10)
SGCharacterAvatarComponent.bEnableUse1PTextureBasedOnDistance = 0x1c8 // bool (Size: 0x1)
SGCharacterAvatarComponent.MpeSoftDepthTestMaterial = 0x1d0 // MaterialInterface* (Size: 0x8)
SGCharacterAvatarManagerComponent.AvatarList = 0x100 // SGInventory* (Size: 0x8)
SGCharacterAvatarManagerComponent.AvatarIDList = 0x180 // FSGAvatarRuntimeInstanced (Size: 0x28)
SGCharacterAvatarManagerComponent.AvatarLowPriorityIDAry = 0x400 // TArray<FSGAvatarRuntimeInstanced> (Size: 0x10)
SGCharacterAvatarManagerComponent.bUseLocalAvatarData = 0x412 // bool (Size: 0x1)
SGCharacterAvatarManagerComponent.bEnableAvatarFallback = 0x413 // bool (Size: 0x1)
SGCharacterAvatarManagerComponent.DefaultAvatarID = 0x418 // TArray<int64_t> (Size: 0x10)
SGCharacterAvatarManagerComponent.PmcAvatarID = 0x428 // TArray<int64_t> (Size: 0x10)
SGCharacterAvatarManagerComponent.ScavAvatarID = 0x438 // TArray<int64_t> (Size: 0x10)
SGCharacterAvatarManagerComponent.LocalCharacterSex = 0x448 // EECharacterSex (Size: 0x1)
SGCharacterAvatarManagerComponent.IgnoreDressInvTypeMap = 0x450 // TMap<...> (Size: 0x50)
SGCharacterAvatarManagerComponent.AvatarIDListCache = 0x4a0 // FSGAvatarRuntimeInstanced (Size: 0x28)
SGCharacterAvatarManagerComponent.CurrentAvatarDatas = 0x720 // TArray<FSGAvatarData> (Size: 0x10)
SGCharacterAvatarManagerComponent.CurrentServerAvatarDatas = 0x730 // TArray<FSGAvatarData> (Size: 0x10)
SGCharacterAvatarManagerComponent.CurrentAvatarDatasFromConsole = 0x740 // TArray<FSGAvatarData> (Size: 0x10)
SGCharacterAvatarManagerComponent.MaxPreloadAvatarNum = 0x750 // int32_t (Size: 0x4)
SGCharacterAvatarManagerComponent.PreloadAvatarCaches = 0x758 // TMap<...> (Size: 0x50)
SGCharacterAvatarManagerComponent.LoadingPreloadAvatarNum = 0x7a8 // int32_t (Size: 0x4)
SGCharacterAvatarManagerComponent.PreloadCharacterSex = 0x7ac // EECharacterSex (Size: 0x1)
SGCharacterAvatarManagerComponent.WaitPreloadAvatarCaches = 0x7b0 // TArray<int64_t> (Size: 0x10)
SGCharacterAvatarManagerComponent.ZoomClipParentMaterial = 0x7e0 // TMap<...> (Size: 0x50)
SGCharacterAvatarManagerComponent.bIsUsingDynamicZoomClipMaterials = 0x830 // bool (Size: 0x1)
SGCharacterAvatarManagerComponent.OriginMaterials = 0x838 // TArray<MaterialInterface*> (Size: 0x10)
SGCharacterAvatarManagerComponent.ZoomClipMaterials = 0x848 // TArray<MaterialInterface*> (Size: 0x10)
SGCharacterAvatarManagerComponent.ZoomParam = 0x858 // FScopeZoomParamOnMaterials (Size: 0x20)
SGCharacterAvatarManagerComponent.CachedGlovesSkeletalMeshComp = 0x878 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterAvatarManagerComponent.PreSpawnAvatarClasses = 0x898 // TArray<ClassProperty> (Size: 0x10)
SGCharacterAvatarManagerComponent.PreSpawnAvatarInstances = 0x8a8 // TMap<...> (Size: 0x50)
SGCharacterAvatarManagerComponent.PreSpawnAvatarID = 0x8f8 // TArray<int64_t> (Size: 0x10)
SGCharacterAvatarMergeComponent.MergedSkeletalMeshComponent = 0x108 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterAvatarMergeComponent.bCanEverMerge = 0x118 // bool (Size: 0x1)
SGCharacterAvatarMergeComponent.MeshSortNameList = 0x120 // TArray<FString> (Size: 0x10)
SGCharacterAvatarMergeComponent.NecessaryNameList = 0x130 // TArray<FString> (Size: 0x10)
SGCharacterAvatarMergeComponent.MergedMeshNameList = 0x140 // TArray<FString> (Size: 0x10)
SGCharacterAvatarMergeComponent.MergedSkeletalMeshParams = 0x150 // FSkeletalMeshMergeParams (Size: 0xa0)
SGCharacterAvatarMergeComponent.SkeletalMeshMerger = 0x1f0 // SGSkeletalMeshMerge* (Size: 0x8)
SGCharacterAvatarMergeComponent.PreMergedMeshAsset = 0x1f8 // SkeletalMesh* (Size: 0x8)
SGCharacterAvatarMergeComponent.MergedBMTexture = 0x208 // Texture2D* (Size: 0x8)
SGCharacterAvatarMergeComponent.MergedORNTexture = 0x210 // Texture2D* (Size: 0x8)
SGCharacterAvatarMergeComponent.MergedAMTexture = 0x218 // Texture2D* (Size: 0x8)
SGCharacterAvatarMergeComponent.MergedPatternTexture = 0x220 // Texture2D* (Size: 0x8)
SGCharacterAvatarMergeComponent.CommonParentMaterial = 0x238 // MaterialInterface* (Size: 0x8)
SGCharacterAvatarMergeComponent.SavedToMergeDiffuseTextureListName = 0x240 // TArray<FString> (Size: 0x10)
SGCharacterAvatarMergeComponent.BlockMergeMeshNameList = 0x250 // TArray<FString> (Size: 0x10)
SGCharacterAvatarMergeComponent.SavedMergeParams = 0x260 // FSkeletalMeshMergeParams (Size: 0xa0)
SGCharacterAvatarMergeComponent.ToMergeBMTextureList = 0x318 // TArray<Texture2D*> (Size: 0x10)
SGCharacterAvatarMergeComponent.ToMergeORNTextureList = 0x328 // TArray<Texture2D*> (Size: 0x10)
SGCharacterAvatarMergeComponent.ToMergeAMTextureList = 0x338 // TArray<Texture2D*> (Size: 0x10)
SGCharacterAvatarMergeComponent.ToMergePatternTextureList = 0x348 // TArray<Texture2D*> (Size: 0x10)
SGCharacterBaseTurnComponent.bTurnLeft = 0x100 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.bTurnRight = 0x101 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.bTurn180 = 0x102 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.bIsChangeActorRotation = 0x103 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.bTickTurnInPlaceAnimation = 0x10d // bool (Size: 0x1)
SGCharacterBaseTurnComponent.ShouldTurnRootBoneYaw = 0x10e // bool (Size: 0x1)
SGCharacterBaseTurnComponent.MinRootBoneRotationYawThreshold = 0x110 // float (Size: 0x4)
SGCharacterBaseTurnComponent.MaxRootBoneRotationYawThreshold = 0x114 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Stand = 0x118 // FSGTurnInPlaceAnimationConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Crouch = 0x148 // FSGTurnInPlaceAnimationConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Prone = 0x178 // FSGTurnInPlaceAnimationConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_DBNO = 0x1a8 // FSGTurnInPlaceAnimationConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Stand_Sequence = 0x1d8 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Crouch_Sequence = 0x208 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_Prone_Sequence = 0x238 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterBaseTurnComponent.TurnInPlaceAnimation_DBNO_Sequence = 0x268 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterBaseTurnComponent.bUseNewTrun = 0x298 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.bTickTurnInPlace = 0x299 // bool (Size: 0x1)
SGCharacterBaseTurnComponent.TurnYawLimit = 0x29c // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceMinThreshold = 0x2a0 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceMaxThreshold = 0x2a4 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceMinThreshold_181 = 0x2a8 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceMaxThreshold_181 = 0x2ac // float (Size: 0x4)
SGCharacterBaseTurnComponent.DBNOTurnInPlaceMinThreshold = 0x2b0 // float (Size: 0x4)
SGCharacterBaseTurnComponent.DBNOTurnInPlaceMaxThreshold = 0x2b4 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInPlaceInterpSpeed = 0x2b8 // float (Size: 0x4)
SGCharacterBaseTurnComponent.LimitTurnInPlaceInterpSpeed = 0x2bc // float (Size: 0x4)
SGCharacterBaseTurnComponent.StopTurnInPlaceThreshold = 0x2c0 // float (Size: 0x4)
SGCharacterBaseTurnComponent.TurnInAnimSequence = 0x2c8 // AnimSequence* (Size: 0x8)
SGCharacterBaseTurnComponent.RotationYawBlendOutSpeed = 0x2f0 // float (Size: 0x4)
SGCharacterBaseTurnComponent.ProneRotationYawBlendOutSpeed = 0x2f4 // float (Size: 0x4)
SGCharacterBaseTurnComponent.HandRollWithYawCurve = 0x2f8 // CurveFloat* (Size: 0x8)
SGCharacterBaseTurnComponent.CameraRollWithYawCurve = 0x300 // CurveFloat* (Size: 0x8)
SGCharacterBaseTurnComponent.SpineZOffsetWithYawCurve = 0x308 // CurveFloat* (Size: 0x8)
SGCharacterBaseTurnComponent.AnimInstance = 0x320 // SGCharacterAnimInstance* (Size: 0x8)
SGCharacterBaseTurnComponent.RepAnimMontageInfo = 0x330 // FRepTurnInPlaceAnimMontage (Size: 0x10)
SGCharacterBaseTurnComponent.LocalAnimMontageInfo = 0x340 // FRepTurnInPlaceAnimMontage (Size: 0x10)
SGCharacterBeUsedCorpseComponent.BeUsedHistory = 0x150 // TArray<Actor*> (Size: 0x10)
SGCharacterBeUsedCorpseComponent.bIsReadyForLoot = 0x160 // bool (Size: 0x1)
SGCharacterBeUsedCorpseComponent.UnLockInfo = 0x168 // FLootContainerUnLockInfo (Size: 0x30)
SGCharacterBeUsedCorpseComponent.ForbidInteractProtectTime = 0x198 // int32_t (Size: 0x4)
SGCharacterBeUsedCorpseComponent.After_ForbidInteractProtectTime = 0x19c // int32_t (Size: 0x4)
SGCharacterBeUsedCorpseComponent.bEnableLootProtect_Boss = 0x1a0 // bool (Size: 0x1)
SGCharacterBeUsedCorpseComponent.bEnableLootProtect_PMC = 0x1a1 // bool (Size: 0x1)
SGCharacterBoneBreakComponent.FallingSpeedThresholdToTriggerDamage = 0x100 // float (Size: 0x4)
SGCharacterBoneBreakComponent.DamageWhenJump = 0x104 // float (Size: 0x4)
SGCharacterBoneBreakComponent.DamageWhenSprint = 0x108 // float (Size: 0x4)
SGCharacterBoneBreakComponent.TakeDamageWhenSprintPeriod = 0x10c // float (Size: 0x4)
SGCharacterBurnEffectComponent.bShowBurnEffect = 0x100 // bool (Size: 0x1)
SGCharacterBurnEffectComponent.BurnEffectPS = 0x108 // ParticleSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPS1 = 0x110 // ParticleSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPS2 = 0x118 // ParticleSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPS3 = 0x120 // ParticleSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPS4 = 0x128 // ParticleSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.SocketName = 0x130 // FName (Size: 0x8)
SGCharacterBurnEffectComponent.SocketBodyName1 = 0x138 // FName (Size: 0x8)
SGCharacterBurnEffectComponent.SocketBodyName2 = 0x140 // FName (Size: 0x8)
SGCharacterBurnEffectComponent.SocketBodyName3 = 0x148 // FName (Size: 0x8)
SGCharacterBurnEffectComponent.SocketBodyName4 = 0x150 // FName (Size: 0x8)
SGCharacterBurnEffectComponent.BurnEffectPSC = 0x158 // ParticleSystemComponent* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPSC1 = 0x160 // ParticleSystemComponent* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPSC2 = 0x168 // ParticleSystemComponent* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPSC3 = 0x170 // ParticleSystemComponent* (Size: 0x8)
SGCharacterBurnEffectComponent.BodyBurnEffectPSC4 = 0x178 // ParticleSystemComponent* (Size: 0x8)
SGCharacterBurnEffectComponent.DamageInstigator = 0x180 // Controller* (Size: 0x8)
SGCharacterBurnEffectComponent.DamageCauser = 0x188 // Actor* (Size: 0x8)
SGCharacterBurnEffectComponent.DamageEvent = 0x190 // FDamageEvent (Size: 0x10)
SGCharacterBurnEffectComponent.EnvSys = 0x1b0 // MFEnvSystem* (Size: 0x8)
SGCharacterBurnEffectComponent.EffectFadeOutTime = 0x1c0 // float (Size: 0x4)
SGCharacterBurnEffectComponent.RepEffectFadeOutTime = 0x1c4 // float (Size: 0x4)
SGCharacterCaptureActor.DressedEquipMeshComponents = 0x318 // TArray<SGInventoryEquipMeshComponent*> (Size: 0x10)
SGCharacterCaptureActor.BodyEquipMeshComponent = 0x328 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGCharacterCaptureActor.BadgeAttachComponents = 0x330 // TMap<...> (Size: 0x50)
SGCharacterCaptureActor.bEnableCastShadow = 0x380 // bool (Size: 0x1)
SGCharacterCaptureActor.bEnableAvatarMerge = 0x381 // bool (Size: 0x1)
SGCharacterCaptureActor.bTurnOnMemoryOptimize = 0x382 // bool (Size: 0x1)
SGCharacterCaptureActor.SceneCaptureNode = 0x388 // SceneCaptureComponent2D* (Size: 0x8)
SGCharacterCaptureActor.CharacterMeshComponent = 0x390 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterCaptureActor.WeaponRootComponent = 0x398 // SceneComponent* (Size: 0x8)
SGCharacterCaptureActor.ActorRelativeLocation = 0x3a0 // FVector (Size: 0xc)
SGCharacterCaptureActor.OwnerCharacter = 0x3b0 // Character* (Size: 0x8)
SGCharacterCaptureActor.HandAnimation = 0x3b8 // AnimMontage* (Size: 0x8)
SGCharacterCaptureActor.CachedCurrentWeapon = 0x3e8 // SGInventory* (Size: 0x8)
SGCharacterCaptureActor.ToRemoveLastWeapon = 0x3f0 // SGInventory* (Size: 0x8)
SGCharacterCaptureActor.WeaponMeshComponetLookupMap = 0x408 // TMap<...> (Size: 0x50)
SGCharacterCaptureActor.SpecialWeaponMeshInfoArray = 0x458 // TArray<FCaptureActorSpecialMeshInfo> (Size: 0x10)
SGCharacterCaptureActor.LeftHandWeaponMeshComp = 0x468 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterCaptureActor.WeaponMeshLoadingList = 0x470 // TArray<SGInventory*> (Size: 0x10)
SGCharacterCaptureActor.WeaponMeshWaitToAttachMap = 0x480 // TMap<...> (Size: 0x50)
SGCharacterCaptureActor.CachedAdapterToDetach = 0x4d0 // SGInventory* (Size: 0x8)
SGCharacterCaptureActor.CachedAdapterToAttach = 0x4d8 // SGInventory* (Size: 0x8)
SGCharacterCaptureActor.WeaponExtraMeshComponentLookupMap = 0x4e0 // TMap<...> (Size: 0x50)
SGCharacterCaptureActor.OriginalRotation = 0x530 // FRotator (Size: 0xc)
SGCharacterCaptureActor.WeaponAttachInvMeshComponents = 0x558 // TArray<MeshComponent*> (Size: 0x10)
SGCharacterCaptureActor.WeaponAttachSexTypes = 0x568 // TArray<EECharacterSex> (Size: 0x10)
SGCharacterCaptureActor.MergedSkeletalMeshComponent = 0x578 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterCaptureActor.MeshMergeParams = 0x580 // FSkeletalMeshMergeParams (Size: 0xa0)
SGCharacterCaptureAnimInstance.LocalProxy = 0x2c0 // FSGCharacterCaptureAnimInstanceProxy (Size: 0x930)
SGCharacterCaptureAnimInstance.AnimDebugLogContainer = 0xbf0 // FSGAnimationDebugLogContainer (Size: 0x10)
SGCharacterCaptureAnimInstanceProxy.HandWeaponOffset_LeftHand = 0x860 // FVector (Size: 0xc)
SGCharacterCaptureAnimInstanceProxy.CaptureCharacterWeaponTranslation = 0x86c // FVector (Size: 0xc)
SGCharacterCaptureAnimInstanceProxy.CaptureCharacterWeaponRotation = 0x878 // FRotator (Size: 0xc)
SGCharacterCaptureAnimInstanceProxy.EnableCaptureCharacterWeaponOffset = 0x884 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.bIsEmptyHand = 0x888 // bool (Size: 0x1)
SGCharacterCaptureAnimInstanceProxy.bHasCasualSeq = 0x889 // bool (Size: 0x1)
SGCharacterCaptureAnimInstanceProxy.bHasReargrip = 0x88a // bool (Size: 0x1)
SGCharacterCaptureAnimInstanceProxy.bHasBaseIdleSeq = 0x88b // bool (Size: 0x1)
SGCharacterCaptureAnimInstanceProxy.bIsCharacterAnimationSetsChange = 0x88c // bool (Size: 0x1)
SGCharacterCaptureAnimInstanceProxy.GripPoseAdjustmentAlpha = 0x890 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.CasualGripBSAplha = 0x894 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.RearGripTypeAlpha = 0x898 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.ForegripTypeAlpha = 0x89c // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Disable_LeftHandGripPose = 0x8a0 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Disable_LeftHandIK = 0x8a4 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_AdaptiveWeaponHandGripPose = 0x8a8 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_BothHandMeleeWeaponCasualGrip = 0x8ac // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.ForeGripOffset = 0x8b0 // FVector (Size: 0xc)
SGCharacterCaptureAnimInstanceProxy.Enable_LeftHandGripOffset = 0x8bc // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_BlendLeftHandGrip = 0x8c0 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_RightHandBlend = 0x8c4 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_RightHandIKBlend = 0x8c8 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_GripPoseAdjust = 0x8cc // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_LeftHandIK = 0x8d0 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_RightHandIK = 0x8d4 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.Enable_HandIK = 0x8d8 // float (Size: 0x4)
SGCharacterCaptureAnimInstanceProxy.RearGripCasualBS = 0x8e0 // BlendSpace1D* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.CasualGripBS = 0x8e8 // BlendSpace1D* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.CasualGripAdjustmentBS = 0x8f0 // BlendSpace1D* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.CasualIdleSeq = 0x8f8 // AnimSequence* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.BaseIdleSeq = 0x900 // AnimSequence* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.SGAnimInstance = 0x908 // SGCharacterCaptureAnimInstance* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.OwnerCharacter = 0x910 // Character* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.SGCaptureCharacter = 0x918 // SGCharacterCaptureActor* (Size: 0x8)
SGCharacterCaptureAnimInstanceProxy.CachedCharacterAnimationSets = 0x920 // SGCharacterAnimationSetsPerCharacterSex* (Size: 0x8)
SGCharacterCastShadowComponent.bCanEverEnable = 0x10f0 // bool (Size: 0x1)
SGCharacterCastShadowComponent.bEnableFor1P = 0x10f1 // bool (Size: 0x1)
SGCharacterCastShadowComponent.bUseLocomotionShadowFor1p = 0x10f2 // bool (Size: 0x1)
SGCharacterCastShadowComponent.ProxySkeletalMesh = 0x10f8 // SkeletalMesh* (Size: 0x8)
SGCharacterCastShadowComponent.ForceLOD = 0x1100 // int32_t (Size: 0x4)
SGCharacterCastShadowComponent.AnimInstanceClass = 0x1108 // ClassProperty (Size: 0x8)
SGCharacterCastShadowComponent.AnimInstanceClassForTest = 0x1110 // ClassProperty (Size: 0x8)
SGCharacterCastShadowComponent.TickOptLevel = 0x1128 // uint8_t (Size: 0x1)
SGCharacterCastShadowComponent.TickIntervalOpt = 0x112c // float (Size: 0x4)
SGCharacterCastShadowComponent.DuplicateDressedMeshMap = 0x1130 // TMap<...> (Size: 0x50)
SGCharacterComponentsSignificanceParams.ComponentName = 0x0 // FName (Size: 0x8)
SGCharacterComponentsSignificanceParams.bMultiThreading = 0x8 // bool (Size: 0x1)
SGCharacterComponentsSignificanceParams.bIgnoreLimitExceed = 0x9 // bool (Size: 0x1)
SGCharacterComponentsSignificanceParams.SignificanceBias = 0xc // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.MinTickInterval_3P = 0x10 // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.MinTickInterval_1P = 0x14 // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.CompSubSigLimitUpdateThreshold = 0x18 // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.CompSubSigLimitUpdateScale = 0x1c // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity = 0x20 // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_NoRender_LongDist = 0x24 // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_NoRender_LongDist_Significance = 0x28 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_NoRender_ShortDist_Significance = 0x2c // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_Render_HighURO = 0x30 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_Render_HighURO_Significance = 0x34 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.HighVelocity_Render_LowURO_Significance = 0x38 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_NoRender_LongDist = 0x3c // float (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_NoRender_LongDist_Significance = 0x40 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_NoRender_ShortDist_Significance = 0x44 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_Render_HighURO = 0x48 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_Render_HighURO_Significance = 0x4c // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceParams.LowVelocity_Render_LowURO_Significance = 0x50 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceThresolds.ComponentClass = 0x8 // ClassProperty (Size: 0x8)
SGCharacterComponentsSignificanceThresolds.DeviceQuality = 0x10 // int32_t (Size: 0x4)
SGCharacterComponentsSignificanceThresolds.SignificanceParams = 0x14 // FSGCharacterComponentsSignificanceParams (Size: 0x54)
SGCharacterContainerInventoryComponent.CorpseContainerClass = 0x190 // ClassProperty (Size: 0x8)
SGCharacterCurveBreathComponent.bEnableBreath = 0x108 // bool (Size: 0x1)
SGCharacterCurveBreathComponent.bEnableNoise = 0x109 // bool (Size: 0x1)
SGCharacterCurveBreathComponent.bSmoothBreath = 0x10a // bool (Size: 0x1)
SGCharacterCurveBreathComponent.SideSwayScale_LocationX = 0x10c // float (Size: 0x4)
SGCharacterCurveBreathComponent.SideSwayScale_RotationX = 0x110 // float (Size: 0x4)
SGCharacterCurveBreathComponent.SideSwayScale_LocationX_ADS = 0x114 // float (Size: 0x4)
SGCharacterCurveBreathComponent.SideSwayScale_RotationX_ADS = 0x118 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CameraRotationScale = 0x11c // float (Size: 0x4)
SGCharacterCurveBreathComponent.LocationCurve_Additive_Walk = 0x120 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Additive_Walk = 0x128 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Additive_Walk = 0x130 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Additive_Walk = 0x138 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Additive_Run = 0x140 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Additive_Run = 0x148 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Additive_Run = 0x150 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Additive_Run = 0x158 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Idle = 0x160 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Idle = 0x168 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Idle = 0x170 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Idle = 0x178 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Idle_ADS = 0x180 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Idle_ADS = 0x188 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Idle_ADS = 0x190 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Idle_ADS = 0x198 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Move = 0x1a0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Move = 0x1a8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.Rotation_ADS_Move_ScaleByFOV = 0x1b0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Move = 0x1b8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Move = 0x1c0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Move_ADS = 0x1c8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Move_ADS = 0x1d0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Move_ADS = 0x1d8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Move_ADS = 0x1e0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_SilentWalk = 0x1e8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_SilentWalk = 0x1f0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_SilentWalk = 0x1f8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_SilentWalk = 0x200 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_SilentWalk_ADS = 0x208 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_SilentWalk_ADS = 0x210 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_SilentWalk_ADS = 0x218 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_SilentWalk_ADS = 0x220 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_Fire_ADS = 0x228 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_Fire_ADS = 0x230 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_Fire_ADS = 0x238 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_Fire_ADS = 0x240 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_BreakLeg_Move = 0x248 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_BreakLeg_Move = 0x250 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_BreakLeg_Move = 0x258 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_BreakLeg_Move = 0x260 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.LocationCurve_BreakLeg_Move_ADS = 0x268 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.RotationCurve_BreakLeg_Move_ADS = 0x270 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.FrequencyCurve_BreakLeg_Move_ADS = 0x278 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AmplitudeCurve_BreakLeg_Move_ADS = 0x280 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_Idle = 0x288 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_Idle = 0x290 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Idle = 0x298 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_Idle_ADS = 0x2a0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_Idle_ADS = 0x2a8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Idle_ADS = 0x2b0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_BreakArm = 0x2b8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_BreakArm = 0x2c0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_BreakArm = 0x2c8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_BreakArm_ADS = 0x2d0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_BreakArm_ADS = 0x2d8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_BreakArm_ADS = 0x2e0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_Exhausted = 0x2e8 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_Exhausted = 0x2f0 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Exhausted = 0x2f8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_Exhausted_ADS = 0x300 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_Exhausted_ADS = 0x308 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Exhausted_ADS = 0x310 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Exhausted_ADS_Location = 0x318 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveAmplitudeCurve_Exhausted_ADS_Rotation = 0x320 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveLocationCurve_Hypoxia = 0x328 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.AdditiveRotationCurve_Hypoxia = 0x330 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.CurrentLocationCurve = 0x338 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.CurrentRotationCurve = 0x340 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.CurrentFrequencyCurve = 0x348 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.CurrentAmplitudeCurve = 0x350 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.ExtraLocationCurve = 0x358 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.ExtraRotationCurve = 0x360 // CurveVector* (Size: 0x8)
SGCharacterCurveBreathComponent.ExtraAmplitudeCurve = 0x368 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.InterpSpeed = 0x370 // float (Size: 0x4)
SGCharacterCurveBreathComponent.MaxVelocityToNormalize = 0x374 // float (Size: 0x4)
SGCharacterCurveBreathComponent.WeaponTypeBaseZero_Common = 0x378 // float (Size: 0x4)
SGCharacterCurveBreathComponent.WeaponTypeBaseZero_Throwable = 0x37c // float (Size: 0x4)
SGCharacterCurveBreathComponent.WeaponTypeBaseZero_EmptyHand = 0x380 // float (Size: 0x4)
SGCharacterCurveBreathComponent.NoiseScale = 0x384 // float (Size: 0x4)
SGCharacterCurveBreathComponent.FixedUpdateTime = 0x388 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CameraAnimatedRotationFadeOutInterpSpeed = 0x38c // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurrentSpeedNormalized = 0x390 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurveUpdateStepScale = 0x394 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurveAmplitudeScale = 0x398 // float (Size: 0x4)
SGCharacterCurveBreathComponent.ExtraAmplitudeScale = 0x39c // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurveTime_NonAdditive = 0x3a0 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurveTime_Additive = 0x3a4 // float (Size: 0x4)
SGCharacterCurveBreathComponent.ExhaustedAmplitudeTime_Additive = 0x3a8 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CurrentLocationValue = 0x3b0 // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.CurrentRotationValue = 0x3bc // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.ExtraLocationValue = 0x3c8 // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.ExtraRotationValue = 0x3d4 // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.SmoothedLocationValue = 0x3e0 // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.SmoothedRotationValue = 0x3ec // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.bEnableAnimationDriven_CameraAnimated = 0x3f8 // bool (Size: 0x1)
SGCharacterCurveBreathComponent.CameraAnimatedScaler_Small = 0x3fc // float (Size: 0x4)
SGCharacterCurveBreathComponent.CameraAnimatedScaler_Medium = 0x400 // float (Size: 0x4)
SGCharacterCurveBreathComponent.CameraAnimatedScaler_Large = 0x404 // float (Size: 0x4)
SGCharacterCurveBreathComponent.BaseCameraAnimatedRotation = 0x410 // FRotator (Size: 0xc)
SGCharacterCurveBreathComponent.CameraAnimatedRotationOffset = 0x41c // FRotator (Size: 0xc)
SGCharacterCurveBreathComponent.CameraAnimatedTranslationOffset = 0x428 // FVector (Size: 0xc)
SGCharacterCurveBreathComponent.BreathZoffsetScaler_SilentWalk = 0x434 // float (Size: 0x4)
SGCharacterCurveBreathComponent.BreathZoffsetScaler_SilentWalk_ADS = 0x438 // float (Size: 0x4)
SGCharacterCurveBreathComponent.IdleBreathAnimBlendSpeed = 0x43c // float (Size: 0x4)
SGCharacterCurveBreathComponent.LocationCurveMaxTimes = 0x448 // TMap<...> (Size: 0x50)
SGCharacterCurveBreathComponent.bServerExhausted = 0x4b6 // bool (Size: 0x1)
SGCharacterCurveBreathComponent.BreathY = 0x4e0 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.BreathZ = 0x4ec // FSinRandom (Size: 0x10)
SGCharacterCurveBreathComponent.WaggleY = 0x4fc // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.WaggleZ = 0x508 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.RecoilNoiseY = 0x514 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.RecoilNoiseZ = 0x520 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.RecoilFrequencyScaleGainOnFire = 0x52c // float (Size: 0x4)
SGCharacterCurveBreathComponent.RecoilFrequencyBlendSpeed = 0x530 // float (Size: 0x4)
SGCharacterCurveBreathComponent.HypoxiaFrequencyScale = 0x558 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterCurveBreathComponent.TrembleNoiseX = 0x5e4 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.TrembleNoiseY = 0x5f0 // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.TrembleNoiseZ = 0x5fc // FValueNoise (Size: 0xc)
SGCharacterCurveBreathComponent.FractureSpasmIntervalRange = 0x608 // FVector2D (Size: 0x8)
SGCharacterCurveBreathComponent.FractureSpasmIntensityRange = 0x610 // FVector2D (Size: 0x8)
SGCharacterCurveBreathComponent.FractureSpasmScale = 0x618 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterCurveBreathComponent.FractureSpasmIntensity = 0x6a4 // float (Size: 0x4)
SGCharacterCurveBreathComponent.FractureSpasmStartTime = 0x6a8 // float (Size: 0x4)
SGCharacterCurveBreathComponent.AdsSteadyScale = 0x6ac // float (Size: 0x4)
SGCharacterCurveBreathComponent.AdsSteadyTrembleScale = 0x6b0 // float (Size: 0x4)
SGCharacterCurveBreathComponent.AdsSteadyDuration = 0x6b4 // float (Size: 0x4)
SGCharacterCurveBreathComponent.AdsSteadyCurve = 0x6c0 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.WeaponStabilityToAdsSteadyDurationScaleCurve = 0x6c8 // CurveFloat* (Size: 0x8)
SGCharacterCurveBreathComponent.ServerBreathNoiseTimeDelta = 0x700 // float (Size: 0x4)
SGCharacterCurveBreathComponent.ServerTrembleNoiseTimeDelta = 0x708 // float (Size: 0x4)
SGCharacterCurveBreathComponent.ServerRecoilNoiseTimeDelta = 0x710 // float (Size: 0x4)
SGCharacterCustomCameraComponent.CameraMeshComponent = 0x128 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterCustomCameraComponent.UAPreviewMesh = 0x130 // SkeletalMesh* (Size: 0x8)
SGCharacterCustomCameraComponent.CameraMeshAnimInstance = 0x138 // ClassProperty (Size: 0x8)
SGCharacterCustomCameraComponent.LerpCharacter = 0x150 // Character* (Size: 0x8)
SGCharacterCustomDepthStencilComponent.CharacterMeshArray = 0x100 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGCharacterDBNOComponent.EnableRescueSelfDelayTime = 0x118 // float (Size: 0x4)
SGCharacterDBNOComponent.RescueSelfStopDamageDelayTime = 0x11c // float (Size: 0x4)
SGCharacterDBNOComponent.bDebugDBNO = 0x120 // bool (Size: 0x1)
SGCharacterDBNOComponent.HitArmorEnterDBNO = 0x128 // Actor* (Size: 0x8)
SGCharacterDBNOComponent.bDebugDBNONoCheck = 0x130 // bool (Size: 0x1)
SGCharacterDBNOComponent.bCanRescueSelfInDBNO = 0x131 // bool (Size: 0x1)
SGCharacterDBNOComponent.ShowFullProgressThreshold = 0x134 // float (Size: 0x4)
SGCharacterDBNOComponent.AbortShowProgressThreshold = 0x138 // float (Size: 0x4)
SGCharacterDBNOComponent.DBNOInfoList = 0x140 // TArray<FSGCharacterDBNOInfo> (Size: 0x10)
SGCharacterDBNOComponent.BroaderDBNOSubModeList = 0x150 // TArray<int32_t> (Size: 0x10)
SGCharacterDBNOComponent.NoDBNODamageTypeList = 0x160 // TArray<EEDamageTypeEnum> (Size: 0x10)
SGCharacterDBNOComponent.bLeftArmOutOfEnduranceAfterRescued = 0x170 // bool (Size: 0x1)
SGCharacterDBNOComponent.bRightArmOutOfEnduranceAfterRescued = 0x171 // bool (Size: 0x1)
SGCharacterDBNOComponent.bLeftLegOutOfEnduranceAfterRescued = 0x172 // bool (Size: 0x1)
SGCharacterDBNOComponent.bRightLegOutOfEnduranceAfterRescued = 0x173 // bool (Size: 0x1)
SGCharacterDBNOComponent.MinHeadEnduranceRescued = 0x174 // float (Size: 0x4)
SGCharacterDBNOComponent.MinChestEnduranceRescued = 0x178 // float (Size: 0x4)
SGCharacterDBNOComponent.MinOthersEnduranceRescued = 0x17c // float (Size: 0x4)
SGCharacterDBNOComponent.FoodDeductionWhenRescued = 0x188 // float (Size: 0x4)
SGCharacterDBNOComponent.MoistureDeductionWhenRescued = 0x18c // float (Size: 0x4)
SGCharacterDBNOComponent.LeftArmTakeDamageScale = 0x190 // float (Size: 0x4)
SGCharacterDBNOComponent.RightArmTakeDamageScale = 0x194 // float (Size: 0x4)
SGCharacterDBNOComponent.LeftLegTakeDamageScale = 0x198 // float (Size: 0x4)
SGCharacterDBNOComponent.RightLegTakeDamageScale = 0x19c // float (Size: 0x4)
SGCharacterDBNOComponent.HeadTakeDamageScale = 0x1a0 // float (Size: 0x4)
SGCharacterDBNOComponent.ChestTakeDamageScale = 0x1a4 // float (Size: 0x4)
SGCharacterDBNOComponent.StomachTakeDamageScale = 0x1a8 // float (Size: 0x4)
SGCharacterDBNOComponent.GodTimeWhenEnterDBNO = 0x1ac // float (Size: 0x4)
SGCharacterDBNOComponent.GodTimeWhenLeaveDBNO = 0x1b0 // float (Size: 0x4)
SGCharacterDBNOComponent.DBNOStopMontageBlendOutTime = 0x1b4 // float (Size: 0x4)
SGCharacterDBNOComponent.DBNOStatusAbilityClass = 0x1b8 // ClassProperty (Size: 0x8)
SGCharacterDBNOComponent.DBNODamageAbilityClass = 0x1c8 // ClassProperty (Size: 0x8)
SGCharacterDBNOComponent.DBNOBuffClearAbilityClass = 0x1d0 // ClassProperty (Size: 0x8)
SGCharacterDBNOComponent.bIsDBNO = 0x1e8 // bool (Size: 0x1)
SGCharacterDBNOComponent.bIsWantToDBNO = 0x1e9 // bool (Size: 0x1)
SGCharacterDBNOComponent.bDisableDBNO = 0x1ea // bool (Size: 0x1)
SGCharacterDBNOComponent.ShowWeaponDelayTime = 0x1f4 // float (Size: 0x4)
SGCharacterDBNOComponent.DBNODamageCauser = 0x200 // Actor* (Size: 0x8)
SGCharacterDBNOComponent.DBNOInstigator = 0x228 // Controller* (Size: 0x8)
SGCharacterDBNOComponent.EnterDBNOCauserProjectile = 0x230 // Actor* (Size: 0x8)
SGCharacterDBNOInfo.InitialDBNOHealth = 0x0 // float (Size: 0x4)
SGCharacterDamageDebugComponent.TextRenderComp = 0x100 // TextRenderComponent* (Size: 0x8)
SGCharacterDamageDebugComponent.TakeDamageInformation = 0x110 // FString (Size: 0x10)
SGCharacterDamageDebugComponent.DebugBodyInfos = 0x120 // FDebugPhysicsBodyInfos (Size: 0x40)
SGCharacterDeathAnimationSets.DeathAnimationSet = 0x28 // FSGUAMDeathAnimationSet (Size: 0x340)
SGCharacterDeathComponent.CachedKillerCharacter = 0x130 // Character* (Size: 0x8)
SGCharacterDeathComponent.bIsUsingLookAtKillerCamera = 0x138 // bool (Size: 0x1)
SGCharacterDeathComponent.AdjustBoxExtend = 0x148 // FVector (Size: 0xc)
SGCharacterDeathComponent.ReturnToLobbyTime = 0x154 // float (Size: 0x4)
SGCharacterDeathComponent.bKeepCorpse = 0x158 // bool (Size: 0x1)
SGCharacterDeathComponent.bAllowRoot = 0x159 // bool (Size: 0x1)
SGCharacterDeathComponent.DeathCountInterval = 0x15c // float (Size: 0x4)
SGCharacterDeathComponent.DogTagClassMap = 0x160 // TMap<...> (Size: 0x50)
SGCharacterDeathComponent.DogTagType = 0x1b0 // int32_t (Size: 0x4)
SGCharacterDeathComponent.bDogTagEnable = 0x1b4 // bool (Size: 0x1)
SGCharacterDeathComponent.CorpseDestroyTime = 0x1b8 // float (Size: 0x4)
SGCharacterDeathComponent.DelaySpawnDeathBoxTime = 0x1bc // float (Size: 0x4)
SGCharacterDeathComponent.DeathBoxClass = 0x1c0 // ClassProperty (Size: 0x8)
SGCharacterDeathComponent.OverrideDeathBoxClass = 0x1c8 // TMap<...> (Size: 0x50)
SGCharacterDeathComponent.IgnoreDeathEffectHiddenTime = 0x218 // float (Size: 0x4)
SGCharacterDeathComponent.DeathEffect = 0x220 // ParticleSystem* (Size: 0x8)
SGCharacterDeathComponent.DistanceNoDeathEffectIfNonRendered = 0x228 // float (Size: 0x4)
SGCharacterDeathComponent.FPAnimationPlayRate = 0x22c // float (Size: 0x4)
SGCharacterDeathComponent.TPAnimationPlayRate = 0x230 // float (Size: 0x4)
SGCharacterDeathComponent.DeathAnimationBlendIn = 0x234 // float (Size: 0x4)
SGCharacterDeathComponent.AssistKillStatisTime = 0x238 // float (Size: 0x4)
SGCharacterDeathComponent.DeathInfo = 0x240 // FCharacterDeathInfo (Size: 0x50)
SGCharacterDeathComponent.OldDeathInfo = 0x290 // FCharacterDeathInfo (Size: 0x50)
SGCharacterDeathComponent.CachedDeathBox = 0x2e0 // SGInventory* (Size: 0x8)
SGCharacterDeathComponent.CachedDeadNationalFlagIso = 0x2e8 // int32_t (Size: 0x4)
SGCharacterDeathComponent.DeathCountTimerHandle = 0x2f0 // FTimerHandle (Size: 0x8)
SGCharacterDeathComponent.DelayPlayDeathEffectTimerHandle = 0x2f8 // FTimerHandle (Size: 0x8)
SGCharacterDeathComponent.DisableCompReplicationHandle = 0x300 // FTimerHandle (Size: 0x8)
SGCharacterDeathComponent.CachedVictimPlayerController = 0x308 // Controller* (Size: 0x8)
SGCharacterDeathComponent.CachedDeathAnimation = 0x310 // AnimMontage* (Size: 0x8)
SGCharacterDeathComponent.bShouldSpawnDogtag = 0x318 // bool (Size: 0x1)
SGCharacterDeathComponent.MeshInterpDuration = 0x350 // float (Size: 0x4)
SGCharacterDeathComponent.AgainstorData = 0x358 // FKillerStaticData (Size: 0x198)
SGCharacterDeathComponent.DBNOKillerData = 0x4f0 // FKillerStaticData (Size: 0x198)
SGCharacterDeathComponent.FinalKilledData = 0x688 // FKilledStaticData (Size: 0x88)
SGCharacterDeathComponent.DBNOKilledData = 0x710 // FKilledStaticData (Size: 0x88)
SGCharacterDeathComponent.SuicideWithoutCauserDeathTypes = 0x798 // TArray<EECharacterDeathType> (Size: 0x10)
SGCharacterDeathComponent.ResetReplay1PSeconds = 0x7a8 // float (Size: 0x4)
SGCharacterDeathComponent.CachedPlayerStateBeforeDied = 0x87c // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterDeathComponent.CachedDeadCharacterInfo = 0x888 // FCachedDeadCharacterInfo (Size: 0x90)
SGCharacterDeathComponent.DogTagInv = 0x928 // SGInventory* (Size: 0x8)
SGCharacterDeathComponent.DelayForClosingEyesAfterDeath = 0x938 // float (Size: 0x4)
SGCharacterDeathComponent.CloseEyesDuration = 0x93c // float (Size: 0x4)
SGCharacterDeathComponent.DelayForStartDeathTDMCamera = 0x940 // float (Size: 0x4)
SGCharacterDebugMovementComponent.SpeedUpScale = 0x100 // float (Size: 0x4)
SGCharacterDebugMovementComponent.DebugMovementData_Server = 0x104 // FSGCharacterDebugMovementInfo (Size: 0x5c)
SGCharacterDebugMovementComponent.DebugSpeedUpAbilityClass = 0x1c0 // ClassProperty (Size: 0x8)
SGCharacterDebugMovementComponent.MontageTickCondition_Server = 0x1d0 // FMontageTickCondition (Size: 0x28)
SGCharacterDebugMovementComponent.CharacterAbilityInfo_Server = 0x220 // FCharacterAbilityDebugInfo (Size: 0x50)
SGCharacterDebugMovementComponent.ServerMoveResultQueue = 0x2d0 // TArray<FSGServerMoveResult> (Size: 0x10)
SGCharacterDebugMovementComponent.ClientMoveInfoQueue = 0x2e0 // TArray<FSGClientMoveInfo> (Size: 0x10)
SGCharacterDebugMovementComponent.ServerMoveResultQueueSize = 0x2f0 // int32_t (Size: 0x4)
SGCharacterDebugMovementComponent.ClientMoveInfoQueueSize = 0x2f4 // int32_t (Size: 0x4)
SGCharacterDebugMovementComponent.bDebugLocation = 0x2f8 // bool (Size: 0x1)
SGCharacterDebugMovementInfo.MaxSpeed = 0x0 // float (Size: 0x4)
SGCharacterDebugMovementInfo.Velocity = 0x4 // FVector (Size: 0xc)
SGCharacterDebugMovementInfo.Acceleration = 0x10 // FVector (Size: 0xc)
SGCharacterDebugMovementInfo.CharacterLocation = 0x1c // FVector (Size: 0xc)
SGCharacterDebugMovementInfo.CharacterRotation = 0x28 // FRotator (Size: 0xc)
SGCharacterDebugMovementInfo.TotalWeaponMovementSpeedScale = 0x34 // float (Size: 0x4)
SGCharacterDebugMovementInfo.ShootingSpeedScale = 0x38 // float (Size: 0x4)
SGCharacterDebugMovementInfo.ReloadMovingScale = 0x3c // float (Size: 0x4)
SGCharacterDebugMovementInfo.ADSZoomMovingScale = 0x40 // float (Size: 0x4)
SGCharacterDebugMovementInfo.MovementAbilitySpeedScale = 0x44 // float (Size: 0x4)
SGCharacterDebugMovementInfo.OverweightMovingScale = 0x48 // float (Size: 0x4)
SGCharacterDebugMovementInfo.EquipmentMovingScale = 0x4c // float (Size: 0x4)
SGCharacterDebugMovementInfo.JumpXYVelocityScale = 0x50 // float (Size: 0x4)
SGCharacterDebugMovementInfo.JumpZVelocityScale = 0x54 // float (Size: 0x4)
SGCharacterDebugMovementInfo.IsSprinting = 0x58 // bool (Size: 0x1)
SGCharacterDebugMovementInfo.SprintFailureReason = 0x59 // EECharacterSprintFailureReason (Size: 0x1)
SGCharacterDefaultInventoryComponent.DelayTimeToGiveInventory = 0x100 // float (Size: 0x4)
SGCharacterDefaultInventoryComponent.CacheEquipInventoriesTotalValue = 0x104 // float (Size: 0x4)
SGCharacterDefaultInventoryComponent.IsNeedDelayBeginPlay = 0x108 // bool (Size: 0x1)
SGCharacterDefaultInventoryComponent.TimerHandle = 0x110 // FTimerHandle (Size: 0x8)
SGCharacterDefaultInventoryComponent.DefaultPickupInventoriesSoft = 0x118 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGCharacterDefaultInventoryComponent.DefaultPickupToBagInventoriesSoft = 0x128 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGCharacterDeliverCargoComponent.OwnerChar = 0xf8 // SGCharacter* (Size: 0x8)
SGCharacterDeliverCargoComponent.DeliverCargosRelevantAnimInfoArr = 0x100 // TArray<FDeliverCargosRelevantAnimInfo> (Size: 0x10)
SGCharacterDeliverCargoComponent.bBagVisible = 0x110 // bool (Size: 0x1)
SGCharacterDialogAnimation.FullBodyAnim = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterDialogAnimation.FacialAnim = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterDialogAnimation.AvatarAnimationSet = 0x50 // TMap<...> (Size: 0x50)
SGCharacterEnduranceAttributeSet.HeadEndurance = 0x48 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.HeadEnduranceMax = 0x4c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.ChestEndurance = 0x50 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.ChestEnduranceMax = 0x54 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.StomachEndurance = 0x58 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.StomachEnduranceMax = 0x5c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftArmEndurance = 0x60 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftArmEnduranceMax = 0x64 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightArmEndurance = 0x68 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightArmEnduranceMax = 0x6c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftLegEndurance = 0x70 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftLegEnduranceMax = 0x74 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightLegEndurance = 0x78 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightLegEnduranceMax = 0x7c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.HeadReduceHealingRatio = 0x80 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.ChestReduceHealingRatio = 0x84 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.StomachReduceHealingRatio = 0x88 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftArmReduceHealingRatio = 0x8c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightArmReduceHealingRatio = 0x90 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftLegReduceHealingRatio = 0x94 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightLegReduceHealingRatio = 0x98 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.HeadSpreadDamageScaleRatio = 0x9c // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.ChestSpreadDamageScaleRatio = 0xa0 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.StomachSpreadDamageScaleRatio = 0xa4 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftArmSpreadDamageScaleRatio = 0xa8 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightArmSpreadDamageScaleRatio = 0xac // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.LeftLegSpreadDamageScaleRatio = 0xb0 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.RightLegSpreadDamageScaleRatio = 0xb4 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.ExtraCureContext = 0xb8 // FSGCharacterEnduranceExtraCureContext (Size: 0x70)
SGCharacterEnduranceAttributeSet.MinEnduraceWhenChangedByBleed = 0x128 // float (Size: 0x4)
SGCharacterEnduranceAttributeSet.MinEnduraceWhenChangedByLackDebuff = 0x12c // float (Size: 0x4)
SGCharacterEnduranceComponent.EnduranceAbility = 0x108 // FCharacterEnduranceAbility (Size: 0x160)
SGCharacterEnduranceComponent.InjuredEnduranceRange = 0xaa8 // FVector2D (Size: 0x8)
SGCharacterEnduranceComponent.InjuredHeadEnduranceRange = 0xab0 // FVector2D (Size: 0x8)
SGCharacterEnduranceComponent.InjuredChestEnduranceRange = 0xab8 // FVector2D (Size: 0x8)
SGCharacterEnduranceComponent.PercentThresholdShowingDying = 0xac0 // float (Size: 0x4)
SGCharacterEnduranceComponent.HeadPercentThresholdShowingDying = 0xac4 // float (Size: 0x4)
SGCharacterEnduranceComponent.ChestPercentThresholdShowingDying = 0xac8 // float (Size: 0x4)
SGCharacterEnduranceComponent.RicochetTinnitusIntensity = 0xacc // float (Size: 0x4)
SGCharacterEnduranceComponent.RicochetStunIntensity = 0xad0 // float (Size: 0x4)
SGCharacterEnduranceComponent.bDrawDebugText = 0xad4 // bool (Size: 0x1)
SGCharacterEnduranceComponent.DamageToEnduranceRatio = 0xad8 // float (Size: 0x4)
SGCharacterEnduranceComponent.AttributeSetClass = 0xae0 // ClassProperty (Size: 0x8)
SGCharacterEnduranceComponent.TinnitusGameplayEffectClass = 0xb08 // ClassProperty (Size: 0x8)
SGCharacterEnduranceComponent.ActivateSuperRecoverHandle = 0xb18 // FTimerHandle (Size: 0x8)
SGCharacterEnduranceComponent.TDMRecoverDelay = 0xb20 // float (Size: 0x4)
SGCharacterEnduranceComponent.SuperRecoverGameplayEffectClass = 0xb28 // ClassProperty (Size: 0x8)
SGCharacterEnduranceComponent.InfiniteClearGameplayEffectClass = 0xb30 // ClassProperty (Size: 0x8)
SGCharacterEnduranceComponent.CurrentHealthCondition = 0xb60 // EECharacterHealthConditionType (Size: 0x1)
SGCharacterEnduranceComponent.DyingPercent = 0xb74 // float (Size: 0x4)
SGCharacterEnduranceExtraCureContext.Vaule = 0x0 // float (Size: 0x4)
SGCharacterEnduranceExtraCureContext.TargetAttribute = 0x8 // FGameplayAttribute (Size: 0x38)
SGCharacterEnduranceExtraCureContext.TargetActor = 0x40 // Actor* (Size: 0x8)
SGCharacterEnduranceExtraCureContext.SourceActor = 0x48 // Actor* (Size: 0x8)
SGCharacterEnduranceExtraCureContext.ModifierOp = 0x50 // uint8_t (Size: 0x1)
SGCharacterEnduranceExtraCureContext.EffectCauser = 0x58 // Actor* (Size: 0x8)
SGCharacterEnduranceExtraCureContext.ContextGA = 0x60 // GameplayAbility* (Size: 0x8)
SGCharacterEnduranceExtraCureContext.LastCureCount = 0x68 // int32_t (Size: 0x4)
SGCharacterEnergyAttributeSet.Energy = 0x48 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.EnergyMax = 0x50 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.MinimumEnergyMax = 0x54 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.MaximumEnergyMax = 0x58 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.ThresholdLeavingExhausted = 0x5c // float (Size: 0x4)
SGCharacterEnergyAttributeSet.bExhausted = 0x60 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.EnergyRecoverSpeedScaleMultiplier = 0x64 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.EnergyReduceSpeedScaleMultiplier = 0x68 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.EnergyRecoverSpeedScaleOfBuff = 0x6c // float (Size: 0x4)
SGCharacterEnergyAttributeSet.EnergyReduceSpeedScaleOfBuff = 0x70 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowEnergy = 0x74 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowEnergyMax = 0x7c // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowMinimumEnergyMax = 0x80 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowMaximumEnergyMax = 0x84 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowThresholdSlightExhausted = 0x88 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.bLowSlightExhausted = 0x8c // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowThresholdLeavingExhausted = 0x90 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.bLowExhausted = 0x94 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowEnergyRecoverSpeedScaleMultiplier = 0x98 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.LowEnergyReduceSpeedScaleMultiplier = 0x9c // float (Size: 0x4)
SGCharacterEnergyAttributeSet.ThresholdLowEmpty = 0xa0 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.bRecoveringLowEnergy = 0xa4 // float (Size: 0x4)
SGCharacterEnergyAttributeSet.bDebug = 0xa8 // bool (Size: 0x1)
SGCharacterEnergyComponent.EnergyReduceScaleCurveBySlopeSprint = 0x108 // CurveFloat* (Size: 0x8)
SGCharacterEnergyComponent.AutoRecoverAbilityClass = 0x128 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByVaultAbilityClass = 0x130 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByJumpAbilityClass = 0x138 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByDiveAbilityClass = 0x140 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PunishmentByExhaustedAbilityClass = 0x148 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByProneToCrouchClass = 0x150 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByProneToStandClass = 0x158 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByCrouchToProneClass = 0x160 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByStandToProneClass = 0x168 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByThrowClass = 0x170 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.PersistentReducedByMeleeAtkClass = 0x178 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.LowAutoRecoverStandClass = 0x180 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.AccumulateDamageToReduceEnergyMax = 0x188 // float (Size: 0x4)
SGCharacterEnergyComponent.ContinuousDamageInterval = 0x18c // float (Size: 0x4)
SGCharacterEnergyComponent.ExhaustAnimRate = 0x190 // float (Size: 0x4)
SGCharacterEnergyComponent.DelayTimeBeforeRecover = 0x194 // float (Size: 0x4)
SGCharacterEnergyComponent.UpEnergyRecoverScale_HoldRifle = 0x198 // float (Size: 0x4)
SGCharacterEnergyComponent.UpEnergyRecoverScale_HoldPistol = 0x19c // float (Size: 0x4)
SGCharacterEnergyComponent.UpEnergyRecoverScale_HoldMeleeOrThrowableStuff = 0x1a0 // float (Size: 0x4)
SGCharacterEnergyComponent.AttributeSetClass = 0x220 // ClassProperty (Size: 0x8)
SGCharacterEnergyComponent.CachedEnergyAttributeSet = 0x238 // SGCharacterEnergyAttributeSet* (Size: 0x8)
SGCharacterEvents.ToggleRescueUI = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.StartRescueTeammate = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.StopRescueTeammate = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.PostStopRescueTeammate = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.FinishRescueTeammate = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.StartRescueProcess = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.StartRescueFailureEvent = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.EndRescueAbilityEvent = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.DetectInRoomEvent = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnDefaultInventoryReplicateComplete = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnPreUnPossessed = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnKeepCorpseAfterDie = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnPreDestroy = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnDestroy = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.TakeDamageEvent = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.TakeFlashedEvent = 0x120 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnUsedInventory = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnMoveInventory = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnSpawnDeathBox = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnGameplayEffectChangedEvent = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.PreApplyTinnitusEffectEvent = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.ToggleDyingEffect = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.DyingEffectChanged = 0x190 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.DeathForEffectMessage = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.UseRecoveryInventory = 0x1b0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.SwitchWeaponCompleted = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.InitPlayerEquipmentsCompleted = 0x1d0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.CostBullet = 0x1e0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.ModifyInventoryTotalCount = 0x1f0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.StackableItemSourceInfoChange = 0x200 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnReadyToPlay = 0x210 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnSprintChanged = 0x220 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnTotalWeightChanged = 0x230 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnWeightConditionChanged = 0x240 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnClientNearByCharacterActivateAbility = 0x250 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnClientNearByCharacterEndAbility = 0x260 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnSpectatedCharProgressAbilityUpdated = 0x270 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.CharacterEnterDangerArea = 0x280 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharacterSetNewOwner = 0x290 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnPreSpawnDeathBox = 0x2a0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharSoundLevelInfluenceFactorChanged = 0x2b0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharSoundMaxDistanceInfluenceFactorChanged = 0x2c0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharacterBeingSpectatedTinnitus = 0x2d0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharacterDestroyActor = 0x2e0 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharLootBoxForReplay = 0x3f8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharLootBoxItemForReplay = 0x408 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharLootPlayerBoxForReplay = 0x418 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharLootPlayerBoxItemForReplay = 0x428 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCharacterReplicatedMovement = 0x468 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnClientCharacterUnLoadPortect = 0x478 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnDBNOThrowEvent = 0x488 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnStartSearchingContainerEvent = 0x498 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnContainerRoughSearchEndEvent = 0x4a8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterEvents.OnCalculateTakeOutValue = 0x4b8 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterFacialAnimInstance.LocalProxy = 0x2c0 // FSGCharacterFacialAnimInstanceProxy (Size: 0x910)
SGCharacterFacialAnimInstance.DefaultIdleFacialSequence = 0xbd0 // AnimSequence* (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.FacialAnimeSeq = 0x860 // AnimSequence* (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.bShouldBlendMouth = 0x868 // float (Size: 0x4)
SGCharacterFacialAnimInstanceProxy.SGAnimInstance = 0x870 // SGCharacterFacialAnimInstance* (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.SGCharacter = 0x878 // SGCharacter* (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.StartTimeOffset = 0x880 // float (Size: 0x4)
SGCharacterFacialAnimInstanceProxy.bIsEquipMask = 0x884 // float (Size: 0x4)
SGCharacterFacialAnimInstanceProxy.ControlRigAimWeight = 0x888 // float (Size: 0x4)
SGCharacterFacialAnimInstanceProxy.EyeAimPosition = 0x88c // FVector (Size: 0xc)
SGCharacterFacialAnimInstanceProxy.FaceAimControl = 0x898 // FVector2D (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.bUseFacialAnimation = 0x8a0 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.bDTCharacter = 0x8a1 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.bZDCharacter = 0x8a2 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.bJSCharacter = 0x8a3 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.bPMCCharacter = 0x8a4 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.bScavCharacter = 0x8a5 // bool (Size: 0x1)
SGCharacterFacialAnimInstanceProxy.ZDCharacterTag = 0x8a8 // FName (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.JSCharacterTag = 0x8b0 // FName (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.HeadAvatarID = 0x8b8 // int64_t (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.IdleFacialSequence = 0x8c0 // AnimSequence* (Size: 0x8)
SGCharacterFacialAnimInstanceProxy.DTRandomMontageList = 0x8c8 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterFacialAnimInstanceProxy.ZDRandomMontageList = 0x8d8 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterFacialAnimInstanceProxy.JSRandomMontageList = 0x8e8 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterFacialAnimationSets.Male = 0x28 // FSGCharacterFacialAnimationSetsPerCharacterSex (Size: 0x1a0)
SGCharacterFacialAnimationSets.Female = 0x1c8 // FSGCharacterFacialAnimationSetsPerCharacterSex (Size: 0x1a0)
SGCharacterFacialAnimationSets.FacialAnimations = 0x368 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSets.DTFacialAnimaSequences = 0x3b8 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSets.PreivewAnimationSets = 0x408 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSetsPerCharacterSex.FacialAnimations = 0x0 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSetsPerCharacterSex.DTFacialAnimaSequences = 0x50 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSetsPerCharacterSex.DTRandomMontageList = 0xa0 // FSGRandomMontageList (Size: 0x10)
SGCharacterFacialAnimationSetsPerCharacterSex.ZDRandomMontageLists = 0xb0 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSetsPerCharacterSex.JSRandomMontageLists = 0x100 // TMap<...> (Size: 0x50)
SGCharacterFacialAnimationSetsPerCharacterSex.IdleFacialAnimSequence = 0x150 // TMap<...> (Size: 0x50)
SGCharacterFallComponent.MaxSafeFallSpeed = 0x108 // float (Size: 0x4)
SGCharacterFallComponent.FallingAnimType = 0x10c // EEFallingAnimType (Size: 0x1)
SGCharacterFallComponent.FallingHighHeight = 0x110 // float (Size: 0x4)
SGCharacterFallComponent.FallingMediumHeight = 0x114 // float (Size: 0x4)
SGCharacterFallComponent.FallingLowHeight = 0x118 // float (Size: 0x4)
SGCharacterFallComponent.FallingHighSpeed = 0x11c // float (Size: 0x4)
SGCharacterFallComponent.FallingMediumSpeed = 0x120 // float (Size: 0x4)
SGCharacterFallComponent.FallingLowSpeed = 0x124 // float (Size: 0x4)
SGCharacterFallComponent.FallingSpeed = 0x128 // float (Size: 0x4)
SGCharacterFallComponent.FallingDamage = 0x12c // float (Size: 0x4)
SGCharacterFallComponent.FallingDamageCurve = 0x130 // CurveFloat* (Size: 0x8)
SGCharacterFallComponent.ContinuouslyJumpDampingClass = 0x138 // ClassProperty (Size: 0x8)
SGCharacterFallComponent.ContinuouslyJumpDampingSpecHandles = 0x140 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
SGCharacterFallComponent.ContinuouslyJumpMaxDampingTimes = 0x150 // int32_t (Size: 0x4)
SGCharacterFallComponent.CancelContinuouslyJumpDampingDelayTime = 0x154 // float (Size: 0x4)
SGCharacterFallComponent.FallingTag = 0x160 // FGameplayTag (Size: 0x8)
SGCharacterFlashGrenadeEffectComponent.RTWidth = 0x100 // float (Size: 0x4)
SGCharacterFlashGrenadeEffectComponent.RTHeight = 0x104 // float (Size: 0x4)
SGCharacterFlashGrenadeEffectComponent.FlashLightCircleFadeoutAddTime = 0x108 // float (Size: 0x4)
SGCharacterFlashGrenadeEffectComponent.FlashFOVAngle = 0x10c // float (Size: 0x4)
SGCharacterFlashGrenadeEffectComponent.FlashBlindClass = 0x110 // ClassProperty (Size: 0x8)
SGCharacterFlashGrenadeEffectComponent.FlashData = 0x118 // FFlashData (Size: 0x28)
SGCharacterFoodAttributeSet.Food = 0x48 // float (Size: 0x4)
SGCharacterFoodAttributeSet.FoodMax = 0x4c // float (Size: 0x4)
SGCharacterFoodComponent.HeavyLackInFoodThreshold = 0x100 // float (Size: 0x4)
SGCharacterFoodComponent.MediumLackInFoodThreshold = 0x104 // float (Size: 0x4)
SGCharacterFoodComponent.SlightLackInFoodThreshold = 0x108 // float (Size: 0x4)
SGCharacterFoodComponent.FoodState = 0x10d // EECharacterFoodStateType (Size: 0x1)
SGCharacterFoodComponent.FoodStateConfigMap = 0x110 // TMap<...> (Size: 0x50)
SGCharacterFoodComponent.GalleryBuffIdList = 0x160 // TMap<...> (Size: 0x50)
SGCharacterFoodComponent.ReduceScaleForGalleryLevel1 = 0x1b0 // float (Size: 0x4)
SGCharacterFoodComponent.ReduceScaleForGalleryLevel2 = 0x1b4 // float (Size: 0x4)
SGCharacterFoodComponent.AutoReducedAbilityClass = 0x1b8 // ClassProperty (Size: 0x8)
SGCharacterFoodComponent.LackInFoodSideEffectAbilityClass = 0x1c0 // ClassProperty (Size: 0x8)
SGCharacterFoodComponent.GalleryLevel1GameplayEffect = 0x1c8 // ClassProperty (Size: 0x8)
SGCharacterFoodComponent.GalleryLevel2GameplayEffect = 0x1d0 // ClassProperty (Size: 0x8)
SGCharacterFoodComponent.AttributeSetClass = 0x1f8 // ClassProperty (Size: 0x8)
SGCharacterFootEffectComponent.PhysicalSurfaceInfluenceFactorConfig = 0x108 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.SpecialSurfaceToFootFactorConfig = 0x158 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.SoundIndicator = 0x1a8 // SoundIndicator* (Size: 0x8)
SGCharacterFootEffectComponent.EnableFootstepSimulation = 0x1b0 // bool (Size: 0x1)
SGCharacterFootEffectComponent.CurrentFootAudioSwitch = 0x1b8 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.FootSmokeList = 0x208 // TArray<uint8_t> (Size: 0x10)
SGCharacterFootEffectComponent.FootAudioSettings = 0x218 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.BodyHeight = 0x268 // float (Size: 0x4)
SGCharacterFootEffectComponent.DefaultTimerInterval = 0x26c // float (Size: 0x4)
SGCharacterFootEffectComponent.LadderPhysicalSurface = 0x270 // uint8_t (Size: 0x1)
SGCharacterFootEffectComponent.CharSpeedSwitch = 0x278 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.InteractiveWaterFootPS1 = 0x2c8 // ParticleSystem* (Size: 0x8)
SGCharacterFootEffectComponent.InteractiveWaterFootPS2 = 0x2d0 // ParticleSystem* (Size: 0x8)
SGCharacterFootEffectComponent.InteractiveWaterBodyPS = 0x2d8 // ParticleSystem* (Size: 0x8)
SGCharacterFootEffectComponent.InteractiveMudFootPS1 = 0x2e0 // ParticleSystem* (Size: 0x8)
SGCharacterFootEffectComponent.InteractiveMudFootPS2 = 0x2e8 // ParticleSystem* (Size: 0x8)
SGCharacterFootEffectComponent.UpdateMaterialInterval = 0x2f0 // float (Size: 0x4)
SGCharacterFootEffectComponent.MatIntervalEnableDis = 0x2f4 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootstepSpreadDis = 0x2f8 // float (Size: 0x4)
SGCharacterFootEffectComponent.SoundDiffusionLevelFactor = 0x2fc // float (Size: 0x4)
SGCharacterFootEffectComponent.SoundDiffusionMaxDistanceFactor = 0x300 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintShowRange = 0x308 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintShowRangeSquared = 0x30c // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxOcclusionTraceDistance = 0x310 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintTrailScale = 0x314 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintPositionOffset = 0x318 // TArray<FVector> (Size: 0x10)
SGCharacterFootEffectComponent.FootprintInstanceMap = 0x328 // FFootprintInstanceMap (Size: 0x1f8)
SGCharacterFootEffectComponent.StepWidth = 0x520 // float (Size: 0x4)
SGCharacterFootEffectComponent.StepNumPerSecond = 0x524 // int32_t (Size: 0x4)
SGCharacterFootEffectComponent.MinStepLength = 0x528 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintPathCollectInterval = 0x52c // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxFootPrintPathValidInterval = 0x530 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintTraceHeight = 0x534 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintTraceRoomHeight = 0x538 // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxFootPrintPathHeight = 0x53c // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxFootPrintPathLengthSquared = 0x540 // float (Size: 0x4)
SGCharacterFootEffectComponent.MinFootPrintPathLengthSquared = 0x544 // float (Size: 0x4)
SGCharacterFootEffectComponent.MinFootPrintPathFloorZ = 0x548 // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxFootPrintHeight = 0x54c // float (Size: 0x4)
SGCharacterFootEffectComponent.MaxLandedFootPrintHeight = 0x550 // float (Size: 0x4)
SGCharacterFootEffectComponent.MinFootPrintHeight = 0x554 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootPrintFixOffset = 0x558 // FVector (Size: 0xc)
SGCharacterFootEffectComponent.MaxFootPrintPathNum = 0x570 // int32_t (Size: 0x4)
SGCharacterFootEffectComponent.MaxTimeErrorFromPath = 0x574 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootSnowTrailRadius = 0x578 // float (Size: 0x4)
SGCharacterFootEffectComponent.WeatherList = 0x580 // TArray<FWeatherFootPrintMap> (Size: 0x10)
SGCharacterFootEffectComponent.WeatherOverrideSettings = 0x590 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.FootPrintPathTempCollectTime = 0x5e0 // float (Size: 0x4)
SGCharacterFootEffectComponent.FootprintManagerSubsystem = 0x5e4 // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterFootEffectComponent.LastFootPrint = 0x634 // FFootPrintInfo (Size: 0x24)
SGCharacterFootEffectComponent.FootPrintOrderedArray = 0x680 // FFootPrintClusterInfoArray (Size: 0x20)
SGCharacterFootEffectComponent.Map = 0x6a0 // TMap<...> (Size: 0x50)
SGCharacterFootEffectComponent.FootPrintClusterArrayFromPath = 0x6f0 // TArray<FFootPrintClusterInfo> (Size: 0x10)
SGCharacterFootEffectComponent.FootPrintClusterArrayFromAnim = 0x700 // FFootPrintClusterInfoArray (Size: 0x20)
SGCharacterFootEffectComponent.LastTimeFootPrintFromAnim = 0x720 // float (Size: 0x4)
SGCharacterFootEffectComponent.WeatherFootPrintType = 0x724 // EFWeatherFootPrintType (Size: 0x1)
SGCharacterFootEffectComponent.CachedForceUpdateOcclusion = 0x725 // bool (Size: 0x1)
SGCharacterFootEffectComponent.CachedCharacter = 0x780 // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterFootEffectComponent.SoundComp = 0x788 // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterFootIKAnimInstance.LocalProxy = 0x2c0 // FSGCharacterFootIKAnimInstanceProxy (Size: 0x920)
SGCharacterFootIKAnimInstance.MainAnimInstance = 0xbe0 // AnimInstance* (Size: 0x8)
SGCharacterFootIKAnimInstanceProxy.IKFoot_Root_Offset = 0x860 // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootLock_L_Rotation = 0x86c // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootLock_L_Location = 0x878 // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootLock_L_Alpha = 0x884 // float (Size: 0x4)
SGCharacterFootIKAnimInstanceProxy.FootLock_R_Rotation = 0x888 // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootLock_R_Location = 0x894 // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootLock_R_Alpha = 0x8a0 // float (Size: 0x4)
SGCharacterFootIKAnimInstanceProxy.FootOffset_L_Location = 0x8a4 // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootOffset_L_Rotation = 0x8b0 // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootOffset_R_Location = 0x8bc // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootOffset_R_Rotation = 0x8c8 // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.PelvisOffset_Location = 0x8d4 // FVector (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.FootIKAlpha = 0x8e0 // float (Size: 0x4)
SGCharacterFootIKAnimInstanceProxy.ThighOffset_L_Rotation_WhenProne = 0x8e4 // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.ThighOffset_R_Rotation_WhenProne = 0x8f0 // FRotator (Size: 0xc)
SGCharacterFootIKAnimInstanceProxy.bIsProne = 0x8fc // bool (Size: 0x1)
SGCharacterFootIKAnimInstanceProxy.bShouldUpdateFootIK = 0x8fd // bool (Size: 0x1)
SGCharacterFootIKAnimInstanceProxy.bInOrTransTacticalPistolState = 0x900 // float (Size: 0x4)
SGCharacterFootIKAnimInstanceProxy.SGAnimInstance = 0x908 // SGCharacterFootIKAnimInstance* (Size: 0x8)
SGCharacterFootIKAnimInstanceProxy.SGMainAnimInstance = 0x910 // AnimInstance* (Size: 0x8)
SGCharacterFootIKAnimInstanceProxy.SGCharacter = 0x918 // SGCharacter* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.OffensiveScreenEffectIns = 0x100 // MaterialInstance* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.OffensiveScreenEffectConfArray = 0x108 // TArray<FScreenEffectConfArray> (Size: 0x10)
SGCharacterFragGrenadeEffectComponent.M67ScreenEffectIns = 0x118 // MaterialInstance* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.M67ScreenEffectConfArray = 0x120 // TArray<FScreenEffectConfArray> (Size: 0x10)
SGCharacterFragGrenadeEffectComponent.FragProjectile = 0x138 // SGThrowableProjectile* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.PPV = 0x140 // PostProcessVolume* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.bDizzyByGrenade = 0x14a // bool (Size: 0x1)
SGCharacterFragGrenadeEffectComponent.bApplyDizzyDuringDizzy = 0x14b // bool (Size: 0x1)
SGCharacterFragGrenadeEffectComponent.LastDizzyByGrenade = 0x158 // Actor* (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.FlashPersistentenceVisionClass = 0x168 // ClassProperty (Size: 0x8)
SGCharacterFragGrenadeEffectComponent.GreaadeBanInfoList = 0x190 // TArray<FThrowableWeaponBanInfo> (Size: 0x10)
SGCharacterFragGrenadeEffectComponent.UnbanMapIdPrefixes = 0x1a0 // TArray<uint32_t> (Size: 0x10)
SGCharacterFragGrenadeEffectComponent.BanList = 0x1b0 // TMap<...> (Size: 0x50)
SGCharacterFreshWoundComponent.ChanceToTrigger_Bleed_When_Jump = 0x100 // float (Size: 0x4)
SGCharacterFreshWoundComponent.ChanceToTrigger_Bleed_When_Sprint = 0x104 // float (Size: 0x4)
SGCharacterFreshWoundComponent.PeriodToTrigger_Bleed_When_Sprint = 0x108 // float (Size: 0x4)
SGCharacterGroundInfo.GroundHitResult = 0x8 // FHitResult (Size: 0x98)
SGCharacterGroundInfo.GroundDistance = 0xa0 // float (Size: 0x4)
SGCharacterHandIKAnimInstance.LocalProxy = 0x2c0 // FSGCharacterHandIKAnimInstanceProxy (Size: 0xa30)
SGCharacterHandIKAnimInstance.MainAnimInstance = 0xcf0 // AnimInstance* (Size: 0x8)
SGCharacterHandIKAnimInstance.LeftHandIK_CurveValue_Scaler = 0xcf8 // float (Size: 0x4)
SGCharacterHandIKAnimInstance.RightHandIK_CurveValue_Scaler = 0xcfc // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.bShouldUpdateHandIK = 0x860 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.Enable_LFingerAdaptive = 0x864 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.Enable_LeftHandIK = 0x868 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.Enable_RightHandIK = 0x86c // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.Enable_HandIK = 0x870 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.Enable_LeftArm_Offset = 0x874 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.Enable_LeftArm_Adjust_Stretch = 0x878 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.ArmStretch_AngleThreshold = 0x894 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.ArmStretch_ExtraOffset = 0x898 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.HandWeaponOffset_LeftHand = 0x8a4 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.HandWeaponOffset_RightHand_Location = 0x8b0 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.HandWeaponOffset_RightHand_Rotation = 0x8bc // FRotator (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.LeftHandJointOffset = 0x8c8 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.RightHandJointOffset = 0x8d4 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.LeftArmOffset = 0x8e0 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.RightHandOffset = 0x8ec // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.RightArmAimOffset = 0x8f8 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.HandOffset_L_Location = 0x904 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.Enable_HandOffset_L_Alpha = 0x910 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.HandOffset_R_Location = 0x914 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.bShouldModified_IK_Hand_L = 0x920 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.ModifiedLocation_IK_Hand_L = 0x924 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.bShouldModified_IK_Hand_R = 0x930 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.bShouldModified_IK_Hand_Gun = 0x931 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.bDisableModified_IK_Hand_R_CopyBone = 0x932 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.ModifiedLocation_IK_Hand_R = 0x934 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.ModifiedLocation_IK_Hand_Gun = 0x940 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.Enable_HandOffset_R_Alpha = 0x94c // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.bShouldCopyRightToGun = 0x950 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.LeftHandParentBoneSpaceOffset = 0x954 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.LeftHandParentBoneSpaceAlpha = 0x960 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.RightHandParentBoneSpaceOffset = 0x964 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.RightHandParentBoneSpaceAlpha = 0x970 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.TacticalLeftHandRifleOffsetAlpha = 0x974 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.LeftHandComponentSpaceOffset = 0x978 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.LeftHandComponentSpaceAlpha = 0x984 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.RightHandComponentSpaceOffset = 0x988 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.RightHandComponentSpaceAlpha = 0x994 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.BindItemLtoR_Alpha = 0x998 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.BindItemLtoR_RelativeTrans = 0x9a0 // FTransform (Size: 0x30)
SGCharacterHandIKAnimInstanceProxy.bIsPrviewCharacter = 0x9d0 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.WeaponStance = 0x9d1 // EEWeaponType (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.bIsUsingItem = 0x9d2 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.bIsRescuingTeammate = 0x9d3 // bool (Size: 0x1)
SGCharacterHandIKAnimInstanceProxy.bTacticalPistol = 0x9d4 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.bInOrTransTacticalPistolState = 0x9d8 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.bTacticalPistolAiming = 0x9dc // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.bShouldTacticalPistolCopyItemr = 0x9e0 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.TacticalPistolHandOffsetAlpha = 0x9e4 // float (Size: 0x4)
SGCharacterHandIKAnimInstanceProxy.TacticalLeftHandOffset = 0x9e8 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.TacticalRightHandOffset = 0x9f4 // FVector (Size: 0xc)
SGCharacterHandIKAnimInstanceProxy.SGAnimInstance = 0xa00 // SGCharacterHandIKAnimInstance* (Size: 0x8)
SGCharacterHandIKAnimInstanceProxy.SGMainAnimInstance = 0xa08 // SGCharacterAnimInstance* (Size: 0x8)
SGCharacterHandIKAnimInstanceProxy.SGCharacter = 0xa10 // SGCharacter* (Size: 0x8)
SGCharacterHandIKAnimInstanceProxy.CharacterAnimationComponent = 0xa18 // SGCharacterAnimationComponent* (Size: 0x8)
SGCharacterHandIKAnimInstanceProxy.SGWeapon = 0xa20 // SGWeapon* (Size: 0x8)
SGCharacterHealthAttributeSet.DBNOHealth = 0x58 // float (Size: 0x4)
SGCharacterHealthAttributeSet.DBNOHealthMax = 0x5c // float (Size: 0x4)
SGCharacterHealthComponent.EnteringBleedAbilityClass = 0x110 // ClassProperty (Size: 0x8)
SGCharacterHealthComponent.EnteringPainAbilityClass = 0x118 // ClassProperty (Size: 0x8)
SGCharacterHealthComponent.HealthPercentThresholdEnteringPain = 0x128 // float (Size: 0x4)
SGCharacterHealthComponent.SignalAttributeSetClass = 0x130 // ClassProperty (Size: 0x8)
SGCharacterHealthComponent.SignalValueChangeEffectClass = 0x138 // ClassProperty (Size: 0x8)
SGCharacterHealthComponent.SignalAutoRecoverValue = 0x140 // float (Size: 0x4)
SGCharacterHealthComponent.DelayTimeBeforeSignalAutoRecover = 0x144 // float (Size: 0x4)
SGCharacterHealthComponent.bIsInBRCylinder = 0x148 // bool (Size: 0x1)
SGCharacterHealthComponent.LastEnterBRCylinderTime = 0x14c // float (Size: 0x4)
SGCharacterHearingComponent.CachedSenseAttributeSet = 0x100 // SGCharacterSenseAttributeSet* (Size: 0x8)
SGCharacterHearingComponent.DelayTimeBeforeRecover = 0x110 // float (Size: 0x4)
SGCharacterHearingComponent.DistanceFactorCurve = 0x118 // CurveFloat* (Size: 0x8)
SGCharacterHearingComponent.AutoRecoverAbilityClass = 0x120 // ClassProperty (Size: 0x8)
SGCharacterHearingComponent.DecreaseByFireClass = 0x128 // ClassProperty (Size: 0x8)
SGCharacterHearingComponent.AttributeSetClass = 0x130 // ClassProperty (Size: 0x8)
SGCharacterHearingComponent.HearingLossEffectAbilityClass = 0x138 // ClassProperty (Size: 0x8)
SGCharacterHearingComponent.HearingEnduranceThreshold = 0x140 // float (Size: 0x4)
SGCharacterHoldBreathComponent.bIsHoldingBreath = 0x100 // bool (Size: 0x1)
SGCharacterIKComponent.bEnableDebug = 0x110 // bool (Size: 0x1)
SGCharacterIKComponent.bEnableRightHandIK = 0x111 // bool (Size: 0x1)
SGCharacterIKComponent.bEnableFootIK = 0x150 // bool (Size: 0x1)
SGCharacterIKComponent.bEnableDSFootIK = 0x151 // bool (Size: 0x1)
SGCharacterIKComponent.FootIKMaxScreenSize = 0x154 // float (Size: 0x4)
SGCharacterIKComponent.IK_TraceDistanceAboveFoot = 0x158 // float (Size: 0x4)
SGCharacterIKComponent.IK_TraceDistanceBelowFoot_Stand = 0x15c // float (Size: 0x4)
SGCharacterIKComponent.IK_TraceDistanceBelowFoot_Crouch = 0x160 // float (Size: 0x4)
SGCharacterIKComponent.IK_TraceDistanceBelowFoot_Prone = 0x164 // float (Size: 0x4)
SGCharacterIKComponent.FootOffset_InterpSpeed = 0x168 // float (Size: 0x4)
SGCharacterIKComponent.PelvisOffset_InterpSpeed = 0x16c // float (Size: 0x4)
SGCharacterIKComponent.FootIK_InterpSpeed = 0x170 // float (Size: 0x4)
SGCharacterIKComponent.FootHeight = 0x174 // float (Size: 0x4)
SGCharacterIKComponent.HandHeight = 0x178 // float (Size: 0x4)
SGCharacterIKComponent.EnableHandOffset_MaxDistance = 0x17c // float (Size: 0x4)
SGCharacterIKComponent.MaxHandOffsetHeight = 0x180 // float (Size: 0x4)
SGCharacterIKComponent.CapsuleTraceRadius = 0x184 // float (Size: 0x4)
SGCharacterIKComponent.Root_Bone = 0x188 // FName (Size: 0x8)
SGCharacterIKComponent.IKFoot_L_Bone = 0x190 // FName (Size: 0x8)
SGCharacterIKComponent.IKFoot_R_Bone = 0x198 // FName (Size: 0x8)
SGCharacterIKComponent.Thigh_L_Bone = 0x1a0 // FName (Size: 0x8)
SGCharacterIKComponent.Thigh_R_Bone = 0x1a8 // FName (Size: 0x8)
SGCharacterIKComponent.IKFoot_Root_Offset_When_Prone = 0x1b0 // FVector (Size: 0xc)
SGCharacterIKComponent.IKHand_L_Bone = 0x1bc // FName (Size: 0x8)
SGCharacterIKComponent.IKHand_R_Bone = 0x1c4 // FName (Size: 0x8)
SGCharacterIKComponent.IK_TraceDistanceBelowHand_Prone = 0x1cc // float (Size: 0x4)
SGCharacterIKComponent.IK_TraceDistanceAboveHand = 0x1d0 // float (Size: 0x4)
SGCharacterIKComponent.IKFootHighDiffValue = 0x23c // float (Size: 0x4)
SGCharacterIKComponent.GSharedInfo = 0x240 // NPCAIGlobalSharedInfo* (Size: 0x8)
SGCharacterIKComponent.Max_FootLock_Rotation_Difference = 0x248 // float (Size: 0x4)
SGCharacterIKComponent.Accumulate_FootLock_L_Rotation = 0x24c // FRotator (Size: 0xc)
SGCharacterIKComponent.Accumulate_FootLock_R_Rotation = 0x258 // FRotator (Size: 0xc)
SGCharacterIKComponent.Accumulate_FootLock_L_Rotation_Difference = 0x264 // float (Size: 0x4)
SGCharacterIKComponent.Accumulate_FootLock_R_Rotation_Difference = 0x268 // float (Size: 0x4)
SGCharacterIKComponent.StandingStillToFootPlacementDormantTime = 0x274 // float (Size: 0x4)
SGCharacterIKComponent.TickSetting_HighEndDevice = 0x278 // FTickSettingBaseOnURO (Size: 0x10)
SGCharacterIKComponent.TickSetting_LowEndDevice = 0x288 // FTickSettingBaseOnURO (Size: 0x10)
SGCharacterInRoomComponent.bDebugTrace = 0x100 // bool (Size: 0x1)
SGCharacterInRoomComponent.TraceLength = 0x104 // float (Size: 0x4)
SGCharacterInRoomComponent.TraceBeginOffset = 0x108 // float (Size: 0x4)
SGCharacterInputProcessComponent.CachedInventory = 0x108 // SGInventory* (Size: 0x8)
SGCharacterInputProcessComponent.CachedLootActor = 0x110 // Actor* (Size: 0x8)
SGCharacterInputProcessComponent.CachedPickupInventory = 0x118 // SGInventory* (Size: 0x8)
SGCharacterInputProcessComponent.CachedTeammate = 0x120 // Character* (Size: 0x8)
SGCharacterInputProcessComponent.CurMovedInventory = 0x128 // SGInventory* (Size: 0x8)
SGCharacterInputProcessComponent.LongShortPressInterval = 0x13c // float (Size: 0x4)
SGCharacterInputProcessComponent.bDoorInteractEnabled = 0x140 // bool (Size: 0x1)
SGCharacterInputProcessComponent.CachedMoveInputXY = 0x150 // FVector2D (Size: 0x8)
SGCharacterInputProcessComponent.HoldInputBehavior = 0x160 // TMap<...> (Size: 0x50)
SGCharacterInputProcessComponent.CachedGameplayTagsToWait = 0x1b0 // TSet<...> (Size: 0x50)
SGCharacterInputProcessComponent.ActionsEnableWaitTransitionByCurve = 0x200 // TSet<...> (Size: 0x50)
SGCharacterInputProcessComponent.TagsEnableWaitTransitionByCurve = 0x250 // FGameplayTagContainer (Size: 0x20)
SGCharacterInputProcessComponent.AllWeaponActions = 0x270 // TArray<FName> (Size: 0x10)
SGCharacterInputProcessComponent.HoldInputRecords = 0x280 // TMap<...> (Size: 0x50)
SGCharacterInputProcessComponent.SprintRightInputScale = 0x2d0 // float (Size: 0x4)
SGCharacterInputProcessComponent.SprintRightInputBlendSpeed = 0x2d4 // float (Size: 0x4)
SGCharacterInputProcessComponent.LeanBlockTags = 0x2e8 // FGameplayTagContainer (Size: 0x20)
SGCharacterInputProcessComponent.SilentWalkBlockTags = 0x308 // FGameplayTagContainer (Size: 0x20)
SGCharacterInspectionComponent.RecordInspectionLootPointIDArray = 0x100 // TArray<int32_t> (Size: 0x10)
SGCharacterInspectionComponent.ExploreInspectionLootPointIDArray = 0x110 // TArray<int32_t> (Size: 0x10)
SGCharacterInteractionComponent.HostedInteractAnimInfoMap = 0x108 // TMap<...> (Size: 0x50)
SGCharacterInteractionComponent.ReplicatedKeyDoorIKInfo = 0x1b0 // FKeyDoorIKInfo (Size: 0x58)
SGCharacterInteractionComponent.InterpSpeed_Location = 0x208 // float (Size: 0x4)
SGCharacterInteractionComponent.InterpSpeed_ControlRotation = 0x20c // float (Size: 0x4)
SGCharacterInteractionComponent.MaxMoveTime = 0x210 // float (Size: 0x4)
SGCharacterInteractionComponent.CachedMontageToPlay = 0x218 // AnimMontage* (Size: 0x8)
SGCharacterInteractionComponent.CachedAdditionalMontageToPlay = 0x220 // AnimMontage* (Size: 0x8)
SGCharacterInteractionComponent.CachedInteractActor = 0x228 // Actor* (Size: 0x8)
SGCharacterInteractionComponent.CachedKeyItem = 0x230 // SGInventory* (Size: 0x8)
SGCharacterInteractionComponent.CachedKeyItemSubClass = 0x238 // ClassProperty (Size: 0x8)
SGCharacterInteractionComponent.CachedDoorCategory = 0x240 // EESGDoorCategory (Size: 0x1)
SGCharacterInteractionComponent.CachedDoorAction = 0x241 // EEDoorAction (Size: 0x1)
SGCharacterInteractionComponent.KeyAttachSocket_1P = 0x244 // FName (Size: 0x8)
SGCharacterInteractionComponent.KeyAttachSocket_3P = 0x24c // FName (Size: 0x8)
SGCharacterInteractionComponent.KeyAttachDelayTime = 0x254 // float (Size: 0x4)
SGCharacterInteractionComponent.CardKeyDetachDelayTime = 0x258 // float (Size: 0x4)
SGCharacterInteractionComponent.DefaultKeyAttachDelayTime = 0x25c // float (Size: 0x4)
SGCharacterInteractionComponent.EnableIKMaxLenFromShoulderToLock = 0x260 // float (Size: 0x4)
SGCharacterInteractionComponent.EnableIKMaxRotFromShoulderToLock = 0x264 // FRotator (Size: 0xc)
SGCharacterInteractionComponent.LShoulderBoneName = 0x270 // FName (Size: 0x8)
SGCharacterInteractionComponent.InnerLockWristOffset = 0x278 // FVector (Size: 0xc)
SGCharacterInteractionComponent.OuterLockWristOffset = 0x284 // FVector (Size: 0xc)
SGCharacterInteractionComponent.UnCrouchDelayTime = 0x290 // float (Size: 0x4)
SGCharacterInteractionComponent.UnProneDelayTime = 0x294 // float (Size: 0x4)
SGCharacterInteractionComponent.MoveToDoorSpeed = 0x298 // float (Size: 0x4)
SGCharacterInteractionComponent.KeyDetachDelayTime = 0x29c // float (Size: 0x4)
SGCharacterInteractionComponent.KeyMeshComponent = 0x2a0 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterInteractionComponent.KeySkeletonMesh = 0x2a8 // SkeletalMesh* (Size: 0x8)
SGCharacterInteractionComponent.KeyItemID = 0x2b0 // int64_t (Size: 0x8)
SGCharacterInvInteractFlagComponent.IsNewFlagInvList = 0x100 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInvInteractFlagComponent.LastIsNewFlagInvList = 0x110 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInvInteractFlagComponent.CurrentInteractingInfo = 0x120 // FInventoryInteractionRepInfo (Size: 0x18)
SGCharacterInvInteractFlagComponent.InventoryJustReplaced = 0x138 // SGInventory* (Size: 0x8)
SGCharacterInvInteractFlagComponent.PlayerWishList = 0x140 // TArray<FSGWishListItemInfo> (Size: 0x10)
SGCharacterInvInteractFlagComponent.PlayerWishListSellItemSet = 0x150 // TSet<...> (Size: 0x50)
SGCharacterInvInteractFlagComponent.PlayerWishListRecipeItemSet = 0x1a0 // TSet<...> (Size: 0x50)
SGCharacterInvInteractFlagComponent.NewInspectedItemIDs = 0x1f0 // TArray<int32_t> (Size: 0x10)
SGCharacterInvInteractFlagComponent.WaitGIDTimerHandle = 0x2a0 // FTimerHandle (Size: 0x8)
SGCharacterInventoryComponent.AutoFindDropPos_OutPos = 0x100 // FItemGridInfo (Size: 0x8)
SGCharacterInventoryComponent.AutoFindDropPos_OutResult = 0x108 // bool (Size: 0x1)
SGCharacterInventoryComponent.AutoFindDropPos_OutIsDoRotate = 0x109 // bool (Size: 0x1)
SGCharacterInventoryComponent.MAX_INV_INTERACT_SQR_DIST = 0x10c // float (Size: 0x4)
SGCharacterInventoryComponent.MAX_INV_INTERACT_SQR_DIST_ScaleForContainer = 0x110 // float (Size: 0x4)
SGCharacterInventoryComponent.GridPreOccupyContainerList = 0x118 // TMap<...> (Size: 0x50)
SGCharacterInventoryComponent.LastPlayerMoveInventoryResult = 0x168 // EEPlayerMoveInventoryResultCode (Size: 0x1)
SGCharacterInventoryComponent.DelayDropInventory = 0x170 // SGInventory* (Size: 0x8)
SGCharacterInventoryDetectComponent.FindPickupMaxRadius = 0x100 // float (Size: 0x4)
SGCharacterInventoryDetectComponent.InventorysNearby = 0x108 // TArray<Actor*> (Size: 0x10)
SGCharacterInventoryDetectComponent.InventorysNearbyInteractInfoMap = 0x118 // TMap<...> (Size: 0x50)
SGCharacterInventoryGiveComponent.PickupAnimRate = 0x100 // float (Size: 0x4)
SGCharacterInventoryGiveComponent.SpawnInventory = 0x108 // SGInventory* (Size: 0x8)
SGCharacterInventoryGiveComponent.TraceChannel = 0x161 // uint8_t (Size: 0x1)
SGCharacterInventoryManagerComponent.CurGivedInventory = 0x108 // SGInventory* (Size: 0x8)
SGCharacterInventoryManagerComponent.InventoryArray = 0x110 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryManagerComponent.CustomEffectCharacterAttributeInventoryPosArr = 0x120 // TArray<EEAttachPosition> (Size: 0x10)
SGCharacterInventoryManagerComponent.EffectCharacterAttributeInventoryArr = 0x130 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryManagerComponent.MarkedInventoryArray = 0x140 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryManagerComponent.EquippedInventoryMap = 0x150 // TMap<...> (Size: 0x50)
SGCharacterInventoryManagerComponent.EquippedInventoryMap2 = 0x1a0 // TMap<...> (Size: 0x50)
SGCharacterInventoryManagerComponent.ExtendInventorys = 0x1f0 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryManagerComponent.TotalWeight = 0x218 // float (Size: 0x4)
SGCharacterInventoryManagerComponent.TotalInventoryValue = 0x21c // int32_t (Size: 0x4)
SGCharacterInventoryManagerComponent.DefaultInventoryNum = 0x270 // int32_t (Size: 0x4)
SGCharacterInventoryManagerComponent.CheckDefaultReplicateInventoryTimeHandle = 0x278 // FTimerHandle (Size: 0x8)
SGCharacterInventoryManagerComponent.bSlicedProcessFindInventoryClassCallbacks = 0x2e0 // bool (Size: 0x1)
SGCharacterInventoryManagerComponent.MaxSlicedProcessTime = 0x2e4 // float (Size: 0x4)
SGCharacterInventoryManagerComponent.ValuableInventoryArray = 0x308 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryManagerComponent.RemovedValuableInventoryArray = 0x318 // TArray<SGInventory*> (Size: 0x10)
SGCharacterInventoryMontageParams.CharacterMontage = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterInventoryMontageParams.InventoryMontage = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterInventorySearchComponent.CurSyncAutoSearchingComList = 0x100 // TArray<SGInventoryContainerSearchingComponent*> (Size: 0x10)
SGCharacterInventorySearchComponent.SearchingContainerInfoList = 0x110 // TArray<FContainerSearchingInfo> (Size: 0x10)
SGCharacterInventorySearchComponent.DetailSearchingInvComList = 0x120 // TArray<SGInventorySearchComponent*> (Size: 0x10)
SGCharacterInventorySearchComponent.ClientOld_DetailSearchingInvComList = 0x130 // TArray<SGInventorySearchComponent*> (Size: 0x10)
SGCharacterInventorySearchComponent.SearchSlowScaleFatigue = 0x144 // float (Size: 0x4)
SGCharacterInventorySearchComponent.SearchSlowScaleSizePerUnit = 0x148 // float (Size: 0x4)
SGCharacterInventorySearchComponent.SearchSlowScaleWeightPerKg = 0x14c // float (Size: 0x4)
SGCharacterInventorySearchComponent.RoughSearchStandardTime = 0x150 // float (Size: 0x4)
SGCharacterInventorySearchComponent.SearchStandardTime = 0x154 // float (Size: 0x4)
SGCharacterInventorySearchComponent.RoughSearchTime = 0x158 // float (Size: 0x4)
SGCharacterInventorySearchComponent.bUseOverallDetailSearchTime = 0x15c // bool (Size: 0x1)
SGCharacterInventorySearchComponent.DetailSearchTime = 0x160 // FVector2D (Size: 0x8)
SGCharacterInventorySearchComponent.RarityToDetailSearchTime = 0x168 // TMap<...> (Size: 0x50)
SGCharacterInventorySearchComponent.DetailSearchTimeWeapon = 0x1b8 // TMap<...> (Size: 0x50)
SGCharacterInventorySearchComponent.DetailSearchTimeEquipment = 0x208 // TMap<...> (Size: 0x50)
SGCharacterInventorySearchComponent.DetailSearchTimeAttachment = 0x258 // TMap<...> (Size: 0x50)
SGCharacterInventorySearchComponent.CurrentLootingActor = 0x2a8 // Actor* (Size: 0x8)
SGCharacterLadderClimbData.bIsClimbing = 0x0 // bool (Size: 0x1)
SGCharacterLadderClimbData.bIsStartClimb = 0x1 // bool (Size: 0x1)
SGCharacterLadderClimbData.bIsClimbFinish = 0x2 // bool (Size: 0x1)
SGCharacterLadderClimbData.EnterType = 0x3 // EELadderClimbEnterType (Size: 0x1)
SGCharacterLadderClimbData.ExitType = 0x4 // EELadderClimbExitType (Size: 0x1)
SGCharacterLadderClimbData.ClimbLadder = 0x8 // Actor* (Size: 0x8)
SGCharacterLadderClimbData.OriginGravityScale = 0x10 // float (Size: 0x4)
SGCharacterLadderClimbData.TraceDistance = 0x14 // float (Size: 0x4)
SGCharacterLadderClimbData.StartClimbTime = 0x18 // float (Size: 0x4)
SGCharacterLadderClimbData.EndClimbTime = 0x1c // float (Size: 0x4)
SGCharacterLadderClimbData.LadderHalfHeight = 0x20 // float (Size: 0x4)
SGCharacterLadderClimbData.LeaveGroundDistance = 0x24 // float (Size: 0x4)
SGCharacterLadderClimbData.ClimbSpeed = 0x28 // float (Size: 0x4)
SGCharacterLeanWallComponent.CurrLeanAimRatio = 0x108 // float (Size: 0x4)
SGCharacterLeanWallComponent.CurrLeanAimYOffset = 0x10c // float (Size: 0x4)
SGCharacterLeanWallComponent.CurrLeanAimAngleOffset = 0x110 // float (Size: 0x4)
SGCharacterLeanWallComponent.HeadBoneName = 0x140 // FName (Size: 0x8)
SGCharacterLeanWallComponent.BlockByWall_AxisYDistance = 0x148 // float (Size: 0x4)
SGCharacterLeanWallComponent.BlockByWall_AxisXDistance = 0x14c // float (Size: 0x4)
SGCharacterLeanWallComponent.BoxTraceHeight = 0x150 // float (Size: 0x4)
SGCharacterLeanWallComponent.TraceCenterOffsetX = 0x154 // float (Size: 0x4)
SGCharacterLeanWallComponent.TraceCenterOffsetZ = 0x158 // float (Size: 0x4)
SGCharacterLeanWallComponent.NotLeaningTolerance = 0x164 // float (Size: 0x4)
SGCharacterLeanWallComponent.FPLeanParams = 0x168 // FCharacterLeanParams (Size: 0x28)
SGCharacterLeanWallComponent.StandLeanParams = 0x190 // FCharacterLeanParams (Size: 0x28)
SGCharacterLeanWallComponent.CrouchLeanParams = 0x1b8 // FCharacterLeanParams (Size: 0x28)
SGCharacterLeanWallComponent.CustomCurveFP = 0x1e0 // CurveFloat* (Size: 0x8)
SGCharacterLeanWallComponent.LeanAdditiveInterpSpeed = 0x1e8 // float (Size: 0x4)
SGCharacterLeanWallComponent.bBlockByWall_Left = 0x1f8 // bool (Size: 0x1)
SGCharacterLeanWallComponent.bBlockByWall_Right = 0x1f9 // bool (Size: 0x1)
SGCharacterLeanWallComponent.WeaponLeanAimType = 0x1fa // EEWeaponLeanAimType (Size: 0x1)
SGCharacterLeanWallComponent.LeanRate = 0x24c // float (Size: 0x4)
SGCharacterLeanWallComponent.LineLength = 0x254 // float (Size: 0x4)
SGCharacterLeanWallComponent.LineLifeTime = 0x258 // float (Size: 0x4)
SGCharacterLeanWallComponent.LineTickness = 0x25c // float (Size: 0x4)
SGCharacterLeanWallComponent.DepthPriority = 0x260 // uint32_t (Size: 0x4)
SGCharacterLeanWallComponent.bPersistentLines = 0x264 // bool (Size: 0x1)
SGCharacterLeanWallComponent.LeanStateChangeInterval = 0x268 // float (Size: 0x4)
SGCharacterLoadProtectComponent.bEnable = 0x100 // bool (Size: 0x1)
SGCharacterLoadProtectComponent.bIsProtect = 0x101 // bool (Size: 0x1)
SGCharacterLoadProtectComponent.bIsProtectWithoutHiding = 0x102 // bool (Size: 0x1)
SGCharacterLoadProtectComponent.ProtectCacheMap = 0x108 // TMap<...> (Size: 0x50)
SGCharacterLoadProtectComponent.HiddenInventoryMap = 0x158 // TMap<...> (Size: 0x50)
SGCharacterLoadProtectComponent.LoadProtectEndTime = 0x1a8 // float (Size: 0x4)
SGCharacterLobbySuperIdleAnimInstance.LocalProxy = 0x2c0 // FSGCharacterLobbySuperIdleAnimInstanceProxy (Size: 0x860)
SGCharacterLobbySuperIdleAnimInstance.CharacterAnimMontage_Male = 0xb20 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterLobbySuperIdleAnimInstance.WeaponAnimMontage_Male = 0xb30 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterLobbySuperIdleAnimInstance.CharacterAnimMontage_Female = 0xb40 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterLobbySuperIdleAnimInstance.WeaponAnimMontage_Female = 0xb50 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterLobbySuperIdleAnimInstance.LastCharacterAnimMontage = 0xb60 // AnimMontage* (Size: 0x8)
SGCharacterLobbySuperIdleAnimInstance.LastWeaponAnimMontage = 0xb68 // AnimMontage* (Size: 0x8)
SGCharacterLobbySuperIdleAnimInstance.CharacterOwner = 0xb78 // SGCharacter* (Size: 0x8)
SGCharacterLobbySuperIdleAnimInstance.Weapon = 0xb80 // SGWeapon* (Size: 0x8)
SGCharacterLocomotionAnimInstance.LocalProxy = 0x2c0 // FSGCharacterLocomotionAnimInstanceProxy (Size: 0xec0)
SGCharacterLocomotionAnimInstance.MainAnimInstance = 0x1180 // SGCharacterAnimInstance* (Size: 0x8)
SGCharacterLocomotionAnimInstance.Prone360IdleInterpSpeed_Moving = 0x1188 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.Prone360IdleInterpSpeed_Leave = 0x118c // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.Turn90YawThreshold_Stand = 0x1190 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.Turn90YawThreshold_Crouch = 0x1194 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.Turn90YawThreshold_Prone = 0x1198 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.Turn90YawThreshold_DBNO = 0x119c // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.TurnInPlaceBlendOutThreshold = 0x11a0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Stand_Sequence_1P = 0x11a8 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Crouch_Sequence_1P = 0x11d8 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Prone_Sequence_1P = 0x1208 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_DBNO_Sequence_1P = 0x1238 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Stand_Sequence_3P = 0x1268 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Crouch_Sequence_3P = 0x1298 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_Prone_Sequence_3P = 0x12c8 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.TurnInPlaceAnimation_DBNO_Sequence_3P = 0x12f8 // FSGTurnInPlaceAnimSequenceConfig (Size: 0x30)
SGCharacterLocomotionAnimInstance.bForce3PLocomotion = 0x1328 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.MovementStanceBufferSize = 0x132c // int32_t (Size: 0x4)
SGCharacterLocomotionAnimInstance.StandToCrouchBlender = 0x1330 // FSGOneWayBlend (Size: 0x38)
SGCharacterLocomotionAnimInstance.CrouchToStandBlender = 0x1368 // FSGOneWayBlend (Size: 0x38)
SGCharacterLocomotionAnimInstance.FixedMovingDirectionInterpSpeed = 0x13a0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.bEnableFixedMovingDirectionCompensation = 0x13a4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.MovingCardinalTPSelectionOffset = 0x13a8 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.MovingCardinalSelectionDeadZone = 0x13b0 // FVector4 (Size: 0x10)
SGCharacterLocomotionAnimInstance.MovingCardinalSelectionDeadZoneLyra = 0x13c0 // FVector4 (Size: 0x10)
SGCharacterLocomotionAnimInstance.MovingOrientationWarpingAngleInterpSpeed = 0x13d0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.MovingOrientationWarpingAngleClamp = 0x13d4 // FFloatRange (Size: 0x10)
SGCharacterLocomotionAnimInstance.bEnableMovingOrientationWarpingAngleClamp = 0x13e4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.bEnableMovingOrientationWarpingAngleCompensation = 0x13e5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.bUseLyraCardinalSelectionMethod = 0x13e6 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.MovingCardinalDirectionDef = 0x13f0 // FVector4 (Size: 0x10)
SGCharacterLocomotionAnimInstance.MovingForwardThreshold = 0x1400 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.LastPivotTimeInitValue = 0x1404 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.PivotBlendToCycleTime = 0x1408 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.SmoothLastUpdateLocalAccNormal2DInterpSpeed = 0x140c // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.EnterLandThreshold = 0x1410 // float (Size: 0x4)
SGCharacterLocomotionAnimInstance.bCurrentTransitionFinished = 0x1414 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstance.CharacterAnimationSetsClass = 0x1418 // ClassProperty (Size: 0x8)
SGCharacterLocomotionAnimInstance.PerWeaponAnimationSetsClass = 0x1420 // ClassProperty (Size: 0x8)
SGCharacterLocomotionAnimInstance.PerWeaponAnimationSetsClass_Left = 0x1428 // ClassProperty (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_Idle = 0x860 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Idle_FixUpRightHand = 0x868 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_Locomotion = 0x870 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_Locomotion_Type = 0x878 // EELocomotionType (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.Stand_Locomotion_HandSway = 0x880 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_WalkLocomotion = 0x888 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_RunLocomotion = 0x890 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_SprintLocomotion = 0x898 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_SprintLocomotion_Melee = 0x8a0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_SprintLocomotion_TacticalGear = 0x8a8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintAdditiveBS = 0x8b0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_Idle = 0x8b8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_Locomotion = 0x8c0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_WalkLocomotion = 0x8c8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_RunLocomotion = 0x8d0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_SprintLocomotion = 0x8d8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone_Idle = 0x8e0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone_Locomotion = 0x8e8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone_WalkLocomotion = 0x8f0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone_RunLocomotion = 0x8f8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone_SprintLocomotion = 0x900 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNO_Idle = 0x908 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNO_Locomotion = 0x910 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNO_WalkLocomotion = 0x918 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNO_RunLocomotion = 0x920 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNO_SprintLocomotion = 0x928 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Current_Idle = 0x930 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.TransitionAnimationSet = 0x938 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.StandToCrouch = 0x940 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.StandToProne = 0x948 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.StandToProneBS = 0x950 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CrouchToProneBS = 0x958 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunToSprint = 0x960 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToRun = 0x968 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunToSprintRight = 0x970 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToRunRight = 0x978 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToProne = 0x980 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CrouchToStand = 0x988 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CrouchToProne = 0x990 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.ProneToStand = 0x998 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.ProneToCrouch = 0x9a0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.StandToDBNO = 0x9a8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToDBNO = 0x9b0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CrouchToDBNO = 0x9b8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.ProneToDBNO = 0x9c0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNOToCrouch = 0x9c8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DBNOToProne = 0x9d0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.StandToSprint = 0x9d8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToStand = 0x9e0 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToCrouch = 0x9e8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.JumpStart = 0x9f0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.JumpLoop = 0x9f8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.JumpEnd = 0xa00 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunJumpStart = 0xa08 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunJumpLoop = 0xa10 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunJumpEnd = 0xa18 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.JumpHighEnd = 0xa20 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunJumpHighEnd = 0xa28 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.PreJump = 0xa30 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintJumpStart = 0xa38 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintJumpLoop = 0xa40 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintJumpEnd = 0xa48 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToRunJumpEnd = 0xa50 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunToIdleJumpEnd = 0xa58 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintToIdleJumpEnd = 0xa60 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DeathAnim = 0xa68 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DiveStart = 0xa70 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DiveLoop = 0xa78 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DiveEnd = 0xa80 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stance = 0xa88 // EEAnimStance (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.WeaponStance = 0xa89 // EEWeaponType (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSprintingLastTime = 0xa8a // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSprintingLastUpdate = 0xa8b // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.CharacterSex = 0xa8c // EECharacterSex (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsViewTargetLocomotion = 0xa8d // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIs1P = 0xa8e // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.IdleBreathAlpha = 0xa90 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIs1PAiming = 0xa94 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIs1PTacticalPistolAiming = 0xa98 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bLastLocationChanged = 0xa9c // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bStanceChangedThisFrame = 0xa9d // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.GroundDistance = 0xaa0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsAiming = 0xaa4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsAimingLastUpdate = 0xaa5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsScoping = 0xaa6 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSprintingLastTime_3P = 0xaa7 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsCrouchAndNotDBNO = 0xaa8 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsProneAndNotDBNO = 0xaa9 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bFootRFrontWhenSprintChange = 0xaaa // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsMovingOnGroundAndSprinting = 0xaab // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsMovingOnGroundAndSprintJumping = 0xaac // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bAnimStanceTransitionInvalid1P = 0xaad // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bAnimStanceTransitionInvalid3P = 0xaae // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bStandToCrouchTransitionBlendOut = 0xaaf // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bCrouchToStandTransitionBlendOut = 0xab0 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsStand = 0xab1 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsCasual = 0xab2 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsCrouch = 0xab3 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsProne = 0xab4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsDBNO = 0xab5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.PronePlayRate = 0xab8 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsMoving = 0xabc // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bProneChangeThisFrame = 0xabd // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bWasMovingLastUpdate = 0xabe // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSilentWalk = 0xabf // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsMovingForward = 0xac0 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsMovingOnGround = 0xac1 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSprinting = 0xac2 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.MovementStance = 0xac4 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsUsingItem = 0xac8 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithGun = 0xac9 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithoutGun = 0xaca // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithThrown = 0xacb // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithTacticalGear = 0xacc // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithMelee = 0xacd // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithMainWeapon = 0xace // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithAssistWeapon = 0xacf // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsArmedWithDualHandWeapon = 0xad0 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bInTacticalState = 0xad1 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bNotInTacticalState = 0xad2 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.TacticalWeapon = 0xad8 // SGWeapon* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.WeaponForLocomotion = 0xae0 // SGWeapon* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.LocomotionWeaponStance = 0xae8 // EELocomotionWeaponStance (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsJumping = 0xae9 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsSprintJumping = 0xaea // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsRunJumping = 0xaeb // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsFalling = 0xaec // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.FallingAnimType = 0xaf0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsInAir = 0xaf4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsInAirChangeThisFrame = 0xaf5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.WorldRotation = 0xaf8 // FRotator (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.Acceleration = 0xb04 // FVector (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.LocalAcceleration2DNormalized = 0xb10 // FVector (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.Velocity = 0xb1c // FVector (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.bIsRunningIntoWall = 0xb28 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bAccelerationOpposeVelocity = 0xb29 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.CurrentFloorSlopeWitnRootQuat = 0xb2c // FRotator (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.MovementPlayRate = 0xb38 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovementStartPosition = 0xb3c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovementSpeedWarping = 0xb40 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.DirectionBeforStop = 0xb44 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsNotMoving = 0xb48 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsNotSprinting = 0xb49 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsNotInAir = 0xb4a // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bEnableSliding = 0xb4b // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsChangeActorRotation = 0xb4c // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bTurnLeft = 0xb4d // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bEnableTeleportTurnAnimation = 0xb4e // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceMaxThreshold = 0xb50 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsDiving = 0xb54 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsDiveEnd = 0xb55 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bStopDiveEnd = 0xb56 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsDivingOrProne = 0xb57 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsDivingOrFullyProne = 0xb58 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.IsTransToProne = 0xb5c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsPreJump = 0xb60 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsNoneJumpState = 0xb61 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bIsPreJumpAnimValid = 0xb62 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bCanEnterPreJumpState = 0xb63 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bNearlyMovingForward = 0xb64 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bCanAnimStanceTransitionBlendOut = 0xb65 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bCanProneToCrouchBlendOut = 0xb66 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bSprintToRunBlendToRun = 0xb67 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.MovingDirection = 0xb68 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingDirectionWithOffset = 0xb6c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingDirectionClamped = 0xb70 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingDirectionCompensation = 0xb74 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingDirectionOrientationWarpCopyBoneAlpha = 0xb78 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.CurrentMovingCardinalTP = 0xb7c // int32_t (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.CurrentMovingOrientationWarpingAngle = 0xb80 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.SmoothedMovingOrientationWarpingAngle = 0xb84 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStartOrientationWarpingAngle = 0xb88 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingDirectionByCardinalTP = 0xb8c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceAnimationSequence = 0xb90 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceAnimationTime = 0xb98 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.RootBoneRotationYaw = 0xb9c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.NegRootBoneRotationYaw = 0xba0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.TurnYawWeight = 0xba4 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceState = 0xba8 // EETurnInPlaceState (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.RootYawOffsetMode = 0xba9 // EERootYawOffsetMode (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldTurnInIdle = 0xbaa // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldTurnInPlace = 0xbab // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldTurnInPlaceRecvoery = 0xbac // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.SGAnimInstance = 0xbb0 // SGCharacterLocomotionAnimInstance* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SGMainAnimInstance = 0xbb8 // SGCharacterAnimInstance* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SGCharacter = 0xbc0 // SGCharacter* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SGWeapon = 0xbc8 // SGWeapon* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.bIsWeaponChange = 0xbd0 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bHasTransition = 0xbd1 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.TransitionType = 0xbd4 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bHasAnimStanceTransition = 0xbd8 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.AnimStanceTransitionType = 0xbdc // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.StandToProneTransitionType = 0xbe0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bSprintToProne = 0xbe4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.SprintToCrouchTransitionType = 0xbe8 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bIsSprintToCrouch = 0xbec // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.SprintTransitionOutPlayRate = 0xbf0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovementStanceRingBuffer = 0xbf8 // TArray<EEMovementStance> (Size: 0x10)
SGCharacterLocomotionAnimInstanceProxy.CopyPoseFrom = 0xc10 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.FixedMovingDirection = 0xc18 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.FixedMovingDirectionPositive = 0xc1c // int32_t (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.FixedMovingDirectionWithOffset = 0xc20 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.SmoothedFixedMovingDirection = 0xc24 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.Stand_MovingStartBS = 0xc38 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_MovingStartBS = 0xc40 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_MovingStopBS = 0xc48 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_MovingStopBS_L = 0xc50 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_MovingStopBS_R = 0xc58 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_MovingStopBS = 0xc60 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_MovingStopBS_L = 0xc68 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_MovingStopBS_R = 0xc70 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.DestMovingStopBS = 0xc78 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Stand_MovingPivotBS = 0xc80 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Crouch_MovingPivotBS = 0xc88 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.MovingStartAnimSeq = 0xc90 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.MovingStopAnimSeq = 0xc98 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.bShouldMovingStart = 0xca0 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldJumpToMoving = 0xca1 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.MovingStartAnimSeq_Stand = 0xca8 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStartTime_Stand = 0xcb0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStartAnimSeq_Crouch = 0xcb8 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStartTime_Crouch = 0xcc0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStopAnimSeq_Stand = 0xcc8 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStopTime_Stand = 0xcd0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStopAnimSeq_Crouch = 0xcd8 // AnimSequenceBase* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStopTime_Crouch = 0xce0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bShouldJumpToMovingFast = 0xce4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldMovingStop = 0xce5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldJumpToIdle = 0xce6 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldJumpToStop = 0xce7 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bPivot = 0xce8 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bPostPivot = 0xce9 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStartTime = 0xcec // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStartNormalizeTime = 0xcf0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.AnimSeqMovingStopTime = 0xcf4 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStopNormalizeTime = 0xcf8 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStopDirection = 0xcfc // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingPivotNormalizeTime = 0xd00 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingPivotDirection = 0xd04 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStartNormalizeSpeed = 0xd08 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.MovingStopNormalizeSpeed = 0xd0c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bMovingStartInvalid = 0xd10 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bMovingStopInvalid = 0xd11 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.RootYawOffset = 0xd4c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceAnimTime = 0xd50 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.TurnInPlaceAnimSequence = 0xd58 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.bTurnInPlaceIdle = 0xd60 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bTurnInPlaceRotation = 0xd61 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bTurnInPlaceRecovery = 0xd62 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.OrientationWarpingAngle = 0xd64 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bProne360AnimEnabled = 0xd70 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.Prone360LocomotionByAngle = 0xd78 // TArray<FSGProne360BlendSpace> (Size: 0x10)
SGCharacterLocomotionAnimInstanceProxy.Prone360ToStandByAngle = 0xd88 // TArray<FSGProne360Sequence> (Size: 0x10)
SGCharacterLocomotionAnimInstanceProxy.Prone360ToCrouchByAngle = 0xd98 // TArray<FSGProne360Sequence> (Size: 0x10)
SGCharacterLocomotionAnimInstanceProxy.Prone360Locomotion = 0xda8 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone360LocomotionAngle = 0xdb0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.Prone360IdleAnimAdditive = 0xdb8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.Prone360IdleAnimAdditiveLength = 0xdc0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.Prone360IdleAnimAdditiveCurrentTime = 0xdc4 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.Dive360AnimAdditive = 0xdc8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CurrentProne360ToStand = 0xdd0 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CurrentProne360ToCrouch = 0xdd8 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.LeaveProne360AnimAngle = 0xde0 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bMovingPerpendicularToInitialPivot = 0xde4 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bCanEnterPivotState = 0xde5 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bPivotBlendToStop = 0xde6 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bPivotBlendToCycle = 0xde7 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bPivotBlendToCycleDueToStanceChange = 0xde8 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.bShouldSwitchPivotState = 0xde9 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.PivotStartingAcceleration = 0xdec // FVector (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.TimeAtPivotStop = 0xdf8 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.LastPivotTime = 0xdfc // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.PivotAnimSequenceA = 0xe00 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.PivotAnimSequenceB = 0xe08 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.PivotAnimSequenceLength = 0xe10 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.PivotSequencePlayerATime = 0xe14 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.PivotSequencePlayerBTime = 0xe18 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bUsePivotStateMachineA = 0xe1c // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.SmoothLastUpdateLocalAccNormal2D = 0xe20 // FVector (Size: 0xc)
SGCharacterLocomotionAnimInstanceProxy.JumpLand = 0xe58 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.RunJumpLand = 0xe60 // BlendSpace* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.SprintJumpLand = 0xe68 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.JumpLandAnimation = 0xe70 // AnimSequence* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.LandAnimPosition = 0xe78 // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.LandAnimNormalizedTime = 0xe7c // float (Size: 0x4)
SGCharacterLocomotionAnimInstanceProxy.bCanEnterLand = 0xe80 // bool (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.CurrentCharacterAnimationSetsPerCharacterSex = 0xe88 // SGCharacterAnimationSetsPerCharacterSex* (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CurrentPerWeaponAnimationSetsClass = 0xe90 // ClassProperty (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.CurrentPerWeaponAnimationSetsClass_Left = 0xe98 // ClassProperty (Size: 0x8)
SGCharacterLocomotionAnimInstanceProxy.FromMovementStance = 0xea0 // EEMovementStance (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.ToMovementStance = 0xea1 // EEMovementStance (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.FromAnimStance = 0xea2 // EEAnimStance (Size: 0x1)
SGCharacterLocomotionAnimInstanceProxy.ToAnimStance = 0xea3 // EEAnimStance (Size: 0x1)
SGCharacterLookAroundComponent.LookAroundXSensitivity = 0x100 // float (Size: 0x4)
SGCharacterLookAroundComponent.LookAroundYSensitivity = 0x104 // float (Size: 0x4)
SGCharacterLookAroundComponent.MaxLookAroundYaw = 0x108 // float (Size: 0x4)
SGCharacterLookAroundComponent.MinLookAroundYaw = 0x10c // float (Size: 0x4)
SGCharacterLookAroundComponent.MaxLookAroundPitch = 0x110 // float (Size: 0x4)
SGCharacterLookAroundComponent.MinLookAroundPitch = 0x114 // float (Size: 0x4)
SGCharacterLookAroundComponent.PitchOffsetInterpSpeed = 0x118 // float (Size: 0x4)
SGCharacterLookAroundComponent.YawOffsetInterpSpeed = 0x11c // float (Size: 0x4)
SGCharacterLookAroundComponent.UpperarmL_OffsetRatio = 0x120 // float (Size: 0x4)
SGCharacterLookAroundComponent.UpperarmLMiddleSlider1_OffsetRatio = 0x124 // float (Size: 0x4)
SGCharacterLookAroundComponent.LookAroundBlockTags = 0x128 // FGameplayTagContainer (Size: 0x20)
SGCharacterLookAroundComponent.CurrentLookAroundOffset = 0x148 // FRotator (Size: 0xc)
SGCharacterLookAroundComponent.bLookAroundEnabled = 0x154 // bool (Size: 0x1)
SGCharacterMeshComponent.HeadBoneName = 0x108 // FName (Size: 0x8)
SGCharacterMeshComponent.PelvisBoneName = 0x110 // FName (Size: 0x8)
SGCharacterMeshComponent.SpineBoneName = 0x118 // FName (Size: 0x8)
SGCharacterMeshComponent.FPPHiddenBones = 0x120 // TArray<FName> (Size: 0x10)
SGCharacterMeshComponent.DeadBodyMeshDrawDistance = 0x130 // float (Size: 0x4)
SGCharacterMeshComponent.bEnableVisiualMeshLODs = 0x140 // bool (Size: 0x1)
SGCharacterMeshComponent.ReticleTargetActor = 0x148 // Character* (Size: 0x8)
SGCharacterMeshComponent.MessageIndex = 0x150 // uint64_t (Size: 0x8)
SGCharacterMeshComponent.CharacterTrisCount = 0x158 // uint32_t (Size: 0x4)
SGCharacterMeshComponent.WeaponTrisCount = 0x15c // uint32_t (Size: 0x4)
SGCharacterMeshComponent.CachedHeadInventory = 0x160 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedHairInventory = 0x168 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedChestHangingInventory = 0x170 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedArmorInventory = 0x178 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedTorsoInventory = 0x180 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedLegInventory = 0x188 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedShoeInventory = 0x190 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedGloveInventory = 0x198 // SGInventory* (Size: 0x8)
SGCharacterMeshComponent.CachedHeadAvatarID = 0x1a0 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedHairAvatarID = 0x1a8 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedChestHangingAvatarID = 0x1b0 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedTorsoAvatarID = 0x1b8 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedLegAvatarID = 0x1c0 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedShoeAvatarID = 0x1c8 // int64_t (Size: 0x8)
SGCharacterMeshComponent.CachedGloveAvatarID = 0x1d0 // int64_t (Size: 0x8)
SGCharacterMeshComponent.ConfigTinyAvatarInventory = 0x1d8 // TMap<...> (Size: 0x50)
SGCharacterMeshComponent.ConfigTinyAvatarID = 0x228 // TMap<...> (Size: 0x50)
SGCharacterMeshComponent.SpecificCharacterMeshPolicy = 0x280 // EECharacterMeshPolicy (Size: 0x1)
SGCharacterMeshComponent.SimpleMesh_Male = 0x288 // SkeletalMesh* (Size: 0x8)
SGCharacterMeshComponent.SimpleMesh_Male_Lobby = 0x290 // SkeletalMesh* (Size: 0x8)
SGCharacterMeshComponent.SimpleMesh_Female_Game = 0x298 // SkeletalMesh* (Size: 0x8)
SGCharacterMeshComponent.SimpleMesh_Female_Lobby = 0x2a0 // SkeletalMesh* (Size: 0x8)
SGCharacterMeshComponent.SimpleMeshs_ForTest = 0x2a8 // TArray<SkeletalMesh*> (Size: 0x10)
SGCharacterMeshComponent.AvatarIdGroup_Female = 0x2b8 // TArray<int32_t> (Size: 0x10)
SGCharacterMeshComponent.DynamicLoadMeshTemplate = 0x2c8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGCharacterMeshComponent.DynamicLoadAvatarInventories = 0x2f0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGCharacterMeshComponent.DynamicLoadAnimClass = 0x300 // TSoftClassPtr<UObject> (Size: 0x28)
SGCharacterMoistureAttributeSet.Moisture = 0x48 // float (Size: 0x4)
SGCharacterMoistureAttributeSet.MoistureMax = 0x4c // float (Size: 0x4)
SGCharacterMoistureComponent.LackInMoistureAbilityClass = 0x100 // ClassProperty (Size: 0x8)
SGCharacterMoistureComponent.GalleryBuffIdList = 0x110 // TMap<...> (Size: 0x50)
SGCharacterMoistureComponent.ReduceScaleForGalleryLevel1 = 0x160 // float (Size: 0x4)
SGCharacterMoistureComponent.ReduceScaleForGalleryLevel2 = 0x164 // float (Size: 0x4)
SGCharacterMoistureComponent.GalleryLevel1GameplayEffect = 0x168 // ClassProperty (Size: 0x8)
SGCharacterMoistureComponent.GalleryLevel2GameplayEffect = 0x170 // ClassProperty (Size: 0x8)
SGCharacterMoistureComponent.AutoReducedAbilityClass = 0x180 // ClassProperty (Size: 0x8)
SGCharacterMoistureComponent.AttributeSetClass = 0x198 // ClassProperty (Size: 0x8)
SGCharacterMoveBlockedAvoidanceComponent.bEnableMoveBlockedAvoidance = 0x100 // bool (Size: 0x1)
SGCharacterMoveBlockedAvoidanceComponent.bMoveBlockedCurrentFrame = 0x101 // bool (Size: 0x1)
SGCharacterMoveBlockedAvoidanceComponent.MoveBlockedTimeToTriggerAvoidance = 0x104 // float (Size: 0x4)
SGCharacterMoveBlockedAvoidanceComponent.MoveBlockedEcpliseTime = 0x108 // float (Size: 0x4)
SGCharacterMoveBlockedAvoidanceComponent.IgnoreActorWhenMoving = 0x110 // Actor* (Size: 0x8)
SGCharacterMoveBlockedAvoidanceComponent.ResolvePenetrationVelocity = 0x118 // float (Size: 0x4)
SGCharacterMoveBlockedAvoidanceComponent.BlockedByCharacterOnClientMaxDistance = 0x11c // float (Size: 0x4)
SGCharacterMoveBlockedAvoidanceComponent.CachedBlockingCharacter = 0x120 // SGCharacter* (Size: 0x8)
SGCharacterMoveBlockedAvoidanceComponent.LastBlockActor = 0x130 // SGCharacter* (Size: 0x8)
SGCharacterMovementAbilityComponent.AttributeSetClass = 0x100 // ClassProperty (Size: 0x8)
SGCharacterMovementAbilityComponent.MinSpeedScaleByBuff = 0x108 // float (Size: 0x4)
SGCharacterMovementAbilityComponent.MaxSpeedScaleByBuff = 0x10c // float (Size: 0x4)
SGCharacterMovementAbilityComponent.PunishMoveTime_NoPenetrate = 0x110 // float (Size: 0x4)
SGCharacterMovementAbilityComponent.PunishMoveScale_NoPenetrate = 0x114 // float (Size: 0x4)
SGCharacterMovementAbilityComponent.PunishMoveTime_Penetrate = 0x118 // float (Size: 0x4)
SGCharacterMovementAbilityComponent.PunishMoveScale_Penetrate = 0x11c // float (Size: 0x4)
SGCharacterMovementAbilityComponent.Temp_PunishMoveTime_Penetrate = 0x120 // float (Size: 0x4)
SGCharacterMovementAbilityComponent.Temp_PunishMoveTime_NoPenetrate = 0x124 // float (Size: 0x4)
SGCharacterMovementAttributeSet.MovementSpeedScaleAdder = 0x48 // float (Size: 0x4)
SGCharacterMovementAttributeSet.MovementForbiddenMultiplier = 0x4c // float (Size: 0x4)
SGCharacterMovementAttributeSet.MovementSpeedScaleWhenLegOutofEnduranceAdder = 0x50 // float (Size: 0x4)
SGCharacterMovementAttributeSet.JumpZVelocityScaleMultiplier = 0x54 // float (Size: 0x4)
SGCharacterMovementAttributeSet.JumpXYVelocityScaleMultiplier = 0x58 // float (Size: 0x4)
SGCharacterMovementAttributeSet.ForbiddenJumpMultiplier = 0x60 // FGameplayAttributeData (Size: 0x10)
SGCharacterMovementAttributeSet.ForbiddenVaultMultiplier = 0x70 // float (Size: 0x4)
SGCharacterMovementAttributeSet.ForbiddenSprintMultiplier = 0x74 // float (Size: 0x4)
SGCharacterMovementAttributeSet.ForbiddenTakeCoverMultiplier = 0x78 // float (Size: 0x4)
SGCharacterMovementAttributeSet.ForbiddenProneMultiplier = 0x7c // float (Size: 0x4)
SGCharacterMovementAttributeSet.ForbiddenWeaponStateMultiplier = 0x80 // float (Size: 0x4)
SGCharacterMovementAttributeSet.InstantMovementSpeedScale = 0x84 // float (Size: 0x4)
SGCharacterMovementAttributeSet.InstantJumpZVelocityScale = 0x88 // float (Size: 0x4)
SGCharacterMovementAttributeSet.SearchScaleMultiplier = 0x8c // float (Size: 0x4)
SGCharacterMovementAttributeSet.MovementSpeedScaleWhenBothLegsOutofEndurance = 0x90 // float (Size: 0x4)
SGCharacterMovementAttributeSet.DiveXYVelocityAdder = 0x94 // float (Size: 0x4)
SGCharacterMovementAttributeSet.DiveZVelocityAdder = 0x98 // float (Size: 0x4)
SGCharacterMovementAttributeSet.SlideXYVelocityAdder = 0x9c // float (Size: 0x4)
SGCharacterMovementAttributeSet.DiveLandBrakingDecAdder = 0xa0 // float (Size: 0x4)
SGCharacterMovementComponent.bWantsToProne = 0xca0 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToDBNO = 0xca1 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToSprint = 0xca2 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToSilentWalk = 0xca3 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToAim = 0xca4 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToHoldBreath = 0xca5 // bool (Size: 0x1)
SGCharacterMovementComponent.bWantsToDive = 0xca6 // bool (Size: 0x1)
SGCharacterMovementComponent.bJumpCoolDown = 0xca8 // bool (Size: 0x1)
SGCharacterMovementComponent.AccelerationCurve = 0xcb0 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.AcceWeightScaleCurve = 0xcb8 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.LocomotionAnimIstanceTag = 0xcc4 // FName (Size: 0x8)
SGCharacterMovementComponent.BaseLocomotionStateMachineName = 0xccc // FName (Size: 0x8)
SGCharacterMovementComponent.StandToProneStateName = 0xcd4 // FName (Size: 0x8)
SGCharacterMovementComponent.bSilentWalk = 0xce8 // bool (Size: 0x1)
SGCharacterMovementComponent.JumpCoolDownTime = 0xcec // float (Size: 0x4)
SGCharacterMovementComponent.NeedAddJumpCoolDown = 0xcf0 // float (Size: 0x4)
SGCharacterMovementComponent.bHiSpeedFall = 0xcf5 // bool (Size: 0x1)
SGCharacterMovementComponent.HeaveLandSpeed = 0xcf8 // float (Size: 0x4)
SGCharacterMovementComponent.HeaveLandMaxSpeed = 0xcfc // float (Size: 0x4)
SGCharacterMovementComponent.HeavyLandingEffect = 0xd00 // ClassProperty (Size: 0x8)
SGCharacterMovementComponent.JumpCoolDownCurveBySpeed = 0xd08 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.Trap = 0xd20 // SGTrapComponent* (Size: 0x8)
SGCharacterMovementComponent.FireComp = 0xd28 // SGFireTrapComponent* (Size: 0x8)
SGCharacterMovementComponent.PhyscisAsset = 0xd30 // PhysicsAsset* (Size: 0x8)
SGCharacterMovementComponent.SGCharacterOwner = 0xe88 // SGCharacter* (Size: 0x8)
SGCharacterMovementComponent.UnCrouchBeEncroached = 0xe90 // bool (Size: 0x1)
SGCharacterMovementComponent.UnProneBeEncroached = 0xe91 // bool (Size: 0x1)
SGCharacterMovementComponent.StandMinCharacterMovementSpeed = 0xe9c // float (Size: 0x4)
SGCharacterMovementComponent.CrouchMinCharacterMovementSpeed = 0xea0 // float (Size: 0x4)
SGCharacterMovementComponent.ProneMinCharacterMovementSpeed = 0xea4 // float (Size: 0x4)
SGCharacterMovementComponent.DBNOMinCharacterMovementSpeed = 0xea8 // float (Size: 0x4)
SGCharacterMovementComponent.SwitchToProneMaxSpeed = 0xeac // float (Size: 0x4)
SGCharacterMovementComponent.MaxCharacterMovementSpeed = 0xeb0 // float (Size: 0x4)
SGCharacterMovementComponent.AccelerationOnAngle = 0xeb8 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.BrakingDecelerationOnAngle = 0xf40 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.StandRunSpeedOnAngle = 0xfc8 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.CrouchSpeedOnAngle = 0x1050 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.ProneSpeedOnAngle = 0x10d8 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.DBNOSpeedOnAngle = 0x1160 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.StandSprintSpeedScale = 0x11e8 // float (Size: 0x4)
SGCharacterMovementComponent.StandSprintExhaustedSpeedScale = 0x11ec // float (Size: 0x4)
SGCharacterMovementComponent.StandSprintSpeedScaleDoingWeaponOperation = 0x11f0 // float (Size: 0x4)
SGCharacterMovementComponent.SprintAccelerationOnAngle = 0x11f8 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterMovementComponent.StandSilentWalkSpeedScale = 0x1280 // float (Size: 0x4)
SGCharacterMovementComponent.StandLeanWalkSpeedScale = 0x1284 // float (Size: 0x4)
SGCharacterMovementComponent.CrouchSprintSpeedScale = 0x1288 // float (Size: 0x4)
SGCharacterMovementComponent.CrouchSprintExhaustedSpeedScale = 0x128c // float (Size: 0x4)
SGCharacterMovementComponent.CrouchSilentWalkSpeedScale = 0x1290 // float (Size: 0x4)
SGCharacterMovementComponent.CrouchLeanWalkSpeedScale = 0x1294 // float (Size: 0x4)
SGCharacterMovementComponent.ProneSilentWalkSpeedScale = 0x1298 // float (Size: 0x4)
SGCharacterMovementComponent.ProneLeanWalkSpeedScale = 0x129c // float (Size: 0x4)
SGCharacterMovementComponent.bCanWalkOffLedgesWhenProne = 0x12a0 // uint8_t (Size: 0x1)
SGCharacterMovementComponent.bCanWalkOffLedgesWhenDBNO = 0x12a0 // uint8_t (Size: 0x1)
SGCharacterMovementComponent.SpeedWarping_Scaler_Normal = 0x12a4 // float (Size: 0x4)
SGCharacterMovementComponent.SpeedWarping_Scaler_ADS_1P = 0x12a8 // float (Size: 0x4)
SGCharacterMovementComponent.SpeedWarping_Scaler_ADS = 0x12ac // float (Size: 0x4)
SGCharacterMovementComponent.SpeedWarping_Scaler_OutOfEndurance = 0x12b0 // float (Size: 0x4)
SGCharacterMovementComponent.ClientAuthorityMaxSpeedExceedScale = 0x12b4 // float (Size: 0x4)
SGCharacterMovementComponent.ClientAuthorityMaxZDiffPerSecond = 0x12b8 // float (Size: 0x4)
SGCharacterMovementComponent.ClientAuthorityMaxZDiffPerSecondWhenVault = 0x12bc // float (Size: 0x4)
SGCharacterMovementComponent.ServerMaxSpeedInCurrentMovePack = 0x12d0 // float (Size: 0x4)
SGCharacterMovementComponent.TempClientMaxSpeed = 0x12d4 // float (Size: 0x4)
SGCharacterMovementComponent.TotalDeltaTimeInCurrentMovePack = 0x12d8 // float (Size: 0x4)
SGCharacterMovementComponent.ServerLocAfterLastMovePackProcessed = 0x12dc // FVector (Size: 0xc)
SGCharacterMovementComponent.ServerTimeStampAfterLastMovePackProcessed = 0x12e8 // float (Size: 0x4)
SGCharacterMovementComponent.MaxPositionErrorScaleDecreaseSpeed = 0x12ec // float (Size: 0x4)
SGCharacterMovementComponent.MaxPositionErrorScale = 0x12f0 // float (Size: 0x4)
SGCharacterMovementComponent.MaxPositionErrorScale_Min = 0x12f4 // float (Size: 0x4)
SGCharacterMovementComponent.StuckAccumulateMaxTime = 0x12f8 // float (Size: 0x4)
SGCharacterMovementComponent.StandCollisionRadius = 0x130c // float (Size: 0x4)
SGCharacterMovementComponent.bUseInputAixCheckMoveForward = 0x1310 // bool (Size: 0x1)
SGCharacterMovementComponent.fTimerRate = 0x1320 // float (Size: 0x4)
SGCharacterMovementComponent.CharacterMoveDistances = 0x1328 // TMap<...> (Size: 0x50)
SGCharacterMovementComponent.GetGroundInfoTraceDistance = 0x1378 // float (Size: 0x4)
SGCharacterMovementComponent.GetOutRecordLocationThresholdSquare = 0x1428 // float (Size: 0x4)
SGCharacterMovementComponent.GetOutPastLocationRecordNum = 0x142c // int32_t (Size: 0x4)
SGCharacterMovementComponent.GetOutPastLocationRecords = 0x1430 // TArray<FVector> (Size: 0x10)
SGCharacterMovementComponent.LastWalkableMovementBase = 0x1440 // PrimitiveComponent* (Size: 0x8)
SGCharacterMovementComponent.bPlayAnim = 0x1480 // bool (Size: 0x1)
SGCharacterMovementComponent.ResetServerVelocityTime = 0x1490 // float (Size: 0x4)
SGCharacterMovementComponent.ReportMoveLossThreshold = 0x1494 // float (Size: 0x4)
SGCharacterMovementComponent.BlockAllowableVelocityXYCheckTags = 0x1508 // FGameplayTagContainer (Size: 0x20)
SGCharacterMovementComponent.bEnableDCLocomotion = 0x1550 // bool (Size: 0x1)
SGCharacterMovementComponent.PredictSimulationIterations = 0x1554 // int32_t (Size: 0x4)
SGCharacterMovementComponent.bEnableDCLocomotionLOD = 0x1558 // bool (Size: 0x1)
SGCharacterMovementComponent.DCLocomotionDistance = 0x155c // float (Size: 0x4)
SGCharacterMovementComponent.PredictStopLocation = 0x1560 // FVector (Size: 0xc)
SGCharacterMovementComponent.ForcePositionUpdateCount = 0x156c // int32_t (Size: 0x4)
SGCharacterMovementComponent.bStopMovingOnForcePositionUpdate = 0x1570 // bool (Size: 0x1)
SGCharacterMovementComponent.MovingStartLocation = 0x1574 // FVector (Size: 0xc)
SGCharacterMovementComponent.AnimSpeedConfig = 0x1598 // TMap<...> (Size: 0x50)
SGCharacterMovementComponent.WalkingLowSpeed = 0x15e8 // float (Size: 0x4)
SGCharacterMovementComponent.bEnableCheckUpdateComponent = 0x1600 // bool (Size: 0x1)
SGCharacterMovementComponent.ProneCheckZOffset = 0x1604 // float (Size: 0x4)
SGCharacterMovementComponent.ProneCheckDistance = 0x1608 // float (Size: 0x4)
SGCharacterMovementComponent.ProneCheckRadius = 0x160c // float (Size: 0x4)
SGCharacterMovementComponent.ExtraPositionRateScaleWhenWantsToVault = 0x1614 // float (Size: 0x4)
SGCharacterMovementComponent.GroundLeanInterpSpeed = 0x1620 // float (Size: 0x4)
SGCharacterMovementComponent.GroundLeanBrakeFactor = 0x1624 // float (Size: 0x4)
SGCharacterMovementComponent.GroundLeanAmplifyCurve = 0x1628 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.SmoothLastUpdateVelocityInterpSpeed = 0x1630 // float (Size: 0x4)
SGCharacterMovementComponent.ProneBrakingDuration = 0x166c // float (Size: 0x4)
SGCharacterMovementComponent.ProneBrakingFriction = 0x1670 // float (Size: 0x4)
SGCharacterMovementComponent.ProneBrakingDeceleration = 0x1674 // float (Size: 0x4)
SGCharacterMovementComponent.CrouchBrakingDuration = 0x1678 // float (Size: 0x4)
SGCharacterMovementComponent.CrouchBrakingFriction = 0x167c // float (Size: 0x4)
SGCharacterMovementComponent.CrouchBrakingDeceleration = 0x1680 // float (Size: 0x4)
SGCharacterMovementComponent.SlidingDistance = 0x1684 // float (Size: 0x4)
SGCharacterMovementComponent.bEnableSliding = 0x1688 // bool (Size: 0x1)
SGCharacterMovementComponent.DivingBrakingFriction = 0x168c // float (Size: 0x4)
SGCharacterMovementComponent.DivingBrakingDeceleration = 0x1690 // float (Size: 0x4)
SGCharacterMovementComponent.DiveLandBrakingDuration = 0x1694 // float (Size: 0x4)
SGCharacterMovementComponent.DiveLandBrakingFriction = 0x1698 // float (Size: 0x4)
SGCharacterMovementComponent.DiveLandBrakingDeceleration = 0x169c // float (Size: 0x4)
SGCharacterMovementComponent.SlidingFriction = 0x16a0 // float (Size: 0x4)
SGCharacterMovementComponent.SlidingDeceleration = 0x16a4 // float (Size: 0x4)
SGCharacterMovementComponent.SlidingDuration = 0x16a8 // float (Size: 0x4)
SGCharacterMovementComponent.SlidingBrakeFriction = 0x16ac // float (Size: 0x4)
SGCharacterMovementComponent.SlidingBrakeDeceleration = 0x16b0 // float (Size: 0x4)
SGCharacterMovementComponent.SprintComponent = 0x16b8 // SGCharacterSprintComponent* (Size: 0x8)
SGCharacterMovementComponent.MovementProneComponent = 0x16c0 // SGCharacterMovementProneComponent* (Size: 0x8)
SGCharacterMovementComponent.MovementDBNOComponent = 0x16c8 // SGCharacterMovementDBNOComponent* (Size: 0x8)
SGCharacterMovementComponent.SoundComp = 0x16d0 // SGCharacterSoundComponent* (Size: 0x8)
SGCharacterMovementComponent.ReturnNavWalkingCheckInterval = 0x1984 // float (Size: 0x4)
SGCharacterMovementComponent.NearbyCharacterVelocityChanger = 0x1988 // Object* (Size: 0x8)
SGCharacterMovementComponent.CharacterAdditionalVelocity = 0x1990 // FVector (Size: 0xc)
SGCharacterMovementComponent.IsTemporaryFixFalloffFrictionWhenAdditionalVelocity = 0x199c // bool (Size: 0x1)
SGCharacterMovementComponent.TemporaryFixFalloffFrictionValue = 0x19a0 // float (Size: 0x4)
SGCharacterMovementComponent.TemporaryFixFalloffFrictionTime = 0x19a4 // float (Size: 0x4)
SGCharacterMovementComponent.LastFallLocation = 0x19b8 // FVector (Size: 0xc)
SGCharacterMovementComponent.FallProtectHandle = 0x19c8 // FTimerHandle (Size: 0x8)
SGCharacterMovementComponent.GameStrilessMoreThanTimeThreshold = 0x1a30 // float (Size: 0x4)
SGCharacterMovementComponent.CachedStatisComponent = 0x1a38 // SGPlayerStateStatisComponent* (Size: 0x8)
SGCharacterMovementComponent.MaxStuckInGeometryPopUpRadiusScaler = 0x1a5c // float (Size: 0x4)
SGCharacterMovementComponent.NotifyStuckInGeometryPopUpMessage = 0x1a68 // FString (Size: 0x10)
SGCharacterMovementComponent.Report_LargeLocSize3P = 0x1a78 // float (Size: 0x4)
SGCharacterMovementComponent.Report_LocFromPlayer = 0x1a7c // float (Size: 0x4)
SGCharacterMovementComponent.bEnableCorrectStance = 0x1a80 // bool (Size: 0x1)
SGCharacterMovementComponent.bCompleteCorrectStance = 0x1a81 // bool (Size: 0x1)
SGCharacterMovementComponent.bEnableFindFloorBetweenSteeps = 0x1a82 // bool (Size: 0x1)
SGCharacterMovementComponent.SampleBattleIntensityExpectationInterval = 0x1a88 // float (Size: 0x4)
SGCharacterMovementComponent.MovementLockType = 0x1a90 // int32_t (Size: 0x4)
SGCharacterMovementComponent.bAddDiveXYVelocity = 0x1a94 // bool (Size: 0x1)
SGCharacterMovementComponent.DiveZVelocity = 0x1a98 // float (Size: 0x4)
SGCharacterMovementComponent.DiveXYVelocity = 0x1a9c // float (Size: 0x4)
SGCharacterMovementComponent.MinSpeedToDive = 0x1aa0 // float (Size: 0x4)
SGCharacterMovementComponent.DivingMaxAcceleration = 0x1aa4 // float (Size: 0x4)
SGCharacterMovementComponent.WeightScaleClampMax = 0x1aa8 // float (Size: 0x4)
SGCharacterMovementComponent.DiveZWeightScaleCurve = 0x1ab0 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.DiveXYWeightScaleCurve = 0x1ab8 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.DiveLandBrakeWeightScaleCurve = 0x1ac0 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.DiveEndTimeWeightScaleCurve = 0x1ac8 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.bCanEverDive = 0x1ad0 // bool (Size: 0x1)
SGCharacterMovementComponent.ForbiddenDiveItems = 0x1ad8 // TArray<int32_t> (Size: 0x10)
SGCharacterMovementComponent.DiveHalfHeight = 0x1ae8 // float (Size: 0x4)
SGCharacterMovementComponent.MaxDiveStartFixHeight = 0x1aec // float (Size: 0x4)
SGCharacterMovementComponent.MaxDiveStartFixTime = 0x1af0 // float (Size: 0x4)
SGCharacterMovementComponent.DiveEndTime = 0x1af4 // float (Size: 0x4)
SGCharacterMovementComponent.DiveCD = 0x1af8 // float (Size: 0x4)
SGCharacterMovementComponent.bDiveCoolDown = 0x1afd // bool (Size: 0x1)
SGCharacterMovementComponent.bIsDiving = 0x1b38 // bool (Size: 0x1)
SGCharacterMovementComponent.bIsDivingEnd = 0x1b39 // bool (Size: 0x1)
SGCharacterMovementComponent.DiveCoolDownTime = 0x1b48 // float (Size: 0x4)
SGCharacterMovementComponent.GravityCenterSpring = 0x1b60 // FAnimationSpring (Size: 0x110)
SGCharacterMovementComponent.GravityCenterMovableAngle = 0x1c70 // FVector2D (Size: 0x8)
SGCharacterMovementComponent.LandForceIntensity = 0x1c78 // float (Size: 0x4)
SGCharacterMovementComponent.ShiftingGravityCenterAccScaler = 0x1c7c // float (Size: 0x4)
SGCharacterMovementComponent.OverrideCharacterVelocityAfterJumpCurve = 0x1c88 // CurveFloat* (Size: 0x8)
SGCharacterMovementComponent.SprintSpeedScaleInBushes = 0x1c94 // float (Size: 0x4)
SGCharacterMovementComponent.RunSpeedScaleInBushes = 0x1c98 // float (Size: 0x4)
SGCharacterMovementComponent.GrassCheckInterval = 0x1c9c // float (Size: 0x4)
SGCharacterMovementComponent.bSlowdownByBushes = 0x1ca4 // bool (Size: 0x1)
SGCharacterMovementComponent.NearGrassBounds = 0x1cb0 // FAINearGrassBounds (Size: 0x20)
SGCharacterMovementDBNOComponent.DBNOEyeHeight = 0x100 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOHalfHeight = 0x104 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.RampRotationInterpSpeed = 0x108 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOMeshOffsetInterpSpeed = 0x10c // float (Size: 0x4)
SGCharacterMovementDBNOComponent.UnDBNOMeshOffsetInterpSpeed = 0x110 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.EnterDBNOTime = 0x114 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.ExitDBNOTime = 0x118 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOMeshZOffset = 0x11c // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOMeshXOffset = 0x120 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOMeshYOffset = 0x124 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.CollisionIgnoreHeight = 0x128 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.bIsDBNOMove = 0x12c // bool (Size: 0x1)
SGCharacterMovementDBNOComponent.RampRayTraceDistance = 0x130 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.RampDetectAngleThreshold = 0x134 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.RibCageBoneName = 0x138 // FName (Size: 0x8)
SGCharacterMovementDBNOComponent.bExitZoomWhenSwitch = 0x140 // bool (Size: 0x1)
SGCharacterMovementDBNOComponent.DBNOWalkableFloorAngle = 0x144 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOMaxStepHeight = 0x148 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.CamerTraceStartOffset = 0x14c // float (Size: 0x4)
SGCharacterMovementDBNOComponent.CamerTraceRadius = 0x150 // float (Size: 0x4)
SGCharacterMovementDBNOComponent.DBNOCollisionComponent = 0x160 // CapsuleComponent* (Size: 0x8)
SGCharacterMovementDBNOComponent.bDBNOMaintainsBaseLocation = 0x168 // uint8_t (Size: 0x1)
SGCharacterMovementDBNOComponent.DBNORotationOffset = 0x16c // FRotator (Size: 0xc)
SGCharacterMovementLadderClimbComponent.MotionWarpingPathNodes = 0x108 // TArray<FSGPredictPathNode> (Size: 0x10)
SGCharacterMovementLadderClimbComponent.TopEnterMoveToTargetSpeed = 0x118 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomEnterMoveToTargetSpeed = 0x11c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopEnterUnEquipWeaponRateScale = 0x120 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopExitEquipWeaponRateScale = 0x124 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomEnterUnEquipWeaponRateScale = 0x128 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomExitEquipWeaponRateScale = 0x12c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopEnterAnimPlayRateScale = 0x130 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopExitAnimPlayRateScale = 0x134 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomEnterAnimPlayRateScale = 0x138 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomExitAnimPlayRateScale = 0x13c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.LadderMoveAnimPlayRate = 0x140 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopEnterAngleRange = 0x144 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.TopEnterPitchAngleRange = 0x148 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.BottomEnterAngleRange = 0x14c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.HeadSocketName = 0x150 // FName (Size: 0x8)
SGCharacterMovementLadderClimbComponent.InterpSpeed_ControlRotation = 0x158 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.IdleItemROffsetZ = 0x15c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.CheckExitLadderTriggerBoxDisSquared = 0x160 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.IdleStateFixPosDeviation = 0x164 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.IdleStateFixPosOverTime = 0x168 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.CharacterOwner = 0x170 // SGCharacter* (Size: 0x8)
SGCharacterMovementLadderClimbComponent.FixPosDisSquared = 0x178 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.bNeedInteractBtnWhenFromBottom = 0x17c // bool (Size: 0x1)
SGCharacterMovementLadderClimbComponent.bIsLadderClimbing = 0x17d // bool (Size: 0x1)
SGCharacterMovementLadderClimbComponent.CurrentBarIndex = 0x180 // int32_t (Size: 0x4)
SGCharacterMovementLadderClimbComponent.CurrentLadderClimbingState = 0x188 // LadderClimbingBaseState* (Size: 0x8)
SGCharacterMovementLadderClimbComponent.LadderArray = 0x190 // TArray<SGLadderBase*> (Size: 0x10)
SGCharacterMovementLadderClimbComponent.CurrentLadder = 0x1a0 // SGLadderBase* (Size: 0x8)
SGCharacterMovementLadderClimbComponent.DirectionType = 0x1a8 // EELadderClimbingDirectionType (Size: 0x1)
SGCharacterMovementLadderClimbComponent.InputType = 0x1a9 // EELadderClimbingInputType (Size: 0x1)
SGCharacterMovementLadderClimbComponent.LadderClimbingStateMap = 0x1b0 // TMap<...> (Size: 0x50)
SGCharacterMovementLadderClimbComponent.LadderClimbingExitStateTimerMap = 0x200 // TMap<...> (Size: 0x50)
SGCharacterMovementLadderClimbComponent.CameraLimitLerpTimeLength = 0x250 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.EnterLadderTimeStamp = 0x258 // double (Size: 0x8)
SGCharacterMovementLadderClimbComponent.MaxHandClampDistanceScaler = 0x26c // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.MaxDistanceBetweenUpperArmAndHand = 0x270 // float (Size: 0x4)
SGCharacterMovementLadderClimbComponent.NearestLoc_Hand_L_LastTime = 0x27c // FVector (Size: 0xc)
SGCharacterMovementLadderClimbComponent.NearestLoc_Hand_R_LastTime = 0x288 // FVector (Size: 0xc)
SGCharacterMovementLadderClimbComponent.ModifiedLocation_Hand_L_LastTime = 0x294 // FVector (Size: 0xc)
SGCharacterMovementLadderClimbComponent.ModifiedLocation_Hand_R_LastTime = 0x2a0 // FVector (Size: 0xc)
SGCharacterMovementLadderClimbComponent.ModifiedLocationInterpSpeed = 0x2ac // float (Size: 0x4)
SGCharacterMovementProneComponent.ProneEyeHeight = 0x108 // float (Size: 0x4)
SGCharacterMovementProneComponent.ProneHalfHeight = 0x10c // float (Size: 0x4)
SGCharacterMovementProneComponent.SlopeRotationInterpSpeed = 0x110 // float (Size: 0x4)
SGCharacterMovementProneComponent.TargetProneRotationOffset = 0x114 // FRotator (Size: 0xc)
SGCharacterMovementProneComponent.SmoothProneRotationOffset = 0x120 // FRotator (Size: 0xc)
SGCharacterMovementProneComponent.TargetProneLegsRotationOffset = 0x12c // FRotator (Size: 0xc)
SGCharacterMovementProneComponent.SmoothProneLegsRotationOffset = 0x138 // FRotator (Size: 0xc)
SGCharacterMovementProneComponent.ProneMeshLocationOffset = 0x144 // FVector (Size: 0xc)
SGCharacterMovementProneComponent.TargetProneMeshLocationOffset = 0x150 // FVector (Size: 0xc)
SGCharacterMovementProneComponent.MeshLocationOffsetInterpSpeed = 0x15c // float (Size: 0x4)
SGCharacterMovementProneComponent.CollisionIgnoreHeight = 0x160 // float (Size: 0x4)
SGCharacterMovementProneComponent.MaxUnproneAdjustDistance = 0x164 // float (Size: 0x4)
SGCharacterMovementProneComponent.bIsProne = 0x168 // bool (Size: 0x1)
SGCharacterMovementProneComponent.DefaultCapsuleHalfHeight = 0x16c // float (Size: 0x4)
SGCharacterMovementProneComponent.DefaultCapsuleRadius = 0x170 // float (Size: 0x4)
SGCharacterMovementProneComponent.UnProneBeEncroached = 0x17c // bool (Size: 0x1)
SGCharacterMovementProneComponent.ProneCollisionComponent = 0x180 // CapsuleComponent* (Size: 0x8)
SGCharacterMovementProneComponent.bProneMaintainsBaseLocation = 0x188 // uint8_t (Size: 0x1)
SGCharacterMovementProneComponent.SlopeRayTraceDistance = 0x18c // float (Size: 0x4)
SGCharacterMovementProneComponent.bStandOnStairs = 0x190 // bool (Size: 0x1)
SGCharacterMovementProneComponent.CanProneInCurrentEnvironmentTickInterval = 0x198 // float (Size: 0x4)
SGCharacterMovementProneComponent.RibCageBoneName = 0x19c // FName (Size: 0x8)
SGCharacterMovementProneComponent.bExitZoomWhenSwitch = 0x1a4 // bool (Size: 0x1)
SGCharacterMovementProneComponent.ProneWalkableFloorAngle = 0x1a8 // float (Size: 0x4)
SGCharacterMovementProneComponent.ProneMaxStepHeight = 0x1ac // float (Size: 0x4)
SGCharacterMovementProneComponent.CamerTraceStartOffset = 0x1b0 // float (Size: 0x4)
SGCharacterMovementProneComponent.CamerTraceRadius = 0x1b4 // float (Size: 0x4)
SGCharacterMovementProneComponent.FaceForwardDistance = 0x1b8 // float (Size: 0x4)
SGCharacterMovementProneComponent.ProneLegsTraceRadius = 0x1bc // float (Size: 0x4)
SGCharacterMovementProneComponent.StairMaterial = 0x1c0 // PhysicalMaterial* (Size: 0x8)
SGCharacterMovementProneComponent.CanProneOnStairMaxAngle = 0x1c8 // float (Size: 0x4)
SGCharacterMovementProneComponent.CanProneMaxAngle = 0x1cc // float (Size: 0x4)
SGCharacterMovementProneComponent.bEnableProneAvoidObstacle = 0x1d0 // bool (Size: 0x1)
SGCharacterMovementProneComponent.ProneAdditionalBodyLength = 0x1d4 // float (Size: 0x4)
SGCharacterMovementProneComponent.AvoidObstacleAdjustmentAdditionalDistance = 0x1d8 // float (Size: 0x4)
SGCharacterMovementProneComponent.AvoidObstacleAcceleration = 0x1dc // float (Size: 0x4)
SGCharacterMovementProneComponent.DebugTraceEndlessLoopInProneCounter = 0x1e0 // int32_t (Size: 0x4)
SGCharacterMovementProneComponent.DebugTraceEndlessLoopInProneFrameCycleCounter = 0x1e4 // int32_t (Size: 0x4)
SGCharacterMovementVaultComponent.VaultAnimationList = 0x108 // TArray<FSGVaultAnimationConfig> (Size: 0x10)
SGCharacterMovementVaultComponent.VaultObstacleHeightsNormal = 0x118 // TArray<int32_t> (Size: 0x10)
SGCharacterMovementVaultComponent.VaultObstacleMaxThickNormal = 0x128 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ThickTraceExtraTimeNormal = 0x12c // float (Size: 0x4)
SGCharacterMovementVaultComponent.AngleTowardsObstacleToleranceNormal = 0x130 // float (Size: 0x4)
SGCharacterMovementVaultComponent.VaultBlockingTags = 0x138 // FGameplayTagContainer (Size: 0x20)
SGCharacterMovementVaultComponent.AccAngleTowardsObstacleTolerance = 0x158 // float (Size: 0x4)
SGCharacterMovementVaultComponent.MaxDistanceTowardsObstacle = 0x15c // float (Size: 0x4)
SGCharacterMovementVaultComponent.ForwardTraceDistanceNormal = 0x160 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ForwardTraceExtraTimeNormal = 0x164 // float (Size: 0x4)
SGCharacterMovementVaultComponent.VaultObstacleHeightsOverWeight = 0x168 // TArray<int32_t> (Size: 0x10)
SGCharacterMovementVaultComponent.VaultObstacleMaxThickOverWeight = 0x178 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ThickTraceExtraTimeOverWeight = 0x17c // float (Size: 0x4)
SGCharacterMovementVaultComponent.AngleTowardsObstacleToleranceOverWeight = 0x180 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ForwardTraceDistanceOverWeight = 0x184 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ForwardTraceExtraTimeOverWeight = 0x188 // float (Size: 0x4)
SGCharacterMovementVaultComponent.CanClimbObstacleFloorMaxAngle = 0x18c // float (Size: 0x4)
SGCharacterMovementVaultComponent.ApexPointAdjustmentMaxErrorTolerance = 0x190 // float (Size: 0x4)
SGCharacterMovementVaultComponent.EarlyOutVaultFallHeight = 0x194 // float (Size: 0x4)
SGCharacterMovementVaultComponent.MinVelocityZWhenExitVault = 0x198 // float (Size: 0x4)
SGCharacterMovementVaultComponent.ObjectCanVaultCollisionChannel = 0x19c // uint8_t (Size: 0x1)
SGCharacterMovementVaultComponent.ObjectBlockVaultCollisionChannel = 0x19d // uint8_t (Size: 0x1)
SGCharacterMovementVaultComponent.bVerifyPathNode = 0x19e // bool (Size: 0x1)
SGCharacterMovementVaultComponent.PathNodeErrorTolerance = 0x1a0 // float (Size: 0x4)
SGCharacterMovementVaultComponent.MinVelocityZToTriggerVault = 0x1a4 // float (Size: 0x4)
SGCharacterMovementVaultComponent.MaxVaultDistance2D = 0x1a8 // float (Size: 0x4)
SGCharacterMovementVaultComponent.CurrentVaultAnimation = 0x1b8 // FSoftObjectPath (Size: 0x18)
SGCharacterMovementVaultComponent.ServerEndVaultExtraTimeOut = 0x1d0 // float (Size: 0x4)
SGCharacterMovementVaultComponent.StartVaultCharacterLocationThreshold = 0x1e0 // float (Size: 0x4)
SGCharacterMovementVaultComponent.bIgnoreLookInputWhenVault = 0x1e4 // bool (Size: 0x1)
SGCharacterMovementVaultComponent.RepVaultInfo = 0x1e8 // FVaultRepInfo (Size: 0x30)
SGCharacterMovementVaultComponent.VaultResult = 0x218 // FVaultResult (Size: 0xb8)
SGCharacterMovementVaultComponent.VaultPhase = 0x2d0 // EEVaultPhase (Size: 0x1)
SGCharacterMovementVaultComponent.ActorsToIgnore = 0x300 // TArray<Actor*> (Size: 0x10)
SGCharacterMovementVaultComponent.VaultTag = 0x310 // FGameplayTag (Size: 0x8)
SGCharacterOutlineEffectComponent.MyCustomStencilValue = 0x100 // uint8_t (Size: 0x1)
SGCharacterOutlineEffectComponent.TeammateCustomStencilValue = 0x101 // uint8_t (Size: 0x1)
SGCharacterOutlineEffectComponent.EnemyCustomStencilValue = 0x102 // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.SkeletalMeshArray = 0xf8 // TArray<MeshComponent*> (Size: 0x10)
SGCharacterPerspectiveComponent.TargetDepth = 0x108 // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.TargetStencilMask = 0x109 // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.bTargetRenderCustomDepth = 0x10a // bool (Size: 0x1)
SGCharacterPerspectiveComponent.bIsVailCharacter = 0x10b // bool (Size: 0x1)
SGCharacterPerspectiveComponent.VictimDepth = 0x118 // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.VictimDepthMask = 0x119 // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.SameTeamDepth = 0x11a // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.SameTeamDepthMask = 0x11b // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.DifferentTeamDepth = 0x11c // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.DifferentTeamDepthMask = 0x11d // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.AIDepth = 0x11e // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.AIDepthMask = 0x11f // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.KillerDepth = 0x120 // uint8_t (Size: 0x1)
SGCharacterPerspectiveComponent.KillerDepthMask = 0x121 // EERendererStencilMask (Size: 0x1)
SGCharacterPerspectiveComponent.VailDistance = 0x124 // float (Size: 0x4)
SGCharacterPerspectiveComponent.DirectionIndicatorMeshComponent = 0x128 // StaticMeshComponent* (Size: 0x8)
SGCharacterPerspectiveComponent.bPerspective = 0x130 // bool (Size: 0x1)
SGCharacterPreviewAnimInstance.LocalProxy = 0x2c0 // FSGCharacterPreviewAnimInstanceProxy (Size: 0xbe0)
SGCharacterPreviewAnimInstance.GripPoseAdjustmentMaxOffset = 0xea0 // float (Size: 0x4)
SGCharacterPreviewAnimInstance.PMCCharacterTag = 0xea4 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.ScavCharacterTag = 0xeac // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.TeamPlatformCharacterPrefix = 0xeb8 // FString (Size: 0x10)
SGCharacterPreviewAnimInstance.SettlementCharacterPrefix = 0xec8 // FString (Size: 0x10)
SGCharacterPreviewAnimInstance.AvatarInformationCharacterTag = 0xed8 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.EquipmentAvatarCharacterTag = 0xee0 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.ExitBattleBodyStateCharacterTag = 0xee8 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.ExitBattleHUBCharacterTag = 0xef0 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.CongratulationCharacterTag = 0xef8 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.ShareCharacter3pTag = 0xf00 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.ExitBattleCharacterAnimTag = 0xf08 // FName (Size: 0x8)
SGCharacterPreviewAnimInstance.AnimDebugLogContainer = 0xf10 // FSGAnimationDebugLogContainer (Size: 0x10)
SGCharacterPreviewAnimInstanceProxy.bShouldUseFPPBreath = 0x860 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bHasIdleSeq = 0x861 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.IdleSeq = 0x868 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.IdleSeqBasePose = 0x870 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.IdleBreathAdditiveSeq = 0x878 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bHasCasualIdleSeq = 0x880 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.HasCasualIdleSeq = 0x884 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.DTRandomIdleSeq = 0x888 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.DTRandomIdleLength = 0x890 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.DTRandomIdleTime = 0x894 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.bHasDTRandomIdleSeq = 0x898 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bShouldUseCasualIdleSeq = 0x899 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.CasualIdleSeq = 0x8a0 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.DTCustomizeAnimeSeq = 0x8a8 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.DefaultDTCustomAnimSeq = 0x8b0 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.ZDIdleAnimeSeq = 0x8b8 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bHasZDIdleAnimeSeq = 0x8c0 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bHasDTCustomizeAnimeSeq = 0x8c1 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.DTIdleSequence = 0x8c8 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.StartTimeOffset = 0x8d0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.WeaponHandgripType = 0x8d4 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_AdaptiveWeaponHandGripPose = 0x8d8 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_LeftHandGripPose = 0x8dc // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_LeftHandGripOffset = 0x8e0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.bIsPlayingSlotAnimation_LeftHand = 0x8e4 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.Enable_BlendLeftHandGrip = 0x8e8 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_BlendLeftHandGrip_FPGrip = 0x8ec // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_Breath_Additive_FP = 0x8f0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.SGWeapon = 0x8f8 // SGWeapon* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bIsWeaponChange = 0x900 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsCharacterAnimationSetsChange = 0x901 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.LastWeaponType = 0x902 // EESGWeaponType (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.CurrentWeaponType = 0x903 // EESGWeaponType (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bHasLeftHandWeaponMeshChange = 0x904 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.WeaponStance = 0x905 // EEWeaponType (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.FullBodySlotAnimationRatio = 0x908 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.DefaultSlotAnimationRatio = 0x90c // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.LobbySuperIdleSlotAnimationRatio = 0x910 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.bIsUseLobbySuperIdle = 0x914 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsArmedWithMainWeapon = 0x915 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsArmedWithAssistWeapon = 0x916 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsArmedWithMeleeWeapon = 0x917 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bLockChangeAnimationSet = 0x918 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bTeamUpCharacter = 0x919 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bTeamUpScav = 0x91a // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bTeamPlatformCharacter = 0x91b // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bAvatarInformationCharacter = 0x91c // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bEquipmentAvatarCharacter = 0x91d // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bExitBattleBodyStateCharacter = 0x91e // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bExitBattleHUBCharacter = 0x91f // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bCongratulationCharacter = 0x920 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bShareCharacter3p = 0x921 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bReady = 0x922 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bReadyLastUpdate = 0x923 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bNotReady = 0x924 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.RootBoneRotation = 0x928 // FRotator (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.TeamPlatformTag = 0x934 // FName (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bJSCharacter = 0x93c // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.JSCharacterTag = 0x940 // FName (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.TeamPlatformCasualGripAdjustmentBS = 0x948 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.TeamPlatfromIdleMontageList = 0x950 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterPreviewAnimInstanceProxy.TeamPlatfromReadyMontageList = 0x960 // TArray<AnimMontage*> (Size: 0x10)
SGCharacterPreviewAnimInstanceProxy.JSCasualGripAdjustmentBS = 0x970 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.HandWeaponOffset_LeftHand = 0x978 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.HandWeaponOffset_RightHand_Location = 0x984 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.HandWeaponOffset_RightHand_Rotation = 0x990 // FRotator (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.HandOffset_L_Location = 0x99c // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.Enable_HandOffset_L_Alpha = 0x9a8 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.HandOffset_R_Location = 0x9ac // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.HandOffset_R_Trigger = 0x9b8 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.Enable_HandOffset_R_Alpha = 0x9c4 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.PreviewCharacterWeaponTranslation = 0x9c8 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.PreviewCharacterWeaponRotation = 0x9d4 // FRotator (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.EnablePreviewCharacterWeaponOffset = 0x9e0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.ForeGripOffset = 0x9e4 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.ZDIdleBasePoseBlendRatio = 0x9f0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.GripPoseAdjustmentOffset = 0x9f4 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.Enable_GripPoseAdjust = 0xa00 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_DTGripPoseAdditive = 0xa04 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.EnableRightHandBlend = 0xa08 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.EnableRightHandIKBlend = 0xa0c // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.EnableLobbyGunRotationOffset = 0xa10 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.EnableLobbyWeaponGripPose = 0xa14 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.WeaponReargripType = 0xa18 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.RearGripIdleBS = 0xa20 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.CasualRearGripIdleBS = 0xa28 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.Enable_RightHandGripPose = 0xa30 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.bHasForegrip = 0xa34 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bPistolGrip = 0xa35 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bHasWeaponForegrip = 0xa36 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.WeaponForegripType = 0xa38 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.GripPoseAdjustmentAlpha = 0xa3c // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.CasualGripAdjustmentBS = 0xa40 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.AdjustGripIdleBS = 0xa48 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.ForeGripBS = 0xa50 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.CasualGripIdleBS = 0xa58 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.GripIdleBS = 0xa60 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bHasReargrip = 0xa68 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bHasLeftHandWeaponMesh = 0xa69 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.LFingerAdaptiveBS = 0xa70 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bEnableLFingerAdaptive = 0xa78 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.LFingerAdaptiveAlpha = 0xa7c // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_AdaptiveWeaponTriggerPointAlpha = 0xa80 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.AdaptiveLeftHandWeaponTriggerPointAlpha = 0xa84 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.AdaptiveRightHandWeaponTriggerPointAlpha = 0xa88 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_BothHandMeleeWeaponCasualGrip = 0xa8c // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_RightHandCasualGripPose = 0xa90 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_AdditiveAdjustmentPose = 0xa94 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Enable_UseIdleRightHand = 0xa98 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.DTAnimSequenceScaleRate = 0xaa0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.CharacterSex = 0xaa4 // EECharacterSex (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsMale = 0xaa5 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.SGAnimInstance = 0xaa8 // SGCharacterPreviewAnimInstance* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.SGCharacter = 0xab0 // SGCharacter* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.CachedPreviewComponent = 0xab8 // SGCharacterPreviewComponent* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.CharacterAnimationSetsClass = 0xac0 // ClassProperty (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.PerWeaponAnimationSetsClass = 0xac8 // ClassProperty (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.CachedCharacterAnimationSets = 0xad8 // SGCharacterAnimationSetsPerCharacterSex* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bAnimSetReady = 0xae0 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bEnableLookAtCamera = 0xae1 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.LookAtLocation = 0xae4 // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.LookAtBlendSpeed = 0xaf0 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.RetargetOptionsInLobby = 0xaf8 // FSGAvatarAnimRetargetData (Size: 0x98)
SGCharacterPreviewAnimInstanceProxy.bPreviewCaptureCharacter = 0xb92 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIsCasual = 0xb93 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bIs1P = 0xb94 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.bAdditiveLeftHandGrip = 0xb95 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.ControlRigAimWeight = 0xb98 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.EyeAimPosition = 0xb9c // FVector (Size: 0xc)
SGCharacterPreviewAnimInstanceProxy.FaceAimControl = 0xba8 // FVector2D (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.PreviewIdleAnim = 0xbb0 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.PreviewAdjustmentBS = 0xbb8 // BlendSpace1D* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.PreviewIdleAnimHandPose = 0xbc0 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.WeaponOrientPose = 0xbc8 // AnimSequence* (Size: 0x8)
SGCharacterPreviewAnimInstanceProxy.bShouldUseTeamHandPose = 0xbd0 // bool (Size: 0x1)
SGCharacterPreviewAnimInstanceProxy.Curve_LeftHandPose = 0xbd4 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.Curve_RightHandPose = 0xbd8 // float (Size: 0x4)
SGCharacterPreviewAnimInstanceProxy.PreviewAnimFKGunPose = 0xbdc // float (Size: 0x4)
SGCharacterPreviewComponent.bShouldStopCapture = 0x100 // bool (Size: 0x1)
SGCharacterPreviewComponent.bForceTickPoseAndRefreshBone = 0x101 // bool (Size: 0x1)
SGCharacterPreviewComponent.DefaultDTCustomAnimSeq_Male = 0x108 // AnimSequence* (Size: 0x8)
SGCharacterPreviewComponent.DefaultDTCustomAnimSeq_Female = 0x110 // AnimSequence* (Size: 0x8)
SGCharacterPreviewComponent.DefaultDTFacialAnimSeq = 0x118 // AnimSequence* (Size: 0x8)
SGCharacterPreviewComponent.DefaultDTBreathAnimSeq = 0x120 // AnimSequence* (Size: 0x8)
SGCharacterPreviewComponent.InBattleAKMBreathAnimSeq = 0x128 // AnimSequence* (Size: 0x8)
SGCharacterPreviewComponent.StartTimeOffset = 0x130 // float (Size: 0x4)
SGCharacterPreviewComponent.BaseAccumulateTime = 0x134 // float (Size: 0x4)
SGCharacterPreviewComponent.bUseFacialAnimation = 0x138 // bool (Size: 0x1)
SGCharacterPreviewComponent.bForceDisableWindAnim = 0x139 // bool (Size: 0x1)
SGCharacterPreviewComponent.AllMeshLoaded = 0x148 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterPreviewComponent.UpdateAvatarsFinish = 0x158 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterPreviewComponent.bIsFPPMode = 0x168 // bool (Size: 0x1)
SGCharacterPreviewComponent.bReady = 0x169 // bool (Size: 0x1)
SGCharacterPreviewComponent.PreviewCharacterAnimTagName = 0x16c // FName (Size: 0x8)
SGCharacterPreviewComponent.bCanAddRootBoneRotation = 0x174 // bool (Size: 0x1)
SGCharacterPreviewComponent.PreviewCameraComponent = 0x178 // CameraComponent* (Size: 0x8)
SGCharacterPreviewComponent.SceneCaptureNode = 0x180 // SceneCaptureComponent2D* (Size: 0x8)
SGCharacterPreviewComponent.PlayerLocName = 0x198 // FString (Size: 0x10)
SGCharacterPreviewComponent.Preview_SyncLoadingAnimaitonsSets = 0x1b8 // TArray<ClassProperty> (Size: 0x10)
SGCharacterPreviewComponent.bTeamMatchingCharacter = 0x1c8 // bool (Size: 0x1)
SGCharacterPreviewComponent.AvatarEnterBlendOutTime = 0x1cc // float (Size: 0x4)
SGCharacterPreviewComponent.OutsideAvatarSet = 0x1d0 // ClassProperty (Size: 0x8)
SGCharacterPreviewComponent.CachedParticleSystemComponent = 0x1d8 // ParticleSystemComponent* (Size: 0x8)
SGCharacterPreviewComponent.CachedItemMeshComponent = 0x1e0 // TArray<SkeletalMeshComponent*> (Size: 0x10)
SGCharacterPreviewComponent.ZDCharacterTagPrefix = 0x1f0 // FString (Size: 0x10)
SGCharacterPreviewComponent.DefaultLobbyCharacterTag = 0x200 // FName (Size: 0x8)
SGCharacterPreviewComponent.WeaponAttachRelativeTransform = 0x210 // FTransform (Size: 0x30)
SGCharacterPreviewComponent.bShouldModifyTakeupItemr = 0x240 // bool (Size: 0x1)
SGCharacterPreviewComponent.TakeupAnimationItemrTransformMap = 0x248 // TMap<...> (Size: 0x50)
SGCharacterPreviewComponent.LoadedAnims = 0x2b0 // TArray<AnimSequenceBase*> (Size: 0x10)
SGCharacterPreviewComponent.CachedAvatarAnimation = 0x310 // TMap<...> (Size: 0x50)
SGCharacterPreviewComponent.CachedCharacterAnimation = 0x360 // AnimMontage* (Size: 0x8)
SGCharacterPreviewComponent.bEnableLookAtCamera = 0x368 // bool (Size: 0x1)
SGCharacterPreviewComponent.LookAtLocation = 0x36c // FVector (Size: 0xc)
SGCharacterPreviewComponent.LookAtBlendSpeed = 0x378 // float (Size: 0x4)
SGCharacterPreviewComponent.CachedDialogAnimation = 0x380 // TMap<...> (Size: 0x50)
SGCharacterPreviewComponent.CachedCharacterPoseAnimation = 0x3d0 // TMap<...> (Size: 0x50)
SGCharacterPreviewComponent.CharacterDialogAnimationState = 0x420 // EECharacterDialogAnimationLoadState (Size: 0x1)
SGCharacterPreviewComponent.CharacterPoseAnimationState = 0x421 // EECharacterDialogAnimationLoadState (Size: 0x1)
SGCharacterProgressAbility.AbilityClass = 0x0 // ClassProperty (Size: 0x8)
SGCharacterProgressAbility.AbilitySpecHandle = 0x8 // FGameplayAbilitySpecHandle (Size: 0x4)
SGCharacterProgressAbility.Owner = 0x10 // Character* (Size: 0x8)
SGCharacterProgressAbility_ChangeMagazine.CachedFillInventory = 0x18 // Actor* (Size: 0x8)
SGCharacterProgressAbility_FillMagazineExtra.CachedTargetContainer = 0x18 // Actor* (Size: 0x8)
SGCharacterProgressAbility_SetupC4.CachedFillSource = 0x18 // Actor* (Size: 0x8)
SGCharacterProgressAbility_SetupC4.CachedUseTime = 0x20 // float (Size: 0x4)
SGCharacterProgressManagerComponent.FillMagazineAbilityExtra = 0x100 // FSGCharacterProgressAbility_FillMagazineExtra (Size: 0x20)
SGCharacterProgressManagerComponent.ChangeMagazineAbility = 0x120 // FSGCharacterProgressAbility_ChangeMagazine (Size: 0x20)
SGCharacterProgressManagerComponent.SetupC4Ability = 0x140 // FSGCharacterProgressAbility_SetupC4 (Size: 0x38)
SGCharacterQTEBase.QTEType = 0xf8 // EEQTEType (Size: 0x1)
SGCharacterQTEBase.CurrentStep = 0xf9 // EEQTEStep (Size: 0x1)
SGCharacterQTEBase.QTEManager = 0x100 // SGCharacterQTEManageComponent* (Size: 0x8)
SGCharacterQTECooperateAttack.ToTargetYawMin = 0x138 // float (Size: 0x4)
SGCharacterQTECooperateAttack.ToTargetYawMax = 0x13c // float (Size: 0x4)
SGCharacterQTECooperateAttack.ToTargetPitchMin = 0x140 // float (Size: 0x4)
SGCharacterQTECooperateAttack.ToTargetPitchMax = 0x144 // float (Size: 0x4)
SGCharacterQTECooperateAttack.TriggerRelativeFaceDirection = 0x148 // float (Size: 0x4)
SGCharacterQTECooperateAttack.TriggerMaxDistance = 0x14c // float (Size: 0x4)
SGCharacterQTECooperateAttack.TriggerMinDistance = 0x150 // float (Size: 0x4)
SGCharacterQTECooperateAttack.StartAttackRelativeTransform = 0x160 // FTransform (Size: 0x30)
SGCharacterQTECooperateAttack.ToStartLocationSpeed = 0x190 // float (Size: 0x4)
SGCharacterQTECooperateAttack.ToStartRotationSpeed = 0x194 // float (Size: 0x4)
SGCharacterQTECooperateAttack.ArriveStartPointDist = 0x198 // float (Size: 0x4)
SGCharacterQTECooperateAttack.DamageValue = 0x19c // float (Size: 0x4)
SGCharacterQTECooperateAttack.StartAttackWorldLocation = 0x1a0 // FVector (Size: 0xc)
SGCharacterQTECooperateBase.SponsorInfo = 0x108 // FCooperateQTECharacterInfo (Size: 0x10)
SGCharacterQTECooperateBase.TargetsInfo = 0x118 // TArray<FCooperateQTECharacterInfo> (Size: 0x10)
SGCharacterQTECooperateBase.MineCharacterInfo = 0x128 // FCooperateQTECharacterInfo (Size: 0x10)
SGCharacterQTEManageComponent.QTEList = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGCharacterQTEManageComponent.CheckTargetRadius = 0x110 // float (Size: 0x4)
SGCharacterQTEManageComponent.bDrawDebug = 0x114 // bool (Size: 0x1)
SGCharacterQTEManageComponent.TraceChannel = 0x115 // uint8_t (Size: 0x1)
SGCharacterQTEManageComponent.QTEInstList = 0x118 // TArray<SGCharacterQTEBase*> (Size: 0x10)
SGCharacterQTEManageComponent.BestPlayQTE = 0x128 // SGCharacterQTEBase* (Size: 0x8)
SGCharacterRagdollAnimInstance.LocalProxy = 0x2c0 // FSGCharacterRagdollAnimInstanceProxy (Size: 0x8b0)
SGCharacterRagdollAnimInstanceProxy.AnimInstance = 0x860 // SGCharacterRagdollAnimInstance* (Size: 0x8)
SGCharacterRagdollAnimInstanceProxy.SGCharacter = 0x868 // SGCharacter* (Size: 0x8)
SGCharacterRagdollAnimInstanceProxy.bIsDead = 0x870 // bool (Size: 0x1)
SGCharacterRagdollAnimInstanceProxy.bIsRagdoll = 0x871 // bool (Size: 0x1)
SGCharacterRagdollAnimInstanceProxy.ForceSnapPelvisToRootAlpha = 0x874 // float (Size: 0x4)
SGCharacterRagdollAnimInstanceProxy.RagdollPose = 0x878 // FPoseSnapshot (Size: 0x38)
SGCharacterRagdollComponent.bStartingRagdoll = 0x100 // bool (Size: 0x1)
SGCharacterRagdollComponent.bInRagdollRecovery = 0x101 // bool (Size: 0x1)
SGCharacterRagdollComponent.RagdollGravityScale = 0x104 // float (Size: 0x4)
SGCharacterRagdollComponent.RagdollFallSound = 0x108 // AkAudioEvent* (Size: 0x8)
SGCharacterRagdollComponent.RagdollCollisionBleedThreshold = 0x110 // float (Size: 0x4)
SGCharacterRagdollComponent.RagdollBlendOutTime = 0x114 // float (Size: 0x4)
SGCharacterRagdollNewComponent.bEnableRagdoll = 0x108 // bool (Size: 0x1)
SGCharacterRagdollNewComponent.RepBodyState = 0x110 // FRigidBodyState (Size: 0x40)
SGCharacterRagdollNewComponent.RagdollBakedBoneInfo = 0x150 // FSGRagdollBakedBoneInfo (Size: 0x28)
SGCharacterRagdollNewComponent.ServerRagdollStageForDebug = 0x178 // EESGRagdollStage (Size: 0x1)
SGCharacterRagdollNewComponent.ServerPelvisLocation = 0x17c // FVector (Size: 0xc)
SGCharacterRagdollNewComponent.RagdollPhysicsAsset = 0x1d8 // PhysicsAsset* (Size: 0x8)
SGCharacterRagdollNewComponent.RagdollPhysicsAsset_RootMotion = 0x1e0 // PhysicsAsset* (Size: 0x8)
SGCharacterRagdollNewComponent.RagdollDataAsset = 0x1e8 // SGRagdollData_HD* (Size: 0x8)
SGCharacterRandomrDefaultInvComp.CharacterDefaultInventoryListPool = 0x100 // TArray<FCharacterDefaultInventoryList> (Size: 0x10)
SGCharacterRandomrDefaultInvComp.CurrDefaultInventoryList = 0x110 // FCharacterDefaultInventoryList (Size: 0x20)
SGCharacterRebornComponent.bIsInRebornSafty = 0x108 // bool (Size: 0x1)
SGCharacterRescuedByTeammateInfo.StartRescueTime = 0x0 // double (Size: 0x8)
SGCharacterRescuedByTeammateInfo.KindlyTeammate = 0x8 // SGCharacter* (Size: 0x8)
SGCharacterRushSlideComponent.SlideToCrouchAnim = 0x100 // AnimMontage* (Size: 0x8)
SGCharacterRushSlideComponent.ForwardSection = 0x108 // FName (Size: 0x8)
SGCharacterRushSlideComponent.RightForwardSection = 0x110 // FName (Size: 0x8)
SGCharacterRushSlideComponent.LeftForwardSection = 0x118 // FName (Size: 0x8)
SGCharacterSearchComponent.IsSearchEnemy = 0x100 // bool (Size: 0x1)
SGCharacterSearchComponent.SearchSpeedMin = 0x104 // float (Size: 0x4)
SGCharacterSearchComponent.SearchDistanceMax = 0x108 // float (Size: 0x4)
SGCharacterSearchComponent.SearchEnergyMax = 0x10c // float (Size: 0x4)
SGCharacterSearchComponent.ReduceSearchEnergySpeed = 0x110 // float (Size: 0x4)
SGCharacterSearchComponent.RecoverSearchEnergySpeed = 0x114 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.GeneralGameplayEffectConfigMap = 0x108 // TMap<...> (Size: 0x50)
SGCharacterSenseAbilityComponent.GeneralActiveGameEffectHandleMap = 0x158 // TMap<...> (Size: 0x50)
SGCharacterSenseAbilityComponent.bInTearGasArea = 0x1a8 // bool (Size: 0x1)
SGCharacterSenseAbilityComponent.bInSceneGasArea = 0x1a9 // bool (Size: 0x1)
SGCharacterSenseAbilityComponent.TearGasToxinValue = 0x1ac // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MaxTearGasToxinValue = 0x1b4 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.AddTearGasToxinStep = 0x1b8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.AddTearGasToxinStepCurve = 0x1c0 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.MinusTearGasToxinStep = 0x1c8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MinusTearGasToxinStepCurve = 0x1d0 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.SlightTearGasThreshold = 0x1d8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MediumTearGasThreshold = 0x1dc // float (Size: 0x4)
SGCharacterSenseAbilityComponent.bImmuneTearGas = 0x1e0 // bool (Size: 0x1)
SGCharacterSenseAbilityComponent.TearGasState = 0x1e1 // EECharacterTearGasStateType (Size: 0x1)
SGCharacterSenseAbilityComponent.TearGasToxinCalInterval = 0x1e4 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.CacheGasMask = 0x1e8 // SGInventory* (Size: 0x8)
SGCharacterSenseAbilityComponent.GasMaskResistanceByDurabililtyCurve = 0x1f0 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.InventoryFlashDebuffRemoveDelay = 0x278 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.SevereFlashBurnChangeVal = 0x280 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.ModerateFlashBurnChangeVal = 0x284 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MildFlashBurnChangeVal = 0x288 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.SevereFlashBurnDecreaseVal = 0x28c // float (Size: 0x4)
SGCharacterSenseAbilityComponent.ModerateFlashBurnDecreaseVal = 0x290 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MildFlashBurnDecreaseVal = 0x294 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.ChangeFlashBurnValCurve = 0x2a0 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.FlashLightRelativeLocation = 0x2a8 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.EffectScaleDistanceCurve = 0x2b0 // CurveFloat* (Size: 0x8)
SGCharacterSenseAbilityComponent.FlashBurnVal = 0x2b8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.MildFlashBurnThreshold = 0x2f0 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.ModerateFlashBurnThreshold = 0x2f4 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.SevereFlashBurnThreshold = 0x2f8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.InventoryFlashCauser = 0x300 // SGCharacter* (Size: 0x8)
SGCharacterSenseAbilityComponent.InMolotovValue = 0x324 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.ValidCallParadropTimePeriod = 0x328 // FVector2D (Size: 0x8)
SGCharacterSenseAbilityComponent.bNoMoreCallParadropNum = 0x330 // bool (Size: 0x1)
SGCharacterSenseAbilityComponent.EarCheckTimeInterval = 0x34c // float (Size: 0x4)
SGCharacterSenseAbilityComponent.BleedTags = 0x350 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.PainTags = 0x390 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.BoneBreakTags = 0x3d0 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.OutOfEnduranceTags = 0x410 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.TunnelVisionTags = 0x450 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.TrembleTags = 0x490 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.FreshWoundTags = 0x4d0 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.IsOverWeightTag = 0x510 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.IsCompleteOverWeightTag = 0x518 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.LackInMoistureTag = 0x520 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.LackInFoodTag = 0x528 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.LackInFoodSlightTag = 0x530 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.LackInFoodMediumTag = 0x538 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.TinnitusTag = 0x540 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.SlightTearGasTag = 0x548 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.MediumTearGasTag = 0x550 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.RegenerationTags = 0x558 // FCharacterGameEffectTags (Size: 0x40)
SGCharacterSenseAbilityComponent.PainInhibiteTag = 0x598 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.IsClearTag = 0x5a0 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.ExcitedTag = 0x5a8 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.FortitudeTag = 0x5b0 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.PoisonTag = 0x5b8 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.ActivityBeMarkedTag = 0x5c0 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.ActivityMarkTag = 0x5c8 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.HearingEnhanceTag = 0x5d0 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.HearingReduceTag = 0x5d8 // FGameplayTag (Size: 0x8)
SGCharacterSenseAbilityComponent.AttributeSetClass = 0x5e0 // ClassProperty (Size: 0x8)
SGCharacterSenseAbilityComponent.InhibiteSenseAbilityClasses = 0x5e8 // TMap<...> (Size: 0x50)
SGCharacterSenseAbilityComponent.BleedDurabilityCost = 0x638 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.BoneBreakDurabilityCost = 0x63c // float (Size: 0x4)
SGCharacterSenseAbilityComponent.OutOfEnduranceDurabilityCost = 0x640 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.InhibiteSenseAbilitySpecHandles = 0x648 // TMap<...> (Size: 0x50)
SGCharacterSenseAbilityComponent.BulletPassSenseRadius = 0x6a0 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.BulletPassCloseQuarterDistance = 0x6a4 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.BulletPassInterval = 0x6a8 // float (Size: 0x4)
SGCharacterSenseAbilityComponent.AbilitySystemComp = 0x6b0 // AbilitySystemComponent* (Size: 0x8)
SGCharacterSenseAbilityComponent.ThermalViewComp = 0x6b8 // SGPCThermalViewComponent* (Size: 0x8)
SGCharacterSenseAttributeSet.EarCover = 0x48 // float (Size: 0x4)
SGCharacterSenseAttributeSet.EarCoverMultiplier = 0x4c // float (Size: 0x4)
SGCharacterSenseAttributeSet.BleedAlpha = 0x50 // float (Size: 0x4)
SGCharacterSenseAttributeSet.HearingEnduranceMax = 0x54 // float (Size: 0x4)
SGCharacterSenseAttributeSet.HearingEndurance = 0x58 // float (Size: 0x4)
SGCharacterShadowAnimInstance.LocalProxy = 0x2c0 // FSGCharacterShadowAnimInstanceProxy (Size: 0x890)
SGCharacterShadowAnimInstanceProxy.CachedCastShadowComponent = 0x860 // SGCharacterCastShadowComponent* (Size: 0x8)
SGCharacterShadowAnimInstanceProxy.AORotationWithWeaponSway_OnlyYaw = 0x868 // FRotator (Size: 0xc)
SGCharacterShadowAnimInstanceProxy.AORotationWithWeaponSway_OnlyPitch = 0x874 // FRotator (Size: 0xc)
SGCharacterShadowAnimInstanceProxy.Enable_AO_1P = 0x880 // float (Size: 0x4)
SGCharacterShadowAnimInstanceProxy.bInOrTransTacticalPistolState = 0x884 // float (Size: 0x4)
SGCharacterSignalAttributeSet.SignalValue = 0x48 // float (Size: 0x4)
SGCharacterSignalAttributeSet.SignalValueMax = 0x4c // float (Size: 0x4)
SGCharacterSignificanceComponent.bEverEnable = 0x100 // bool (Size: 0x1)
SGCharacterSignificanceComponent.SignificanceManagerTag = 0x104 // FName (Size: 0x8)
SGCharacterSignificanceComponent.NonRenderedHighSignificance = 0x10c // float (Size: 0x4)
SGCharacterSignificanceComponent.NonRenderedLowSignificance = 0x110 // float (Size: 0x4)
SGCharacterSignificanceComponent.NonRenderedLowSignificanceDistance = 0x114 // float (Size: 0x4)
SGCharacterSignificanceComponent.TreatAsNonRenderedLowSignificanceForDeadTime = 0x118 // float (Size: 0x4)
SGCharacterSignificanceComponent.TreatAsNonRenderedHighSignificanceUnderLevel = 0x11c // float (Size: 0x4)
SGCharacterSignificanceComponent.bUseLoadBalance = 0x120 // bool (Size: 0x1)
SGCharacterSignificanceComponent.LoadBalanceBudgets = 0x128 // TArray<float> (Size: 0x10)
SGCharacterSignificanceComponent.MaxSignificanceDemoteValueForLoadBalance = 0x138 // float (Size: 0x4)
SGCharacterSignificanceComponent.CharacterMovementSignificanceBias = 0x13c // float (Size: 0x4)
SGCharacterSignificanceComponent.HighSignificanceMovingVelocity = 0x140 // float (Size: 0x4)
SGCharacterSignificanceComponent.LowestSignificanceForCharacterMovementWhileMovingWhenRendered = 0x144 // float (Size: 0x4)
SGCharacterSignificanceComponent.LowestSignificanceForCharacterMovementWhileMovingWhenNonRendered = 0x148 // float (Size: 0x4)
SGCharacterSignificanceComponent.bEnableCharacterMeshTickOptForNonRenderedLowSignificance = 0x14c // bool (Size: 0x1)
SGCharacterSignificanceComponent.LowSignificanceForCharacterMesh = 0x150 // float (Size: 0x4)
SGCharacterSignificanceManager.SignificanceVolumeManager = 0x208 // SGCompSignificanceVolumeManager* (Size: 0x8)
SGCharacterSignificanceManager.CompSigDataTable = 0x210 // DataTable* (Size: 0x8)
SGCharacterSignificanceManager.CompSigParamsMap = 0x218 // TMap<...> (Size: 0x50)
SGCharacterSignificanceManager.CachedViewtarget = 0x2f8 // SGCharacter* (Size: 0x8)
SGCharacterSignificanceManager.CachedPC = 0x300 // PlayerController* (Size: 0x8)
SGCharacterSignificanceManager.CachedWorld = 0x308 // World* (Size: 0x8)
SGCharacterSkillAttributeSet.SoundLevelInfluenceFactor = 0x48 // float (Size: 0x4)
SGCharacterSkillAttributeSet.SoundMaxDistanceInfluenceFactor = 0x4c // float (Size: 0x4)
SGCharacterSkillAttributeSet.SoundMaxDistanceInfluenceFactor_Battle = 0x50 // float (Size: 0x4)
SGCharacterSkillAttributeSet.SoundMaxDistanceInfluenceFactor_Character = 0x54 // float (Size: 0x4)
SGCharacterSkillAttributeSet.SoundIndicatorLevelInfluenceFactor = 0x58 // float (Size: 0x4)
SGCharacterSkillAttributeSet.SoundIndicatorMaxDistanceInfluenceFactor = 0x5c // float (Size: 0x4)
SGCharacterSkillAttributeSet.MedicalTypeRTPCValue = 0x60 // float (Size: 0x4)
SGCharacterSkillAttributeSet.ImmuneTearGas = 0x64 // float (Size: 0x4)
SGCharacterSkillComponent.AttributeSetClass = 0x100 // ClassProperty (Size: 0x8)
SGCharacterSlideComponent.SlideAngle = 0x100 // float (Size: 0x4)
SGCharacterSlideComponent.bIsSliding = 0x104 // bool (Size: 0x1)
SGCharacterSlideComponent.bRotateCharacterToVelcityDirection = 0x105 // bool (Size: 0x1)
SGCharacterSlideComponent.TraceDeltaDistance = 0x108 // float (Size: 0x4)
SGCharacterSlideComponent.bDrawDebug = 0x10c // bool (Size: 0x1)
SGCharacterSlideComponent.TriggerAngle = 0x110 // float (Size: 0x4)
SGCharacterSlideComponent.TraceDownDistance = 0x114 // float (Size: 0x4)
SGCharacterSlideComponent.SGCharacter = 0x118 // SGCharacter* (Size: 0x8)
SGCharacterSlideComponent.MovementComponent = 0x120 // CharacterMovementComponent* (Size: 0x8)
SGCharacterSmokeGrenadeEffectComponent.SmokeGrenadeCacheList = 0x100 // TArray<Actor*> (Size: 0x10)
SGCharacterSmokeGrenadeEffectComponent.SmokeEffectRadiusSq = 0x110 // float (Size: 0x4)
SGCharacterSmokeGrenadeEffectComponent.SmokeScreenMaterialTemplate = 0x118 // MaterialInstance* (Size: 0x8)
SGCharacterSmokeGrenadeEffectComponent.SmokeScreenMaterial = 0x120 // MaterialInstanceDynamic* (Size: 0x8)
SGCharacterSmokeGrenadeEffectComponent.DensityParamName = 0x128 // FName (Size: 0x8)
SGCharacterSmokeGrenadeEffectComponent.DesityTimeCurve = 0x130 // CurveFloat* (Size: 0x8)
SGCharacterSoundComponent.DeathGrunt = 0x100 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.GetHitGrunt = 0x108 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.GetArmorHitGrunt = 0x110 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.GetHitGruntCooldown = 0x118 // float (Size: 0x4)
SGCharacterSoundComponent.GruntMiddleThreshold = 0x11c // float (Size: 0x4)
SGCharacterSoundComponent.GruntHighThreshold = 0x120 // float (Size: 0x4)
SGCharacterSoundComponent.DBNOGrunt = 0x128 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.HearingSound = 0x130 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.BreathSound = 0x138 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.DyingEffectBeginEvent = 0x140 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.DyingEffectEndEvent = 0x148 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.TinnitusEffectBeginEvent = 0x150 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.TinnitusEffectEndEvent = 0x158 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.TinnitusRTPCName = 0x160 // FString (Size: 0x10)
SGCharacterSoundComponent.MaxTinnitusRTPC = 0x170 // float (Size: 0x4)
SGCharacterSoundComponent.TinnitusFadeoutTime = 0x174 // float (Size: 0x4)
SGCharacterSoundComponent.LandSoundForCharacterUsing3PAnim = 0x178 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.JumpSound = 0x180 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.LandSound = 0x188 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.CrouchSound = 0x190 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.ProneSound = 0x198 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.StandUpSound = 0x1a0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.LeanSound = 0x1a8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.LeanBackSound = 0x1b0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.LeanWithGunSound = 0x1b8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.LeanBackWithGunSound = 0x1c0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.DeathEffectSound = 0x1c8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.BulletHeadshotSound = 0x1d0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.BulletHitHelmetSound = 0x1d8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.BulletHitArmorSound = 0x1e0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.BulletHitBodySound = 0x1e8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.HitMarkerCoolDown = 0x1f0 // float (Size: 0x4)
SGCharacterSoundComponent.SelfHeadshotSound = 0x1f8 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.SelfHitHelmetSound = 0x200 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.SelfHitArmorSound = 0x208 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.SelfHitBodySound = 0x210 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.SelfRicochetSound = 0x218 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.SelfHitMarkerCoolDown = 0x220 // float (Size: 0x4)
SGCharacterSoundComponent.TDMRecoverSound = 0x228 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.GrenadeTakeHitAudioMap = 0x230 // TMap<...> (Size: 0x50)
SGCharacterSoundComponent.GrenadeHitMarkerAudioMap = 0x280 // TMap<...> (Size: 0x50)
SGCharacterSoundComponent.MoveInBushSound = 0x2d0 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.StopInBushSound = 0x2d8 // FString (Size: 0x10)
SGCharacterSoundComponent.EnvironmentInteractionCooldown = 0x2e8 // float (Size: 0x4)
SGCharacterSoundComponent.TickCullDistance = 0x2ec // int32_t (Size: 0x4)
SGCharacterSoundComponent.TickThresholdQuick = 0x2f0 // float (Size: 0x4)
SGCharacterSoundComponent.TickThresholdSlow = 0x2f4 // float (Size: 0x4)
SGCharacterSoundComponent.AngularVelocityRatio = 0x2f8 // float (Size: 0x4)
SGCharacterSoundComponent.PoseChangedInBushSpeed = 0x2fc // float (Size: 0x4)
SGCharacterSoundComponent.UpdateRainAccumulationInterval = 0x308 // float (Size: 0x4)
SGCharacterSoundComponent.RainAccumulationParameterName = 0x310 // FString (Size: 0x10)
SGCharacterSoundComponent.SnowAccumulationParameterName = 0x320 // FString (Size: 0x10)
SGCharacterSoundComponent.RTPCNames = 0x338 // TArray<FString> (Size: 0x10)
SGCharacterSoundComponent.RTPCNames_1P = 0x348 // TArray<FString> (Size: 0x10)
SGCharacterSoundComponent.RTPCNames_3P = 0x358 // TArray<FString> (Size: 0x10)
SGCharacterSoundComponent.MulticastCharacterVoiceCoolDown = 0x36c // float (Size: 0x4)
SGCharacterSoundComponent.CharacterVoiceEvent = 0x370 // AkAudioEvent* (Size: 0x8)
SGCharacterSoundComponent.Action_Turn_Curve = 0x378 // CurveFloat* (Size: 0x8)
SGCharacterSoundComponent.CachedCharacter = 0x384 // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterSoundComponent.fDistanceToListener = 0x38c // float (Size: 0x4)
SGCharacterSoundComponent.CachedHealthStatus = 0x390 // FString (Size: 0x10)
SGCharacterSoundComponent.CachedPlayerController = 0x3a0 // TWeakObjectPtr<UObject> (Size: 0x8)
SGCharacterSoundComponent.BreathSoundTimerHandle = 0x3b0 // FTimerHandle (Size: 0x8)
SGCharacterSoundComponent.BreathSoundIntervalDefault = 0x3b8 // float (Size: 0x4)
SGCharacterSoundComponent.CacheSoundSourceType = 0x3bc // EESoundSourceType (Size: 0x1)
SGCharacterSoundComponent.CharacterVoiceTimerHandle = 0x3c0 // FTimerHandle (Size: 0x8)
SGCharacterSoundComponent.IsUpdateInDoorSpatialEnable = 0x3c8 // bool (Size: 0x1)
SGCharacterSoundComponent.CurVirtualRoom = 0x3d8 // CAVirtualRoomComponent* (Size: 0x8)
SGCharacterSoundComponent.SenseComp = 0x3e0 // SGCharacterSenseAbilityComponent* (Size: 0x8)
SGCharacterSoundComponent.bIsPlayingBreathSound = 0x3fc // bool (Size: 0x1)
SGCharacterSoundComponent.bIsUnderDyingEffect = 0x3fd // bool (Size: 0x1)
SGCharacterSoundComponent.bIsLocalGamePlayer = 0x3fe // bool (Size: 0x1)
SGCharacterSoundComponent.bIsUnderTinnitusEffect = 0x3ff // bool (Size: 0x1)
SGCharacterSoundComponent.bIsMovingInBush = 0x400 // bool (Size: 0x1)
SGCharacterSoundComponent.CachedMovingStatus = 0x408 // FString (Size: 0x10)
SGCharacterSoundComponent.CachedEnergyStatus = 0x418 // FString (Size: 0x10)
SGCharacterSoundComponent.CachedWeightStatus = 0x428 // FString (Size: 0x10)
SGCharacterSoundComponent.CachedTinnitusRTPC = 0x438 // float (Size: 0x4)
SGCharacterSoundComponent.CachedUseItemStatus = 0x440 // FString (Size: 0x10)
SGCharacterSoundComponent.RefreshArmorTimerHandle = 0x470 // FTimerHandle (Size: 0x8)
SGCharacterSoundComponent.EmitterListenerManager = 0x490 // EmitterListenerManager* (Size: 0x8)
SGCharacterSoundComponent.SuppressorRTPCParameterName = 0x498 // FString (Size: 0x10)
SGCharacterSoundComponent.SuppressorRTPCDefaultValue = 0x4a8 // float (Size: 0x4)
SGCharacterSoundComponent.CurWeaponSuppressorType = 0x4ac // EESGGunSilencerType (Size: 0x1)
SGCharacterSoundComponent.SuppressorRTPCValue = 0x4b0 // float (Size: 0x4)
SGCharacterSoundComponent.CachedListenerWeapon = 0x4b8 // SGInventory* (Size: 0x8)
SGCharacterSoundComponent.CurrentWeaponSwitchGroupName = 0x4d0 // FString (Size: 0x10)
SGCharacterSoundComponent.CurrentWeaponSwitchName_MainWeapon = 0x4e0 // FString (Size: 0x10)
SGCharacterSoundComponent.CurrentWeaponSwitchName_AssistWeapon = 0x4f0 // FString (Size: 0x10)
SGCharacterSoundComponent.CurrentWeaponSwitchName_MeleeWeapon = 0x500 // FString (Size: 0x10)
SGCharacterSoundComponent.CurrentWeaponSwitchName_ThrowWeapon = 0x510 // FString (Size: 0x10)
SGCharacterSoundComponent.CurrentWeaponSwitchName_EmptyHand = 0x520 // FString (Size: 0x10)
SGCharacterSoundComponent.HypoxiaDuration = 0x530 // float (Size: 0x4)
SGCharacterSoundComponent.AnimNotifySoundCoolingDownTimeMap = 0x588 // TMap<...> (Size: 0x50)
SGCharacterSoundComponent.AnimNotifySoundCoolingDownTimeMap3P = 0x5d8 // TMap<...> (Size: 0x50)
SGCharacterSpectatingComponent.UIOpInfo = 0x100 // FUIOpStruct (Size: 0x10)
SGCharacterSpectatingComponent.bSpectated = 0x110 // bool (Size: 0x1)
SGCharacterSpringAnimInstanceProxy_HD.bAiming = 0x860 // bool (Size: 0x1)
SGCharacterSpringAnimInstanceProxy_HD.AimingAlignAlpha = 0x864 // float (Size: 0x4)
SGCharacterSpringAnimInstanceProxy_HD.bInTacticalState = 0x868 // bool (Size: 0x1)
SGCharacterSpringAnimInstanceProxy_HD.bAimingTMValid = 0x869 // bool (Size: 0x1)
SGCharacterSpringAnimInstanceProxy_HD.HandTranslation = 0x86c // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.HandRotation = 0x878 // FRotator (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.HandPivotRotation = 0x884 // FRotator (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.RecoilPivotRotation = 0x890 // FRotator (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.RecoilPivot = 0x89c // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.WeaponSwayTranslation = 0x8a8 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.WeaponSwayRotation = 0x8b4 // FRotator (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.WeaponShakeTranslation = 0x8c0 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.WeaponShakePivotRotation = 0x8cc // FRotator (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.WeaponShakePivot = 0x8d8 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.CameraRecoilTranslation = 0x8e4 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.AimingAlignPivot = 0x8f0 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.AimingTransform = 0x900 // FTransform (Size: 0x30)
SGCharacterSpringAnimInstanceProxy_HD.CameraTranslation = 0x930 // FVector (Size: 0xc)
SGCharacterSpringAnimInstanceProxy_HD.AimingAlignSpeed = 0x93c // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.LocalProxy = 0x2c0 // FSGCharacterSpringAnimInstanceProxy_HD (Size: 0x940)
SGCharacterSpringAnimInstance_HD.CharacterOwner = 0xc00 // SGCharacter* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.HandTranslationSpring = 0xc10 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.HandRotationSpring = 0xd20 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.CameraTranslationSpring = 0xe30 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.CameraRotationSpring = 0xf40 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.WeaponSwaySpring = 0x1050 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.FlinchSpring = 0x1160 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.RecoilSpring = 0x1270 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.SpreadSpring = 0x1380 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.CameraRecoilTranslationSpring = 0x1490 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.CameraRecoilRotationSpring = 0x15a0 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.WeaponShakeTranslationSpring = 0x16b0 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.WeaponShakeRotationSpring = 0x17c0 // FAnimationSpring (Size: 0x110)
SGCharacterSpringAnimInstance_HD.FixedTickSpringInterval = 0x18d0 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.RecoilModifer = 0x1900 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.SpreadModifer = 0x19b0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.RecoilCameraTranslationModifier = 0x1a80 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.RecoilCameraRotationModifier = 0x1b30 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.RecoilWeaponShakeModifier = 0x1be0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.RecoilRecoverAssistThresholdForTrack = 0x1c90 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.ContinuousFireMaxTimeGap = 0x1c94 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.SimulateViewRotationSmoothSpeed = 0x1c98 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.SimulateViewRotationSmoothSpeedKeepTime = 0x1c9c // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.SimulateViewRotationSmoothSpeedBlendOutTime = 0x1ca0 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.BreathHandTranslationModifier = 0x1cc0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.BreathHandRotationModifier = 0x1d70 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.BreathCameraTranslationModifier = 0x1e20 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.BreathCameraRotationModifier = 0x1ed0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.WaggleHandRotationModifier = 0x1f80 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.HoldingBreathScale = 0x2030 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.ExhaustedScale = 0x2034 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.HypoxiaHandAmplitudeScale = 0x2038 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterSpringAnimInstance_HD.HypoxiaCameraAmplitudeScale = 0x20c0 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterSpringAnimInstance_HD.FlinchTightenScale = 0x215c // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.MaxViewRotateSpeed = 0x2160 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.RotateVelocityTrack = 0x2168 // FValueTracker (Size: 0x28)
SGCharacterSpringAnimInstance_HD.RotateVelocitySmooth = 0x2190 // FSmoothDamper (Size: 0x28)
SGCharacterSpringAnimInstance_HD.RotateVelocityIntensity = 0x21c0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.RotateAccelerationTrack = 0x21d0 // FValueTracker (Size: 0x28)
SGCharacterSpringAnimInstance_HD.RotateAccelerationSmooth = 0x21f8 // FSmoothDamper (Size: 0x28)
SGCharacterSpringAnimInstance_HD.RotateAccelerationIntensity = 0x2220 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.ViewRotationIntensity = 0x2230 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.ViewRotationModifier = 0x2240 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.ViewRotationStrengthCurve = 0x22f0 // FRuntimeFloatCurve (Size: 0x88)
SGCharacterSpringAnimInstance_HD.bUseStrengthCurve = 0x2378 // bool (Size: 0x1)
SGCharacterSpringAnimInstance_HD.WalkHandTranslationIntensity = 0x2394 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.WalkHandRotationIntensity = 0x23a0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.AdsWalkHandTranslationIntensity = 0x23b0 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.AdsWalkHandRotationIntensity = 0x23c0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.WalkCameraTranslationIntensity = 0x23d0 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.WalkCameraRotationIntensity = 0x23e0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.AdsWalkCameraTranslationIntensity = 0x23f0 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.AdsWalkCameraRotationIntensity = 0x2400 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.WalkCameraTranslationModifier = 0x2410 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.WalkCameraRotationModifier = 0x24c0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.LandingCameraRotationIntensity = 0x2570 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.ErgonomicsToADSWalkHandTranslationScale = 0x2578 // CurveVector* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.WalkCameraTranslationScaleMap = 0x2580 // TMap<...> (Size: 0x50)
SGCharacterSpringAnimInstance_HD.WalkCameraTranslationScaleMap_ADS = 0x25d0 // TMap<...> (Size: 0x50)
SGCharacterSpringAnimInstance_HD.WalkCameraRotationScaleMap = 0x2620 // TMap<...> (Size: 0x50)
SGCharacterSpringAnimInstance_HD.WalkCameraRotationScaleMap_ADS = 0x2670 // TMap<...> (Size: 0x50)
SGCharacterSpringAnimInstance_HD.WeaponStabilityToWalkHandScaleCurve = 0x26c0 // CurveLinearColor* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.WeaponStabilityToWalkCameraScaleCurve = 0x26c8 // CurveLinearColor* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.WeaponStabilityToAdsWalkHandScaleCurve = 0x26d0 // CurveLinearColor* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.WeaponStabilityToAdsWalkCameraScaleCurve = 0x26d8 // CurveLinearColor* (Size: 0x8)
SGCharacterSpringAnimInstance_HD.HitUpForceScaleRange = 0x2728 // FVector2D (Size: 0x8)
SGCharacterSpringAnimInstance_HD.HitDispersion = 0x2730 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.HitHandTranslationIntensity = 0x2734 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.HitHandRotationIntensity = 0x2740 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.HitCameraTranslationIntensity = 0x2750 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.HitCameraRotationIntensity = 0x2760 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.HitModifer = 0x2770 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.BulletproofScale = 0x2820 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.HitCooldownRange = 0x2824 // FVector2D (Size: 0x8)
SGCharacterSpringAnimInstance_HD.FlinchDuration = 0x2830 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.FlinchCooldown = 0x2834 // float (Size: 0x4)
SGCharacterSpringAnimInstance_HD.FlinchIntensity = 0x2840 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.FlinchModifier = 0x2850 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.InertanceHandTranslationIntensity = 0x2920 // FVector (Size: 0xc)
SGCharacterSpringAnimInstance_HD.InertanceHandTranslationModifier = 0x2930 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.InertancHandRotationIntensity = 0x29e0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.InertanceHandRotationModifier = 0x29f0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.InertanceCameraTranslationIntensity = 0x2aa0 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.InertanceCameraTranslationModifier = 0x2ab0 // FForceModifier (Size: 0xb0)
SGCharacterSpringAnimInstance_HD.InertanceCameraRotationIntensity = 0x2b60 // FVector4 (Size: 0x10)
SGCharacterSpringAnimInstance_HD.InertanceCameraRotationModifier = 0x2b70 // FForceModifier (Size: 0xb0)
SGCharacterSprintComponent.SprintMinSpeed = 0x108 // float (Size: 0x4)
SGCharacterSprintComponent.SprintTranslationADSCurve = 0x110 // CurveVector* (Size: 0x8)
SGCharacterSprintComponent.SprintRotationADSCurve = 0x118 // CurveVector* (Size: 0x8)
SGCharacterSprintComponent.Ergonomic_AlphaCurve = 0x120 // CurveFloat* (Size: 0x8)
SGCharacterSprintComponent.SprintAccelerationCurve = 0x128 // CurveFloat* (Size: 0x8)
SGCharacterSprintComponent.SprintAcceWeightScaleCurve = 0x130 // CurveFloat* (Size: 0x8)
SGCharacterSprintComponent.SprintMaxSpeedLowerLimit = 0x138 // float (Size: 0x4)
SGCharacterSprintComponent.bEnableSprintAccelerationCurve = 0x13c // bool (Size: 0x1)
SGCharacterSprintComponent.bSprinting = 0x13d // bool (Size: 0x1)
SGCharacterSprintComponent.SprintingTime = 0x140 // float (Size: 0x4)
SGCharacterSprintComponent.SprintStateChangeInterval = 0x148 // float (Size: 0x4)
SGCharacterSprintComponent.SprintChangedEvents = 0x150 // SGCharacterEvents* (Size: 0x8)
SGCharacterSprintComponent.CannotMoveTimeThreshold = 0x174 // float (Size: 0x4)
SGCharacterStunGrenadeEffectComponent.bIsStunning = 0x100 // bool (Size: 0x1)
SGCharacterStunGrenadeEffectComponent.StunEndTime = 0x104 // float (Size: 0x4)
SGCharacterStunGrenadeEffectComponent.StunDuration = 0x108 // float (Size: 0x4)
SGCharacterStunGrenadeEffectComponent.MoveSpeedScale = 0x10c // float (Size: 0x4)
SGCharacterStunGrenadeEffectComponent.SensitivityScale = 0x110 // float (Size: 0x4)
SGCharacterStunGrenadeEffectComponent.StunGrenadeDeafAudioEvents = 0x118 // TArray<AkAudioEvent*> (Size: 0x10)
SGCharacterSwimComponent.RestrictCrouchMessageID = 0x100 // int32_t (Size: 0x4)
SGCharacterSwimComponent.RestrictProneMessageID = 0x104 // int32_t (Size: 0x4)
SGCharacterSwimComponent.MoveInWaterAudioEvent = 0x108 // AkAudioEvent* (Size: 0x8)
SGCharacterSwimComponent.MoveInWaterPS = 0x110 // ParticleSystem* (Size: 0x8)
SGCharacterSwimComponent.MoveInWaterPSEmitterOffset = 0x118 // FVector (Size: 0xc)
SGCharacterSwimComponent.UnitWalkLength = 0x124 // float (Size: 0x4)
SGCharacterSwimComponent.RestrictCrouchWaterDepth = 0x128 // float (Size: 0x4)
SGCharacterSwimComponent.RestrictProneWaterDepth = 0x12c // float (Size: 0x4)
SGCharacterSwimComponent.bRestrictActionOnlyWhenAlreadyInWater = 0x130 // bool (Size: 0x1)
SGCharacterSwimComponent.bAlwaysUseCurrentGroundLocationZ = 0x131 // bool (Size: 0x1)
SGCharacterSwimComponent.CachedWaterActorList = 0x138 // TArray<Actor*> (Size: 0x10)
SGCharacterTacticalPistolComponent.CanUseTacticalPistol = 0x100 // bool (Size: 0x1)
SGCharacterTacticalPistolComponent.TacticalMainWeaponSocketName = 0x104 // FName (Size: 0x8)
SGCharacterTacticalPistolComponent.TacticalAssistSocketName = 0x10c // FName (Size: 0x8)
SGCharacterTacticalPistolComponent.Transition_B_GATags = 0x118 // FGameplayTagContainer (Size: 0x20)
SGCharacterTacticalPistolComponent.Transition_B_Fast_GATags = 0x138 // FGameplayTagContainer (Size: 0x20)
SGCharacterTacticalPistolComponent.Transition_C_GATags = 0x158 // FGameplayTagContainer (Size: 0x20)
SGCharacterTacticalPistolComponent.Transition_Instantly = 0x178 // FGameplayTagContainer (Size: 0x20)
SGCharacterTacticalPistolComponent.bTacticalPistol = 0x198 // bool (Size: 0x1)
SGCharacterTacticalPistolComponent.bLastInOrTransTacticalPistol = 0x199 // bool (Size: 0x1)
SGCharacterTacticalPistolComponent.CurrentTacticalRepInfo = 0x1a0 // FTacticalPistolRepInfo (Size: 0x20)
SGCharacterTacticalPistolComponent.LocalLeftHandWeapon = 0x1c0 // SGInventory* (Size: 0x8)
SGCharacterTacticalPistolComponent.LocalRightHandWeapon = 0x1c8 // SGInventory* (Size: 0x8)
SGCharacterTakeCoverComponent.bAutoTakeCover = 0x100 // bool (Size: 0x1)
SGCharacterTakeCoverComponent.TraceDistance = 0x104 // float (Size: 0x4)
SGCharacterTakeCoverComponent.StandCoverDetectHeigh = 0x108 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CrouchCoverDetectHeigh = 0x10c // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverDetectWidthHalf = 0x110 // float (Size: 0x4)
SGCharacterTakeCoverComponent.TriggerDistance = 0x114 // float (Size: 0x4)
SGCharacterTakeCoverComponent.EndTakeCoverControllerAngle = 0x118 // float (Size: 0x4)
SGCharacterTakeCoverComponent.StartTakeCoverMaxVelocity = 0x11c // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverResetRotationTriggerAngle = 0x120 // float (Size: 0x4)
SGCharacterTakeCoverComponent.TakeCoverCDTime = 0x124 // float (Size: 0x4)
SGCharacterTakeCoverComponent.QuitCoverInputTime = 0x128 // float (Size: 0x4)
SGCharacterTakeCoverComponent.bIsTakingCover = 0x12c // bool (Size: 0x1)
SGCharacterTakeCoverComponent.TraceChannel = 0x12d // uint8_t (Size: 0x1)
SGCharacterTakeCoverComponent.bDrawDebug = 0x12e // bool (Size: 0x1)
SGCharacterTakeCoverComponent.bLeanLeft = 0x12f // bool (Size: 0x1)
SGCharacterTakeCoverComponent.bWantLeanLeft = 0x130 // bool (Size: 0x1)
SGCharacterTakeCoverComponent.bLimitCharacterLocation = 0x131 // bool (Size: 0x1)
SGCharacterTakeCoverComponent.CurrToCoverDistance = 0x134 // float (Size: 0x4)
SGCharacterTakeCoverComponent.QuitCoverAccAngleCos = 0x138 // float (Size: 0x4)
SGCharacterTakeCoverComponent.bAutoCrouch = 0x13c // bool (Size: 0x1)
SGCharacterTakeCoverComponent.bAutoSwitchWeaponHand = 0x13d // bool (Size: 0x1)
SGCharacterTakeCoverComponent.CoverEdgeDectectSideOffset = 0x140 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverEdgeDectectHeighOffset = 0x144 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverAimAnimationTime = 0x148 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverFireAnimationTime = 0x14c // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverAimFireBackDistance = 0x150 // float (Size: 0x4)
SGCharacterTakeCoverComponent.TranslationAnimPlayProgress = 0x154 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverAimTraceRadius = 0x158 // float (Size: 0x4)
SGCharacterTakeCoverComponent.AimPointToEdgeDistance = 0x15c // float (Size: 0x4)
SGCharacterTakeCoverComponent.SideAimMaxYaw = 0x160 // float (Size: 0x4)
SGCharacterTakeCoverComponent.bSideAimingAutoSwitchToForward = 0x164 // bool (Size: 0x1)
SGCharacterTakeCoverComponent.StandHeightMax = 0x168 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CrouchHeightMax = 0x16c // float (Size: 0x4)
SGCharacterTakeCoverComponent.CrouchHeightMin = 0x170 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverHeightValue = 0x174 // float (Size: 0x4)
SGCharacterTakeCoverComponent.bTakeCoverStandBy = 0x178 // bool (Size: 0x1)
SGCharacterTakeCoverComponent.MoveForwardDeadZoneAngle = 0x17c // float (Size: 0x4)
SGCharacterTakeCoverComponent.ControlFollowCameraAngle = 0x180 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverStandMoveSpeedScale = 0x184 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverCrouchMoveSpeedScale = 0x188 // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverSwitchLeanSideInputTime = 0x18c // float (Size: 0x4)
SGCharacterTakeCoverComponent.CoverSideToTopTriggerAngle = 0x190 // float (Size: 0x4)
SGCharacterTakeCoverComponent.TakeCoverType = 0x194 // EESGCoverType (Size: 0x1)
SGCharacterTakeCoverComponent.CoverHeight = 0x195 // EESGCoverHeight (Size: 0x1)
SGCharacterTakeCoverComponent.CharacterCoverAimingState = 0x196 // EESGCharacterCoverAimingState (Size: 0x1)
SGCharacterTakeCoverComponent.CharacterCoverState = 0x197 // EESGCharacterCoverState (Size: 0x1)
SGCharacterTakeCoverComponent.CharacterAimFireTargetLocation = 0x198 // FVector (Size: 0xc)
SGCharacterTakeCoverComponent.CharacterOriginLocation = 0x1a4 // FVector (Size: 0xc)
SGCharacterTakeCoverComponent.SGCharacter = 0x1b8 // SGCharacter* (Size: 0x8)
SGCharacterTakeCoverComponent.CurrCoverActor = 0x200 // Actor* (Size: 0x8)
SGCharacterTakeCoverComponent.PreCoverActor = 0x208 // Actor* (Size: 0x8)
SGCharacterTakeDamageComponent.bDamageHurtsHealth = 0x110 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.bDebugDamage = 0x111 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.bDebugGrenadeDamage = 0x112 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.bTeamGrenadeHarmEnable = 0x113 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.bFactionGrenadeHarmEnable = 0x114 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.Config = 0x118 // SGConfigUtil* (Size: 0x8)
SGCharacterTakeDamageComponent.LastHitByDamageEventObject = 0x120 // DamageEventObject* (Size: 0x8)
SGCharacterTakeDamageComponent.LastEventInstigator = 0x128 // Controller* (Size: 0x8)
SGCharacterTakeDamageComponent.ConfigClass = 0x130 // ClassProperty (Size: 0x8)
SGCharacterTakeDamageComponent.bEnableTeammateDamage = 0x138 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.bDebugHitPhyMaterial = 0x139 // bool (Size: 0x1)
SGCharacterTakeDamageComponent.HitPartInfoLookupTable = 0x140 // TArray<FHitPartInfo> (Size: 0x10)
SGCharacterTakeDamageComponent.HitMaterialToHitPartInfoMap = 0x150 // TMap<...> (Size: 0x50)
SGCharacterTakeDamageComponent.HitGroupToHitPartInfoMap = 0x1a0 // TMap<...> (Size: 0x50)
SGCharacterTakeDamageComponent.TakeDamageHistory = 0x1f0 // TArray<FTakeDamageRecord> (Size: 0x10)
SGCharacterTakeDamageComponent.FakeKillerStaticData = 0x200 // FKillerStaticData (Size: 0x198)
SGCharacterTakeDamageComponent.FakeKilledStaticData = 0x398 // FKilledStaticData (Size: 0x88)
SGCharacterTakeDamageComponent.HitArmorId = 0x420 // uint64_t (Size: 0x8)
SGCharacterTakeDamageComponent.HitArmorDurability = 0x428 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitAnimationInfo = 0x100 // FSGTakeHitInfo (Size: 0x20)
SGCharacterTakeHitEffectComponent.PreviousTakeHitPlayReactionTime = 0x120 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitPlayReactionTime = 0x124 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitReactionInterval = 0x128 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.bUseTakeHitAnimation = 0x12c // bool (Size: 0x1)
SGCharacterTakeHitEffectComponent.TakeHitAnimationLength = 0x130 // int32_t (Size: 0x4)
SGCharacterTakeHitEffectComponent.MinRandomFrame = 0x134 // int32_t (Size: 0x4)
SGCharacterTakeHitEffectComponent.MaxRandomFrame = 0x138 // int32_t (Size: 0x4)
SGCharacterTakeHitEffectComponent.HeadTakeHitAnimationPlayRate = 0x13c // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.ChestTakeHitAnimationPlayRate = 0x140 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.LeftArmTakeHitAnimationPlayRate = 0x144 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.RightArmTakeHitAnimationPlayRate = 0x148 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.LeftLegTakeHitAnimationPlayRate = 0x14c // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.RightLegTakeHitAnimationPlayRate = 0x150 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitAnimationAlpha = 0x154 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitImpulseMagnitudeScaler = 0x158 // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.TakeHitPhysicStateDuration = 0x15c // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.HeadTakeHitSimulateRoot = 0x160 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.ChestTakeHitSimulateRoot = 0x168 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.LeftArmTakeHitSimulateRoot = 0x170 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.RightArmTakeHitSimulateRoot = 0x178 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.LeftLegTakeHitSimulateRoot = 0x180 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.RightLegTakeHitSimulateRoot = 0x188 // FName (Size: 0x8)
SGCharacterTakeHitEffectComponent.TakeHitPhysicAnimationBlendWeight = 0x190 // CurveFloat* (Size: 0x8)
SGCharacterTakeHitEffectComponent.bEnableBlood = 0x198 // bool (Size: 0x1)
SGCharacterTakeHitEffectComponent.PlayHapticDamageValue = 0x19c // float (Size: 0x4)
SGCharacterTakeHitEffectComponent.RepTakeHitInfo = 0x1a0 // FRepTakeHitInfo (Size: 0xf8)
SGCharacterTeamComponent.Team = 0x100 // SGTeamInfo* (Size: 0x8)
SGCharacterTeamRescueComponent.FindRescueTargetInterval = 0x104 // float (Size: 0x4)
SGCharacterTeamRescueComponent.MaxRescueTeammateDist = 0x108 // float (Size: 0x4)
SGCharacterTeamRescueComponent.Duration = 0x10c // float (Size: 0x4)
SGCharacterTeamRescueComponent.CrouchDelayTime = 0x110 // float (Size: 0x4)
SGCharacterTeamRescueComponent.InterpSpeed_Location = 0x114 // float (Size: 0x4)
SGCharacterTeamRescueComponent.InterpSpeed_ControlRotation = 0x118 // float (Size: 0x4)
SGCharacterTeamRescueComponent.RescuerRibCageBoneName = 0x11c // FName (Size: 0x8)
SGCharacterTeamRescueComponent.RescueeRibCageBoneName = 0x124 // FName (Size: 0x8)
SGCharacterTeamRescueComponent.AlternativeRescueInventory = 0x130 // SGInventory* (Size: 0x8)
SGCharacterTeamRescueComponent.RefreshRescueUIDelay = 0x138 // float (Size: 0x4)
SGCharacterTeamRescueComponent.bJustLeaveDBNOStatus = 0x148 // bool (Size: 0x1)
SGCharacterTeamRescueComponent.CachedRescuer = 0x150 // Character* (Size: 0x8)
SGCharacterTeamRescueComponent.CachedRescuee = 0x158 // Character* (Size: 0x8)
SGCharacterTeamRescueComponent.CachedWeapon = 0x160 // SGInventory* (Size: 0x8)
SGCharacterTeamRescueComponent.bIsRescuingTeammate = 0x168 // bool (Size: 0x1)
SGCharacterTeamRescueComponent.bIsBeRescuingByTeammate = 0x169 // bool (Size: 0x1)
SGCharacterTeamRescueComponent.bIsPlayRescueProcess = 0x16a // bool (Size: 0x1)
SGCharacterTeamRescueComponent.RescueTimeScale = 0x16c // float (Size: 0x4)
SGCharacterTeamRescueComponent.InventorySkeletalMeshComponent = 0x170 // SkeletalMeshComponent* (Size: 0x8)
SGCharacterTestDamageComponent.TextRenderComp = 0x100 // TextRenderComponent* (Size: 0x8)
SGCharacterTestDamageComponent.WholeDamageInfo = 0x168 // FString (Size: 0x10)
SGCharacterTestDamageComponent.KillerController = 0x178 // Controller* (Size: 0x8)
SGCharacterTestDamageComponent.bShowDamageTextUpHead = 0x184 // bool (Size: 0x1)
SGCharacterTestDamageComponent.bShowAvatarInfo = 0x185 // bool (Size: 0x1)
SGCharacterTestDamageComponent.InfoStrings = 0x188 // TArray<FString> (Size: 0x10)
SGCharacterTestDamageComponent.LatestKillDamageInfo = 0x198 // FString (Size: 0x10)
SGCharacterTurnComponent.DefaultTurningActionTime = 0x358 // float (Size: 0x4)
SGCharacterTurnComponent.ProneTurnningActionTime = 0x35c // float (Size: 0x4)
SGCharacterTurnComponent.DefaultTurningAngle = 0x360 // float (Size: 0x4)
SGCharacterTurnComponent.ProneTruningAngle = 0x364 // float (Size: 0x4)
SGCharacterTurnComponent.bUseConstTurnInterp = 0x368 // bool (Size: 0x1)
SGCharacterTurnComponent.ConstRotateSpeed = 0x36c // float (Size: 0x4)
SGCharacterTurnComponent.RotateSpeed = 0x370 // float (Size: 0x4)
SGCharacterTurnComponent.TurningProgress = 0x374 // float (Size: 0x4)
SGCharacterTurnComponent.bLockedRotation = 0x378 // bool (Size: 0x1)
SGCharacterTurnComponent.bDisableTurningProcess = 0x379 // bool (Size: 0x1)
SGCharacterTurnComponent.bUsingAnimRotationCurve = 0x37a // bool (Size: 0x1)
SGCharacterTurnComponent.RootMotionRotationCurveName = 0x37c // FName (Size: 0x8)
SGCharacterTurnComponent.RootMotionTurn = 0x384 // float (Size: 0x4)
SGCharacterTurnComponent.RotationTolerance = 0x388 // float (Size: 0x4)
SGCharacterTurnComponent.StandingStillTransitionTime = 0x38c // float (Size: 0x4)
SGCharacterTurnComponent.bEnableImmediateTurnInADS = 0x3ac // bool (Size: 0x1)
SGCharacterVehicleComponent.CharacterVehicleReplicationData = 0x100 // FSGCharacterVehicleReplicationData (Size: 0x38)
SGCharacterVehicleComponent.Vehicle = 0x138 // Pawn* (Size: 0x8)
SGCharacterVehicleComponent.ClosestVehicle = 0x140 // Pawn* (Size: 0x8)
SGCharacterVehicleReplicationData.SyncType = 0x0 // EESGCharacterVehicleSyncType (Size: 0x1)
SGCharacterVehicleReplicationData.Vehicle = 0x8 // Pawn* (Size: 0x8)
SGCharacterVehicleReplicationData.SeatIndex = 0x10 // int32_t (Size: 0x4)
SGCharacterVehicleReplicationData.ExitLocation = 0x14 // FVector (Size: 0xc)
SGCharacterVehicleReplicationData.ExitRotation = 0x20 // FRotator (Size: 0xc)
SGCharacterVehicleReplicationData.LastVehicle = 0x30 // Pawn* (Size: 0x8)
SGCharacterWeaponAnimInstance.LocalProxy = 0x2c0 // FSGCharacterWeaponAnimInstanceProxy (Size: 0x860)
SGCharacterWeaponAnimInstance.CharacterOwner = 0xb20 // SGCharacter* (Size: 0x8)
SGCharacterWeaponAnimInstance.Weapon = 0xb28 // SGWeapon* (Size: 0x8)
SGCharacterWeaponAnimInstance.CharacterAnimMotions = 0xb30 // TMap<...> (Size: 0x50)
SGCharacterWeaponAnimInstance.CameraAnimMotions = 0xb80 // TMap<...> (Size: 0x50)
SGCharacterWeaponAnimInstance.ControllerAnimMotions = 0xbd0 // TMap<...> (Size: 0x50)
SGCharacterWeaponAnimInstance.AutoResetOnFireEndAnimMotions = 0xc70 // TArray<FName> (Size: 0x10)
SGCharacterWeaponAnimInstance.ShotCountResetDelay = 0xc80 // float (Size: 0x4)
SGCharacterWeaponAnimInstance.ShotCount = 0xcc0 // int32_t (Size: 0x4)
SGCharacterWeaponAnimInstance.RecoilRecoverAssistAnimMotions = 0xcc8 // TArray<FName> (Size: 0x10)
SGCharacterWeaponAnimInstance.RecoilRecoverAssistThresholdForTrack = 0xcd8 // float (Size: 0x4)
SGCharacterWeaponAnimInstance.SimulateViewRotationSmoothSpeed = 0xcdc // float (Size: 0x4)
SGCharacterWeaponAnimInstance.SimulateViewRotationSmoothSpeedKeepTime = 0xce0 // float (Size: 0x4)
SGCharacterWeaponAnimInstance.SimulateViewRotationSmoothSpeedBlendOutTime = 0xce4 // float (Size: 0x4)
SGCharacterWeaponAttachComponent.WeaponBackAttachSockets = 0x100 // TArray<FString> (Size: 0x10)
SGCharacterWeaponAttachComponent.WeaponAttachInvMeshComponents = 0x110 // TArray<MeshComponent*> (Size: 0x10)
SGCharacterWeaponAttachComponent.WeaponAttachSexTypes = 0x120 // TArray<EECharacterSex> (Size: 0x10)
SGCharacterWeaponAttachComponent.bIsNeedRefresh = 0x130 // bool (Size: 0x1)
SGCharacterWeaponAttachComponent.AttachedInventorySocketIndexMap = 0x138 // TArray<FWeaponAttachInfoStruct> (Size: 0x10)
SGCharacterWeaponAttachComponent.AttachSocketOffsets = 0x148 // TMap<...> (Size: 0x50)
SGCharacterWeaponAttachComponent.bForceWeaponHangToCharacter = 0x1d1 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.OnInteruptBackswingEvent = 0x108 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterWeaponManagerComponent.bInteruptBackswing = 0x118 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.CachedDestWeaponInteruptBackswing = 0x120 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.CarriedAmmoList = 0x1d0 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.EmptyHandInvClass = 0x1e0 // ClassProperty (Size: 0x8)
SGCharacterWeaponManagerComponent.EmptyHand = 0x1e8 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.LeftHandWeapon = 0x1f0 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.CurrentWeapon = 0x1f8 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.TacticalWeapon = 0x200 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.CurrentWeaponChangeInfo = 0x208 // FSGWeaponChangedInfo (Size: 0xb0)
SGCharacterWeaponManagerComponent.bIsAutoTakeUpWhenSwitchNewMeleeWeapon = 0x2b9 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.LastUsedLeftHandWeapon = 0x2c0 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.CurrentThrowWeapon = 0x2c8 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.CurrentSpecialWeapon = 0x2d0 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.LastUsedWeapon = 0x2d8 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.LastUsedWeaponWhenUseInventory = 0x2e0 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.LastNoneThrowableWeapon = 0x2e8 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.bInfiniteAmmo = 0x2f0 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.bInfiniteReload = 0x2f1 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.bEnableAutoGive = 0x2f2 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.MainWeaponList = 0x300 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.ThrowWeaponList = 0x310 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.SpecialWeaponList = 0x320 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.CarriedMagazineList = 0x330 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.WeaponList = 0x340 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.AllMagazineList = 0x350 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.AllAmmoList = 0x360 // TArray<SGInventory*> (Size: 0x10)
SGCharacterWeaponManagerComponent.AttributeSetClass = 0x370 // ClassProperty (Size: 0x8)
SGCharacterWeaponManagerComponent.fBallisticEffectAngle = 0x378 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.MaxBulletPassByDistance = 0x37c // float (Size: 0x4)
SGCharacterWeaponManagerComponent.MaxBulletPassByDistanceInHud = 0x380 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.MaxFillContainerTimeScale = 0x384 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.ZoomingAlphaWhenLean = 0x388 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.ZoomingAlphaWhenProne = 0x38c // float (Size: 0x4)
SGCharacterWeaponManagerComponent.ZoomingAlpha = 0x390 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.bCanReloadDuringCheckMag = 0x394 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.ReloadStartTimeDuringCheckMag = 0x398 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.Curve_SwitchWeaponRate_ErgonomicsScale = 0x3b8 // CurveFloat* (Size: 0x8)
SGCharacterWeaponManagerComponent.SwitchWeaponRate_ItemTypeScale = 0x3c0 // TMap<...> (Size: 0x50)
SGCharacterWeaponManagerComponent.StashedDestWeapon = 0x428 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.DefaultEquipWeaponClass = 0x430 // ClassProperty (Size: 0x8)
SGCharacterWeaponManagerComponent.bDefaultEquipWeaponInfiniteFire = 0x438 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.bForcePullBoltReady = 0x439 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.KeepFireTimeHandler = 0x440 // FTimerHandle (Size: 0x8)
SGCharacterWeaponManagerComponent.TimerHandle_EndMonitorInput = 0x458 // FTimerHandle (Size: 0x8)
SGCharacterWeaponManagerComponent.SwitchWeaponAbilityTag = 0x460 // FGameplayTag (Size: 0x8)
SGCharacterWeaponManagerComponent.bEnableDynamicPlayRateFP = 0x468 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.bEnableDynamicPlayRateTP = 0x469 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.SwitchWeaponPlayRateOverrideRangeFP = 0x46c // FFloatRange (Size: 0x10)
SGCharacterWeaponManagerComponent.SwitchWeaponPlayRateOverrideRangeTP = 0x47c // FFloatRange (Size: 0x10)
SGCharacterWeaponManagerComponent.MeleeToMainWeaponTakeUpAnimPlayRate = 0x48c // float (Size: 0x4)
SGCharacterWeaponManagerComponent.HandWeaponState = 0x490 // FSGHandWeaponState (Size: 0xc8)
SGCharacterWeaponManagerComponent.ReplicatedSwitchWeaponIntent = 0x558 // FSGSwitchWeaponIntent (Size: 0x28)
SGCharacterWeaponManagerComponent.ReplicatedHandState = 0x580 // EESGHandState (Size: 0x1)
SGCharacterWeaponManagerComponent.OnSetSwitchWeaponIntent = 0x588 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterWeaponManagerComponent.OnSwitchWeaponIntentFullfilled = 0x598 // FMulticastInlineDelegate (Size: 0x10)
SGCharacterWeaponManagerComponent.SwitchWeaponWaitTimeStamp_TimerHandle = 0x5b0 // FTimerHandle (Size: 0x8)
SGCharacterWeaponManagerComponent.SwitchWeaponMontageTimeUp_TimerHandle = 0x5b8 // FTimerHandle (Size: 0x8)
SGCharacterWeaponManagerComponent.SwitchWeaponWaitServerConfirm_TimerHandle = 0x5c0 // FTimerHandle (Size: 0x8)
SGCharacterWeaponManagerComponent.WaitServerConfirmTimeout = 0x5c8 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.SwitchWeaponBlockTags = 0x5d0 // FGameplayTagContainer (Size: 0x20)
SGCharacterWeaponManagerComponent.ServerSwitchWeaponTimeout = 0x5f8 // float (Size: 0x4)
SGCharacterWeaponManagerComponent.LastDestWeapon = 0x600 // SGWeapon* (Size: 0x8)
SGCharacterWeaponManagerComponent.bSkipPutdownAnimWhenSwitchWithMelee = 0x618 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.LeaveTacticalStateTags = 0x620 // FGameplayTagContainer (Size: 0x20)
SGCharacterWeaponManagerComponent.CurrentLeftHandWeapon = 0x640 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.bEnableTacticalSwitchWeapon = 0x648 // bool (Size: 0x1)
SGCharacterWeaponManagerComponent.RemoveCurrentWeaponInturrupt = 0x658 // FGameplayTagContainer (Size: 0x20)
SGCharacterWeaponManagerComponent.HoldingInventory = 0x678 // SGInventory* (Size: 0x8)
SGCharacterWeaponManagerComponent.RepHoldingInventory = 0x680 // SGInventory* (Size: 0x8)
SGCharacterWeaponSwayComponent.TimeSteps = 0x16c // float (Size: 0x4)
SGCharacterWeaponSwayComponent.WeaponSwayScalerByEngonomicsCurve = 0x170 // CurveFloat* (Size: 0x8)
SGCharacterWeaponSwayComponent.DefaultWeaponSwayScaler = 0x178 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.SmoothAngularVelocityInterpSpeed = 0x1a4 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.AngularVelocityNormalizedRange_Yaw = 0x1a8 // FVector2D (Size: 0x8)
SGCharacterWeaponSwayComponent.AngularVelocityNormalizedRange_Pitch = 0x1b0 // FVector2D (Size: 0x8)
SGCharacterWeaponSwayComponent.ADSWeaponSwayClamp_Yaw = 0x1b8 // FVector2D (Size: 0x8)
SGCharacterWeaponSwayComponent.ADSWeaponSwayClamp_Pitch = 0x1c0 // FVector2D (Size: 0x8)
SGCharacterWeaponSwayComponent.WeaponSwayDelay_Yaw = 0x1c8 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.WeaponSwayDelay_Pitch = 0x1cc // float (Size: 0x4)
SGCharacterWeaponSwayComponent.MovementSwayStrength = 0x1d4 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.bShouldWeaponSway = 0x1dc // bool (Size: 0x1)
SGCharacterWeaponSwayComponent.PowerBaseValue = 0x1e0 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.PowerUpdateFrequency = 0x1e4 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.SinePeriod = 0x1e8 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.WeaponSwayLocOffsetScaler = 0x20c // float (Size: 0x4)
SGCharacterWeaponSwayComponent.WeaponSwayRotOffsetScaler = 0x210 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.WeaponSwayOffsetScaler_ADS = 0x248 // float (Size: 0x4)
SGCharacterWeaponSwayComponent.LastPoseTickFrame = 0x24c // uint32_t (Size: 0x4)
SGCharacterWeaponTraceComponent.WeaponTraceOffset = 0x108 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.CameraOffsetForWeaponTrace_1P = 0x114 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.CameraOffsetForWeaponTrace_3P = 0x120 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.Tolerance = 0x12c // float (Size: 0x4)
SGCharacterWeaponTraceComponent.WeaponTraceRadius = 0x130 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.InterpSpeed = 0x134 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.PullBackRange = 0x138 // FVector2D (Size: 0x8)
SGCharacterWeaponTraceComponent.FoldRange = 0x140 // FVector2D (Size: 0x8)
SGCharacterWeaponTraceComponent.HandUpDirection = 0x148 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.WeaponTraceBone_1P = 0x154 // FName (Size: 0x8)
SGCharacterWeaponTraceComponent.WeaponTraceBone = 0x15c // FName (Size: 0x8)
SGCharacterWeaponTraceComponent.WeaponTraceBone_InTacticalState = 0x164 // FName (Size: 0x8)
SGCharacterWeaponTraceComponent.CameraToWeaponRootBone = 0x16c // FName (Size: 0x8)
SGCharacterWeaponTraceComponent.WeaponMinLength_Long = 0x174 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.ExtraTraceDistance_Long = 0x178 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.RightHandOffset_Long_1P = 0x17c // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.RightHandOffset_Long_3P = 0x1ac // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.LHandJointOffset_Common = 0x1dc // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.WeaponMinLength_Mid = 0x1e8 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.ExtraTraceDistance_Mid = 0x1ec // float (Size: 0x4)
SGCharacterWeaponTraceComponent.RightHandOffset_Mid_1P = 0x1f0 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.RightHandOffset_Mid_3P = 0x220 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.ExtraTraceDistance_Short = 0x250 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.ExtraBackDistance_Short = 0x254 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.ExtraBackDistance_Melee = 0x258 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.RightHandOffset_Short_1P = 0x25c // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.RightHandOffset_Short_3P = 0x28c // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.RightHandOffset_Tactical_1P = 0x2bc // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.RightHandOffset_Tactical_3P = 0x2ec // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGCharacterWeaponTraceComponent.bEnable = 0x31c // bool (Size: 0x1)
SGCharacterWeaponTraceComponent.AI_MuzzleMeshLength = 0x320 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.WeaponMeshLengthDic = 0x328 // TMap<...> (Size: 0x50)
SGCharacterWeaponTraceComponent.RotOffset_RightHand = 0x378 // FRotator (Size: 0xc)
SGCharacterWeaponTraceComponent.bEnableDebug = 0x3af // bool (Size: 0x1)
SGCharacterWeaponTraceComponent.FoldDelay = 0x3b0 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.FoldDelayTick = 0x3b4 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.FoldDelaySmoothInterpSpeed = 0x3b8 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.EmptyHandTraceDistance = 0x3bc // float (Size: 0x4)
SGCharacterWeaponTraceComponent.EmptyHandTraceStartBone = 0x3c0 // FName (Size: 0x8)
SGCharacterWeaponTraceComponent.EmptyHandPullBack_LocOffset = 0x3c8 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.EmptyHandTraceRadius = 0x3d4 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.Empty_RHandJointOffset = 0x3d8 // FVector (Size: 0xc)
SGCharacterWeaponTraceComponent.CharacterWPOMatParamCollection = 0x3e8 // MaterialParameterCollection* (Size: 0x8)
SGCharacterWeaponTraceComponent.EnableFirstRendering = 0x3f0 // bool (Size: 0x1)
SGCharacterWeaponTraceComponent.RenderingScale = 0x3f4 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.EnableMeleeWeaponOrEmptyHandSupport = 0x3f8 // bool (Size: 0x1)
SGCharacterWeaponTraceComponent.TickSetting_HighEndDevice = 0x400 // FTickSettingBaseOnURO (Size: 0x10)
SGCharacterWeaponTraceComponent.TickSetting_LowEndDevice = 0x410 // FTickSettingBaseOnURO (Size: 0x10)
SGCharacterWeaponTraceComponent.TickTimeScalerWhenIdle = 0x420 // float (Size: 0x4)
SGCharacterWeaponTraceComponent.FPDefaultUROLevel = 0x424 // int32_t (Size: 0x4)
SGCharacterWeaponTraceComponent.NonPullWeaponInterpDeviceLevel = 0x428 // int32_t (Size: 0x4)
SGCharacterWeaponTraceComponent.NonPullWeaponInterpUROLevel = 0x42c // int32_t (Size: 0x4)
SGCharacterWeaponTraceComponent.CurrentWeapon = 0x438 // SGInventory* (Size: 0x8)
SGCharacterWeaponTraceComponent.IgnoreActor = 0x538 // TArray<Actor*> (Size: 0x10)
SGCharacterWeaponTraceComponent.AIObjectTypeQuery = 0x548 // TArray<uint8_t> (Size: 0x10)
SGCharacterWeaponTraceComponent.WeaponMgr = 0x558 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGCharacterWeaponTraceComponent.AnimIns = 0x570 // AnimInstance* (Size: 0x8)
SGCharacterWeaponTraceComponent.MovementComponent = 0x578 // SGCharacterMovementComponent* (Size: 0x8)
SGCharacterWeaponTraceComponent.CharacterAnimInstance = 0x580 // SGCharacterAnimInstance* (Size: 0x8)
SGCharacterWeightAttributeSet.fCondition = 0x48 // float (Size: 0x4)
SGCharacterWeightAttributeSet.fConditionComplete = 0x4c // float (Size: 0x4)
SGCharacterWeightAttributeSet.WeightMax = 0x50 // float (Size: 0x4)
SGCharacterWeightComponent.fDamage = 0x108 // float (Size: 0x4)
SGCharacterWeightComponent.fJumpHeight = 0x10c // float (Size: 0x4)
SGCharacterWeightComponent.fSpeed = 0x110 // float (Size: 0x4)
SGCharacterWeightComponent.fDamageComplete = 0x114 // float (Size: 0x4)
SGCharacterWeightComponent.fJumpHeightComplete = 0x118 // float (Size: 0x4)
SGCharacterWeightComponent.fSpeedComplete = 0x11c // float (Size: 0x4)
SGCharacterWeightComponent.WeightCondition1 = 0x120 // float (Size: 0x4)
SGCharacterWeightComponent.WeightCondition2 = 0x124 // float (Size: 0x4)
SGCharacterWeightComponent.MinRecoverScale = 0x128 // float (Size: 0x4)
SGCharacterWeightComponent.MaxReduceScale = 0x12c // float (Size: 0x4)
SGCharacterWeightComponent.OverweightSoundFactor = 0x130 // FSoundInfluenceFactor (Size: 0x8)
SGCharacterWeightComponent.CompletelyOverweightSoundFactor = 0x138 // FSoundInfluenceFactor (Size: 0x8)
SGCharacterWeightComponent.bEnableWeightSystem = 0x140 // bool (Size: 0x1)
SGCharacterWeightComponent.PersistentOverWeightAbilityClass = 0x148 // ClassProperty (Size: 0x8)
SGCharacterWeightComponent.PersistentCompleteOverWeightAbilityClass = 0x150 // ClassProperty (Size: 0x8)
SGCharacterWeightComponent.AttributeSetClass = 0x168 // ClassProperty (Size: 0x8)
SGCharacterWeightComponent.Debug = 0x170 // bool (Size: 0x1)
SGClientMoveInfo.ClientTimeStamp = 0x0 // float (Size: 0x4)
SGClientMoveInfo.DeltaTime = 0x4 // float (Size: 0x4)
SGClientShowItemInfo.GID = 0x0 // uint64_t (Size: 0x8)
SGClientShowItemInfo.ItemId = 0x8 // uint64_t (Size: 0x8)
SGClientShowItemInfo.ItemNum = 0x10 // uint32_t (Size: 0x4)
SGClientShowItemInfo.ParentID = 0x18 // uint64_t (Size: 0x8)
SGClientShowItemInfo.Index = 0x20 // uint32_t (Size: 0x4)
SGClientShowItemInfo.PosX = 0x24 // uint32_t (Size: 0x4)
SGClientShowItemInfo.PosY = 0x28 // uint32_t (Size: 0x4)
SGClientShowItemInfo.bRollUp = 0x2c // bool (Size: 0x1)
SGClientShowItemInfo.bDisable = 0x2d // bool (Size: 0x1)
SGClientShowItemInfo.PendantID = 0x30 // uint32_t (Size: 0x4)
SGClientShowItemInfo.SprayID = 0x34 // uint32_t (Size: 0x4)
SGClientShowItemInfo.Durability = 0x38 // uint32_t (Size: 0x4)
SGClientShowItemInfo.MaxDurability = 0x3c // uint32_t (Size: 0x4)
SGCmdObjectManager.CmdObjectMap = 0x28 // TMap<...> (Size: 0x50)
SGCollisionSwitherComponent.CollisionActors = 0x40 // TArray<Actor*> (Size: 0x10)
SGCollisionSwitherComponent.bShowState = 0x50 // bool (Size: 0x1)
SGCompSignificanceVolumeManager.VolumeRelevantInfoList = 0x310 // TArray<FSGCompSignificanceVolumeRelevantInfo> (Size: 0x10)
SGCompSignificanceVolumeRelevantInfo.Type = 0x0 // EESGCompSignificanceVolumeRelevantType (Size: 0x1)
SGCompSignificanceVolumeRelevantInfo.GroupA = 0x8 // TArray<SGCompSignificanceVolume*> (Size: 0x10)
SGCompSignificanceVolumeRelevantInfo.GroupB = 0x18 // TArray<SGCompSignificanceVolume*> (Size: 0x10)
SGCompetitionAPIReport.CachePackgetNum = 0xf8 // int32_t (Size: 0x4)
SGCompetitionAPIReport.RecordGIDArray = 0x108 // TArray<int64_t> (Size: 0x10)
SGCompetitionAPIReport.SendPackgetCoolTime = 0x118 // float (Size: 0x4)
SGCompetitionAPIReport.BossTokenID = 0x11c // int32_t (Size: 0x4)
SGCompetitionAPIReport.RecordRarity = 0x120 // int32_t (Size: 0x4)
SGCompetitionGameEvents.OBPlayerRestart = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.CompetitionGameGlobalDataInfoChange = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnCompetitionGameAllTeamPanelVisibilityChange = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnCompetitionGameFallReport = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnCompetitionEscapeReport = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnChangePerspectiveState = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnChangeCharacterStatusArrays = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnAPIPlayerStaticInfo = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnAPIPlayerDynamicInfo = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnAPIReportInfo = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnTakeOutValueChange = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnOBSpectateStateChange = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnCompetitionFlagChange = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionGameEvents.OnRequestFinishGame = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGCompetitionInfoComponent.SoundIndicatorEffect = 0xf8 // ParticleSystem* (Size: 0x8)
SGCompetitionInfoComponent.SoundIndicatorEffectBaseScale = 0x100 // float (Size: 0x4)
SGCompetitionInfoComponent.Max1PDistanceInfluenceFactor = 0x104 // float (Size: 0x4)
SGCompetitionInfoComponent.TriggerSoundIndicatorInterval = 0x108 // float (Size: 0x4)
SGCompetitionInfoComponent.ActiveSoundMap = 0x110 // TMap<...> (Size: 0x50)
SGCompetitionKillInfoManage.AllPlayerKillListData = 0xf8 // TArray<FCompetitionPlayerKillList> (Size: 0x10)
SGCompetitionPerspectiveManage.MeshObj = 0x108 // StaticMesh* (Size: 0x8)
SGCompetitionPerspectiveManage.SourceMaterial = 0x110 // MaterialInterface* (Size: 0x8)
SGCompetitionPerspectiveManage.DirectionIndicatorSourceMaterial = 0x118 // MaterialInterface* (Size: 0x8)
SGCompetitionPerspectiveManage.AliveCharacterList = 0x120 // TArray<SGCharacter*> (Size: 0x10)
SGCompetitionPerspectiveManage.PostProcessVolume = 0x130 // PostProcessVolume* (Size: 0x8)
SGCompetitionPlayerStatusManage.StatusArray = 0xf8 // TArray<SGCompetitionStatusBase*> (Size: 0x10)
SGCompetitionPlayerStatusManage.CharacterStatusArrays = 0x108 // TArray<FPlayerStatusInfo> (Size: 0x10)
SGCompetitionPlayerStatusManage.CompetitionFlagsValue = 0x118 // int32_t (Size: 0x4)
SGCompetitionStatusBase.StatusType = 0x28 // EESGCompetitionStatusType (Size: 0x1)
SGCompetitionStatusBase.OwnerStatusManage = 0x30 // SGCompetitionPlayerStatusManage* (Size: 0x8)
SGCompetitionStatusBase.RegisterCharacterArray = 0x38 // TArray<SGCharacter*> (Size: 0x10)
SGConsoleCommandAliasSettings.CommandAliasGroups = 0x38 // TArray<FCommandAliasGroup> (Size: 0x10)
SGConstrabandComponent.ContrabandType = 0x100 // EEContrabandType (Size: 0x1)
SGConstrabandComponent.CachedUsingGA = 0x108 // SGGamePlayAbility_UseContraband* (Size: 0x8)
SGConstrabandComponent.StopUsingEffect = 0x110 // NiagaraSystem* (Size: 0x8)
SGConstrabandComponent.ScanDeviceStartEffectDelayTime = 0x118 // float (Size: 0x4)
SGConstrabandComponent.ScanDeviceEndEffectDelayTime = 0x11c // float (Size: 0x4)
SGConstrabandComponent.bNeedAutoCloseBag = 0x130 // bool (Size: 0x1)
SGConstrabandComponent.bIsAlreadyUsed = 0x131 // bool (Size: 0x1)
SGContainerEffectParam.AllInventoryThresholdValue = 0x0 // int64_t (Size: 0x8)
SGContainerEffectParam.ParticleSystemAsset = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGContainerSearchEffectComponent.ParticleSystemComponent = 0x100 // ParticleSystemComponent* (Size: 0x8)
SGContainerSearchEffectComponent.EffectGradeConfig = 0x108 // TArray<FSGContainerEffectParam> (Size: 0x10)
SGContextMenu.SlotClass = 0x2f0 // ClassProperty (Size: 0x8)
SGContextMenu.SlotArray = 0x2f8 // TArray<SGContextMenuSlot*> (Size: 0x10)
SGContextMenu.SlotTypeArray = 0x308 // TArray<FContextMenuSlotType> (Size: 0x10)
SGContextMenu.SlotVerticalBox = 0x318 // VerticalBox* (Size: 0x8)
SGContextMenuSlot.SlotSettings = 0x2f0 // DataTable* (Size: 0x8)
SGContextMenuSlot.ParentWidget = 0x2f8 // SGContextMenu* (Size: 0x8)
SGContextMenuSlot.SlotButton = 0x308 // Button* (Size: 0x8)
SGContextMenuSlot.TextName = 0x310 // TextBlock* (Size: 0x8)
SGContextMenuSlot.SlotIcon = 0x318 // Image* (Size: 0x8)
SGContextMenuSpawner.ContextMenuAnchor = 0x2f0 // MenuAnchor* (Size: 0x8)
SGContextMenuSpawner.ContextMenu = 0x2f8 // SGContextMenu* (Size: 0x8)
SGCorpseDetectorComponent.OwnerGID = 0x1088 // uint64_t (Size: 0x8)
SGCorpseDetectorComponent.SearchedDeadCharacterGID = 0x1090 // TArray<uint64_t> (Size: 0x10)
SGCreateInteractActorComponent.InteractActorClass = 0xf8 // ClassProperty (Size: 0x8)
SGCreateInteractActorComponent.CreatedActor = 0x100 // Actor* (Size: 0x8)
SGCrosshairStyleWidget.Spread = 0x2f0 // WidgetAnimation* (Size: 0x8)
SGCrosshairWidget.StyleWidget = 0x2f0 // SGCrosshairStyleWidget* (Size: 0x8)
SGCrosshairWidget.StyleContainer = 0x2f8 // CanvasPanel* (Size: 0x8)
SGCrosshairWidget.CentralDot = 0x300 // Image* (Size: 0x8)
SGCrosshairWidget_CA.MaterialInstance = 0x328 // MaterialInstanceDynamic* (Size: 0x8)
SGCustomFOVRenderMatrixComponent.CustomFOV = 0x104 // float (Size: 0x4)
SGCustomFOVRenderMatrixComponent.ZoomCustomFOV = 0x108 // float (Size: 0x4)
SGCustomFOVRenderMatrixComponent.CustomFOVBlendSpeed = 0x10c // float (Size: 0x4)
SGCustomFOVRenderMatrixComponent.bCanEverEnable = 0x110 // bool (Size: 0x1)
SGCustomFOVRenderMatrixComponent.CachedCharacterOwner = 0x118 // SGCharacter* (Size: 0x8)
SGCustomFOVRenderMatrixComponent.CachedFOVComponent = 0x128 // SGPCMCameraFOVComponent* (Size: 0x8)
SGCustomFOVRenderMatrixComponent.CachedPrimitiveComponent = 0x130 // PrimitiveComponent* (Size: 0x8)
SGCustomFOVRenderMatrixComponent.bEnableCustomFOV = 0x138 // uint8_t (Size: 0x1)
SGCustomFOVRenderMatrixComponent.bEnableCustomFOVForRender = 0x140 // uint8_t (Size: 0x1)
SGCustomizeAnimationGroup.CharacterAnimation = 0x0 // AnimMontage* (Size: 0x8)
SGCustomizeAnimationGroup.WeaponAnimation = 0x8 // AnimMontage* (Size: 0x8)
SGCustomizeAnimationGroup.FacialAnimation = 0x10 // AnimMontage* (Size: 0x8)
SGDSAMessageConfigTable.SettlemetMessageFlags = 0x20 // TArray<EESGSettlemetMessageFlag> (Size: 0x10)
SGDSCommandContainer.Commands = 0x0 // TArray<FSGDSCommandUnit> (Size: 0x10)
SGDSCommandUnit.TimingTypeInt = 0x0 // int32_t (Size: 0x4)
SGDSCommandUnit.CommandTypeInt = 0x8 // int32_t (Size: 0x4)
SGDSCommandUnit.DelayTime = 0x10 // float (Size: 0x4)
SGDSCommandUnit.LoopingLimit = 0x14 // int32_t (Size: 0x4)
SGDSCommandUnit.CommandLine = 0x18 // FString (Size: 0x10)
SGDSCommandUnit.Context = 0x28 // FString (Size: 0x10)
SGDSCommandUnit.enable = 0x38 // int32_t (Size: 0x4)
SGDSSeedAssetSubsystem.SeedPreLoadPackage = 0x30 // TArray<Package*> (Size: 0x10)
SGDamageType.WalkMovementReductionPct = 0x40 // float (Size: 0x4)
SGDamageType.WalkMovementReductionDuration = 0x44 // float (Size: 0x4)
SGDamageType.ForceZMomentumPct = 0x48 // float (Size: 0x4)
SGDamageType.SelfMomentumBoost = 0x4c // float (Size: 0x4)
SGDamageType.bSelfMomentumBoostOnlyZ = 0x50 // uint8_t (Size: 0x1)
SGDamageType.bForceZMomentum = 0x50 // uint8_t (Size: 0x1)
SGDamageType.bPreventWalkingZMomentum = 0x50 // uint8_t (Size: 0x1)
SGDamageType.bCausesBlood = 0x50 // uint8_t (Size: 0x1)
SGDamageType.WallHitType = 0x50 // uint8_t (Size: 0x1)
SGDamageType_Burn.Duration = 0x58 // float (Size: 0x4)
SGDamageType_Burn.DamagePerSecond = 0x5c // float (Size: 0x4)
SGDataAsset_Crosshair.Exposure_color_Divide = 0x30 // float (Size: 0x4)
SGDataAsset_Crosshair.Exposure_color_Divide_ADD = 0x34 // float (Size: 0x4)
SGDataAsset_Crosshair.Exposure_EyeAdaptation_Mul = 0x38 // float (Size: 0x4)
SGDataAsset_Crosshair.laser_noise = 0x3c // float (Size: 0x4)
SGDataAsset_Crosshair.Halo_Dither = 0x40 // float (Size: 0x4)
SGDataAsset_Crosshair.AlphaExp = 0x44 // float (Size: 0x4)
SGDataAsset_Crosshair.PointNoise = 0x48 // float (Size: 0x4)
SGDataTableManager.DataTablePathList = 0x28 // TArray<FString> (Size: 0x10)
SGDataTableManager.DataTables = 0x38 // TMap<...> (Size: 0x50)
SGDebugCameraMode_Free.DebugCameraControllerRef = 0xb8 // DebugCameraController* (Size: 0x8)
SGDecalComponent.FadeStartDelay = 0x670 // float (Size: 0x4)
SGDecalComponent.FadeDuration = 0x674 // float (Size: 0x4)
SGDecalComponent.bRandomRotate = 0x678 // bool (Size: 0x1)
SGDecalComponent.bDestroyOwnerAfterFade = 0x679 // uint8_t (Size: 0x1)
SGDirectlyHiddenInfo.DirectlyHiddenInventorySet = 0x0 // TSet<...> (Size: 0x50)
SGDirectlyHiddenInfo.DirectlyHiddenAvatarSet = 0x50 // TSet<...> (Size: 0x50)
SGDirectlyHiddenInfo.DirectlyHiddenMaterialSet = 0xa0 // TMap<...> (Size: 0x50)
SGDirectlyHiddenInfo.DirectlyHiddenWeaponSet = 0xf0 // TSet<...> (Size: 0x50)
SGDoorBase.LimitedFactions = 0x3a0 // TArray<EEFactionType> (Size: 0x10)
SGDoorBase.DoorType = 0x3b0 // EESGDoorType (Size: 0x1)
SGDoorBase.DoorKeyItemIDForTips = 0x3b8 // int64_t (Size: 0x8)
SGDoorBase.DoorKeyItemIDArray = 0x3c0 // TArray<int64_t> (Size: 0x10)
SGDoorBase.DoorLockedTipsKey = 0x3d0 // FString (Size: 0x10)
SGDoorBase.bShowWreck = 0x3e0 // bool (Size: 0x1)
SGDoorBase.bCanOpenFromInner = 0x3e1 // bool (Size: 0x1)
SGDoorBase.bIsControlledByGenerator = 0x3e2 // bool (Size: 0x1)
SGDoorBase.CloseDoorDetectDistance = 0x3e4 // float (Size: 0x4)
SGDoorBase.ClosedRotation = 0x3e8 // FRotator (Size: 0xc)
SGDoorBase.CardReaderDoorType = 0x3f4 // EESGCardReaderDoorType (Size: 0x1)
SGDoorBase.ResetCoolDownTime = 0x3f8 // float (Size: 0x4)
SGDoorBase.AmendCloseGeneratorLockedDoorTime = 0x3fc // float (Size: 0x4)
SGDoorBase.OnDoorStateChange = 0x400 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnDoorCardStateChange = 0x410 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnClientDoorMoveBegin = 0x420 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnClientDoorMoveFinish = 0x430 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnDoorOpenTypeChange = 0x440 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnDoorMoveFinish = 0x450 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.OnDoorUnLockEvent = 0x460 // FMulticastInlineDelegate (Size: 0x10)
SGDoorBase.CurrentCoolDownTime = 0x490 // float (Size: 0x4)
SGDoorBase.bCurrentGeneratorOn = 0x494 // bool (Size: 0x1)
SGDoorBase.DoorOpenTypeConfig = 0x495 // EESGDoorOpenType (Size: 0x1)
SGDoorBase.CardDoorStateConfig = 0x496 // EESGCardReaderDoorState (Size: 0x1)
SGDoorBase.DoorState = 0x497 // EESGDoorState (Size: 0x1)
SGDoorBase.CardDoorState = 0x498 // EESGCardReaderDoorState (Size: 0x1)
SGDoorBase.DoorOpenType = 0x499 // EESGDoorOpenType (Size: 0x1)
SGDoorBase.IsDoorCanBeForcedBreak = 0x49a // bool (Size: 0x1)
SGDoorBase.DoorForceBreakHitCountMin = 0x49c // int32_t (Size: 0x4)
SGDoorBase.DoorForceBreakHitCountMax = 0x4a0 // int32_t (Size: 0x4)
SGDoorBase.DoorForceBreakMat = 0x4a8 // MaterialInterface* (Size: 0x8)
SGDoorBase.DoorForceBreakMatIndex = 0x4b0 // int32_t (Size: 0x4)
SGDoorBase.DoorForceBreakShakeMontage = 0x4b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGDoorBase.DoorForceBreakHitRemainCount = 0x4e0 // int32_t (Size: 0x4)
SGDoorBase.DoorForceBreakHitMaxCount = 0x4e4 // int32_t (Size: 0x4)
SGDoorBase.DoorExplosiveGameStartDelayTime = 0x4e8 // float (Size: 0x4)
SGDoorBase.DoorUseType = 0x4ec // EESGDoorUseType (Size: 0x1)
SGDoorBase.CurAction = 0x4ed // EEDoorAction (Size: 0x1)
SGDoorBase.DoorActionAry = 0x4f0 // TArray<FDoorActionInfo> (Size: 0x10)
SGDoorBase.DoorCategory = 0x500 // EESGDoorCategory (Size: 0x1)
SGDoorBase.CachedDoorMovmentComponent = 0x508 // SGDoorMovmentComponentBase* (Size: 0x8)
SGDoorBase.CachedTwoWayDoorPlankComponent = 0x510 // SGTwoWayDoorPlankComponent* (Size: 0x8)
SGDoorBase.CachedRelightingPortalComponent = 0x518 // MFRelightingPortalComponent* (Size: 0x8)
SGDoorBase.RelightingPortalData = 0x520 // FRelightingPortalData (Size: 0x30)
SGDoorBase.ShadowProxyThickness = 0x550 // float (Size: 0x4)
SGDoorBase.ShadowProxyFrame = 0x554 // float (Size: 0x4)
SGDoorBase.ShadowProxy = 0x558 // StaticMeshComponent* (Size: 0x8)
SGDoorBase.DoorComponentClasses = 0x560 // TArray<ClassProperty> (Size: 0x10)
SGDoorBase.InteractCharacter = 0x570 // Character* (Size: 0x8)
SGDoorBase.MaxDrawDistance = 0x578 // float (Size: 0x4)
SGDoorBase.CachedDoorHandleClosedDir = 0x588 // FVector (Size: 0xc)
SGDoorBase.GateOn = 0x594 // bool (Size: 0x1)
SGDoorBase.GateOnTime = 0x598 // FDateTime (Size: 0x8)
SGDoorBase.GateName = 0x5a0 // FString (Size: 0x10)
SGDoorBase.LeftDoorMarker = 0x5b0 // SphereComponent* (Size: 0x8)
SGDoorBase.RightDoorMarker = 0x5b8 // SphereComponent* (Size: 0x8)
SGDoorBase.LeftDoorLockMarker = 0x5c0 // SphereComponent* (Size: 0x8)
SGDoorBase.RightDoorLockMarker = 0x5c8 // SphereComponent* (Size: 0x8)
SGDoorBase.PortalCheckMarker = 0x5d0 // SphereComponent* (Size: 0x8)
SGDoorBase.ParticleSystemLock = 0x5d8 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlockCoolDown = 0x5e0 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlock = 0x5e8 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlockCountDown = 0x5f0 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemLockBack = 0x5f8 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlockCoolDownBack = 0x600 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlockBack = 0x608 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.ParticleSystemUnlockCountDownBack = 0x610 // ParticleSystemComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentLock = 0x618 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlockCoolDown = 0x620 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlock = 0x628 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlockCountDown = 0x630 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentLockBack = 0x638 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlockCoolDownBack = 0x640 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlockBack = 0x648 // NiagaraComponent* (Size: 0x8)
SGDoorBase.NiagaraComponentUnlockCountDownBack = 0x650 // NiagaraComponent* (Size: 0x8)
SGDoorBase.FrameSettingOutStaticMeshComp = 0x658 // StaticMeshComponent* (Size: 0x8)
SGDoorBase.FrameSettingInStaticMeshComp = 0x660 // StaticMeshComponent* (Size: 0x8)
SGDoorBase.OverlapActors = 0x678 // TArray<Actor*> (Size: 0x10)
SGDoorBase.LastTickDoorHandleDir = 0x688 // FVector (Size: 0xc)
SGDoorBase.DoorWidth = 0x694 // float (Size: 0x4)
SGDoorBase.OutOfDoorVelocityWhenOpen = 0x698 // float (Size: 0x4)
SGDoorBase.OutOfDoorVelocityWhenOpenScale = 0x69c // FVector2D (Size: 0x8)
SGDoorBase.OutOfDoorVelocityWhenClose = 0x6a4 // float (Size: 0x4)
SGDoorBase.OutOfDoorVelocityWhenCloseScale = 0x6a8 // FVector2D (Size: 0x8)
SGDoorBase.PronePushMiddleAdditionVelocity = 0x6b0 // float (Size: 0x4)
SGDoorBase.TraceConfigID = 0x6b4 // int32_t (Size: 0x4)
SGDoorBase.AnnounceConfigID = 0x6b8 // int32_t (Size: 0x4)
SGDoorBase.InteractVolumeArray = 0x6c0 // TArray<SGVolume*> (Size: 0x10)
SGDoorBase.DoorMovableMap = 0x6d0 // TMap<...> (Size: 0x50)
SGDoorBeUsedComponent.MaxUseDistance = 0x14c // float (Size: 0x4)
SGDoorLockComponent.LootSubAreaVolume = 0xf8 // SGLootSubAreaVolume* (Size: 0x8)
SGDoorLockComponent.VolumeID = 0x100 // int32_t (Size: 0x4)
SGDoorMovementInfo.bIsMoving = 0x0 // bool (Size: 0x1)
SGDoorMovementInfo.MovingProgress = 0x4 // float (Size: 0x4)
SGDoorMovementInfo.PreState = 0x8 // EESGDoorState (Size: 0x1)
SGDoorMovementInfo.NewState = 0x9 // EESGDoorState (Size: 0x1)
SGDoorMovementInfo.UseMod = 0xa // EESGDoorUseMode (Size: 0x1)
SGDoorMovementInfo.MoveSpeed = 0xc // float (Size: 0x4)
SGDoorMovementInfo.OptCount = 0x10 // int32_t (Size: 0x4)
SGDoorMovementInfo.bInit = 0x14 // bool (Size: 0x1)
SGDoorMovementInfo.DoorMover = 0x18 // Character* (Size: 0x8)
SGDoorMovementSyncInfo.MovementInfo = 0x0 // FSGDoorMovementInfo (Size: 0x20)
SGDoorMovementSyncInfo.Count = 0x20 // int32_t (Size: 0x4)
SGDoorMovmentComponentBase.DoorOwner = 0x100 // SGDoorBase* (Size: 0x8)
SGDoorMovmentComponentBase.DoorSpeed = 0x108 // float (Size: 0x4)
SGDoorMovmentComponentBase.DoorSpeedForceBreak = 0x10c // float (Size: 0x4)
SGDoorMovmentComponentBase.ActualDoorSpeed = 0x110 // float (Size: 0x4)
SGDoorMovmentComponentBase.MaxDeltaTime = 0x114 // float (Size: 0x4)
SGDoorMovmentComponentBase.bCanRevertWhenMoving = 0x118 // bool (Size: 0x1)
SGDoorMovmentComponentBase.MovementInfo = 0x120 // FSGDoorMovementInfo (Size: 0x20)
SGDoorMovmentComponentBase.ClientMovementInfo = 0x140 // FSGDoorMovementInfo (Size: 0x20)
SGDoorMovmentComponentBase.DoorStatusSyncInfo = 0x160 // FSGDoorMovementSyncInfo (Size: 0x28)
SGDoorSoundComponent.OpenSound = 0xf8 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.CloseSound = 0x100 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.OpenSound_3P = 0x108 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.CloseSound_3P = 0x110 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.KickOpenSound = 0x118 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.KickFailSound = 0x120 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.UnlockSound = 0x128 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.CardUnlockSound = 0x130 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.UnlockSound_3P = 0x138 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.CardUnlockSound_3P = 0x140 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.ReLockSound = 0x148 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.LockCoolDownSound = 0x150 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.GateDoorBeginCountDownSound = 0x158 // AkAudioEvent* (Size: 0x8)
SGDoorSoundComponent.PlaySoundFromDoor = 0x160 // bool (Size: 0x1)
SGDoorStateSwitcherComponent.DelayTime = 0x48 // float (Size: 0x4)
SGDoorStateSwitcherComponent.Door = 0x50 // SGDoorBase* (Size: 0x8)
SGDoorStateSwitcherComponent.bOpen = 0x58 // bool (Size: 0x1)
SGDynamicAnimationSet.WeaponForegripType = 0x0 // EESGWeaponForegripType (Size: 0x1)
SGDynamicAnimationSet.bHasForegrip = 0x1 // bool (Size: 0x1)
SGDynamicAnimationSet.IdleSeq = 0x8 // AnimSequence* (Size: 0x8)
SGDynamicAnimationSet.GripIdleBS = 0x10 // BlendSpace1D* (Size: 0x8)
SGDynamicAnimationSet.WeaponSwayBS = 0x18 // BlendSpace1D* (Size: 0x8)
SGDynamicAnimationSet.WeaponSwayBS_ADS = 0x20 // BlendSpace1D* (Size: 0x8)
SGDynamicAnimationSet.KickingDoorHandSeq = 0x28 // AnimSequence* (Size: 0x8)
SGDynamicContentWidget.ContentWidgetClass = 0x148 // ClassProperty (Size: 0x8)
SGDynamicContentWidget.CreatedContentWidget = 0x150 // UserWidget* (Size: 0x8)
SGDynamicContentWidget.DynamicContentPoolListOwner_Observer = 0x158 // TWeakObjectPtr<UObject> (Size: 0x8)
SGEffectSwitherComponent.EffectActorArr = 0x40 // TArray<SGShowControlEffectActor*> (Size: 0x10)
SGEnterLoopLeaveStateMachine.bCanReverse = 0x0 // bool (Size: 0x1)
SGEnterLoopLeaveStateMachine.EnterSeqLength = 0x4 // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.LeaveSeqLength = 0x8 // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.EnterSeqTime = 0xc // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.LeaveSeqTime = 0x10 // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.bFullyEntered = 0x14 // bool (Size: 0x1)
SGEnterLoopLeaveStateMachine.bFullyLeaved = 0x15 // bool (Size: 0x1)
SGEnterLoopLeaveStateMachine.NormalizedEnterSeqTime = 0x18 // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.NormalizedLeaveSeqTime = 0x1c // float (Size: 0x4)
SGEnterLoopLeaveStateMachine.State = 0x21 // EESGEnterLoopLeaveState (Size: 0x1)
SGEquipMeshAssetUserData.PrefabForFemale = 0x28 // FWearableMeshAssetData (Size: 0x40)
SGEquipMeshAssetUserData.PrefabForMale = 0x68 // FWearableMeshAssetData (Size: 0x40)
SGExhibitionComponent.ItemId = 0xf8 // FName (Size: 0x8)
SGExhibitionComponent.bOnlyCheckOnClient = 0x100 // bool (Size: 0x1)
SGExhibitionComponent.ShowTimeConfigs = 0x108 // TArray<FExhibitionShowTime> (Size: 0x10)
SGExhibitionComponent.bExhibited = 0x118 // bool (Size: 0x1)
SGExhibitionItemTable.ShowTimeConfigs = 0x8 // TArray<FExhibitionShowTime> (Size: 0x10)
SGExhibitionItemTable.Describe = 0x18 // FString (Size: 0x10)
SGExplosionComponent.ExplosionCountTime = 0xf8 // float (Size: 0x4)
SGExplosionComponent.ExplosionFinalCountTime = 0xfc // float (Size: 0x4)
SGExplosionComponent.ExplosionRemainTimeClient = 0x100 // int32_t (Size: 0x4)
SGExplosionComponent.DoExplosionRemainTime = 0x104 // float (Size: 0x4)
SGExplosionComponent.ToFinalCountTimeRemain = 0x108 // float (Size: 0x4)
SGExplosionComponent.ExplosionState = 0x10c // EESGExplosionState (Size: 0x1)
SGExplosionComponent.Explosive = 0x110 // SGThrowableProjectile* (Size: 0x8)
SGExplosionComponent.OnExplosionStateChange = 0x118 // FMulticastInlineDelegate (Size: 0x10)
SGExplosionComponent.OnRemainTimeClientUpdat = 0x128 // FMulticastInlineDelegate (Size: 0x10)
SGFEAvatarCameraFOVComponent.Owner = 0xf8 // Actor* (Size: 0x8)
SGFEAvatarCameraFOVComponent.CameraActor = 0x100 // CameraActor* (Size: 0x8)
SGFEAvatarCameraFOVComponent.CameraComponent = 0x108 // CameraComponent* (Size: 0x8)
SGFEAvatarCameraFOVComponent.enable = 0x12c // bool (Size: 0x1)
SGFEAvatarCameraFOVComponent.OriginAspectRatio = 0x130 // float (Size: 0x4)
SGFEAvatarCameraFOVComponent.OriginFOV = 0x134 // float (Size: 0x4)
SGFaction.FactionIndex = 0x328 // int32_t (Size: 0x4)
SGFaction.FactionType = 0x32c // EEFactionType (Size: 0x1)
SGFaction.TeamArray = 0x330 // TArray<SGTeamInfo*> (Size: 0x10)
SGFaction.FactionmemberBaseInfoArray = 0x340 // TArray<FFactionmemberBaseInfo> (Size: 0x10)
SGFaction.OwnedDomainArr = 0x350 // TArray<SGFactionDomainVolume*> (Size: 0x10)
SGFaction.PlayerStartArr = 0x360 // TArray<int32_t> (Size: 0x10)
SGFaction.AISpawnPointArr = 0x370 // TArray<SGAISpawnPoint*> (Size: 0x10)
SGFaction.bOpenContainerLootProtectByFaction = 0x380 // bool (Size: 0x1)
SGFactionCommonDataComponent.InventoryChangeSourceType = 0xf8 // EESGTakeInSourceType (Size: 0x1)
SGFactionCommonDataComponent.InvChangeSrcTypeOrderCharacterType = 0x100 // TArray<EECharacterType> (Size: 0x10)
SGFactionDomainVolume.PlayerStartArr = 0x398 // TArray<int32_t> (Size: 0x10)
SGFactionDomainVolume.AISpawnPointArr = 0x3a8 // TArray<FMissionActorReference> (Size: 0x10)
SGFactionLevelupData.PlayerName = 0x0 // FString (Size: 0x10)
SGFactionLevelupData.PlayerGid = 0x10 // int64_t (Size: 0x8)
SGFactionLevelupData.Faction = 0x18 // EEFactionType (Size: 0x1)
SGFactionLevelupData.FactionLevel = 0x1c // int32_t (Size: 0x4)
SGFactionLevelupData.ReportCreateTime = 0x20 // float (Size: 0x4)
SGFence.bSplineEditable = 0x310 // bool (Size: 0x1)
SGFence.SplineComponent = 0x318 // SplineComponent* (Size: 0x8)
SGFence.BeginSelector = 0x320 // EESGFenceSelector (Size: 0x1)
SGFence.BeginMesh1 = 0x328 // StaticMesh* (Size: 0x8)
SGFence.BeginMesh2 = 0x330 // StaticMesh* (Size: 0x8)
SGFence.BeginMesh3 = 0x338 // StaticMesh* (Size: 0x8)
SGFence.BeginMesh4 = 0x340 // StaticMesh* (Size: 0x8)
SGFence.bUseRandomForMiddle = 0x348 // bool (Size: 0x1)
SGFence.bUseMiddleSegmentsInOrder = 0x349 // bool (Size: 0x1)
SGFence.UnitLengthForMiddle = 0x34c // float (Size: 0x4)
SGFence.UnitSpacingForMiddle = 0x350 // float (Size: 0x4)
SGFence.PivotOffsetForMiddle = 0x354 // float (Size: 0x4)
SGFence.RandomStreamForMiddle = 0x358 // FRandomStream (Size: 0x8)
SGFence.MiddleMesh1 = 0x360 // StaticMesh* (Size: 0x8)
SGFence.MiddleMesh2 = 0x368 // StaticMesh* (Size: 0x8)
SGFence.MiddleMesh3 = 0x370 // StaticMesh* (Size: 0x8)
SGFence.MiddleMesh4 = 0x378 // StaticMesh* (Size: 0x8)
SGFence.EndSelector = 0x380 // EESGFenceSelector (Size: 0x1)
SGFence.EndMesh1 = 0x388 // StaticMesh* (Size: 0x8)
SGFence.EndMesh2 = 0x390 // StaticMesh* (Size: 0x8)
SGFence.EndMesh3 = 0x398 // StaticMesh* (Size: 0x8)
SGFence.EndMesh4 = 0x3a0 // StaticMesh* (Size: 0x8)
SGFireButton.PostStartFireByPress = 0x498 // FMulticastInlineDelegate (Size: 0x10)
SGFireButton.bIsLeftFireBtn = 0x4a8 // bool (Size: 0x1)
SGFireRepInfo.FireID = 0x0 // int64_t (Size: 0x8)
SGFireRepInfo.Timestamp = 0x8 // float (Size: 0x4)
SGFireRepInfo.Shots = 0x10 // FSGFireShots (Size: 0x28)
SGFireRepInfo.AmmoClass = 0x38 // ClassProperty (Size: 0x8)
SGFireRepInfo.FireMode = 0x40 // uint8_t (Size: 0x1)
SGFireRepInfo.AttackerPos = 0x44 // FVector (Size: 0xc)
SGFireRepInfo.ControlRotPacked = 0x50 // uint32_t (Size: 0x4)
SGFireRepInfo.ExpiredTimeOnServer = 0x54 // float (Size: 0x4)
SGFireRepInfo.CurFOV = 0x58 // uint8_t (Size: 0x1)
SGFireRepInfo.FireIntervalShotNum = 0x59 // uint8_t (Size: 0x1)
SGFireRepInfo.bIsReadyForNextFire = 0x5a // bool (Size: 0x1)
SGFireRepInfo.bIsWeaponCollapsed = 0x5b // bool (Size: 0x1)
SGFireRepInfo.bADS = 0x5c // bool (Size: 0x1)
SGFireRepInfo.ProjcetileClass = 0x60 // ClassProperty (Size: 0x8)
SGFireRepInfo.bValidateSuccess = 0x68 // bool (Size: 0x1)
SGFireRepInfo.RemainingAmmo = 0x69 // uint8_t (Size: 0x1)
SGFireRepInfo3P.FireID = 0x0 // int64_t (Size: 0x8)
SGFireRepInfo3P.Shots = 0x8 // FSGFireShots (Size: 0x28)
SGFireRepInfo3P.AmmoClass = 0x30 // ClassProperty (Size: 0x8)
SGFireRepInfo3P.ExpiredTimeOnServer = 0x38 // float (Size: 0x4)
SGFireRepInfo3P.bFireEnd = 0x3c // uint8_t (Size: 0x1)
SGFireRepInfo3P.bIsReadyForNextFire = 0x3c // uint8_t (Size: 0x1)
SGFireRepInfo3P.ShootingMode = 0x3d // EESGWeaponShootingMode (Size: 0x1)
SGFireRepInfo3P.FireIntervalShotNum = 0x3e // uint8_t (Size: 0x1)
SGFireRepInfo3P.ProjcetileClass = 0x40 // ClassProperty (Size: 0x8)
SGFireRepInfo3P.FireMode = 0x48 // uint8_t (Size: 0x1)
SGFireRepInfo3P.RemainingAmmo = 0x49 // uint8_t (Size: 0x1)
SGFireShot.ShotLocation = 0x0 // FVector_NetQuantize (Size: 0xc)
SGFireShot.ShotDirection = 0xc // FVector_NetQuantizeNormal (Size: 0xc)
SGFireShots.LaunchLocation = 0x0 // FVector (Size: 0xc)
SGFireShots.ShotLocation = 0xc // FVector (Size: 0xc)
SGFireShots.BulletPaths = 0x18 // TArray<FSGBulletPath> (Size: 0x10)
SGFireTrapComponent.fBurnDmgPerSec = 0xf8 // float (Size: 0x4)
SGFireTrapComponent.fPainProbability = 0xfc // float (Size: 0x4)
SGFireTrapComponent.BurnSound = 0x100 // AkAudioEvent* (Size: 0x8)
SGFireTrapComponent.bSoundPlaying = 0x114 // bool (Size: 0x1)
SGFiringWorldSubsystem.CachedBulletPassByActorMap = 0x30 // TMap<...> (Size: 0x50)
SGFirstPersonCameraMode.CameraSocketName = 0xb8 // FName (Size: 0x8)
SGFirstPersonCameraMode.LocationModifyCurve = 0xc0 // CurveVector* (Size: 0x8)
SGFirstPersonCameraMode.RotationModifyCurve = 0xc8 // CurveVector* (Size: 0x8)
SGFirstPersonCameraMode.HUDShakeEvents = 0xd0 // SGHUDShakeEvents* (Size: 0x8)
SGFirstPersonCameraMode_ClimbLadder.UnlimitedMaxPitch = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_ClimbLadder.UnlimitedMinPitch = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_ClimbLadder.LimitToggleDistanceThreshold = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_Crouch.UnlimitedMaxPitch = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_Crouch.UnlimitedMinPitch = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_Crouch.LimitToggleDistanceThreshold = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_DBNO.UnlimitedMaxPitch = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_DBNO.UnlimitedMinPitch = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_DBNO.LimitToggleDistanceThreshold = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_Default.InterpScaleWithSpeedSq = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_Diving.MinPitchWithYawCurve = 0xe0 // CurveFloat* (Size: 0x8)
SGFirstPersonCameraMode_FreeView.FreeViewMovement = 0xe0 // FVector2D (Size: 0x8)
SGFirstPersonCameraMode_FreeView.FreeViewMinYaw = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_FreeView.FreeViewMaxYaw = 0xec // float (Size: 0x4)
SGFirstPersonCameraMode_FreeView.FreeViewMinPitch = 0xf0 // float (Size: 0x4)
SGFirstPersonCameraMode_FreeView.FreeViewMaxPitch = 0xf4 // float (Size: 0x4)
SGFirstPersonCameraMode_Prone.UnlimitedMaxPitch = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_Prone.UnlimitedMinPitch = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_Prone.LimitToggleDistanceThreshold = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.bEnableCameraSway = 0xe0 // bool (Size: 0x1)
SGFirstPersonCameraMode_ProneZooming.SwayScale_Horizontal = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.SwayScale_Vertical = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.MaxSwayAmount_Vertical = 0xec // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.MaxSwayAmount_Horizontal = 0xf0 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.SwayInterpSpeed = 0xf4 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.SwayDeltaTimeLimit = 0xf8 // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.ConfigSpeedThreashold = 0xfc // float (Size: 0x4)
SGFirstPersonCameraMode_ProneZooming.MinPitchWithYawCurve = 0x100 // CurveFloat* (Size: 0x8)
SGFirstPersonCameraMode_Rescuer.UnlimitedMaxPitch = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_Rescuer.UnlimitedMinPitch = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_Rescuer.LimitToggleDistanceThreshold = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.TraceTargetTime = 0xe0 // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.ResetTime = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.ResetInterpSpeed = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.OnActiveStateTime = 0xec // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.OnActiveStateInterpSpeed = 0xf0 // float (Size: 0x4)
SGFirstPersonCameraMode_TDMDeath.CurrentState = 0xf4 // EETDMDeathCameraState (Size: 0x1)
SGFirstPersonCameraMode_TDMDeath.CacheKillerCharacter = 0x120 // Character* (Size: 0x8)
SGFirstPersonCameraMode_TDMDeath.TDMDeathOutlinePostprocessMaterial = 0x128 // MaterialInterface* (Size: 0x8)
SGFirstPersonCameraMode_TDMDeath.PostProcessVolume = 0x130 // PostProcessVolume* (Size: 0x8)
SGFirstPersonCameraMode_Zooming.bEnableCameraSway = 0xe0 // bool (Size: 0x1)
SGFirstPersonCameraMode_Zooming.SwayScale_Horizontal = 0xe4 // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.SwayScale_Vertical = 0xe8 // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.MaxSwayAmount_Vertical = 0xec // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.MaxSwayAmount_Horizontal = 0xf0 // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.SwayInterpSpeed = 0xf4 // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.SwayDeltaTimeLimit = 0xf8 // float (Size: 0x4)
SGFirstPersonCameraMode_Zooming.ConfigSpeedThreashold = 0xfc // float (Size: 0x4)
SGFloatCurvePlayer.Curve = 0x0 // CurveFloat* (Size: 0x8)
SGFloatCurvePlayer.PlayRate = 0x8 // float (Size: 0x4)
SGFloatCurvePlayer.bLoop = 0xc // bool (Size: 0x1)
SGFloatCurvePlayer.PlayRange = 0x10 // FFloatRange (Size: 0x10)
SGFlowManager.FlowComponentClasses = 0x310 // TArray<ClassProperty> (Size: 0x10)
SGFlowManager.FlowComponents = 0x320 // TArray<SGFlowBase*> (Size: 0x10)
SGFootprintManagerSubsystem.FootprintCharacters = 0x30 // TSet<...> (Size: 0x50)
SGForceMagnitudeFloat.MagnitudeCalculationType = 0x0 // EESGForceMagnitudeCalculation (Size: 0x1)
SGForceMagnitudeFloat.ConstantMagnitude = 0x4 // float (Size: 0x4)
SGForceMagnitudeFloat.RandomInRangeMagnitude = 0x8 // FVector2D (Size: 0x8)
SGForceMagnitudeFloat.DistributionCurveMagnitude = 0x10 // FRuntimeFloatCurve (Size: 0x88)
SGForceMagnitudeFloat.NegativeRate = 0x98 // float (Size: 0x4)
SGForceMagnitudeVector.X = 0x0 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector.Y = 0xa0 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector.Z = 0x140 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector4.X = 0x0 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector4.Y = 0xa0 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector4.Z = 0x140 // FSGForceMagnitudeFloat (Size: 0xa0)
SGForceMagnitudeVector4.W = 0x1e0 // FSGForceMagnitudeFloat (Size: 0xa0)
SGFreeGridQueryParams.IgnoreInventory = 0x0 // Actor* (Size: 0x8)
SGFreeGridQueryParams.IgnoreInventory2 = 0x8 // Actor* (Size: 0x8)
SGFreeGridQueryParams.bAllowMerge = 0x10 // bool (Size: 0x1)
SGFreeGridQueryParams.SelfItemID = 0x18 // int64_t (Size: 0x8)
SGFreeGridQueryParams.SearchingPrefer = 0x20 // EESearchingPrefer (Size: 0x1)
SGFreeLadder.TriggerBox = 0x310 // BoxComponent* (Size: 0x8)
SGFreeLadder.TopEnter = 0x318 // SceneComponent* (Size: 0x8)
SGFreeLadder.BottomEnter = 0x320 // SceneComponent* (Size: 0x8)
SGGADataReference.DataOwner = 0x0 // Object* (Size: 0x8)
SGGEData.OwnerItemID = 0x8 // uint32_t (Size: 0x4)
SGGEData.GameplayEffect = 0x10 // ClassProperty (Size: 0x8)
SGGEData.AttributeModifiers = 0x18 // TArray<FInventoryGEAttributeModifier> (Size: 0x10)
SGGEData.Duration = 0x28 // float (Size: 0x4)
SGGEData.Period = 0x2c // float (Size: 0x4)
SGGEData.DurationCalcClass = 0x30 // ClassProperty (Size: 0x8)
SGGEData.Chance = 0x38 // float (Size: 0x4)
SGGEData.GrantedTags = 0x40 // FGameplayTagContainer (Size: 0x20)
SGGEData.RemoveGEWithGameplayTag = 0x60 // FGameplayTagContainer (Size: 0x20)
SGGEData.GEAssetGameplayTag = 0x80 // FGameplayTagContainer (Size: 0x20)
SGGEData.bBodypartLimitUse = 0xa0 // bool (Size: 0x1)
SGGEData.PrematureExpirationGameplayEffectsRefList = 0xa8 // TArray<FSGGEDataLookupDT> (Size: 0x10)
SGGEData.RoutineExpirationGameplayEffectsRefList = 0xb8 // TArray<FSGGEDataLookupDT> (Size: 0x10)
SGGEDataLookupDT.DataOwner = 0x0 // DataTable* (Size: 0x8)
SGGEDataLookupDT.GEData_ID = 0x8 // uint32_t (Size: 0x4)
SGGEDataReference.DataOwner = 0x0 // DataTable* (Size: 0x8)
SGGEDataReference.GE_ID = 0x8 // uint32_t (Size: 0x4)
SGGIGASGlobalComponent.RecoveryTag_OutOfEndurance = 0x28 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_BoneBreak = 0x30 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_Bleed = 0x38 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_Pain = 0x40 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_EnduranceLoss = 0x48 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_TearGas = 0x50 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_Moisture = 0x58 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_Food = 0x60 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.RecoveryTag_RescueMyself = 0x68 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.ActionTag_SelfRescue = 0x70 // FGameplayTag (Size: 0x8)
SGGIGASGlobalComponent.Block_Sprint = 0x78 // FGameplayTag (Size: 0x8)
SGGSAILevelComponent.LevelLoadOnClient = 0x108 // bool (Size: 0x1)
SGGSDSParamComponent.IsPrepared = 0x100 // bool (Size: 0x1)
SGGSDSParamComponent.PMCNum = 0x104 // int32_t (Size: 0x4)
SGGSDSParamComponent.OBNum = 0x158 // int32_t (Size: 0x4)
SGGSDSParamComponent.BossShield = 0x160 // TMap<...> (Size: 0x50)
SGGSDSParamComponent.DSParamArray = 0x1b0 // TArray<int32_t> (Size: 0x10)
SGGSDSParamComponent.bUseSoundIndicator = 0x1c0 // bool (Size: 0x1)
SGGSDSParamComponent.InitFunctionConfig = 0x1c1 // bool (Size: 0x1)
SGGSDSParamComponent.UseAIRL = 0x1c4 // int32_t (Size: 0x4)
SGGSDSParamComponent.ActulUseAIRL = 0x1c8 // bool (Size: 0x1)
SGGSDSParamComponent.UsePoorCheet = 0x1cc // int32_t (Size: 0x4)
SGGSDSParamComponent.ActulUsePoorCheet = 0x1d0 // bool (Size: 0x1)
SGGSDSParamComponent.PoorCheetValue = 0x1d4 // int32_t (Size: 0x4)
SGGSDSParamComponent.UseSafeGuard = 0x1d8 // int32_t (Size: 0x4)
SGGSDSParamComponent.ActulUseSafeGuard = 0x1dc // bool (Size: 0x1)
SGGSDSParamComponent.UseLaunderCheet = 0x1e0 // int32_t (Size: 0x4)
SGGSDSParamComponent.ActulUseLaunderCheet = 0x1e4 // bool (Size: 0x1)
SGGSDSParamComponent.UseAntiCamper = 0x1e8 // int32_t (Size: 0x4)
SGGSDSParamComponent.ActulUseAntiCamper = 0x1ec // bool (Size: 0x1)
SGGSDSParamComponent.DisableLootPointIDs = 0x1f0 // TArray<int32_t> (Size: 0x10)
SGGSDSParamComponent.OnEquipInfoFinish = 0x200 // FMulticastInlineDelegate (Size: 0x10)
SGGSDSParamComponent.ActivityList = 0x210 // TArray<FActivityInfo> (Size: 0x10)
SGGSDSParamComponent.PlayerAuthInfoList = 0x220 // TArray<FPlayerAuthInfo> (Size: 0x10)
SGGSDSParamComponent.PlayerTokenMap = 0x230 // TMap<...> (Size: 0x50)
SGGSDSParamComponent.DiscardTokenArr = 0x280 // TArray<FString> (Size: 0x10)
SGGSDSParamComponent.WeatherInfo = 0x290 // FWeatherInfo (Size: 0x18)
SGGSDSParamComponent.RoomRanking = 0x2a8 // int32_t (Size: 0x4)
SGGSDSParamComponent.bGiveBackTeammateItem = 0x2ac // bool (Size: 0x1)
SGGSDSParamComponent.ItemValueMap = 0x2b0 // TMap<...> (Size: 0x50)
SGGSDSParamComponent.MatchIsolationType = 0x300 // uint32_t (Size: 0x4)
SGGSDSParamComponent.IsTakeInThresholdGame = 0x304 // bool (Size: 0x1)
SGGSDSParamComponent.IsMarkInHighRatio_CompetitionGame = 0x305 // bool (Size: 0x1)
SGGSDSParamComponent.CompetitionRoomID = 0x308 // uint64_t (Size: 0x8)
SGGSDSParamComponent.DsZone = 0x310 // int32_t (Size: 0x4)
SGGSDSParamComponent.IsVehicleMap = 0x314 // bool (Size: 0x1)
SGGSDSParamComponent.AnnihilateTempleEquipsMap = 0x318 // TMap<...> (Size: 0x50)
SGGSDSParamComponent.SuitEquipsAry = 0x368 // TArray<FSuitInfo> (Size: 0x10)
SGGSDSParamComponent.RWGStartSuit = 0x378 // FSuitInfo (Size: 0x40)
SGGSDSParamComponent.SupplyStationGroupConfigID = 0x3b8 // int64_t (Size: 0x8)
SGGSDSParamComponent.DurabilitySellBasePercent = 0x3c0 // int32_t (Size: 0x4)
SGGSDSParamComponent.CloudEnvType = 0x418 // uint32_t (Size: 0x4)
SGGSDSParamComponent.LuckyCollectionItemLimit = 0x41c // uint32_t (Size: 0x4)
SGGSDSParamComponent.RepairMaterialCoefMap = 0x420 // TMap<...> (Size: 0x50)
SGGSDSParamComponent.LowTechCoef = 0x470 // float (Size: 0x4)
SGGSDSParamComponent.UnitRepairPriceCoef = 0x474 // float (Size: 0x4)
SGGSKillEventReportComponent.ReportRule = 0x148 // EESGReportRule (Size: 0x1)
SGGSKillEventReportComponent.ReportCharacterType = 0x150 // TArray<EECharacterType> (Size: 0x10)
SGGSLootInventoryProtectManager.AnnounceIDForLootProtect = 0x100 // int32_t (Size: 0x4)
SGGSPasswordDoorManagerComponent.ClosedZoneLength = 0x100 // int32_t (Size: 0x4)
SGGSPasswordDoorManagerComponent.Strong_ClosedZoneLength = 0x104 // int32_t (Size: 0x4)
SGGSPasswordDoorManagerComponent.PasswordNumberList = 0x108 // TArray<int32_t> (Size: 0x10)
SGGSPasswordDoorManagerComponent.PasswordLetterList = 0x118 // TArray<int32_t> (Size: 0x10)
SGGSPasswordDoorManagerComponent.PasswordLength = 0x128 // int32_t (Size: 0x4)
SGGSPasswordDoorManagerComponent.PasswordIndexList = 0x130 // TArray<int32_t> (Size: 0x10)
SGGSPasswordDoorManagerComponent.bIsAlreadyUnLock = 0x140 // bool (Size: 0x1)
SGGSPasswordDoorManagerComponent.CacheUnLockUser = 0x148 // Character* (Size: 0x8)
SGGSPasswordDoorManagerComponent.bIsAlreadyInitPasswordInfo = 0x150 // bool (Size: 0x1)
SGGameInfo.MainModeID = 0x0 // uint32_t (Size: 0x4)
SGGameInfo.SubModeID = 0x4 // uint32_t (Size: 0x4)
SGGameInfo.MapID = 0x8 // uint32_t (Size: 0x4)
SGGameInfo.Difficulty = 0xc // uint32_t (Size: 0x4)
SGGameInfo.SpecialID = 0x10 // uint32_t (Size: 0x4)
SGGameInstance.OnWorldBeginPlay = 0x1d0 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstance.DeviceLevel_HighEnd = 0x200 // int32_t (Size: 0x4)
SGGameInstance.OnScreenOrientationChanged = 0x208 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstance.CacheLocalPC = 0x218 // PlayerController* (Size: 0x8)
SGGameInstance.ComponentClasses = 0x220 // TArray<ClassProperty> (Size: 0x10)
SGGameInstance.Components = 0x230 // TArray<SGGameInstanceComponent*> (Size: 0x10)
SGGameInstance.CachePackages = 0x258 // TArray<Package*> (Size: 0x10)
SGGameInstance.CacheWorlds = 0x268 // TArray<World*> (Size: 0x10)
SGGameInstance.MapNameToPath = 0x278 // TMap<...> (Size: 0x50)
SGGameInstance.TexturesStreamingInfo = 0x2f0 // TMap<...> (Size: 0x50)
SGGameInstance.MeshCustomDepthStencilInfo = 0x340 // TMap<...> (Size: 0x50)
SGGameInstanceCmdObjectManagerComponent.CmdObjectManager = 0x28 // SGCmdObjectManager* (Size: 0x8)
SGGameInstanceConsoleCommandComponent.BenchmarkSequenceActor = 0x28 // LevelSequenceActor* (Size: 0x8)
SGGameInstanceG6PlatformComponent.G6PlatformGameInstanceClass = 0x28 // ClassProperty (Size: 0x8)
SGGameInstanceG6PlatformComponent.G6PlatformGameInstance = 0x30 // G6PlatformGameInstance* (Size: 0x8)
SGGameInstanceGameInfoComponent.SGGameInfo = 0x28 // FSGGameInfo (Size: 0x14)
SGGameInstanceGameInfoComponent.OverrideGameModeID = 0x48 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceGameInfoComponent.SwitchesFlag = 0x58 // int32_t (Size: 0x4)
SGGameInstanceLoadingScreenComponent.PanelZOrder = 0x28 // int32_t (Size: 0x4)
SGGameInstanceLoadingScreenComponent.LoadingFinishDelegate = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceLoadingScreenComponent.bLoadingFinishForce = 0x40 // bool (Size: 0x1)
SGGameInstanceLoadingScreenComponent.LoadingInfoArray = 0x48 // TArray<FSGLoadingInfo> (Size: 0x10)
SGGameInstanceLoadingScreenComponent.UMGLoadingScreenWidget = 0x58 // UserWidget* (Size: 0x8)
SGGameInstanceLoadingScreenComponent.UMGSeparateLoadingScreenWidget = 0x60 // UserWidget* (Size: 0x8)
SGGameInstanceLoadingScreenComponent.LoadingAnimation = 0x68 // LoadingAnimation* (Size: 0x8)
SGGameInstanceLoadingScreenComponent.rootCanvas = 0x70 // CanvasPanel* (Size: 0x8)
SGGameInstanceLoadingScreenComponent.bUsePostLoadingUI = 0x78 // bool (Size: 0x1)
SGGameInstanceLoadingScreenComponent.bUseSeparateLoadingUI = 0x79 // bool (Size: 0x1)
SGGameInstanceLoadingScreenComponent.LastLoadingPath = 0x80 // FString (Size: 0x10)
SGGameInstanceLoadingScreenComponent.LoadingScreenMovie = 0x90 // TArray<FString> (Size: 0x10)
SGGameInstanceLoadingScreenComponent.MinMovieTime = 0xa0 // float (Size: 0x4)
SGGameInstanceLoadingScreenComponent.MovieOrderLevel = 0xa8 // FString (Size: 0x10)
SGGameInstanceLoadingScreenComponent.bMovieWithUMG = 0xc8 // bool (Size: 0x1)
SGGameInstanceLoadingScreenComponent.bTickEnable = 0xc9 // bool (Size: 0x1)
SGGameInstanceLoadingScreenComponent.GPreMapName = 0xd0 // FString (Size: 0x10)
SGGameInstanceLoadingScreenComponent.GMapName = 0xe0 // FString (Size: 0x10)
SGGameInstanceLoadingScreenComponent.LoadingTickHandle = 0xf0 // LoadingScreenTickableGameObject* (Size: 0x8)
SGGameInstanceLoadingScreenComponent.MapDefaultLoadingMap = 0x130 // UserWidget* (Size: 0x8)
SGGameInstancePluginManagerComponent.PluginManagerClass = 0x28 // ClassProperty (Size: 0x8)
SGGameInstancePluginManagerComponent.PluginManager = 0x30 // MFPWPluginManager* (Size: 0x8)
SGGameInstanceReplaySubsystem.OnReplayStateGameEvent = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceReplaySubsystem.HttpDownloadKillCamInfoList = 0xa0 // TArray<FSGLocalFileKillCamInfo> (Size: 0x10)
SGGameInstanceReplaySubsystem.LocalFileKillCamInfo = 0xb8 // FSGLocalFileKillCamInfo (Size: 0xd8)
SGGameInstanceReplaySubsystem.LoadingWidget = 0x1b0 // UserWidget* (Size: 0x8)
SGGameInstanceReplaySubsystem.OnPostSpectateKillerEvent = 0x208 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceReplaySubsystem.OnAllActorReady = 0x218 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceReplaySubsystem.OnReplayScrubCompleteEvent = 0x228 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceReplaySubsystem.ReplayContentType = 0x240 // EESGReplayContentType (Size: 0x1)
SGGameInstanceSwitchConfigComponent.InitWorld = 0x28 // World* (Size: 0x8)
SGGameInstanceSwitchConfigComponent.DeferredCmdList = 0x30 // TArray<FDeferredExecCmd> (Size: 0x10)
SGGameInstanceSwitchLevelComponent.LevelName = 0x30 // FString (Size: 0x10)
SGGameInstanceSwitchLevelComponent.CachedLevelName = 0x40 // FString (Size: 0x10)
SGGameInstanceSwitchLevelComponent.InitWorld = 0x50 // World* (Size: 0x8)
SGGameInstanceWeakNetworkComponent.OnNetWorkChanged = 0x28 // FMulticastInlineDelegate (Size: 0x10)
SGGameInstanceWeakNetworkComponent.NetworkObserver = 0x38 // MFGCloudNetworkObserver* (Size: 0x8)
SGGameInstanceWeakNetworkComponent.ReconnectWidget = 0x40 // UserWidget* (Size: 0x8)
SGGameInstanceWeakNetworkComponent.OpenUrl = 0x48 // FURL (Size: 0x68)
SGGameMode.ExitGameDelayTime = 0x3f8 // float (Size: 0x4)
SGGameMode.SoundPlayerClass = 0x400 // ClassProperty (Size: 0x8)
SGGameMode.WaitDelayRestartPlayer = 0x408 // bool (Size: 0x1)
SGGameMode.MainModeIDPIE = 0x40c // int32_t (Size: 0x4)
SGGameMode.SubModeIDPIE = 0x410 // int32_t (Size: 0x4)
SGGameMode.DifficultyPIE = 0x414 // int32_t (Size: 0x4)
SGGameMode.SpecialIDPIE = 0x418 // int32_t (Size: 0x4)
SGGameMode.CharacterSpawnType = 0x41c // EESGCharacterSpawnType (Size: 0x1)
SGGameMode.PlayersToken = 0x420 // TArray<FString> (Size: 0x10)
SGGameMode.NewClientConnTime = 0x430 // int32_t (Size: 0x4)
SGGameMode.PlayerLocData = 0x448 // TArray<SGCharacter*> (Size: 0x10)
SGGameMode.DelayRestartPlayerQueue = 0x4d8 // TArray<Controller*> (Size: 0x10)
SGGameMode.PreLoginPlayers = 0x4e8 // TArray<uint64_t> (Size: 0x10)
SGGameMode.DSMultiNetTickOccurRate = 0x530 // float (Size: 0x4)
SGGameMode.DSMultiNetTickIntervalAvg = 0x534 // float (Size: 0x4)
SGGameMode.DSTickIntervalAvg = 0x538 // float (Size: 0x4)
SGGameMode.DynamicTickChangeCount = 0x53c // int32_t (Size: 0x4)
SGGameMode.DSMultiNetTickDisableCountByConcentration = 0x540 // int32_t (Size: 0x4)
SGGameMode.UFPlayers = 0x548 // FUAUFStruct (Size: 0xb0)
SGGameModeActiveSettlementComp.ActiveSettlementPlayerGIDList = 0x100 // TArray<int64_t> (Size: 0x10)
SGGameModeActiveSettlementComp.bCanActiveSettlement = 0x110 // bool (Size: 0x1)
SGGameModeActiveSettlementComp.ValidTeamIndexs = 0x118 // TArray<int32_t> (Size: 0x10)
SGGameModeActiveSettlementComp.nCanActiveSettlementTeamNumber = 0x128 // int32_t (Size: 0x4)
SGGameModeActiveSettlementComp.FoceSettlementType = 0x12c // EEPlayerEndGameType (Size: 0x1)
SGGameModeActivityManagerComponent.ActivityRequireComponentInfos = 0x100 // TMap<...> (Size: 0x50)
SGGameModeActivityManagerComponent.ActivatedActivities = 0x150 // TArray<EEActivityType> (Size: 0x10)
SGGameModeActivityManagerComponent.bisThemeMode = 0x170 // bool (Size: 0x1)
SGGameModeActivityManagerComponent.EditorTestActivities = 0x178 // TArray<EEActivityType> (Size: 0x10)
SGGameModeChoosePlayerStartComponent.LastStartSpot = 0x100 // Actor* (Size: 0x8)
SGGameModeChoosePlayerStartComponent.ValidAIAddtionStartGroupNum = 0x108 // int32_t (Size: 0x4)
SGGameModeEndConditionComponent.EndConditionClasses = 0xf8 // TArray<ClassProperty> (Size: 0x10)
SGGameModeEndConditionComponent.EndConditions = 0x108 // TArray<SGGameModeEndCondition*> (Size: 0x10)
SGGameModeEvents.Login = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.PostLogin = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.Logout = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.Killed = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.MissionKilled = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.LaterKilled = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.KilledV2 = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.LaterKilledV2 = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.DBNOPlayer = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.DiedEnterDBNO = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.MatchStateChanged = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.PreGameFlowStateChanged = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameFlowStateChanged = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameModePlayerFinishGameEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameModePrePlayerFinishGameEvent0 = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameModePrePlayerFinishGameEvent = 0x120 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameModeFactionSettlement = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.ReqPlayerFinishGameEvent = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.ReqOBPlayerFinishGameEvent = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnReqExitWatchGame = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnPostReqExitWatchGame = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnDSParamPrepared = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnQuestStateChange = 0x190 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnQuestGraphStatusChange = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnQuestProgressChange = 0x1b0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnMissionInstanceDataChanged = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnMissionReplicateDataChanged = 0x1d0 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.bQuestReportInitialized = 0x1e0 // bool (Size: 0x1)
SGGameModeEvents.OnMissionFlowReplicateDataChanged = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAllPMCFinishSpawning = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RestartPlayer = 0x208 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAISpawned = 0x218 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAISpawnedForDebug = 0x228 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAIActived = 0x238 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnApplicationWillDeactive = 0x248 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnApplicationHasReactive = 0x258 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnServerLoadComplete = 0x268 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnGameTimeOut = 0x278 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnGameBegin = 0x288 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnGameDeployIn = 0x298 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnServerTimeRep = 0x2a8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnGameBeginTimeRep = 0x2b8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnPreBeginGameInit = 0x2c8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnBeginGameInit = 0x2d8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnPostBeginGameInit = 0x2e8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAfterBeginGameInit = 0x2f8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnPostBeginGameInit_AIConfigNode = 0x308 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnPostBeginGameInit_AISpawn = 0x318 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnActivityInit = 0x328 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.BeginHook = 0x338 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.EndGameSettle = 0x348 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.PreGotoHallroom = 0x368 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnEscapePointReport = 0x378 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.GameModePlayerStartGameEvent = 0x388 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnChaseActivityStateChange = 0x398 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnLevelAddToWorld = 0x3a8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnLevelRemoveFromWorld = 0x3b8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnDoorGateReport = 0x3c8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnLootPointSpawnCompleted = 0x3d8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnWatchGameStateChanged = 0x3e8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnOwnedActivityInventoryInfoChange = 0x3f8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnUploadNPCEquipFinish = 0x408 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAIEquipmentPoolCapacityGrown = 0x418 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnAIIDMappingReady = 0x428 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnGashaReadyToLoot = 0x438 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.OnBUseSoundIndicatorChange = 0x448 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RangeInAreaListChange = 0x458 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.UnLoadProtectAllCharacter = 0x468 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.MissionInformGameEnd = 0x478 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RoundGamePrepare = 0x488 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RoundGameCountDown = 0x498 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RoundGameBegin = 0x4a8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.AnnihilateKillEventReport = 0x4b8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.TDMPrepare = 0x4c8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.TDMCountDown = 0x4d8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.TDMGameBegin = 0x4e8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.TDMRoundBegin = 0x4f8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.MPGameEnding = 0x508 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.ARGPlayerUpgrade = 0x518 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.ARGPlayerFactionLevelupReport = 0x528 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.RWGRandomWeapon = 0x538 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeEvents.MPGameRoundTimeChanged = 0x548 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeGameFlowComponent.BeginGameInit = 0x100 // bool (Size: 0x1)
SGGameModeGameFlowComponent.PostInitDelayFrame = 0x104 // int32_t (Size: 0x4)
SGGameModeInventoryManagerComponent.DisableLootPointIDs = 0x110 // TArray<int32_t> (Size: 0x10)
SGGameModeInventoryManagerComponent.InventoryFactoryComponents = 0x120 // TArray<SGActorInventoryFactoryComponent*> (Size: 0x10)
SGGameModeInventoryManagerComponent.OneTickMaxSpawnCount = 0x130 // int32_t (Size: 0x4)
SGGameModeInventoryManagerComponent.OneTickMaxSecondCost = 0x134 // float (Size: 0x4)
SGGameModeInventoryManagerComponent.ItemShieldRandom = 0x140 // TMap<...> (Size: 0x50)
SGGameModeInventoryManagerComponent.GuaranteeItemShieldRandom = 0x190 // TMap<...> (Size: 0x50)
SGGameModeInventoryManagerComponent.bDropDisappear = 0x1e0 // bool (Size: 0x1)
SGGameModeInventoryManagerComponent.OnSpawnLootInventoryOver = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeInventoryManagerComponent.OnInitDoorLockStateFinish = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeRespawnConditionComponent.RespawnConditionClasses = 0xf8 // TArray<ClassProperty> (Size: 0x10)
SGGameModeRespawnConditionComponent.RespawnConditions = 0x108 // TArray<SGGameModeRespawnCondition*> (Size: 0x10)
SGGameModeStartMatchComponent.OnLoadComplete = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGGameModeStartMatchComponent.bLoadingChecking = 0x110 // bool (Size: 0x1)
SGGameModeStartMatchComponent.bIsLoadComplete = 0x111 // bool (Size: 0x1)
SGGameModeStartMatchComponent.bNotStartMatch = 0x112 // bool (Size: 0x1)
SGGameModeStartMatchComponent.bStartWithTeamMakeWidget = 0x113 // bool (Size: 0x1)
SGGameModeStartMatchComponent.CheckTimeTheshold_AISpawn = 0x120 // double (Size: 0x8)
SGGameModeVictoryConditionComponent.VictoryConditionClasses = 0xf8 // TArray<ClassProperty> (Size: 0x10)
SGGameModeVictoryConditionComponent.VictoryConditions = 0x108 // TArray<SGGameModeVictoryCondition*> (Size: 0x10)
SGGamePlayAbility_UseContraband.Inventory = 0x550 // SGInventory* (Size: 0x8)
SGGamePlayAbility_UseContraband.Character = 0x558 // SGCharacter* (Size: 0x8)
SGGamePlayAbility_UseContraband.SGGADataRef = 0x560 // FSGGADataReference (Size: 0x10)
SGGamePlayAbility_UseContraband.AppliedEffectHandlesWhileBegined = 0x598 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
SGGamePlayAbility_UseContraband.CachedNextWeapon = 0x5c0 // SGInventory* (Size: 0x8)
SGGameSettings_Sensitivity.SensitivityMaxValue = 0x38 // int32_t (Size: 0x4)
SGGameSettings_Sensitivity.SensitivityMinValue = 0x3c // int32_t (Size: 0x4)
SGGameSettings_Sensitivity.SensitiveScale = 0x40 // float (Size: 0x4)
SGGameSettings_Sensitivity.SensitiveScaleForSimulator = 0x44 // float (Size: 0x4)
SGGameSettings_Sensitivity.bUseFireSensitivity = 0x48 // int32_t (Size: 0x4)
SGGameSettings_Sensitivity.CameraSensitivities = 0x50 // TArray<FSensitivityData> (Size: 0x10)
SGGameSettings_Sensitivity.CurrentCameraSensitivity = 0x60 // FSensitivityData (Size: 0x28)
SGGameSettings_Sensitivity.FireSensitivities = 0x88 // TArray<FSensitivityData> (Size: 0x10)
SGGameSettings_Sensitivity.CurrentFireSensitivity = 0x98 // FSensitivityData (Size: 0x28)
SGGameSettings_Sensitivity.GyroSensitivities = 0xc0 // TArray<FSensitivityData> (Size: 0x10)
SGGameSettings_Sensitivity.CurrentGyroSensitivity = 0xd0 // FSensitivityData (Size: 0x28)
SGGameSettings_Sensitivity.CameraSensitivityMode = 0xf8 // uint8_t (Size: 0x1)
SGGameSettings_Sensitivity.FireSensitivityMode = 0xf9 // uint8_t (Size: 0x1)
SGGameSettings_Sensitivity.GyroSensitivityMode = 0xfa // uint8_t (Size: 0x1)
SGGameState.bDamageHurtsHealth = 0x398 // bool (Size: 0x1)
SGGameState.bIsOpenDeathThirdPersonCamera = 0x399 // bool (Size: 0x1)
SGGameState.CameraTraceTime = 0x39c // float (Size: 0x4)
SGGameState.bUseLootAreaTips = 0x3a0 // bool (Size: 0x1)
SGGameState.roomid = 0x428 // uint64_t (Size: 0x8)
SGGameState.CurServerTickRate = 0x430 // float (Size: 0x4)
SGGameState.FixedServerTickRate = 0x434 // int32_t (Size: 0x4)
SGGameState.Server_Season_ID = 0x438 // uint32_t (Size: 0x4)
SGGameState.DynamicMissionFlowList = 0x440 // TArray<FMissionFlowData> (Size: 0x10)
SGGameState.DistributedMissionFlowIDs = 0x450 // TArray<uint32_t> (Size: 0x10)
SGGameState.ComponentClasses = 0x460 // TArray<ClassProperty> (Size: 0x10)
SGGameState.ComponentClassesAdditional = 0x470 // TArray<ClassProperty> (Size: 0x10)
SGGameState.TemplateClass = 0x480 // ClassProperty (Size: 0x8)
SGGameState.ServerRealTimeDelta = 0x488 // FTimespan (Size: 0x8)
SGGameState.ServerRealTimeDeltaAdjust = 0x490 // FTimespan (Size: 0x8)
SGGameState.ReplicateServerTime = 0x4a0 // FDateTime (Size: 0x8)
SGGameState.ReplicateTimeCountDown = 0x4a8 // float (Size: 0x4)
SGGameState.PlayerFinishTypeMap = 0x4b0 // TMap<...> (Size: 0x50)
SGGameState.GIDAliveStateMap = 0x500 // TMap<...> (Size: 0x50)
SGGameState.DebugCompInfoClasses = 0x560 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGGameState.GameSceneType = 0x571 // EEGameSceneType (Size: 0x1)
SGGameState.FactionManagerComponent = 0x578 // SGGameStateFactionManagerComponent* (Size: 0x8)
SGGameState.GameStateStatisComponent = 0x580 // SGGameStateStatisComponent* (Size: 0x8)
SGGameState.GameFlowStateComponent = 0x588 // SGGameStateGameFlowStateComponent* (Size: 0x8)
SGGameState.bEnableOptimizeSyncVehiclePhysicState = 0x590 // bool (Size: 0x1)
SGGameState.bEnableClientAdjustByDSPhysicState = 0x591 // bool (Size: 0x1)
SGGameState.bEnableVehicle1PAuthority = 0x592 // bool (Size: 0x1)
SGGameState.bEnableVehiclePredictLocation = 0x593 // bool (Size: 0x1)
SGGameState.bEnableVehiclePredictRotation = 0x594 // bool (Size: 0x1)
SGGameState.fCheckDSVehicleStabledTime = 0x598 // float (Size: 0x4)
SGGameState.VehicleOptimizeLevelCfg = 0x59c // int32_t (Size: 0x4)
SGGameState.VehicleOptimizeLevel = 0x5a0 // int32_t (Size: 0x4)
SGGameState.NormalKeyDurationCost = 0x5a4 // float (Size: 0x4)
SGGameState.DSNetTickRate = 0x5a8 // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.BossSquadIDs = 0x108 // TArray<int32_t> (Size: 0x10)
SGGameStateAIDebugInfoComponent.SquadIDRangeMin = 0x118 // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.SquadIDRangeMax = 0x11c // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.bShowDetails = 0x120 // bool (Size: 0x1)
SGGameStateAIDebugInfoComponent.ShowSquadType = 0x124 // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.AISenseTotalQueries = 0x128 // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.AISenseAverageCount = 0x12c // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.DebugAIInfoList = 0x130 // TArray<FSpawnedAIInfoForDebug> (Size: 0x10)
SGGameStateAIDebugInfoComponent.SpawnedAI = 0x148 // TMap<...> (Size: 0x50)
SGGameStateAIDebugInfoComponent.ScavInfos = 0x198 // TArray<FScavInfo> (Size: 0x10)
SGGameStateAIDebugInfoComponent.MapID = 0x1a8 // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.SpawnConfigID = 0x1ac // int32_t (Size: 0x4)
SGGameStateAIDebugInfoComponent.AISpawnLevelName = 0x1b0 // FString (Size: 0x10)
SGGameStateAIDebugInfoComponent.bAISpawnStarted = 0x1c0 // bool (Size: 0x1)
SGGameStateAIDebugInfoComponent.bCanSpawnAIPMC = 0x1c1 // bool (Size: 0x1)
SGGameStateAIDebugInfoComponent.bPlayerPMCSpawnFinished = 0x1c2 // bool (Size: 0x1)
SGGameStateAIDebugInfoComponent.bAISpawnControllerIsValid = 0x1c3 // bool (Size: 0x1)
SGGameStateAIDebugInfoComponent.AIHudMobileWidget = 0x1d0 // UserWidget* (Size: 0x8)
SGGameStateBigGoldRaidComponent.CanInteractTimeRange = 0x100 // FVector2D (Size: 0x8)
SGGameStateBigGoldRaidComponent.AirdropUnLockTime = 0x108 // float (Size: 0x4)
SGGameStateBigGoldRaidComponent.GameStartAnnounceConfigID = 0x10c // int32_t (Size: 0x4)
SGGameStateBigGoldRaidComponent.CanInteractAnnounceConfigID = 0x110 // int32_t (Size: 0x4)
SGGameStateBigGoldRaidComponent.BigGoldBeTakenAnnounceConfigID = 0x114 // int32_t (Size: 0x4)
SGGameStateBigGoldRaidComponent.AIEventStrList = 0x118 // TArray<FString> (Size: 0x10)
SGGameStateBigGoldRaidComponent.GameStartAnnounceDelayTime = 0x128 // float (Size: 0x4)
SGGameStateBigGoldRaidComponent.RealCanInteractTime = 0x12c // float (Size: 0x4)
SGGameStateBigGoldRaidComponent.StateTimeHandle = 0x130 // float (Size: 0x4)
SGGameStateBigGoldRaidComponent.CurrentInteractState = 0x134 // EEBigGoldRaidInteractState (Size: 0x1)
SGGameStateBigGoldRaidComponent.AirdropUnLockLastTime = 0x138 // float (Size: 0x4)
SGGameStateBigGoldRaidComponent.CantInteractLastTime = 0x13c // float (Size: 0x4)
SGGameStateChaseActivityInfoComp.MinScanInterval = 0x100 // float (Size: 0x4)
SGGameStateChaseActivityInfoComp.ChaseActivityStateChangeInfo = 0x104 // FChaseActivityStateChangeInfo (Size: 0x8)
SGGameStateChaseActivityInfoComp.ActivityAvatarInfos = 0x110 // TArray<FChaseActivityAvatarInfo> (Size: 0x10)
SGGameStateChaseActivityInfoComp.ActivityInventoryIDs = 0x120 // TArray<int32_t> (Size: 0x10)
SGGameStateChaseActivityInfoComp.HasActivityInventoryAliveAI = 0x130 // TArray<Character*> (Size: 0x10)
SGGameStateClientInventoryComponent.InvUIFlagChangedEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGGameStateClientInventoryComponent.LocalInventoryMap = 0x110 // TMap<...> (Size: 0x50)
SGGameStateDeathDropComponent.DeathDropType = 0x108 // EEDeathDropType (Size: 0x1)
SGGameStateDeathDropComponent.DuplicationDropRate = 0x10c // float (Size: 0x4)
SGGameStateDeathDropComponent.ConvertToMoneyItemCountMinCoefficient = 0x110 // float (Size: 0x4)
SGGameStateDeathDropComponent.ConvertToMoneyItemCountMaxCoefficient = 0x114 // float (Size: 0x4)
SGGameStateDeathDropComponent.MaxValueAdapterConvertRateMin = 0x118 // float (Size: 0x4)
SGGameStateDeathDropComponent.MaxValueAdapterConvertRateMax = 0x11c // float (Size: 0x4)
SGGameStateDeathDropComponent.ConvertWeightPow = 0x120 // float (Size: 0x4)
SGGameStateDeathDropComponent.MoneyItemID = 0x124 // int32_t (Size: 0x4)
SGGameStateDeathDropComponent.ItemTotalValueToMoneyCoefficient = 0x128 // float (Size: 0x4)
SGGameStateDeathDropComponent.ArmorDurabilityConvertCoefficientMin = 0x12c // float (Size: 0x4)
SGGameStateDeathDropComponent.ArmorDurabilityConvertCoefficientMax = 0x130 // float (Size: 0x4)
SGGameStateDeathDropComponent.HighValueItemConvertCoefficient = 0x134 // float (Size: 0x4)
SGGameStateDeathDropComponent.DebugInfo = 0x138 // FString (Size: 0x10)
SGGameStateDeathDropComponent.CurseInfos = 0x148 // TArray<FTeammateCurseInfo> (Size: 0x10)
SGGameStateDestroyActorManagerComponent.UnreplicateActorInfoQueue = 0x100 // TArray<FDeferUnreplicateActorInFrameInfo> (Size: 0x10)
SGGameStateDestroyActorManagerComponent.DestroyActorInfoQueue = 0x110 // TArray<FDeferDestroyActorInFrameInfo> (Size: 0x10)
SGGameStateDestroyActorManagerComponent.DestroyCharacterInfoQueue = 0x120 // TArray<FDeferDestroyCharacterInFrameInfo> (Size: 0x10)
SGGameStateDestroyActorManagerComponent.InventoryToRemove = 0x138 // TArray<SGInventory*> (Size: 0x10)
SGGameStateEscapeComponent.EscapeInfoArr = 0x100 // TArray<FEscapeInfo> (Size: 0x10)
SGGameStateEventManagerComponent.EventsObjectClasses = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGGameStateEventManagerComponent.EventsObjects = 0x110 // TArray<Object*> (Size: 0x10)
SGGameStateFactionManagerComponent.Factions = 0x100 // TArray<SGFaction*> (Size: 0x10)
SGGameStateFactionManagerComponent.FactionClass = 0x110 // ClassProperty (Size: 0x8)
SGGameStateFlowComponent.CurGameState = 0x100 // EESGRoundGameState (Size: 0x1)
SGGameStateFlowComponent.CurrRound = 0x104 // int32_t (Size: 0x4)
SGGameStateFlowComponent.StateBeginTime = 0x108 // float (Size: 0x4)
SGGameStateFlowComponent.StateTotleTime = 0x10c // float (Size: 0x4)
SGGameStateFlowComponent.MinLoadTime = 0x110 // float (Size: 0x4)
SGGameStateFlowComponent.MaxLoadTime = 0x114 // float (Size: 0x4)
SGGameStateFlowComponent.CountDownTime = 0x118 // float (Size: 0x4)
SGGameStateGameFlowStateComponent.OnWhetherCanFinishGameChangeEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGGameStateGameFlowStateComponent.bWhetherCanFinishGame = 0x110 // bool (Size: 0x1)
SGGameStateGameFlowStateComponent.GameFlowState = 0x114 // FName (Size: 0x8)
SGGameStateGameFlowStateComponent.OldState = 0x11c // FName (Size: 0x8)
SGGameStateGameFlowStateComponent.bIsServerInPIE = 0x124 // bool (Size: 0x1)
SGGameStateGameFlowStateComponent.GameTime = 0x128 // float (Size: 0x4)
SGGameStateGameFlowStateComponent.BeginTime = 0x130 // FDateTime (Size: 0x8)
SGGameStateGoldInventoryManager.GoldSpawnConfig = 0xf8 // TArray<FGoldInventorySpawnConfig> (Size: 0x10)
SGGameStateGoldInventoryManager.bAutoCheckPlacement = 0x108 // bool (Size: 0x1)
SGGameStateGoldInventoryManager.CheckPlacementZOffset = 0x10c // float (Size: 0x4)
SGGameStateGoldInventoryManager.bAutoRandomRotation = 0x110 // bool (Size: 0x1)
SGGameStateGoldInventoryManager.AutoRefreshPositionTimeLength = 0x114 // float (Size: 0x4)
SGGameStateGoldInventoryManager.GoldInventory = 0x118 // SGInventory* (Size: 0x8)
SGGameStateGoldInventoryManager.GoldInventoryStateInfo = 0x120 // FGoldInventoryStateInfo (Size: 0x8)
SGGameStateGoldInventoryManager.GoldInventorySpawnPoints = 0x128 // TArray<SGGoldPickup*> (Size: 0x10)
SGGameStateIntelligenceComponent.LootPointID = 0x100 // int32_t (Size: 0x4)
SGGameStateIntelligenceComponent.IntelligenceKeyClass = 0x108 // ClassProperty (Size: 0x8)
SGGameStateIntelligenceComponent.EscortDistance = 0x110 // float (Size: 0x4)
SGGameStateIntelligenceComponent.OpeningAnnouceDelayTime = 0x114 // float (Size: 0x4)
SGGameStateIntelligenceComponent.IntelligenceKey = 0x118 // SGInventory* (Size: 0x8)
SGGameStateIntelligenceComponent.LastIntelligenceKeyOwnerPS = 0x120 // SGPlayerState* (Size: 0x8)
SGGameStateIntelligenceComponent.CurIntelligenceKeyOwnerPS = 0x128 // SGPlayerState* (Size: 0x8)
SGGameStateIntelligenceComponent.IntelligenceKeyState = 0x130 // EEIntelligenceKeyState (Size: 0x1)
SGGameStateIntelligenceComponent.LootContainerType = 0x134 // uint32_t (Size: 0x4)
SGGameStateIntelligenceComponent.LootContainerTypeTxt = 0x138 // FText (Size: 0x18)
SGGameStateIntelligenceComponent.bIsActived = 0x150 // bool (Size: 0x1)
SGGameStateIntelligenceComponent.IntelligenceKeyPickedupTime = 0x154 // float (Size: 0x4)
SGGameStateIntelligenceComponent.IntelligenceKeyDroppedTime = 0x158 // float (Size: 0x4)
SGGameStateIntelligenceComponent.IntelligenceKeyKeeperName = 0x160 // FString (Size: 0x10)
SGGameStateInventoryUnlockComponent.LootPointUnLockInfo = 0x100 // TMap<...> (Size: 0x50)
SGGameStateInventoryUnlockComponent.LootPointUnlockInfoArray = 0x150 // TArray<FLootPointUnLockInfo> (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.LimitRandomAreaPlanDataInfo = 0xf8 // FLimitRandomAreaPlanDataInfo (Size: 0x38)
SGGameStateLimitRandomAreaPointManager.OnLimitRandomAreaPlanDataInfoChange = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.DPSStructInfo = 0x140 // FDPSStructInfo (Size: 0x8)
SGGameStateLimitRandomAreaPointManager.OnDPSStructInfoChange = 0x148 // FMulticastInlineDelegate (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.DebugAreaPointInfoList = 0x158 // TArray<FAreaPointInfo> (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.OnDebugAreaPointInfoListChangeEvent = 0x168 // FMulticastInlineDelegate (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.bPausePerformLimitArea = 0x178 // bool (Size: 0x1)
SGGameStateLimitRandomAreaPointManager.SnapshotProgressWhenPaused = 0x17c // float (Size: 0x4)
SGGameStateLimitRandomAreaPointManager.ElapsedPauseSeconds = 0x180 // float (Size: 0x4)
SGGameStateLimitRandomAreaPointManager.ActorClass = 0x188 // ClassProperty (Size: 0x8)
SGGameStateLimitRandomAreaPointManager.bForceFirstAreaUseSpecialCenter = 0x190 // bool (Size: 0x1)
SGGameStateLimitRandomAreaPointManager.SpecialCenter = 0x194 // FVector (Size: 0xc)
SGGameStateLimitRandomAreaPointManager.RandomAreaPointWavePickArray = 0x1a0 // TArray<FRandomAreaPointStructData> (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.bForceUseDefaultAreaPointArray = 0x1b0 // bool (Size: 0x1)
SGGameStateLimitRandomAreaPointManager.DefaultAreaPointArray = 0x1b8 // TArray<FVector> (Size: 0x10)
SGGameStateLimitRandomAreaPointManager.BanzoneAreaCylinder = 0x1c8 // Actor* (Size: 0x8)
SGGameStateLimitRandomAreaPointManager.MAX_FAILCOUNT = 0x1d0 // int32_t (Size: 0x4)
SGGameStateLimitRandomAreaPointManager.MAX_LOOPCOUNT = 0x1d4 // int32_t (Size: 0x4)
SGGameStateLimitRandomAreaPointManager.MAXIMUM_ERRORINTERVAL = 0x1d8 // float (Size: 0x4)
SGGameStatePendingMatchComponent.CharacterPath = 0x100 // FString (Size: 0x10)
SGGameStatePendingMatchComponent.PlayerCharacterClass = 0x110 // ClassProperty (Size: 0x8)
SGGameStateReplayComponent.bIsDSRecording = 0x100 // bool (Size: 0x1)
SGGameStateReplayComponent.bClientEnablePlayKillCam = 0x101 // bool (Size: 0x1)
SGGameStateReplayComponent.ReplayFactoryName = 0x108 // FString (Size: 0x10)
SGGameStateReplayComponent.ReplayClientDemoHost = 0x118 // FString (Size: 0x10)
SGGameStateReplayComponent.DeathGUIDInfos = 0x128 // TArray<FCharacterDeathGUIDInfo> (Size: 0x10)
SGGameStateRoundGlobalData.BanJumpAfterRebornTime = 0xf8 // float (Size: 0x4)
SGGameStateRoundGlobalData.NormalRoundTotalTime = 0xfc // int32_t (Size: 0x4)
SGGameStateRoundGlobalData.ExtraRoundTotalTime = 0x100 // int32_t (Size: 0x4)
SGGameStateScoreComponent.ForceScoreInfoArray = 0x100 // TArray<FForceScoreInfo> (Size: 0x10)
SGGameStateScoreComponent.ForceRelevantActorArray = 0x110 // TArray<Actor*> (Size: 0x10)
SGGameStateScoreComponent.bShowScorePanel = 0x120 // bool (Size: 0x1)
SGGameStateScoreComponent.bFreezeAllForceInfo = 0x121 // bool (Size: 0x1)
SGGameStateScoreComponent.ScorePanelConfig = 0x128 // FScorePanelConfig (Size: 0x30)
SGGameStateScoreComponent.HudMaxScore = 0x158 // int32_t (Size: 0x4)
SGGameStateScoreComponent.AssistDamageRadio = 0x15c // float (Size: 0x4)
SGGameStateScoreComponent.KdaArray = 0x160 // TArray<FKdaData> (Size: 0x10)
SGGameStateScoreComponent.TimerValue = 0x170 // float (Size: 0x4)
SGGameStateScoreComponent.bIsRoundOrTDMGame = 0x174 // bool (Size: 0x1)
SGGameStateScoreComponent.HideScorePanelTimeHandle = 0x178 // FTimerHandle (Size: 0x8)
SGGameStateScoreComponent.GID2KdaIndex = 0x180 // TMap<...> (Size: 0x50)
SGGameStateScoreComponent.CustomBeginTime = 0x270 // FDateTime (Size: 0x8)
SGGameStateSoundComponent.DistantGunSoundCooldown = 0x100 // float (Size: 0x4)
SGGameStateSoundComponent.MaxGunSoundInstances = 0x104 // int32_t (Size: 0x4)
SGGameStateSoundComponent.ActiveGunSoundInstances = 0x110 // TArray<SGGunSoundComponent*> (Size: 0x10)
SGGameStateSoundComponent.RealPlayerCharacters = 0x120 // TArray<SGCharacter*> (Size: 0x10)
SGGameStateSoundComponent.VirtualSoundInfoMap = 0x130 // TMap<...> (Size: 0x50)
SGGameStateSoundComponent.NearbyFiringDistance = 0x180 // float (Size: 0x4)
SGGameStateSoundComponent.NearbyFiringDuration = 0x184 // float (Size: 0x4)
SGGameStateSoundComponent.NearbyFiringMaxCount = 0x188 // int32_t (Size: 0x4)
SGGameStateSoundComponent.bPlayTerminalImpactAudio = 0x1e0 // bool (Size: 0x1)
SGGameStateSprayComponent.MaxSprayCount = 0x100 // int32_t (Size: 0x4)
SGGameStateSprayComponent.SprayActorMap = 0x108 // TMap<...> (Size: 0x50)
SGGameStateSprayComponent.SprayActorOrderedArray = 0x158 // TArray<SGSprayActor*> (Size: 0x10)
SGGameStateSprayComponent.SprayActorClass = 0x168 // ClassProperty (Size: 0x8)
SGGameStateStatisComponent.StatBulletInfoPool = 0x100 // TArray<SGStatBulletInfo*> (Size: 0x10)
SGGameStateStatisComponent.PlayerStatisDataMap = 0x110 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AllPlayerGIDArray = 0x160 // TArray<uint64_t> (Size: 0x10)
SGGameStateStatisComponent.StatBulletInfos = 0x170 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.StatPlayerFightInfos = 0x1c0 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.HighOutputGameEndReportData = 0x210 // FHighOutputGameEndReportData (Size: 0x18)
SGGameStateStatisComponent.HighOutputMultiPlayerGameEndReportInfo = 0x228 // FHighOutputMultiPlayerGameEndReportInfo (Size: 0x48)
SGGameStateStatisComponent.ClientQueueBunchReportDataMap = 0x270 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AIGameAchieveMultiReportTimer = 0x310 // FTimerHandle (Size: 0x8)
SGGameStateStatisComponent.AIGameAchieveMsgList = 0x318 // TArray<FAIGameAchieveMessage> (Size: 0x10)
SGGameStateStatisComponent.AllInventoryCreateRareItemCount = 0x338 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AllCharacterTakeOutRareItemCount = 0x388 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AllCharacterTakeOutRareByEquipmentDateItemMap = 0x3d8 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AllCharacterTakeOutRareByGuaranteeItemCount = 0x428 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AllCharacterTakeOutItemSource = 0x478 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AIRLReportDatas = 0x4c8 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AICommonStatisCollection = 0x518 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.GlobalMissionStatisData = 0x568 // FMissionStatisData (Size: 0x50)
SGGameStateStatisComponent.PlayerMissionStatisDataMap = 0x5b8 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.TeamMissionStatisDataMap = 0x608 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.CharacterToBattleIntensityExpectationSampleCollection = 0x658 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.UpdateAreaComp_CD = 0x6ac // float (Size: 0x4)
SGGameStateStatisComponent.AllCharacterHealthStaticsWhenDead = 0x6b0 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.AreaComps = 0x700 // TArray<SGRangeInAreaComponent*> (Size: 0x10)
SGGameStateStatisComponent.BulletHolesDuration = 0x710 // float (Size: 0x4)
SGGameStateStatisComponent.BulletHolesCount = 0x714 // int32_t (Size: 0x4)
SGGameStateStatisComponent.HitBulletHolesDuration = 0x718 // float (Size: 0x4)
SGGameStateStatisComponent.HitBulletHolesCount = 0x71c // int32_t (Size: 0x4)
SGGameStateStatisComponent.ClearBulletHolesTimer = 0x720 // FTimerHandle (Size: 0x8)
SGGameStateStatisComponent.bRoundGameBanzoneSpawn = 0x728 // bool (Size: 0x1)
SGGameStateStatisComponent.RoundGameSignalValueLostList = 0x730 // TMap<...> (Size: 0x50)
SGGameStateStatisComponent.RoundGameSignalValueKillNum = 0x780 // uint32_t (Size: 0x4)
SGGameStateStatisComponent.CanBeDestroyedActorSpawnNum = 0x784 // uint32_t (Size: 0x4)
SGGameStateStatisComponent.CanBeDestroyedActorBrokenNum = 0x788 // uint32_t (Size: 0x4)
SGGameStateStatisComponent.bIsNeedSendPasswordDoorInfo = 0x78c // bool (Size: 0x1)
SGGameStateStatisComponent.PassWordDoorLength = 0x790 // int32_t (Size: 0x4)
SGGameStateStatisComponent.bPasswordDoorIsUnLock = 0x794 // bool (Size: 0x1)
SGGameStateStatisComponent.TryUnLockPasswordDoorTimes = 0x798 // int32_t (Size: 0x4)
SGGameStateTeamManagerComponent.Teams = 0x100 // TArray<SGTeamInfo*> (Size: 0x10)
SGGameStateTeamManagerComponent.TeamClass = 0x110 // ClassProperty (Size: 0x8)
SGGameStateTeamManagerComponent.TeamCount = 0x118 // int32_t (Size: 0x4)
SGGameStateTeamManagerComponent.TeamDMGLimitInfos = 0x120 // TArray<FSGTeamDMGLimitInfo> (Size: 0x10)
SGGameStateTeamManagerComponent.bDMGLimitConfigEnabled = 0x130 // bool (Size: 0x1)
SGGameStateTicketComponent.TotalTickets = 0x100 // int32_t (Size: 0x4)
SGGameStateTicketComponent.CurrentTickets = 0x104 // int32_t (Size: 0x4)
SGGameStateTimeComponent.TotalTime = 0x100 // float (Size: 0x4)
SGGameStateTimeComponent.CurrentTime = 0x104 // float (Size: 0x4)
SGGameStateTodComponent.CurrentWeather = 0x100 // int32_t (Size: 0x4)
SGGameStateTodImpactComponent.CurrentThunderInfo = 0x100 // FThunderInfo (Size: 0x20)
SGGameStateTodImpactComponent.PlayThunderTimeInfoArray = 0x120 // TArray<FModeThunderTimeInfo> (Size: 0x10)
SGGameStateTodImpactComponent.CurrentThunderTimeArrayIndex = 0x130 // int32_t (Size: 0x4)
SGGameStateTodImpactComponent.ThunderPreSound = 0x138 // AkAudioEvent* (Size: 0x8)
SGGameStateTodImpactComponent.ThunderBombSound = 0x140 // AkAudioEvent* (Size: 0x8)
SGGameStateTodImpactComponent.CurrentModePlayCount = 0x148 // int32_t (Size: 0x4)
SGGameStateTodImpactComponent.bDebugMode = 0x14c // bool (Size: 0x1)
SGGameStateVehicleManagerComponent.DefaultVehicleClass = 0x100 // ClassProperty (Size: 0x8)
SGGameStateWorldSettingsCacheComponent.CachedWorldSettings = 0x100 // SGWorldSettingsActor* (Size: 0x8)
SGGameUserSettings.FirstRunning = 0x128 // bool (Size: 0x1)
SGGameUserSettings.AspectRatio = 0x12c // float (Size: 0x4)
SGGameUserSettings.Brightness = 0x130 // float (Size: 0x4)
SGGameUserSettings.HUE_R = 0x134 // float (Size: 0x4)
SGGameUserSettings.HUE_G = 0x138 // float (Size: 0x4)
SGGameUserSettings.HUE_B = 0x13c // float (Size: 0x4)
SGGameUserSettings.ColorStyle = 0x140 // FString (Size: 0x10)
SGGameUserSettings.ColorStyleIntensity = 0x150 // float (Size: 0x4)
SGGameUserSettings.Saturability = 0x154 // float (Size: 0x4)
SGGameUserSettings.Contrast = 0x158 // float (Size: 0x4)
SGGameUserSettings.Sharpen = 0x15c // float (Size: 0x4)
SGGameUserSettings.PostProcessStyle = 0x160 // int32_t (Size: 0x4)
SGGameUserSettings.TotalQuality = 0x164 // int32_t (Size: 0x4)
SGGameUserSettings.PostProcessAAQuality = 0x168 // int32_t (Size: 0x4)
SGGameUserSettings.MotionBlurQuality = 0x16c // int32_t (Size: 0x4)
SGGameUserSettings.DepthOfFieldQuality = 0x170 // int32_t (Size: 0x4)
SGGameUserSettings.AmbientOcclusionLevels = 0x174 // int32_t (Size: 0x4)
SGGameUserSettings.AmbientOcclusionRadiusScale = 0x178 // float (Size: 0x4)
SGGameUserSettings.ViewDistanceScale = 0x17c // float (Size: 0x4)
SGGameUserSettings.ResolutionSamplingType = 0x180 // int32_t (Size: 0x4)
SGGameUserSettings.ResolutionSamplingQuality = 0x184 // int32_t (Size: 0x4)
SGGameUserSettings.MainSoundVolume = 0x188 // float (Size: 0x4)
SGGameUserSettings.UIVolume = 0x18c // float (Size: 0x4)
SGGameUserSettings.SFXVolume = 0x190 // float (Size: 0x4)
SGGameUserSettings.BGMVolume = 0x194 // float (Size: 0x4)
SGGameUserSettings.ContactVolume = 0x198 // float (Size: 0x4)
SGGameUserSettings.HRTFOpen = 0x19c // bool (Size: 0x1)
SGGameUserSettings.MicrophoneVolume = 0x1a0 // float (Size: 0x4)
SGGameUserSettings.SpeakerVolume = 0x1a4 // float (Size: 0x4)
SGGameUserSettings.OperationType = 0x1a8 // TMap<...> (Size: 0x50)
SGGameUserSettings.UserSavedScopePattern = 0x1f8 // TMap<...> (Size: 0x50)
SGGameUserSettings.FOVValue = 0x248 // int32_t (Size: 0x4)
SGGameUserSettings.UserSensitivitySettingScale = 0x24c // float (Size: 0x4)
SGGameUserSettings.ADSSensitivity = 0x250 // float (Size: 0x4)
SGGameUserSettings.FreePerspectiveSensitivity = 0x268 // float (Size: 0x4)
SGGameUserSettings.GyroScopeInverseMode_X = 0x280 // bool (Size: 0x1)
SGGameUserSettings.GyroScopeInverseMode_Y = 0x281 // bool (Size: 0x1)
SGGameUserSettings.HeadSway = 0x284 // int32_t (Size: 0x4)
SGGameUserSettings.AutoTotalQuality = 0x288 // float (Size: 0x4)
SGGameUserSettings.AutoCpuScore = 0x28c // float (Size: 0x4)
SGGameUserSettings.AutoGpuScore = 0x290 // float (Size: 0x4)
SGGameUserSettings.AutoBenchmarkGpuName = 0x298 // FString (Size: 0x10)
SGGameUserSettings.IsFastGrenade = 0x2a8 // bool (Size: 0x1)
SGGameUserSettings.MonitorData = 0x2c0 // TArray<FSGMonitorData> (Size: 0x10)
SGGameUserSettings.MonitorNames = 0x2d0 // TArray<FString> (Size: 0x10)
SGGameUserSettings.FirstPlayStartCG = 0x2e0 // bool (Size: 0x1)
SGGameUserSettings.bIsSwitchAfterThrow = 0x2e1 // bool (Size: 0x1)
SGGameUserSettings.bEnableHighValueAutoPickInSafe = 0x2e2 // bool (Size: 0x1)
SGGameUserSettings.AutoPickInSafeThreshold = 0x2e4 // int32_t (Size: 0x4)
SGGameUserSettings.bEnableHighValueAutoPickInSafe_1x1 = 0x2e8 // bool (Size: 0x1)
SGGameUserSettings.AutoPickInSafeThreshold_1x1 = 0x2ec // int32_t (Size: 0x4)
SGGameUserSettings.bFinishBenchmark = 0x2f0 // bool (Size: 0x1)
SGGameUserSettings.EdgeBrightnessLevel = 0x2f4 // int32_t (Size: 0x4)
SGGameUserSettings.bEnableWeaponMotionBlur = 0x2f8 // bool (Size: 0x1)
SGGameUserSettings.bEnableEscapePointHintEffect = 0x2f9 // bool (Size: 0x1)
SGGameUserSettings.bAllowTeammatesCheckTheBackpack = 0x2fa // bool (Size: 0x1)
SGGameUserSettings.bApplyCameraMaterialClear = 0x2fb // bool (Size: 0x1)
SGGameUserSettings.bPreviewValuable = 0x2fc // bool (Size: 0x1)
SGGameUserSettings.LastSystemMonitorInfoString = 0x300 // FString (Size: 0x10)
SGGameUserSettings.LastMonitorIndex = 0x310 // int32_t (Size: 0x4)
SGGameUserSettings.BloodColorType = 0x318 // int32_t (Size: 0x4)
SGGameViewportClient.CachedPlayerController = 0x398 // PlayerController* (Size: 0x8)
SGGameplayAbility.bActivatableWhenDead = 0x3c8 // bool (Size: 0x1)
SGGameplayAbility.bCancelByDeath = 0x3c9 // bool (Size: 0x1)
SGGameplayAbility.bCancelByUnPossessed = 0x3ca // bool (Size: 0x1)
SGGameplayAbility.bCancelByPoseChanged = 0x3cb // bool (Size: 0x1)
SGGameplayAbility.bCancelByMovement = 0x3cc // bool (Size: 0x1)
SGGameplayAbility.bCancelByLeanChanged = 0x3cd // bool (Size: 0x1)
SGGameplayAbility.bCancelByMovementModeChanged = 0x3ce // bool (Size: 0x1)
SGGameplayAbility.bCancelByCurrentWeaponRemoved = 0x3cf // bool (Size: 0x1)
SGGameplayAbility.bCancelByTakeHit = 0x3d0 // bool (Size: 0x1)
SGGameplayAbility.bActivateNextTickWhenRequiredWeaponSync = 0x3d1 // bool (Size: 0x1)
SGGameplayAbility.ActivationOwnedTagsForRep = 0x3d8 // FGameplayTagContainer (Size: 0x20)
SGGameplayAbility.InterruptByTags = 0x3f8 // FGameplayTagContainer (Size: 0x20)
SGGameplayAbility.ActivationOwnedTags_AnimRecovery = 0x458 // FGameplayTagContainer (Size: 0x20)
SGGameplayAbility.CachedCurrentWeapon = 0x4d0 // SGWeapon* (Size: 0x8)
SGGameplayAbility.EventTargetActor = 0x4e0 // Actor* (Size: 0x8)
SGGameplayAbilityTargetData_ClimbLadder.NetInfo = 0x8 // FLadderClimbingNetInfo (Size: 0x3)
SGGameplayAbilityTargetData_ContainerGridInfo.ContainerIndex = 0x8 // int32_t (Size: 0x4)
SGGameplayAbilityTargetData_ContainerGridInfo.AttachPosition = 0xc // EEAttachPosition (Size: 0x1)
SGGameplayAbilityTargetData_ContainerGridInfo.ItemGridInfo = 0x10 // FItemGridInfo (Size: 0x8)
SGGameplayAbilityTargetData_ContainerGridInfo.IsDoRotate = 0x18 // bool (Size: 0x1)
SGGameplayAbilityTargetData_DeliverCargos.AnimInfo = 0x8 // FDeliverCargosAnimInfo (Size: 0xc8)
SGGameplayAbilityTargetData_FillMagazine.BulletOpType = 0x8 // EEBulletOperationType (Size: 0x1)
SGGameplayAbilityTargetData_FoldScope.AdapterAnimationType = 0x8 // EEAdapterAnimationType (Size: 0x1)
SGGameplayAbilityTargetData_GestureInfo.GestureItemID = 0x8 // int32_t (Size: 0x4)
SGGameplayAbilityTargetData_GestureInfo.ActorRotation = 0xc // FRotator (Size: 0xc)
SGGameplayAbilityTargetData_HostedInteract.AnimInfo = 0x8 // FHostedInteractAnimInfo (Size: 0x58)
SGGameplayAbilityTargetData_InteractTriggerInfo.StartPos = 0x8 // FVector (Size: 0xc)
SGGameplayAbilityTargetData_InteractTriggerInfo.EndPos = 0x14 // FVector (Size: 0xc)
SGGameplayAbilityTargetData_InteractTriggerInfo.InteractIndex = 0x20 // int32_t (Size: 0x4)
SGGameplayAbilityTargetData_InteractTriggerInfo.AntiData = 0x28 // FTssAntiData (Size: 0x20)
SGGameplayAbilityTargetData_MoveBlockedAvoidance.TargetLocation = 0x8 // FVector (Size: 0xc)
SGGameplayAbilityTargetData_MoveBlockedAvoidance.Duration = 0x14 // float (Size: 0x4)
SGGameplayAbilityTargetData_OpenBag.Operation = 0x8 // EEUABagOperation (Size: 0x1)
SGGameplayAbilityTargetData_PreviewPlace.ActorToSpawnClass = 0x8 // ClassProperty (Size: 0x8)
SGGameplayAbilityTargetData_PreviewPlace.ActorToUse = 0x10 // Actor* (Size: 0x8)
SGGameplayAbilityTargetData_QuickFillMagazine.ItemId = 0x8 // int64_t (Size: 0x8)
SGGameplayAbilityTargetData_SprayInfo.SprayTexturePath = 0x8 // FString (Size: 0x10)
SGGameplayAbilityTargetData_SprayInfo.SprayItemID = 0x18 // int32_t (Size: 0x4)
SGGameplayAbilityTargetData_SwitchWeapon.bTakeUpWeapon = 0x8 // bool (Size: 0x1)
SGGameplayAbilityTargetData_SwitchWeapon.bSkipPutDownAnim = 0x9 // bool (Size: 0x1)
SGGameplayAbilityTargetData_SwitchWeapon.bLastWeaponDropped = 0xa // bool (Size: 0x1)
SGGameplayAbilityTargetData_SwitchWeapon.PredKey = 0xc // int32_t (Size: 0x4)
SGGameplayAbility_Aim.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_Aim.AimActionName = 0x558 // FName (Size: 0x8)
SGGameplayAbility_BoresPump.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_CameraShake.CameraAnim = 0x3c8 // CameraAnim* (Size: 0x8)
SGGameplayAbility_CameraShake.BlendInTime = 0x3d0 // float (Size: 0x4)
SGGameplayAbility_CameraShake.BlendOutTime = 0x3d4 // float (Size: 0x4)
SGGameplayAbility_CheckFireMode.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_CheckFireMode.ShouldPlayMontage = 0x558 // bool (Size: 0x1)
SGGameplayAbility_CheckFireMode.SkipMontageTags = 0x560 // FGameplayTagContainer (Size: 0x20)
SGGameplayAbility_CheckMagazineInBag_HD.CurrentMagazine = 0x5b0 // SGInventory* (Size: 0x8)
SGGameplayAbility_CheckMagazineInBag_HD.CheckSeconds = 0x5b8 // float (Size: 0x4)
SGGameplayAbility_ClearBores.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_ClearBores.CharacterClearBoresMontageParams = 0x558 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ClearBores.CharacterPushBoresMontageParams = 0x5a0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ClearBores.WeaponClearBoresMontageParams = 0x5e8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ClearBores.WeaponPushBoresMontageParams = 0x630 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ClearMalfunction.Character = 0x550 // Character* (Size: 0x8)
SGGameplayAbility_ClearMalfunction.CurrentHandMontageParams = 0x558 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ClearMalfunction.PlayViewWeaponMontageTask = 0x5a0 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGGameplayAbility_ClearMalfunction.PlayPullBoltMontageTask = 0x5a8 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGGameplayAbility_ClimbLadder.TransitionAnimPlayRate = 0x550 // float (Size: 0x4)
SGGameplayAbility_ClimbLadder.IdleMontage = 0x558 // AnimMontage* (Size: 0x8)
SGGameplayAbility_ClimbLadder.EnterMontages = 0x560 // TArray<FLadderClimbingMontage> (Size: 0x10)
SGGameplayAbility_ClimbLadder.ExitMontages = 0x570 // TArray<FLadderClimbingMontage> (Size: 0x10)
SGGameplayAbility_ClimbLadder.LoopMontages = 0x580 // TArray<FLadderClimbingMontage> (Size: 0x10)
SGGameplayAbility_ClimbLadder.NetInfo = 0x590 // FLadderClimbingNetInfo (Size: 0x3)
SGGameplayAbility_ClimbLadder.WeaponBeforeEnterLadder = 0x598 // SGWeapon* (Size: 0x8)
SGGameplayAbility_CloseBolt.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_DeliverCargo.InventoryAttachSocket = 0x550 // FName (Size: 0x8)
SGGameplayAbility_DropBag.CurrentWeapon = 0x550 // SGWeapon* (Size: 0x8)
SGGameplayAbility_DropBag.CachedCharacter = 0x558 // SGCharacter* (Size: 0x8)
SGGameplayAbility_DropBag.DropBagSeqName = 0x560 // FString (Size: 0x10)
SGGameplayAbility_DropBag.bDropBagPerformed = 0x570 // bool (Size: 0x1)
SGGameplayAbility_EmptyTrigger.CurrentWeapon = 0x550 // SGWeapon* (Size: 0x8)
SGGameplayAbility_EscapeInteract.LookAtSocketName = 0x550 // FName (Size: 0x8)
SGGameplayAbility_EscapeInteract.CharacterMoveToSocketName = 0x558 // FName (Size: 0x8)
SGGameplayAbility_EscapeInteract.MoveToTargetOverTime = 0x560 // float (Size: 0x4)
SGGameplayAbility_EscapeInteract.RotationInterpSpeed = 0x564 // float (Size: 0x4)
SGGameplayAbility_EscapeInteract.CachedCharacter = 0x568 // SGCharacter* (Size: 0x8)
SGGameplayAbility_EscapeInteract.CachedEscapeInteractMeshActor = 0x570 // SkeletalMeshActor* (Size: 0x8)
SGGameplayAbility_EscapeInteract.CachedWeaponBeforeEscapeInteract = 0x578 // SGInventory* (Size: 0x8)
SGGameplayAbility_EscapeInteract.CachedInteractComponent = 0x580 // SGInteractComponentBase* (Size: 0x8)
SGGameplayAbility_FillContainer.InFillInventory = 0x5b0 // SGInventory* (Size: 0x8)
SGGameplayAbility_FillContainer.ContainerInventory = 0x5b8 // SGInventory* (Size: 0x8)
SGGameplayAbility_FillContainer.FillContainerBasicTime = 0x5c0 // float (Size: 0x4)
SGGameplayAbility_FillContainer.FillContainerTotalTime = 0x5c4 // float (Size: 0x4)
SGGameplayAbility_FillContainer.FillContainerTimePerElement = 0x5c8 // float (Size: 0x4)
SGGameplayAbility_FillContainer.BulletsNumToFill = 0x5d0 // int32_t (Size: 0x4)
SGGameplayAbility_FillContainer.ContainerAttachedOnWeaponPerLoopTimeRatio = 0x5dc // float (Size: 0x4)
SGGameplayAbility_FillContainer.CachedPushMagInfoDep = 0x5e0 // FRepDependency (Size: 0x18)
SGGameplayAbility_FillContainer.AnimTargetDataHandle = 0x5f8 // FSGAnimTargetDataHandle (Size: 0x10)
SGGameplayAbility_Fire.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_Fire.FireMode = 0x558 // int32_t (Size: 0x4)
SGGameplayAbility_FoldScope.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_FoldScope.ScopeInv = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_FoldScope.bIsFold = 0x560 // bool (Size: 0x1)
SGGameplayAbility_FoldScope.AdapterAnimationType = 0x561 // EEAdapterAnimationType (Size: 0x1)
SGGameplayAbility_FoldScope.CurrentHandMontage = 0x568 // TSoftObjectPtr<UObject> (Size: 0x28)
SGGameplayAbility_FoldStock.CharacterMontageParams = 0x568 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_FoldStock.WeaponMontageParams = 0x5b0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Gesture.Character = 0x570 // SGCharacter* (Size: 0x8)
SGGameplayAbility_Gesture.PlayAnimHandle = 0x588 // FTimerHandle (Size: 0x8)
SGGameplayAbility_Gesture.CurrentHandMontageParams = 0x590 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Gesture.CurrentEquipMontage = 0x5d8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Gesture.CurrentGesture = 0x620 // FGestureAnim (Size: 0xa8)
SGGameplayAbility_Gesture.GestureActionId = 0x6c8 // int32_t (Size: 0x4)
SGGameplayAbility_Gesture.GestureMontagesMap = 0x6d0 // TMap<...> (Size: 0x50)
SGGameplayAbility_Gesture.bEnableCollisionDetection = 0x720 // bool (Size: 0x1)
SGGameplayAbility_Gesture.CollisionDetectionRadius = 0x724 // float (Size: 0x4)
SGGameplayAbility_Gesture.FullBodyCameraBaseRotation = 0x728 // FRotator (Size: 0xc)
SGGameplayAbility_Gesture.IsOneHand = 0x734 // bool (Size: 0x1)
SGGameplayAbility_Gesture.GestureType = 0x735 // EEGestureType (Size: 0x1)
SGGameplayAbility_Gesture.GestureItemID = 0x738 // int32_t (Size: 0x4)
SGGameplayAbility_Gesture.ActorRotation = 0x73c // FRotator (Size: 0xc)
SGGameplayAbility_Gesture.CurrentWeapon = 0x748 // SGInventory* (Size: 0x8)
SGGameplayAbility_Gesture.EmptyHand = 0x750 // SGInventory* (Size: 0x8)
SGGameplayAbility_HandLUseItem.MontageToPlayWithWeapon = 0x550 // AnimMontage* (Size: 0x8)
SGGameplayAbility_HandLUseItem.MontageToEmptyHands = 0x558 // AnimMontage* (Size: 0x8)
SGGameplayAbility_HandLUseItem.MontageToPlay = 0x560 // AnimMontage* (Size: 0x8)
SGGameplayAbility_HoldInventory.Character = 0x570 // SGCharacter* (Size: 0x8)
SGGameplayAbility_HoldInventory.WeaponManagerComponent = 0x578 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGGameplayAbility_HoldInventory.Inventory = 0x580 // SGInventory* (Size: 0x8)
SGGameplayAbility_HoldOpen.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_HostedInteract.RemainDuration = 0x550 // float (Size: 0x4)
SGGameplayAbility_HostedInteract.HostedInteractAnimInfo = 0x558 // FHostedInteractAnimInfo (Size: 0x58)
SGGameplayAbility_HostedInteract.MontageTask = 0x5b0 // AbilityTask_PlayMontageAndWait* (Size: 0x8)
SGGameplayAbility_HostedInteract.SafeBox = 0x5b8 // Actor* (Size: 0x8)
SGGameplayAbility_HostedInteract.SafeBoxMeshComp = 0x5c0 // SkeletalMeshComponentBudgeted* (Size: 0x8)
SGGameplayAbility_HostedInteract.CharacterMeshComp = 0x5c8 // SkeletalMeshComponent* (Size: 0x8)
SGGameplayAbility_HostedInteract.SectionType = 0x5f8 // EEAnimSectionType (Size: 0x1)
SGGameplayAbility_HostedInteract.CachedCharacter = 0x600 // SGCharacter* (Size: 0x8)
SGGameplayAbility_HostedInteract.CachedWeaponBeforeHostedInteract = 0x608 // SGInventory* (Size: 0x8)
SGGameplayAbility_Interact.Character = 0x550 // Character* (Size: 0x8)
SGGameplayAbility_Interact.InteractType = 0x558 // EESGInteractEvent (Size: 0x1)
SGGameplayAbility_Interact.ActorToUse = 0x560 // Actor* (Size: 0x8)
SGGameplayAbility_Interact.UseMode = 0x568 // int32_t (Size: 0x4)
SGGameplayAbility_Interact.TriggerFinish = 0x56c // bool (Size: 0x1)
SGGameplayAbility_Interact.TriggerFinishTime = 0x570 // float (Size: 0x4)
SGGameplayAbility_Interact.MAX_INV_INTERACT_SQR_DIST = 0x574 // float (Size: 0x4)
SGGameplayAbility_Interact.LockWristOffset = 0x578 // FVector (Size: 0xc)
SGGameplayAbility_Interact.InteractionComp = 0x588 // SGCharacterInteractionComponent* (Size: 0x8)
SGGameplayAbility_Interact.CharacterWeaponCache = 0x590 // SGWeapon* (Size: 0x8)
SGGameplayAbility_InteractWithProgress.icon = 0x5a0 // Object* (Size: 0x8)
SGGameplayAbility_InteractWithProgress.DurationTime = 0x5a8 // float (Size: 0x4)
SGGameplayAbility_InteractWithProgress.ProgressStartTime = 0x5b0 // double (Size: 0x8)
SGGameplayAbility_InteractWithProgress.IsDisplayProgress = 0x5b8 // bool (Size: 0x1)
SGGameplayAbility_InteractWithProgress.bIsCanCancel = 0x5b9 // bool (Size: 0x1)
SGGameplayAbility_Jump.bShouldDelayJump = 0x550 // bool (Size: 0x1)
SGGameplayAbility_Jump.JumpLenScaleByLowEnergy = 0x558 // CurveFloat* (Size: 0x8)
SGGameplayAbility_Jump.JumpLenScaleByLowEnergySprint = 0x560 // CurveFloat* (Size: 0x8)
SGGameplayAbility_Jump.PreJumpAnimTime = 0x568 // float (Size: 0x4)
SGGameplayAbility_Jump.JumpEndAnimTime = 0x56c // float (Size: 0x4)
SGGameplayAbility_Jump.SprintJumpCoolDown = 0x570 // float (Size: 0x4)
SGGameplayAbility_LowReady.CharacterBeginLowReadyMontageParams = 0x550 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_LowReady.CharacterEndLowReadyMontageParams = 0x598 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_MeleeFire.CurrentCharacter = 0x558 // Character* (Size: 0x8)
SGGameplayAbility_MeleeFire.FireMode = 0x560 // int32_t (Size: 0x4)
SGGameplayAbility_MeleeFire.MontagePlayParams = 0x568 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.MontagePlayParamsArray = 0x5b0 // TArray<FSGMontagePlayParams> (Size: 0x10)
SGGameplayAbility_MeleeFire.WeaponMontagePlayParamsArray = 0x5c0 // TArray<FSGMontagePlayParams> (Size: 0x10)
SGGameplayAbility_MeleeFire.MontagePostShowcasePlayParamsArray = 0x5d0 // TArray<FSGMontagePlayParams> (Size: 0x10)
SGGameplayAbility_MeleeFire.MontagePostWeaponShowcasePlayParamsArray = 0x5e0 // TArray<FSGMontagePlayParams> (Size: 0x10)
SGGameplayAbility_MeleeFire.MontagePlayParamsProne = 0x5f0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.MontagePostShowcasePlayParamsProne = 0x638 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.WeaponMontagePlayParamsProne = 0x680 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.WeaponMontagePostShowcasePlayParamsProne = 0x6c8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_MeleeFire.bIsProne = 0x710 // bool (Size: 0x1)
SGGameplayAbility_MoveBlockedAvoidance.TargetLocation = 0x550 // FVector (Size: 0xc)
SGGameplayAbility_MoveBlockedAvoidance.Duration = 0x55c // float (Size: 0x4)
SGGameplayAbility_OpenBag.UIOperation = 0x550 // EEUABagOperation (Size: 0x1)
SGGameplayAbility_OpenBag.InteractTarget = 0x558 // Actor* (Size: 0x8)
SGGameplayAbility_OpenBag.CharacterOpenBagMontageParams = 0x560 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_OpenBag.CharacterCloseBagMontageParams = 0x5a8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_PreviewPlace.PreviewDis = 0x550 // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.MinDisSquared = 0x554 // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.PreviewActorClass = 0x558 // ClassProperty (Size: 0x8)
SGGameplayAbility_PreviewPlace.ActorToSpawnClass = 0x568 // ClassProperty (Size: 0x8)
SGGameplayAbility_PreviewPlace.ActorToUse = 0x570 // Actor* (Size: 0x8)
SGGameplayAbility_PreviewPlace.MatPreview = 0x578 // MaterialInstance* (Size: 0x8)
SGGameplayAbility_PreviewPlace.InterpSpeed_Location = 0x580 // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.InterpSpeed_ControlRotation = 0x584 // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.ActorLocUpTraceDis = 0x588 // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.ActorLocDownTraceDis = 0x58c // float (Size: 0x4)
SGGameplayAbility_PreviewPlace.CanPlaceColor = 0x590 // FLinearColor (Size: 0x10)
SGGameplayAbility_PreviewPlace.CanNotPlaceColor = 0x5a0 // FLinearColor (Size: 0x10)
SGGameplayAbility_PreviewPlace.HeadSocketName = 0x5b0 // FName (Size: 0x8)
SGGameplayAbility_PreviewPlace.CameraBoneName = 0x5b8 // FName (Size: 0x8)
SGGameplayAbility_PreviewPlace.PreviewActor = 0x5c0 // SGPreviewActor* (Size: 0x8)
SGGameplayAbility_PreviewPlace.OwnerCharacter = 0x5c8 // SGCharacter* (Size: 0x8)
SGGameplayAbility_PreviewPlace.PreviewPlaceTask = 0x5d0 // SGAbilityTask_PreviewPlace* (Size: 0x8)
SGGameplayAbility_PreviewPlace.CachedTransform = 0x5e0 // FTransform (Size: 0x30)
SGGameplayAbility_PreviewPlace.InterruptByTagsBeforePlacement = 0x618 // FGameplayTagContainer (Size: 0x20)
SGGameplayAbility_PreviewPlace.MeshComp = 0x648 // StaticMeshComponent* (Size: 0x8)
SGGameplayAbility_PreviewPlace.InventoryGiveComponent = 0x650 // SGCharacterInventoryGiveComponent* (Size: 0x8)
SGGameplayAbility_PullBolt.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.icon = 0x558 // Object* (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.bShowProgressUIButton = 0x560 // bool (Size: 0x1)
SGGameplayAbility_QuickFillMagazine.bScaleIconToFit = 0x561 // bool (Size: 0x1)
SGGameplayAbility_QuickFillMagazine.FillPerBulletTime = 0x564 // float (Size: 0x4)
SGGameplayAbility_QuickFillMagazine.ItemId = 0x570 // int64_t (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.CurrentTaskTotalFillCount = 0x578 // int32_t (Size: 0x4)
SGGameplayAbility_QuickFillMagazine.CurrentTaskRemainFillCount = 0x57c // int32_t (Size: 0x4)
SGGameplayAbility_QuickFillMagazine.CurrentTaskMagazine = 0x580 // SGInventory* (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.CurrentTaskBullet = 0x588 // SGInventory* (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.LastTaskMagazine = 0x590 // SGInventory* (Size: 0x8)
SGGameplayAbility_QuickFillMagazine.CachedPushMagInfoDep = 0x598 // FRepDependency (Size: 0x18)
SGGameplayAbility_ReleaseHoldOpen.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_Reload.CurrentWeapon = 0x558 // SGWeapon* (Size: 0x8)
SGGameplayAbility_Reload.OldMagazine = 0x560 // SGInventory* (Size: 0x8)
SGGameplayAbility_Reload.NewMagazine = 0x568 // SGInventory* (Size: 0x8)
SGGameplayAbility_Reload.ParentInventory = 0x570 // SGInventory* (Size: 0x8)
SGGameplayAbility_Reload.CharacterMagazineOutMontageParams = 0x578 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterMagazineInMontageParams = 0x5c0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterOpenBoltMontageParams = 0x608 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterCloseBoltMontageParams = 0x650 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterBeltOutMontageParams = 0x698 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterBeltInMontageParams = 0x6e0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponMagazineOutMontageParams = 0x728 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponMagazineInMontageParams = 0x770 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponOpenBoltMontageParams = 0x7b8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponCloseBoltMontageParams = 0x800 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponBeltOutMontageParams = 0x848 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponBeltInMontageParams = 0x890 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterReleaseHoldOpenMontageParams = 0x8d8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponReleaseHoldOpenMontageParams = 0x920 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.CharacterPullBoltMontageParams = 0x968 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.WeaponPullBoltMontageParams = 0x9b0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Reload.bClientWantsPullBolt = 0x9f9 // bool (Size: 0x1)
SGGameplayAbility_Reload.AddNewMagTime = 0xa08 // float (Size: 0x4)
SGGameplayAbility_Reload.RemoveOldMagTime = 0xa0c // float (Size: 0x4)
SGGameplayAbility_ReloadBores.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadBores.FillBullet = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadBores.CharacterClearBoresMontageParams = 0x560 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.CharacterPushBoresMontageParams = 0x5a8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.CharacterOpenBoltMontageParams = 0x5f0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.CharacterCloseBoltMontageParams = 0x638 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.WeaponClearBoresMontageParams = 0x680 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.WeaponPushBoresMontageParams = 0x6c8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.WeaponOpenBoltMontageParams = 0x710 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBores.WeaponCloseBoltMontageParams = 0x758 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOnHang.TgtWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadBoresOnHang.FillBullet = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadBoresOnHang.OpCharacter = 0x560 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ReloadBoresOneByOne.CharacterStartMontageParams = 0x560 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.CharacterEndMontageParams = 0x5a8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.CharacterPushBulletMontageParams = 0x5f0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.CharacterChangeBulletMontageParams = 0x638 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.CharacterClockwiseMontageParams = 0x680 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.CharacterCounterClockwiseMontageParams = 0x6c8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.WeaponStartMontageParams = 0x710 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.WeaponEndMontageParams = 0x758 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadBoresOneByOne.Character = 0x7a0 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ReloadBoresOneByOne.CachedBoreComponent = 0x7a8 // SGWeaponBoreComponent* (Size: 0x8)
SGGameplayAbility_ReloadBoresOneByOne.FillBullet = 0x7b0 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadBoresOneByOne.NeedToFillNum = 0x7b8 // int32_t (Size: 0x4)
SGGameplayAbility_ReloadBoresOneByOne.CurrentFilledNum = 0x7bc // int32_t (Size: 0x4)
SGGameplayAbility_ReloadBoresOneByOne.CurrentBoreIndex = 0x7c0 // int32_t (Size: 0x4)
SGGameplayAbility_ReloadBoresOneByOne.ReloadBoreRotateClockwise = 0x7c4 // bool (Size: 0x1)
SGGameplayAbility_ReloadBoresOneByOne.CurrentPlayAnimDep = 0x7c8 // TArray<FRepDependency> (Size: 0x10)
SGGameplayAbility_ReloadOneByOne.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadOneByOne.TgtMagazine = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadOneByOne.FillBullet = 0x560 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadOneByOne.FillBulletClass = 0x568 // ClassProperty (Size: 0x8)
SGGameplayAbility_ReloadOneByOne.bInOpenBoltReloading = 0x570 // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOne.bClientNeedPullBoltAfterReload = 0x571 // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOne.BulletToFill = 0x574 // int32_t (Size: 0x4)
SGGameplayAbility_ReloadOneByOne.FillOneByOneCountPerLoop = 0x578 // int32_t (Size: 0x4)
SGGameplayAbility_ReloadOneByOne.bInWaitingStop = 0x57c // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOne.bFinWithAnim = 0x57d // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOne.CharacterReloadBeginMontageParams = 0x580 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.CharacterReloadLoopMontageParams = 0x5c8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.CharacterReloadEndMontageParams = 0x610 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.WeaponReloadBeginMontageParams = 0x658 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.WeaponReloadLoopMontageParams = 0x6a0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.WeaponReloadEndMontageParams = 0x6e8 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.CharacterReleaseHoldOpenMontageParams = 0x730 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.WeaponReleaseHoldOpenMontageParams = 0x778 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.CharacterPullBoltMontageParams = 0x7c0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.WeaponPullBoltMontageParams = 0x808 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ReloadOneByOne.bEmptyBoreLeverActionWeapon = 0x860 // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOne.bPlayOpenBoltCatchBulletAnim = 0x861 // bool (Size: 0x1)
SGGameplayAbility_ReloadOneByOneOnHang.TgtMagazine = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadOneByOneOnHang.FillBullet = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_ReloadOneByOneOnHang.OpCharacter = 0x560 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ReloadOneByOneOnHang.BulletToFill = 0x568 // int32_t (Size: 0x4)
SGGameplayAbility_RepairWeapon.ShowShellEffectHandle = 0x560 // FTimerHandle (Size: 0x8)
SGGameplayAbility_RescueSelf.ResCueSelfInventoryMontage = 0x550 // AnimMontage* (Size: 0x8)
SGGameplayAbility_RescueSelf.ResCueSelfCharacterMontage = 0x558 // AnimMontage* (Size: 0x8)
SGGameplayAbility_RescueSelf.InventoryMeshAsset = 0x560 // SkeletalMesh* (Size: 0x8)
SGGameplayAbility_RescueSelf.InventoryAnimInstance = 0x568 // ClassProperty (Size: 0x8)
SGGameplayAbility_RescueSelf.SelfRescueDuration = 0x570 // float (Size: 0x4)
SGGameplayAbility_RescueSelf.ApplyGameplayEffectClass = 0x578 // ClassProperty (Size: 0x8)
SGGameplayAbility_RescueSelf.Character = 0x580 // Character* (Size: 0x8)
SGGameplayAbility_RescueSelf.ResCueSelfToUse = 0x588 // SGInventory* (Size: 0x8)
SGGameplayAbility_RescueSelf.ApplyGEHandle = 0x590 // FActiveGameplayEffectHandle (Size: 0x8)
SGGameplayAbility_RescueSelf.TimesUpHandle = 0x598 // FTimerHandle (Size: 0x8)
SGGameplayAbility_Rescuer.AbilitySystemComponent = 0x550 // AbilitySystemComponent* (Size: 0x8)
SGGameplayAbility_Rescuer.Character = 0x558 // Character* (Size: 0x8)
SGGameplayAbility_Rescuer.Rescuee = 0x560 // Character* (Size: 0x8)
SGGameplayAbility_Rescuer.CurrentWeapon = 0x568 // SGInventory* (Size: 0x8)
SGGameplayAbility_Rescuer.AlternativeRescueInventory = 0x570 // SGInventory* (Size: 0x8)
SGGameplayAbility_Rescuer.RescueMontage = 0x578 // AnimMontage* (Size: 0x8)
SGGameplayAbility_Rescuer.RescueInventoryMontage = 0x580 // AnimMontage* (Size: 0x8)
SGGameplayAbility_Rescuer.CharacterRescueMontageParams = 0x588 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Rescuer.InventoryRescueMontageParams = 0x5d0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_Rescuer.RescueInventoryMesh = 0x618 // SkeletalMesh* (Size: 0x8)
SGGameplayAbility_Rescuer.InventoryMeshSoftObjectPtr = 0x620 // TSoftObjectPtr<UObject> (Size: 0x28)
SGGameplayAbility_Rescuer.EndRescueRemainingTime = 0x648 // float (Size: 0x4)
SGGameplayAbility_Rescuer.StandToCrouchTime = 0x64c // float (Size: 0x4)
SGGameplayAbility_Rescuer.ProneToCrouchTime = 0x650 // float (Size: 0x4)
SGGameplayAbility_Rescuer.RescueMontagePlayRate = 0x654 // float (Size: 0x4)
SGGameplayAbility_RollUpBag.TargetBag = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_SetBipod.CurrentWeapon = 0x550 // SGInventory* (Size: 0x8)
SGGameplayAbility_SetBipod.CurrentBipod = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_SetBipod.bToSetOn = 0x560 // bool (Size: 0x1)
SGGameplayAbility_SetupAdapter.CharacterSetupMontageParams = 0x558 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_SetupAdapter.WeaponSetupMontageParams = 0x5a0 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_SetupAdapter.SetupDuration = 0x5e8 // float (Size: 0x4)
SGGameplayAbility_SetupArmorAdapter.bIsAttachSetup = 0x558 // bool (Size: 0x1)
SGGameplayAbility_SetupArmorAdapter.AttachSetupDuration = 0x55c // float (Size: 0x4)
SGGameplayAbility_SetupArmorAdapter.DetachSetupDuration = 0x560 // float (Size: 0x4)
SGGameplayAbility_SetupArmorAdapter.Inventory = 0x598 // SGInventory* (Size: 0x8)
SGGameplayAbility_SetupArmorAdapter.SGGADataRef = 0x5a0 // FSGGADataReference (Size: 0x10)
SGGameplayAbility_Spray.SprayMaxDistance = 0x550 // float (Size: 0x4)
SGGameplayAbility_Spray.DecalSize = 0x554 // FVector (Size: 0xc)
SGGameplayAbility_Spray.ObjectTypes = 0x560 // TArray<uint8_t> (Size: 0x10)
SGGameplayAbility_Spray.GameplayCueTag = 0x570 // FGameplayTag (Size: 0x8)
SGGameplayAbility_SwitchFireMode.bHasMoreThanOneFireMode = 0x550 // bool (Size: 0x1)
SGGameplayAbility_SwitchFireMode.CurrentWeapon = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_SwitchScope.GameplayCueTag = 0x550 // FGameplayTag (Size: 0x8)
SGGameplayAbility_SwitchScope.CharacterAnimationName = 0x558 // FString (Size: 0x10)
SGGameplayAbility_SwitchScope.HandMontageParams = 0x568 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_SwitchScope.HandAnimationTime = 0x5b0 // float (Size: 0x4)
SGGameplayAbility_SwitchScope.bIncludeFoldScopeAnim = 0x5b4 // bool (Size: 0x1)
SGGameplayAbility_SwitchScopePattern.CharacterAnimationName = 0x550 // FString (Size: 0x10)
SGGameplayAbility_SwitchScopePattern.HandMontageParams = 0x560 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_SwitchWeapon.CurrentWeapon = 0x550 // SGWeapon* (Size: 0x8)
SGGameplayAbility_SwitchWeapon.DestWeapon = 0x558 // SGWeapon* (Size: 0x8)
SGGameplayAbility_SwitchWeapon.MeleeWeaponCanSwitchWeapon = 0x560 // bool (Size: 0x1)
SGGameplayAbility_SwitchWeapon.IsTakeupWeaponPhase = 0x561 // bool (Size: 0x1)
SGGameplayAbility_SwitchWeapon.bShouldUseTacticalTrans = 0x562 // bool (Size: 0x1)
SGGameplayAbility_SwitchWeapon.WeaponOwner = 0x568 // SGCharacter* (Size: 0x8)
SGGameplayAbility_SwitchWeapon.bLastWeaponRemoved = 0x570 // bool (Size: 0x1)
SGGameplayAbility_SwitchWeapon.FromGrenadeAccelerateVal = 0x574 // float (Size: 0x4)
SGGameplayAbility_SwitchWeapon.ToGrenadeAccelerateVal = 0x578 // float (Size: 0x4)
SGGameplayAbility_SwitchWeapon.MainToAssistWeaponExtraSwitchSpeedScale = 0x57c // float (Size: 0x4)
SGGameplayAbility_SwitchWeaponHD.CachedWeaponManagerComp = 0x550 // SGCharacterWeaponManagerComponent* (Size: 0x8)
SGGameplayAbility_SwitchWeaponHD.CachedCharacter = 0x558 // SGCharacter* (Size: 0x8)
SGGameplayAbility_SwitchWeaponHD.DestWeapon = 0x560 // SGInventory* (Size: 0x8)
SGGameplayAbility_SwitchWeaponHD.DestLeftHandWeapon = 0x568 // SGInventory* (Size: 0x8)
SGGameplayAbility_SwitchWeaponHD.bTakeUpWeapon = 0x570 // bool (Size: 0x1)
SGGameplayAbility_SwitchWeaponHD.PredKey = 0x574 // int32_t (Size: 0x4)
SGGameplayAbility_SwitchWeaponHD.CachedPredKeyWhenPreNativeActive = 0x578 // int32_t (Size: 0x4)
SGGameplayAbility_ThrowWeapon.CurrentWeapon = 0x550 // SGWeapon* (Size: 0x8)
SGGameplayAbility_ThrowWeapon.WeaponToThrow = 0x558 // SGWeapon* (Size: 0x8)
SGGameplayAbility_ThrowWeapon.CurCharacter = 0x560 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ThrowWeapon.bIsFastThrow = 0x568 // bool (Size: 0x1)
SGGameplayAbility_ThrowWeapon.bCancelThrow = 0x569 // bool (Size: 0x1)
SGGameplayAbility_ThrowWeapon.bIsHoldGrenadeThrow = 0x56a // bool (Size: 0x1)
SGGameplayAbility_ThrowWeapon.bIsStopFireTriggered = 0x56b // bool (Size: 0x1)
SGGameplayAbility_ThrowWeapon.ForbidMovement = 0x570 // ClassProperty (Size: 0x8)
SGGameplayAbility_ToggleCrouch.Character = 0x550 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ToggleCrouch.AnimDuration = 0x558 // float (Size: 0x4)
SGGameplayAbility_ToggleCrouch.CrouchActionName = 0x55c // FName (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.SwitchOnHeadwearDelay = 0x550 // float (Size: 0x4)
SGGameplayAbility_ToggleHeadwear.SwitchOffHeadwearDelay = 0x554 // float (Size: 0x4)
SGGameplayAbility_ToggleHeadwear.ToggleHeadwearHandle = 0x558 // FTimerHandle (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.TacticTag = 0x560 // FGameplayTag (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.bTryTurnOff = 0x568 // bool (Size: 0x1)
SGGameplayAbility_ToggleHeadwear.bHasToggleActivationState = 0x569 // bool (Size: 0x1)
SGGameplayAbility_ToggleHeadwear.HeadwearType = 0x56a // EESGMainHeadwearType (Size: 0x1)
SGGameplayAbility_ToggleHeadwear.TimeOutHandle = 0x570 // FTimerHandle (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.PutUpMontagesMap_Inventory = 0x588 // TMap<...> (Size: 0x50)
SGGameplayAbility_ToggleHeadwear.PutDownMontagesMap_Inventory = 0x5d8 // TMap<...> (Size: 0x50)
SGGameplayAbility_ToggleHeadwear.HandMontageParams = 0x628 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ToggleHeadwear.InvMontageParams = 0x670 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ToggleHeadwear.HeadwearInv = 0x6b8 // SGInventory* (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.HeadwearComp = 0x6c0 // SGInventoryToggleableHeadwearComponent* (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.HelmetInv = 0x6c8 // SGInventory* (Size: 0x8)
SGGameplayAbility_ToggleHeadwear.HelmetSwitchsComp = 0x6d0 // SGInventoryHelmetSwitchComponent* (Size: 0x8)
SGGameplayAbility_ToggleProne.AnimDuration = 0x550 // float (Size: 0x4)
SGGameplayAbility_ToggleTactical.GameplayCueTag = 0x550 // FGameplayTag (Size: 0x8)
SGGameplayAbility_ToggleTactical.SwitchSequence = 0x558 // TArray<uint8_t> (Size: 0x10)
SGGameplayAbility_ToggleTactical.CharacterAnimationName = 0x568 // FString (Size: 0x10)
SGGameplayAbility_ToggleTactical.HandMontageParams = 0x578 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_TurnInPlace.AbilitySystemComponent = 0x550 // AbilitySystemComponent* (Size: 0x8)
SGGameplayAbility_TurnInPlace.Character = 0x558 // Character* (Size: 0x8)
SGGameplayAbility_UnFillContainer.ContainerInventory = 0x5b0 // SGInventory* (Size: 0x8)
SGGameplayAbility_UnFillContainer.UnfillContainerBasicTime = 0x5b8 // float (Size: 0x4)
SGGameplayAbility_UnFillContainer.UnfillContainerTotalTime = 0x5bc // float (Size: 0x4)
SGGameplayAbility_UnFillContainer.UnfillContainerTimePerElement = 0x5c0 // float (Size: 0x4)
SGGameplayAbility_UnFillContainer.LastPoppedBullet = 0x5c8 // SGInventory* (Size: 0x8)
SGGameplayAbility_UnFillContainer.BulletsNumToUnFill = 0x5d4 // int32_t (Size: 0x4)
SGGameplayAbility_UnFillContainer.NextBulletGlobalOccupyInfo = 0x5e0 // FSGGlobalGridOccupyInfo (Size: 0x28)
SGGameplayAbility_UnFillContainer.BulletGlobalOccupyInfoBucket = 0x608 // TArray<FSGGlobalGridOccupyInfo> (Size: 0x10)
SGGameplayAbility_UseInventory.Inventory = 0x560 // SGInventory* (Size: 0x8)
SGGameplayAbility_UseInventory.Character = 0x568 // SGCharacter* (Size: 0x8)
SGGameplayAbility_UseInventory.icon = 0x598 // Object* (Size: 0x8)
SGGameplayAbility_UseInventory.bShowProgressUI = 0x5a0 // bool (Size: 0x1)
SGGameplayAbility_UseInventory.bShowProgressUIButton = 0x5a1 // bool (Size: 0x1)
SGGameplayAbility_UseInventory.bScaleIconToFit = 0x5a2 // bool (Size: 0x1)
SGGameplayAbility_UseInventory.AppliedEffectHandlesWhileBegined = 0x600 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
SGGameplayAbility_UseInventory.AppliedEffectHandlesWhileAnimating = 0x610 // TArray<FActiveGameplayEffectHandle> (Size: 0x10)
SGGameplayAbility_UseInventory.SGGADataRef = 0x648 // FSGGADataReference (Size: 0x10)
SGGameplayAbility_UseInventory.CachedNextWeapon = 0x660 // SGInventory* (Size: 0x8)
SGGameplayAbility_UseInventory.UpcomingInventory = 0x668 // SGInventory* (Size: 0x8)
SGGameplayAbility_ViewInventory.Character = 0x570 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ViewInventory.Inventory = 0x578 // SGInventory* (Size: 0x8)
SGGameplayAbility_ViewMonitor.MAX_INV_INTERACT_SQR_DIST = 0x550 // float (Size: 0x4)
SGGameplayAbility_ViewMonitor.ViewMonitorMontage = 0x558 // TSoftObjectPtr<UObject> (Size: 0x28)
SGGameplayAbility_ViewMonitor.ShutdownMonitorMontage = 0x580 // TSoftObjectPtr<UObject> (Size: 0x28)
SGGameplayAbility_ViewMonitor.SGCharacter = 0x5a8 // SGCharacter* (Size: 0x8)
SGGameplayAbility_ViewMonitor.MonitorInventory = 0x5b0 // SGSecurityMonitor* (Size: 0x8)
SGGameplayAbility_ViewWeapon.Character = 0x550 // Character* (Size: 0x8)
SGGameplayAbility_ViewWeapon.CurrentHandMontageParams = 0x558 // FSGMontagePlayParams (Size: 0x48)
SGGameplayAbility_ViewWeapon.PlayViewWeaponMontageTask = 0x5a0 // SGAbilityTask_PlayWeaponMontage* (Size: 0x8)
SGGameplayAbility_WeaponDetector.CurrentWeapon = 0x550 // SGWeapon* (Size: 0x8)
SGGameplayAbility_WithDestWeap.CachedCharacter = 0x550 // SGCharacter* (Size: 0x8)
SGGameplayAbility_WithDestWeap.CachedLastWeapon = 0x558 // SGInventory* (Size: 0x8)
SGGameplayAbility_WithDestWeap.CachedDestWeapon = 0x560 // SGInventory* (Size: 0x8)
SGGameplayAbility_WithDestWeap.bInstantSwitchToDestWeapon = 0x568 // bool (Size: 0x1)
SGGameplayAbility_WithDestWeap.bTakeUpWeapon = 0x569 // bool (Size: 0x1)
SGGameplayEffectContext.SGGEDataRef = 0x70 // FSGGEDataReference (Size: 0x18)
SGGameplayEffectExecutionCalculation_RecordRemoveEffect.EffectType = 0x40 // EECharacterGameEffectType (Size: 0x1)
SGGameplayEffectExecutionCalculation_RecordRemoveEffect.EnduranceType = 0x41 // EECharacterEnduranceType (Size: 0x1)
SGGameplayEffectExecutionCalculation_UseInBodyType.UseInBestMatchBodyPart = 0x40 // bool (Size: 0x1)
SGGameplayEffectExecutionCalculation_UseInBodyType.EnduranceType = 0x41 // EECharacterEnduranceType (Size: 0x1)
SGGameplayEffect_TakeDamage.DamageEventObject = 0x7c0 // DamageEventObject* (Size: 0x8)
SGGas.CurrentIntensity = 0x310 // float (Size: 0x4)
SGGashapon.interactareabox = 0x318 // BoxComponent* (Size: 0x8)
SGGashapon.GashaponName = 0x320 // FString (Size: 0x10)
SGGashapon.Capacity = 0x330 // int32_t (Size: 0x4)
SGGashapon.CharacterUsageCounter = 0x334 // int32_t (Size: 0x4)
SGGashapon.InteractionExpressionTime = 0x338 // float (Size: 0x4)
SGGashapon.GashaponSpawnInventoryGears = 0x340 // TMap<...> (Size: 0x50)
SGGashapon.SpendInventoryInfoList = 0x390 // TArray<FInteractInventoryInfo> (Size: 0x10)
SGGashapon.CurGashaponGearsType = 0x3a0 // EEGashaponGearsType (Size: 0x1)
SGGashapon.LeftItemCount = 0x3a4 // int32_t (Size: 0x4)
SGGashapon.OnStartGashaponByActor = 0x3a8 // FMulticastInlineDelegate (Size: 0x10)
SGGashapon.OnLeftItemCountChange = 0x3b8 // FMulticastInlineDelegate (Size: 0x10)
SGGashapon.OnGashaponGearsTypeChange = 0x3c8 // FMulticastInlineDelegate (Size: 0x10)
SGGashaponBeUsedComponent.ForbidInteractGidList = 0x148 // TArray<uint64_t> (Size: 0x10)
SGGashaponBeUsedComponent.bCanUsed = 0x158 // bool (Size: 0x1)
SGGashaponBeUsedComponent.UserCounterActorMap = 0x160 // TMap<...> (Size: 0x50)
SGGashaponExtend.NeedItemNum = 0x3d8 // int32_t (Size: 0x4)
SGGashaponExtend.NowItemNum = 0x3dc // int32_t (Size: 0x4)
SGGashaponExtend.RefuseAudio = 0x3e0 // AkAudioEvent* (Size: 0x8)
SGGashaponExtend.HandInAudio = 0x3e8 // AkAudioEvent* (Size: 0x8)
SGGashaponExtend.MachineReadyAudio = 0x3f0 // AkAudioEvent* (Size: 0x8)
SGGashaponExtend.StartAudio = 0x3f8 // AkAudioEvent* (Size: 0x8)
SGGashaponExtend.RewardContainers = 0x400 // TArray<SGInventory*> (Size: 0x10)
SGGashaponExtend.SavedOccupiedTeam = 0x410 // SGTeamInfo* (Size: 0x8)
SGGashaponExtend.GashaponState = 0x418 // FString (Size: 0x10)
SGGashaponExtend.MeshComponentName = 0x428 // FName (Size: 0x8)
SGGashaponExtend.TargetSkeletalMesh = 0x430 // SkeletalMeshComponent* (Size: 0x8)
SGGashaponExtend.InteractAnimSequence = 0x438 // AnimSequence* (Size: 0x8)
SGGashaponExtend.InteractNiagaraEffect01 = 0x440 // NiagaraSystem* (Size: 0x8)
SGGashaponExtend.InteractNiagaraEffect02 = 0x448 // NiagaraSystem* (Size: 0x8)
SGGashaponExtend.LightCurve = 0x450 // CurveFloat* (Size: 0x8)
SGGashaponExtend.ActivateSpeed = 0x458 // float (Size: 0x4)
SGGashaponExtend.ReadyToLootTimerHandle = 0x460 // FTimerHandle (Size: 0x8)
SGGashaponExtend.NiagaraComponent1 = 0x468 // NiagaraComponent* (Size: 0x8)
SGGashaponExtend.NiagaraComponent2 = 0x470 // NiagaraComponent* (Size: 0x8)
SGGlobalGridOccupyInfo.ContainerInventory = 0x0 // SGInventory* (Size: 0x8)
SGGlobalGridOccupyInfo.ContainerIndex = 0x8 // int32_t (Size: 0x4)
SGGlobalGridOccupyInfo.OccupyInfo = 0x10 // FSGGridOccupyInfo (Size: 0x18)
SGGoldPickup.Weight = 0x310 // float (Size: 0x4)
SGGraphicStyleOverridePPVActor.MaxNumStyle = 0x310 // uint8_t (Size: 0x1)
SGGraphicStyleOverridePPVActor.MaxNumQuality = 0x311 // uint8_t (Size: 0x1)
SGGraphicStyleOverridePPVActor.bResetWhenBeginOrEndPlay = 0x312 // uint8_t (Size: 0x1)
SGGraphicStyleOverridePPVActor.SortedPPComps = 0x318 // TArray<PostProcessComponent*> (Size: 0x10)
SGGraphicStyleSubSystem.OverridePPVActors = 0x30 // TArray<SGGraphicStyleOverridePPVActor*> (Size: 0x10)
SGGrenadeSoundComponent.SoundBank = 0x190 // AkAudioBank* (Size: 0x8)
SGGrenadeSoundComponent.LoopAudioEvent = 0x198 // AkAudioEvent* (Size: 0x8)
SGGridOccupyInfo.StartRow = 0x0 // int32_t (Size: 0x4)
SGGridOccupyInfo.StartColumn = 0x4 // int32_t (Size: 0x4)
SGGridOccupyInfo.EndRow = 0x8 // int32_t (Size: 0x4)
SGGridOccupyInfo.EndColumn = 0xc // int32_t (Size: 0x4)
SGGridOccupyInfo.MergeTargetInventory = 0x10 // SGInventory* (Size: 0x8)
SGGuaranteeLootExtraInfo.GuranteeCumulate = 0x0 // int32_t (Size: 0x4)
SGGuaranteeLootExtraInfo.NewGuranteeCumulate = 0x4 // int32_t (Size: 0x4)
SGGuaranteeLootExtraInfo.GuranteeAccFactor = 0x8 // float (Size: 0x4)
SGGuaranteeLootExtraInfo.GuranteeGate = 0xc // int32_t (Size: 0x4)
SGGuaranteeLootExtraInfo.CheckedItemID = 0x10 // int32_t (Size: 0x4)
SGGuaranteeLootExtraInfo.IsGuranteed = 0x14 // bool (Size: 0x1)
SGGuaranteeLootExtraInfo.IsRefreshCumulate = 0x15 // bool (Size: 0x1)
SGGunSoundComponent.WeaponTypeSwitchGroup = 0x198 // FString (Size: 0x10)
SGGunSoundComponent.WeaponNameSwitch = 0x1a8 // FString (Size: 0x10)
SGGunSoundComponent.bStableFireInterval = 0x1b8 // bool (Size: 0x1)
SGGunSoundComponent.FireIntervalPostfixes = 0x1c0 // TArray<FFireIntervalPostfix> (Size: 0x10)
SGGunSoundComponent.BasePriority = 0x1d0 // float (Size: 0x4)
SGGunSoundComponent.PriorityDropPerMeter = 0x1d4 // float (Size: 0x4)
SGGunSoundComponent.PriorityDropPerDegree = 0x1d8 // float (Size: 0x4)
SGGunSoundComponent.PlayBulletDropSound = 0x1dc // bool (Size: 0x1)
SGGunSoundComponent.BulletSizeSwitch = 0x1e0 // FString (Size: 0x10)
SGGunSoundComponent.BulletDropDelay = 0x1f0 // float (Size: 0x4)
SGGunSoundComponent.Caliber = 0x1f8 // FString (Size: 0x10)
SGGunSoundComponent.GenSoundVisualInterval = 0x208 // float (Size: 0x4)
SGGunSoundComponent.ShootingMode = 0x210 // FString (Size: 0x10)
SGGunSoundComponent.CurrentPriority = 0x220 // float (Size: 0x4)
SGGunSoundComponent.IsMutedByPriority = 0x224 // bool (Size: 0x1)
SGGunSoundComponent.FireInfo = 0x240 // FSGFireRepInfo3P (Size: 0x50)
SGGunSoundComponent.AmmoComponent = 0x290 // SGWeaponAmmoComponent* (Size: 0x8)
SGGunSoundComponent.FiringComponent = 0x298 // SGWeaponFiringComponent* (Size: 0x8)
SGGunSoundComponent.FireIntervalComponent = 0x2a0 // SGWeaponFireIntervalComponent* (Size: 0x8)
SGGunSoundComponent.BoreComp = 0x2a8 // SGWeaponBoreComponent* (Size: 0x8)
SGGunSoundComponent.CachedWeaponOwner = 0x2b0 // TWeakObjectPtr<UObject> (Size: 0x8)
SGGunSoundComponent.GameStateSoundComp = 0x2b8 // TWeakObjectPtr<UObject> (Size: 0x8)
SGGunSoundComponent.bIsAutoFireSoundPlaying = 0x2e0 // bool (Size: 0x1)
SGGunSoundComponent.bIsOwnedByLocalPlayer = 0x2e1 // bool (Size: 0x1)
SGGunSoundComponent.bIsSuppressed = 0x2e2 // bool (Size: 0x1)
SGGunSoundComponent.LoadedFiringBank = 0x2e8 // FString (Size: 0x10)
SGGunSoundComponent.bIsMechBankLoaded = 0x2f8 // bool (Size: 0x1)
SGGunSoundComponent.CachedAutoFiringEventName = 0x300 // FString (Size: 0x10)
SGGunSoundComponent.BulletDelayTime = 0x330 // float (Size: 0x4)
SGGunSoundComponent.BulletStartTime = 0x334 // float (Size: 0x4)
SGHUD.ComponentClasses = 0x420 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGHUD.LoadedComponentClasses = 0x430 // TArray<ClassProperty> (Size: 0x10)
SGHUD.ComponentClassesDynamic = 0x440 // TArray<ClassProperty> (Size: 0x10)
SGHUD.Components = 0x450 // TArray<SGUserWidget*> (Size: 0x10)
SGHUD.TemplateClass = 0x460 // ClassProperty (Size: 0x8)
SGHUD.ParticularUpdateWidgets = 0x468 // TArray<SGUserWidget*> (Size: 0x10)
SGHUD.CreateComponentTask = 0x478 // TMap<...> (Size: 0x50)
SGHUD.DebugAppInfoClasses = 0x4c8 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGHUD.PendingLoadHUDClassInfoList = 0x4d8 // TArray<FPendingLoadHUDClassInfo> (Size: 0x10)
SGHUD.DebugAppInfoWidget = 0x4e8 // SGUserWidget* (Size: 0x8)
SGHUD.SafeZoneCache = 0x4f4 // FSafeZoneCache (Size: 0x10)
SGHUD.bForceEnableSafeZone = 0x504 // bool (Size: 0x1)
SGHUD.CurrentCmdIndex = 0x520 // int32_t (Size: 0x4)
SGHUD.HUDShakeEvents = 0x528 // SGHUDShakeEvents* (Size: 0x8)
SGHUDShakeCanvasPanel.CachedCharacter = 0x348 // SGCharacter* (Size: 0x8)
SGHUDShakeCanvasPanel.CachedShakeEvents = 0x350 // SGHUDShakeEvents* (Size: 0x8)
SGHUDShakeCanvasPanel.HUDShakeConfig = 0x390 // HUDShakeConfig* (Size: 0x8)
SGHUDShakeCanvasPanel.HUDShakePanels = 0x398 // TMap<...> (Size: 0x50)
SGHUDShakeCanvasPanel.HUDShakePanelsAndTags = 0x3e8 // TMap<...> (Size: 0x50)
SGHUDShakeCanvasPanel.HUDShakePanelsScales = 0x438 // TArray<FVector2D> (Size: 0x10)
SGHUDShakeEvents.ShakePanels = 0x38 // TArray<SGHUDShakeCanvasPanel*> (Size: 0x10)
SGHUDShakeEvents.SetUseHUDShakeEvent = 0x48 // FMulticastInlineDelegate (Size: 0x10)
SGHandWeaponState.HandState = 0x0 // EESGHandState (Size: 0x1)
SGHandWeaponState.Intent = 0x8 // FSGSwitchWeaponIntent (Size: 0x28)
SGHandWeaponState.HandAnim = 0x30 // FSGMontagePlayParams (Size: 0x48)
SGHandWeaponState.WeaponAnim = 0x78 // FSGMontagePlayParams (Size: 0x48)
SGHandWeaponState.bIntentFullFilled = 0xc0 // bool (Size: 0x1)
SGHeadwearAnimationSet.PutUpHeadwearMap = 0x0 // TMap<...> (Size: 0x50)
SGHeadwearAnimationSet.PutDownHeadwearMap = 0x50 // TMap<...> (Size: 0x50)
SGHoldInputBehavior.TagsToWait = 0x0 // FGameplayTagContainer (Size: 0x20)
SGHoldInputBehavior.ActionsToOverride = 0x20 // TArray<FName> (Size: 0x10)
SGHoverBuoyancyForceComponent.CurrentWaterVolume = 0x238 // PhysicsVolume* (Size: 0x8)
SGHoverBuoyancyForceComponent.BoundsExtentBias = 0x240 // float (Size: 0x4)
SGHoverBuoyancyForceComponent.WeightFactorBias = 0x244 // float (Size: 0x4)
SGHoverBuoyancyForceComponent.LinearDamping = 0x248 // float (Size: 0x4)
SGHoverBuoyancyForceComponent.AngularDamping = 0x24c // float (Size: 0x4)
SGHoverBuoyancyForceComponent.LinearDampingCoefficient = 0x250 // float (Size: 0x4)
SGHoverBuoyancyForceComponent.BuoyancyCollider = 0x260 // SkeletalMeshComponent* (Size: 0x8)
SGHoverBuoyancyForceComponent.bUseAABBBounds = 0x268 // bool (Size: 0x1)
SGHoverBuoyancyForceComponent.Samples = 0x26c // int32_t (Size: 0x4)
SGHoverBuoyancyForceComponent.WidthCount = 0x270 // int32_t (Size: 0x4)
SGHoverBuoyancyForceComponent.HeightCount = 0x274 // int32_t (Size: 0x4)
SGHoverBuoyancyForceComponent.CheckPointBoxSize = 0x278 // FVector (Size: 0xc)
SGHoverBuoyancyForceComponent.WeightFactor = 0x284 // float (Size: 0x4)
SGHoverForceComponent.TraceLength = 0x238 // float (Size: 0x4)
SGHoverForceComponent.HoverForce = 0x23c // float (Size: 0x4)
SGHoverForceComponent.LinearDamping = 0x240 // float (Size: 0x4)
SGHoverForceComponent.AngularDamping = 0x244 // float (Size: 0x4)
SGHoverForceComponent.ZOffset = 0x248 // float (Size: 0x4)
SGHoverVehicle.bIsSpeedUp = 0x399 // bool (Size: 0x1)
SGHoverVehicle.bToggleBrake = 0x39a // bool (Size: 0x1)
SGHoverVehicle.VehicleHitInfo = 0x3a0 // FVehicleHitRepInfo (Size: 0x10)
SGHoverVehicle.BPConfigVehicleType = 0x3b0 // EESGVehicleType (Size: 0x1)
SGHoverVehicle.VehicleSeatData = 0x3b8 // FVehicleSeatData (Size: 0x40)
SGHoverVehicle.ExtendSeatCount = 0x3f8 // int32_t (Size: 0x4)
SGHoverVehicle.DriverHalfHeight = 0x3fc // float (Size: 0x4)
SGHoverVehicle.DriverRadius = 0x400 // float (Size: 0x4)
SGHoverVehicle.Mesh = 0x408 // SkeletalMeshComponent* (Size: 0x8)
SGHoverVehicle.HoverMovementComp = 0x410 // HoverVehicleMovementComponentBase* (Size: 0x8)
SGHoverVehicle.SpringArm = 0x418 // SpringArmComponent* (Size: 0x8)
SGHoverVehicle.Camera = 0x420 // CameraComponent* (Size: 0x8)
SGHoverVehicle.FuelComponent = 0x428 // VehicleFuelComponent* (Size: 0x8)
SGHoverVehicle.BoxCollisionForPawn = 0x430 // BoxComponent* (Size: 0x8)
SGHoverVehicle.BoxOverlapFront = 0x438 // BoxComponent* (Size: 0x8)
SGHoverVehicle.BoxOverlapBack = 0x440 // BoxComponent* (Size: 0x8)
SGHoverVehicle.HitWallDamageVelocityThreshold = 0x448 // float (Size: 0x4)
SGHoverVehicle.HitWallPassengerHurtDamageCurve = 0x450 // CurveFloat* (Size: 0x8)
SGHoverVehicle.HitWallVehicleHurtDamageCurve = 0x458 // CurveFloat* (Size: 0x8)
SGHoverVehicle.OverlapCarForceCurve = 0x460 // CurveFloat* (Size: 0x8)
SGHoverVehicle.OverlapCarDamageCurve = 0x468 // CurveFloat* (Size: 0x8)
SGHoverVehicle.ExploreDamage = 0x470 // float (Size: 0x4)
SGHoverVehicle.ExploreDamageRadius = 0x474 // float (Size: 0x4)
SGHoverVehicle.HitPawnDamageVelocityThreshold = 0x478 // float (Size: 0x4)
SGHoverVehicle.DeadBodyExistTime = 0x480 // float (Size: 0x4)
SGHoverVehicle.bVehicleDebugMode = 0x484 // bool (Size: 0x1)
SGHoverVehicle.MaxEnterVehicleDistance = 0x488 // float (Size: 0x4)
SGHoverVehicle.PhysicsBlendValue = 0x48c // float (Size: 0x4)
SGHoverVehicle.ForceVelocityHitBank = 0x490 // float (Size: 0x4)
SGHoverVehicle.OutOfWaterCount = 0x49c // int32_t (Size: 0x4)
SGHoverVehicle.EyeButtonCameraRotateFactor = 0x4b4 // float (Size: 0x4)
SGHoverVehicle.MoreForwardAreaTanValue = 0x4b8 // float (Size: 0x4)
SGHoverVehicle.HoverForceComponentArray = 0x4c0 // TArray<SGHoverForceComponent*> (Size: 0x10)
SGHoverVehicle.HoverBuoyancyForceComponent = 0x4d0 // SGHoverBuoyancyForceComponent* (Size: 0x8)
SGHoverVehicle.MaxHealth = 0x4d8 // int32_t (Size: 0x4)
SGHoverVehicle.DamageScale = 0x4e0 // TArray<FVehicleDamageScale> (Size: 0x10)
SGHoverVehicle.Health = 0x4f0 // int32_t (Size: 0x4)
SGHoverVehicle.SmokingScale = 0x4f4 // float (Size: 0x4)
SGHoverVehicle.BurningScale = 0x4f8 // float (Size: 0x4)
SGHoverVehicle.bPlayDying = 0x4fc // bool (Size: 0x1)
SGHoverVehicle.bNearlyBroken = 0x4fd // bool (Size: 0x1)
SGHoverVehicle.bPlaySmoking = 0x4fe // bool (Size: 0x1)
SGHoverVehicle.ImpactTemplate = 0x500 // ClassProperty (Size: 0x8)
SGHoverVehicle.ImpactEffectNormalForceThreshold = 0x508 // float (Size: 0x4)
SGHoverVehicle.LowHealthEffect = 0x510 // TArray<FVehicleLowHealthEffect> (Size: 0x10)
SGHoverVehicle.DestroyedMaterial = 0x520 // MaterialInstanceConstant* (Size: 0x8)
SGHoverVehicle.CurrentLowHealthPSC = 0x528 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.SoundComponent = 0x530 // SGVehicleSoundComponent* (Size: 0x8)
SGHoverVehicle.VehicleCommonComp = 0x538 // SGVehicleCommonComp* (Size: 0x8)
SGHoverVehicle.VehicleMeshMI = 0x540 // MaterialInstanceDynamic* (Size: 0x8)
SGHoverVehicle.LandingSound = 0x548 // SoundCue* (Size: 0x8)
SGHoverVehicle.DustPSC = 0x550 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.SkidThresholdVelocity = 0x570 // float (Size: 0x4)
SGHoverVehicle.LongSlipSkidThreshold = 0x574 // float (Size: 0x4)
SGHoverVehicle.LateralSlipSkidThreshold = 0x578 // float (Size: 0x4)
SGHoverVehicle.VehicleExplodeAttachSocketName = 0x57c // FName (Size: 0x8)
SGHoverVehicle.VehicleExplodeEffect = 0x588 // ParticleSystem* (Size: 0x8)
SGHoverVehicle.VehicleExplodeEffectPSC = 0x590 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.VehicleMoveAttachSocketName = 0x598 // FName (Size: 0x8)
SGHoverVehicle.VehicleMoveEffect = 0x5a0 // ParticleSystem* (Size: 0x8)
SGHoverVehicle.VehicleMoveEffectPSC = 0x5a8 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.MoveSpeedCurve = 0x5b0 // CurveFloat* (Size: 0x8)
SGHoverVehicle.VehicleBroken1AttachSocketName = 0x5b8 // FName (Size: 0x8)
SGHoverVehicle.VehicleBroken1Effect = 0x5c0 // ParticleSystem* (Size: 0x8)
SGHoverVehicle.VehicleBroken1EffectPSC = 0x5c8 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.VehicleBroken2AttachSocketName = 0x5d0 // FName (Size: 0x8)
SGHoverVehicle.VehicleBroken2Effect = 0x5d8 // ParticleSystem* (Size: 0x8)
SGHoverVehicle.VehicleBroken2EffectPSC = 0x5e0 // ParticleSystemComponent* (Size: 0x8)
SGHoverVehicle.TimerHandle_DisableSimulatePhysics = 0x5e8 // FTimerHandle (Size: 0x8)
SGHoverVehicle.VehicleType = 0x5f0 // uint8_t (Size: 0x1)
SGHoverVehicle.Driver = 0x5f8 // Pawn* (Size: 0x8)
SGHoverVehicle.SeatRepData = 0x600 // FVehicleSeatRepData (Size: 0x38)
SGHoverVehicle.TireData = 0x638 // FVehicleTireData (Size: 0x10)
SGHoverVehicle.SpringCompressionLandingThreshold = 0x648 // float (Size: 0x4)
SGHoverVehicle.SkidDurationRequiredForStopSound = 0x64c // float (Size: 0x4)
SGHoverVehicle.PhysicsMaterialSoundMinSpeed = 0x650 // float (Size: 0x4)
SGHoverVehicle.ImpactCameraShake = 0x670 // ClassProperty (Size: 0x8)
SGHoverVehicle.IsFreeRotationCamera = 0x678 // bool (Size: 0x1)
SGHoverVehicle.DriverCameraRotateFactor = 0x67c // float (Size: 0x4)
SGHoverVehicle.DriverCameraYawMin = 0x680 // float (Size: 0x4)
SGHoverVehicle.DriverCameraYawMax = 0x684 // float (Size: 0x4)
SGHoverVehicle.DriverCameraPitchMin = 0x688 // float (Size: 0x4)
SGHoverVehicle.DriverCameraPitchMax = 0x68c // float (Size: 0x4)
SGHoverVehicle.SeatSpringArmOffSetX = 0x690 // float (Size: 0x4)
SGHoverVehicle.SeatSpringArmOffSetY = 0x694 // float (Size: 0x4)
SGHoverVehicle.InitialSpringArmPitch = 0x698 // float (Size: 0x4)
SGHoverVehicle.CurrentWaterVolume = 0x6c8 // PhysicsVolume* (Size: 0x8)
SGHoverVehicle.VehicleMaxSpeedInDS = 0x6e0 // float (Size: 0x4)
SGHoverVehicle.VehicleMaxSpeedTolerateRate = 0x6e4 // float (Size: 0x4)
SGHoverVehicle.bIngoreSteerInputValue = 0x6e8 // bool (Size: 0x1)
SGHoverVehicle.SyncPhysicStateComponent = 0x6f0 // SGVehicleSyncPhysicStateComponent* (Size: 0x8)
SGHoverVehicle.VehicleParamsTable = 0x6f8 // DataTable* (Size: 0x8)
SGIdleBreathAnimationSet.UseIdleBreathAnimation = 0x0 // bool (Size: 0x1)
SGIdleBreathAnimationSet.IdleBreathAnimation = 0x8 // AnimSequence* (Size: 0x8)
SGImageButton.AdvancedHitTexture = 0x290 // Texture2D* (Size: 0x8)
SGImageButton.PixelAlphaData = 0x298 // TArray<uint8_t> (Size: 0x10)
SGImpactAudioData_HD.EnvironmentImpacts = 0x30 // TMap<...> (Size: 0x50)
SGImpactAudioData_HD.EnvironmentRicochetImpacts = 0x80 // TMap<...> (Size: 0x50)
SGImpactAudioData_HD.HeadImpact = 0xd0 // FImpactAudioResource_HD (Size: 0x18)
SGImpactAudioData_HD.BodyImpact = 0xe8 // FImpactAudioResource_HD (Size: 0x18)
SGImpactAudioData_HD.ArmorImpact = 0x100 // FImpactAudioResource_HD (Size: 0x18)
SGImpactAudioData_HD.RicochetImpact = 0x118 // FImpactAudioResource_HD (Size: 0x18)
SGImpactAudioData_HD.TerminalImpact = 0x130 // FImpactAudioResource_HD (Size: 0x18)
SGImpactAudioData_HD.HeadshotTerminalImpact = 0x148 // FImpactAudioResource_HD (Size: 0x18)
SGImpactEffectData_HD.EnvironmentImpacts = 0x30 // TMap<...> (Size: 0x50)
SGImpactEffectData_HD.BodyImpact = 0x80 // FImpactEffectResource_HD (Size: 0x90)
SGImpactEffectData_HD.ArmorImpact = 0x110 // FImpactEffectResource_HD (Size: 0x90)
SGImpactEffectData_HD.RicochetImpact = 0x1a0 // FImpactEffectResource_HD (Size: 0x90)
SGImpactEffectData_HD.TerminalImpact = 0x230 // FImpactEffectResource_HD (Size: 0x90)
SGImpactEffect_HD.DecalComponent = 0x358 // DecalComponent* (Size: 0x8)
SGImpactEffect_HD.AoDecalComponent = 0x360 // DecalComponent* (Size: 0x8)
SGImpactEffect_HD.MeshComponent = 0x368 // StaticMeshComponent* (Size: 0x8)
SGImpactRicochetData_HD.EnvironmentImpacts = 0x30 // TMap<...> (Size: 0x50)
SGInputControlStruct.BCanMove = 0x0 // bool (Size: 0x1)
SGInputControlStruct.bCanTurn = 0x1 // bool (Size: 0x1)
SGInputControlStruct.bCanSprint = 0x2 // bool (Size: 0x1)
SGInteractActorComponent.InteractModeConfigList = 0xf8 // TArray<FInteractConfig> (Size: 0x10)
SGInteractActorComponent.KeyItemID = 0x108 // int64_t (Size: 0x8)
SGInteractActorComponent.DefaultKeyAttachDelayTime = 0x110 // float (Size: 0x4)
SGInteractActorComponent.DefaultKeyDetachDelayTime = 0x114 // float (Size: 0x4)
SGInteractActorComponent.TriggerFinishTime = 0x118 // float (Size: 0x4)
SGInteractActorComponent.DefaultAnimMontageName = 0x120 // FString (Size: 0x10)
SGInteractActorComponent.ActorName = 0x130 // FName (Size: 0x8)
SGInteractActorComponent.InteractMode = 0x138 // int32_t (Size: 0x4)
SGInteractActorComponent.NotNeedRotateUser = 0x13c // bool (Size: 0x1)
SGInteractActorComponent.NotNeedForbiddenMove = 0x13d // bool (Size: 0x1)
SGInteractActorComponent.InteractMarkerIndex = 0x140 // int32_t (Size: 0x4)
SGInteractComponentBase.LocalControlledCharacter = 0xf8 // SGCharacter* (Size: 0x8)
SGInteractComponentBase.SelectInventories = 0x100 // TArray<SGInventory*> (Size: 0x10)
SGInteractComponentBase.UserWidgetPopInfos = 0x110 // TArray<FUserWidgetPopInfo> (Size: 0x10)
SGInteractComponentBase.DisableInteractTargets = 0x130 // TArray<Actor*> (Size: 0x10)
SGInteractComponentBase.ActorFilterType = 0x140 // EEActorFilterType (Size: 0x1)
SGInteractComponentBase.CheckTargets = 0x148 // TArray<Actor*> (Size: 0x10)
SGInteractComponentBase.bIsOwnerInteractable = 0x158 // bool (Size: 0x1)
SGInteractUserWidget.InteractActor = 0x2f0 // Actor* (Size: 0x8)
SGInteractUserWidget.InteractComponent = 0x2f8 // SGInteractComponentBase* (Size: 0x8)
SGInteractUserWidget.InteractRequireTime = 0x300 // float (Size: 0x4)
SGInteractUserWidget.DisplayIcon = 0x308 // Object* (Size: 0x8)
SGInteractUserWidget.DisplayText = 0x310 // FText (Size: 0x18)
SGInteractUserWidget.UsingDisplayText = 0x328 // FText (Size: 0x18)
SGInteractableActor.InteractID = 0x318 // int32_t (Size: 0x4)
SGInvAnimationAdditionMeshInfo.AdapterAnimType = 0x0 // EEAdapterAnimationType (Size: 0x1)
SGInvAnimationAdditionMeshInfo.SkeletalMeshPath = 0x8 // FSoftObjectPath (Size: 0x18)
SGInvAnimationAdditionMeshInfo.AdditionMeshAnim = 0x20 // AnimSequenceBase* (Size: 0x8)
SGInvAnimationAdditionMeshInfo.CachedSkeletalMesh = 0x28 // SkeletalMesh* (Size: 0x8)
SGInvAnimationAdditionMeshInfo.bAttachToCharacter = 0x30 // bool (Size: 0x1)
SGInvAnimationAdditionMeshInfo.AttachSocketName = 0x34 // FName (Size: 0x8)
SGInvAnimationAdditionMeshInfo.AdditionMeshAnimSoftPtr = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInvAnimationAdditionMeshInfo.AdditionMeshAnimInstancePath = 0x68 // FSoftClassPath (Size: 0x18)
SGInvAnimationAdditionMeshInfo.AdditionMeshAnimInstance = 0x80 // ClassProperty (Size: 0x8)
SGInventory.PreGiveToEvent = 0x320 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.AddedEvent = 0x330 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.RemovedEvent = 0x340 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.DragedEvent = 0x350 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnRollUpStateChanged = 0x360 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.AssembledEvent = 0x370 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnAssembledEvent = 0x380 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.AdpaterFreshEvent = 0x390 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.DisassembledEvent = 0x3a0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.BeDisassembledEvent = 0x3b0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.AllAssembleFinishedEvent = 0x3c0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.RemovedFromGridWidgetEvent = 0x3d0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.ChangeAttachPosEvent = 0x3e0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnOwnerChangedEvent = 0x3f0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnSelfOwnerChangedEvent = 0x400 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.ChangeParentActorEvent = 0x410 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.ClientChangeParentActorEvent = 0x420 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.LockedByCharacterChangedEvent = 0x430 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnWeaponActivedEvent = 0x440 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryDropped = 0x450 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnSwitchToSimpleMeshEvent = 0x460 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventorySkeletalMeshLoadCompleted = 0x470 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryStaticMeshLoadCompleted = 0x480 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventorySimpleSkeletalMeshLoadCompleted = 0x490 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnEquipSkeletalMeshLoadCompleted = 0x4a0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnEquipStaticMeshLoadCompleted = 0x4b0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryHiddenStateChanged = 0x4c0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryVisibilityChanged = 0x4d0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryAttachToBack = 0x4e0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryDressed = 0x4f0 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryUnDressed = 0x500 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnStartInteractBoxInventory = 0x510 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryGridInfoChange = 0x520 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnDetectorUpdateCoolDown = 0x620 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnPostSetSkeletalMesh = 0x630 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInventoryRebornSaftyStateChanged = 0x640 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnSearchFinished = 0x650 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.OnInstIdReplicated = 0x678 // FMulticastInlineDelegate (Size: 0x10)
SGInventory.ZoneInfoComponent = 0x6a0 // SGInventoryZoneInfoComponent* (Size: 0x8)
SGInventory.ItemId = 0x6a8 // uint64_t (Size: 0x8)
SGInventory.ArmorLevel = 0x6b0 // uint32_t (Size: 0x4)
SGInventory.ArmorMaterialID = 0x6b4 // uint32_t (Size: 0x4)
SGInventory.MagazineTypeName = 0x6b8 // FString (Size: 0x10)
SGInventory.MagazineLeftHandOffset_ReloadMag = 0x6d0 // FTransform (Size: 0x30)
SGInventory.MagazineLeftHandOffset_CheckMag = 0x700 // FTransform (Size: 0x30)
SGInventory.RenderRotator = 0x730 // FRotator (Size: 0xc)
SGInventory.isRollup = 0x73c // bool (Size: 0x1)
SGInventory.UniqueID = 0x740 // FString (Size: 0x10)
SGInventory.CommonDataComponent = 0x750 // SGInventoryCommonDataComponent* (Size: 0x8)
SGInventory.InventoryType = 0x758 // EESGInventoryType (Size: 0x1)
SGInventory.RelevantCheckType = 0x780 // EERelevantCheckType (Size: 0x1)
SGInventory.RelevantForActors = 0x788 // TArray<Actor*> (Size: 0x10)
SGInventory.bIsInRebornSafty = 0x799 // bool (Size: 0x1)
SGInventory.LastRefreshFrame = 0x7a0 // uint64_t (Size: 0x8)
SGInventory.LastInfoChangeMask = 0x7a8 // int32_t (Size: 0x4)
SGInventory.RuntimeID = 0x7b0 // int32_t (Size: 0x4)
SGInventory.EquipPosition = 0x7b4 // EEWeaponEquipPosition (Size: 0x1)
SGInventory.MinComponentTickOptDist = 0x7b8 // float (Size: 0x4)
SGInventory.MinComponentTickOptInterval = 0x7bc // float (Size: 0x4)
SGInventory.MinActorTickOptDist = 0x7c0 // float (Size: 0x4)
SGInventory.MinActorTickOptInterval = 0x7c4 // float (Size: 0x4)
SGInventory.bForceUseOwnerTickInterval = 0x7c8 // bool (Size: 0x1)
SGInventory.bFreezed = 0x7cc // bool (Size: 0x1)
SGInventory.ManualFollowOnwer = 0x7d0 // FManualNetRelevantFollowOnwerInfo (Size: 0x10)
SGInventory.bBeDormantWhenFollowOwner = 0x7e0 // bool (Size: 0x1)
SGInventory.AssembleComp = 0x7e8 // SGInventoryAssembleComponent* (Size: 0x8)
SGInventory.EquipMeshComp = 0x7f0 // SGInventoryEquipMeshComponent* (Size: 0x8)
SGInventory.MeshComponent = 0x7f8 // SGInventoryMeshComponent* (Size: 0x8)
SGInventory.InventoryCameraComp = 0x800 // SGInventoryCameraComponent* (Size: 0x8)
SGInventory.InventoryModifyAttributeComp = 0x808 // SGInventoryModifyAttributeComponent* (Size: 0x8)
SGInventory.WeaponMovementComponent = 0x810 // SGWeaponMovementComponent* (Size: 0x8)
SGInventory.InventoryTypeComponent_Avatar = 0x818 // SGInventoryTypeComponent_Avatar* (Size: 0x8)
SGInventory.InventoryTypeComponent_Armor = 0x820 // SGInventoryTypeComponent_Armor* (Size: 0x8)
SGInventory.InventoryTypeComponent_Badge = 0x828 // SGInventoryTypeComponent_Badge* (Size: 0x8)
SGInventory.InventoryAbilityComponent = 0x830 // SGInventoryAbilityComponent* (Size: 0x8)
SGInventory.InventoryZoomComponent = 0x838 // SGInventoryZoomComponent* (Size: 0x8)
SGInventory.SoundDiffuseComponent = 0x840 // SGInventorySoundDiffuseComponent* (Size: 0x8)
SGInventory.CacheInventoryGridComponent = 0x848 // SGInventoryGridComponent* (Size: 0x8)
SGInventory.InventoryArmorComponent = 0x850 // SGInventoryArmorComponent* (Size: 0x8)
SGInventory.WidgetToRenderTargetComponent = 0x858 // SGWidgetToRenderTargetComponent* (Size: 0x8)
SGInventory.bIsPaint = 0x860 // bool (Size: 0x1)
SGInventory.PaintTextureId = 0x864 // int32_t (Size: 0x4)
SGInventory.PaintTexturePtr = 0x868 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventory.BindShortcutPos = 0x890 // EEAttachPosition (Size: 0x1)
SGInventory.ModifiedContainerIndex = 0x894 // int32_t (Size: 0x4)
SGInventoryAbilityComponent.AbilityClass = 0x100 // ClassProperty (Size: 0x8)
SGInventoryAbilityComponent.UseInventoryDelegateName = 0x108 // FName (Size: 0x8)
SGInventoryAbilityComponent.ActiveAttachPosition = 0x110 // EEAttachPosition (Size: 0x1)
SGInventoryAbilityComponent.bPassive = 0x111 // bool (Size: 0x1)
SGInventoryAbilityComponent.bCancelAbilityWhileMoving = 0x112 // bool (Size: 0x1)
SGInventoryAbilityComponent.CancelAbilityMovingThreshold = 0x114 // float (Size: 0x4)
SGInventoryAbilityComponent.TargetUser = 0x118 // Actor* (Size: 0x8)
SGInventoryAbilityComponent.AuxiliaryCurve1 = 0x130 // CurveFloat* (Size: 0x8)
SGInventoryAbilityComponent.AuxiliaryCurve2 = 0x138 // CurveFloat* (Size: 0x8)
SGInventoryAbilityComponent.SeedForDecideSubInventory = 0x140 // int32_t (Size: 0x4)
SGInventoryAbilityComponent.SGGADataRef = 0x148 // FSGGADataReference (Size: 0x10)
SGInventoryAbilityComponent.SetupGEDataReference = 0x158 // FSGGEDataReference (Size: 0x18)
SGInventoryAbilityComponent.SetupHandle = 0x170 // FActiveGameplayEffectHandle (Size: 0x8)
SGInventoryAbilityComponent.bPreloadGARequiredAsset = 0x178 // bool (Size: 0x1)
SGInventoryActivityItemComponent.LevelupInstID = 0x100 // uint64_t (Size: 0x8)
SGInventoryActivityItemComponent.ActivityItemExtraInfo = 0x108 // FInventoryActivityItemExtraInfo (Size: 0x48)
SGInventoryAnimInstance.LocalProxy = 0x2c0 // FSGInventoryAnimInstanceProxy (Size: 0x870)
SGInventoryAnimInstanceProxy.bIs1P = 0x860 // bool (Size: 0x1)
SGInventoryAnimInstanceProxy.bIsOwnerCharacterProne = 0x861 // bool (Size: 0x1)
SGInventoryAnimInstanceProxy.AnimInstance = 0x868 // SGInventoryAnimInstance* (Size: 0x8)
SGInventoryAnimationComponent.EquipAnimPoseInfo = 0x108 // FInventoryAnimPoseInfo (Size: 0x18)
SGInventoryAnimationComponent.bIsAssembled = 0x120 // bool (Size: 0x1)
SGInventoryAnimationComponent.bOnlyEnableAnimWhenAssembled = 0x139 // bool (Size: 0x1)
SGInventoryAnimationComponent.AdapterAnimSet = 0x140 // FSGAdapterAnimSet (Size: 0xa0)
SGInventoryAnimationComponent.FoldStockAnimSeq = 0x1e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.UnFoldStockAnimSeq = 0x208 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.FoldScopeAnimAdapterOffset = 0x230 // FVector (Size: 0xc)
SGInventoryAnimationComponent.CharacterFoldScopeHandMontage = 0x240 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.CharacterUnfoldScopeHandMontage = 0x268 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.AdditionMeshAnimInfos = 0x290 // TArray<FSGInvAnimationAdditionMeshInfo> (Size: 0x10)
SGInventoryAnimationComponent.AdditionSkeletalMeshComp = 0x2a0 // SkeletalMeshComponent* (Size: 0x8)
SGInventoryAnimationComponent.ViewInventory_CharacterMontage = 0x2a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.ViewInventory_InventoryMontage = 0x2d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.HoldInventory_BlockOtherInputAnim = 0x2f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryAnimationComponent.HoldInventoryViewMontageList = 0x320 // TArray<FSGCharacterInventoryMontageParams> (Size: 0x10)
SGInventoryAnimationComponent.OnInventoryAnimationNotify = 0x330 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryAnimationComponent.AdditionMeshAnimInstClass = 0x358 // ClassProperty (Size: 0x8)
SGInventoryArmorComponent.GasResistanceCurve = 0x160 // CurveFloat* (Size: 0x8)
SGInventoryAssembleComponent.AssembleTag = 0x108 // FGameplayTag (Size: 0x8)
SGInventoryAssembleComponent.AssembleForGripTag = 0x110 // FGameplayTag (Size: 0x8)
SGInventoryAssembleComponent.SubAssembleTag = 0x118 // FGameplayTag (Size: 0x8)
SGInventoryAssembleComponent.ConflictClassList = 0x120 // TArray<uint32_t> (Size: 0x10)
SGInventoryAssembleComponent.DisplayContainerIndexOnParent = 0x130 // int32_t (Size: 0x4)
SGInventoryAssembleComponent.ContainerGridInfoOnParent = 0x134 // FItemGridInfo (Size: 0x8)
SGInventoryAssembleComponent.AssembleSupportSocketList = 0x140 // TArray<FAssembleSocketInfo> (Size: 0x10)
SGInventoryAssembleComponent.AssembleSocketOffsets = 0x150 // TArray<FAssembleSocketOffset> (Size: 0x10)
SGInventoryAssembleComponent.ParentItem = 0x160 // Actor* (Size: 0x8)
SGInventoryAssembleComponent.ParentSocketIndex = 0x168 // int32_t (Size: 0x4)
SGInventoryAssembleComponent.InventoryWidth = 0x16c // int32_t (Size: 0x4)
SGInventoryAssembleComponent.InventoryHeight = 0x170 // int32_t (Size: 0x4)
SGInventoryAssembleComponent.ScopeAimTransform = 0x180 // FTransform (Size: 0x30)
SGInventoryAssembleComponent.ScopeAimSocketName = 0x1b0 // FName (Size: 0x8)
SGInventoryAssembleComponent.ZeroPointSocketName = 0x1b8 // FName (Size: 0x8)
SGInventoryAssembleComponent.SubScopeAimSocketNames = 0x1c0 // TArray<FName> (Size: 0x10)
SGInventoryAssembleComponent.SubMagnificationScopeAimSocketNames = 0x1d0 // TArray<FName> (Size: 0x10)
SGInventoryAssembleComponent.BoreSocketName = 0x1e0 // FName (Size: 0x8)
SGInventoryAssembleComponent.MultiBoreSockets = 0x1e8 // TArray<FName> (Size: 0x10)
SGInventoryAssembleComponent.WeaponWtihStockHoldingOffset = 0x1f8 // FVector (Size: 0xc)
SGInventoryAssembleComponent.WeaponWtihHandguardOffset_LeftHand = 0x204 // FVector (Size: 0xc)
SGInventoryAssembleComponent.WeaponWtihHandguardOffset_LeftHand_Female = 0x210 // FVector (Size: 0xc)
SGInventoryAssembleComponent.DisableHandguardOffsetWithoutForegrip = 0x21c // bool (Size: 0x1)
SGInventoryAssembleComponent.LFingerAdaptiveAlpha = 0x220 // float (Size: 0x4)
SGInventoryAssembleComponent.ScopeRadius = 0x224 // float (Size: 0x4)
SGInventoryAssembleComponent.SightSubBlockAreas = 0x228 // TArray<FSightBlockArea> (Size: 0x10)
SGInventoryAssembleComponent.IronSightDiffHeight = 0x238 // float (Size: 0x4)
SGInventoryAssembleComponent.bUnAssemable = 0x23c // bool (Size: 0x1)
SGInventoryAssembleComponent.bStockCanBeFolded = 0x23d // bool (Size: 0x1)
SGInventoryAssembleComponent.ADSShakeScale = 0x240 // float (Size: 0x4)
SGInventoryAssembleComponent.FPPSprintWeaponTriggerOffset = 0x244 // FVector (Size: 0xc)
SGInventoryAssembleComponent.CachedBulletMeshComps = 0x250 // TMap<...> (Size: 0x50)
SGInventoryAssembleComponent.ExtraFireRequireTagList = 0x2a0 // FGameplayTagContainer (Size: 0x20)
SGInventoryAssembleComponent.DeducteFireRequireTag = 0x2c0 // FGameplayTag (Size: 0x8)
SGInventoryAssembleComponent.BipodHeight = 0x2c8 // float (Size: 0x4)
SGInventoryAssembleComponent.ParentItemList = 0x2d0 // TArray<FAssembleParentInfo> (Size: 0x10)
SGInventoryAssembleComponent.ShowBulletWhenSpectated = 0x2e0 // bool (Size: 0x1)
SGInventoryAssembleComponent.CachedBullet = 0x2e8 // StaticMeshComponent* (Size: 0x8)
SGInventoryAssembleComponent.CachedBores = 0x2f0 // TArray<StaticMeshComponent*> (Size: 0x10)
SGInventoryAssembleComponent.bFireRequiredTagFilled = 0x304 // bool (Size: 0x1)
SGInventoryAssembleComponent.MatchTagResults = 0x308 // TMap<...> (Size: 0x50)
SGInventoryAttachDefaultClassesComponent.bForceCreate = 0x100 // bool (Size: 0x1)
SGInventoryAttachDefaultClassesComponent.bUseOldLst = 0x101 // bool (Size: 0x1)
SGInventoryAttachDefaultClassesComponent.AttachmentInfoLst = 0x108 // TArray<FAttachInvInfo> (Size: 0x10)
SGInventoryAttachDefaultClassesComponent.AttachmentInfo = 0x118 // AttachInventoryInfo* (Size: 0x8)
SGInventoryAttachDefaultClassesComponent.bForceMakeMagFull = 0x120 // bool (Size: 0x1)
SGInventoryAttachDefaultClassesComponent.DefaultInventories = 0x130 // TArray<SGInventory*> (Size: 0x10)
SGInventoryBagEquipMeshComponent.LeftWeaponSocketOffset = 0x850 // FVector (Size: 0xc)
SGInventoryBagEquipMeshComponent.RightWeaponSocketOffset = 0x85c // FVector (Size: 0xc)
SGInventoryBeUsedComponent.InteractLimitAxis = 0x150 // EEActorInteractLimitAxis (Size: 0x1)
SGInventoryBeUsedComponent.InteractLimitAngle = 0x154 // float (Size: 0x4)
SGInventoryBeUsedComponent.InteractLimitDistanceSq = 0x158 // float (Size: 0x4)
SGInventoryBeUsedComponent.PreCheckEnduranceLoss = 0x15c // bool (Size: 0x1)
SGInventoryBeUsedComponent.PreCheckBoneBreak = 0x15d // bool (Size: 0x1)
SGInventoryBeUsedComponent.PreCheckBleed = 0x15e // bool (Size: 0x1)
SGInventoryBeUsedComponent.PreCheckOutOfEndurance = 0x15f // bool (Size: 0x1)
SGInventoryBeUsedComponent.PreCheckSelfRescue = 0x160 // bool (Size: 0x1)
SGInventoryBeUsedComponent.bCanLeanWhenUse = 0x161 // bool (Size: 0x1)
SGInventoryBeUsedComponent.bCanBeUsedOnProne = 0x162 // bool (Size: 0x1)
SGInventoryBeUsedComponent.bCanBeUsedDirectly = 0x163 // bool (Size: 0x1)
SGInventoryBeUsedComponent.BuildTargetInventoryClass = 0x168 // ClassProperty (Size: 0x8)
SGInventoryBeUsedComponent.bCanMultiPersonUse = 0x170 // bool (Size: 0x1)
SGInventoryBeUsedComponent.MaxUseTimesPerPerson = 0x174 // int32_t (Size: 0x4)
SGInventoryBeUsedComponent.BeUsedRecordMap = 0x178 // TArray<FBeUsedRecord> (Size: 0x10)
SGInventoryBeUsedComponent.UseInBodyPartChangedEvent = 0x188 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryBeUsedGiveComponent.ForbidInteractFactionList = 0x150 // TArray<EEFactionType> (Size: 0x10)
SGInventoryBeUsedGiveComponent.ForbidInteractConfigMsg = 0x160 // FString (Size: 0x10)
SGInventoryBeUsedLootComponent.InteractLimitAxis = 0x150 // EEActorInteractLimitAxis (Size: 0x1)
SGInventoryBeUsedLootComponent.InteractLimitAngle = 0x154 // float (Size: 0x4)
SGInventoryBeUsedLootComponent.InteractLimitDistanceSq = 0x158 // float (Size: 0x4)
SGInventoryBeUsedLootComponent.bIndividualContainer = 0x15c // bool (Size: 0x1)
SGInventoryBeUsedLootComponent.OwnerGID = 0x160 // uint64_t (Size: 0x8)
SGInventoryBeUsedLootComponent.BeUsedHistory = 0x168 // TArray<Actor*> (Size: 0x10)
SGInventoryBeUsedLootComponent.bUsed = 0x178 // bool (Size: 0x1)
SGInventoryBeUsedLootComponent.bIsReadyForLoot = 0x179 // bool (Size: 0x1)
SGInventoryBeUsedLootComponent.ForbidInteractFactionList = 0x180 // TArray<EEFactionType> (Size: 0x10)
SGInventoryBeUsedLootComponent.ForbidInteractConfigMsg = 0x190 // FString (Size: 0x10)
SGInventoryBeUsedLootComponent.bWaitBoxOpenOnLoot = 0x1a0 // bool (Size: 0x1)
SGInventoryBeUsedOpenComponent.InteractLimitAxis = 0x158 // EEActorInteractLimitAxis (Size: 0x1)
SGInventoryBeUsedOpenComponent.bUseInvertAxis = 0x159 // bool (Size: 0x1)
SGInventoryBeUsedOpenComponent.InteractLimitAngle = 0x15c // float (Size: 0x4)
SGInventoryBeUsedOpenComponent.InteractLimitDistanceSq = 0x160 // float (Size: 0x4)
SGInventoryBeUsedOpenComponent.InteractActorConfigID = 0x164 // int32_t (Size: 0x4)
SGInventoryBeUsedOpenComponent.InteractActorGID = 0x168 // int32_t (Size: 0x4)
SGInventoryBeUsedOpenComponent.BeUsedHistory = 0x170 // TArray<Actor*> (Size: 0x10)
SGInventoryBeUsedOpenComponent.bUsed = 0x180 // bool (Size: 0x1)
SGInventoryBeUsedOpenComponent.ForbidInteractFactionList = 0x188 // TArray<EEFactionType> (Size: 0x10)
SGInventoryBeUsedOpenComponent.ForbidInteractConfigMsg = 0x198 // FString (Size: 0x10)
SGInventoryBulletDamageComponent.BaseDamage = 0x100 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BaseSpeed = 0x104 // float (Size: 0x4)
SGInventoryBulletDamageComponent.DragCoefficient = 0x108 // float (Size: 0x4)
SGInventoryBulletDamageComponent.PenetrationFactor = 0x10c // float (Size: 0x4)
SGInventoryBulletDamageComponent.PenetrationFactorScaleByNormalizedFlyDistance = 0x110 // CurveFloat* (Size: 0x8)
SGInventoryBulletDamageComponent.PenetrationLevel = 0x118 // int32_t (Size: 0x4)
SGInventoryBulletDamageComponent.bPenetrationCovers = 0x11c // bool (Size: 0x1)
SGInventoryBulletDamageComponent.BrokenProbability = 0x120 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BrokenDamageScale = 0x124 // float (Size: 0x4)
SGInventoryBulletDamageComponent.ArmorDamage = 0x128 // float (Size: 0x4)
SGInventoryBulletDamageComponent.ShotsInOneBullet = 0x12c // int32_t (Size: 0x4)
SGInventoryBulletDamageComponent.BodyHitThroughDamageFactor = 0x130 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BodyHitThroughProbability = 0x134 // float (Size: 0x4)
SGInventoryBulletDamageComponent.PrimaryHitBones = 0x138 // TArray<FName> (Size: 0x10)
SGInventoryBulletDamageComponent.SecondaryHitBones = 0x148 // TArray<FName> (Size: 0x10)
SGInventoryBulletDamageComponent.MOA = 0x158 // float (Size: 0x4)
SGInventoryBulletDamageComponent.MoaX = 0x15c // float (Size: 0x4)
SGInventoryBulletDamageComponent.MoaY = 0x160 // float (Size: 0x4)
SGInventoryBulletDamageComponent.HorizontalRecoil = 0x164 // float (Size: 0x4)
SGInventoryBulletDamageComponent.VerticalRecoil = 0x168 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BarrierPenetrationFactor = 0x16c // float (Size: 0x4)
SGInventoryBulletDamageComponent.EnergyBreak = 0x170 // float (Size: 0x4)
SGInventoryBulletDamageComponent.ImpactForce = 0x174 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BleedProbabilityForPenetration = 0x178 // float (Size: 0x4)
SGInventoryBulletDamageComponent.BleedProbabilityForBlock = 0x17c // float (Size: 0x4)
SGInventoryBulletDamageComponent.BleedProbabilityForBody = 0x180 // float (Size: 0x4)
SGInventoryBulletDamageComponent.SpecialProjectileClass = 0x188 // ClassProperty (Size: 0x8)
SGInventoryBulletMeshComponent.Mesh = 0x100 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.ShellMesh = 0x128 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.BeltMesh = 0x150 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.BulletHeapMesh = 0x178 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.bBulletTraceForPerShot = 0x1a0 // bool (Size: 0x1)
SGInventoryBulletMeshComponent.BulletTraceTemplate = 0x1a8 // FEffectParticleInfo (Size: 0x50)
SGInventoryBulletMeshComponent.BulletTraceTemplate1P = 0x1f8 // FEffectParticleInfo (Size: 0x50)
SGInventoryBulletMeshComponent.TracerEffectSpeed = 0x248 // float (Size: 0x4)
SGInventoryBulletMeshComponent.TracerEffectLength = 0x24c // float (Size: 0x4)
SGInventoryBulletMeshComponent.bAdsHideBulletLine = 0x250 // bool (Size: 0x1)
SGInventoryBulletMeshComponent.BulletFlyTemplate = 0x258 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.ImpactEffectData = 0x2d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.ImpactAudioData = 0x2f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryBulletMeshComponent.RicochetData = 0x320 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryCameraComponent.SubCameraInfoList = 0x100 // TArray<FSubCameraInfo> (Size: 0x10)
SGInventoryCameraComponent.SubMagnificationInfoList = 0x110 // TArray<FSubCameraInfo> (Size: 0x10)
SGInventoryCameraComponent.SightPriority = 0x120 // int32_t (Size: 0x4)
SGInventoryCameraComponent.bSkipLimitPlane = 0x124 // bool (Size: 0x1)
SGInventoryCameraComponent.bChangeCrossHairWithMagnChange = 0x125 // bool (Size: 0x1)
SGInventoryCameraComponent.bChangeCrossHairWithCameraChange = 0x126 // bool (Size: 0x1)
SGInventoryCameraComponent.bClipFullWeaponWhenZoom = 0x127 // bool (Size: 0x1)
SGInventoryCameraComponent.FireEffectOffset = 0x128 // FVector (Size: 0xc)
SGInventoryCameraComponent.bFollowMainScopeZeroing = 0x134 // bool (Size: 0x1)
SGInventoryCameraComponent.ScopeReticleList = 0x138 // TArray<FCrossHairTexInfo> (Size: 0x10)
SGInventoryCameraComponent.ADSSceneFOV = 0x148 // float (Size: 0x4)
SGInventoryCameraComponent.Magnification = 0x14c // float (Size: 0x4)
SGInventoryCameraComponent.BlurMaterial = 0x150 // MaterialInterface* (Size: 0x8)
SGInventoryCameraComponent.LensDistortMaterial = 0x158 // MaterialInterface* (Size: 0x8)
SGInventoryCameraComponent.ZeroingDistanceList = 0x160 // TArray<float> (Size: 0x10)
SGInventoryCameraComponent.ZeroingIndexBase = 0x170 // int32_t (Size: 0x4)
SGInventoryCameraComponent.ZeroingIndexBiases = 0x178 // TArray<int32_t> (Size: 0x10)
SGInventoryCameraComponent.ScopeReticleTexture = 0x198 // Texture* (Size: 0x8)
SGInventoryCameraComponent.ScopeReticleScale = 0x1a0 // float (Size: 0x4)
SGInventoryCameraComponent.ScopeMaterialIndex = 0x1a4 // int32_t (Size: 0x4)
SGInventoryCameraComponent.CurrentCameraNum = 0x1a8 // int32_t (Size: 0x4)
SGInventoryCameraComponent.CurrentMagnification = 0x1ac // int32_t (Size: 0x4)
SGInventoryCameraComponent.CurrentPattern = 0x1b0 // int32_t (Size: 0x4)
SGInventoryCameraComponent.ScopeLevel = 0x1b4 // int32_t (Size: 0x4)
SGInventoryCameraComponent.ZoomingSensitivity = 0x1b8 // float (Size: 0x4)
SGInventoryCameraComponent.ShoulderZoomingSensitivity = 0x1bc // float (Size: 0x4)
SGInventoryCameraComponent.BlurRadius = 0x1c0 // float (Size: 0x4)
SGInventoryCameraComponent.BlurThresHold = 0x1c4 // float (Size: 0x4)
SGInventoryCameraComponent.FiringZoomInVector = 0x1c8 // FVector (Size: 0xc)
SGInventoryCameraComponent.NormalFireSensitivity = 0x1d4 // float (Size: 0x4)
SGInventoryCameraComponent.FiringAnimTranslationWeight = 0x1d8 // float (Size: 0x4)
SGInventoryCameraComponent.FiringAnimRotationWeight = 0x1dc // float (Size: 0x4)
SGInventoryCameraComponent.ADSGunKickWeight = 0x1e0 // float (Size: 0x4)
SGInventoryCameraComponent.AimingBase = 0x1e4 // FName (Size: 0x8)
SGInventoryCameraComponent.AimingPivotSocket = 0x1ec // FName (Size: 0x8)
SGInventoryCameraComponent.AimingDOF = 0x1f4 // FName (Size: 0x8)
SGInventoryCameraComponent.AimingBaseOffset = 0x1fc // FVector (Size: 0xc)
SGInventoryCameraComponent.SwitchAnim = 0x208 // EEAdapterAnimationType (Size: 0x1)
SGInventoryCameraComponent.FoldAnim = 0x209 // EEAdapterAnimationType (Size: 0x1)
SGInventoryCameraComponent.SwitchMagnificationAnim = 0x210 // AnimSequenceBase* (Size: 0x8)
SGInventoryCameraComponent.bIsFold = 0x218 // bool (Size: 0x1)
SGInventoryCameraComponent.CameraPreparationTime = 0x21c // float (Size: 0x4)
SGInventoryCameraComponent.CrossHairMtrlIndex = 0x220 // int32_t (Size: 0x4)
SGInventoryCameraComponent.CrossHairTextures = 0x228 // TArray<FCrossHairTexInfo> (Size: 0x10)
SGInventoryCameraComponent.CrossHairTexturesWithCamera = 0x238 // TArray<FCrossHairTexInfo> (Size: 0x10)
SGInventoryCameraComponent.ZoomFOV = 0x250 // float (Size: 0x4)
SGInventoryCameraComponent.HoldingBreathZoomFOV = 0x254 // float (Size: 0x4)
SGInventoryCameraComponent.DefaultCameraGunKickWeight = 0x258 // float (Size: 0x4)
SGInventoryCameraComponent.ThermalImagerParams = 0x25c // FSGThermalImagerParams (Size: 0x14)
SGInventoryCameraComponent.bIsThermalScope = 0x270 // bool (Size: 0x1)
SGInventoryCameraComponent.bShouldForceRebaseOrigin = 0x271 // bool (Size: 0x1)
SGInventoryCameraComponent.SwitchBackSubCameraTime = 0x274 // float (Size: 0x4)
SGInventoryCameraComponent.SuspendThermalScopeTags = 0x278 // FGameplayTagContainer (Size: 0x20)
SGInventoryCameraComponent.SuspendThermalScopeTimeInProneTransition = 0x298 // float (Size: 0x4)
SGInventoryCameraComponent.bUsingScopeSceneCapture = 0x2f8 // bool (Size: 0x1)
SGInventoryCameraComponent.ScopeRangeForTeammateIcon = 0x2fc // FScopeRangeForTeammateIcon (Size: 0x2c)
SGInventoryCameraComponent.DisplayName = 0x328 // FText (Size: 0x18)
SGInventoryChildConfig.InventoryClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryChildConfig.Percent = 0x28 // float (Size: 0x4)
SGInventoryChildConfigsTableRow.Percent = 0x8 // float (Size: 0x4)
SGInventoryChildConfigsTableRow.ConfigType = 0xc // EESGInventoryChildConfigOperation (Size: 0x1)
SGInventoryChildConfigsTableRow.ChildConfigs = 0x10 // TArray<FSGInventoryChildConfig> (Size: 0x10)
SGInventoryCollectionComponent.StaticMeshTemplate_Shelf = 0x100 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryCollectionComponent.CollectionOnShelfTransform = 0x130 // FTransform (Size: 0x30)
SGInventoryCollectionComponent.ConstructStaticMeshComponent = 0x160 // StaticMeshComponent* (Size: 0x8)
SGInventoryCollectionComponent.MeshComponent = 0x178 // MeshComponent* (Size: 0x8)
SGInventoryCollectionComponent.CollectionMesh = 0x180 // MeshComponent* (Size: 0x8)
SGInventoryCommonDataComponent.MaxTotalCount = 0x100 // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.TotalCount = 0x104 // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.FireNoiseResistance = 0x108 // float (Size: 0x4)
SGInventoryCommonDataComponent.StandardPrice = 0x10c // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.Rarity = 0x110 // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.RollUpTime = 0x114 // float (Size: 0x4)
SGInventoryCommonDataComponent.Durability = 0x118 // float (Size: 0x4)
SGInventoryCommonDataComponent.DurabilityMax = 0x11c // float (Size: 0x4)
SGInventoryCommonDataComponent.RecoveryItemDurabilityCostStrategyBreakPoint = 0x120 // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.FSBreakList = 0x12c // int32_t (Size: 0x4)
SGInventoryCommonDataComponent.DefaultMaxDurability = 0x130 // uint32_t (Size: 0x4)
SGInventoryCommonDataComponent.SellPrice = 0x134 // uint32_t (Size: 0x4)
SGInventoryCommonDataComponent.MoistureCostRatio = 0x138 // float (Size: 0x4)
SGInventoryCommonDataComponent.FoodCostRatio = 0x13c // float (Size: 0x4)
SGInventoryCommonDataComponent.DisplayName = 0x140 // FText (Size: 0x18)
SGInventoryCommonDataComponent.Description = 0x158 // FText (Size: 0x18)
SGInventoryCommonDataComponent.SimpleDisplayName = 0x170 // FText (Size: 0x18)
SGInventoryCommonDataComponent.IconNormal = 0x188 // Object* (Size: 0x8)
SGInventoryCommonDataComponent.IconKill = 0x190 // Object* (Size: 0x8)
SGInventoryCommonDataComponent.IconRotate = 0x198 // Object* (Size: 0x8)
SGInventoryCommonDataComponent.IconSmall = 0x1a0 // Object* (Size: 0x8)
SGInventoryCommonDataComponent.IconWhite = 0x1a8 // Object* (Size: 0x8)
SGInventoryCommonDataComponent.AssembleRTTexture = 0x1b0 // TextureRenderTarget2D* (Size: 0x8)
SGInventoryCommonDataComponent.AssembleRTMaterial = 0x1b8 // MaterialInstanceDynamic* (Size: 0x8)
SGInventoryCommonDataComponent.MeshSizeToRTSizeScale = 0x1c0 // float (Size: 0x4)
SGInventoryCommonDataComponent.IconResourcePath = 0x1c8 // FString (Size: 0x10)
SGInventoryCommonDataComponent.bCaptutred = 0x1d8 // bool (Size: 0x1)
SGInventoryCommonDataComponent.Weight = 0x1dc // float (Size: 0x4)
SGInventoryCommonDataComponent.PickupSound = 0x1e0 // FString (Size: 0x10)
SGInventoryCommonDataComponent.UseSound = 0x1f0 // FString (Size: 0x10)
SGInventoryCommonDataComponent.DropSound = 0x200 // FString (Size: 0x10)
SGInventoryCommonDataComponent.DropOnGroundSound = 0x210 // FString (Size: 0x10)
SGInventoryCommonDataComponent.bIsTacticalInventory = 0x221 // bool (Size: 0x1)
SGInventoryCommonDataComponent.CheckResourceTimerHandler = 0x228 // FTimerHandle (Size: 0x8)
SGInventoryCommonDataComponent.RTLoadDistance = 0x230 // float (Size: 0x4)
SGInventoryCommonDataComponent.ActivitySignIDs = 0x240 // TArray<int32_t> (Size: 0x10)
SGInventoryCommonDataComponent.InventoryTags = 0x250 // TArray<FSGInventoryTag> (Size: 0x10)
SGInventoryContainerBaseComponent.RowNum = 0x100 // int32_t (Size: 0x4)
SGInventoryContainerBaseComponent.ColumnNum = 0x104 // int32_t (Size: 0x4)
SGInventoryContainerBaseComponent.RuleID = 0x108 // int32_t (Size: 0x4)
SGInventoryContainerBaseComponent.GridList = 0x110 // TArray<FSGBagGridInfo> (Size: 0x10)
SGInventoryContainerBaseComponent.PreOccupiedActorInfoMap = 0x120 // TArray<FGridPreOccupiedInfo> (Size: 0x10)
SGInventoryContainerBaseComponent.ContainerIndex = 0x130 // int32_t (Size: 0x4)
SGInventoryContainerBaseComponent.ChildActorList = 0x138 // TArray<Actor*> (Size: 0x10)
SGInventoryContainerChildComponent.DefaultChildInventories = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGInventoryContainerInteractPerformanceComponent.InteractCharacter = 0x100 // SGCharacter* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.MeshComponentIndex = 0x108 // int32_t (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.bUseAnim = 0x10c // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.bUseAdditionalAnim = 0x10d // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.AdditionalMeshIndex = 0x110 // int32_t (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.AdditionalTargetMesh = 0x118 // MeshComponent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AdditionalTranslateOffset = 0x120 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.AdditionalPivotRelativeLocation = 0x12c // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.bEndSearchAutoClose = 0x138 // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.TargetMesh = 0x140 // MeshComponent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.bUseRotateAnim = 0x148 // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.DummyPivotOffset = 0x14c // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.RotateAxis = 0x158 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.RotateAngle = 0x164 // float (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.RotateDuration = 0x168 // float (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.RotateAnimProgress = 0x16c // float (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.RotateAnimState = 0x170 // EEContainerIteractAnimState (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.DummyPivotRelativeLocation = 0x174 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.DummyPivotOriginRelativeRotation = 0x180 // FRotator (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.bUseTranslateAnim = 0x18c // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.TranslateOffset = 0x190 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.TranslateDuration = 0x19c // float (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.TranslateProgress = 0x1a0 // float (Size: 0x4)
SGInventoryContainerInteractPerformanceComponent.TranslateAnimState = 0x1a4 // EEContainerIteractAnimState (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.IsBySearch = 0x1a5 // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.PivotOriginRelativeLocation = 0x1a8 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.PivotRelativeLocation = 0x1b4 // FVector (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.PivotOriginRelativeRotation = 0x1c0 // FRotator (Size: 0xc)
SGInventoryContainerInteractPerformanceComponent.InteractingCharacters = 0x1d0 // TArray<SGCharacter*> (Size: 0x10)
SGInventoryContainerInteractPerformanceComponent.bInitialized = 0x1e0 // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.bForceRecalc = 0x1e1 // bool (Size: 0x1)
SGInventoryContainerInteractPerformanceComponent.OnInteractPerformanceStateChanged = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryContainerInteractPerformanceComponent.OnSearchingRoleCountChanged = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryContainerInteractPerformanceComponent.LastSearchingCharacter = 0x208 // SGCharacter* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnClosed = 0x220 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnOpening = 0x228 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnOpened = 0x230 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnClosing = 0x238 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnSearching = 0x240 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnEndSearching = 0x248 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnClosed_3P = 0x250 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnOpening_3P = 0x258 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnOpened_3P = 0x260 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnClosing_3P = 0x268 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnSearching_3P = 0x270 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.AkAudioEventOnEndSearching_3P = 0x278 // AkAudioEvent* (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.CachePlayingID = 0x280 // int64_t (Size: 0x8)
SGInventoryContainerInteractPerformanceComponent.InteractDisplayNameText = 0x288 // FText (Size: 0x18)
SGInventoryContainerMgrComponent.PreOccupiedActorInfoMapList = 0x120 // TArray<FInventoryContainerBase_PreOccupiedActorInfoMap> (Size: 0x10)
SGInventoryContainerMgrComponent.InventoryContainerBaseExtraRowNumList = 0x130 // TArray<int32_t> (Size: 0x10)
SGInventoryContainerMgrComponent.InventoryContainerBaseList = 0x140 // TArray<FInventoryContainerBase> (Size: 0x10)
SGInventoryContainerMgrComponent.IsRolledUp = 0x150 // bool (Size: 0x1)
SGInventoryContainerSearchingComponent.SearchingCharacterList = 0x100 // TArray<SGCharacter*> (Size: 0x10)
SGInventoryContainerSearchingComponent.RoughSearchedFinishedCharacterList = 0x118 // TArray<int64_t> (Size: 0x10)
SGInventoryContainerSearchingComponent.RoughSearchedFinishedActorList = 0x128 // TArray<Actor*> (Size: 0x10)
SGInventoryContainerSearchingComponent.IsLootOpenStartSearching = 0x138 // bool (Size: 0x1)
SGInventoryContainerSearchingComponent.OnSearchingRoleListChanged = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryContainerSearchingComponent.bCanCloseAfterSearching = 0x150 // bool (Size: 0x1)
SGInventoryCueMonitor_GameplayTag.Added = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_GameplayTag.Removed = 0x88 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_HD.OwnerCue = 0x68 // SGInventoryCue_HD* (Size: 0x8)
SGInventoryCueMonitor_Montage.Started = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_Montage.BlendingOut = 0x88 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_Montage.Completed = 0x98 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_Montage.Interrupted = 0xa8 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_Montage.MontagesToMonitor = 0xb8 // TArray<AnimMontage*> (Size: 0x10)
SGInventoryCueMonitor_WeaponAssemble.Assembled = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_WeaponAssemble.Disassembled = 0x88 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_WeaponAssemble.AdapterSkinChanged = 0x98 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_WeaponFire.OnFire = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCueMonitor_WeaponHeat.OnHeatChanged = 0x78 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryCue_HD.Inventory = 0x318 // SGInventory* (Size: 0x8)
SGInventoryCue_HD.Weapon = 0x320 // SGWeapon* (Size: 0x8)
SGInventoryCue_HD.Character = 0x328 // SGCharacter* (Size: 0x8)
SGInventoryCue_HD.bActive = 0x330 // bool (Size: 0x1)
SGInventoryCue_HD.GameplayTasksComponent = 0x338 // GameplayTasksComponent* (Size: 0x8)
SGInventoryCue_HD.NiagaraComponents = 0x360 // TArray<NiagaraComponent*> (Size: 0x10)
SGInventoryCustomShowComponent.AfterPlacedLoopSoundEvent = 0x100 // AkAudioEvent* (Size: 0x8)
SGInventoryCustomShowComponent.DurabilityUsedUpSoundEvent = 0x108 // AkAudioEvent* (Size: 0x8)
SGInventoryCustomShowComponent.RemainingDurabilityMesh = 0x110 // StaticMesh* (Size: 0x8)
SGInventoryCustomShowComponent.EmptyDurabilityMesh = 0x118 // StaticMesh* (Size: 0x8)
SGInventoryCustomShowComponent.TargetMaterialIndex = 0x120 // int32_t (Size: 0x4)
SGInventoryCustomShowComponent.RemainingDurabilityMaterial = 0x128 // MaterialInterface* (Size: 0x8)
SGInventoryCustomShowComponent.EmptyDurabilityMaterial = 0x130 // MaterialInterface* (Size: 0x8)
SGInventoryDBNOComponent.RescueTimeScale = 0x100 // float (Size: 0x4)
SGInventoryDataAsset.StaticMesh = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryDataAsset.bCanPickup = 0x58 // bool (Size: 0x1)
SGInventoryDataAsset.PickupTrans = 0x5c // FVector (Size: 0xc)
SGInventoryDataAsset.PickupRot = 0x68 // FRotator (Size: 0xc)
SGInventoryDataAsset.LDMaxDrawDistance = 0x74 // float (Size: 0x4)
SGInventoryDataAsset.Transform = 0x80 // FTransform (Size: 0x30)
SGInventoryDataAsset.PickUpMaterialColor = 0xb0 // FLinearColor (Size: 0x10)
SGInventoryDataAsset.FresnelColorName = 0xc0 // FName (Size: 0x8)
SGInventoryDataAsset.UserActor = 0xc8 // Actor* (Size: 0x8)
SGInventoryDataAsset.UseInBodyPart = 0xd0 // EECharacterEnduranceType (Size: 0x1)
SGInventoryDataAsset.CharacterUsingAnim = 0xd8 // AnimMontage* (Size: 0x8)
SGInventoryDataAsset.CharacterUnUsingAnim = 0xe0 // AnimMontage* (Size: 0x8)
SGInventoryDataAsset.bInitFromDataTable = 0xe8 // bool (Size: 0x1)
SGInventoryDataAsset.MaxTotalCount = 0xec // int32_t (Size: 0x4)
SGInventoryDataAsset.TotalCount = 0xf0 // int32_t (Size: 0x4)
SGInventoryDataAsset.StandardPrice = 0xf4 // int32_t (Size: 0x4)
SGInventoryDataAsset.RollUpTime = 0xf8 // float (Size: 0x4)
SGInventoryDataAsset.Durability = 0xfc // float (Size: 0x4)
SGInventoryDataAsset.DurabilityMax = 0x100 // float (Size: 0x4)
SGInventoryDataAsset.MoistureCostRatio = 0x104 // float (Size: 0x4)
SGInventoryDataAsset.FoodCostRatio = 0x108 // float (Size: 0x4)
SGInventoryDataAsset.DisplayName = 0x110 // FString (Size: 0x10)
SGInventoryDataAsset.Description = 0x120 // FString (Size: 0x10)
SGInventoryDataAsset.SimpleDisplayName = 0x130 // FString (Size: 0x10)
SGInventoryDataAsset.Weight = 0x140 // float (Size: 0x4)
SGInventoryDataAsset.JumpZVelocityScale = 0x144 // float (Size: 0x4)
SGInventoryDataAsset.PickupSound = 0x148 // FString (Size: 0x10)
SGInventoryDataAsset.UseSound = 0x158 // FString (Size: 0x10)
SGInventoryDataAsset.DropSound = 0x168 // FString (Size: 0x10)
SGInventoryDataAsset.InventoryType = 0x178 // EESGInventoryType (Size: 0x1)
SGInventoryDataAsset.RejectAttachPositions = 0x180 // TArray<uint8_t> (Size: 0x10)
SGInventoryDataAsset.AssignableAttachPosition = 0x1a0 // uint8_t (Size: 0x1)
SGInventoryDataAsset.sortIndex = 0x1a4 // int32_t (Size: 0x4)
SGInventoryDataAsset.AssembleTag = 0x1a8 // FGameplayTag (Size: 0x8)
SGInventoryDataAsset.AssembleForGripTag = 0x1b0 // FGameplayTag (Size: 0x8)
SGInventoryDataAsset.SubAssembleTag = 0x1b8 // FGameplayTag (Size: 0x8)
SGInventoryDataAsset.ConflictClassList = 0x1c0 // TArray<uint32_t> (Size: 0x10)
SGInventoryDataAsset.DisplayContainerIndexOnParent = 0x1d0 // int32_t (Size: 0x4)
SGInventoryDataAsset.ContainerGridInfoOnParent = 0x1d4 // FItemGridInfo (Size: 0x8)
SGInventoryDataAsset.AssembleSupportSocketList = 0x1e0 // TArray<FAssembleSocketInfo> (Size: 0x10)
SGInventoryDataAsset.InventoryWidth = 0x1f0 // int32_t (Size: 0x4)
SGInventoryDataAsset.InventoryHeight = 0x1f4 // int32_t (Size: 0x4)
SGInventoryDataAsset.ScopeAimTransform = 0x200 // FTransform (Size: 0x30)
SGInventoryDataAsset.ScopeAimSocketName = 0x230 // FName (Size: 0x8)
SGInventoryDataAsset.ZeroPointSocketName = 0x238 // FName (Size: 0x8)
SGInventoryDataAsset.SubScopeAimSocketNames = 0x240 // TArray<FName> (Size: 0x10)
SGInventoryDataAsset.SubMagnificationScopeAimSocketNames = 0x250 // TArray<FName> (Size: 0x10)
SGInventoryDataAsset.BoreSocketName = 0x260 // FName (Size: 0x8)
SGInventoryDataAsset.MultiBoreSockets = 0x268 // TArray<FName> (Size: 0x10)
SGInventoryDataAsset.WeaponWtihStockHoldingOffset = 0x278 // FVector (Size: 0xc)
SGInventoryDataAsset.WeaponWtihHandguardOffset_LeftHand = 0x284 // FVector (Size: 0xc)
SGInventoryDataAsset.LFingerAdaptiveAlpha = 0x290 // float (Size: 0x4)
SGInventoryDataAsset.ScopeSize = 0x294 // float (Size: 0x4)
SGInventoryDataAsset.IronSightDiffHeight = 0x298 // float (Size: 0x4)
SGInventoryDataAsset.bUnAssemable = 0x29c // bool (Size: 0x1)
SGInventoryDataAsset.bStockCanBeFolded = 0x29d // bool (Size: 0x1)
SGInventoryDataAsset.ExtraFireRequireTagList = 0x2a0 // FGameplayTagContainer (Size: 0x20)
SGInventoryDataAsset.DeducteFireRequireTag = 0x2c0 // FGameplayTag (Size: 0x8)
SGInventoryDataAsset.BipodHeight = 0x2c8 // float (Size: 0x4)
SGInventoryDataAsset.EnableCustomFOV = 0x2cc // uint8_t (Size: 0x1)
SGInventoryDataAsset.CustomFOV = 0x2d0 // float (Size: 0x4)
SGInventoryDataAsset.ZoomCustomFOV = 0x2d4 // float (Size: 0x4)
SGInventoryDataAsset.CustomFOVBlendSpeed = 0x2d8 // float (Size: 0x4)
SGInventoryDataAsset.bCanEverEnable = 0x2dc // bool (Size: 0x1)
SGInventoryDataAssetComponent.DataAssetArray = 0x100 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGInventoryDataSettings.ConfigFileName = 0x38 // FString (Size: 0x10)
SGInventoryDataSettings.InventoryIdClassList = 0x48 // TArray<FInventoryIdClass> (Size: 0x10)
SGInventoryDataSettings.TempleteClass = 0x58 // TArray<FInventoryTempleteClass> (Size: 0x10)
SGInventoryDataSettings.FactionInventoryIDs = 0x68 // TArray<uint64_t> (Size: 0x10)
SGInventoryDataSettings.SingleGameInventoryIDs = 0x78 // TArray<uint64_t> (Size: 0x10)
SGInventoryDataSettings.InventoryIDClassMap = 0x88 // TMap<...> (Size: 0x50)
SGInventoryDataSettings.InventoryIDTempleteClassMap = 0xd8 // TMap<...> (Size: 0x50)
SGInventoryDataSettings.InventoryClassIDMap = 0x128 // TMap<...> (Size: 0x50)
SGInventoryDebugPhysicsComponent.bEnableDebugPhysics = 0x100 // bool (Size: 0x1)
SGInventoryDebugPhysicsComponent.bForAvatar = 0x101 // bool (Size: 0x1)
SGInventoryDebugPhysicsComponent.DisplayMaterial_NoPhysics = 0x108 // MaterialInterface* (Size: 0x8)
SGInventoryDebugPhysicsComponent.DebugSkeletalMeshComponent = 0x110 // SkeletalMeshComponent* (Size: 0x8)
SGInventoryDetectorComponent.DetectorInfo = 0xf40 // FInventoryDetectorInfo (Size: 0x18)
SGInventoryDetectorComponent.ScreenPSC = 0xf58 // ParticleSystemComponent* (Size: 0x8)
SGInventoryDetectorComponent.SearchedInventories = 0xf60 // TSet<...> (Size: 0x50)
SGInventoryDetectorComponent.PowerConsumption = 0xfb0 // float (Size: 0x4)
SGInventoryDetectorComponent.DetectInterval = 0xfb4 // float (Size: 0x4)
SGInventoryDetectorComponent.ChangeTargetInterval = 0xfb8 // float (Size: 0x4)
SGInventoryDetectorComponent.detectrange = 0xfbc // float (Size: 0x4)
SGInventoryDetectorComponent.MarkDetectedRange = 0xfc0 // float (Size: 0x4)
SGInventoryDetectorComponent.ForwardAngle = 0xfc4 // float (Size: 0x4)
SGInventoryDetectorComponent.BackAngle = 0xfc8 // float (Size: 0x4)
SGInventoryDetectorComponent.ForwardAlpha = 0xfcc // float (Size: 0x4)
SGInventoryDetectorComponent.SideAlpha = 0xfd0 // float (Size: 0x4)
SGInventoryDetectorComponent.BackAlpha = 0xfd4 // float (Size: 0x4)
SGInventoryDetectorComponent.DistanceCurve = 0xfd8 // CurveFloat* (Size: 0x8)
SGInventoryDetectorComponent.InventoryTypeToDetect = 0xfe0 // TArray<EESGInventoryType> (Size: 0x10)
SGInventoryDetectorComponent.LootPointIDToDetect = 0xff0 // TArray<int32_t> (Size: 0x10)
SGInventoryDetectorComponent.DetectionValueDistribution = 0x1000 // TArray<float> (Size: 0x10)
SGInventoryDetectorComponent.ScreenParticleAsset = 0x1010 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryDetectorComponent.ScreenParticleSocket = 0x1038 // FName (Size: 0x8)
SGInventoryDetectorComponent.ScreenParticleTransform = 0x1040 // FTransform (Size: 0x30)
SGInventoryDogTagComponent.DogTagInfo = 0x100 // FInventoryDogTagInfo (Size: 0x68)
SGInventoryDropComponent.MomentumScale = 0x108 // float (Size: 0x4)
SGInventoryDropComponent.CollisionAvoidExtention = 0x10c // float (Size: 0x4)
SGInventoryDropComponent.StartPositionOffset = 0x110 // FVector (Size: 0xc)
SGInventoryDropComponent.FallbackTransform = 0x120 // FTransform (Size: 0x30)
SGInventoryDropComponent.ClientFallbackTransform = 0x150 // FTransform (Size: 0x30)
SGInventoryDropComponent.DropTransformInfo = 0x180 // FDropTransformInfo (Size: 0x50)
SGInventoryDurabilityComponent.Durability = 0x100 // float (Size: 0x4)
SGInventoryDurabilityComponent.DurabilityMax = 0x104 // float (Size: 0x4)
SGInventoryDurabilityComponent.MoistureCostRatio = 0x10c // float (Size: 0x4)
SGInventoryDurabilityComponent.FoodCostRatio = 0x110 // float (Size: 0x4)
SGInventoryEquipMeshComponent.CacheOwner = 0x100 // SGCharacter* (Size: 0x8)
SGInventoryEquipMeshComponent.WearableMesh = 0x108 // FWearableMesh (Size: 0x458)
SGInventoryEquipMeshComponent.SGKawaiiPhysicsParams = 0x560 // FSGKawaiiPhysicsParam (Size: 0x20)
SGInventoryEquipMeshComponent.SGKawaiiPhysicsParams_Game = 0x580 // FSGKawaiiPhysicsParam (Size: 0x20)
SGInventoryEquipMeshComponent.RetargetOptionsInLobby = 0x5a0 // FSGAvatarAnimRetargetData (Size: 0x98)
SGInventoryEquipMeshComponent.AdditionalWearableInventories = 0x638 // TArray<ClassProperty> (Size: 0x10)
SGInventoryEquipMeshComponent.AdditionalWearableAvatar = 0x648 // TArray<int64_t> (Size: 0x10)
SGInventoryEquipMeshComponent.LayerIndex = 0x658 // int32_t (Size: 0x4)
SGInventoryEquipMeshComponent.bIsAdapter = 0x65c // bool (Size: 0x1)
SGInventoryEquipMeshComponent.bCanPlayAnimation = 0x65d // bool (Size: 0x1)
SGInventoryEquipMeshComponent.AnimPoseInfo = 0x660 // FInventoryAnimPoseInfo (Size: 0x18)
SGInventoryEquipMeshComponent.MeshEffectComponents = 0x690 // TArray<NiagaraComponent*> (Size: 0x10)
SGInventoryEquipMeshComponent.ItemLevel = 0x6a0 // int32_t (Size: 0x4)
SGInventoryEquipMeshComponent.TranslucencySortPriority = 0x6a4 // int32_t (Size: 0x4)
SGInventoryEquipMeshComponent.BoneModifyInfoList = 0x6a8 // TArray<FBoneModifyInfo> (Size: 0x10)
SGInventoryEquipMeshComponent.ForceUseLobbyMesh = 0x6b8 // bool (Size: 0x1)
SGInventoryEquipMeshComponent.HideBackPistol = 0x6b9 // bool (Size: 0x1)
SGInventoryEquipMeshComponent.BadgeAttachOffset = 0x6bc // FVector (Size: 0xc)
SGInventoryEquipMeshComponent.CachedLoadedSkeletalMeshCompList = 0x6f0 // TArray<SkeletalMeshComponent*> (Size: 0x10)
SGInventoryEquipMeshComponent.SavedAttachParent = 0x700 // SceneComponent* (Size: 0x8)
SGInventoryEquipMeshComponent.SavedAttachSocketName = 0x708 // FName (Size: 0x8)
SGInventoryEquipMeshComponent.MeshPolicy = 0x710 // EECharacterMeshPolicy (Size: 0x1)
SGInventoryEquipMeshComponent.EquipMeshComponentList = 0x718 // TArray<MeshComponent*> (Size: 0x10)
SGInventoryEquipMeshComponent.CachedInventory = 0x728 // SGInventory* (Size: 0x8)
SGInventoryEquipMeshComponent.SkinID = 0x744 // int32_t (Size: 0x4)
SGInventoryEquipMeshComponent.EquipmentSkinInfo = 0x748 // FEquipmentSkinInfo (Size: 0xd0)
SGInventoryEquipMeshComponent.PendingProcessMaterails = 0x838 // TArray<MaterialInterface*> (Size: 0x10)
SGInventoryEquipMeshComponent.bDefaultPutOnOrTakeOffState = 0x848 // bool (Size: 0x1)
SGInventoryEvents.VisableChanged = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.ParentActorChanged = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.PosChanged = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.PosChangedForLootSubsystem = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OwnerChanged = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.InventoryAddedEvent = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.InventoryRemovedEvent = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.InventoryCountChangeEvent = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.AttachPositionChanged = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.GameplayDefinedVisableChanged = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.AntiHackProtectionChanged = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnTacticalInvSwitchRefreshed = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnInventorySearched = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnPlayerCarriedThermalDeviceEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnInventoryPickStateChanged = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnContainerInteractStateChanged = 0x120 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnInventoryBeginPlay = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.OnInventoryUpdateDropPosition = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryEvents.InventortDropComplete = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryFastThrowComponent.FastThrowPreFireTime = 0x108 // float (Size: 0x4)
SGInventoryFastThrowComponent.bIsSwitchOnFastThrow = 0x10c // bool (Size: 0x1)
SGInventoryFlashComponent.CachedWeapon = 0x118 // SGWeapon* (Size: 0x8)
SGInventoryFlashComponent.FlashParticleSystemTemplate = 0x120 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryFlashComponent.Flash1PParticleSystemTemplate = 0x148 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryFlashComponent.ParticleAlpha1PCurve = 0x170 // CurveFloat* (Size: 0x8)
SGInventoryFlashComponent.FlashNearDimFor1P = 0x178 // float (Size: 0x4)
SGInventoryFlashComponent.FlashNearDimFor3P = 0x17c // float (Size: 0x4)
SGInventoryFlashComponent.FlashFarDimFor1P = 0x180 // float (Size: 0x4)
SGInventoryFlashComponent.FlashFarDimFor3P = 0x184 // float (Size: 0x4)
SGInventoryFlashComponent.FlashDistanceFor1P = 0x188 // float (Size: 0x4)
SGInventoryFlashComponent.FlashDistanceFor3P = 0x18c // float (Size: 0x4)
SGInventoryFlashComponent.FlashColor = 0x190 // FColor (Size: 0x4)
SGInventoryFlashComponent.LensFlareAngleScale = 0x194 // float (Size: 0x4)
SGInventoryFlashComponent.SpotLightIntensityScale = 0x198 // float (Size: 0x4)
SGInventoryFlashComponent.LensFlareIntensityScale = 0x19c // float (Size: 0x4)
SGInventoryFlashComponent.FlashTraceCollisionChannel = 0x1a0 // uint8_t (Size: 0x1)
SGInventoryFlashComponent.FlareBlockTestRadius = 0x1a4 // float (Size: 0x4)
SGInventoryFlashComponent.FlashTraceStartOffset = 0x1a8 // float (Size: 0x4)
SGInventoryFlashComponent.FlareAngleCurve = 0x1b0 // CurveFloat* (Size: 0x8)
SGInventoryFlashComponent.FlareScreenAngleCurve = 0x1b8 // CurveFloat* (Size: 0x8)
SGInventoryFlashComponent.FlareLengthCurve = 0x1c0 // CurveFloat* (Size: 0x8)
SGInventoryFlashComponent.FlareLengthSizeCurve = 0x1c8 // CurveFloat* (Size: 0x8)
SGInventoryFlashComponent.FlashParticleSystem = 0x1d0 // ParticleSystemComponent* (Size: 0x8)
SGInventoryFlashComponent.Flash1PParticleSystem = 0x1d8 // ParticleSystemComponent* (Size: 0x8)
SGInventoryFlashComponent.bAlwaysUseSimpleMeshEffectSocket = 0x1e0 // bool (Size: 0x1)
SGInventoryFlashComponent.SimpleMeshEffectSocketOffset = 0x1e4 // float (Size: 0x4)
SGInventoryFlashComponent.FlashSocketName = 0x1e8 // FName (Size: 0x8)
SGInventoryFlashComponent.FlashLightClass = 0x1f0 // ClassProperty (Size: 0x8)
SGInventoryFlashComponent.LensFlareClass = 0x1f8 // ClassProperty (Size: 0x8)
SGInventoryFlashComponent.MildDebuffDistance = 0x200 // float (Size: 0x4)
SGInventoryFlashComponent.ModerateDebuffDistance = 0x204 // float (Size: 0x4)
SGInventoryFlashComponent.SevereDebuffDistance = 0x208 // float (Size: 0x4)
SGInventoryFlashComponent.FlashZoneAngle = 0x20c // float (Size: 0x4)
SGInventoryFlashComponent.MinFlashAngle = 0x210 // float (Size: 0x4)
SGInventoryFlashComponent.FlashLight = 0x228 // Actor* (Size: 0x8)
SGInventoryFlashComponent.LensFlare = 0x230 // Actor* (Size: 0x8)
SGInventoryFlashComponent.CachedNearGrassBounds = 0x268 // FAINearGrassBounds (Size: 0x20)
SGInventoryFlashlightComponent_HD.LightInfos = 0x118 // TArray<FFlashlightInfo_HD> (Size: 0x10)
SGInventoryFlashlightComponent_HD.LightShaftClass = 0x128 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryFlashlightComponent_HD.LightShaftActor = 0x160 // Actor* (Size: 0x8)
SGInventoryFlashlightComponent_HD.LightConeHalfAngleForAI = 0x180 // float (Size: 0x4)
SGInventoryFlashlightComponent_HD.LightRangeForAI = 0x184 // float (Size: 0x4)
SGInventoryFulton.bActivated = 0x8a0 // bool (Size: 0x1)
SGInventoryFulton.ConfigID = 0x8a4 // int32_t (Size: 0x4)
SGInventoryFulton.LootInvList = 0x8a8 // TArray<SGInventory*> (Size: 0x10)
SGInventoryFulton.SpawnedPCList = 0x8b8 // TArray<PlayerController*> (Size: 0x10)
SGInventoryFulton.CachedOccupiedTeam = 0x8c8 // SGTeamInfo* (Size: 0x8)
SGInventoryFulton.LootInventoryClass = 0x8d0 // ClassProperty (Size: 0x8)
SGInventoryGiveComponent.IsCanPickup = 0x108 // bool (Size: 0x1)
SGInventoryGiveComponent.AttachSocketName = 0x10c // FName (Size: 0x8)
SGInventoryGridComponent.InventoryGridInfo = 0x110 // FInventoryGridInfo (Size: 0x48)
SGInventoryGridComponent.OldInventoryGridInfo = 0x158 // FInventoryGridInfo (Size: 0x48)
SGInventoryGridComponent.LockInfo = 0x1c0 // FInventoryLockInfo (Size: 0x18)
SGInventoryGridComponent.IsRotated = 0x1d8 // bool (Size: 0x1)
SGInventoryGridComponent.IsPlayerInteracting = 0x1d9 // bool (Size: 0x1)
SGInventoryHearingAidComponent.IgnoreSoundIndicatorType = 0x110 // TSet<...> (Size: 0x50)
SGInventoryHelmetSwitchComponent.bPendingActivationToggle = 0x140 // bool (Size: 0x1)
SGInventoryHelmetSwitchComponent.CurrentEnabledHeadwearType = 0x14c // EESGMainHeadwearType (Size: 0x1)
SGInventoryHostedInteractComp.CurForcedInteractInfo = 0x108 // FInventoryForcedInteractInfo (Size: 0x20)
SGInventoryHostedInteractComp.HostedInteractConfigID = 0x12c // int32_t (Size: 0x4)
SGInventoryHostedInteractComp.HostedInteractActorGID = 0x130 // int32_t (Size: 0x4)
SGInventoryHostedInteractComp.ForcedInteractAngle = 0x134 // float (Size: 0x4)
SGInventoryHostedInteractComp.ForcedInteractDistance = 0x138 // float (Size: 0x4)
SGInventoryHostedInteractComp.OnForcedInteractInfoChange = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryHostedInteractComp.InteractTransfromComp = 0x150 // StaticMeshComponent* (Size: 0x8)
SGInventoryHostedInteractComp.CacheHostedInteractAnimConfTableRow = 0x158 // FFHostedInteractAnimConfTableRow (Size: 0x110)
SGInventoryLaserComponent.CachedWeapon = 0x118 // SGWeapon* (Size: 0x8)
SGInventoryLaserComponent.LaserTraceStartOffset = 0x124 // float (Size: 0x4)
SGInventoryLaserComponent.LaserTraceCollisionChannel = 0x128 // uint8_t (Size: 0x1)
SGInventoryLaserComponent.LaserTraceDualFovBlendRange = 0x12c // FVector2D (Size: 0x8)
SGInventoryLaserComponent.LaserBeamParticleSystemTemplate = 0x138 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.LaserBeamParticleSystemTemplate_3P = 0x160 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.LaserBeamParticleSystemTemplate_Lobby = 0x188 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.SecLaserBeamParticleSystemTemplate_Lobby = 0x1b0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.LaserBeamMaxDistance = 0x1d8 // float (Size: 0x4)
SGInventoryLaserComponent.bCameraBasedZeroingWhenHipFire = 0x1dc // bool (Size: 0x1)
SGInventoryLaserComponent.BeamSocketName = 0x1e0 // FName (Size: 0x8)
SGInventoryLaserComponent.BeamColor = 0x1e8 // FLinearColor (Size: 0x10)
SGInventoryLaserComponent.bSecLaserActive = 0x1f8 // bool (Size: 0x1)
SGInventoryLaserComponent.SecondBeamSocketName = 0x1fc // FName (Size: 0x8)
SGInventoryLaserComponent.SecondBeamColor = 0x204 // FLinearColor (Size: 0x10)
SGInventoryLaserComponent.LaserDotParticleSystemTemplate = 0x218 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.LaserDotParticleSystemTemplate_Lobby = 0x240 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryLaserComponent.bAlwaysShowLaserDot = 0x268 // bool (Size: 0x1)
SGInventoryLaserComponent.ScaleWithDistanceCurve = 0x270 // CurveFloat* (Size: 0x8)
SGInventoryLaserComponent.DotColor = 0x278 // FLinearColor (Size: 0x10)
SGInventoryLaserComponent.SecDotColor = 0x288 // FLinearColor (Size: 0x10)
SGInventoryLaserComponent.LaserBeamParticleSystem = 0x298 // FXSystemComponent* (Size: 0x8)
SGInventoryLaserComponent.LaserDotParticleSystem = 0x2a0 // FXSystemComponent* (Size: 0x8)
SGInventoryLaserComponent.SecLaserBeamParticleSystem = 0x2a8 // FXSystemComponent* (Size: 0x8)
SGInventoryLaserComponent.SecLaserDotParticleSystem = 0x2b0 // FXSystemComponent* (Size: 0x8)
SGInventoryMeshComponent.SkeletalMeshTemplate = 0x108 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_InGame = 0x130 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_InGame3P = 0x158 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_InGame2 = 0x180 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_InLobby = 0x1a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.StaticMeshTemplate_InGame = 0x1d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.StaticMeshTemplate_InLobby = 0x1f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.StaticMeshTemplate_Rollup = 0x220 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_OverrideInGame = 0x248 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshTemplate_OverrideInLobby = 0x270 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SimpleMeshTemplate = 0x298 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SimpleMeshDefaultAnimInstance = 0x2c0 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.ProjectileMeshTemplate = 0x2e8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.InnerScopeBlurMaterial = 0x310 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.bScopeBlurMatDistortionEnabled = 0x338 // bool (Size: 0x1)
SGInventoryMeshComponent.LensDistortionImageScale = 0x33c // float (Size: 0x4)
SGInventoryMeshComponent.ThermalScopeUnlitMaterial = 0x340 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.ScopeMaterialElementIndex = 0x368 // int32_t (Size: 0x4)
SGInventoryMeshComponent.ThermalViewOpaqueMaterialElementIndex = 0x36c // int32_t (Size: 0x4)
SGInventoryMeshComponent.StaticMeshTemplate = 0x370 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.MeshTickPolicy = 0x398 // EEMeshTickPolicy (Size: 0x1)
SGInventoryMeshComponent.bEnableMeshOptimization = 0x399 // bool (Size: 0x1)
SGInventoryMeshComponent.bAdsLod0 = 0x39a // bool (Size: 0x1)
SGInventoryMeshComponent.LootInventoryMeshTrans = 0x39c // FVector (Size: 0xc)
SGInventoryMeshComponent.LootInventoryMeshRot = 0x3a8 // FRotator (Size: 0xc)
SGInventoryMeshComponent.PickupTrans = 0x3b4 // FVector (Size: 0xc)
SGInventoryMeshComponent.PickupRot = 0x3c0 // FRotator (Size: 0xc)
SGInventoryMeshComponent.bForceUseLobby = 0x3cc // bool (Size: 0x1)
SGInventoryMeshComponent.PickupCullDistance = 0x3d0 // float (Size: 0x4)
SGInventoryMeshComponent.CrosshairExposureData = 0x3d8 // SGDataAsset_Crosshair* (Size: 0x8)
SGInventoryMeshComponent.WeaponTraceOffset = 0x3e0 // FVector (Size: 0xc)
SGInventoryMeshComponent.FaceShieldTemplate = 0x3f0 // MaterialInterface* (Size: 0x8)
SGInventoryMeshComponent.MaterialInstanceDynamicArray = 0x3f8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGInventoryMeshComponent.PickUpMaterialColor = 0x408 // FLinearColor (Size: 0x10)
SGInventoryMeshComponent.FresnelColorName = 0x418 // FName (Size: 0x8)
SGInventoryMeshComponent.PhysicsStopCheckCount = 0x420 // int32_t (Size: 0x4)
SGInventoryMeshComponent.PhysicsStopCheckRate = 0x424 // float (Size: 0x4)
SGInventoryMeshComponent.PhysicsStopCheckDelay = 0x428 // float (Size: 0x4)
SGInventoryMeshComponent.CheckTolerance = 0x42c // float (Size: 0x4)
SGInventoryMeshComponent.LocationTolerance = 0x430 // float (Size: 0x4)
SGInventoryMeshComponent.MaxSimulateDistanceSquared = 0x434 // float (Size: 0x4)
SGInventoryMeshComponent.MaxSimulateTime = 0x448 // float (Size: 0x4)
SGInventoryMeshComponent.ThrowAngularVelocity = 0x44c // FVector (Size: 0xc)
SGInventoryMeshComponent.ServerBakedTransform = 0x460 // FTransform (Size: 0x30)
SGInventoryMeshComponent.CheckPhysicsStopHandle = 0x490 // FTimerHandle (Size: 0x8)
SGInventoryMeshComponent.PhysicsTimeoutHandle = 0x498 // FTimerHandle (Size: 0x8)
SGInventoryMeshComponent.CustomIndex = 0x4c0 // int8_t (Size: 0x1)
SGInventoryMeshComponent.MeshSkinIndex = 0x4c4 // int32_t (Size: 0x4)
SGInventoryMeshComponent.OnAfterRecalcPickupAndHiddenState = 0x4c8 // FMulticastInlineDelegate (Size: 0x10)
SGInventoryMeshComponent.LowResolutionThreshold = 0x4d8 // float (Size: 0x4)
SGInventoryMeshComponent.AdditionalUVOffset = 0x4dc // FVector2D (Size: 0x8)
SGInventoryMeshComponent.bEnableFadeFor1xScope = 0x4e4 // bool (Size: 0x1)
SGInventoryMeshComponent.bPickup = 0x4f1 // bool (Size: 0x1)
SGInventoryMeshComponent.bMeshHiddenInServer = 0x4f2 // bool (Size: 0x1)
SGInventoryMeshComponent.bMeshVisible = 0x4f3 // bool (Size: 0x1)
SGInventoryMeshComponent.bMeshTraceable = 0x4f4 // bool (Size: 0x1)
SGInventoryMeshComponent.DropTransform = 0x520 // FTransform (Size: 0x30)
SGInventoryMeshComponent.MeshComponent = 0x550 // MeshComponent* (Size: 0x8)
SGInventoryMeshComponent.ConstructSkeletalMeshComponent = 0x558 // SkeletalMeshComponent* (Size: 0x8)
SGInventoryMeshComponent.ConstructStaticMeshComponent = 0x560 // StaticMeshComponent* (Size: 0x8)
SGInventoryMeshComponent.MeshComponent_Outline = 0x568 // MeshComponent* (Size: 0x8)
SGInventoryMeshComponent.ConstructSkeletalMeshComponent_Outline = 0x570 // SkeletalMeshComponent* (Size: 0x8)
SGInventoryMeshComponent.ConstructStaticMeshComponent_Outline = 0x578 // StaticMeshComponent* (Size: 0x8)
SGInventoryMeshComponent.PlayerController = 0x580 // SGPlayerController* (Size: 0x8)
SGInventoryMeshComponent.bWithZoomMatiral = 0x588 // bool (Size: 0x1)
SGInventoryMeshComponent.TurnOnZoomMatiralThreshold = 0x58c // float (Size: 0x4)
SGInventoryMeshComponent.bTurnOnZoomMaterialSwitchingScope = 0x590 // bool (Size: 0x1)
SGInventoryMeshComponent.SceneCaptureSocketName = 0x594 // FName (Size: 0x8)
SGInventoryMeshComponent.EyePieceScreenRatio = 0x59c // float (Size: 0x4)
SGInventoryMeshComponent.PostProcessScopeMaterialTemplate = 0x5a0 // MaterialInterface* (Size: 0x8)
SGInventoryMeshComponent.PostProcessScopeMaterialInstance = 0x5a8 // MaterialInstanceDynamic* (Size: 0x8)
SGInventoryMeshComponent.ScopeFadeCurve = 0x5b8 // CurveLinearColor* (Size: 0x8)
SGInventoryMeshComponent.EyePieceSocketName = 0x5c0 // FName (Size: 0x8)
SGInventoryMeshComponent.EyePieceEdgeSocketName = 0x5c8 // FName (Size: 0x8)
SGInventoryMeshComponent.ReticleDepthSocketName = 0x5d0 // FName (Size: 0x8)
SGInventoryMeshComponent.bDisableRestOffset = 0x5ec // bool (Size: 0x1)
SGInventoryMeshComponent.ScopeReticleTexture = 0x5f0 // Texture* (Size: 0x8)
SGInventoryMeshComponent.CustomScale = 0x5f8 // float (Size: 0x4)
SGInventoryMeshComponent.LocalScopeParam = 0x5fc // FVector (Size: 0xc)
SGInventoryMeshComponent.ScopeRadius = 0x608 // float (Size: 0x4)
SGInventoryMeshComponent.ReticleDepth = 0x60c // float (Size: 0x4)
SGInventoryMeshComponent.ReticleDepthToSceneCaptureDepthOffset = 0x610 // float (Size: 0x4)
SGInventoryMeshComponent.ClipParameters = 0x614 // FVector (Size: 0xc)
SGInventoryMeshComponent.EllipseCenterUV = 0x620 // FVector2D (Size: 0x8)
SGInventoryMeshComponent.ColorParam = 0x628 // FLinearColor (Size: 0x10)
SGInventoryMeshComponent.CrosshairOnThreshold = 0x638 // float (Size: 0x4)
SGInventoryMeshComponent.ThermalViewInstanceEnabledName = 0x63c // FName (Size: 0x8)
SGInventoryMeshComponent.ThermalScopeOpaqueOverrideName = 0x644 // FName (Size: 0x8)
SGInventoryMeshComponent.OnlyClipScopeMtrlSightList = 0x650 // TArray<int64_t> (Size: 0x10)
SGInventoryMeshComponent.NotClipWithScopeMtrl = 0x660 // bool (Size: 0x1)
SGInventoryMeshComponent.CachedZoomParam = 0x678 // FScopeZoomParamOnMaterials (Size: 0x20)
SGInventoryMeshComponent.CachedParentActor = 0x698 // Actor* (Size: 0x8)
SGInventoryMeshComponent.CachedAttachPosition = 0x6a0 // EEAttachPosition (Size: 0x1)
SGInventoryMeshComponent.CachedOwnerCharacter = 0x6a8 // Character* (Size: 0x8)
SGInventoryMeshComponent.BackupScopeMI = 0x6b0 // MaterialInstanceDynamic* (Size: 0x8)
SGInventoryMeshComponent.InnerScopeBlurMI = 0x6b8 // MaterialInstanceDynamic* (Size: 0x8)
SGInventoryMeshComponent.SavedAnimInstanceClass = 0x6c0 // ClassProperty (Size: 0x8)
SGInventoryMeshComponent.CheckWeaponFullyLoadTimerHandle = 0x6c8 // FTimerHandle (Size: 0x8)
SGInventoryMeshComponent.HiddenFlag = 0x708 // uint64_t (Size: 0x8)
SGInventoryMeshComponent.SkeletalMeshAnimClass = 0x710 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.bAlwaysEnableAnimationUpdateInGame = 0x738 // bool (Size: 0x1)
SGInventoryMeshComponent.bAlwaysEnableAnimationUpdateInLobby = 0x739 // bool (Size: 0x1)
SGInventoryMeshComponent.SkeletalMeshAnimClassInLobby = 0x740 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.SkeletalMeshAnimClassOverride = 0x768 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.bRemarkableAppearance = 0x792 // bool (Size: 0x1)
SGInventoryMeshComponent.bIgnoreInWeaponMerging = 0x793 // bool (Size: 0x1)
SGInventoryMeshComponent.SkinID = 0x798 // int32_t (Size: 0x4)
SGInventoryMeshComponent.ItemSkinInfo = 0x7a0 // FItemSkinInfo (Size: 0x138)
SGInventoryMeshComponent.PendingProcessMaterails = 0x8f8 // TArray<MaterialInterface*> (Size: 0x10)
SGInventoryMeshComponent.ZoomClipParentMaterial = 0x908 // TMap<...> (Size: 0x50)
SGInventoryMeshComponent.bIsUsingDynamicZoomClipMaterials = 0x958 // bool (Size: 0x1)
SGInventoryMeshComponent.OriginMaterials = 0x960 // TArray<MaterialInterface*> (Size: 0x10)
SGInventoryMeshComponent.ZoomClipMaterials = 0x970 // TArray<MaterialInterface*> (Size: 0x10)
SGInventoryMeshComponent.AttachExtraMeshTasks = 0x980 // TArray<SGTask_AttachExtraMesh*> (Size: 0x10)
SGInventoryMeshComponent.LootOutlineMaterial = 0x990 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.LootOutlineCulldistance = 0x9b8 // float (Size: 0x4)
SGInventoryMeshComponent.bRenderCustomDepth = 0x9d0 // bool (Size: 0x1)
SGInventoryMeshComponent.CustomDepthStencilValue_Aiming = 0x9d4 // int32_t (Size: 0x4)
SGInventoryMeshComponent.CustomDepthStencilValue_Default = 0x9d8 // int32_t (Size: 0x4)
SGInventoryMeshComponent.CueClass = 0xa28 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventoryMeshComponent.CueInstance = 0xa50 // SGInventoryCue_HD* (Size: 0x8)
SGInventoryModifyAttributeComponent.bEnableErgonomicsModify = 0x100 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.ErgonomicsValue = 0x104 // int32_t (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableRecoilModify = 0x108 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.VerticalRecoilValue_Multiplier = 0x10c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.HorizentalRecoilValue_Multiplier = 0x110 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableSpreadModify = 0x114 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.AccuracyValue_Multiplier = 0x118 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoaScaleX_Multiplier = 0x11c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoaScaleY_Multiplier = 0x120 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoaFinalScale_Multiplier = 0x124 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableFireInitSpeedModify = 0x128 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.FireInitSpeedScale = 0x12c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FireInitSpeed_Adder = 0x130 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.BulletZeroDropDistance = 0x134 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.AdapterAdjustDamage = 0x138 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableChangeClipSpeedModify = 0x13c // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.bEnableSwitchToADSTimeModify = 0x13d // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.SwitchToADSTimeScale = 0x140 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.WeaponEquipTimeTimeModify = 0x144 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.WeaponEquipTimeScale = 0x148 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableShoulderZoomSpreadShrinkModify = 0x14c // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.ShoulderZoomSpreadShrinkSpeedScale = 0x150 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableHoldBreathEnergyCostModify = 0x154 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.HoldBreathEnergyCostScale = 0x158 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FPMergeFireHDRTemplate = 0x160 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.FPMergeFireLDRTemplate = 0x1b0 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.TPMergeFireHDRTemplate = 0x200 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.TPMergeFireLDRTemplate = 0x250 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.bEnableFlameModify = 0x2a0 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.Flame1PTemplate = 0x2a8 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.Flame3PTemplate = 0x2f8 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.bEnableFogModify = 0x348 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.FogTemplate = 0x350 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.bEnableFireLightModify = 0x3a0 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.FireLightTemplate = 0x3a8 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.IntensityOfFireLight = 0x3f8 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FireLightSize = 0x3fc // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FireLightTemplate_LDR = 0x400 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.IntensityColorOfFireLight_LDR = 0x450 // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.FireLightSize_LDR = 0x45c // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.FireLightTemplate3P = 0x468 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.IntensityOfFireLight3P = 0x4b8 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FireLightSize3P = 0x4bc // float (Size: 0x4)
SGInventoryModifyAttributeComponent.FireLightTemplate3P_LDR = 0x4c0 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.IntensityColorOfFireLight3P_LDR = 0x510 // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.FireLightSize3P_LDR = 0x51c // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.CompositeFireTemplate = 0x528 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.CompositeFireLightSize = 0x578 // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.CompositeFireLightColor = 0x584 // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.CompositeFireTemplate3P = 0x590 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.CompositeFireLightSize3P = 0x5e0 // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.CompositeFireLightColor3P = 0x5ec // FVector (Size: 0xc)
SGInventoryModifyAttributeComponent.bEnableSmokeTrailModify = 0x5f8 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.SmokeTrailTemplates = 0x600 // FEffectParticleInfo (Size: 0x50)
SGInventoryModifyAttributeComponent.bEnableBarrelSmokeModify = 0x650 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.BarrelSmokeTemplates = 0x658 // TArray<FEffectParticleInfo> (Size: 0x10)
SGInventoryModifyAttributeComponent.FirstShootProbability = 0x668 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.ContinuousShootProbability = 0x66c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bEnableSoundModify = 0x670 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.SuppressorRTPCValue = 0x674 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.bOnlyModifyWhenSwitchOn = 0x678 // bool (Size: 0x1)
SGInventoryModifyAttributeComponent.RaceStrategy = 0x67c // int32_t (Size: 0x4)
SGInventoryModifyAttributeComponent.ReloadSpeedRatio_Multiplier = 0x688 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.ADSMoveSpeedRatio_Multiplier = 0x68c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoveSpeedRatio_Multiplier = 0x690 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoveSpeedRatio_Walk_Multiplier = 0x694 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoveSpeedRatio_Sprint_Multiplier = 0x698 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.MoveSpeedRatio_SlientWalk_Multiplier = 0x69c // float (Size: 0x4)
SGInventoryModifyAttributeComponent.SprintToIdleConefficient = 0x6a0 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.LeanRatio_Multiplier = 0x6a4 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.AccuracyPunishRatio_Multiplier = 0x6a8 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.CheckMagSpeedRatio_Multiplier = 0x6ac // float (Size: 0x4)
SGInventoryModifyAttributeComponent.EnergyCostPerFire_FromAdapter = 0x6b0 // float (Size: 0x4)
SGInventoryModifyAttributeComponent.CachedWeapon = 0x7a0 // SGInventory* (Size: 0x8)
SGInventoryModifyFireRecoilComponent.VerticalRecoilScale = 0x100 // float (Size: 0x4)
SGInventoryModifyFireRecoilComponent.HorizentalRecoilScale = 0x104 // float (Size: 0x4)
SGInventoryModifyFireSpreadComponent.SpreadScale = 0x100 // float (Size: 0x4)
SGInventoryMonitorVolume.InVolumeInvArr = 0x310 // TArray<Actor*> (Size: 0x10)
SGInventoryMonitorVolume.BoxComp = 0x320 // BoxComponent* (Size: 0x8)
SGInventoryMovableArmorComponent.bSpecialUseCaseForBallisticShield = 0x100 // bool (Size: 0x1)
SGInventoryMovableArmorComponent.Destructibility = 0x104 // float (Size: 0x4)
SGInventoryMovableArmorComponent.AmmoDestructibilityOverrideMap = 0x108 // TMap<...> (Size: 0x50)
SGInventoryMovableArmorComponent.ProjectileDestructibilityOverrideMap = 0x158 // TMap<...> (Size: 0x50)
SGInventoryMovableArmorComponent.MinimumDurabilityLossValue = 0x1a8 // float (Size: 0x4)
SGInventoryMovableArmorComponent.bExistsAfterCompletelyDamaged = 0x1ac // bool (Size: 0x1)
SGInventoryMovableArmorComponent.ResiduaryKineticEnergyCurve = 0x1b0 // CurveFloat* (Size: 0x8)
SGInventoryMovableArmorComponent.HitDecalStaticMesh = 0x1b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.HitDecalMaterial = 0x1e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.HitSound = 0x208 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.CompletelyDamagedSound = 0x230 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.CompletelyDamagedMesh = 0x258 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.CompletelyDamagedParticle = 0x280 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryMovableArmorComponent.bIsInstalled = 0x2a8 // bool (Size: 0x1)
SGInventoryMovableArmorComponent.bIsEnabled = 0x2a9 // bool (Size: 0x1)
SGInventoryMovableArmorComponent.CachedWeapon = 0x2b0 // SGInventory* (Size: 0x8)
SGInventoryMovableArmorComponent.CachedParentActor = 0x2b8 // Actor* (Size: 0x8)
SGInventoryMovableArmorComponent.CachedAttachParentSocketName = 0x2c0 // FName (Size: 0x8)
SGInventoryMovableArmorComponent.BulletScaleMap = 0x2d0 // TMap<...> (Size: 0x50)
SGInventoryMovableArmorComponent.HitDecal = 0x320 // SGPooledImpactEffect* (Size: 0x8)
SGInventoryMovableArmorComponent.HitDecalStaticMeshPtr = 0x328 // StaticMesh* (Size: 0x8)
SGInventoryMovableArmorComponent.HitDecalMaterialPtr = 0x330 // MaterialInterface* (Size: 0x8)
SGInventoryMovableArmorComponent.HitSoundPtr = 0x338 // AkAudioEvent* (Size: 0x8)
SGInventoryMovableArmorComponent.CompletelyDamagedSoundPtr = 0x340 // AkAudioEvent* (Size: 0x8)
SGInventoryMovableArmorComponent.CompletelyDamagedMeshPtr = 0x348 // SkeletalMesh* (Size: 0x8)
SGInventoryMovableArmorComponent.CompletelyDamagedParticlePtr = 0x350 // ParticleSystem* (Size: 0x8)
SGInventoryNameComponent.InventoryName = 0x100 // FName (Size: 0x8)
SGInventoryPickupMeshComponent.StaticMesh = 0x108 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryPickupMeshComponent.StaticMeshComponent = 0x130 // StaticMeshComponent* (Size: 0x8)
SGInventoryPickupMeshComponent.bCanPickup = 0x139 // bool (Size: 0x1)
SGInventoryPickupMeshComponent.PickupTrans = 0x13c // FVector (Size: 0xc)
SGInventoryPickupMeshComponent.PickupRot = 0x148 // FRotator (Size: 0xc)
SGInventoryPickupMeshComponent.DropTransform = 0x160 // FTransform (Size: 0x30)
SGInventoryPickupMeshComponent.MaterialInstanceDynamicArray = 0x190 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGInventoryPickupMeshComponent.PickUpMaterialColor = 0x1a0 // FLinearColor (Size: 0x10)
SGInventoryPickupMeshComponent.FresnelColorName = 0x1b0 // FName (Size: 0x8)
SGInventoryPickupMeshComponent.CachedParentActor = 0x1b8 // Actor* (Size: 0x8)
SGInventoryPickupMeshComponent.CachedOwnerCharacter = 0x1c0 // Character* (Size: 0x8)
SGInventoryPickupMeshComponent.LDMaxDrawDistance = 0x1c8 // float (Size: 0x4)
SGInventoryPickupMeshComponent.Transform = 0x1d0 // FTransform (Size: 0x30)
SGInventoryPriorityComponent.Priority = 0x100 // int32_t (Size: 0x4)
SGInventoryScopeSceneCaptureComponent.ShowAssembleTags = 0xa70 // TArray<FGameplayTag> (Size: 0x10)
SGInventoryScopeSceneCaptureComponent.DuplicatedInventoryMeshMap = 0xab0 // TMap<...> (Size: 0x50)
SGInventorySearchComponent.SearchFinishedCharacterList = 0x108 // TArray<uint64_t> (Size: 0x10)
SGInventorySearchComponent.IsSearched_LocalClient = 0x118 // bool (Size: 0x1)
SGInventorySearchComponent.IsInSearching_LocalClient = 0x119 // bool (Size: 0x1)
SGInventorySearchComponent.WaitGIDTimerHandle = 0x120 // FTimerHandle (Size: 0x8)
SGInventorySearchComponent.UnsearchedParentInventoryList = 0x128 // TArray<SGInventory*> (Size: 0x10)
SGInventorySearchComponent.UnsearchedChildrenInventoryList = 0x138 // TArray<SGInventory*> (Size: 0x10)
SGInventorySearchComponent.LastMovedTimestamp = 0x148 // int64_t (Size: 0x8)
SGInventorySoundComponent.PickupSound = 0x100 // FString (Size: 0x10)
SGInventorySoundComponent.UseSound = 0x110 // FString (Size: 0x10)
SGInventorySoundComponent.DropSound = 0x120 // FString (Size: 0x10)
SGInventorySourceTypeComponent.OldOwnerCharacterType = 0x108 // EECharacterType (Size: 0x1)
SGInventorySourceTypeComponent.OldCharaterGuid = 0x110 // uint64_t (Size: 0x8)
SGInventorySourceTypeComponent.OldCharaterOpenId = 0x118 // uint64_t (Size: 0x8)
SGInventorySourceTypeComponent.SourceType = 0x120 // EESGPickupSourceType (Size: 0x1)
SGInventorySourceTypeComponent.SpawnSourceType = 0x121 // EESGInventorySpawnSourceType (Size: 0x1)
SGInventorySourceTypeComponent.FromLootPoint = 0x128 // Actor* (Size: 0x8)
SGInventorySourceTypeComponent.FromLootSubAreaVolume = 0x130 // SGLootSubAreaVolume* (Size: 0x8)
SGInventorySourceTypeComponent.FromLootPointID = 0x138 // int32_t (Size: 0x4)
SGInventorySourceTypeComponent.FromLootPointType = 0x13c // int32_t (Size: 0x4)
SGInventorySourceTypeComponent.FromLootLoosePointInfo = 0x140 // FLoosePointInfo (Size: 0x18)
SGInventorySourceTypeComponent.WeaponAssembleId = 0x158 // int64_t (Size: 0x8)
SGInventorySourceTypeComponent.FromCharacterType = 0x160 // EECharacterType (Size: 0x1)
SGInventorySourceTypeComponent.FromPlayerGID = 0x168 // uint64_t (Size: 0x8)
SGInventorySourceTypeComponent.FromTeamIndex = 0x170 // int32_t (Size: 0x4)
SGInventorySourceTypeComponent.CanNotSellItem = 0x174 // bool (Size: 0x1)
SGInventorySourceTypeComponent.LastCharacterOwnerInfo = 0x178 // FLastCharacterOwnerInfo (Size: 0x10)
SGInventorySourceTypeComponent.LootLimitPoolID = 0x188 // int32_t (Size: 0x4)
SGInventorySourceTypeComponent.StackableItemSourceInfos = 0x190 // TArray<FStackableItemSourceInfo> (Size: 0x10)
SGInventorySpritesComponent.IconNormal = 0x100 // Object* (Size: 0x8)
SGInventorySpritesComponent.IconKill = 0x108 // Object* (Size: 0x8)
SGInventorySpritesComponent.IconRotate = 0x110 // Object* (Size: 0x8)
SGInventorySpritesComponent.IconSmall = 0x118 // Object* (Size: 0x8)
SGInventorySpritesComponent.IconWhite = 0x120 // Object* (Size: 0x8)
SGInventorySpritesComponent.AssembleRTTexture = 0x128 // TextureRenderTarget2D* (Size: 0x8)
SGInventorySpritesComponent.AssembleRTMaterial = 0x130 // MaterialInstanceDynamic* (Size: 0x8)
SGInventorySpritesComponent.MeshSizeToRTSizeScale = 0x138 // float (Size: 0x4)
SGInventorySpritesComponent.IconResourcePath = 0x140 // FString (Size: 0x10)
SGInventorySpritesComponent.bCaptutred = 0x150 // bool (Size: 0x1)
SGInventorySubsystem.BulletClassPreLoadMap = 0x30 // TMap<...> (Size: 0x50)
SGInventorySubsystem.WeaponClassPreLoadMap = 0x80 // TMap<...> (Size: 0x50)
SGInventorySubsystem.WeaponAccessoryClassPreLoadMap = 0xd0 // TMap<...> (Size: 0x50)
SGInventorySubsystem.ClothPreLoadMap = 0x120 // TMap<...> (Size: 0x50)
SGInventorySubsystem.ItemPreLoadMap = 0x170 // TMap<...> (Size: 0x50)
SGInventorySubsystem.OnWeaponSkinStainDataLoaded = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
SGInventorySwitchComponent.ManagedTags = 0x108 // TArray<FGameplayTag> (Size: 0x10)
SGInventorySwitchComponent.TacticalInvStateInfos = 0x118 // TArray<FTacticalInvStateInfo> (Size: 0x10)
SGInventorySwitchComponent.CachedCharacterOwner = 0x128 // Character* (Size: 0x8)
SGInventoryTacticComponent.TacticTag = 0x100 // FGameplayTag (Size: 0x8)
SGInventoryTacticComponent.bSwitchStateOn = 0x108 // bool (Size: 0x1)
SGInventoryTacticComponent.bActive = 0x109 // bool (Size: 0x1)
SGInventoryTacticComponent.SwitcherInventory = 0x110 // SGInventory* (Size: 0x8)
SGInventoryTag.TagName = 0x0 // FName (Size: 0x8)
SGInventoryTag.EffectiveRelation = 0x8 // EESGInventoryTagEffectiveRelation (Size: 0x1)
SGInventoryTag.DisplayRelation = 0x9 // EESGInventoryTagEffectiveRelation (Size: 0x1)
SGInventoryTag.OpenSpecialInventoryDetail = 0xa // bool (Size: 0x1)
SGInventoryTag.SpecialInventoryDetail = 0x10 // FSpecialInventoryConfig (Size: 0x40)
SGInventoryTag.Functions = 0x50 // TArray<EESGInventoryTagFunction> (Size: 0x10)
SGInventoryTag.TakeOutReplaceToItemID = 0x60 // int64_t (Size: 0x8)
SGInventoryTag.TakeOutReplaceToItemNum = 0x68 // int64_t (Size: 0x8)
SGInventoryTagRow.TagName = 0x0 // FName (Size: 0x8)
SGInventoryTagRow.HitSourceType = 0x8 // TArray<EESGInventorySpawnSourceType> (Size: 0x10)
SGInventoryTagRow.HitInventoryIDOrType = 0x18 // TArray<int64_t> (Size: 0x10)
SGInventoryTagRow.HitAttachPosition = 0x28 // TArray<EEAttachPosition> (Size: 0x10)
SGInventoryTagRow.HitFaction = 0x38 // TArray<EEFactionType> (Size: 0x10)
SGInventoryTagRow.EffectiveRelation = 0x48 // EESGInventoryTagEffectiveRelation (Size: 0x1)
SGInventoryTagRow.DisplayRelation = 0x49 // EESGInventoryTagEffectiveRelation (Size: 0x1)
SGInventoryTagRow.OpenSpecialInventoryDetail = 0x4a // bool (Size: 0x1)
SGInventoryTagRow.SpecialInventoryDetail = 0x50 // FSGSpecialInventoryDetail (Size: 0x58)
SGInventoryTagRow.Functions = 0xa8 // TArray<EESGInventoryTagFunction> (Size: 0x10)
SGInventoryTagRow.TakeOutReplaceToItemID = 0xb8 // int64_t (Size: 0x8)
SGInventoryTagRow.TakeOutReplaceToItemNum = 0xc0 // int64_t (Size: 0x8)
SGInventoryTagTable.InventoryTags = 0x10 // TArray<FSGInventoryTagRow> (Size: 0x10)
SGInventoryTakeOutTag.TagName = 0x0 // FName (Size: 0x8)
SGInventoryTakeOutTag.IsRelative = 0x8 // bool (Size: 0x1)
SGInventoryTakeOutTag.TagFunction = 0x9 // EESGInventoryTagFunction (Size: 0x1)
SGInventoryTakeOutTag.TakeOutReplaceToItemID = 0x10 // int64_t (Size: 0x8)
SGInventoryTakeOutTag.TakeOutReplaceToItemNum = 0x18 // int64_t (Size: 0x8)
SGInventoryTextsComponent.DisplayName = 0x100 // FText (Size: 0x18)
SGInventoryTextsComponent.Description = 0x118 // FText (Size: 0x18)
SGInventoryTextsComponent.SimpleDisplayName = 0x130 // FText (Size: 0x18)
SGInventoryThermalHeadwearComponent.ThermalImagerParams = 0x158 // FSGThermalImagerParams (Size: 0x14)
SGInventoryToggleableHeadwearComponent.PutUpMontagePtr = 0x128 // TSoftObjectPtr<UObject> (Size: 0x28)
SGInventoryToggleableHeadwearComponent.HeadwearType = 0x150 // EESGMainHeadwearType (Size: 0x1)
SGInventoryTypeComponent.InventoryType = 0x100 // EESGInventoryType (Size: 0x1)
SGInventoryTypeComponent.RejectAttachPositions = 0x108 // TArray<uint8_t> (Size: 0x10)
SGInventoryTypeComponent.AssignableAttachPosition = 0x128 // uint8_t (Size: 0x1)
SGInventoryTypeComponent.sortIndex = 0x12c // int32_t (Size: 0x4)
SGInventoryTypeComponent_Adapter.WeaponAdapterType = 0x130 // FSGWeaponAdapterInfo (Size: 0x20)
SGInventoryTypeComponent_Ammo.CaliberType = 0x130 // ClassProperty (Size: 0x8)
SGInventoryTypeComponent_Armor.ArmorType = 0x130 // EESGArmorType (Size: 0x1)
SGInventoryTypeComponent_Avatar.AvatarType = 0x130 // EESGAvatarType (Size: 0x1)
SGInventoryTypeComponent_Avatar.AvatarData = 0x138 // FSGAvatarData (Size: 0x20)
SGInventoryTypeComponent_Badge.AttachPos = 0x100 // EESGBadgeAttach (Size: 0x1)
SGInventoryTypeComponent_Badge.AttachInventory = 0x108 // SGInventory* (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.DeadCharacterType = 0x130 // EECharacterType (Size: 0x1)
SGInventoryTypeComponent_CorpseContainer.DeadCharacterGID = 0x138 // uint64_t (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.DeadCharacterTeamID = 0x140 // int32_t (Size: 0x4)
SGInventoryTypeComponent_CorpseContainer.KillerCharacterGID = 0x148 // int64_t (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.KillerCharacterType = 0x150 // EECharacterType (Size: 0x1)
SGInventoryTypeComponent_CorpseContainer.CachedDeadCharacterInfo = 0x158 // FCachedDeadCharacterInfo (Size: 0x90)
SGInventoryTypeComponent_CorpseContainer.IsDropReplaced = 0x1e8 // bool (Size: 0x1)
SGInventoryTypeComponent_CorpseContainer.UnLockInfo = 0x1f0 // FLootContainerUnLockInfo (Size: 0x30)
SGInventoryTypeComponent_CorpseContainer.bIsRewardBox = 0x220 // bool (Size: 0x1)
SGInventoryTypeComponent_CorpseContainer.DeathDropWhiteList = 0x228 // TArray<SGInventory*> (Size: 0x10)
SGInventoryTypeComponent_CorpseContainer.OriginVestBag = 0x238 // SGInventory* (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.OriginBag = 0x240 // SGInventory* (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.OriginBagToReplacedBag = 0x248 // TMap<...> (Size: 0x50)
SGInventoryTypeComponent_CorpseContainer.ReplacedInvToOriginInv = 0x298 // TMap<...> (Size: 0x50)
SGInventoryTypeComponent_CorpseContainer.InvParentMap = 0x2e8 // TMap<...> (Size: 0x50)
SGInventoryTypeComponent_CorpseContainer.ForceInVestContainerInvs = 0x338 // TArray<SGInventory*> (Size: 0x10)
SGInventoryTypeComponent_CorpseContainer.TakeDamageHistoryLength = 0x348 // float (Size: 0x4)
SGInventoryTypeComponent_CorpseContainer.RecentTakeDamageByPlayerHistory = 0x350 // TArray<FTakeDamageRecord> (Size: 0x10)
SGInventoryTypeComponent_CorpseContainer.SpawnDeadBoxDateTime = 0x360 // FDateTime (Size: 0x8)
SGInventoryTypeComponent_CorpseContainer.ForbidInteractProtectTime = 0x368 // int32_t (Size: 0x4)
SGInventoryTypeComponent_CorpseContainer.After_ForbidInteractProtectTime = 0x36c // int32_t (Size: 0x4)
SGInventoryTypeComponent_Item.ItemType = 0x130 // EESGItemType (Size: 0x1)
SGInventoryTypeComponent_Recovery.RecoveryType = 0x130 // EESGRecoveryType (Size: 0x1)
SGInventoryTypeComponent_Recovery.bPassiveItem = 0x131 // bool (Size: 0x1)
SGInventoryTypeComponent_Recovery.bHeadShotToDBNO = 0x132 // bool (Size: 0x1)
SGInventoryWeightComponent.Weight = 0x100 // float (Size: 0x4)
SGInventoryWeightComponent.JumpZVelocityScale = 0x104 // float (Size: 0x4)
SGInventoryZoneInfoComponent.InstId = 0x110 // uint64_t (Size: 0x8)
SGInventoryZoneInfoComponent.TakeInPlayerGID = 0x118 // uint64_t (Size: 0x8)
SGInventoryZoneInfoComponent.InsureType = 0x120 // int32_t (Size: 0x4)
SGInventoryZoneInfoComponent.OldInstID = 0x128 // uint64_t (Size: 0x8)
SGInventoryZoneInfoComponent.OldTakeInPlayerGID = 0x130 // uint64_t (Size: 0x8)
SGInventoryZoneInfoComponent.IsBlackLoot = 0x138 // bool (Size: 0x1)
SGInventoryZoneInfoComponent.IsFaction = 0x139 // bool (Size: 0x1)
SGInventoryZoneInfoComponent.IsSingleOffice = 0x13a // bool (Size: 0x1)
SGInventoryZoneInfoComponent.ExpireTime = 0x13c // int32_t (Size: 0x4)
SGInventoryZoomComponent.bZoomParamsValid = 0x100 // bool (Size: 0x1)
SGInventoryZoomComponent.WeaponZoomTime = 0x104 // float (Size: 0x4)
SGInventoryZoomComponent.WeaponUnZoomTime = 0x108 // float (Size: 0x4)
SGInventoryZoomComponent.WeaponZoomFOVBlendTime = 0x10c // float (Size: 0x4)
SGInventoryZoomComponent.WeaponUnZoomFOVBlendTime = 0x110 // float (Size: 0x4)
SGInventoryZoomComponent.WeaponZoomFOVBlendDelay = 0x114 // float (Size: 0x4)
SGInventoryZoomComponent.WeaponUnZoomFOVBlendDelay = 0x118 // float (Size: 0x4)
SGInventoryZoomComponent.ErgADSTimeScaleCurve = 0x120 // CurveFloat* (Size: 0x8)
SGItemRarityOutlineTableRow.Rarity = 0x8 // int32_t (Size: 0x4)
SGItemRarityOutlineTableRow.OutlineMaterialPath = 0x10 // FSoftObjectPath (Size: 0x18)
SGJSCharacterAnimationSet.CasualGripAdjustmentBS = 0x0 // BlendSpace1D* (Size: 0x8)
SGJSCharacterAnimationSet.CustomAnimations = 0x8 // TMap<...> (Size: 0x50)
SGKawaiiClothAnimInstance.LocalProxy = 0x2c0 // FSGKawaiiClothAnimInstanceProxy (Size: 0xb00)
SGKawaiiClothAnimInstance.AvatarType = 0xdc0 // EESGAvatarType (Size: 0x1)
SGKawaiiClothAnimInstanceProxy.AnimInstance = 0x860 // SGKawaiiClothAnimInstance* (Size: 0x8)
SGKawaiiClothAnimInstanceProxy.bIsDead = 0x868 // bool (Size: 0x1)
SGKawaiiClothAnimInstanceProxy.InsideKawaiiPhysicsSettings = 0x86c // FKawaiiPhysicsSettings (Size: 0x18)
SGKawaiiClothAnimInstanceProxy.InsideStiffnessCurveData = 0x888 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiClothAnimInstanceProxy.InsideLimitAngleCurveData = 0x910 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiClothAnimInstanceProxy.InsideDummyBoneLength = 0x998 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.InsideTeleportDistanceThreShold = 0x99c // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.InsideTeleportRotationThreShold = 0x9a0 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.InsideAlpha = 0x9a4 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.OutsideKawaiiPhysicsSettings = 0x9a8 // FKawaiiPhysicsSettings (Size: 0x18)
SGKawaiiClothAnimInstanceProxy.OutsideStiffnessCurveData = 0x9c0 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiClothAnimInstanceProxy.OutsideLimitAngleCurveData = 0xa48 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiClothAnimInstanceProxy.OutsideDummyBoneLength = 0xad0 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.OutsideTeleportDistanceThreShold = 0xad4 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.OutsideTeleportRotationThreShold = 0xad8 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.OutsideAlpha = 0xadc // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.Gravity = 0xae0 // FVector (Size: 0xc)
SGKawaiiClothAnimInstanceProxy.bEnableWind = 0xaec // bool (Size: 0x1)
SGKawaiiClothAnimInstanceProxy.bAllowWorldCollision = 0xaed // bool (Size: 0x1)
SGKawaiiClothAnimInstanceProxy.ConstraintAlpha = 0xaf0 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.AnimationBlendWeight = 0xaf4 // float (Size: 0x4)
SGKawaiiClothAnimInstanceProxy.bIsFemale = 0xaf8 // bool (Size: 0x1)
SGKawaiiClothAnimInstanceProxy.bEquipBackpack = 0xaf9 // bool (Size: 0x1)
SGKawaiiPhysicsParam.SideParams = 0x0 // TArray<FSGKawaiiPhysicsSideParam> (Size: 0x10)
SGKawaiiPhysicsParam.Gravity = 0x10 // FVector (Size: 0xc)
SGKawaiiPhysicsParam.bEnableWind = 0x1c // bool (Size: 0x1)
SGKawaiiPhysicsParam.bAllowWorldCollision = 0x1d // bool (Size: 0x1)
SGKawaiiPhysicsSideParam.KawaiiPhysicsSettings = 0x0 // FKawaiiPhysicsSettings (Size: 0x18)
SGKawaiiPhysicsSideParam.StiffnessCurveData = 0x18 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiPhysicsSideParam.LimitAngleCurveData = 0xa0 // FRuntimeFloatCurve (Size: 0x88)
SGKawaiiPhysicsSideParam.DummyBoneLength = 0x128 // float (Size: 0x4)
SGKawaiiPhysicsSideParam.TeleportDistanceThreShold = 0x12c // float (Size: 0x4)
SGKawaiiPhysicsSideParam.TeleportRotationThreShold = 0x130 // float (Size: 0x4)
SGKawaiiPhysicsSideParam.Alpha = 0x134 // float (Size: 0x4)
SGKillCamInfo.RecordStartTime = 0x0 // float (Size: 0x4)
SGKillCamInfo.TimeOfDeath = 0x4 // float (Size: 0x4)
SGKillCamInfo.PlaybackStart = 0x8 // float (Size: 0x4)
SGKillCamInfo.PlaybackLength = 0xc // float (Size: 0x4)
SGKillEventInfo.VictimNetworkGUID = 0x0 // uint32_t (Size: 0x4)
SGKillEventInfo.VictimLocation = 0x4 // FVector (Size: 0xc)
SGKillEventInfo.VictimGID = 0x10 // uint64_t (Size: 0x8)
SGKillEventInfo.VictimName = 0x18 // FString (Size: 0x10)
SGKillEventInfo.KillerNetworkGUID = 0x28 // uint32_t (Size: 0x4)
SGKillEventInfo.KillerLocation = 0x2c // FVector (Size: 0xc)
SGKillEventInfo.KillerGID = 0x38 // uint64_t (Size: 0x8)
SGKillEventInfo.KillerName = 0x40 // FString (Size: 0x10)
SGKillEventInfo.bIsDBNODie = 0x50 // bool (Size: 0x1)
SGKillEventInfo.RelevantGUIDsForRep = 0xa8 // TArray<uint32_t> (Size: 0x10)
SGKillEventInfo.StartTimeMS = 0xb8 // uint32_t (Size: 0x4)
SGKillEventInfo.EndTimeMS = 0xbc // uint32_t (Size: 0x4)
SGKillEventInfo.KillerWeaponId = 0xc0 // uint32_t (Size: 0x4)
SGLadderBase.TopEnterRot = 0x310 // FRotator (Size: 0xc)
SGLadderBase.BottomEnterRot = 0x31c // FRotator (Size: 0xc)
SGLadderBase.TopBoxTrigger = 0x328 // BoxComponent* (Size: 0x8)
SGLadderBase.BottomBoxTrigger = 0x330 // BoxComponent* (Size: 0x8)
SGLadderBase.BottomBeginIndex = 0x338 // int32_t (Size: 0x4)
SGLadderBase.Character = 0x340 // SGCharacter* (Size: 0x8)
SGLadderBase.LadderBarLocs = 0x348 // TArray<FVector> (Size: 0x10)
SGLadderBase.LadderBarSyncPoints = 0x358 // TArray<FVector> (Size: 0x10)
SGLadderBase.LadderClimbComponentClass = 0x368 // ClassProperty (Size: 0x8)
SGLadderBase.CharacterClass = 0x370 // ClassProperty (Size: 0x8)
SGLadderBase.BarStartHeight = 0x378 // float (Size: 0x4)
SGLadderBase.BarSpacing = 0x37c // float (Size: 0x4)
SGLadderBase.BarCount = 0x380 // int32_t (Size: 0x4)
SGLadderBase.LegStartHeight = 0x384 // float (Size: 0x4)
SGLadderBase.LegSpacing = 0x388 // float (Size: 0x4)
SGLadderBase.LegCount = 0x38c // int32_t (Size: 0x4)
SGLadderBase.RootComp = 0x390 // SceneComponent* (Size: 0x8)
SGLadderBase.TopMeshComp = 0x398 // StaticMeshComponent* (Size: 0x8)
SGLadderBase.BottomMeshComp = 0x3a0 // StaticMeshComponent* (Size: 0x8)
SGLadderBase.InstancedStaticMeshCompBar = 0x3a8 // InstancedStaticMeshComponent* (Size: 0x8)
SGLadderBase.InstancedStaticMeshCompLeg = 0x3b0 // InstancedStaticMeshComponent* (Size: 0x8)
SGLadderBase.TransitionSyncPointPosComp = 0x3b8 // SphereComponent* (Size: 0x8)
SGLadderBase.TopSyncPointPosComp = 0x3c0 // SphereComponent* (Size: 0x8)
SGLadderBase.BottomSyncPointPosComp = 0x3c8 // SphereComponent* (Size: 0x8)
SGLadderBase.TopSyncPointPos = 0x3d0 // FVector (Size: 0xc)
SGLadderBase.TransitionSyncPointPos = 0x3dc // FVector (Size: 0xc)
SGLadderBase.BottomSyncPointPos = 0x3e8 // FVector (Size: 0xc)
SGLastHitByInfo.HitByGID = 0x0 // uint64_t (Size: 0x8)
SGLastHitByInfo.HitByName = 0x8 // FString (Size: 0x10)
SGLastHitByInfo.HitByNetGUIDForReplay = 0x18 // int32_t (Size: 0x4)
SGLastHitByInfo.HitByPos = 0x1c // FVector (Size: 0xc)
SGLastHitByInfo.HitByTime = 0x28 // FDateTime (Size: 0x8)
SGLifeDetectorComponent.DetectorInfo = 0xf40 // FLifeDetectorInfo (Size: 0x20)
SGLifeDetectorComponent.bCachedDetectButtonClicked = 0xf60 // bool (Size: 0x1)
SGLifeDetectorComponent.ScanAudioEvent = 0xf68 // AkAudioEvent* (Size: 0x8)
SGLifeDetectorComponent.FindTargetAudioEvent = 0xf70 // AkAudioEvent* (Size: 0x8)
SGLifeDetectorComponent.PowerOffAudioEvent = 0xf78 // AkAudioEvent* (Size: 0x8)
SGLifeDetectorComponent.PowerOnAudioEvent = 0xf80 // AkAudioEvent* (Size: 0x8)
SGLifeDetectorComponent.ScreenPSC = 0xf88 // NiagaraComponent* (Size: 0x8)
SGLifeDetectorComponent.ScreenScanResultPSC = 0xf90 // NiagaraComponent* (Size: 0x8)
SGLifeDetectorComponent.ScreenScanPSC = 0xf98 // NiagaraComponent* (Size: 0x8)
SGLifeDetectorComponent.PowerOnOffPSC = 0xfa0 // NiagaraComponent* (Size: 0x8)
SGLifeDetectorComponent.MaterialInstanceDynamicArray = 0xfa8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SGLifeDetectorComponent.CachedStatisComponent = 0xfb8 // SGPlayerStateStatisComponent* (Size: 0x8)
SGLifeDetectorComponent.DetectPMCPlayers = 0xfc0 // TSet<...> (Size: 0x50)
SGLifeDetectorComponent.PowerConsumption = 0x1010 // float (Size: 0x4)
SGLifeDetectorComponent.DetectInterval = 0x1014 // float (Size: 0x4)
SGLifeDetectorComponent.DetectDelay = 0x1018 // float (Size: 0x4)
SGLifeDetectorComponent.PowerOnDelay = 0x101c // float (Size: 0x4)
SGLifeDetectorComponent.PowerOffDelay = 0x1020 // float (Size: 0x4)
SGLifeDetectorComponent.SwitchWeaponDelay = 0x1024 // float (Size: 0x4)
SGLifeDetectorComponent.DetectCoolDown = 0x1028 // float (Size: 0x4)
SGLifeDetectorComponent.detectrange = 0x102c // float (Size: 0x4)
SGLifeDetectorComponent.DetectAngle = 0x1030 // float (Size: 0x4)
SGLifeDetectorComponent.ScreenAngleList = 0x1038 // TArray<int32_t> (Size: 0x10)
SGLifeDetectorComponent.ScreenDistList = 0x1048 // TArray<int32_t> (Size: 0x10)
SGLifeDetectorComponent.AdjustBrightnessNum = 0x1058 // int32_t (Size: 0x4)
SGLifeDetectorComponent.bEnableAnnouncement = 0x105c // bool (Size: 0x1)
SGLifeDetectorComponent.DetectedAnnounceId = 0x1060 // int32_t (Size: 0x4)
SGLifeDetectorComponent.ScanAudioAsset = 0x1068 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.FindTargetAudioAsset = 0x1090 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.PowerOffAudioAsset = 0x10b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.PowerOnAudioAsset = 0x10e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.ScreenParticleAsset = 0x1108 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.ScreenScanResultAsset = 0x1130 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.ScreenScanAsset = 0x1158 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.PowerOnAsset = 0x1180 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.PowerOffAsset = 0x11a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLifeDetectorComponent.ScreenParticleSocket = 0x11d0 // FName (Size: 0x8)
SGLifeDetectorComponent.ScreenParticleTransform = 0x11e0 // FTransform (Size: 0x30)
SGLifeDetectorComponent.ScreenScanResultParticleTransform = 0x1210 // FTransform (Size: 0x30)
SGLifeDetectorComponent.ScanOffsetCurve = 0x1240 // CurveFloat* (Size: 0x8)
SGLifeDetectorComponent.CurvePeriod = 0x1248 // float (Size: 0x4)
SGLinearMotionSimulationComponent.OnSimulationStageBegin = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
SGLinearMotionSimulationComponent.OnSimulationStageEnd = 0x108 // FMulticastInlineDelegate (Size: 0x10)
SGLinearMotionSimulationComponent.SimulationStageMap = 0x118 // TMap<...> (Size: 0x50)
SGLinearMotionSimulationComponent.CurrentParameters = 0x16c // FSGLinearMotionSimulationCurrentParameters (Size: 0x18)
SGLinearMotionSimulationCurrentParameters.CurrentStageIndex = 0x0 // int32_t (Size: 0x4)
SGLinearMotionSimulationCurrentParameters.CurrentStageSpeed = 0x4 // float (Size: 0x4)
SGLinearMotionSimulationCurrentParameters.CurrentStageDistance = 0x8 // float (Size: 0x4)
SGLinearMotionSimulationCurrentParameters.CurrentStageTime = 0xc // float (Size: 0x4)
SGLinearMotionSimulationCurrentParameters.OverrideEndConditionType = 0x10 // EESGLinearMotionSimulationStageEndConditionType (Size: 0x1)
SGLinearMotionSimulationCurrentParameters.OverrideEndConditionValue = 0x14 // float (Size: 0x4)
SGLinearMotionSimulationStage.InitialSpeedType = 0x0 // EESGLinearMotionSimulationStageInitialSpeedType (Size: 0x1)
SGLinearMotionSimulationStage.InitialSpeed = 0x4 // float (Size: 0x4)
SGLinearMotionSimulationStage.Acceleration = 0x8 // float (Size: 0x4)
SGLinearMotionSimulationStage.MotionDirection = 0xc // FVector (Size: 0xc)
SGLinearMotionSimulationStage.EndConditionType = 0x18 // EESGLinearMotionSimulationStageEndConditionType (Size: 0x1)
SGLinearMotionSimulationStage.EndConditionValue = 0x1c // float (Size: 0x4)
SGLoadingInfo.MapTag = 0x0 // FString (Size: 0x10)
SGLoadingInfo.PreMapTag = 0x10 // FString (Size: 0x10)
SGLoadingInfo.bUsePostLoading = 0x20 // bool (Size: 0x1)
SGLoadingInfo.bUseSeparateWidget = 0x21 // bool (Size: 0x1)
SGLoadingInfo.SeparateWidgetPath = 0x28 // FString (Size: 0x10)
SGLoadingInfo.LoadingPathArray = 0x38 // TArray<FString> (Size: 0x10)
SGLoadingInfo.CurrentMovieIndex = 0x48 // int32_t (Size: 0x4)
SGLoadingTickHandleComponent.bTickEnable = 0xf8 // bool (Size: 0x1)
SGLoadingTickHandleComponent.GPreMapName = 0x100 // FString (Size: 0x10)
SGLoadingTickHandleComponent.GMapName = 0x110 // FString (Size: 0x10)
SGLobbyCharacterDialogAnimationRow.AnimKey = 0x8 // FString (Size: 0x10)
SGLobbyCharacterDialogAnimationRow.FullBodyAnim = 0x18 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyCharacterDialogAnimationRow.AvatarAnimationSet = 0x40 // TMap<...> (Size: 0x50)
SGLobbyCharacterDialogAnimationRow.FacialAnim = 0x90 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyCharacterDialogAnimationRow.FacialAnimByLanguage = 0xb8 // TArray<FSGLocalizedAnimation> (Size: 0x10)
SGLobbyNPCAnimInstance.LocalProxy = 0x2c0 // FSGLobbyNPCAnimInstanceProxy (Size: 0x860)
SGLobbyNPCAnimInstance.AnimDebugLogContainer = 0xb20 // FSGAnimationDebugLogContainer (Size: 0x10)
SGLobbyNPCAnimation.BodyAnim = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyNPCAnimation.FacialAnim = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyNPCAnimationRow.NPCName = 0x8 // FName (Size: 0x8)
SGLobbyNPCAnimationRow.AnimKey = 0x10 // FName (Size: 0x8)
SGLobbyNPCAnimationRow.BodyAnim = 0x18 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyNPCAnimationRow.FacialAnim = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLobbyNPCAnimationRow.FacialAnimByLanguage = 0x68 // TArray<FSGLocalizedAnimation> (Size: 0x10)
SGLobbyNPCComponent.CachedLobbyNPCAnimation = 0x120 // TMap<...> (Size: 0x50)
SGLobbyNPCComponent.NPCName = 0x170 // FName (Size: 0x8)
SGLobbyNPCFacialAnimInstance.LocalProxy = 0x2c0 // FSGLobbyNPCFacialAnimInstanceProxy (Size: 0x860)
SGLobbyNPCFacialAnimInstance.AnimDebugLogContainer = 0xb20 // FSGAnimationDebugLogContainer (Size: 0x10)
SGLocalFileKillCamInfo.DeathDemoTime = 0x0 // float (Size: 0x4)
SGLocalFileKillCamInfo.VictimGID = 0x8 // uint64_t (Size: 0x8)
SGLocalFileKillCamInfo.VictimName = 0x10 // FString (Size: 0x10)
SGLocalFileKillCamInfo.KillerGID = 0x20 // uint64_t (Size: 0x8)
SGLocalFileKillCamInfo.KillerName = 0x28 // FString (Size: 0x10)
SGLocalFileKillCamInfo.VictimNetGUID = 0x38 // uint32_t (Size: 0x4)
SGLocalFileKillCamInfo.VictimLocation = 0x3c // FVector (Size: 0xc)
SGLocalFileKillCamInfo.KillerNetGUID = 0x48 // uint32_t (Size: 0x4)
SGLocalFileKillCamInfo.KillerLocation = 0x4c // FVector (Size: 0xc)
SGLocalFileKillCamInfo.bIsDBNODie = 0x58 // bool (Size: 0x1)
SGLocalFileKillCamInfo.ReplayDemoStartTime = 0x5c // float (Size: 0x4)
SGLocalFileKillCamInfo.ReplayDemoEndTime = 0x60 // float (Size: 0x4)
SGLocalFileKillCamInfo.ReplayFileName = 0x68 // FString (Size: 0x10)
SGLocalFileKillCamInfo.KillerWeaponId = 0xc8 // uint32_t (Size: 0x4)
SGLocalFileKillCamInfo.roomid = 0xd0 // int64_t (Size: 0x8)
SGLocalizedAnimation.Languages = 0x8 // TArray<FString> (Size: 0x10)
SGLocalizedAnimation.Animation = 0x18 // TSoftObjectPtr<UObject> (Size: 0x28)
SGLoopMaterialComponent.ItemId = 0xf8 // FName (Size: 0x8)
SGLoopMaterialComponent.MeshMaterials = 0x100 // TArray<MaterialInstanceConstant*> (Size: 0x10)
SGLoopMaterialComponent.LoopTime = 0x110 // float (Size: 0x4)
SGLoopMaterialComponent.LoopMaterialIDs = 0x118 // TArray<int32_t> (Size: 0x10)
SGLoopMaterialComponent.LoopTimerHandle = 0x128 // FTimerHandle (Size: 0x8)
SGLoopMaterialComponent.CurMaterialIndex = 0x130 // int32_t (Size: 0x4)
SGLoopMaterialItemTable.LoopTime = 0x8 // float (Size: 0x4)
SGLoopMaterialItemTable.LoopMaterialIDs = 0x10 // TArray<int32_t> (Size: 0x10)
SGLoopMaterialItemTable.SpecialTimeConfigs = 0x20 // TArray<FLoopMaterialForSpecialTime> (Size: 0x10)
SGLoopMaterialItemTable.Describe = 0x30 // FString (Size: 0x10)
SGLootSubAreaVolume.UnLockInfo = 0x398 // FLootContainerUnLockInfo (Size: 0x30)
SGMCOM.MaxCapacity = 0x320 // int32_t (Size: 0x4)
SGMCOM.MinSucCapacity = 0x324 // int32_t (Size: 0x4)
SGMCOM.CurProgress = 0x328 // int32_t (Size: 0x4)
SGMCOM.UpLoadTime = 0x32c // float (Size: 0x4)
SGMCOM.MComFactionType = 0x330 // EEFactionType (Size: 0x1)
SGMCOM.StartUpLoadDateTime = 0x338 // FDateTime (Size: 0x8)
SGMCOM.OnStartInteractionMComByActor = 0x340 // FMulticastInlineDelegate (Size: 0x10)
SGMCOM.OnMComProgressChange = 0x350 // FMulticastInlineDelegate (Size: 0x10)
SGMCOM.OnWhereabouts = 0x360 // FMulticastInlineDelegate (Size: 0x10)
SGMCOM.OnMComStartUpLoadDateTimeChange = 0x370 // FMulticastInlineDelegate (Size: 0x10)
SGMagazineAnimData.SkinStainID = 0x8 // int32_t (Size: 0x4)
SGMagazineAnimData.ItemId = 0xc // int32_t (Size: 0x4)
SGMagazineAnimData.SkinID = 0x10 // int32_t (Size: 0x4)
SGMagazineAnimInstance.MagStepDownAnim = 0x2b8 // AnimSequence* (Size: 0x8)
SGMagazineAnimInstance.FollowerAnim = 0x2c0 // AnimSequence* (Size: 0x8)
SGMagazineAnimInstance.ShowBulletNum = 0x2c8 // int32_t (Size: 0x4)
SGMagazineAnimInstance.BulletStepDownAnimProgress = 0x2cc // FAnimPositionTracker (Size: 0xc)
SGMagazineAnimInstance.FollowerAnimProgress = 0x2d8 // FAnimPositionAccumulator (Size: 0x18)
SGMagazineAnimInstance.LocalProxy = 0x2f0 // FSGMagazineAnimInstanceProxy (Size: 0x870)
SGMagazineAnimInstance.PushBulletMontage = 0xb60 // AnimMontage* (Size: 0x8)
SGMagazineAnimInstance.Bullets = 0xb70 // TArray<FSGBulletInMagazine> (Size: 0x10)
SGMagazineAnimInstance.IndexToSlotName = 0xb80 // TMap<...> (Size: 0x50)
SGMagazineAnimInstance.AnimDebugLogContainer = 0xbe0 // FSGAnimationDebugLogContainer (Size: 0x10)
SGMagazineAnimInstanceProxy.AnimInstance = 0x860 // SGMagazineAnimInstance* (Size: 0x8)
SGMagazinedAmmoInfo.RelatedMagazine = 0x0 // SGInventory* (Size: 0x8)
SGMagazinedAmmoInfo.AmmoInventory = 0x8 // SGInventory* (Size: 0x8)
SGMaterialParameters.MaterialIndex = 0x0 // int32_t (Size: 0x4)
SGMaterialParameters.ScalarParameters = 0x8 // TArray<FSGMaterialScalarParameterData> (Size: 0x10)
SGMaterialParameters.VectorParameters = 0x18 // TArray<FSGMaterialVectorParameterData> (Size: 0x10)
SGMaterialParameters.TextureParameters = 0x28 // TArray<FSGMaterialTextureParameterData> (Size: 0x10)
SGMaterialScalarParameterData.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
SGMaterialScalarParameterData.ParameterValue = 0x10 // float (Size: 0x4)
SGMaterialTextureParameterData.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
SGMaterialTextureParameterData.ParameterValue = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
SGMaterialVectorParameterData.ParameterInfo = 0x0 // FMaterialParameterInfo (Size: 0x10)
SGMaterialVectorParameterData.ParameterValue = 0x10 // FLinearColor (Size: 0x10)
SGMaxSpeedFactorDiff.Factor = 0x0 // EESGMaxSpeedFactor (Size: 0x4)
SGMaxSpeedFactorDiff.Client = 0x4 // float (Size: 0x4)
SGMaxSpeedFactorDiff.Server = 0x8 // float (Size: 0x4)
SGMeleeWeaponSoundComponent.SoundBank = 0x190 // AkAudioBank* (Size: 0x8)
SGMeleeWeaponSoundComponent.UnloadBankDelayTime = 0x198 // float (Size: 0x4)
SGMeshLightSwitherComponent.MeshActors = 0x40 // TArray<Actor*> (Size: 0x10)
SGMeshLightSwitherComponent.HasCreateDynamicMaterial = 0x50 // bool (Size: 0x1)
SGMeshLightSwitherComponent.ShinnColor = 0x54 // FLinearColor (Size: 0x10)
SGMeshSimpleAnimationComponent.bForceRecalc = 0xf9 // bool (Size: 0x1)
SGMeshSimpleAnimationComponent.MeshComponentName = 0xfc // FName (Size: 0x8)
SGMeshSimpleAnimationComponent.TargetMesh = 0x108 // MeshComponent* (Size: 0x8)
SGMeshSimpleAnimationComponent.bUseRotateAnim = 0x110 // bool (Size: 0x1)
SGMeshSimpleAnimationComponent.DummyPivotOffset = 0x114 // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.RotateAxis = 0x120 // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.RotateAngle = 0x12c // float (Size: 0x4)
SGMeshSimpleAnimationComponent.RotateDuration = 0x130 // float (Size: 0x4)
SGMeshSimpleAnimationComponent.RotateAnimProgress = 0x134 // float (Size: 0x4)
SGMeshSimpleAnimationComponent.RotateAnimState = 0x138 // EESimpleAnimationState (Size: 0x1)
SGMeshSimpleAnimationComponent.DummyPivotRelativeLocation = 0x13c // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.DummyPivotOriginRelativeRotation = 0x148 // FRotator (Size: 0xc)
SGMeshSimpleAnimationComponent.bUseTranslateAnim = 0x154 // bool (Size: 0x1)
SGMeshSimpleAnimationComponent.TranslateOffset = 0x158 // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.TranslateDuration = 0x164 // float (Size: 0x4)
SGMeshSimpleAnimationComponent.PivotOriginRelativeLocation = 0x168 // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.PivotRelativeLocation = 0x174 // FVector (Size: 0xc)
SGMeshSimpleAnimationComponent.PivotOriginRelativeRotation = 0x180 // FRotator (Size: 0xc)
SGMeshSimpleAnimationComponent.TranslateProgress = 0x18c // float (Size: 0x4)
SGMeshSimpleAnimationComponent.TranslateAnimState = 0x190 // EESimpleAnimationState (Size: 0x1)
SGMeshSimpleAnimationComponent.AkAudioEventOnClosed = 0x198 // AkAudioEvent* (Size: 0x8)
SGMeshSimpleAnimationComponent.AkAudioEventOnOpening = 0x1a0 // AkAudioEvent* (Size: 0x8)
SGMeshSimpleAnimationComponent.AkAudioEventOnOpened = 0x1a8 // AkAudioEvent* (Size: 0x8)
SGMeshSimpleAnimationComponent.AkAudioEventOnClosing = 0x1b0 // AkAudioEvent* (Size: 0x8)
SGMeshSwitherComponent.MeshActors = 0x40 // TArray<Actor*> (Size: 0x10)
SGMeshSwitherComponent.bKeepCollisoin = 0x50 // bool (Size: 0x1)
SGMeshSwitherComponent.bPreviewState = 0x51 // bool (Size: 0x1)
SGMeshSwitherComponent.bCacheState = 0x52 // bool (Size: 0x1)
SGMeshSwitherComponent.bShowState = 0x53 // bool (Size: 0x1)
SGMessageEvents.TakeHitMessage = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TakeHitHelmetMessage = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SimpleTakeHit = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDropOfBlood = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.DeathMessage = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.MatchStateChanged = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.CurrentWeaponChanged = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.CurrentWeaponHoldOpenChanged = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.CurrentThrowWeaponChanged = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.NewBagTipMessage = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InventoryAdded = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InventoryRemoved = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.WeaponInnerEvent = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.WidgetInputAction = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InputTouchEvent = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAcceptRotationInput = 0x120 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ThrowWeaponChangedEvent = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ThrowConnectionTimeOutEvent = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InvDurabilityCost = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InvDurabilityChange = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGenerateSound = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGenerateOBGlobalSound = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGenerateSoundRelevancy = 0x190 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGenerateSoundPreview = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGenerateExplosionSound = 0x1b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSelfGenerateSound = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSelfToggleBreathSound = 0x1d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InventoryMoved = 0x1e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientInventoryChanged = 0x1f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnQuickUseItemScrollChanged = 0x200 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientThrowWeaponGridChange = 0x210 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientAddVestBag = 0x220 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGetPlayerInventoryMoveResult = 0x230 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGetPlayerInventoryUnFillResult = 0x240 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDoorUnLockEvent = 0x250 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChangeCurrentInteractingTypeResult = 0x260 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRepInspectedItemList = 0x270 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.RepForcePositionUpdate = 0x280 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRepPlayerDetectedInvPosList = 0x290 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterInspecting = 0x2a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFocusLost = 0x2b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChangeSoundVisualPlan = 0x2c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.RequestChangeBagTopMenu = 0x2d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.RequestShowQuestTraceInfoInMap = 0x2e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BulletPassBy = 0x2f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.LookAroundStatusChanged = 0x300 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ForceRefreshThermal = 0x310 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.WeaponLoadComplete = 0x320 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponIconImageUpdated = 0x330 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.AsyncLoadImageComplete = 0x340 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ThrowWeaponBeSearched = 0x350 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.QuickUseInvBeSearched = 0x360 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNetworkTryReconnect = 0x370 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNetworkReconnect = 0x380 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNotifyInteractEvent = 0x390 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNotifyInteractHandledEvent = 0x3a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameHUDShowMessageByID = 0x3b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowCommunicationTips = 0x3c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameHUDClearMessageByID = 0x3d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.GamePadMessageByID = 0x3e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChangeGamePadVisibility = 0x3f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGamePadEffectVisibility = 0x400 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameHUDClearAllMessage = 0x410 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowQuestPrice = 0x420 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponLoaded = 0x430 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.UseActorFailedEvent = 0x440 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnUseActorCancelled = 0x450 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.UseActorSuccess = 0x460 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.UseMagazineSuccess = 0x470 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBagScrollEnabled = 0x480 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCorpseBagScrollEnabled = 0x490 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPinchStarted = 0x4a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPinchUpdate = 0x4b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowTutorialMask = 0x4c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowMovementRun = 0x4d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAddQuestReport = 0x4e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnQuestReportVisibleChanged = 0x4f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBroadcastAchievement = 0x500 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EnterDBNOStatusMessage = 0x510 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ExitDBNOStatusMessage = 0x520 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InteractingFultonClose = 0x530 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowLifeStateInfoPanel = 0x540 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapEffectShow = 0x550 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapLoadAssestCompelete = 0x560 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPadSettingBtnShow = 0x570 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFlashGrenade = 0x580 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInventoryFlash = 0x590 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOffensiveGrenade = 0x5a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterEnterMolotov = 0x5b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterFirework = 0x5c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowGetInventoryCloseBtn = 0x5d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPadSettingResetLayout = 0x5e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHelmetEquiped = 0x5f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHelmetUnequiped = 0x600 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnVestEquiped = 0x610 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnVestUnEquiped = 0x620 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHeadSetEquiped = 0x630 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHeadSetUnEquiped = 0x640 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFaceShieldEquiped = 0x650 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFaceShieldUnequiped = 0x660 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThighArmorEquiped = 0x670 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThighArmorUnEquiped = 0x680 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFaceCoverEquiped = 0x690 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFaceCoverUnequiped = 0x6a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnToggleThermalHeadwear = 0x6b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapEffect = 0x6c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapStateChange = 0x6d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.Crouch = 0x6e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SilentWalk = 0x6f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.Sprint = 0x700 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.Jump = 0x710 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnZoom = 0x720 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.LeanTypeChanged = 0x730 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.IsZoom = 0x740 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ToggleScopeMagnitudeUI = 0x750 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHoldBreathChanged = 0x760 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowWeaponFire = 0x770 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowWeaponEnd = 0x780 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponFire = 0x790 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowWeaponFireCanBeHold = 0x7a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnProneChanged = 0x7b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDivingChanged = 0x7c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCanDiveChanged = 0x7d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TeammateCurseChanged = 0x7e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BigMapRefreshAllModule = 0x7f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BigMapLowRefreshAllModule = 0x800 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BigMapEnableModule = 0x810 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.GameTipsEnableRefresh = 0x820 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BigmapDetailBoardShow = 0x830 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.GraphicQualityChanged = 0x840 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTeammatesCountsChanged = 0x850 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTeammatesIndexChanged = 0x860 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.NotifyExplosion = 0x870 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EnableAllGamePadView = 0x880 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTimeLimitedQuestCountDown = 0x890 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMissionTimeLimitedCountDown = 0x8a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponActionAbilityActive = 0x8b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterDieInClient = 0x8c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientReceiveKillerInfo = 0x8d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterEnterSmoke = 0x8e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EnduranceChangedEvent = 0x8f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SignalValueChangedEvent = 0x900 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.FoodChangedEvent = 0x910 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.MoistureChangedEvent = 0x920 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TearGasDurationSetEvent = 0x930 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TearGasStateChangedEvent = 0x940 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameplayTagsChangedEvent = 0x950 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameplayEffectAppliedEvent = 0x960 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAnyGameplayEffectRemovedEvent = 0x970 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOpenItemDetailPanel = 0x980 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameplayEffectAppliedDataEvent = 0x990 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMagazineChanged = 0x9a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTraceQuestChange = 0x9b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnContainerTopMenuChangeEvent = 0x9c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnReceiveUseActorFailureReason = 0x9d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnReplayRecordStarted = 0x9e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnReplayPlaybackStarted = 0x9f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnReplayStartPlaybackFailed = 0xa00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnReplayFinishPlayback = 0xa10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChangeGamePadHighEffect = 0xa20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TutorialMaskShow = 0xa30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTutorialHintChanged = 0xa40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TutorialSetSprintEnable = 0xa50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SpawnLootContainer = 0xa60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SpawnLootInventoryItem = 0xa70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRemoveLootCommonItem = 0xa80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRemoveLootGuaranteeItem = 0xa90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameSettingClicked = 0xaa0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBackToGame = 0xab0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOpenBagClicked = 0xac0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOpenMapClicked = 0xad0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnQuickUseItem = 0xae0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChangeClip = 0xaf0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCheckMagazine = 0xb00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLootPressed = 0xb10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLootReleased = 0xb20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTeaminfoRepFinish = 0xb30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnEnterAreaVolume = 0xb40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLeavingAreaVolume = 0xb50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPreEnterReportAreaVolume = 0xb60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPreLeavingReportAreaVolume = 0xb70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnEnterHeatMapAreaVolume = 0xb80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLeaveHeatMapAreaVolume = 0xb90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.IllegalSight = 0xba0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSceneEventTrigger = 0xbb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSceneEventExpired = 0xbc0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSceneEventCompleted = 0xbd0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSceneEventRemoved = 0xbe0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowableProjectileSpawn = 0xbf0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowableProjectileExplode = 0xc00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowableProjectileDestory = 0xc10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThrowableProjectileStop = 0xc20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterEffectAdded = 0xc30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowTextSubTitle = 0xc40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowAudioSubTitle = 0xc50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.AddSystemChatMessage = 0xc60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EscapeStateChange = 0xc70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EscapeBeginTimeChange = 0xc80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChaseActivityTargetsUpdate = 0xc90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChaseActivityStateChange = 0xca0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ActivityInventoryStateChange = 0xcb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChaseActivityStart = 0xcc0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChaseActivityStageChange = 0xcd0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChaseActivityInventoryNumChange = 0xce0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OwnedChaseActivityInventoryNumChange = 0xcf0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TraceableActorInfoUpdate = 0xd00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TraceableActorInfosUpdate = 0xd10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNewActiveTraceableActorInfosUpdate = 0xd20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNewPassivityTraceableActorInfosUpdate = 0xd30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMousePinTraceInfosUpdate = 0xd40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnScanDeviceInfosUpdate = 0xd50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMousePinReplay = 0xd60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBlackStoreItemsChange = 0xd70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigGoldRaidStateChange = 0xd80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigGoldRaidBoxBeUsedByReal = 0xd90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerStopUsingContraband = 0xda0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerStartUsingContraband = 0xdb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBlackStoreBuyItem = 0xdc0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerBlackStoreInfoChange = 0xdd0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerCoinMoneyChange = 0xde0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerReciveBlackStoreBuyResult = 0xdf0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerUsingScanDevice = 0xe00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerReceiveScanResult = 0xe10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerBeScannedNotify = 0xe20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSupplyStationBuyResultNotify = 0xe30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPasswordDoorInfoRep = 0xe40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPasswordDoorCheckSuccess = 0xe50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNotifyPasswordDoorCheckResult = 0xe60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSupplyStationItemChange = 0xe70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSupplyStationLimitBuyListChange = 0xe80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnUIModeChanged = 0xe90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSetBagSelectPanelLocked = 0xea0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnQuestEffectGiveItem = 0xeb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMissionActionGiveItem = 0xec0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChangeAdviseItemProity = 0xed0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBagOpenEvent = 0xee0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBagCloseEvent = 0xef0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnViewMonitorChange = 0xf00 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMonitorShutdown = 0xf10 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBlackStoreOpenEvent = 0xf20 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnScanDevicePanelOpen = 0xf30 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBlackStoreCloseEvent = 0xf40 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBlackStoreInteractButtonDown = 0xf50 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPasswordDoorInputDeviceUsedByReal = 0xf60 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSceneScanDeviceUsedByReal = 0xf70 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPasswordDoorInputPanelOpen = 0xf80 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRecordParamTransmit = 0xf90 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChaseActivityInventoryDestroyed = 0xfa0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMarkBuffChanged = 0xfb0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBeMarkBuffChanged = 0xfc0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponSupportOnStateChange = 0xfd0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientTakeDamageObjective = 0xfe0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapTeamSign = 0xff0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBigMapClearTeamSign = 0x1000 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.PlayHeadwearUIAnimation = 0x1010 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.HeadwearScreenEffectChanged = 0x1020 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSetScreenEffectPaddingByCmd = 0x1030 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowGameTimeCountDown = 0x1040 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.VolumeActorChanged = 0x1050 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.DoorGateOn = 0x1060 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInventoryAttractAI = 0x1070 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIEscaped = 0x1080 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowQuestReport = 0x1090 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMainWeaponListChanged = 0x10a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOutOfAmmo = 0x10b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHasAmmo = 0x10c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAmmmoCountChanged = 0x10d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCurrentShootingModeChanged = 0x10e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInputTouchEnded = 0x10f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAimedActorChanged = 0x1100 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAimedDoorChanged = 0x1110 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAimedContainerChanged = 0x1120 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCanPickUpInventoriesChanged = 0x1130 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponFoldStock = 0x1140 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeaponFoldStateChange = 0x1150 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAddToTeamEvent = 0x1160 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAddToFactionEvent = 0x1170 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRemoveToFactionEvent = 0x1180 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOBAddToTeamEvent = 0x1190 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOBRemoveFromTeamEvent = 0x11a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInBattleTeamMemberPlayerConditionChange = 0x11b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAddToTeamSpecialmemberEvent = 0x11c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRemoveToTeamEvent = 0x11d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayInventoryAnimation = 0x11e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerIdentityTypeChange = 0x11f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRepPlayerName = 0x1200 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerChatVoiceIDsChange = 0x1210 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGoToTimeProcessed = 0x1220 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTeamEscapeStateChange = 0x1230 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTeamExplreEscapePointsChange = 0x1240 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnActorBeginOverlapCylinderEvent = 0x1250 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnActorEndOverlapCylinderEvent = 0x1260 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnX5Spawn = 0x1270 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnX5Deactive = 0x1280 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFultonOwnerSettle = 0x1290 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFultonStartInteract = 0x12a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCameraMaterialConfigChange = 0x12b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLockedByCharacterChangedEvent = 0x12c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInspectItemClick = 0x12d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClientInvDestroy = 0x12e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGameHudAddToast = 0x12f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSwitchInputMode = 0x1300 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.CharacterEnterTrainPopArea = 0x1310 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFootStepMakerTriggerSoundIndicator = 0x1320 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ReportSoundIndicatorScore = 0x1330 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ReportSoundIndicatorCount = 0x1340 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.CharacterEnterSceneGasArea = 0x1350 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.GasGateToggled = 0x1360 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowMergedAvatar = 0x1370 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.PickItemClick = 0x1380 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDragEnabled = 0x1390 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnEnableItemToolTip = 0x13a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLockMoveForward = 0x13b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRecordInspectionLootPointIDChange = 0x13c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnExploreInspectionLootPointIDChange = 0x13d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnEnableFullScreenHudCloseEvent = 0x13e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TestEventToLua = 0x13f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ReportClientIP = 0x1400 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SetLadderClimbingBtnVisibility = 0x1410 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SceneInteractActorTriggerTlog = 0x1420 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ChangeSprintStateEvent = 0x1430 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGetOutOfStuckResult = 0x1440 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.WeaponJammingStateChangedEvent = 0x1450 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.HintWeaponMayJammingEvent = 0x1460 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.AddMapSign = 0x1470 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ForceScoreInfoUpdated = 0x1480 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLockItems = 0x1490 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnUnlockItems = 0x14a0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDoorInteract = 0x14b0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLadderClimbing = 0x14c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHostedInteract = 0x14d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.QuestTraceHighEffect = 0x14e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.PlayDirectionalBarHighEffect = 0x14f0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPreviewPlaceStateChanged = 0x1500 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SetAllGamePadVisibilityBut = 0x1510 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ForceUpdateGamePad = 0x1520 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnClickLaserSwitch = 0x1530 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowTutorialNewTip = 0x1540 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowSubTitle = 0x1550 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTickDemoPlaybackStart = 0x1578 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnLootSubAreaVolumeBlockStateChange = 0x1588 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnNewWidgetCreated = 0x1598 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGashaponSpawnInventoryHandle = 0x15a8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGashaponOccupied = 0x15b8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnChaseActivityAvatarInfoChange = 0x15c8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRepIsDSRecordingReplay = 0x15d8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnInventoryInteractionTypeChange = 0x15e8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.FactionScoreUpdateEvent = 0x15f8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFactionChangedInGameEvent = 0x1608 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowScorePanel = 0x1618 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SetScorePanelConfig = 0x1628 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.SetScorePanelMaxScore = 0x1638 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.FreezeAllForceInfo = 0x1648 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.FactionFightWinEvent = 0x1658 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFactionTeammemberPlayerBaseInfoChange = 0x1668 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.VestAndBagBreathe = 0x1678 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OpenSearchEffect = 0x1688 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OpenHightlightEscape = 0x1698 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWeatherChangedEvent = 0x16a8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.PlayerStateRepFinish = 0x16b8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.HighlightSelectButton = 0x16c8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OpenArrowTip = 0x16d8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterPreEnterTacticStatus = 0x1718 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIMarkBattleEnter = 0x1758 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIMarkBattleLeave = 0x1768 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIMarkFire = 0x1778 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDestoryDiscardedAI = 0x1788 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIMarkEndPlay = 0x1798 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnShowTextDetail = 0x17a8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHideTextDetail = 0x17b8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMoveShowTextDetail = 0x17c8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMoveHideTextDetail = 0x17d8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.EnablePIEVehicleInput = 0x17e8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThunderStageChanged = 0x17f8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterSlicedProcessFinished = 0x1808 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnWalkinAnimationEndEvent = 0x1818 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGrenadeByTeammate = 0x1828 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnGrenadeByTeammateFeedback = 0x1838 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTryActivateGestureResult = 0x1848 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnStartInvDetecting = 0x1888 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnStartInteractActor = 0x1898 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAntiCamperStageTriggered = 0x18c0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterEnterStationaryState = 0x18d0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCharacterExitStationaryState = 0x18e0 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.InvokeAnnounceOnServer = 0x1908 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ClientPlayToast = 0x1918 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAIIllustratedBook = 0x1938 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.BattleRoyalStageChange = 0x1948 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOpenAnimationEnd = 0x1958 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OperationResultState = 0x1968 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.On1pFloorChanged = 0x1978 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnUpdateHUDDBNOPercent = 0x1988 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCurrentScopeChanged = 0x1998 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ActionFeedbackMessage = 0x19a8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ActivityReportMessage = 0x19b8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnIntelligenceExposedChanged = 0x19c8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnDirectionBarShow = 0x19d8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBulletHitArmor = 0x19e8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnThermalMaterialChanged = 0x19f8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnSpawnLootItemsFinished = 0x1a08 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnBanThrowableWeapon = 0x1a18 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.TutorialRookieTriggerIDReport = 0x1a28 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAimInteractItem = 0x1a38 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOnCameraFocusEnd = 0x1a48 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnHUDWidgetClickCountTLOG = 0x1a58 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnAllLobbyNPCAnimationLoaded = 0x1a68 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRoundGameGlobalDataChange = 0x1a78 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnTDMGameGlobalDataChange = 0x1a88 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.ShowRebornInfoPanel = 0x1a98 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerLevelChanged = 0x1aa8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnPlayerKillNumChanged = 0x1ab8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnIntelligenceStateChanged = 0x1ac8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnIntelligenceKeyLocExplode = 0x1ad8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnOtherTeamPickedUpIntelligenceKey = 0x1ae8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnRoundSelectSuit = 0x1af8 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnActorBeBroken = 0x1b08 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFrontEndSequenceStart = 0x1b18 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFrontEndSequenceFinish = 0x1b28 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnFrontEndSequenceTrigger = 0x1b38 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnMissionFlowFinished = 0x1b48 // FMulticastInlineDelegate (Size: 0x10)
SGMessageEvents.OnCustomAnimNotify = 0x1b58 // FMulticastInlineDelegate (Size: 0x10)
SGMissionDataComponent.WaitingMissionFlowReplicateDataChangedList = 0x208 // TArray<FMissionFlowReplicateDataChangedEvent> (Size: 0x10)
SGMissionDataComponent.WaitingMissionReplicateDataChangedList = 0x218 // TArray<FMissionReplicateDataChangedEvent> (Size: 0x10)
SGMissionObjective.bOnlyOneSuccess = 0x118 // bool (Size: 0x1)
SGMissionObjective.bSupportPlayerSettle = 0x119 // bool (Size: 0x1)
SGMissionObjective.GSStatisComponent = 0x120 // SGGameStateStatisComponent* (Size: 0x8)
SGModeAIDogTagReplaceRaw.AIID = 0x0 // TArray<int64_t> (Size: 0x10)
SGModeAIDogTagReplaceRaw.FactionType = 0x10 // EEFactionType (Size: 0x1)
SGModeAIDogTagReplaceRaw.ReplaceItemID = 0x18 // uint64_t (Size: 0x8)
SGModeActorPoolTable.PoolActorInfoList = 0x20 // TArray<FPoolActorInfo> (Size: 0x10)
SGModeActorPoolTable.PoolInventoryInfoList = 0x30 // TMap<...> (Size: 0x50)
SGModeDataTableManager.CurrMainModeID = 0x28 // int32_t (Size: 0x4)
SGModeDataTableManager.CurrSubModeID = 0x2c // int32_t (Size: 0x4)
SGModeDataTableManager.CurrMapID = 0x30 // int32_t (Size: 0x4)
SGModeDataTableManager.CurrDifficulty = 0x34 // int32_t (Size: 0x4)
SGModeDataTableManager.CurrSpecialID = 0x38 // int32_t (Size: 0x4)
SGModeDataTableManager.DataTableArr = 0x40 // TArray<DataTable*> (Size: 0x10)
SGModeDogTagReplaceRaw.FactionType = 0x0 // EEFactionType (Size: 0x1)
SGModeDogTagReplaceRaw.ReplaceItemID = 0x8 // uint64_t (Size: 0x8)
SGModeDogTagReplaceTable.ModeDogTagReplaceArr = 0x20 // TArray<FSGModeDogTagReplaceRaw> (Size: 0x10)
SGModeDogTagReplaceTable.AIDogTagReplaceArr = 0x30 // TArray<FSGModeAIDogTagReplaceRaw> (Size: 0x10)
SGModePreloadClassTable.PreloadClass = 0x20 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGModePreloadClassTable.DevPreloadClass = 0x30 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGModeTagTable.GameplayTag = 0x20 // TArray<FName> (Size: 0x10)
SGMonitorData.PrevPosition = 0x68 // FVector2D (Size: 0x8)
SGMonitorData.PrevResolution = 0x70 // FIntPoint (Size: 0x8)
SGMontagePlayConfig.AdapterAnimType = 0x0 // EEAdapterAnimationType (Size: 0x1)
SGMontagePlayConfig.ForceBlendInTime = 0x4 // float (Size: 0x4)
SGMontagePlayConfig.ForceBlendOutTime = 0x8 // float (Size: 0x4)
SGMontagePlayConfig.bDisableBlendIn = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bDisableBlendOut = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bLockAnimationSet = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bStopAllMontage = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bSyncMontage = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bCanTriggerWithGrass = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.bReplayWhileIsPlaying = 0xc // uint8_t (Size: 0x1)
SGMontagePlayConfig.RequiredWeapon = 0x10 // SGInventory* (Size: 0x8)
SGMontagePlayParams.MontagePath = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGMontagePlayParams.Montage = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
SGMontagePlayParams.MontageHardPtr = 0x30 // AnimMontage* (Size: 0x8)
SGMontagePlayParams.SectionName = 0x38 // FName (Size: 0x8)
SGMontagePlayParams.PlayRate = 0x40 // float (Size: 0x4)
SGMontagePlayParams.StartTime = 0x44 // float (Size: 0x4)
SGMontargeWithPlayRate.AnimSeq = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGMontargeWithPlayRate.PlayRate = 0x28 // float (Size: 0x4)
SGMontargeWithPlayRateChangeClip.AnimSeq = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGMontargeWithPlayRateChangeClip.PlayRate = 0x28 // float (Size: 0x4)
SGMontargeWithPlayRateChangeClip.BlendInWhenPlayStandAlone = 0x2c // float (Size: 0x4)
SGMontargeWithPlayRateChangeClip.BlendOutWhenPlayStandAlone = 0x30 // float (Size: 0x4)
SGMotionWarpingComponent.NetSyncPoints = 0x1f8 // TArray<FMotionWarpingNetSyncPoint> (Size: 0x10)
SGMotionWarpingComponent.TempSyncPoint = 0x210 // FMotionWarpingNetSyncPoint (Size: 0x30)
SGNPCAIFactionTableRow.MustPlugin = 0x8 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGNPCAIFactionTableRow.ExtraPlugin = 0x18 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGNPCAIFactionTableRow.SwitchPlugin = 0x28 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGNPCAINameTableRow.NameIndex = 0x8 // int32_t (Size: 0x4)
SGNPCAINameTableRow.NameText = 0x10 // FText (Size: 0x18)
SGNPCAINameTableRow.NamePoolID = 0x28 // int32_t (Size: 0x4)
SGNPCAINameTableRow.Level = 0x2c // int32_t (Size: 0x4)
SGNPCAINameTableRow.Rank = 0x30 // int32_t (Size: 0x4)
SGNPCSpawnConfigTableRow.AIDisplayName = 0x8 // FString (Size: 0x10)
SGNPCSpawnConfigTableRow.MaxEquipSuiteCount = 0x18 // int32_t (Size: 0x4)
SGNPCSpawnConfigTableRow.PullPriority = 0x1c // int32_t (Size: 0x4)
SGNPCSpawnConfigTableRow.NamePoolID = 0x20 // int32_t (Size: 0x4)
SGNPCSpawnConfigTableRow.AICharacterClass = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
SGNPCSpawnConfigTableRow.AIFactionPerformances = 0x50 // TMap<...> (Size: 0x50)
SGNPCSpawnConfigTableRow.AIControllerClass = 0xa0 // TSoftClassPtr<UObject> (Size: 0x28)
SGNPCSpawnConfigTableRow.FactionClass = 0xc8 // TSoftClassPtr<UObject> (Size: 0x28)
SGNPCSpawnConfigTableRow.RoleClass = 0xf0 // TSoftClassPtr<UObject> (Size: 0x28)
SGNPCSpawnConfigTableRow.ArchetypeTemplate = 0x118 // TSoftObjectPtr<UObject> (Size: 0x28)
SGNPCSpawnConfigTableRow.FactionName = 0x140 // FName (Size: 0x8)
SGNPCSpawnGroupWeight.GroupID = 0x0 // FName (Size: 0x8)
SGNPCSpawnGroupWeight.SpawnWeight = 0x8 // float (Size: 0x4)
SGNPCSpawnGroupWeight.Probability = 0xc // float (Size: 0x4)
SGNPCSpawnGroupWeight.TakenCount = 0x10 // int32_t (Size: 0x4)
SGNetConnectionSubsystem.PingMap = 0x60 // TMap<...> (Size: 0x50)
SGNetRelevantConfigurableActor.RelevantForActors = 0x318 // TArray<Actor*> (Size: 0x10)
SGNetRelevantConfigurableActor.InteractID = 0x328 // int32_t (Size: 0x4)
SGOBMovementComponent_HD.OrbitingActor = 0xc58 // Actor* (Size: 0x8)
SGOBMovementComponent_HD.OrbitingOffset = 0xc60 // FVector (Size: 0xc)
SGOBMovementComponent_HD.SpeedBias = 0xc6c // float (Size: 0x4)
SGOneWayBlend.Blend = 0x0 // FAlphaBlend (Size: 0x30)
SGOneWayBlend.bCompleted = 0x30 // bool (Size: 0x1)
SGOneWayBlend.Value = 0x34 // float (Size: 0x4)
SGOrnamentAnimInstance.LocalProxy = 0x2c0 // FSGOrnamentAnimInstanceProxy (Size: 0x8c0)
SGOrnamentAnimInstance.ComponentLinearAccScale = 0xb80 // FVector (Size: 0xc)
SGOrnamentAnimInstance.ComponentLinearVelScale = 0xb8c // FVector (Size: 0xc)
SGOrnamentAnimInstance.ComponentAppliedLinearAccClamp = 0xb98 // FVector (Size: 0xc)
SGOrnamentAnimInstance.ForceStrength = 0xba4 // float (Size: 0x4)
SGOrnamentAnimInstance.ExternalCollisionTransform = 0xbb0 // FTransform (Size: 0x30)
SGOrnamentAnimInstance.ExternalCollisionExtend = 0xbe0 // FVector (Size: 0xc)
SGOrnamentAnimInstance.ExternalCollisionTarget = 0xbf0 // SkeletalMeshComponent* (Size: 0x8)
SGOrnamentAnimInstanceProxy.AnimInstance = 0x860 // SGOrnamentAnimInstance* (Size: 0x8)
SGOrnamentAnimInstanceProxy.ActiveSimulateMethod = 0x868 // EEOrnamentSimulateMethod (Size: 0x1)
SGOrnamentAnimInstanceProxy.ExternalCollisionTransform = 0x870 // FTransform (Size: 0x30)
SGOrnamentAnimInstanceProxy.ExternalCollisionExtend = 0x8a0 // FVector (Size: 0xc)
SGOrnamentAnimInstanceProxy.ExternalCollisionTarget = 0x8b0 // SkeletalMeshComponent* (Size: 0x8)
SGOutsideAvatarAnimationSet.CharacterAnimation = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGOutsideAvatarAnimationSet.FacialAnimation = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGOutsideAvatarAnimationSet.WeaponAnimation = 0x50 // TSoftObjectPtr<UObject> (Size: 0x28)
SGOutsideAvatarAnimationSet.AvatarAnimationSet = 0x78 // TMap<...> (Size: 0x50)
SGOutsideAvatarSet.PerLocationOutsideAvatarSet_Male = 0x28 // TMap<...> (Size: 0x50)
SGOutsideAvatarSet.PerLocationOutsideAvatarSet_Female = 0x78 // TMap<...> (Size: 0x50)
SGOutsideItemAnimationSet.ItemMesh = 0x0 // SkeletalMesh* (Size: 0x8)
SGOutsideItemAnimationSet.AttachSocketName = 0x8 // FName (Size: 0x8)
SGOutsideItemAnimationSet.ItemAnimation = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
SGOutsideItemAnimationSet.ItemBoundsScale = 0x38 // float (Size: 0x4)
SGOutsideParticleSystemInfo.ParticleEffect = 0x0 // ParticleSystem* (Size: 0x8)
SGOutsideParticleSystemInfo.AttachSocketName = 0x8 // FName (Size: 0x8)
SGOutsideParticleSystemInfo.AttachOffset = 0x10 // FVector (Size: 0xc)
SGOverrideInventoryMeshForSpecialTime.StartTime = 0x0 // FDateTime (Size: 0x8)
SGOverrideInventoryMeshForSpecialTime.EndTime = 0x8 // FDateTime (Size: 0x8)
SGOverrideInventoryMeshForSpecialTime.OverrideMeshes = 0x10 // TMap<...> (Size: 0x50)
SGOverrideInventoryMeshForSpecialTimeComponent.ItemName = 0xf8 // FName (Size: 0x8)
SGOverrideInventoryMeshForSpecialTimeItemTable.SpecialTimeConfigs = 0x8 // TArray<FSGOverrideInventoryMeshForSpecialTime> (Size: 0x10)
SGOverrideInventoryMeshForSpecialTimeItemTable.Describe = 0x18 // FString (Size: 0x10)
SGPCAimingComponent.AimedActorCache = 0x100 // Actor* (Size: 0x8)
SGPCAimingComponent.CheckDistance = 0x108 // float (Size: 0x4)
SGPCAimingComponent.Angle = 0x10c // float (Size: 0x4)
SGPCAimingComponent.CosAngle = 0x110 // float (Size: 0x4)
SGPCAimingComponent.LastGetAllAimedActorsTime = 0x114 // float (Size: 0x4)
SGPCAimingComponent.CachedAimedActors = 0x118 // TArray<Actor*> (Size: 0x10)
SGPCAimingComponent.CachedAimedActorsInteractInfoMap = 0x128 // TMap<...> (Size: 0x50)
SGPCAimingComponent.LastCalcCanPickUpTime = 0x178 // float (Size: 0x4)
SGPCAimingComponent.CachedCanPickUpInventories = 0x180 // TArray<Actor*> (Size: 0x10)
SGPCAimingComponent.CachedDoor = 0x190 // Actor* (Size: 0x8)
SGPCAimingComponent.CachedContainer = 0x198 // Actor* (Size: 0x8)
SGPCAimingComponent.MaxCanpickUpInvCount = 0x1a0 // int32_t (Size: 0x4)
SGPCAimingComponent.RecalcInteval = 0x1a4 // float (Size: 0x4)
SGPCAimingComponent.ProneSizeSquared2D = 0x1a8 // float (Size: 0x4)
SGPCAimingComponent.LastBreakActor = 0x1b0 // Actor* (Size: 0x8)
SGPCAssetLoadManager.bEnableBulletPool = 0x100 // bool (Size: 0x1)
SGPCAssetLoadManager.bEnableImpactEffectPool = 0x101 // bool (Size: 0x1)
SGPCAssetLoadManager.bEnableBloodSplatterPool = 0x102 // bool (Size: 0x1)
SGPCAssetLoadManager.bEnableBulletShellPool = 0x103 // bool (Size: 0x1)
SGPCAssetLoadManager.bEnableFireEffectPool = 0x104 // bool (Size: 0x1)
SGPCAssetLoadManager.bEnableProjectileEffectPool = 0x105 // bool (Size: 0x1)
SGPCAssetLoadManager.ImpactEffectPool = 0x108 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BloodSplatterPool = 0x110 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BulletShellPool = 0x118 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.GravityBulletPool = 0x120 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ProjectileEffectPool = 0x128 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.GeneralPoolList = 0x130 // TArray<ObjectPool*> (Size: 0x10)
SGPCAssetLoadManager.ShotFire1PEffectPool = 0x140 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotFire1PEffectPoolAnyThread = 0x148 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotFire3PEffectPool = 0x150 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotFire3PEffectPoolAnyThread = 0x158 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotLightEffectPool = 0x160 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotLightEffectPoolAnyThread = 0x168 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BulletShellEffectPool = 0x170 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BulletShellEffectPoolAnyThread = 0x178 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotFogEffectPool = 0x180 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.ShotFogEffectPoolAnyThread = 0x188 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BulletTracerEffectPool = 0x190 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.BulletTracerEffectPoolAnyThread = 0x198 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.NormalFireEffectPool = 0x1a0 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.NormalFireEffectPoolAnyThread = 0x1a8 // ObjectPool* (Size: 0x8)
SGPCAssetLoadManager.PoolSize_GravityBullet = 0x1b0 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_HitImpact = 0x1b4 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_BloodSplatter = 0x1b8 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_BulletShell = 0x1bc // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_FireEffect = 0x1c0 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_BulletLineEffect = 0x1c4 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_NormalFireEffect = 0x1c8 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_ProjectileEffect = 0x1cc // int32_t (Size: 0x4)
SGPCAssetLoadManager.PooledImpactEffectManagerClass = 0x1d0 // ClassProperty (Size: 0x8)
SGPCAssetLoadManager.GeneralGravityBulletClass = 0x1d8 // ClassProperty (Size: 0x8)
SGPCAssetLoadManager.ImpactEffectClass = 0x1e0 // ClassProperty (Size: 0x8)
SGPCAssetLoadManager.BulletShellClass = 0x1e8 // ClassProperty (Size: 0x8)
SGPCAssetLoadManager.PoolSize_FireEffect_WhenInit_PerTempate = 0x1f0 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_BulletLineEffect_WhenInit_PerTempate = 0x1f4 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_BulletShellEffect_WhenInit_PerTempate = 0x1f8 // int32_t (Size: 0x4)
SGPCAssetLoadManager.PoolSize_ImpactEffect_WhenInit_PerTempate = 0x1fc // int32_t (Size: 0x4)
SGPCAssetLoadManager.ProjectileTrajectoryClass = 0x208 // ClassProperty (Size: 0x8)
SGPCAssetLoadManager.TrajectoryActor = 0x210 // SGProjectileTrajectory* (Size: 0x8)
SGPCAssetLoadManager.PSCCreatingList = 0x218 // TArray<FPSCInfo> (Size: 0x10)
SGPCAssetLoadManager.PooledImpactEffectManager = 0x230 // SGPooledImpactEffectManager* (Size: 0x8)
SGPCAssetLoadManager.AvatarMergeMeshShareInfoList = 0x238 // TArray<FAvatarMergeMeshShareInfo> (Size: 0x10)
SGPCAssetLoadManager.WeaponMergeMeshShareInfoList = 0x248 // TArray<FWeaponMergeMeshShareInfo> (Size: 0x10)
SGPCAssetLoadManager.ImpactDataPreloadPath = 0x258 // FString (Size: 0x10)
SGPCAssetLoadManager.ImpactDataAssetLibrary = 0x268 // ObjectLibrary* (Size: 0x8)
SGPCAutoAimingComponent.DefaultParamsSet = 0x100 // AutoAimParamsSet* (Size: 0x8)
SGPCAutoAimingComponent.DefaultAdditionalParamsSet = 0x108 // TArray<AutoAimParamsSet*> (Size: 0x10)
SGPCAutoAimingComponent.DebugDataAsset = 0x118 // AutoAimDebugDataAsset* (Size: 0x8)
SGPCAutoAimingComponent.bOverWrittenByWeapon = 0x120 // bool (Size: 0x1)
SGPCAutoAimingComponent.bEnableAutoAiming = 0x121 // bool (Size: 0x1)
SGPCAutoAimingComponent.bDebugAutoAiming = 0x122 // bool (Size: 0x1)
SGPCAutoAimingComponent.LastFrameRecord = 0x124 // FAutoAimFrameRecord (Size: 0x84)
SGPCAutoAimingComponent.MaxTimeSicneLastRendered = 0x1a8 // float (Size: 0x4)
SGPCAutoAimingComponent.UpEnergyThresholdToEnableAutoAim = 0x1ac // float (Size: 0x4)
SGPCAutoAimingComponent.MainParamsSet = 0x1b0 // AutoAimParamsSet* (Size: 0x8)
SGPCAutoAimingComponent.AdditionalParamsSet = 0x1b8 // TArray<AutoAimParamsSet*> (Size: 0x10)
SGPCAutoAimingComponent.SnappingParamsSet = 0x1c8 // AutoAimParamsSet* (Size: 0x8)
SGPCAutoAimingComponent.Context = 0x228 // FAutoAimContext (Size: 0x2c)
SGPCAutoAimingComponent.CurrentWeapon = 0x258 // SGInventory* (Size: 0x8)
SGPCAutoAimingComponent.AntiHackStatis = 0x260 // FAutoAimAntiHackStatis (Size: 0x8)
SGPCAutoAimingComponent.LastSendRecordTime = 0x268 // float (Size: 0x4)
SGPCAutoAimingComponent.SendRecordInterval = 0x26c // float (Size: 0x4)
SGPCAutoAimingComponent.AntiHackMaxAngularSpeedH = 0x270 // float (Size: 0x4)
SGPCAutoAimingComponent.AntiHackMaxStartRangeH = 0x274 // float (Size: 0x4)
SGPCAutoAimingComponent.ServerRecordNum = 0x278 // int32_t (Size: 0x4)
SGPCAutoAimingComponent.InvalidRecordNum = 0x27c // int32_t (Size: 0x4)
SGPCAutoTestComponent.bEnable = 0x100 // bool (Size: 0x1)
SGPCAutoTestComponent.MovementSpeed = 0x104 // float (Size: 0x4)
SGPCAutoTestComponent.LocationErrorToleranceSq = 0x108 // float (Size: 0x4)
SGPCAutoTestComponent.bDumpCustomStats = 0x10c // bool (Size: 0x1)
SGPCAutoTestComponent.CachedTaticSysActor = 0x110 // TacticSystemActor* (Size: 0x8)
SGPCAutoTestComponent.GID = 0x118 // uint64_t (Size: 0x8)
SGPCAutoTestComponent.TimeLeft = 0x120 // float (Size: 0x4)
SGPCAutoTestComponent.bIsRunning = 0x124 // bool (Size: 0x1)
SGPCAutoTestComponent.AutoTestNoteList = 0x128 // TArray<FVector> (Size: 0x10)
SGPCAutoTestComponent.NextTargetNoteIndex = 0x138 // int32_t (Size: 0x4)
SGPCAutoTestComponent.LockOwner = 0x13c // EELockOwner (Size: 0x1)
SGPCAutoTestComponent.NextAbsPathNode = 0x140 // FVector (Size: 0xc)
SGPCAutoTestComponent.CachedAbsLastPos = 0x14c // FVector (Size: 0xc)
SGPCAutoTestComponent.bShouldCheckArrived = 0x158 // bool (Size: 0x1)
SGPCAutoTestComponent.bAutoSearchAndLoot = 0x159 // bool (Size: 0x1)
SGPCAutoTestComponent.bAutoSearchAndKill = 0x15a // bool (Size: 0x1)
SGPCAutoTestComponent.OverWatchPoints = 0x160 // TArray<FVector> (Size: 0x10)
SGPCAutoTestComponent.ADSDelay = 0x170 // float (Size: 0x4)
SGPCAutoTestComponent.StopFireDelay = 0x174 // float (Size: 0x4)
SGPCAutoTestComponent.SearchingRadiusForWindows = 0x178 // float (Size: 0x4)
SGPCAutoTestComponent.FireDurationForWin = 0x17c // float (Size: 0x4)
SGPCAutoTestComponent.SearchingRadiusForEnemys = 0x180 // float (Size: 0x4)
SGPCAutoTestComponent.FireDurationForEnemy = 0x184 // float (Size: 0x4)
SGPCAutoTestComponent.SearchingRadiusForBox = 0x188 // float (Size: 0x4)
SGPCAutoTestComponent.LootedActors = 0x190 // TSet<...> (Size: 0x50)
SGPCAutoTestComponent.LastAbsPosOnLooting = 0x1e0 // FVector (Size: 0xc)
SGPCBehaviorControlComponent.BehaviorControlData = 0x100 // FBehaviorControlData (Size: 0x2)
SGPCBehaviorControlComponent.LocalBehaviorControlData = 0x102 // FBehaviorControlData (Size: 0x2)
SGPCCombatRecordComponent_HD.CombatRecords = 0x100 // TArray<FCombatRecord_HD> (Size: 0x10)
SGPCCombatRecordComponent_HD.TargetInfos = 0x110 // TArray<FCombatTargetInfo_HD> (Size: 0x10)
SGPCCombatRecordComponent_HD.LatestHitCombatRecordIndex = 0x120 // int32_t (Size: 0x4)
SGPCCombatRecordComponent_HD.LatestHitTargetIndex = 0x124 // int32_t (Size: 0x4)
SGPCCombatRecordComponent_HD.OnCombatRecordUpdated = 0x128 // FMulticastInlineDelegate (Size: 0x10)
SGPCDeathCameraComponent.MinDistanceCameraToKiller = 0x100 // float (Size: 0x4)
SGPCDeathCameraComponent.MoveCameraToKillerTime = 0x104 // float (Size: 0x4)
SGPCDeathCameraComponent.KillerMoveTo = 0x138 // Character* (Size: 0x8)
SGPCFPPModeComponent.SwitchFPPEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGPCFPPModeComponent.bDefaultFPPMode = 0x110 // bool (Size: 0x1)
SGPCFPPModeComponent.bEnableAntiPeek = 0x111 // bool (Size: 0x1)
SGPCFPPModeComponent.bFPPMode = 0x112 // bool (Size: 0x1)
SGPCFlowControlComponent.PlayerEndGameType = 0x100 // EEPlayerEndGameType (Size: 0x1)
SGPCFlowControlComponent.PlayerFlowState = 0x104 // FName (Size: 0x8)
SGPCFlowControlComponent.OldState = 0x10c // FName (Size: 0x8)
SGPCFlowControlComponent.bLoadComplete = 0x114 // bool (Size: 0x1)
SGPCFlowControlComponent.IsCheckingLoad = 0x115 // bool (Size: 0x1)
SGPCFlowControlComponent.bClientQuitGame = 0x116 // bool (Size: 0x1)
SGPCFlowControlComponent.IsTimeOut = 0x117 // bool (Size: 0x1)
SGPCFlowControlComponent.MonitorFlag = 0x118 // bool (Size: 0x1)
SGPCFlowControlComponent.InitPlayerControllerLoc = 0x11c // FVector (Size: 0xc)
SGPCFlowControlComponent.InitPlayerControllerRot = 0x128 // FRotator (Size: 0xc)
SGPCFlowControlComponent.bNeedCheckCharacter = 0x134 // bool (Size: 0x1)
SGPCFlowControlComponent.bNeedCheckWeaponsRep = 0x135 // bool (Size: 0x1)
SGPCFlowControlComponent.CheckLoadTimeHandle = 0x138 // FTimerHandle (Size: 0x8)
SGPCFlowControlComponent.bNotSendComplete = 0x140 // bool (Size: 0x1)
SGPCFlowControlComponent.HasSettment = 0x141 // bool (Size: 0x1)
SGPCFlowControlComponent.PlayerWeapons = 0x148 // TArray<SGInventory*> (Size: 0x10)
SGPCFlowControlComponent.PlayerWeaponNum = 0x158 // int32_t (Size: 0x4)
SGPCFlowControlComponent.ClientCountDown = 0x164 // float (Size: 0x4)
SGPCFlowControlComponent.WorldSettingActor = 0x168 // WorldSettings* (Size: 0x8)
SGPCFlowControlComponent.BeginTimeSecond = 0x170 // float (Size: 0x4)
SGPCFlowControlComponent.CheckBeginTime = 0x178 // double (Size: 0x8)
SGPCFlowControlComponent.MaxProcessDelegateTimeInBattle = 0x180 // float (Size: 0x4)
SGPCFlowControlComponent.FirstEnterGameStateTimeSeconds = 0x184 // float (Size: 0x4)
SGPCFlowControlComponent.SkipCountNum = 0x188 // int32_t (Size: 0x4)
SGPCFlowControlComponent.LoadWaitType = 0x18c // int32_t (Size: 0x4)
SGPCInputHandleComponent.SGInputControlStruct = 0x108 // FSGInputControlStruct (Size: 0x3)
SGPCInputHandleComponent.bVehicleMoveInputPressed = 0x10b // bool (Size: 0x1)
SGPCLocalFileKillCamComponent.HttpDeathReplayInfo = 0x150 // FHttpDeathReplayInfo (Size: 0xe0)
SGPCLocalFileKillCamComponent.CachedDemoNetDriver = 0x240 // DemoNetDriver* (Size: 0x8)
SGPCLocalFileKillCamComponent.CachedReplayNetConnection = 0x248 // ReplayNetConnection* (Size: 0x8)
SGPCMCameraFOVComponent.DualFOVEnterLeaveMachine = 0x150 // FSGEnterLoopLeaveStateMachine (Size: 0x24)
SGPCMCameraFOVComponent.SceneFOVEnterLeaveMachine = 0x174 // FSGEnterLoopLeaveStateMachine (Size: 0x24)
SGPCMCameraFOVComponent.FOVBlendTimeInTacticalState = 0x198 // float (Size: 0x4)
SGPCMCameraFOVComponent.CameraFOVList = 0x1c8 // TArray<SGCameraFOV*> (Size: 0x10)
SGPCMCameraFOVComponent.CameraFOVClassList = 0x1d8 // TArray<ClassProperty> (Size: 0x10)
SGPCMCameraFOVComponent.bEnableBlendOnSwitchingViewTarget = 0x1e8 // bool (Size: 0x1)
SGPCMCameraFOVComponent.BlendTime = 0x1ec // float (Size: 0x4)
SGPCMCameraFOVComponent.CachedViewTargetPawn = 0x200 // Pawn* (Size: 0x8)
SGPCMCameraFOVComponent.CachedViewTaretForTick = 0x208 // Character* (Size: 0x8)
SGPCMCameraFOVComponent.CachedPCM = 0x210 // PlayerCameraManager* (Size: 0x8)
SGPCMCameraFOVComponent.FOVDeltaEscaped = 0x218 // float (Size: 0x4)
SGPCMCameraFOVComponent.FOVDeltaEscapedBlend = 0x220 // FAlphaBlend (Size: 0x30)
SGPCMCameraMaterialComponent.CameraMaterialClassList = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGPCMCameraMaterialComponent.MaterialWithBlurList = 0x110 // TArray<ClassProperty> (Size: 0x10)
SGPCMCameraMaterialComponent.CameraMaterialSpecList = 0x120 // TArray<FSGCameraMaterialSpec> (Size: 0x10)
SGPCMCameraShakeComponent.CameraShakeClassList = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGPCMCameraShakeComponent.CameraShakeList = 0x110 // TArray<SGCameraShakeBase*> (Size: 0x10)
SGPCMCameraShakeComponent.PlayerCameraManagerCache = 0x120 // PlayerCameraManager* (Size: 0x8)
SGPCMCameraStyleComponent.CameraStyleClasses = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGPCMCameraStyleComponent.DefaultCameraStyleClass = 0x110 // ClassProperty (Size: 0x8)
SGPCMCameraStyleComponent.CameraStyles = 0x118 // TArray<SGCameraStyle*> (Size: 0x10)
SGPCMCameraStyleComponent.DefaultCameraStyle = 0x128 // SGCameraStyle* (Size: 0x8)
SGPCMCameraStyleComponent.ChangeCameraStyleEvent = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGPCMDepthOfFieldComponent.CameraDOFClassList = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGPCMDepthOfFieldComponent.CameraDOFList = 0x110 // TArray<SGCameraDOF*> (Size: 0x10)
SGPCMDepthOfFieldComponent.ReticleClassList = 0x120 // TArray<ClassProperty> (Size: 0x10)
SGPCMDepthOfFieldComponent.ReticleEffectList = 0x130 // TArray<SGCameraDOF*> (Size: 0x10)
SGPCMDepthOfFieldComponent.CurrentActiveDOF = 0x140 // SGCameraDOF* (Size: 0x8)
SGPCMDepthOfFieldComponent.CurrentActiveReticleEffect = 0x148 // SGCameraDOF* (Size: 0x8)
SGPCMDepthOfFieldComponent.DOFBlendDuration = 0x150 // float (Size: 0x4)
SGPCMDepthOfFieldComponent.LastActiveDOF = 0x158 // SGCameraDOF* (Size: 0x8)
SGPCMDepthOfFieldComponent.ReticleBlendDuration = 0x160 // float (Size: 0x4)
SGPCMDepthOfFieldComponent.LastActiveReticleEffect = 0x168 // SGCameraDOF* (Size: 0x8)
SGPCMMirrorComponent.bMirror = 0x100 // bool (Size: 0x1)
SGPCMUpdateViewTargetComponent.CurrentCameraStyle = 0x100 // SGCameraStyle* (Size: 0x8)
SGPCMUpdateViewTargetComponent.CurrentViewTarget = 0x108 // Actor* (Size: 0x8)
SGPCMUpdateViewTargetComponent.bResetInterp = 0x110 // bool (Size: 0x1)
SGPCMUpdateViewTargetComponent.bRangeLogic = 0x111 // bool (Size: 0x1)
SGPCMotionSensorComponent.MotionRotateMode = 0x100 // EEMotionRotateMode (Size: 0x1)
SGPCMotionSensorComponent.MotionRotateSensitivity = 0x104 // float (Size: 0x4)
SGPCMotionSensorComponent.bInverseHorizontal = 0x108 // bool (Size: 0x1)
SGPCMotionSensorComponent.bInverseVertical = 0x109 // bool (Size: 0x1)
SGPCOptimizeCharacterDrawPolicyComponent.bEnableDebug = 0x100 // bool (Size: 0x1)
SGPCOptimizeCharacterDrawPolicyComponent.bEnableOptimize = 0x101 // bool (Size: 0x1)
SGPCOptimizeCharacterDrawPolicyComponent.ShowSingleMeshScreenSizeThreshold = 0x104 // float (Size: 0x4)
SGPCOptimizeCharacterDrawPolicyComponent.CheckInterval = 0x108 // float (Size: 0x4)
SGPCOptimizeCharacterDrawPolicyComponent.MaxProcessCountPerFrame = 0x10c // int32_t (Size: 0x4)
SGPCProcessPenetrationComponent.CachedCurrentWeapon = 0x100 // SGInventory* (Size: 0x8)
SGPCProcessPenetrationComponent.bCanEverEnable = 0x108 // bool (Size: 0x1)
SGPCReplayKillCamPlayComp.HUDClass = 0x100 // ClassProperty (Size: 0x8)
SGPCReplayKillCamPlayComp.Victim = 0x108 // Character* (Size: 0x8)
SGPCReplayKillCamPlayComp.VictimTeamIndex = 0x110 // int32_t (Size: 0x4)
SGPCReplayKillCamPlayComp.Killer = 0x118 // Character* (Size: 0x8)
SGPCReplayKillCamPlayComp.bIsAllActorsReady = 0x120 // int32_t (Size: 0x4)
SGPCReplayKillCamPlayComp.CachedViewtarget = 0x130 // SGCharacter* (Size: 0x8)
SGPCReplayKillCamPlayComp.PostProcessVolume = 0x138 // PostProcessVolume* (Size: 0x8)
SGPCReplayKillCamPlayComp.VictimOutlineDrawDistance = 0x150 // float (Size: 0x4)
SGPCRotateRateComponent.BaseTurnRate = 0x100 // float (Size: 0x4)
SGPCRotateRateComponent.BaseLookUpRate = 0x104 // float (Size: 0x4)
SGPCRotateRateComponent.BaseTurnRateMobile = 0x108 // float (Size: 0x4)
SGPCRotateRateComponent.BaseLookUpRateMobile = 0x10c // float (Size: 0x4)
SGPCRotateRateComponent.GlobalRotateSensitivity = 0x110 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Crouch = 0x114 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Prone = 0x118 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScaleByYawDelta_ProneTurnInPlace = 0x11c // FVector2D (Size: 0x8)
SGPCRotateRateComponent.RotateSensitivityTargetScale_ProneTurnInPlace = 0x124 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_ProneTurnInPlace = 0x128 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Run = 0x12c // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Sprint = 0x130 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Jump = 0x134 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_Aiming = 0x138 // float (Size: 0x4)
SGPCRotateRateComponent.RotateSensitivityScale_SprintStop = 0x13c // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_NoGlass = 0x144 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_RedPoint = 0x148 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_Hologram = 0x14c // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_Mechanical = 0x150 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_VSS = 0x154 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_x2 = 0x158 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_x3 = 0x15c // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_x4 = 0x160 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_x6 = 0x164 // float (Size: 0x4)
SGPCRotateRateComponent.ScopeRotateRate_x8 = 0x168 // float (Size: 0x4)
SGPCRotateRateComponent.bUseFireSensitive = 0x16c // bool (Size: 0x1)
SGPCRotateRateComponent.FireScopeRotateRate_NoGlass = 0x170 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_Mechanical = 0x174 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_RedPoint = 0x178 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x1 = 0x17c // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x2 = 0x180 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x3 = 0x184 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x4 = 0x188 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x6 = 0x18c // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_x8 = 0x190 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_VSS = 0x194 // float (Size: 0x4)
SGPCRotateRateComponent.FireScopeRotateRate_Hologram = 0x198 // float (Size: 0x4)
SGPCRotateRateComponent.CurrentRotateRateScale = 0x1d8 // float (Size: 0x4)
SGPCRoundControlComponent.CountDownBeginTime = 0x100 // float (Size: 0x4)
SGPCRoundControlComponent.MaxCountTime = 0x104 // float (Size: 0x4)
SGPCRoundControlComponent.EndingInfo = 0x108 // FMPGameEndingInfo (Size: 0x10)
SGPCServerCommandComponent.ParticleSystemComponentArray = 0x100 // TArray<ParticleSystemComponent*> (Size: 0x10)
SGPCServerCommandComponent.PlayerStartArray = 0x110 // TArray<PlayerStart*> (Size: 0x10)
SGPCServerCommandComponent.MyController = 0x128 // Controller* (Size: 0x8)
SGPCServerCommandComponent.FakeCharacterClassList = 0x130 // TArray<ClassProperty> (Size: 0x10)
SGPCServerCommandComponent.TestAvatarList = 0x140 // TArray<ClassProperty> (Size: 0x10)
SGPCSettlementComponent.SettlementConfig = 0x100 // TMap<...> (Size: 0x50)
SGPCSettlementComponent.PlayerTouchSettlementType = 0x150 // EEPlayerTouchSettlementType (Size: 0x1)
SGPCSpectatingComponent.fCameraFOVScale = 0x100 // float (Size: 0x4)
SGPCSpectatingComponent.fCachedCameraFOV = 0x104 // float (Size: 0x4)
SGPCSpectatingComponent.bMovieRecordingMode = 0x108 // bool (Size: 0x1)
SGPCSpectatingComponent.OBSpectateState = 0x109 // EEOBSpectateState (Size: 0x1)
SGPCSpectatingComponent.LastGoalYaw = 0x10c // float (Size: 0x4)
SGPCSpectatingComponent.FinalViewTarget = 0x110 // Actor* (Size: 0x8)
SGPCSpectatingComponent.OldViewTarget = 0x118 // Actor* (Size: 0x8)
SGPCSpectatingComponent.StartSpectatingTime = 0x120 // float (Size: 0x4)
SGPCSpectatingComponent.StartRoundSpectatingTime = 0x124 // float (Size: 0x4)
SGPCSpectatingComponent.OBPlayerAfterDeathAutoSpectatingTime = 0x128 // float (Size: 0x4)
SGPCSpectatingComponent.bOnlySpectatingTeammate = 0x12c // bool (Size: 0x1)
SGPCSpectatingComponent.bDisabelSpectating = 0x12d // bool (Size: 0x1)
SGPCSpectatingComponent.CurrentPlayerState = 0x130 // PlayerState* (Size: 0x8)
SGPCSpectatingComponent.RealtimeViewTarget = 0x138 // Actor* (Size: 0x8)
SGPCSpectatingComponent.CachePlayerController = 0x140 // PlayerController* (Size: 0x8)
SGPCSpectatingComponent.ViewTargetBindingCharacter = 0x148 // SGCharacter* (Size: 0x8)
SGPCSpectatingComponent.DoSpectateRequestViewTarget = 0x150 // Actor* (Size: 0x8)
SGPCSpectatingComponent.OriginViewTarget = 0x158 // Character* (Size: 0x8)
SGPCSpectatingComponent.SpectatingBanTime = 0x17c // uint32_t (Size: 0x4)
SGPCSpectatingComponent.RecommendGIDS = 0x188 // TArray<uint64_t> (Size: 0x10)
SGPCSpectatingComponent.SpectatedTimeSecondsConfToRecommend = 0x198 // float (Size: 0x4)
SGPCStatisComponent.IsOpenReport = 0xf8 // bool (Size: 0x1)
SGPCStatisComponent.MaxSpawnActorMilliseconds = 0xfc // float (Size: 0x4)
SGPCStatisComponent.DeviceLevel_Config = 0x100 // TMap<...> (Size: 0x50)
SGPCStatisComponent.CurSelectConfigParam = 0x150 // FStatisDefaultParams (Size: 0x18)
SGPCStatisComponent.CurReportStatisInfo = 0x168 // FPCReportStatisInfo (Size: 0x24)
SGPCStatisComponent.bEnableLogic = 0x1a0 // bool (Size: 0x1)
SGPCStatisComponent.SvrMaxPing = 0x1a4 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrMinPing = 0x1a8 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrAvgPing = 0x1ac // int32_t (Size: 0x4)
SGPCStatisComponent.SvrStddevPing = 0x1b0 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrPingTimes = 0x1b4 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrAbnormalPingTimes = 0x1b8 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrMaxPingCount = 0x1d8 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrAbnormalPingConfInMS = 0x1dc // int32_t (Size: 0x4)
SGPCStatisComponent.SvrReconnectTimes = 0x1e0 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrReLoginTimes = 0x1e4 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrRewriteTimes = 0x1e8 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrDupAckTimes = 0x1ec // int32_t (Size: 0x4)
SGPCStatisComponent.SvrWnzpReqTimes = 0x1f0 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrPosPullTimes = 0x1f4 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrKickReason = 0x1f8 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrPlayerDuration = 0x1fc // int32_t (Size: 0x4)
SGPCStatisComponent.SvrSrcDev = 0x200 // int32_t (Size: 0x4)
SGPCStatisComponent.SvrDsSvrIP = 0x208 // FString (Size: 0x10)
SGPCStatisComponent.SvrListenIP = 0x218 // FString (Size: 0x10)
SGPCStatisComponent.SvrListenPort = 0x228 // int32_t (Size: 0x4)
SGPCStatisComponent.CharacterAvgMoveCountPerFrame = 0x22c // float (Size: 0x4)
SGPCStatisComponent.CharacterAvgFastMoveCountPerFrame = 0x230 // float (Size: 0x4)
SGPCStatisComponent.Sum3PLocDiff = 0x234 // float (Size: 0x4)
SGPCThermalViewComponent.bThermalViewActived = 0x100 // bool (Size: 0x1)
SGPCThermalViewComponent.ThermalMaterialParameterCollection = 0x108 // MaterialParameterCollection* (Size: 0x8)
SGPCThermalViewComponent.EnabledParameterName = 0x110 // FName (Size: 0x8)
SGPCThermalViewComponent.ThermalViewEV100 = 0x118 // float (Size: 0x4)
SGPCThermalViewComponent.TimeLerpToThermalViewEV100 = 0x11c // float (Size: 0x4)
SGPCThermalViewComponent.ModeParameterName = 0x120 // FName (Size: 0x8)
SGPCThermalViewComponent.CacheSourceInventory = 0x130 // SGInventory* (Size: 0x8)
SGPCThermalViewComponent.SourceHeadwearInventory = 0x158 // SGInventory* (Size: 0x8)
SGPCThermalViewComponent.SourceScopeInventory = 0x160 // SGInventory* (Size: 0x8)
SGPCThermalViewComponent.DefaultThermalImagerParams = 0x168 // TArray<FSGThermalImagerParams> (Size: 0x10)
SGPCThermalViewComponent.OnThermalViewStateChanged = 0x178 // FMulticastInlineDelegate (Size: 0x10)
SGPCThermalViewComponent.PostProcessVolume = 0x190 // PostProcessVolume* (Size: 0x8)
SGPCWatchGameComponent.WatchGameSettleData = 0x100 // FSGWatchGameSettleData (Size: 0x108)
SGPCWatchGameComponent.KillerTitle = 0x208 // int32_t (Size: 0x4)
SGPCWatchGameComponent.WatchGameState = 0x20c // EEWatchGameState (Size: 0x1)
SGPCWeaponAssembleComponent.AssembleSceneClass = 0x100 // ClassProperty (Size: 0x8)
SGPCWeaponAssembleComponent.AssembleScene = 0x108 // SGWeaponAssembleEnvironment* (Size: 0x8)
SGPCWeaponAssembleComponent.AssembleSceneWorld = 0x110 // SGWeaponAssembleEnvironment* (Size: 0x8)
SGPCWeaponAssembleComponent.SpawnLocationOffset = 0x118 // float (Size: 0x4)
SGPCWeaponAssembleComponent.SpawnRotationOffset = 0x11c // FRotator (Size: 0xc)
SGPCZoneInfoManagerComponent.ZoneInfoComponentArray = 0x100 // TArray<SGActorZoneInfoComponentBase*> (Size: 0x10)
SGPSChatInboxComponent.CurIndex = 0x100 // uint32_t (Size: 0x4)
SGPSChatInboxComponent.Capacity = 0x104 // uint32_t (Size: 0x4)
SGPSChatInboxComponent.AllContents = 0x108 // TArray<FSGSingleChatContent> (Size: 0x10)
SGPSFlowStateComponent.FlowState = 0x100 // FName (Size: 0x8)
SGPSZoneInfoManagerComponent.ZoneInfoComponentArray = 0x100 // TArray<SGActorZoneInfoComponentBase*> (Size: 0x10)
SGParadropBase.PushCharacterHeight = 0x318 // float (Size: 0x4)
SGParadropBase.PushCharacterDistanceXYOffset = 0x31c // float (Size: 0x4)
SGParadropBase.DefaultPushDirection = 0x320 // FVector (Size: 0xc)
SGParadropBase.PushCharacterVelocityCoefficient = 0x32c // float (Size: 0x4)
SGParadropBase.PushCharacterFinalLocationVerificationCoefficient = 0x330 // float (Size: 0x4)
SGParadropBase.PushCharacterFinalVelocityVerificationCoefficient = 0x334 // float (Size: 0x4)
SGParadropBase.BackupCharacterTeleportLocationZOffset = 0x338 // float (Size: 0x4)
SGParadropBase.TransformReplicationFrequency = 0x33c // float (Size: 0x4)
SGParadropBase.ParadropWaveRowName = 0x340 // FName (Size: 0x8)
SGParadropBase.ParadropState = 0x350 // EESGParadropState (Size: 0x1)
SGParadropBase.ParadropCarrierPart = 0x358 // Actor* (Size: 0x8)
SGParadropBase.ParadropPayloadPart = 0x360 // Actor* (Size: 0x8)
SGParadropBase.TargetLandingLocation = 0x368 // FVector (Size: 0xc)
SGParadropBase.TargetLandingRotation = 0x374 // FRotator (Size: 0xc)
SGParadropBase.ActualLandingLocation = 0x380 // FVector (Size: 0xc)
SGParadropBase.ActualLandingRotation = 0x38c // FRotator (Size: 0xc)
SGParadropBase.bParadropDamaged = 0x398 // bool (Size: 0x1)
SGParadropBase.BeingPushedCharacters = 0x3a0 // TArray<Character*> (Size: 0x10)
SGParadropBigGroupInfo.BigGroup = 0x0 // int32_t (Size: 0x4)
SGParadropBigGroupInfo.Priority = 0x4 // int32_t (Size: 0x4)
SGParadropBigGroupInfo.PriorityReduction = 0x8 // int32_t (Size: 0x4)
SGParadropBigGroupInfo.GroupInfos = 0x10 // TArray<FSGParadropGroupInfo> (Size: 0x10)
SGParadropConfigTableRow.ActIDs = 0x20 // TArray<int32_t> (Size: 0x10)
SGParadropConfigTableRow.CachedRowName = 0x30 // FName (Size: 0x8)
SGParadropConfigTableRow.LevelName = 0x38 // FString (Size: 0x10)
SGParadropConfigTableRow.ParadropWaveConfigTableRowNames = 0x48 // TArray<FName> (Size: 0x10)
SGParadropConfigTableRow.CalledParadropWaveConfigTableRowName = 0x58 // FName (Size: 0x8)
SGParadropConfigTableRow.BigGroupInfos = 0x60 // TArray<FSGParadropBigGroupInfo> (Size: 0x10)
SGParadropDetailInfo.ParadropBaseClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
SGParadropDetailInfo.ParadropCarrierClass = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
SGParadropDetailInfo.ParadropPayloadClass = 0x50 // TSoftClassPtr<UObject> (Size: 0x28)
SGParadropDetailInfo.ParadropRequiredFallingChannelRadius = 0x78 // float (Size: 0x4)
SGParadropDetailInfo.ParadropRequiredFlatGroundRadius = 0x7c // float (Size: 0x4)
SGParadropGroupInfo.GroupIndex = 0x0 // int32_t (Size: 0x4)
SGParadropGroupInfo.Weight = 0x4 // int32_t (Size: 0x4)
SGParadropGroupInfo.WeightReduction = 0x8 // int32_t (Size: 0x4)
SGParadropManagerComponent.ParadropRadius = 0x108 // float (Size: 0x4)
SGParadropManagerComponent.LandingOffset = 0x10c // bool (Size: 0x1)
SGParadropManagerComponent.NavSkeletonQueryLength = 0x110 // float (Size: 0x4)
SGParadropManagerComponent.NavSkeletonQueryHeight = 0x114 // float (Size: 0x4)
SGParadropManagerComponent.RetryNumInNavSkeletonQueryResults = 0x118 // int32_t (Size: 0x4)
SGParadropManagerComponent.MaxCalledParadropNumPerCharacter = 0x11c // int32_t (Size: 0x4)
SGParadropManagerComponent.DefaultValidCallParadropTimePeriod = 0x120 // FVector2D (Size: 0x8)
SGParadropManagerComponent.ValidCallParadropTimePeriodOverrideMapByTotalGameDuration = 0x128 // TMap<...> (Size: 0x50)
SGParadropManagerComponent.CalledParadropNumMap = 0x198 // TMap<...> (Size: 0x50)
SGParadropWaveInfo.Probability = 0x8 // int32_t (Size: 0x4)
SGParadropWaveInfo.MinTime = 0xc // int32_t (Size: 0x4)
SGParadropWaveInfo.MaxTime = 0x10 // int32_t (Size: 0x4)
SGParadropWaveInfo.MinNum = 0x14 // int32_t (Size: 0x4)
SGParadropWaveInfo.MaxNum = 0x18 // int32_t (Size: 0x4)
SGParadropWaveInfo.ValidGroupIndexs = 0x20 // TArray<int32_t> (Size: 0x10)
SGParadropWaveInfo.SpecialReplaceProbability = 0x30 // int32_t (Size: 0x4)
SGParadropWaveInfo.NormalParadropDetail = 0x38 // TArray<FSGParadropDetailInfo> (Size: 0x10)
SGParadropWaveInfo.SpecialParadropDetail = 0x48 // TArray<FSGParadropDetailInfo> (Size: 0x10)
SGParadropWaveInfo.PlaneClass = 0x58 // TSoftClassPtr<UObject> (Size: 0x28)
SGParadropWaveInfo.Radius = 0x80 // int32_t (Size: 0x4)
SGParadropWaveInfo.Height = 0x84 // int32_t (Size: 0x4)
SGParadropWaveInfo.AdjustmentHeight = 0x88 // int32_t (Size: 0x4)
SGParadropWaveInfo.PlaneSpeed = 0x8c // int32_t (Size: 0x4)
SGParadropWaveInfo.PlaneEndAudioEvent = 0x90 // TSoftObjectPtr<UObject> (Size: 0x28)
SGParadropWaveInfo.PlaneStartAudioEvent = 0xb8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGParadropWaveInfo.Pre_PassivityTraceConfigID = 0xe0 // int32_t (Size: 0x4)
SGParadropWaveInfo.PassivityTarceParadropState = 0xe4 // EESGParadropState (Size: 0x1)
SGParadropWaveInfo.PassivityTaraceConfigID = 0xe8 // int32_t (Size: 0x4)
SGParadropWaveInfo.BroadcastConfig = 0xf0 // TMap<...> (Size: 0x50)
SGParticleModule_KillDistance.Distance = 0x30 // FRawDistributionFloat (Size: 0x30)
SGParticleModule_KillDistance.bConsiderSize = 0x60 // bool (Size: 0x1)
SGPerIventoryAccessoryAnimationSets.WeaponAnimationSet = 0x28 // FSGWeaponAccesoryAnimationSet (Size: 0x8)
SGPerLocationAvatarAnimationSet.OutsideAvatarSet = 0x0 // TMap<...> (Size: 0x50)
SGPerWeaponAnimSetAnimNotifyStateConfig.NotifyStateClass = 0x0 // ClassProperty (Size: 0x8)
SGPerWeaponAnimSetAnimNotifyStateConfig.PropertyNameToNotifyStateDuration = 0x8 // TMap<...> (Size: 0x50)
SGPerWeaponAnimSetDuplicateConfig.PerWeaponAnimSetToDuplicate = 0x0 // Object* (Size: 0x8)
SGPerWeaponAnimSetDuplicateConfig.OutPathSet = 0x8 // FString (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.OutPathHand = 0x18 // FString (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.OutPathWeapon = 0x28 // FString (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.PropertiesToDuplicateHand = 0x38 // TArray<FName> (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.PropertiesToDuplicateWeapon = 0x48 // TArray<FName> (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.PropertiesNotToDuplicateHand = 0x58 // TArray<FName> (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.PropertiesNotToDuplicateWeapon = 0x68 // TArray<FName> (Size: 0x10)
SGPerWeaponAnimSetDuplicateConfig.bAutoSave = 0x78 // bool (Size: 0x1)
SGPerWeaponAnimSetDuplicateConfig.bOverrideCurve = 0x79 // bool (Size: 0x1)
SGPerWeaponAnimSetDuplicateConfig.NotifyStateConfig = 0x80 // FSGPerWeaponAnimSetAnimNotifyStateConfig (Size: 0x58)
SGPerWeaponAnimSetDuplicateConfig.ReplaceHandMontageByPropertyNameMap = 0xd8 // TMap<...> (Size: 0x50)
SGPerWeaponAnimSetDuplicateConfig.ReplaceWeaponMontageByPropertyNameMap = 0x128 // TMap<...> (Size: 0x50)
SGPerWeaponAvatarAnimationSet.DefaultOutsideAvatarSet = 0x0 // FSGOutsideAvatarAnimationSet (Size: 0xc8)
SGPerWeaponAvatarAnimationSet.WeaponIdToOutsideAvatarSet = 0xc8 // TMap<...> (Size: 0x50)
SGPickUpGroup.bRunOnBeginPlay = 0x311 // bool (Size: 0x1)
SGPickUpGroup.PickUpGroupType = 0x312 // EESGPickUpGroupType (Size: 0x1)
SGPickUpGroup.PickupGroupsConfig = 0x318 // TArray<FSGPickupGroupParams> (Size: 0x10)
SGPickUpGroup.RangePickupGroupCount = 0x328 // int32_t (Size: 0x4)
SGPickUpGroup.PickupSingleConfig = 0x330 // FSGPickupSingleParams (Size: 0x10)
SGPickup.FromLootSubAreaVolume = 0x310 // SGLootSubAreaVolume* (Size: 0x8)
SGPickupGroupParams.Pickup = 0x0 // SGPickup* (Size: 0x8)
SGPickupGroupParams.Weight = 0x8 // int32_t (Size: 0x4)
SGPickupSingleParams.Pickup = 0x0 // SGPickup* (Size: 0x8)
SGPickupSingleParams.Probability = 0x8 // int32_t (Size: 0x4)
SGPivotCardinalsAnimation.Forward = 0x0 // AnimSequence* (Size: 0x8)
SGPivotCardinalsAnimation.Backward = 0x8 // AnimSequence* (Size: 0x8)
SGPivotCardinalsAnimation.Left = 0x10 // AnimSequence* (Size: 0x8)
SGPivotCardinalsAnimation.Right = 0x18 // AnimSequence* (Size: 0x8)
SGPlaceItemTableRow.ItemId = 0x8 // int32_t (Size: 0x4)
SGPlaceItemTableRow.ItemMesh = 0x10 // StaticMesh* (Size: 0x8)
SGPlayerActivityItemInfoComponent.BlackStoreTicketNum = 0x100 // int32_t (Size: 0x4)
SGPlayerActivityItemInfoComponent.AlreadyUseTicketNum = 0x104 // int32_t (Size: 0x4)
SGPlayerActivityItemInfoComponent.AlreadyBuyItemList = 0x108 // TArray<FBlackStoreAlreadyBuyInfo> (Size: 0x10)
SGPlayerActivityItemInfoComponent.CoinMoneyNum = 0x118 // int64_t (Size: 0x8)
SGPlayerActivityItemInfoComponent.AlreadyUseMoneyNum = 0x120 // int64_t (Size: 0x8)
SGPlayerBannerInfo.ImageID = 0x0 // uint32_t (Size: 0x4)
SGPlayerBannerInfo.FrameID = 0x4 // uint32_t (Size: 0x4)
SGPlayerBannerInfo.BannerBadges = 0x8 // TArray<FSGPlayerRoleBannerBadge> (Size: 0x10)
SGPlayerBannerInfo.BannerCustomData = 0x18 // TArray<FSGPlayerRoleBannerCustomData> (Size: 0x10)
SGPlayerCameraManager.ComponentClasses = 0x3040 // TArray<ClassProperty> (Size: 0x10)
SGPlayerCameraManager.ComponentClassesAdditional = 0x3050 // TArray<ClassProperty> (Size: 0x10)
SGPlayerCameraManager.TemplateClass = 0x3060 // ClassProperty (Size: 0x8)
SGPlayerCameraManager.CachedMaterialComponent = 0x3068 // SGPCMCameraMaterialComponent* (Size: 0x8)
SGPlayerCameraManager.CachedCameraDOFComponent = 0x3070 // SGPCMDepthOfFieldComponent* (Size: 0x8)
SGPlayerCameraManager.bEnableModifyRotationByMotionSensor = 0x3078 // bool (Size: 0x1)
SGPlayerCameraManager.bEnableModifyRotationByWeaponRecoil = 0x3079 // bool (Size: 0x1)
SGPlayerCameraManager.bEnableModifyRotationByAutoAiming = 0x307a // bool (Size: 0x1)
SGPlayerCameraManager.bEnableModifyRotationByForceLookingAt = 0x307b // bool (Size: 0x1)
SGPlayerCameraManager.ThisFrameBeforeCameraShakeRotator = 0x307c // FRotator (Size: 0xc)
SGPlayerCameraManager.PCMFOVComponent = 0x30b0 // SGPCMCameraFOVComponent* (Size: 0x8)
SGPlayerCameraManager.CameraShakeComponent = 0x30b8 // SGPCMCameraShakeComponent* (Size: 0x8)
SGPlayerController.bDebugShowDamageInformation = 0x680 // bool (Size: 0x1)
SGPlayerController.PadVisibilityRowName = 0x688 // FString (Size: 0x10)
SGPlayerController.CharacterCaptureActorClass = 0x698 // ClassProperty (Size: 0x8)
SGPlayerController.bEnableCharacterCapture = 0x6a0 // bool (Size: 0x1)
SGPlayerController.SettingPostProcessPreviewActorClass = 0x6a8 // ClassProperty (Size: 0x8)
SGPlayerController.SoundIndicator = 0x6b0 // SoundIndicator* (Size: 0x8)
SGPlayerController.SoundIndicatorClass = 0x6b8 // ClassProperty (Size: 0x8)
SGPlayerController.PlayerInputClass = 0x6c0 // TSoftClassPtr<UObject> (Size: 0x28)
SGPlayerController.SGPlayerInput = 0x6f8 // SGPlayerInput* (Size: 0x8)
SGPlayerController.LastTouchLocation = 0x700 // FVector2D (Size: 0x8)
SGPlayerController.PawnPendingDestroyEvent = 0x708 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnProcessPawn = 0x718 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnUnPossessPawn = 0x728 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnEscaped = 0x738 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnViewTargetChanged = 0x748 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnPlayerZoomChanged = 0x758 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnCheckFireDown = 0x768 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnOperated = 0x778 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.PlayerStart = 0x798 // PlayerStart* (Size: 0x8)
SGPlayerController.DebugCompInfoClasses = 0x7a0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
SGPlayerController.OnAutoMoveFin = 0x7b0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnAutoMoveDir = 0x7c0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.OnArrivedAtLocationDelegate = 0x7d0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerController.bAllowStrafe = 0x7e0 // uint8_t (Size: 0x1)
SGPlayerController.DefaultNavigationFilterClass = 0x7e8 // ClassProperty (Size: 0x8)
SGPlayerController.PathFollowingComponent = 0x810 // PathFollowingComponent* (Size: 0x8)
SGPlayerController.bAllowInMemoryReplay = 0x818 // bool (Size: 0x1)
SGPlayerController.CharacterCaptureActor = 0x820 // SGCharacterCaptureActor* (Size: 0x8)
SGPlayerController.SettingPostProcessPreviewActor = 0x828 // Actor* (Size: 0x8)
SGPlayerController.UIModeComponent = 0x830 // SGPCUIModeComponent* (Size: 0x8)
SGPlayerController.PCStatisComponent = 0x838 // SGPCStatisComponent* (Size: 0x8)
SGPlayerController.SpectatingComponent = 0x840 // SGPCSpectatingComponent* (Size: 0x8)
SGPlayerController.FPPModeComponent = 0x848 // SGPCFPPModeComponent* (Size: 0x8)
SGPlayerController.PCFlowControllerComponent = 0x850 // SGPCFlowControlComponent* (Size: 0x8)
SGPlayerController.bMoveTimeDiffEnable = 0x862 // bool (Size: 0x1)
SGPlayerController.TimeOutValue = 0x864 // int32_t (Size: 0x4)
SGPlayerController.DSSwitchConfig = 0x868 // FDSSwitchConfig (Size: 0xc)
SGPlayerController.NewTraceInfoIndex = 0x874 // int32_t (Size: 0x4)
SGPlayerController.IsReconnectPlayer = 0x87c // bool (Size: 0x1)
SGPlayerController.EndGameType = 0x880 // int32_t (Size: 0x4)
SGPlayerController.HasBeginGame = 0x884 // bool (Size: 0x1)
SGPlayerController.FinishType = 0x885 // EEPlayerEndGameType (Size: 0x1)
SGPlayerController.nGetAttachLoopMaxNum = 0x888 // int32_t (Size: 0x4)
SGPlayerController.InputFlowDataSplitSize = 0x894 // int32_t (Size: 0x4)
SGPlayerController.ControlledCharacter = 0x8e0 // SGCharacter* (Size: 0x8)
SGPlayerController.CachedReachableConnection = 0x8e8 // NetConnection* (Size: 0x8)
SGPlayerController.ForgiveJudgeTime = 0x8f0 // float (Size: 0x4)
SGPlayerController.HitSelfTeammates = 0x8f8 // TArray<SGCharacter*> (Size: 0x10)
SGPlayerController.bShowStrongTrajectory = 0x908 // bool (Size: 0x1)
SGPlayerController.OBTrajectoryDistance = 0x90c // float (Size: 0x4)
SGPlayerController.AIDebugComponentClass = 0x910 // ClassProperty (Size: 0x8)
SGPlayerController.EscapePointIDs = 0x918 // TArray<int32_t> (Size: 0x10)
SGPlayerController.PlayerStartLocation = 0x928 // FVector (Size: 0xc)
SGPlayerController.GlobalInputComponentClass = 0x938 // ClassProperty (Size: 0x8)
SGPlayerController.GlobalInputComponent = 0x940 // InputComponent* (Size: 0x8)
SGPlayerController.bShouldUseTeleportCheckFrames = 0x948 // bool (Size: 0x1)
SGPlayerController.bAutoCheckAndStopHurryLoad = 0x949 // bool (Size: 0x1)
SGPlayerControllerEvents.OnLoadComplete = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnProcessPawn = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPreUnPossessPawn = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnUnPossessPawn = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnRepPawn = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnRepLastPawn = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnSetPawn = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnFlowStateChange = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPreReconnect = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnReconnect = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPostReconnect = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.ConnectionIssueForClientEvent = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.ConnectionCleanUpEvent = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OutOfAmmoEvent = 0x100 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OutOfGrenadeEvent = 0x110 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OutOfUpperEnergy = 0x120 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OutOfLowerEnergy = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnOutOfHealth = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnGameplayEffectBleed = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnGameplayEffectOutOfEndurance = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnChangeClipDetected = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnEscapePointsChange = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnStartLocationChanged = 0x190 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPassCheckPointIDsChange = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnHasExploratedPointIDsChange = 0x1b0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnNewHUDReport = 0x1c0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnReturnToHallRoom = 0x1d0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnStartSpectating = 0x1e0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnBanSpectating = 0x1f0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnStartSpectatingDistance = 0x200 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPreStartSpectating = 0x210 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnSpectatingUIOp = 0x220 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnSpectatingStop = 0x230 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.ClientLevelLoadComplete = 0x240 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPlayerBeginGame = 0x250 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPlayerSettle = 0x260 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnSpectatChange = 0x270 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnAutoZoom = 0x280 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.DSReserveReport = 0x2c0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnSpray = 0x2d0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnClientFinishTypeChange = 0x2e0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnPlayerStateBeBanSpectated = 0x2f0 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnRoundControlStateChanged = 0x300 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnMPGameWeaponGiven = 0x310 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnMPGameEnding = 0x320 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnRebornSaftyStateChanged = 0x330 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerControllerEvents.OnTDMKilledV2 = 0x340 // FMulticastInlineDelegate (Size: 0x10)
SGPlayerDebuffInfoBase.BodyPart = 0xf8 // uint8_t (Size: 0x1)
SGPlayerDebuffInfoBase.BuffId = 0xfc // uint32_t (Size: 0x4)
SGPlayerDebuffInfoBase.RemainingTime = 0x100 // int64_t (Size: 0x8)
SGPlayerEquipInfo.EquipPlayeritemList = 0x0 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerEquipInfo.ExtendPlayeritemList = 0x10 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerEquipInfo.AvatarGender = 0x20 // EECharacterSex (Size: 0x1)
SGPlayerEquipInfo.AvatarItems = 0x28 // TArray<FSGAvatarInfo> (Size: 0x10)
SGPlayerEquipInfo.bBodyStatus = 0x38 // uint32_t (Size: 0x4)
SGPlayerEquipInfo.BadgeItems = 0x40 // TArray<FSGBadgeInfo> (Size: 0x10)
SGPlayerEquipInfo.EliminatePlayeritemList = 0x50 // TArray<FEliminateInventoryGridInfo> (Size: 0x10)
SGPlayerIconInfo.Name = 0x0 // FString (Size: 0x10)
SGPlayerIconInfo.Level = 0x10 // int32_t (Size: 0x4)
SGPlayerIconInfo.Rank = 0x14 // int32_t (Size: 0x4)
SGPlayerIconInfo.TitleInfo = 0x18 // FSGPlayerTitleInfo (Size: 0x1c)
SGPlayerIconInfo.AvatarUrl = 0x38 // FString (Size: 0x10)
SGPlayerIconInfo.HeadBoxID = 0x48 // int32_t (Size: 0x4)
SGPlayerIconInfo.HeadPicID = 0x4c // int32_t (Size: 0x4)
SGPlayerIconInfo.NameCard = 0x50 // int32_t (Size: 0x4)
SGPlayerIconInfo.PrivilegeLevel = 0x54 // uint32_t (Size: 0x4)
SGPlayerInput.LeftFireBtnPressed = 0x3d0 // bool (Size: 0x1)
SGPlayerInput.RightFireBtnPressed = 0x3d1 // bool (Size: 0x1)
SGPlayerInput.DefaultSensitivitySettingScale = 0x44c // float (Size: 0x4)
SGPlayerInput.DefaultSensitivitySettingScaleNormal = 0x450 // float (Size: 0x4)
SGPlayerInput.DefaultSensitivitySettingScaleOnFire = 0x454 // float (Size: 0x4)
SGPlayerInput.DefaultSensitivitySettingScaleGyro = 0x458 // float (Size: 0x4)
SGPlayerInput.DefaultSensitivityCurveNormal = 0x460 // CurveFloat* (Size: 0x8)
SGPlayerInput.DefaultSensitivityCurveOnFire = 0x468 // CurveFloat* (Size: 0x8)
SGPlayerInput.DefaultSensitivityCurveGyro = 0x470 // CurveFloat* (Size: 0x8)
SGPlayerInput.MagFOVConfig = 0x478 // TArray<FMagFOVRaw> (Size: 0x10)
SGPlayerInput.CustomSensitivitySetting = 0x488 // FMagnificationSensitivitySetting (Size: 0xf0)
SGPlayerItemInfoBase.GID = 0x28 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.ItemId = 0x30 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.ItemNum = 0x38 // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.IsRotated = 0x3c // bool (Size: 0x1)
SGPlayerItemInfoBase.IsRolldeUp = 0x3d // bool (Size: 0x1)
SGPlayerItemInfoBase.IsHelmetDisabled = 0x3e // bool (Size: 0x1)
SGPlayerItemInfoBase.FSBreakList = 0x40 // int32_t (Size: 0x4)
SGPlayerItemInfoBase.IsFoldButt = 0x44 // bool (Size: 0x1)
SGPlayerItemInfoBase.IsBlackLoot = 0x45 // bool (Size: 0x1)
SGPlayerItemInfoBase.IsFaction = 0x46 // bool (Size: 0x1)
SGPlayerItemInfoBase.IsDarkZoneItem = 0x47 // bool (Size: 0x1)
SGPlayerItemInfoBase.IsCanNotSellItem = 0x48 // bool (Size: 0x1)
SGPlayerItemInfoBase.IsFunctionDisabled = 0x49 // bool (Size: 0x1)
SGPlayerItemInfoBase.ExpireTime = 0x4c // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.Pos = 0x50 // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.Durability = 0x54 // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.MaxDurability = 0x58 // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.ItemPosition = 0x5c // FItemGridInfo (Size: 0x8)
SGPlayerItemInfoBase.InContainerIndex = 0x64 // int32_t (Size: 0x4)
SGPlayerItemInfoBase.SocketIndex = 0x68 // int32_t (Size: 0x4)
SGPlayerItemInfoBase.ParentFakeID = 0x70 // int64_t (Size: 0x8)
SGPlayerItemInfoBase.ParentUSGPlayerItemInfoGID = 0x78 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.TakeInPlayerGID = 0x80 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.InsureType = 0x88 // int32_t (Size: 0x4)
SGPlayerItemInfoBase.DogTagLevel = 0x8c // int32_t (Size: 0x4)
SGPlayerItemInfoBase.SpecialInfoIntParams = 0x90 // TArray<uint64_t> (Size: 0x10)
SGPlayerItemInfoBase.SpecialInfoStrParams = 0xa0 // TArray<FString> (Size: 0x10)
SGPlayerItemInfoBase.DeathCharacterName = 0xb0 // FString (Size: 0x10)
SGPlayerItemInfoBase.DeathCharacterGID = 0xc0 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.OldGID = 0xc8 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.OldTakeInPlayerGID = 0xd0 // uint64_t (Size: 0x8)
SGPlayerItemInfoBase.StackableItemSourceInfos = 0xd8 // TArray<FStackableItemSourceInfo> (Size: 0x10)
SGPlayerItemInfoBase.SpawnSourceType = 0xe8 // int32_t (Size: 0x4)
SGPlayerItemInfoBase.PendantID = 0xec // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.SkinID = 0xf0 // uint32_t (Size: 0x4)
SGPlayerItemInfoBase.bGeneratedAsPendant = 0xf4 // bool (Size: 0x1)
SGPlayerItemInfoBase.ActivitySignIDArr = 0xf8 // TArray<int32_t> (Size: 0x10)
SGPlayerItemInfoBase.ChildPlayerInfoList = 0x108 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerItemInfoBase.IsSingleOfficeInv = 0x118 // bool (Size: 0x1)
SGPlayerItemInfoBase.InventoryTakeOutTag = 0x120 // FSGInventoryTakeOutTag (Size: 0x20)
SGPlayerMonitorSubsystem.PlayerRecordClass = 0x30 // ClassProperty (Size: 0x8)
SGPlayerMonitorSubsystem.PlayerRecordMap = 0x38 // TMap<...> (Size: 0x50)
SGPlayerMonitorSubsystem.PlayerTagMap = 0x88 // TMap<...> (Size: 0x50)
SGPlayerRecord.PlayerCharacter = 0x28 // Character* (Size: 0x8)
SGPlayerRecord.LootTimes = 0x30 // int32_t (Size: 0x4)
SGPlayerRecord.LastTimeLoot = 0x34 // float (Size: 0x4)
SGPlayerRecord.StandTime = 0x40 // float (Size: 0x4)
SGPlayerRecord.CrouchTime = 0x44 // float (Size: 0x4)
SGPlayerRecord.ProneTime = 0x48 // float (Size: 0x4)
SGPlayerRecord.LastTimeChangePose = 0x4c // float (Size: 0x4)
SGPlayerRecord.StayTime = 0x54 // float (Size: 0x4)
SGPlayerRecord.SilentWalkTime = 0x58 // float (Size: 0x4)
SGPlayerRecord.WalkTime = 0x5c // float (Size: 0x4)
SGPlayerRecord.SprintTime = 0x60 // float (Size: 0x4)
SGPlayerRecord.LastTimeChangeMoveType = 0x64 // float (Size: 0x4)
SGPlayerRecord.MoveVector_10s = 0x78 // FVector (Size: 0xc)
SGPlayerRecord.MoveVector_60s = 0x94 // FVector (Size: 0xc)
SGPlayerRecord.ADSTime = 0xa8 // float (Size: 0x4)
SGPlayerRecord.LastTimeChangeADS = 0xac // float (Size: 0x4)
SGPlayerRecord.FireTimes = 0xb0 // int32_t (Size: 0x4)
SGPlayerRecord.HitTimes = 0xb4 // int32_t (Size: 0x4)
SGPlayerRecord.LastTimeFire = 0xb8 // float (Size: 0x4)
SGPlayerRecord.LastTimeOperate = 0xbc // float (Size: 0x4)
SGPlayerRecord.FirstMainWeapon = 0xc0 // SGInventory* (Size: 0x8)
SGPlayerRecord.SecondMainWeapon = 0xc8 // SGInventory* (Size: 0x8)
SGPlayerRecord.AssistWeapon = 0xd0 // SGInventory* (Size: 0x8)
SGPlayerRecord.FirstMainAmmoLevel = 0xd8 // float (Size: 0x4)
SGPlayerRecord.SecondMainAmmoLevel = 0xdc // float (Size: 0x4)
SGPlayerRecord.AssistAmmoLevel = 0xe0 // float (Size: 0x4)
SGPlayerRecord.ArmorLevel = 0xe4 // int32_t (Size: 0x4)
SGPlayerRecord.HeadsetLevel = 0xe8 // int32_t (Size: 0x4)
SGPlayerRecord.FoodCount = 0xec // int32_t (Size: 0x4)
SGPlayerRecord.ThrowWeaponCount = 0xf0 // int32_t (Size: 0x4)
SGPlayerRoleBannerBadge.Index = 0x0 // uint32_t (Size: 0x4)
SGPlayerRoleBannerBadge.TitleInfo = 0x4 // FSGPlayerTitleInfo (Size: 0x1c)
SGPlayerRoleBannerCustomData.ID = 0x0 // uint32_t (Size: 0x4)
SGPlayerRoleBannerCustomData.Value = 0x4 // uint32_t (Size: 0x4)
SGPlayerRoleBannerCustomData.BackgroundID = 0x8 // uint32_t (Size: 0x4)
SGPlayerRoleBannerCustomData.Index = 0xc // uint32_t (Size: 0x4)
SGPlayerRoomSettleSiteInfo.room_id = 0x0 // uint32_t (Size: 0x4)
SGPlayerRoomSettleSiteInfo.room_svr_id = 0x8 // uint64_t (Size: 0x8)
SGPlayerRoomSettleSiteInfo.room_type = 0x10 // uint32_t (Size: 0x4)
SGPlayerRoomSettleSiteInfo.room_bus_type = 0x14 // uint32_t (Size: 0x4)
SGPlayerRoomSettleSiteInfo.cmd_begin = 0x18 // uint32_t (Size: 0x4)
SGPlayerRoomSettleSiteInfo.cmd_over = 0x1c // uint32_t (Size: 0x4)
SGPlayerSeparatedItemInfos.SelfItemList = 0x0 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerSeparatedItemInfos.TeammateItemList = 0x10 // TArray<FSGBringOutTeamItemInfo> (Size: 0x10)
SGPlayerSeparatedItemInfos.SelfSeparatedItemList = 0x20 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerShowInfo.ClientShowItems = 0x0 // TArray<FSGClientShowItemInfo> (Size: 0x10)
SGPlayerShowInfo.AvatarGender = 0x10 // EECharacterSex (Size: 0x1)
SGPlayerShowInfo.AvatarItems = 0x18 // TArray<FSGAvatarInfo> (Size: 0x10)
SGPlayerShowInfo.bBodyStatus = 0x28 // uint32_t (Size: 0x4)
SGPlayerShowInfo.BadgeItems = 0x30 // TArray<FSGBadgeInfo> (Size: 0x10)
SGPlayerStart.PlayerStartComponentClasses = 0x340 // TArray<ClassProperty> (Size: 0x10)
SGPlayerStart.PlayerStartID = 0x350 // int32_t (Size: 0x4)
SGPlayerStart.StartGroupIndex = 0x354 // int32_t (Size: 0x4)
SGPlayerStart.PlayerStartComponents = 0x358 // TArray<ActorComponent*> (Size: 0x10)
SGPlayerStartDefaultInventoryComponent.DefaultPickupInventories = 0x100 // TArray<ClassProperty> (Size: 0x10)
SGPlayerStartDefaultInventoryComponent.DefaultPickupToBagInventories = 0x110 // TArray<ClassProperty> (Size: 0x10)
SGPlayerStartTeamComponent.TeamIndex = 0x100 // int32_t (Size: 0x4)
SGPlayerState.HitTeammates = 0x428 // TArray<SGCharacter*> (Size: 0x10)
SGPlayerState.HitTeammatesController = 0x438 // TSet<...> (Size: 0x50)
SGPlayerState.BroadcastComponent = 0x490 // SGPlayerStateBroadcastComponent* (Size: 0x8)
SGPlayerState.SGPlayerStateTeamComponent = 0x498 // SGPlayerStateTeamComponent* (Size: 0x8)
SGPlayerState.SGPlayerStateStatisComponent = 0x4a0 // SGPlayerStateStatisComponent* (Size: 0x8)
SGPlayerState.SGPlayerStateZoneInfoComp = 0x4a8 // SGPlayerStateZoneInfoComponent* (Size: 0x8)
SGPlayerState.PlayerPlatformId = 0x4b0 // uint8_t (Size: 0x1)
SGPlayerState.bApplyZoneSvrInfo = 0x4b1 // bool (Size: 0x1)
SGPlayerState.bHasInitNewPlayer = 0x4b2 // bool (Size: 0x1)
SGPlayerState.CacheLootLimitUserTagTableRow = 0x4b8 // FLootLimitUserTagTableRow (Size: 0x40)
SGPlayerState.GID = 0x4f8 // uint64_t (Size: 0x8)
SGPlayerState.GOpenID = 0x500 // uint32_t (Size: 0x4)
SGPlayerState.SGCharacter = 0x508 // SGCharacter* (Size: 0x8)
SGPlayerState.OnReconnect = 0x510 // bool (Size: 0x1)
SGPlayerState.roomid = 0x518 // uint64_t (Size: 0x8)
SGPlayerState.TeamIndex = 0x520 // int32_t (Size: 0x4)
SGPlayerState.TeamName = 0x528 // FString (Size: 0x10)
SGPlayerState.TeamGroupIndex = 0x538 // int32_t (Size: 0x4)
SGPlayerState.SquadIndex = 0x53c // int32_t (Size: 0x4)
SGPlayerState.GetOutOfStuckChance = 0x540 // int32_t (Size: 0x4)
SGPlayerState.seasonId = 0x544 // int32_t (Size: 0x4)
SGPlayerState.bInitFromZone = 0x548 // bool (Size: 0x1)
SGPlayerState.TeamType = 0x54c // int32_t (Size: 0x4)
SGPlayerState.game_mode = 0x550 // int32_t (Size: 0x4)
SGPlayerState.channelType = 0x554 // int32_t (Size: 0x4)
SGPlayerState.ranked_Level = 0x558 // uint32_t (Size: 0x4)
SGPlayerState.ranked_Score = 0x55c // uint32_t (Size: 0x4)
SGPlayerState.ranking = 0x560 // uint32_t (Size: 0x4)
SGPlayerState.pranking = 0x564 // uint32_t (Size: 0x4)
SGPlayerState.ranked_rd = 0x568 // uint32_t (Size: 0x4)
SGPlayerState.Rank = 0x56c // uint32_t (Size: 0x4)
SGPlayerState.pvp_ranking = 0x570 // uint32_t (Size: 0x4)
SGPlayerState.CurSeason_ID = 0x574 // uint32_t (Size: 0x4)
SGPlayerState.Server_Season_ID = 0x578 // uint32_t (Size: 0x4)
SGPlayerState.PlatPrivilegeType = 0x57c // uint32_t (Size: 0x4)
SGPlayerState.ranked_status = 0x580 // uint32_t (Size: 0x4)
SGPlayerState.Area_ID = 0x584 // uint32_t (Size: 0x4)
SGPlayerState.PMC_KillCountByPMC = 0x588 // uint32_t (Size: 0x4)
SGPlayerState.SCAV_KillCountByPMC = 0x58c // uint32_t (Size: 0x4)
SGPlayerState.DeathCountByPMC = 0x590 // uint32_t (Size: 0x4)
SGPlayerState.PlatId = 0x594 // int32_t (Size: 0x4)
SGPlayerState.bIsSingle = 0x598 // uint32_t (Size: 0x4)
SGPlayerState.AutoMatch = 0x59c // uint32_t (Size: 0x4)
SGPlayerState.PlayerLevel = 0x5a0 // uint32_t (Size: 0x4)
SGPlayerState.ZonePlayerName = 0x5a8 // FString (Size: 0x10)
SGPlayerState.CharacterSex = 0x5b8 // EECharacterSex (Size: 0x1)
SGPlayerState.PlayerIconInfo = 0x5c0 // FSGPlayerIconInfo (Size: 0x58)
SGPlayerState.PlayerBannerInfo = 0x618 // FSGPlayerBannerInfo (Size: 0x28)
SGPlayerState.Mentor_Identity = 0x640 // uint32_t (Size: 0x4)
SGPlayerState.Mentor_Gid = 0x644 // uint32_t (Size: 0x4)
SGPlayerState.Student_gid_List = 0x648 // TArray<int32_t> (Size: 0x10)
SGPlayerState.Mentor_Name = 0x658 // FString (Size: 0x10)
SGPlayerState.Student_Name_List = 0x668 // TArray<FString> (Size: 0x10)
SGPlayerState.LootLimitPoolID = 0x678 // int32_t (Size: 0x4)
SGPlayerState.EnterGameLeftTime = 0x67c // float (Size: 0x4)
SGPlayerState.EnterGameTime = 0x680 // float (Size: 0x4)
SGPlayerState.NationalFlagIso = 0x684 // int32_t (Size: 0x4)
SGPlayerState.bLettering = 0x688 // bool (Size: 0x1)
SGPlayerState.EnterDsZone = 0x68c // int32_t (Size: 0x4)
SGPlayerState.IdealDsZone = 0x690 // int32_t (Size: 0x4)
SGPlayerState.mapunlockId = 0x694 // uint32_t (Size: 0x4)
SGPlayerState.TakeOutInspectionLootPointIDArray = 0x698 // TArray<int32_t> (Size: 0x10)
SGPlayerState.TakeInInspectionLootPointIDArray = 0x6a8 // TArray<int32_t> (Size: 0x10)
SGPlayerState.GuranteedPool = 0x6b8 // TMap<...> (Size: 0x50)
SGPlayerState.ClientXIDArray = 0x708 // TArray<FString> (Size: 0x10)
SGPlayerState.CharacterLootExtDataMap = 0x718 // TMap<...> (Size: 0x50)
SGPlayerState.RecentCollectionItemCounts = 0x768 // TArray<uint32_t> (Size: 0x10)
SGPlayerState.LootGuaranteeFactor = 0x778 // float (Size: 0x4)
SGPlayerState.PlayerTagIds = 0x780 // TArray<int32_t> (Size: 0x10)
SGPlayerState.BanGrenadesTimestamp = 0x790 // uint64_t (Size: 0x8)
SGPlayerState.BanGrenadesTimestampIDIP = 0x798 // uint64_t (Size: 0x8)
SGPlayerState.bShouldBanGrennade = 0x7a0 // bool (Size: 0x1)
SGPlayerState.TempBanGrenade = 0x7a1 // bool (Size: 0x1)
SGPlayerState.bCanBeSpectated = 0x7a2 // bool (Size: 0x1)
SGPlayerState.NetbarLevel = 0x7a4 // uint32_t (Size: 0x4)
SGPlayerState.NetbarExpGainRate = 0x7a8 // uint32_t (Size: 0x4)
SGPlayerState.GentlemanType = 0x7ac // int32_t (Size: 0x4)
SGPlayerState.ItemUpgradeInfos = 0x7b0 // TArray<FActivityItemUpgradeInfo> (Size: 0x10)
SGPlayerState.IdentityType = 0x7c4 // EEPlayerIdentityType (Size: 0x1)
SGPlayerState.VirtualItemList = 0x7c8 // TArray<FSGVirtualItemInfo> (Size: 0x10)
SGPlayerState.bAllowTeammatesCheckTheBackpack = 0x7d8 // bool (Size: 0x1)
SGPlayerState.ComponentClasses = 0x7e0 // TArray<ClassProperty> (Size: 0x10)
SGPlayerState.ComponentClassesAdditional = 0x7f0 // TArray<ClassProperty> (Size: 0x10)
SGPlayerState.TemplateClass = 0x800 // ClassProperty (Size: 0x8)
SGPlayerState.bIsReconnectSpawn = 0x808 // bool (Size: 0x1)
SGPlayerState.bCancelReconnection = 0x809 // bool (Size: 0x1)
SGPlayerState.KillByEnemy = 0x818 // FString (Size: 0x10)
SGPlayerState.TotalDamageToEnemy = 0x828 // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyHead = 0x82c // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyChest = 0x830 // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyStomach = 0x834 // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyLeftArm = 0x838 // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyRightArm = 0x83c // int32_t (Size: 0x4)
SGPlayerState.DamageToEnemyLeg = 0x840 // int32_t (Size: 0x4)
SGPlayerState.TotalHitTimes = 0x844 // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyHead = 0x848 // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyChest = 0x84c // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyStomach = 0x850 // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyLeftArm = 0x854 // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyRightArm = 0x858 // int32_t (Size: 0x4)
SGPlayerState.HitTimesToEnemyLeg = 0x85c // int32_t (Size: 0x4)
SGPlayerState.TotalAmmoCost = 0x860 // int32_t (Size: 0x4)
SGPlayerState.EnemyArmorDamageReduceAmount = 0x864 // int32_t (Size: 0x4)
SGPlayerState.DeathType = 0x868 // EEDeathType (Size: 0x1)
SGPlayerState.KillEnemyCount = 0x86c // int32_t (Size: 0x4)
SGPlayerState.TotalGetDamage = 0x870 // int32_t (Size: 0x4)
SGPlayerState.TotalGetDamageTimes = 0x874 // int32_t (Size: 0x4)
SGPlayerState.HeadGetDamage = 0x878 // int32_t (Size: 0x4)
SGPlayerState.ChestGetDamage = 0x87c // int32_t (Size: 0x4)
SGPlayerState.StomachGetDamage = 0x880 // int32_t (Size: 0x4)
SGPlayerState.LeftArmGetDamage = 0x884 // int32_t (Size: 0x4)
SGPlayerState.RightArmGetDamage = 0x888 // int32_t (Size: 0x4)
SGPlayerState.LegGetDamage = 0x88c // int32_t (Size: 0x4)
SGPlayerState.MyselfArmorDamageReduceAmount = 0x890 // int32_t (Size: 0x4)
SGPlayerState.LastAimEnemy = 0x898 // SGCharacter* (Size: 0x8)
SGPlayerState.LastAimEnemyTime = 0x8a0 // float (Size: 0x4)
SGPlayerState.ChatVoiceIDs = 0x8a8 // TArray<int32_t> (Size: 0x10)
SGPlayerState.PlayerCommunicationIDs = 0x8b8 // TArray<int32_t> (Size: 0x10)
SGPlayerState.EscapePointName = 0x8c8 // FString (Size: 0x10)
SGPlayerState.KillPlayerPMC = 0x8d8 // int32_t (Size: 0x4)
SGPlayerState.KillPlayerScav = 0x8dc // int32_t (Size: 0x4)
SGPlayerState.KillTeammate = 0x8e0 // int32_t (Size: 0x4)
SGPlayerState.KillAIScav = 0x8e4 // int32_t (Size: 0x4)
SGPlayerState.KillAIScavBoss = 0x8e8 // int32_t (Size: 0x4)
SGPlayerState.KillAIPMC = 0x8ec // int32_t (Size: 0x4)
SGPlayerState.KillTotalCount = 0x8f0 // int32_t (Size: 0x4)
SGPlayerState.KillAIThemeBOSS = 0x8f4 // int32_t (Size: 0x4)
SGPlayerState.IsOpenMic = 0x8f8 // bool (Size: 0x1)
SGPlayerState.SignType = 0x8fc // int32_t (Size: 0x4)
SGPlayerState.NetOutLoss = 0x900 // uint32_t (Size: 0x4)
SGPlayerState.NetOutPackets = 0x904 // uint32_t (Size: 0x4)
SGPlayerState.NetInLoss = 0x908 // uint32_t (Size: 0x4)
SGPlayerState.NetInRate = 0x90c // uint32_t (Size: 0x4)
SGPlayerState.NetOutRate = 0x910 // uint32_t (Size: 0x4)
SGPlayerState.NetSaturated = 0x914 // uint32_t (Size: 0x4)
SGPlayerState.NetOutTotalPackets = 0x918 // uint32_t (Size: 0x4)
SGPlayerState.NetTotalOutLoss = 0x91c // uint32_t (Size: 0x4)
SGPlayerState.NetTotalInLoss = 0x920 // uint32_t (Size: 0x4)
SGPlayerState.TakeInValue = 0x924 // int32_t (Size: 0x4)
SGPlayerState.TakeOutTotalValue = 0x928 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_Self = 0x92c // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_Loot = 0x930 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_PMC = 0x934 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_SCAV = 0x938 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_AISCAV = 0x93c // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_AIBOSS = 0x940 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_AIPMC = 0x944 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_Other = 0x948 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_AIFollower = 0x94c // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_AIElit = 0x950 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_BOSS = 0x954 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_QuestEffectGive = 0x958 // int32_t (Size: 0x4)
SGPlayerState.TakeOutValue_GMCheat = 0x95c // int32_t (Size: 0x4)
SGPlayerStateBrilliantTimeComp.PlayerEndGameType = 0x100 // EEPlayerEndGameType (Size: 0x1)
SGPlayerStateBrilliantTimeComp.BrilliantTimeReplayInfo = 0x108 // FBrilliantTimeReplayInfo (Size: 0x30)
SGPlayerStateBrilliantTimeComp.DuplicatePreventionActorList = 0x188 // TArray<Actor*> (Size: 0x10)
SGPlayerStateBroadcastComponent.bQuestReportVisible = 0x110 // bool (Size: 0x1)
SGPlayerStateChaseActivityInfoComponent.TraceableActorUpdateServerTime = 0x100 // float (Size: 0x4)
SGPlayerStateChaseActivityInfoComponent.bIsActivityFinished = 0x104 // bool (Size: 0x1)
SGPlayerStateChaseActivityInfoComponent.ChaseActivityAvatarInfo = 0x108 // FChaseActivityAvatarInfo (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.ChaseActivityStateChangeInfo = 0x118 // FChaseActivityStateChangeInfo (Size: 0x8)
SGPlayerStateChaseActivityInfoComponent.ChaseActivityAvatarInfoReport = 0x120 // FActivityReportConfigArray (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.ChaseActivityReportConfig = 0x130 // TMap<...> (Size: 0x50)
SGPlayerStateChaseActivityInfoComponent.OwnedActivityInventoryInfo = 0x180 // FOwnedActivityInventoryInfo (Size: 0x28)
SGPlayerStateChaseActivityInfoComponent.TeammateOwnedActivityInventories = 0x1a8 // TArray<SGInventory*> (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.TeammateOwnedActivityInventoryHandles = 0x1b8 // TArray<int32_t> (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.ActivityInventoryStateChangeInfo = 0x1c8 // FActivityInventoryStateChangeInfo (Size: 0x2)
SGPlayerStateChaseActivityInfoComponent.ActivityInventoryStateReportConfig = 0x1d0 // TMap<...> (Size: 0x50)
SGPlayerStateChaseActivityInfoComponent.ActivityMessageConfigs = 0x220 // TMap<...> (Size: 0x50)
SGPlayerStateChaseActivityInfoComponent.MapScanIntervalText = 0x280 // FText (Size: 0x18)
SGPlayerStateChaseActivityInfoComponent.SpectatingGameHUDClearMessageIDs = 0x298 // TArray<int32_t> (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.StartSpectatingIgnoreMessageIDs = 0x2a8 // TArray<int32_t> (Size: 0x10)
SGPlayerStateChaseActivityInfoComponent.AlreadyReportCheckTimeConfigs = 0x2b8 // TArray<int32_t> (Size: 0x10)
SGPlayerStateDeathComponent.bDead = 0x100 // bool (Size: 0x1)
SGPlayerStateDeathComponent.Deaths = 0x104 // int32_t (Size: 0x4)
SGPlayerStateDeathComponent.LastDeadTime = 0x108 // float (Size: 0x4)
SGPlayerStateDeathComponent.LastPawn = 0x110 // Pawn* (Size: 0x8)
SGPlayerStateDeathComponent.LastKillerPlayerState = 0x118 // PlayerState* (Size: 0x8)
SGPlayerStateDeathComponent.LastKillerPlayerGID = 0x120 // int64_t (Size: 0x8)
SGPlayerStateDeathComponent.LastKillerPlayerName = 0x128 // FString (Size: 0x10)
SGPlayerStateDeathComponent.LastKillerPlayerLevel = 0x138 // int32_t (Size: 0x4)
SGPlayerStateDebugComponent.bDebug = 0x100 // bool (Size: 0x1)
SGPlayerStateHealthComponent.Health = 0x100 // int32_t (Size: 0x4)
SGPlayerStateHealthComponent.HealthMax = 0x104 // int32_t (Size: 0x4)
SGPlayerStateIntelligenceComponent.IntelligenceMissionState = 0x100 // EEIntelligenceMissionState (Size: 0x1)
SGPlayerStateIntelligenceComponent.IntelligenceKeyPickedupTime = 0x104 // float (Size: 0x4)
SGPlayerStateIntelligenceComponent.IntelligenceKeyKeeperName = 0x108 // FString (Size: 0x10)
SGPlayerStateIntelligenceComponent.IntelligenceKeyKeeperPS = 0x118 // SGPlayerState* (Size: 0x8)
SGPlayerStateIntelligenceComponent.LastIntelligenceMissionState = 0x124 // EEIntelligenceMissionState (Size: 0x1)
SGPlayerStateInvDetectActComp.PlayerInvDetectInfo = 0x108 // FPlayerInvDetectInfo (Size: 0x18)
SGPlayerStateInvDetectActComp.DetectingWatchItemID = 0x120 // int32_t (Size: 0x4)
SGPlayerStateInvDetectActComp.DetectingInvItemID = 0x124 // int32_t (Size: 0x4)
SGPlayerStateInvDetectActComp.InvDetectRadius = 0x128 // float (Size: 0x4)
SGPlayerStateInvDetectActComp.MaxDetectInvNum = 0x12c // int32_t (Size: 0x4)
SGPlayerStateInvDetectActComp.PlayerInvDetectConfigParams = 0x130 // TArray<FPlayerInvDetectConfig> (Size: 0x10)
SGPlayerStateInvDetectActComp.CurPlayerInvDetectConfig = 0x140 // FPlayerInvDetectConfig (Size: 0xc8)
SGPlayerStateInvDetectActComp.LastOnRepPlayerDetectedInvPosListNum = 0x208 // int32_t (Size: 0x4)
SGPlayerStateInvDetectActComp.LastIsInvDetecting = 0x20c // bool (Size: 0x1)
SGPlayerStateKillComponent.Kills = 0x100 // int32_t (Size: 0x4)
SGPlayerStateLifeComponent.TotalLifes = 0x100 // int32_t (Size: 0x4)
SGPlayerStateLifeComponent.RemainLifes = 0x104 // int32_t (Size: 0x4)
SGPlayerStateRankComponent.Rank = 0x100 // int32_t (Size: 0x4)
SGPlayerStateRespawnComponent.RespawnInterval = 0x100 // float (Size: 0x4)
SGPlayerStateStatisComponent.AllCauseRealDamageOnBodyPartStruct = 0x100 // TArray<FRealDamageOnBodyPartStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllHitStruct = 0x110 // TArray<FHitStatis> (Size: 0x10)
SGPlayerStateStatisComponent.AllKillStruct = 0x120 // TArray<FKillStatis> (Size: 0x10)
SGPlayerStateStatisComponent.AllCauseArmorDamageStruct = 0x130 // TArray<FArmorDamageStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllCauseHitDamage = 0x140 // TMap<...> (Size: 0x50)
SGPlayerStateStatisComponent.AllCauseBuffChangeStruct = 0x190 // TArray<FDebuffInfoStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllRealDamageOnBodyPartStruct = 0x1a0 // TArray<FRealDamageOnBodyPartStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllRealDamageOnBodyPartForTlogMap = 0x1b0 // TMap<...> (Size: 0x50)
SGPlayerStateStatisComponent.AllTakeBuffChangeStruct = 0x200 // TArray<FDebuffInfoStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllCauseArmorConsumeStruct = 0x210 // TArray<FArmorConsumeStruct> (Size: 0x10)
SGPlayerStateStatisComponent.AllEnemyHealthStaticsWhenDead = 0x220 // TArray<FCharacterHealthStaticsWhenDead> (Size: 0x10)
SGPlayerStateStatisComponent.AllWeaponValidateFailInfo = 0x230 // TArray<FDSWeaponValidateFail> (Size: 0x10)
SGPlayerStateStatisComponent.VictimGIDs = 0x240 // TArray<int64_t> (Size: 0x10)
SGPlayerStateStatisComponent.DeathTimeUnix = 0x250 // int64_t (Size: 0x8)
SGPlayerStateStatisComponent.TakeDamageInfoDisplayRange = 0x258 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.KillerName = 0x260 // FString (Size: 0x10)
SGPlayerStateStatisComponent.KillCount = 0x270 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.DamgeTakenArray = 0x278 // TArray<float> (Size: 0x10)
SGPlayerStateStatisComponent.GetDeBuffCountArray = 0x288 // TArray<int32_t> (Size: 0x10)
SGPlayerStateStatisComponent.KillOtherArray = 0x298 // TArray<int32_t> (Size: 0x10)
SGPlayerStateStatisComponent.AverageKillTime = 0x2a8 // float (Size: 0x4)
SGPlayerStateStatisComponent.AllKillOtherCount = 0x2ac // float (Size: 0x4)
SGPlayerStateStatisComponent.GameFinishType = 0x2b0 // EEPlayerEndGameType (Size: 0x1)
SGPlayerStateStatisComponent.Food = 0x2b4 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.Moisture = 0x2b8 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.PlayGestureCount = 0x2bc // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.RunDuration = 0x2c0 // float (Size: 0x4)
SGPlayerStateStatisComponent.StrilessDuration = 0x2c4 // float (Size: 0x4)
SGPlayerStateStatisComponent.StrilessMoreThanTime = 0x2c8 // bool (Size: 0x1)
SGPlayerStateStatisComponent.StopStepDuration = 0x2cc // float (Size: 0x4)
SGPlayerStateStatisComponent.LastHitBulletInfo = 0x2d0 // FLastHitPlayerInfo (Size: 0x128)
SGPlayerStateStatisComponent.SpectatingFlowDataArray = 0x3f8 // TArray<FSpectatingFlowData> (Size: 0x10)
SGPlayerStateStatisComponent.MonitorToggleInputAfterThrowInfo = 0x408 // FMonitorToggleInputAfterThrow (Size: 0x70)
SGPlayerStateStatisComponent.MonitorToggleInputSimpleInfo = 0x478 // FMonitorToggleInputSimple (Size: 0x70)
SGPlayerStateStatisComponent.ShootInputFlowDataStrArray = 0x500 // TArray<FString> (Size: 0x10)
SGPlayerStateStatisComponent.CachedPlayerActionInputData = 0x510 // TMap<...> (Size: 0x50)
SGPlayerStateStatisComponent.StationaryStateEnterTimeThreshold = 0x56c // float (Size: 0x4)
SGPlayerStateStatisComponent.StationaryStateExitDistanceThreshold = 0x570 // float (Size: 0x4)
SGPlayerStateStatisComponent.SoundIndicatorInfoRecordIntervalTime = 0x574 // float (Size: 0x4)
SGPlayerStateStatisComponent.FrameRateJitterThreshold = 0x578 // float (Size: 0x4)
SGPlayerStateStatisComponent.ReportPeriod = 0x57c // float (Size: 0x4)
SGPlayerStateStatisComponent.FrameRateJitterCount = 0x580 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.DBNOStatis = 0x590 // FDBNOStatis (Size: 0x20)
SGPlayerStateStatisComponent.PlayerTags = 0x5b0 // TSet<...> (Size: 0x50)
SGPlayerStateStatisComponent.EvaluateInterval = 0x608 // float (Size: 0x4)
SGPlayerStateStatisComponent.FireTimes = 0x60c // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.HitTimes = 0x610 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.LastFireTime = 0x614 // float (Size: 0x4)
SGPlayerStateStatisComponent.LootTimes = 0x618 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.LastLootTime = 0x61c // float (Size: 0x4)
SGPlayerStateStatisComponent.PoseCache = 0x620 // EEPlayerPoseType (Size: 0x1)
SGPlayerStateStatisComponent.PoseTimeCache = 0x624 // float (Size: 0x4)
SGPlayerStateStatisComponent.StandTime = 0x628 // float (Size: 0x4)
SGPlayerStateStatisComponent.CrouchTime = 0x62c // float (Size: 0x4)
SGPlayerStateStatisComponent.ProneTime = 0x630 // float (Size: 0x4)
SGPlayerStateStatisComponent.LastTimeChangePose = 0x634 // float (Size: 0x4)
SGPlayerStateStatisComponent.ZoomTime = 0x638 // float (Size: 0x4)
SGPlayerStateStatisComponent.LastZoomChangeTime = 0x63c // float (Size: 0x4)
SGPlayerStateStatisComponent.LastTimeOperate = 0x640 // float (Size: 0x4)
SGPlayerStateStatisComponent.LifeDetectorDetectNumber = 0x64c // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.LifeDetectorDetectCharacters = 0x650 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.LifeDetectorDetectPMC = 0x654 // int32_t (Size: 0x4)
SGPlayerStateStatisComponent.LifeDetectorKillPMC = 0x658 // int32_t (Size: 0x4)
SGPlayerStateTeamComponent.Team = 0x100 // SGTeamInfo* (Size: 0x8)
SGPlayerStateTicketComponent.Tickets = 0x100 // int32_t (Size: 0x4)
SGPlayerStateZoneInfoComponent.BusinessmanInfoList = 0x100 // TArray<FSGBusinessmanInfo> (Size: 0x10)
SGPlayerStateZoneInfoComponent.bAITeammateAutoSendBack = 0x110 // bool (Size: 0x1)
SGPlayerStateZoneInfoComponent.IsGivenDefaultInventory = 0x111 // bool (Size: 0x1)
SGPlayerStateZoneInfoComponent.ZonePlayerInfo = 0x118 // FSGZonePlayerInfo (Size: 0x1b0)
SGPlayerStateZoneInfoComponent.NewZonePlayerInfo = 0x2c8 // FSGZonePlayerInfo (Size: 0x1b0)
SGPlayerStateZoneInfoComponent.InventoryBaseID = 0x478 // uint64_t (Size: 0x8)
SGPlayerStateZoneInfoComponent.EnableSetInstId = 0x480 // bool (Size: 0x1)
SGPlayerStateZoneInfoComponent.DropItems = 0x488 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerStateZoneInfoComponent.SelfItemList = 0x498 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerStateZoneInfoComponent.TeammateItemList = 0x4a8 // TArray<FSGBringOutTeamItemInfo> (Size: 0x10)
SGPlayerStateZoneInfoComponent.SelfSeparatedItemList = 0x4b8 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerStateZoneInfoComponent.SelfSeparatedItemListTemp = 0x4c8 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
SGPlayerStateZoneInfoComponent.AITeammateAutoSendBackItemList = 0x4d8 // TArray<FSGBringOutTeamItemInfo> (Size: 0x10)
SGPlayerStateZoneInfoComponent.ProcessedAITeammateAutoSendBackItemList = 0x4e8 // TArray<FSGBringOutTeamItemInfo> (Size: 0x10)
SGPlayerStateZoneInfoComponent.KillTeammateCount = 0x4f8 // int8_t (Size: 0x1)
SGPlayerStateZoneInfoComponent.TakeOutValue = 0x500 // uint64_t (Size: 0x8)
SGPlayerStateZoneInfoComponent.TakeOutLimitType = 0x508 // EETakeOutLimitType (Size: 0x1)
SGPlayerStateZoneInfoComponent.OrderTakeInSourceType = 0x509 // EESGTakeInSourceType (Size: 0x1)
SGPlayerStateZoneInfoComponent.BrokenGunShieldDestroyedTip = 0x510 // FString (Size: 0x10)
SGPlayerTag.TagTime = 0x28 // float (Size: 0x4)
SGPlayerTitleInfo.ItemId = 0x0 // uint32_t (Size: 0x4)
SGPlayerTitleInfo.HasTitle = 0x4 // bool (Size: 0x1)
SGPlayerTitleInfo.StarNum = 0x8 // uint32_t (Size: 0x4)
SGPlayerTitleInfo.Rank = 0xc // uint32_t (Size: 0x4)
SGPlayerTitleInfo.ADCode = 0x10 // uint32_t (Size: 0x4)
SGPlayerTitleInfo.LBSRankLevel = 0x14 // uint32_t (Size: 0x4)
SGPlayerTitleInfo.HighestRankedLevel = 0x18 // uint32_t (Size: 0x4)
SGPlayerZoneSettleSiteInfo.business_id = 0x0 // uint32_t (Size: 0x4)
SGPlayerZoneSettleSiteInfo.svr_id = 0x8 // uint64_t (Size: 0x8)
SGPlayerZoneSettleSiteInfo.cmd_begin = 0x10 // uint32_t (Size: 0x4)
SGPlayerZoneSettleSiteInfo.cmd_over = 0x14 // uint32_t (Size: 0x4)
SGPointDamageEvent.DamageTypeEnum = 0xb8 // EEDamageTypeEnum (Size: 0x1)
SGPointDamageEvent.BulletID = 0xc0 // FSGBulletID (Size: 0x10)
SGPointDamageEvent.Impulse = 0xd0 // float (Size: 0x4)
SGPointDamageEvent.HitGroup = 0xd4 // EEHitGroupType (Size: 0x1)
SGPointDamageEvent.AmmoClass = 0xd8 // ClassProperty (Size: 0x8)
SGPointDamageEvent.HeadHitSubGroup = 0xe0 // EEHeadHitSubGroupType (Size: 0x1)
SGPointDamageEvent.CaptureWeaponZoomType = 0xe1 // EESGZoomType (Size: 0x1)
SGPointDamageEvent.FireModeNum = 0xe2 // uint8_t (Size: 0x1)
SGPointDamageEvent.HitFlags = 0xe3 // uint8_t (Size: 0x1)
SGPointDamageEvent.bIsBestHit = 0xe4 // bool (Size: 0x1)
SGPointDamageEvent.ImportantLocations = 0xe8 // TArray<FVector> (Size: 0x10)
SGPointDamageEvent.BulletInfo = 0xf8 // FBulletInfo (Size: 0x20)
SGPointDamageEvent.HitMovableArmor = 0x118 // SGInventory* (Size: 0x8)
SGPointDamageEvent.bTakerIsCrouch = 0x120 // bool (Size: 0x1)
SGPointDamageEvent.bTakerIsProne = 0x121 // bool (Size: 0x1)
SGPointDamageEvent.bTakerIsDBNO = 0x122 // bool (Size: 0x1)
SGPointDamageEvent.TakerMoveReceivedTimeDelta = 0x124 // float (Size: 0x4)
SGPointDamageEventObject.DamageTypeEnum = 0xd8 // EEDamageTypeEnum (Size: 0x1)
SGPointDamageEventObject.BulletID = 0xe0 // FSGBulletID (Size: 0x10)
SGPointDamageEventObject.Impulse = 0xf0 // float (Size: 0x4)
SGPointDamageEventObject.HitGroup = 0xf4 // EEHitGroupType (Size: 0x1)
SGPointDamageEventObject.AmmoClass = 0xf8 // ClassProperty (Size: 0x8)
SGPointDamageEventObject.HeadHitSubGroup = 0x100 // EEHeadHitSubGroupType (Size: 0x1)
SGPointDamageEventObject.CaptureWeaponZoomType = 0x101 // EESGZoomType (Size: 0x1)
SGPointDamageEventObject.FireModeNum = 0x102 // uint8_t (Size: 0x1)
SGPoisonGas.bPenetrateCollison = 0x324 // bool (Size: 0x1)
SGPoisonGas.bNeedPlayParticleEffect = 0x325 // bool (Size: 0x1)
SGPoisonGas.SpawnSmokeBPOnServer = 0x326 // bool (Size: 0x1)
SGPoisonGas.SmokeEffectBPSoftClass = 0x328 // TSoftClassPtr<UObject> (Size: 0x28)
SGPoisonGas.MiddleSmokeEffectBPSoftClass = 0x350 // TSoftClassPtr<UObject> (Size: 0x28)
SGPoisonGas.PoisonGasVolume = 0x378 // SGVolume* (Size: 0x8)
SGPoisonGas.SmokeEffectTime = 0x380 // float (Size: 0x4)
SGPoisonGas.SmokeExpandTime = 0x384 // float (Size: 0x4)
SGPoisonGas.SmokeFadeoutTime = 0x388 // float (Size: 0x4)
SGPoisonGas.FadeOutOffsetTime = 0x38c // float (Size: 0x4)
SGPoisonGas.SmokeBP = 0x390 // Actor* (Size: 0x8)
SGPoisonGas.ParticleVolumeSmokeBP = 0x398 // ParticleVolumeActor* (Size: 0x8)
SGPoisonGas.OwnerActor = 0x3a0 // Actor* (Size: 0x8)
SGPoisonGas.SmokePSC = 0x3a8 // ParticleSystemComponent* (Size: 0x8)
SGPoisonGas.PSCArray = 0x448 // TArray<ActorComponent*> (Size: 0x10)
SGPoisonGas.BlockBoxExtent = 0x458 // FVector (Size: 0xc)
SGPoisonGas.EffectBoxExtent = 0x464 // FVector (Size: 0xc)
SGPoisonGas.BlockStartTime = 0x470 // float (Size: 0x4)
SGPoisonGas.BlockDurationTime = 0x474 // float (Size: 0x4)
SGPoisonGas.LeftSmokeEffectTimeRep = 0x478 // float (Size: 0x4)
SGPoisonGas.bStartPlayEffectInServer = 0x47c // bool (Size: 0x1)
SGPoisonGas.RealEffectLocation = 0x480 // FVector (Size: 0xc)
SGPooledFireEffect.FireParticleCmp = 0x358 // ParticleSystemComponent* (Size: 0x8)
SGPooledFireEffect.ParticleFovComp = 0x360 // SGWeaponEffectFOVComponent* (Size: 0x8)
SGPooledFireEffect.Weapon = 0x368 // SGInventory* (Size: 0x8)
SGPooledImpactEffect.DummyRoot = 0x358 // SceneComponent* (Size: 0x8)
SGPooledImpactEffect.ImpactMeshComp = 0x360 // StaticMeshComponent* (Size: 0x8)
SGPooledImpactEffect.ImpactDecalComp = 0x368 // DecalComponent* (Size: 0x8)
SGPooledImpactEffectManager.PooledImpactEffectBindList = 0x28 // TArray<FPooledImpactEffectBind> (Size: 0x10)
SGPooledImpactEffectManager.EffectResouceHead = 0x38 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceArm = 0x118 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceLeg = 0x1f8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceBody = 0x2d8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceChest = 0x3b8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceHitArmor = 0x498 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceHead_3P = 0x578 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceArm_3P = 0x658 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceLeg_3P = 0x738 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceBody_3P = 0x818 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceChest_3P = 0x8f8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.EffectResouceHitArmor_3P = 0x9d8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceHead = 0xab8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceArm = 0xb98 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceLeg = 0xc78 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceBody = 0xd58 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceChest = 0xe38 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceHitArmor = 0xf18 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceHead_3P = 0xff8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceArm_3P = 0x10d8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceLeg_3P = 0x11b8 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceBody_3P = 0x1298 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.MeleeEffectResouceHitArmor_3P = 0x1378 // FPooledImpactEffectResource (Size: 0xe0)
SGPooledImpactEffectManager.BloodSplatterDecalResource = 0x1458 // FDecalImpactEffectResource (Size: 0x60)
SGPooledImpactEffectManager.BloodSplatterDistance = 0x14b8 // float (Size: 0x4)
SGPooledImpactEffectManager.BloodSplatterDeflectionRange = 0x14bc // float (Size: 0x4)
SGPooledImpactEffectManager.BloodSplatterLifeSpan = 0x14c0 // float (Size: 0x4)
SGPooledImpactEffectManager.BloodSplatterDamageScale = 0x14c8 // FRuntimeFloatCurve (Size: 0x88)
SGPooledImpactEffectManager.BloodSplatterProbability = 0x1550 // float (Size: 0x4)
SGPoseCacheInfo.PoseCache = 0x0 // FPoseSnapshot (Size: 0x38)
SGPoseSnapshotRotationTranslation.Rotation = 0x0 // FQuat (Size: 0x10)
SGPoseSnapshotRotationTranslation.Translation = 0x10 // FVector_NetQuantize (Size: 0xc)
SGPredictCamDistNode.PredictCameraDistance = 0x0 // float (Size: 0x4)
SGPredictCamDistNode.PredictTime = 0x4 // float (Size: 0x4)
SGPredictPathNode.PredictLocation = 0x0 // FVector (Size: 0xc)
SGPredictPathNode.PredictRotation = 0xc // FRotator (Size: 0xc)
SGPredictPathNode.Name = 0x18 // FName (Size: 0x8)
SGPreviewActor.PreviewMesh = 0x310 // StaticMeshComponent* (Size: 0x8)
SGPreviewActor.IDMeshTable = 0x318 // DataTable* (Size: 0x8)
SGPreviewCaptureLightsSets.CustomCaptureLights = 0x28 // TMap<...> (Size: 0x50)
SGPreviewCharacterAnimationSet.CustomAnimations = 0x0 // TMap<...> (Size: 0x50)
SGPreviewCharacterAnimationSet.CasualGripAdjustmentBS = 0x50 // BlendSpace1D* (Size: 0x8)
SGPreviewCharacterAnimationSet.RandomMontageLists = 0x58 // TMap<...> (Size: 0x50)
SGPreviewRandomIdleAnimConfig.Anim = 0x0 // AnimSequence* (Size: 0x8)
SGPreviewRandomIdleAnimConfig.Weight = 0x8 // int32_t (Size: 0x4)
SGPreviewRandomIdleAnimGroup.AnimGroup = 0x0 // TArray<FSGPreviewRandomIdleAnimConfig> (Size: 0x10)
SGPreviewRandomIdleAnimGroup.GroupWeight = 0x10 // int32_t (Size: 0x4)
SGPreviewRandomIdleAnimSet.BigAnimGroup = 0x0 // FSGPreviewRandomIdleAnimGroup (Size: 0x18)
SGPreviewRandomIdleAnimSet.SmallAnimGroup = 0x18 // FSGPreviewRandomIdleAnimGroup (Size: 0x18)
SGProjectileAudioComponent.SoundBank = 0x100 // AkAudioBank* (Size: 0x8)
SGProjectileAudioComponent.UnloadBankOnImpactEnd = 0x108 // bool (Size: 0x1)
SGProjectileAudioComponent.BeginThrowingAudioEvent = 0x110 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.ImpactAudioEvent = 0x118 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.ImpactAudioSFXEvent = 0x120 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.BeginEffectAudioEvent = 0x128 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.EndEffectAudioEvent = 0x130 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.BounceAudioEvent = 0x138 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.ActiveAudioEvent = 0x140 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.WarningAudioEvent = 0x148 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.FireworkAirBlastAudioEvent = 0x150 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.FireworkGroundAudioEvent = 0x158 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.BounceSoundCooldown = 0x160 // float (Size: 0x4)
SGProjectileAudioComponent.BounceAudioDataSet = 0x168 // SGImpactAudioData_HD* (Size: 0x8)
SGProjectileAudioComponent.GothroughGrassAudioEvent = 0x170 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.TinnitusMaxDistance = 0x178 // float (Size: 0x4)
SGProjectileAudioComponent.TinnitusDurationDistCurve = 0x180 // CurveFloat* (Size: 0x8)
SGProjectileAudioComponent.ImpactSurfaceEffectAudioEvent = 0x1b0 // AkAudioEvent* (Size: 0x8)
SGProjectileAudioComponent.WaterMatarial = 0x1b8 // uint8_t (Size: 0x1)
SGProjectileAudioComponent.GrassMatarial = 0x1b9 // uint8_t (Size: 0x1)
SGProjectileBaseDamageComponent.bEnableTakeDamageByBoneDistance = 0xf8 // bool (Size: 0x1)
SGProjectileBaseDamageComponent.HeadBoneName = 0xfc // FName (Size: 0x8)
SGProjectileBaseDamageComponent.ChestBoneName = 0x104 // FName (Size: 0x8)
SGProjectileBaseDamageComponent.StomachBoneName = 0x10c // FName (Size: 0x8)
SGProjectileBaseDamageComponent.LeftArmBoneName = 0x114 // FName (Size: 0x8)
SGProjectileBaseDamageComponent.RightArmBoneName = 0x11c // FName (Size: 0x8)
SGProjectileBaseDamageComponent.LeftLegBoneName = 0x124 // FName (Size: 0x8)
SGProjectileBaseDamageComponent.RightLegBoneName = 0x12c // FName (Size: 0x8)
SGProjectileBaseDamageComponent.DamageHead = 0x134 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageLeftArm = 0x138 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageRightArm = 0x13c // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageChest = 0x140 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageStomach = 0x144 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageLeftLeg = 0x148 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageRightLeg = 0x14c // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageImpulseFactor = 0x150 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageForNoneCharacter = 0x154 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageForProjectile = 0x158 // float (Size: 0x4)
SGProjectileBaseDamageComponent.Momentum = 0x15c // float (Size: 0x4)
SGProjectileBaseDamageComponent.BleedTriggerChance = 0x160 // float (Size: 0x4)
SGProjectileBaseDamageComponent.DamageTypeClass = 0x168 // ClassProperty (Size: 0x8)
SGProjectileBaseDamageComponent.JudgeTime = 0x170 // float (Size: 0x4)
SGProjectileBaseDamageComponent.CharacterBlockScaleMap = 0x218 // TMap<...> (Size: 0x50)
SGProjectileBaseDamageComponent.CharacterExposureScaleMap = 0x268 // TMap<...> (Size: 0x50)
SGProjectileBaseDamageComponent.CachedDamageInfoArray = 0x2b8 // TArray<FCachedDamageInfo> (Size: 0x10)
SGProjectileC4Component.TotalTimeToExplode = 0x348 // float (Size: 0x4)
SGProjectileC4Component.CurrentTimeToExplode = 0x34c // float (Size: 0x4)
SGProjectileC4Component.FlashLightComp = 0x350 // ParticleSystemComponent* (Size: 0x8)
SGProjectileC4Component.DeployAudioEvent = 0x358 // AkAudioEvent* (Size: 0x8)
SGProjectileC4Component.BeepAudioEvent = 0x360 // AkAudioEvent* (Size: 0x8)
SGProjectileC4Component.ExplodeAudioEvent_Wood = 0x368 // AkAudioEvent* (Size: 0x8)
SGProjectileC4Component.ExplodeAudioEvent_Concrete = 0x370 // AkAudioEvent* (Size: 0x8)
SGProjectileC4Component.ExplodeAudioEvent = 0x378 // AkAudioEvent* (Size: 0x8)
SGProjectileCameraComponent.ExplosionCameraShake = 0x100 // ClassProperty (Size: 0x8)
SGProjectileCameraComponent.bPlayCameraShakeAtDestroy = 0x108 // bool (Size: 0x1)
SGProjectileCameraComponent.bPlayCameraShakeAtEffectTime = 0x109 // bool (Size: 0x1)
SGProjectileCameraComponent.ShakeInnerRadius = 0x10c // float (Size: 0x4)
SGProjectileCameraComponent.ShakeOutterRadius = 0x110 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.DamageToArmorAtBack = 0x538 // CurveFloat* (Size: 0x8)
SGProjectileClaymoreDamageComponent.OwnerCharacterList = 0x540 // TArray<EEPlayerTeamType> (Size: 0x10)
SGProjectileClaymoreDamageComponent.OwnerAIList = 0x550 // TArray<EEAIMainType> (Size: 0x10)
SGProjectileClaymoreDamageComponent.DamageTakerCharacterList = 0x560 // TArray<EEPlayerTeamType> (Size: 0x10)
SGProjectileClaymoreDamageComponent.DamageTakerAIList = 0x570 // TArray<EEAIMainType> (Size: 0x10)
SGProjectileClaymoreDamageComponent.DetectInterval = 0x580 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.ExplodeDelay = 0x584 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.Radius = 0x588 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.SmallRadius = 0x58c // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.FanAngle = 0x590 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.CharacterHeight = 0x594 // float (Size: 0x4)
SGProjectileClaymoreDamageComponent.ProjectileHeight = 0x598 // float (Size: 0x4)
SGProjectileDamageComponent.bTakeDamageOnDestroy = 0x2d8 // bool (Size: 0x1)
SGProjectileDamageComponent.bTakeDamageOnEffect = 0x2d9 // bool (Size: 0x1)
SGProjectileDamageComponent.PhysSphereClass = 0x2e0 // ClassProperty (Size: 0x8)
SGProjectileDamageComponent.DamageCurve = 0x2f0 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveHead = 0x2f8 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveLeftArm = 0x300 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveRightArm = 0x308 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveChest = 0x310 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveStom = 0x318 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveLeftLeg = 0x320 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveRightLeg = 0x328 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBack = 0x330 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackHead = 0x338 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackLeftArm = 0x340 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackRightArm = 0x348 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackChest = 0x350 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackStom = 0x358 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackLeftLeg = 0x360 // CurveFloat* (Size: 0x8)
SGProjectileDamageComponent.DamageCurveAtBackRightLeg = 0x368 // CurveFloat* (Size: 0x8)
SGProjectileEffectComponent.bHideProjectileWhenEffectTriggered = 0x110 // bool (Size: 0x1)
SGProjectileEffectComponent.LifeSpanAfterEffectTriggered = 0x114 // float (Size: 0x4)
SGProjectileEffectComponent.EffectUseSelfRotator = 0x118 // bool (Size: 0x1)
SGProjectileEffectComponent.EffectRelativeTransform = 0x120 // FTransform (Size: 0x30)
SGProjectileEffectComponent.TimesToPlay = 0x150 // int32_t (Size: 0x4)
SGProjectileEffectComponent.ImpactPSList1P = 0x160 // TArray<ParticleSystem*> (Size: 0x10)
SGProjectileEffectComponent.ImpactPSList3P = 0x170 // TArray<ParticleSystem*> (Size: 0x10)
SGProjectileEffectComponent.DelayTime = 0x180 // float (Size: 0x4)
SGProjectileEffectComponent.bUseHUDShake = 0x184 // bool (Size: 0x1)
SGProjectileEffectComponent.ImpactPSC = 0x188 // ParticleSystemComponent* (Size: 0x8)
SGProjectileEffectComponent.TimeToRemoveWeapon = 0x190 // float (Size: 0x4)
SGProjectileEffectComponent.EnvSys = 0x238 // MFEnvSystem* (Size: 0x8)
SGProjectileExplosionManager.LongEffectFXSC = 0x100 // TArray<FXSystemComponent*> (Size: 0x10)
SGProjectileExplosionManager.LongEffectInfos = 0x110 // TArray<FLongEffectInfo> (Size: 0x10)
SGProjectileExplosionManager.CachedExplosionInfos = 0x120 // TArray<FExplosionInfoItem> (Size: 0x10)
SGProjectileExplosionManager.ExplosionInfos = 0x140 // FExplosionInfoContainer (Size: 0x128)
SGProjectileExplosionManager.ImpactEffectData = 0x268 // TMap<...> (Size: 0x50)
SGProjectileExplosionManager.ImpactEffectDataSkyAndSmoke = 0x2b8 // TMap<...> (Size: 0x50)
SGProjectileExplosionManager.ImpactAudioData = 0x308 // TMap<...> (Size: 0x50)
SGProjectileExplosionManager.SmokeVolumeBPSoftClass = 0x358 // TMap<...> (Size: 0x50)
SGProjectileExplosionManager.WaterMaterial = 0x3a8 // uint8_t (Size: 0x1)
SGProjectileExplosionManager.GrassMaterial = 0x3a9 // uint8_t (Size: 0x1)
SGProjectileFlashComponent.FlashDistanceConfArray = 0x100 // TArray<FFlashDisConf> (Size: 0x10)
SGProjectileFlashComponent.bConsiderFlashAsHit = 0x110 // bool (Size: 0x1)
SGProjectileFragDamageComponent.bApplyDamageToArmor = 0x408 // bool (Size: 0x1)
SGProjectileFragDamageComponent.MinExposureDamageScale = 0x40c // float (Size: 0x4)
SGProjectileFragDamageComponent.DamageReduceScaleByArmorLevel = 0x410 // CurveFloat* (Size: 0x8)
SGProjectileFragDamageComponent.DamageReduceScaleByArmorDurability = 0x418 // CurveFloat* (Size: 0x8)
SGProjectileFragDamageComponent.DamageToArmor = 0x420 // CurveFloat* (Size: 0x8)
SGProjectileFragDamageComponent.MaxDamageWithinDistance = 0x428 // float (Size: 0x4)
SGProjectileFragDamageComponent.DamageToArmorMap = 0x430 // TMap<...> (Size: 0x50)
SGProjectileFragDamageComponent.CachedDamageInfoArrayToNotCharacter = 0x520 // TArray<FCachedDamageInfo> (Size: 0x10)
SGProjectileFragGrenadeComponent.LaserBeamParticleSystemTemplate = 0x110 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.BeamColor = 0x138 // FLinearColor (Size: 0x10)
SGProjectileFragGrenadeComponent.LaserOffset = 0x148 // float (Size: 0x4)
SGProjectileFragGrenadeComponent.LaserScale = 0x14c // float (Size: 0x4)
SGProjectileFragGrenadeComponent.ExplodeSkyEffectTemplate = 0x150 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.ImpactEffectData = 0x178 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.ActivityEffectTemplate = 0x1a0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.GrenadeExplodeLightTemplate = 0x1c8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.LightSize = 0x1f0 // FVector (Size: 0xc)
SGProjectileFragGrenadeComponent.LightIntensityColor = 0x1fc // FVector (Size: 0xc)
SGProjectileFragGrenadeComponent.LightTime = 0x208 // float (Size: 0x4)
SGProjectileFragGrenadeComponent.GrenadeStaticEffectTemplate = 0x210 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileFragGrenadeComponent.GrenadeSmokeFXSC = 0x238 // FXSystemComponent* (Size: 0x8)
SGProjectileFragGrenadeComponent.WaterMaterial = 0x240 // uint8_t (Size: 0x1)
SGProjectileFragGrenadeComponent.GrenadeExplodeLightPSC = 0x248 // ParticleSystemComponent* (Size: 0x8)
SGProjectileFragGrenadeComponent.LaserBeamPSCCenter = 0x250 // ParticleSystemComponent* (Size: 0x8)
SGProjectileFragGrenadeComponent.LaserBeamPSCLeft = 0x258 // ParticleSystemComponent* (Size: 0x8)
SGProjectileFragGrenadeComponent.LaserBeamPSCRight = 0x260 // ParticleSystemComponent* (Size: 0x8)
SGProjectileHealthComponent.Health = 0x108 // float (Size: 0x4)
SGProjectileHealthComponent.DelayDestroyTime = 0x10c // float (Size: 0x4)
SGProjectileHealthComponent.DestroyedSound = 0x110 // AkAudioEvent* (Size: 0x8)
SGProjectileHealthComponent.DestroyEmitterTemplate = 0x118 // ParticleSystem* (Size: 0x8)
SGProjectileHealthComponent.TwinkleEmitterTemplate = 0x120 // ParticleSystem* (Size: 0x8)
SGProjectileHealthComponent.DestroyEffectTemplate = 0x128 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileHealthComponent.TwinkleEffectTemplate = 0x150 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileHealthComponent.TwinkleEmitterPSC = 0x180 // ParticleSystemComponent* (Size: 0x8)
SGProjectileHealthComponent.TwinkleFXSC = 0x190 // FXSystemComponent* (Size: 0x8)
SGProjectileMolotovComponent.ExplodePS = 0x2d8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileMolotovComponent.ContinuousFiringPS = 0x300 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileMolotovComponent.ContinuousFiringPS_SaaS = 0x328 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileMolotovComponent.CenterContinuousFiringPS = 0x350 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileMolotovComponent.RoundFireAmount = 0x378 // int32_t (Size: 0x4)
SGProjectileMolotovComponent.RoundFireRadiusOffsetRange = 0x37c // float (Size: 0x4)
SGProjectileMolotovComponent.RoundFireThetaOffsetRange = 0x380 // float (Size: 0x4)
SGProjectileMolotovComponent.TriggerDamagePeriod = 0x384 // float (Size: 0x4)
SGProjectileMolotovComponent.DamageDurationTime = 0x388 // float (Size: 0x4)
SGProjectileMolotovComponent.EffectDurationTime = 0x38c // float (Size: 0x4)
SGProjectileMolotovComponent.MolotovImpactRadius = 0x390 // float (Size: 0x4)
SGProjectileMolotovComponent.MolotovImpactHeight = 0x394 // float (Size: 0x4)
SGProjectileMolotovComponent.GroundFireEffectDispearTime = 0x398 // float (Size: 0x4)
SGProjectileMolotovComponent.ContinuousFiringPSCArray = 0x3a8 // TArray<FXSystemComponent*> (Size: 0x10)
SGProjectileMolotovComponent.OnFireActors = 0x3b8 // TArray<Actor*> (Size: 0x10)
SGProjectileMolotovComponent.ActorsToIgnoreWhenCheckDamage = 0x3c8 // TArray<Actor*> (Size: 0x10)
SGProjectileMolotovComponent.ContinuousFiringComponent_SaaS = 0x3d8 // NiagaraComponent* (Size: 0x8)
SGProjectileMolotovComponent.LeftDurationTimerRep = 0x400 // float (Size: 0x4)
SGProjectileMolotovComponent.FirePositionPairArray = 0x408 // TArray<FirePositionPair> (Size: 0x10)
SGProjectileMovementComponent.ZeroGravityDistance = 0x230 // float (Size: 0x4)
SGProjectileMovementComponent.LeftNoGravityTime = 0x234 // float (Size: 0x4)
SGProjectileMovementComponent.LeftNoHorizontalDecTime = 0x238 // float (Size: 0x4)
SGProjectileMovementComponent.HorizontalVelocityDecRate = 0x23c // float (Size: 0x4)
SGProjectileMovementComponent.Mass = 0x240 // float (Size: 0x4)
SGProjectileMovementComponent.ResistanceFactor = 0x244 // float (Size: 0x4)
SGProjectileMovementComponent.GravityDistanceCurve = 0x248 // CurveFloat* (Size: 0x8)
SGProjectileMovementComponent.ResistanceFactorDistanceCurve = 0x250 // CurveFloat* (Size: 0x8)
SGProjectileMovementComponent.GravityScale = 0x258 // float (Size: 0x4)
SGProjectileMovementComponent.HorzFlyDistance = 0x25c // float (Size: 0x4)
SGProjectileMovementComponent.MovementLerpCurve = 0x260 // CurveFloat* (Size: 0x8)
SGProjectileMovementComponent.NearGrassBounds = 0x270 // FAINearGrassBounds (Size: 0x20)
SGProjectileMovementComponent.GrassCheckInterval = 0x290 // float (Size: 0x4)
SGProjectileMovementComponent.SavedProjectileMovements = 0x2a0 // TArray<FSavedProjectileMovement> (Size: 0x10)
SGProjectileOffensiveDamageComponent.BlockDamageScaleByDifferentMaterial = 0x408 // TMap<...> (Size: 0x50)
SGProjectileOffensiveDamageComponent.MaxLayerNumber = 0x458 // int32_t (Size: 0x4)
SGProjectileOffensiveDamageComponent.ScreenEffectMaxDistance = 0x45c // float (Size: 0x4)
SGProjectileOffensiveDamageComponent.ScreenEffectMaxTime = 0x460 // float (Size: 0x4)
SGProjectileOffensiveDamageComponent.bApplyDamageToArmor = 0x464 // bool (Size: 0x1)
SGProjectileOffensiveDamageComponent.DamageReduceScaleByArmorLevel = 0x468 // CurveFloat* (Size: 0x8)
SGProjectileOffensiveDamageComponent.DamageReduceScaleByArmorDurability = 0x470 // CurveFloat* (Size: 0x8)
SGProjectileOffensiveDamageComponent.DamageToArmor = 0x478 // CurveFloat* (Size: 0x8)
SGProjectileOffensiveDamageComponent.DamageToArmorMap = 0x480 // TMap<...> (Size: 0x50)
SGProjectileSmokeComponent.SmokeEffectBPSoftClass = 0x100 // TSoftClassPtr<UObject> (Size: 0x28)
SGProjectileSmokeComponent.MiddleSmokeEffectBPSoftClass = 0x128 // TSoftClassPtr<UObject> (Size: 0x28)
SGProjectileSmokeComponent.SmokeEffectTime = 0x150 // float (Size: 0x4)
SGProjectileSmokeComponent.SmokeExpandTime = 0x154 // float (Size: 0x4)
SGProjectileSmokeComponent.SmokeFadeoutTime = 0x158 // float (Size: 0x4)
SGProjectileSmokeComponent.FadeOutOffsetTime = 0x15c // float (Size: 0x4)
SGProjectileSmokeComponent.SmokeEffectRadius = 0x160 // float (Size: 0x4)
SGProjectileSmokeComponent.SmokeMaxCullDistance = 0x164 // float (Size: 0x4)
SGProjectileSmokeComponent.SmokeBP = 0x168 // Actor* (Size: 0x8)
SGProjectileSmokeComponent.PooledSmokeBP = 0x170 // PooledActor* (Size: 0x8)
SGProjectileSmokeComponent.SmokePSC = 0x178 // ParticleSystemComponent* (Size: 0x8)
SGProjectileSmokeComponent.PSCArray = 0x180 // TArray<ActorComponent*> (Size: 0x10)
SGProjectileSmokeComponent.BlockBoxExtent = 0x228 // FVector (Size: 0xc)
SGProjectileSmokeComponent.EffectBoxExtent = 0x234 // FVector (Size: 0xc)
SGProjectileSmokeComponent.BlockStartTime = 0x240 // float (Size: 0x4)
SGProjectileSmokeComponent.BlockDurationTime = 0x244 // float (Size: 0x4)
SGProjectileSmokeComponent.LeftSmokeEffectTimeRep = 0x248 // float (Size: 0x4)
SGProjectileSmokeComponent.bStartPlayEffectInServer = 0x24c // bool (Size: 0x1)
SGProjectileSmokeComponent.RealEffectLocation = 0x250 // FVector (Size: 0xc)
SGProjectileSmokeComponent.OwnerProjectile = 0x298 // SGThrowableProjectile* (Size: 0x8)
SGProjectileSmokeComponent.bEnableObjectPool = 0x2a0 // bool (Size: 0x1)
SGProjectileSmokeComponent.SmokeEffectTemplate = 0x2b0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGProjectileSmokeComponent.SmokeOnlyVolumeBPSoftClass = 0x2d8 // TSoftClassPtr<UObject> (Size: 0x28)
SGProjectileSmokeComponent.SmokeParticleComponent = 0x300 // FXSystemComponent* (Size: 0x8)
SGProjectileSmokeComponent.SmokeSpawnDelay = 0x308 // float (Size: 0x4)
SGProjectileSoundGeneratorComponent.SoundBank = 0x100 // AkAudioBank* (Size: 0x8)
SGProjectileSoundGeneratorComponent.FootstepsSound = 0x108 // AkAudioEvent* (Size: 0x8)
SGProjectileSoundGeneratorComponent.MaterialFootstepsSound = 0x110 // TMap<...> (Size: 0x50)
SGProjectileSoundGeneratorComponent.StickAudioEvent = 0x160 // AkAudioEvent* (Size: 0x8)
SGProjectileSoundGeneratorComponent.TriggerSingleSoundInterval = 0x168 // float (Size: 0x4)
SGProjectileSoundGeneratorComponent.PhysicalSurface = 0x16c // uint8_t (Size: 0x1)
SGProjectileSoundGeneratorComponent.StickResult = 0x180 // FHitResult (Size: 0x98)
SGProjectileStunComponent.StunDistance = 0x100 // float (Size: 0x4)
SGProjectileStunComponent.StunCurve = 0x108 // CurveFloat* (Size: 0x8)
SGProjectileStunComponent.DecreaseMoveSpeedDistance = 0x110 // float (Size: 0x4)
SGProjectileStunComponent.DecreaseMoveSpeedRate = 0x114 // float (Size: 0x4)
SGProjectileStunComponent.DecreaseMoveSpeedCurve = 0x118 // CurveFloat* (Size: 0x8)
SGProjectileStunComponent.bBreakWindows = 0x120 // bool (Size: 0x1)
SGProjectileStunComponent.bConsiderStunAsHit = 0x121 // bool (Size: 0x1)
SGProjectileStunComponent.DecreaseSensitivityDistance = 0x124 // float (Size: 0x4)
SGProjectileStunComponent.DecreaseSensitivityRate = 0x128 // float (Size: 0x4)
SGProjectileStunComponent.DecreaseSensitivityCurve = 0x130 // CurveFloat* (Size: 0x8)
SGProjectileStunComponent.DecreaseSensitivityDurationCurve = 0x138 // CurveFloat* (Size: 0x8)
SGProjectileTearGasComponent.PoisonGas = 0x328 // ClassProperty (Size: 0x8)
SGProjectileTrajectory.TrajectoryDrawPolicy = 0x310 // EETrajectoryDrawPolicy (Size: 0x1)
SGProjectileTrajectory.SplineComponent = 0x318 // SplineComponent* (Size: 0x8)
SGProjectileTrajectory.SplineStaticMesh = 0x320 // StaticMesh* (Size: 0x8)
SGProjectileTrajectory.SplineMaterial = 0x328 // MaterialInstance* (Size: 0x8)
SGProjectileTrajectory.SplineMaterialStart = 0x330 // MaterialInstance* (Size: 0x8)
SGProjectileTrajectory.InstancedStaticMesh = 0x338 // InstancedStaticMeshComponent* (Size: 0x8)
SGProjectileTrajectory.HISM = 0x340 // StaticMesh* (Size: 0x8)
SGProjectileTrajectory.HISMMat = 0x348 // MaterialInstance* (Size: 0x8)
SGProjectileTrajectory.ProceduralMesh = 0x350 // ProceduralMeshComponent* (Size: 0x8)
SGProjectileTrajectory.ProceduralMeshMat = 0x358 // MaterialInterface* (Size: 0x8)
SGProjectileTrajectory.ProceduralMeshMatMpe = 0x360 // MaterialInterface* (Size: 0x8)
SGProjectileTrajectory.ProceduralMeshDynamicMat = 0x368 // MaterialInstanceDynamic* (Size: 0x8)
SGProjectileTrajectory.ProceduralMeshDynamicMatMpe = 0x370 // MaterialInstanceDynamic* (Size: 0x8)
SGProjectileTrajectory.UsedProceduralMeshDynamicMat = 0x378 // MaterialInstanceDynamic* (Size: 0x8)
SGProjectileTrajectory.CylinderRadius = 0x380 // float (Size: 0x4)
SGProjectileTrajectory.CylinderSlice = 0x384 // int32_t (Size: 0x4)
SGProjectileTrajectory.bInverseUV = 0x388 // bool (Size: 0x1)
SGProjectileTrajectory.NormalGrenadeOpacity = 0x38c // float (Size: 0x4)
SGProjectileTrajectory.OnHoldGrenadeOpacity = 0x390 // float (Size: 0x4)
SGProjectileTrajectory.TrajectoryFadeInCurve = 0x398 // CurveFloat* (Size: 0x8)
SGProjectileTrajectory.TraceRadiusForProcedrualDraw = 0x3a8 // float (Size: 0x4)
SGProjectileTrajectory.FixRotateAngle = 0x3ac // float (Size: 0x4)
SGProjectileTrajectory.bDebugPoint = 0x3b0 // bool (Size: 0x1)
SGProjectileTrajectory.DebugNormalLength = 0x3b4 // float (Size: 0x4)
SGProjectileTrajectory.FarEndLineScaleCurve = 0x3b8 // CurveFloat* (Size: 0x8)
SGProjectileTrajectory.NearHandLineScaleCurve = 0x3c0 // CurveFloat* (Size: 0x8)
SGProjectileTrajectory.NearHandScaleLineNum = 0x3c8 // uint8_t (Size: 0x1)
SGProjectileTrajectory.PointLocAndVelocityMap = 0x3d0 // TMap<...> (Size: 0x50)
SGProjectileTrajectory.StartLocation = 0x420 // FVector (Size: 0xc)
SGProjectileTrajectory.InitialVelocity = 0x42c // FVector (Size: 0xc)
SGProjectileTrajectory.Gravity = 0x438 // float (Size: 0x4)
SGProjectileTrajectory.PathLifeTime = 0x43c // float (Size: 0x4)
SGProjectileTrajectory.TimeInterval = 0x440 // float (Size: 0x4)
SGProjectileTrajectory.BeamSegmentParticleSystem = 0x448 // ParticleSystem* (Size: 0x8)
SGProjectileTrajectory.BeamForeSegmentParticleSystem = 0x450 // ParticleSystem* (Size: 0x8)
SGProjectileTrajectory.BeamForeCount = 0x458 // int32_t (Size: 0x4)
SGProjectileTrajectory.TranslucencySortPriorityOverride = 0x45c // int32_t (Size: 0x4)
SGProjectileTrajectory.BeamSegmentParticleSystemComponentArray = 0x460 // TArray<ParticleSystemComponent*> (Size: 0x10)
SGProjectileTrajectory.SplineMeshComponentArray = 0x470 // TArray<SplineMeshComponent*> (Size: 0x10)
SGProjectileTrajectory.WarningParticleSystemComponent = 0x480 // ParticleSystemComponent* (Size: 0x8)
SGProjectileTrajectoryStraight.MissedColor = 0x490 // FLinearColor (Size: 0x10)
SGProjectileTrajectoryStraight.HittedColor = 0x4a0 // FLinearColor (Size: 0x10)
SGProjectileVisionPersistenceComponent.ApplyEffect = 0x100 // bool (Size: 0x1)
SGProjectileVisionPersistenceComponent.EffectDistanceConfArray = 0x108 // TArray<FEffectDistanceConfArray> (Size: 0x10)
SGProjectileVisionPersistenceComponent.BasicEffectCurve = 0x118 // CurveFloat* (Size: 0x8)
SGProjectileVisionPersistenceComponent.WhiteEffectCurve = 0x120 // CurveFloat* (Size: 0x8)
SGProjectileVisionPersistenceComponent.MovingEffectCurve = 0x128 // CurveVector* (Size: 0x8)
SGProjectileVisionPersistenceComponent.bApplyOnlyInPOV = 0x130 // bool (Size: 0x1)
SGProjectileVisionPersistenceComponent.FlashFOVAngle = 0x134 // float (Size: 0x4)
SGProjectileVisionPersistenceComponent.FlashTimeScaleAngleCurve = 0x138 // CurveFloat* (Size: 0x8)
SGProjectileVisionPersistenceComponent.PPV = 0x140 // PostProcessVolume* (Size: 0x8)
SGProjectileVisionPersistenceComponent.StunResults = 0x148 // TArray<Actor*> (Size: 0x10)
SGProjectile_GravityBullet.bDebugBullet = 0x3a8 // bool (Size: 0x1)
SGProjectile_GravityBullet.bDebugBulletTrace = 0x3a9 // bool (Size: 0x1)
SGProjectile_GravityBullet.bDrawDebugPoint = 0x3aa // bool (Size: 0x1)
SGProjectile_GravityBullet.DrawDebugTime = 0x3ac // float (Size: 0x4)
SGProjectile_GravityBullet.BulletCollisionComp = 0x3b0 // SphereComponent* (Size: 0x8)
SGProjectile_GravityBullet.BulleParticleComp = 0x3b8 // ParticleSystemComponent* (Size: 0x8)
SGProjectile_GravityBullet.MaxConsiderThickness = 0x3c0 // float (Size: 0x4)
SGProjectile_GravityBullet.CurrentBulletTraceDataAsset = 0x3c8 // BulletTraceDataAsset* (Size: 0x8)
SGProjectile_GravityBullet.AmmoClass = 0x3f8 // ClassProperty (Size: 0x8)
SGProjectile_GravityBullet.BulletMovementComp = 0x400 // SGBulletMovementComponent* (Size: 0x8)
SGProjectile_GravityBullet.BulletRotationOffset = 0x408 // FRotator (Size: 0xc)
SGProjectile_GravityBullet.bStayAfterStop = 0x414 // bool (Size: 0x1)
SGProjectile_GravityBullet.ProjectileStayTime = 0x418 // float (Size: 0x4)
SGProjectile_GravityBullet.bSpawnOnServer = 0x41c // bool (Size: 0x1)
SGProjectile_GravityBullet.bShouldDamageDynamicObjects = 0x41d // bool (Size: 0x1)
SGProjectile_GravityBullet.BulletInitVelocity = 0x420 // FVector (Size: 0xc)
SGProjectile_GravityBullet.BulletInitLocation = 0x42c // FVector (Size: 0xc)
SGProjectile_GravityBullet.ZeroGravityDistance = 0x448 // float (Size: 0x4)
SGProjectile_GravityBullet.HorizontalVelocityDecRate = 0x44c // float (Size: 0x4)
SGProjectile_GravityBullet.ZeroHorizontalVelocityDecDistance = 0x450 // float (Size: 0x4)
SGProjectile_GravityBullet.LastCheckLocation = 0x458 // FVector (Size: 0xc)
SGProjectile_GravityBullet.bShouldStopDamage = 0x464 // bool (Size: 0x1)
SGProjectile_GravityBullet.PointDamageEvent = 0x470 // FSGPointDamageEvent (Size: 0x130)
SGProjectile_GravityBullet.bEnableToBetterPart = 0x5a0 // bool (Size: 0x1)
SGProjectile_GravityBullet.CaptureWeaponZoomingType = 0x5b9 // EESGZoomType (Size: 0x1)
SGProjectile_GravityBullet.HitHostileMovableArmor = 0x5c0 // SGInventory* (Size: 0x8)
SGProjectile_GravityBullet_HD.bDebugBulletTrace = 0x3a8 // bool (Size: 0x1)
SGProjectile_GravityBullet_HD.BulletCollisionComp = 0x3b0 // SphereComponent* (Size: 0x8)
SGProjectile_GravityBullet_HD.BulletFXComp = 0x3b8 // NiagaraComponent* (Size: 0x8)
SGProjectile_GravityBullet_HD.AmmoClass = 0x3c0 // ClassProperty (Size: 0x8)
SGProjectile_GravityBullet_HD.BulletMovementComp = 0x3c8 // SGBulletMovementComponent_HD* (Size: 0x8)
SGProjectile_GravityBullet_HD.BulletRotationOffset = 0x3d0 // FRotator (Size: 0xc)
SGProjectile_GravityBullet_HD.bShouldDamageDynamicObjects = 0x3dc // bool (Size: 0x1)
SGProjectile_GravityBullet_HD.OwnerWeapon = 0x3e0 // SGWeapon* (Size: 0x8)
SGProjectile_InstantBullet.AmmoClass = 0x78 // ClassProperty (Size: 0x8)
SGProjectile_InstantBullet.BulletInitFlyDir = 0x80 // FVector (Size: 0xc)
SGProjectile_InstantBullet.BulletInitLocation = 0x8c // FVector (Size: 0xc)
SGProjectile_InstantBullet.IsPredestineHited = 0x98 // bool (Size: 0x1)
SGProjectile_InstantBullet.BulletID = 0xa0 // FSGBulletID (Size: 0x10)
SGProjectile_InstantBullet.HitPartID = 0xb0 // uint8_t (Size: 0x1)
SGProjectile_InstantBullet.bShouldDamageDynamicObjects = 0xb1 // bool (Size: 0x1)
SGProjectile_InstantBullet.PointDamageEvent = 0xb8 // FSGPointDamageEvent (Size: 0x130)
SGProjectile_InstantBullet.CaptureWeaponZoomingType = 0x1e8 // EESGZoomType (Size: 0x1)
SGProjectile_InstantBullet.SpecifiedHitGroup = 0x1e9 // EEHitGroupType (Size: 0x1)
SGProjectile_InstantBullet.bEnableToBetterPart = 0x1ea // bool (Size: 0x1)
SGProjectile_InstantBullet.bEnableToHelmetPartIfHitHead = 0x1eb // bool (Size: 0x1)
SGProjectile_InstantBullet.MaxConsiderThickness = 0x1ec // float (Size: 0x4)
SGProne360BlendSpace.BlendSpace = 0x0 // BlendSpace* (Size: 0x8)
SGProne360BlendSpace.Angle = 0x8 // float (Size: 0x4)
SGProne360Montage.Montage = 0x0 // AnimMontage* (Size: 0x8)
SGProne360Montage.Angle = 0x8 // float (Size: 0x4)
SGProne360Sequence.Sequence = 0x0 // AnimSequence* (Size: 0x8)
SGProne360Sequence.Angle = 0x8 // float (Size: 0x4)
SGRadialDamageEvent.BaseMomentumMag = 0x40 // float (Size: 0x4)
SGRadialDamageEvent.bScaleMomentum = 0x44 // bool (Size: 0x1)
SGRadialDamageEvent.SceneItemID = 0x48 // uint32_t (Size: 0x4)
SGRadialDamageEvent.ProjectilePenetrationFactor = 0x4c // float (Size: 0x4)
SGRadialDamageEventObject.BaseMomentumMag = 0x60 // float (Size: 0x4)
SGRadialDamageEventObject.bScaleMomentum = 0x64 // bool (Size: 0x1)
SGRadialDamageEventObject.SceneItemID = 0x68 // uint32_t (Size: 0x4)
SGRadialDamageEventObject.ProjectilePenetrationFactor = 0x6c // float (Size: 0x4)
SGRagdollBakedBoneInfo.ServerRagdollStage = 0x0 // EESGRagdollStage (Size: 0x1)
SGRagdollBakedBoneInfo.ServerRagdollStartTime = 0x4 // float (Size: 0x4)
SGRagdollBakedBoneInfo.BakedBoneRotationTranslations = 0x8 // TArray<FSGPoseSnapshotRotationTranslation> (Size: 0x10)
SGRagdollBakedBoneInfo.SnapshotBoneNames = 0x18 // TArray<FName> (Size: 0x10)
SGRagdollCriticalBoneInfo_HD.BoneName = 0x0 // FName (Size: 0x8)
SGRagdollCriticalBoneInfo_HD.DisplacementTolerance = 0x8 // float (Size: 0x4)
SGRagdollCriticalBoneInfo_HD.LocationSampleNum = 0xc // int32_t (Size: 0x4)
SGRagdollData_HD.RootMotionCapsuleRadius = 0x30 // float (Size: 0x4)
SGRagdollData_HD.CriticalBones = 0x38 // TArray<FSGRagdollCriticalBoneInfo_HD> (Size: 0x10)
SGRagdollData_HD.CollisionCheckBones = 0x48 // TArray<FName> (Size: 0x10)
SGRagdollData_HD.DeathAnimationStrength = 0x58 // float (Size: 0x4)
SGRagdollData_HD.DefaultImpulseScale = 0x5c // float (Size: 0x4)
SGRagdollData_HD.ImpulseScaleOverrideOnBones = 0x60 // TMap<...> (Size: 0x50)
SGRagdollData_HD.GrenadeImpulseScale = 0xb0 // float (Size: 0x4)
SGRagdollImpulseApplyInfo.DamageCauser = 0x0 // Actor* (Size: 0x8)
SGRagdollImpulseApplyInfo.DamageCauserType = 0x8 // EESGDamageCauserType (Size: 0x1)
SGRagdollImpulseApplyInfo.Momentum = 0xc // FVector (Size: 0xc)
SGRagdollImpulseApplyInfo.HitLocation = 0x18 // FVector (Size: 0xc)
SGRagdollImpulseApplyInfo.HitBoneName = 0x24 // FName (Size: 0x8)
SGRagdollImpulseLinkInfo.Bone1 = 0x0 // FName (Size: 0x8)
SGRagdollImpulseLinkInfo.Bone2 = 0x8 // FName (Size: 0x8)
SGRagdollImpulseLinkInfo.LinkRatio = 0x10 // float (Size: 0x4)
SGRagdollInfo.bIsRagdoll = 0x0 // bool (Size: 0x1)
SGRagdollInfo.RagdollPose = 0x8 // FPoseSnapshot (Size: 0x38)
SGRandomDistributionCurve.ParameterCurve = 0x0 // CurveFloat* (Size: 0x8)
SGRandomMontageList.MontageList = 0x0 // TArray<AnimMontage*> (Size: 0x10)
SGRangeInAreaComponent.GroupID = 0xf8 // int32_t (Size: 0x4)
SGRangeInAreaComponent.Radius = 0xfc // float (Size: 0x4)
SGRangeInAreaComponent.UpperHight = 0x100 // float (Size: 0x4)
SGRangeInAreaComponent.LowerHight = 0x104 // float (Size: 0x4)
SGRangeInAreaComponent.AreaType = 0x108 // EERangeInAreaType (Size: 0x1)
SGRangeInAreaComponent.CharactersIn = 0x110 // TArray<Pawn*> (Size: 0x10)
SGRangeTargetBase.TargetMesh = 0x318 // StaticMeshComponent* (Size: 0x8)
SGRangeTargetBase.IsEnableTakeDamage = 0x321 // bool (Size: 0x1)
SGRangeTargetBase.bEnableRotate = 0x322 // bool (Size: 0x1)
SGRangeTargetBase.Startrotate = 0x323 // bool (Size: 0x1)
SGRangeTargetBase.StartReRotate = 0x324 // bool (Size: 0x1)
SGRangeTargetBase.RotateSpeed = 0x328 // int32_t (Size: 0x4)
SGRangeTargetBase.ReStoreTime = 0x32c // int32_t (Size: 0x4)
SGRangeTargetBase.RaiseSound = 0x330 // AkAudioEvent* (Size: 0x8)
SGRangeTargetBase.FallSound = 0x338 // AkAudioEvent* (Size: 0x8)
SGRangeTargetBase.ReplaceRotateTimerHandle = 0x340 // FTimerHandle (Size: 0x8)
SGRangeTargetBase.SetRotateTimerHandle = 0x348 // FTimerHandle (Size: 0x8)
SGRangeTargetBase.SetReRotateTimerHandle = 0x350 // FTimerHandle (Size: 0x8)
SGRangeTargetBase.OnTakeDamege = 0x358 // FMulticastInlineDelegate (Size: 0x10)
SGRangeTargetBase.bCanBeDamagedByThrowableWeapon = 0x368 // bool (Size: 0x1)
SGRelaxAnimationArray.RelaxAnimation = 0x0 // TArray<AnimSequence*> (Size: 0x10)
SGReloadBoresOneByOneAnimParams.BoreIndex = 0x0 // int32_t (Size: 0x4)
SGReloadBoresOneByOneAnimParams.bRemoveOldBullet = 0x4 // bool (Size: 0x1)
SGReloadBoresOneByOneAnimParams.NewBulletMesh = 0x8 // StaticMesh* (Size: 0x8)
SGReloadBoresOneByOneAnimParams.DepProvider = 0x10 // FRepDependency (Size: 0x18)
SGReplayController.FollowTarget = 0x958 // TWeakObjectPtr<UObject> (Size: 0x8)
SGReplayController.OnFollowTargetChanged = 0x960 // FMulticastInlineDelegate (Size: 0x10)
SGReplayController.bFollowTargetRotation = 0x970 // bool (Size: 0x1)
SGReplayController.FollowLocationInterpMax = 0x974 // float (Size: 0x4)
SGReplayController.FollowLocationInterpSpeed = 0x978 // float (Size: 0x4)
SGReplayController.FollowRotationInterpSpeed = 0x97c // float (Size: 0x4)
SGReplayController.FollowLocationOffsetWhenNoCamera = 0x980 // FVector (Size: 0xc)
SGReplayController.ObserverAttachToMeshLocation = 0x98c // FVector (Size: 0xc)
SGReplayController.ObserverAttachToMeshRotation = 0x998 // FRotator (Size: 0xc)
SGReplayController.Follow3PDist = 0x9a4 // float (Size: 0x4)
SGReplayController.ObserverPawn = 0x9a8 // TWeakObjectPtr<UObject> (Size: 0x8)
SGReplayInfo.ReplayType = 0x0 // FName (Size: 0x8)
SGReplayInfo.StartTime = 0x8 // float (Size: 0x4)
SGReplayInfo.OnFinish = 0x10 // FString (Size: 0x10)
SGReplayInfo.ObserverControllerClass = 0x20 // ClassProperty (Size: 0x8)
SGReplayInfo.ObserverPlayerControllerId = 0x28 // int32_t (Size: 0x4)
SGReplayInfo.ReplayFileName = 0x30 // FString (Size: 0x10)
SGReplayInfo.bIsInBattleDownload = 0x40 // bool (Size: 0x1)
SGReplaySettings.ObserverControllerClass = 0x38 // FSoftClassPath (Size: 0x18)
SGReplaySettings.ObserverPawnClass = 0x50 // FSoftClassPath (Size: 0x18)
SGReplaySettings.ObserverHUDClass = 0x68 // FSoftClassPath (Size: 0x18)
SGReplaySettings.ReplayLoadingUI = 0x80 // FSoftClassPath (Size: 0x18)
SGReplaySettings.ReplayPerspectiveMaterial = 0x98 // TSoftObjectPtr<UObject> (Size: 0x28)
SGReplaySettings.KillCamEnableMinDeviceLevel = 0xc0 // int32_t (Size: 0x4)
SGReplaySettings.KillCamPlaySafeLength = 0xc4 // float (Size: 0x4)
SGReplaySettings.KillCamRecordLengthBeforeDead = 0xc8 // float (Size: 0x4)
SGReplaySettings.KillCamRecordLengthAfterDead = 0xcc // float (Size: 0x4)
SGReplaySettings.KillCamCheckPointLength = 0xd0 // float (Size: 0x4)
SGReplaySettings.KillCamCheckpointSaveMaxMSPerFrame = 0xd4 // float (Size: 0x4)
SGReplaySettings.KillCamDefaultUseFirstPersonCamera = 0xd8 // bool (Size: 0x1)
SGReplaySettings.KillCamPMCUseFirstPersonCamera = 0xd9 // bool (Size: 0x1)
SGReplaySettings.KillCamScavUseFirstPersonCamera = 0xda // bool (Size: 0x1)
SGReplaySettings.KillCamPlayerForceFirstPersonCamera = 0xdb // bool (Size: 0x1)
SGReplaySettings.PlaybackOptDist = 0xdc // float (Size: 0x4)
SGReplaySettings.KillCamCountDownTime = 0xe0 // float (Size: 0x4)
SGReplaySettings.bDisableScavAIKillCam = 0xe4 // bool (Size: 0x1)
SGReplaySettings.MinLevelLoadPercent = 0xe8 // float (Size: 0x4)
SGReplaySettings.LevelLoadMaxTime = 0xec // float (Size: 0x4)
SGReplaySettings.ViewTargetMaxWaitTime = 0xf0 // float (Size: 0x4)
SGReplaySettings.ViewTargetMaxLoadTime = 0xf4 // float (Size: 0x4)
SGReplaySettings.DSReplayEnable = 0xf8 // int32_t (Size: 0x4)
SGReplaySettings.DSReplaySavePath = 0x100 // FString (Size: 0x10)
SGReplaySettings.ShouldPreDuplicateMaps = 0x110 // TArray<FFilePath> (Size: 0x10)
SGReplayUserSettings.DebugMode = 0x38 // bool (Size: 0x1)
SGReplayUserSettings.ReplayFileHistory = 0x40 // TArray<FString> (Size: 0x10)
SGSceneFOV_BaseSetting.SceneFOVMinValue = 0x38 // int32_t (Size: 0x4)
SGSceneFOV_BaseSetting.SceneFOVMaxValue = 0x3c // int32_t (Size: 0x4)
SGSceneFOV_BaseSetting.SceneFOVValue = 0x40 // int32_t (Size: 0x4)
SGSceneScanDevice.SceneScanDeviceIndex = 0x310 // int32_t (Size: 0x4)
SGSceneScanDevice.UseBetweenTime = 0x314 // float (Size: 0x4)
SGSceneScanDevice.CanScanAreaIDList = 0x318 // TArray<int32_t> (Size: 0x10)
SGSceneScanDevice.bAlreadyUse = 0x328 // bool (Size: 0x1)
SGSceneScanDevice.bOnUsing = 0x329 // bool (Size: 0x1)
SGSceneScanDevice.UsingCharacterCache = 0x330 // Actor* (Size: 0x8)
SGSceneScanDevice.UseBetweenTimeHandle = 0x338 // float (Size: 0x4)
SGSecurityCamera.CameraID = 0x9d0 // int32_t (Size: 0x4)
SGSecurityCamera.CameraName = 0x9d8 // FText (Size: 0x18)
SGSecurityCamera.ActiveAudioEvent = 0x9f0 // AkAudioEvent* (Size: 0x8)
SGSecurityCamera.DeactiveAudioEvent = 0x9f8 // AkAudioEvent* (Size: 0x8)
SGSecurityCamera.ActivateEffect = 0xa00 // FXSystemAsset* (Size: 0x8)
SGSecurityCamera.EffectSocketName = 0xa08 // FName (Size: 0x8)
SGSecurityCamera.EffectFXSC = 0xa10 // FXSystemComponent* (Size: 0x8)
SGSecurityMonitor.AvailableCameraIDList = 0x8a0 // TArray<int32_t> (Size: 0x10)
SGSecurityMonitor.BatteryEndurance = 0x8b0 // float (Size: 0x4)
SGSecurityMonitor.BatteryRechargeTime = 0x8b4 // float (Size: 0x4)
SGSecurityMonitor.bActivate = 0x8b8 // bool (Size: 0x1)
SGSecurityMonitor.bAvailable = 0x8b9 // bool (Size: 0x1)
SGSecurityMonitor.InteractingCharacter = 0x8c0 // Character* (Size: 0x8)
SGSecurityMonitor.ActivateEffect = 0x8c8 // FXSystemAsset* (Size: 0x8)
SGSecurityMonitor.AvailableEffect = 0x8d0 // FXSystemAsset* (Size: 0x8)
SGSecurityMonitor.EffectSocketName = 0x8d8 // FName (Size: 0x8)
SGSecurityMonitor.AudioEvents = 0x8e0 // TArray<AkAudioEvent*> (Size: 0x10)
SGSecurityMonitor.EffectFXSC = 0x8f0 // FXSystemComponent* (Size: 0x8)
SGSecurityMonitor.ServerShutdownTime = 0x8f8 // float (Size: 0x4)
SGSecurityMonitor.ServerRestartTime = 0x8fc // float (Size: 0x4)
SGSecurityMonitor.SecurityCameras = 0x910 // TArray<Actor*> (Size: 0x10)
SGSecurityMonitor.CurrentCameraIndex = 0x920 // int32_t (Size: 0x4)
SGSequenceGroupPlayer.Curve = 0x0 // CurveFloat* (Size: 0x8)
SGSequenceSwitherComponent.Sequence = 0x40 // LevelSequence* (Size: 0x8)
SGSequenceSwitherComponent.RootActor = 0x48 // Actor* (Size: 0x8)
SGSequenceSwitherComponent.bForcePlayToEnd = 0x50 // bool (Size: 0x1)
SGSequenceSwitherComponent.PlaySetting = 0x54 // FMovieSceneSequencePlaybackSettings (Size: 0x14)
SGSequenceSwitherComponent.PlayStartTime = 0x68 // float (Size: 0x4)
SGSequenceSwitherComponent.PlayEndTime = 0x6c // float (Size: 0x4)
SGSequenceSwitherComponent.DelayTime = 0x70 // float (Size: 0x4)
SGSequenceSwitherComponent.LevelSequencePlayer = 0x80 // LevelSequencePlayer* (Size: 0x8)
SGSequenceSwitherComponent.LevelSequenceActor = 0x88 // LevelSequenceActor* (Size: 0x8)
SGSequenceSwitherComponent.SequenceBaseClass = 0x90 // ClassProperty (Size: 0x8)
SGSequenceSwitherComponent.SequenceDuration = 0x98 // float (Size: 0x4)
SGServerHitInfo.Timestamp = 0x0 // float (Size: 0x4)
SGServerHitInfo.BulletID = 0x8 // FSGBulletID (Size: 0x10)
SGServerHitInfo.ShotDirection = 0x18 // FVector (Size: 0xc)
SGServerHitInfo.HitActor = 0x28 // Actor* (Size: 0x8)
SGServerHitInfo.Component = 0x30 // PrimitiveComponent* (Size: 0x8)
SGServerHitInfo.HitActorLocation = 0x38 // FVector (Size: 0xc)
SGServerHitInfo.HitActorRotationPacked = 0x44 // uint32_t (Size: 0x4)
SGServerHitInfo.FireEndLocation = 0x48 // FVector (Size: 0xc)
SGServerHitInfo.ImpactNormal = 0x54 // FVector (Size: 0xc)
SGServerHitInfo.Impulse = 0x60 // float (Size: 0x4)
SGServerHitInfo.PhysMaterial = 0x68 // PhysicalMaterial* (Size: 0x8)
SGServerHitInfo.HitGroup = 0x70 // EEHitGroupType (Size: 0x1)
SGServerHitInfo.HeadHitSubGroup = 0x71 // EEHeadHitSubGroupType (Size: 0x1)
SGServerHitInfo.BoneName = 0x74 // FName (Size: 0x8)
SGServerHitInfo.CaptureWeaponZoomType = 0x7c // EESGZoomType (Size: 0x1)
SGServerHitInfo.HitMovableArmor = 0x80 // SGInventory* (Size: 0x8)
SGServerHitInfo.HitFlags = 0x88 // uint8_t (Size: 0x1)
SGServerHitInfo.bTakerIsCrouchClient = 0x89 // uint8_t (Size: 0x1)
SGServerHitInfo.bTakerIsProneClient = 0x89 // uint8_t (Size: 0x1)
SGServerHitInfo.bTakerIsDBNOClient = 0x89 // uint8_t (Size: 0x1)
SGServerHitInfo.bTakerIsLeaning = 0x89 // uint8_t (Size: 0x1)
SGServerHitInfo.MoveReceivedTimeDelta = 0x8c // float (Size: 0x4)
SGServerMoveResult.ClientTimeStamp = 0x0 // float (Size: 0x4)
SGServerMoveResult.DeltaTime = 0x4 // float (Size: 0x4)
SGServerMoveResult.MoveResultType = 0x8 // EEServerMoveResultType (Size: 0x1)
SGServerMoveResult.MoveType = 0xc // int32_t (Size: 0x4)
SGShowControlActor.ShowControlComponent = 0x310 // SGShowControlComponent* (Size: 0x8)
SGShowControlComponent.GlobalSwithComponents = 0xf8 // TArray<SGShowSwithBaseComponent*> (Size: 0x10)
SGShowControlComponent.OrientationSwithComponents = 0x108 // TArray<SGShowSwithBaseComponent*> (Size: 0x10)
SGShowControlComponent.bGlobleShowCache = 0x118 // bool (Size: 0x1)
SGShowControlComponent.bOrientationShowCache = 0x119 // bool (Size: 0x1)
SGShowControlComponent.bOrientationContainPC = 0x11a // bool (Size: 0x1)
SGShowControlComponent.bActiveState = 0x11b // bool (Size: 0x1)
SGShowControlComponent.OrientationPlayers = 0x120 // TArray<PlayerController*> (Size: 0x10)
SGShowControlComponent.bHasActived = 0x130 // bool (Size: 0x1)
SGShowControlComponent.BeginSecond = 0x134 // float (Size: 0x4)
SGShowControlEffectActor.NiagaraComponent = 0x310 // NiagaraComponent* (Size: 0x8)
SGShowControlEffectActor.NiagaraSystem = 0x318 // NiagaraSystem* (Size: 0x8)
SGShowControlEffectActor.BillboardComponent = 0x320 // BillboardComponent* (Size: 0x8)
SGShowControlEffectActor.NeedShowObjArr = 0x328 // TArray<Object*> (Size: 0x10)
SGShowControlSoundActor.AkAudioEvent = 0x310 // AkAudioEvent* (Size: 0x8)
SGShowControlSoundActor.ControlType = 0x318 // EESCSType (Size: 0x1)
SGShowControlSoundActor.TimeType = 0x319 // EESCSTimeType (Size: 0x1)
SGShowControlSoundActor.SoundMap = 0x320 // TMap<...> (Size: 0x50)
SGShowSwithBaseComponent.bOnlyServer = 0x28 // bool (Size: 0x1)
SGShowSwithBaseComponent.bCacheActiveState = 0x29 // bool (Size: 0x1)
SGShowSwithBaseComponent.ShowControlComponent = 0x30 // SGShowControlComponent* (Size: 0x8)
SGShowSwithBaseComponent.GlobalControlFlag = 0x38 // EESGShowSwitchGlobalControlFlag (Size: 0x1)
SGSimpleAnimSwitherComponent.DelayTime = 0x48 // float (Size: 0x4)
SGSimpleAnimSwitherComponent.PlayTime = 0x4c // float (Size: 0x4)
SGSimpleAnimSwitherComponent.AnimActor = 0x50 // Actor* (Size: 0x8)
SGSimpleAnimSwitherComponent.bHiddenWhenDeactive = 0x58 // bool (Size: 0x1)
SGSimpleAnimSwitherComponent.BeginLocation = 0x5c // FVector (Size: 0xc)
SGSimpleAnimSwitherComponent.BeginRotation = 0x68 // FRotator (Size: 0xc)
SGSimpleAnimSwitherComponent.EndLocation = 0x74 // FVector (Size: 0xc)
SGSimpleAnimSwitherComponent.EndRotation = 0x80 // FRotator (Size: 0xc)
SGSimpleAnimSwitherComponent.HaveInitState = 0x8c // bool (Size: 0x1)
SGSimpleAnimSwitherComponent.InitLocation = 0x90 // FVector (Size: 0xc)
SGSimpleAnimSwitherComponent.InitRotation = 0x9c // FRotator (Size: 0xc)
SGSimpleAnimSwitherComponent.RateCurve = 0xa8 // CurveFloat* (Size: 0x8)
SGSimpleAnimSwitherComponent.Timer = 0xb0 // float (Size: 0x4)
SGSimpleAnimSwitherComponent.bPlaying = 0xb4 // bool (Size: 0x1)
SGSimpleAnimSwitherComponent.bHasPlayed = 0xb5 // bool (Size: 0x1)
SGSingleChatContent.Name = 0x0 // FString (Size: 0x10)
SGSingleChatContent.Content = 0x10 // FString (Size: 0x10)
SGSkeletalMeshComponentBudgeted.AnimDebugLogContainer = 0x1128 // FSGAnimationDebugLogContainer (Size: 0x10)
SGSkeletalMeshComponentBudgeted.LastUpdateLog = 0x1138 // FSGAnimationDebugLogLine (Size: 0x20)
SGSkeletalMeshComponentBudgeted.LastEvaluateLog = 0x1158 // FSGAnimationDebugLogLine (Size: 0x20)
SGSkeletalMeshMerge.CachedMergedSkeletalMesh = 0x28 // SkeletalMesh* (Size: 0x8)
SGSkeletalMeshMerge.CachedAvatarMergeComponent = 0x30 // SGCharacterAvatarMergeComponent* (Size: 0x8)
SGSkeletalMeshSwitcherComponent.SkeletalMeshActor = 0x40 // SkeletalMeshActor* (Size: 0x8)
SGSkeletalMeshSwitcherComponent.ResetMontage = 0x48 // AnimMontage* (Size: 0x8)
SGSkeletalMeshSwitcherComponent.bShowState = 0x50 // bool (Size: 0x1)
SGSlidingDoorPlankComponent.DoorSlidingStartPos = 0x6a0 // FVector (Size: 0xc)
SGSlidingDoorPlankComponent.DoorSlidingEndPos = 0x6ac // FVector (Size: 0xc)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemPos = 0x6b8 // FVector (Size: 0xc)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemRot = 0x6c4 // FRotator (Size: 0xc)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemBackPos = 0x6d0 // FVector (Size: 0xc)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemBackRot = 0x6dc // FRotator (Size: 0xc)
SGSlidingDoorPlankComponent.DoorClosedEdgePos = 0x6e8 // FVector (Size: 0xc)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemLock = 0x6f8 // ParticleSystemComponent* (Size: 0x8)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemLockBack = 0x700 // ParticleSystemComponent* (Size: 0x8)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemUnlock = 0x708 // ParticleSystemComponent* (Size: 0x8)
SGSlidingDoorPlankComponent.SlideDoorParticleSystemUnlockBack = 0x710 // ParticleSystemComponent* (Size: 0x8)
SGSlidingDoorPlankComponent.PushOutVelocity = 0x718 // float (Size: 0x4)
SGSlidingDoorPlankComponent.PushVerticalRange = 0x71c // float (Size: 0x4)
SGSlidingDoorPlankComponent.DoorPlankWidth = 0x720 // float (Size: 0x4)
SGSmokeActor.bIsTearGasSmoke = 0x690 // bool (Size: 0x1)
SGSoundSwitherComponent.SoundActor = 0x48 // Actor* (Size: 0x8)
SGSoundSwitherComponent.AkAudioEvent = 0x50 // AkAudioEvent* (Size: 0x8)
SGSoundSwitherComponent.DelayTime = 0x58 // float (Size: 0x4)
SGSoundSwitherComponent.PlayTime = 0x5c // float (Size: 0x4)
SGSpawnInventoryBGWorldSubsystem.PreloadSubsystemTickFunction = 0x30 // FSpawnInventoryBGTickFunction (Size: 0x40)
SGSpawnInventoryBGWorldSubsystem.RoundModeEquipmentList = 0x70 // TArray<FEquipmentItemInfo> (Size: 0x10)
SGSpecialInventoryDetail.IconPath = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGSpecialInventoryDetail.InventorySpecialTypeName = 0x28 // FText (Size: 0x18)
SGSpecialInventoryDetail.InventorySpecialTypeDetail = 0x40 // FText (Size: 0x18)
SGSpectatorPawn.bNeedDelaySetMovementMode = 0x5d8 // uint8_t (Size: 0x1)
SGSpectatorPawn.TimerHandle = 0x5e0 // FTimerHandle (Size: 0x8)
SGSpectatorPawn.bAddDefaultMovementBindings = 0x5e8 // uint8_t (Size: 0x1)
SGSpectatorPawn.OnLockHeightStateChange = 0x5f0 // FMulticastInlineDelegate (Size: 0x10)
SGSpectatorPawn.BaseTurnRate = 0x600 // float (Size: 0x4)
SGSpectatorPawn.BaseLookUpRate = 0x604 // float (Size: 0x4)
SGSpectatorPawn.DefaultFlySpeed = 0x608 // float (Size: 0x4)
SGSpectatorPawn.MaxHeight = 0x60c // float (Size: 0x4)
SGSpectatorPawn.IgnoreClassArray = 0x610 // TArray<ClassProperty> (Size: 0x10)
SGSpectatorPawn.CharacterCameraComponent = 0x620 // CameraComponent* (Size: 0x8)
SGSpectatorPawn.IsSprint = 0x628 // bool (Size: 0x1)
SGSpectatorPawn.bLockHeight = 0x629 // bool (Size: 0x1)
SGSpectatorPawn.ViewRotationOffset = 0x62c // FRotator (Size: 0xc)
SGSpectatorPawn.FOVSpeed = 0x638 // float (Size: 0x4)
SGSprayActor.SprayMaterial = 0x320 // MaterialInterface* (Size: 0x8)
SGSprayActor.DecalLocation = 0x328 // FVector (Size: 0xc)
SGSprayActor.DecalRotation = 0x334 // FRotator (Size: 0xc)
SGSprayActor.DecalSize = 0x340 // FVector (Size: 0xc)
SGSprayActor.DecalTexturePath = 0x350 // FString (Size: 0x10)
SGSprayActor.DecalOffset = 0x360 // float (Size: 0x4)
SGSprayActor.DynamicMaterial = 0x368 // MaterialInstanceDynamic* (Size: 0x8)
SGStatBulletInfo.AIOwner = 0x28 // Actor* (Size: 0x8)
SGStatBulletInfo.bAIShot = 0x30 // uint8_t (Size: 0x1)
SGStatBulletInfo.bHit = 0x30 // uint8_t (Size: 0x1)
SGStatBulletInfo.bIsUsePredestined = 0x30 // uint8_t (Size: 0x1)
SGStatBulletInfo.ShootPartID = 0x31 // uint8_t (Size: 0x1)
SGStatBulletInfo.HitPartID = 0x32 // uint8_t (Size: 0x1)
SGStatBulletInfo.InstigatorType = 0x33 // uint8_t (Size: 0x1)
SGStatBulletInfo.ShootDistance = 0x34 // float (Size: 0x4)
SGStatBulletInfo.ArmorDamage = 0x38 // float (Size: 0x4)
SGStatBulletInfo.BodyDamage = 0x3c // float (Size: 0x4)
SGStatBulletInfo.WeaponId = 0x40 // int64_t (Size: 0x8)
SGStatBulletInfo.InstigatorID = 0x48 // int64_t (Size: 0x8)
SGStatBulletInfo.ShootOffset = 0x50 // FVector (Size: 0xc)
SGStatBulletInfo.AIPathGroupID = 0x60 // int64_t (Size: 0x8)
SGStatBulletInfo.PositionWantToShoot = 0x68 // FVector (Size: 0xc)
SGStatBulletInfo.PositionActualShoot = 0x74 // FVector (Size: 0xc)
SGStatBulletInfo.EnemyName = 0x80 // FString (Size: 0x10)
SGStatBulletInfo.EnemyID = 0x90 // uint64_t (Size: 0x8)
SGStatBulletInfo.BulletPenetrationFactor = 0x98 // int32_t (Size: 0x4)
SGStatBulletInfo.EnemyType = 0x9c // uint8_t (Size: 0x1)
SGStatBulletInfo.bPrevSeriouslyInjured = 0x9d // uint8_t (Size: 0x1)
SGStatBulletInfo.bNowSeriouslyInjured = 0x9d // uint8_t (Size: 0x1)
SGStatBulletInfo.PrevBrokenBodyPartNum = 0x9e // uint8_t (Size: 0x1)
SGStatBulletInfo.NowBrokenBodyPartNum = 0x9f // uint8_t (Size: 0x1)
SGStatBulletInfo.PrevBleedBodyPartNum = 0xa0 // uint8_t (Size: 0x1)
SGStatBulletInfo.NowBleedBodyPartNum = 0xa1 // uint8_t (Size: 0x1)
SGSwitchWeaponIntent.PredKey = 0x0 // int32_t (Size: 0x4)
SGSwitchWeaponIntent.bConfirmedByServer = 0x4 // bool (Size: 0x1)
SGSwitchWeaponIntent.bTakeUpWeapon = 0x5 // bool (Size: 0x1)
SGSwitchWeaponIntent.DestWeap = 0x8 // SGWeapon* (Size: 0x8)
SGSwitchWeaponIntent.DestLeftHandWeap = 0x10 // SGWeapon* (Size: 0x8)
SGSwitchWeaponIntent.bLastWeaponDropped = 0x18 // bool (Size: 0x1)
SGSwitchWeaponIntent.FinishTimeStamp = 0x1c // float (Size: 0x4)
SGSwitchWeaponIntent.RejectReason = 0x20 // EESwitchWeaponIntentRejectReason (Size: 0x1)
SGSwitchWeaponIntent.Type = 0x21 // EESwitchWeaponIntentType (Size: 0x1)
SGTPPRecoilConfig.AccumulateCurve = 0x0 // CurveFloat* (Size: 0x8)
SGTPPRecoilConfig.BlendOutCurve = 0x8 // CurveFloat* (Size: 0x8)
SGTPPRecoilConfig.Blend = 0x10 // FAlphaBlend (Size: 0x30)
SGTPPRecoilConfig.CurrentValue = 0x40 // float (Size: 0x4)
SGTacticWeaponAppearanceComponent.bFunctionTwistedWithCurrentWeaponState = 0xda0 // bool (Size: 0x1)
SGTacticWeaponAppearanceComponent.bIsRadar = 0xda1 // bool (Size: 0x1)
SGTacticWeaponAppearanceComponent.bPlayX5Effect = 0xdb0 // bool (Size: 0x1)
SGTacticWeaponAppearanceComponent.TwinkleEmitterTemplate = 0xdb8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGTacticWeaponAppearanceComponent.PSC = 0xde0 // ParticleSystemComponent* (Size: 0x8)
SGTacticWeaponAppearanceComponent.bHasCoolDown = 0xde8 // bool (Size: 0x1)
SGTacticWeaponAppearanceComponent.CoolDownWhenTakeUp = 0xde9 // bool (Size: 0x1)
SGTacticWeaponAppearanceComponent.CoolDownTime = 0xdec // float (Size: 0x4)
SGTacticWeaponAppearanceComponent.MovementDistanceWidgetClass = 0xdf0 // TSoftClassPtr<UObject> (Size: 0x28)
SGTacticWeaponAppearanceComponent.MovementDistanceWidgetClassLow = 0xe18 // TSoftClassPtr<UObject> (Size: 0x28)
SGTacticWeaponAppearanceComponent.MoveDistanceTextName = 0xe40 // FName (Size: 0x8)
SGTacticWeaponAppearanceComponent.TotalMoveDistanceTextName = 0xe48 // FName (Size: 0x8)
SGTacticWeaponAppearanceComponent.MoveFootImageName = 0xe50 // FName (Size: 0x8)
SGTacticWeaponAppearanceComponent.MovementDistanceDesc = 0xe58 // FText (Size: 0x18)
SGTacticWeaponAppearanceComponent.WidgetAttachTransform = 0xe70 // FTransform (Size: 0x30)
SGTacticWeaponAppearanceComponent.WidgetAttachTransformLow = 0xea0 // FTransform (Size: 0x30)
SGTacticWeaponAppearanceComponent.WidgetAttachSocketName = 0xed0 // FName (Size: 0x8)
SGTacticWeaponAppearanceComponent.MovementDistanceMissionFlowName = 0xed8 // FString (Size: 0x10)
SGTacticWeaponAppearanceComponent.MovementDistanceMissionName = 0xee8 // FString (Size: 0x10)
SGTacticWeaponAppearanceComponent.MovementDistanceCalibrationThreshold = 0xef8 // int32_t (Size: 0x4)
SGTacticWeaponAppearanceComponent.MovementDistanceAnimSpeedFactor = 0xefc // float (Size: 0x4)
SGTacticWeaponAppearanceComponent.TimerHandle_CoolDownDetect = 0xf00 // FTimerHandle (Size: 0x8)
SGTacticWeaponAppearanceComponent.WidgetActor = 0xf18 // Actor* (Size: 0x8)
SGTacticalPistolAnimationSet.IdleToTacticalAnimation = 0x0 // AnimMontage* (Size: 0x8)
SGTacticalPistolAnimationSet.TacticalToMainWeaponAnimation = 0x8 // AnimMontage* (Size: 0x8)
SGTacticalPistolAnimationSet.TacticalToPistolMontage = 0x10 // AnimMontage* (Size: 0x8)
SGTacticalPistolAnimationSet.TacticalToPistolMontage_Fast = 0x18 // AnimMontage* (Size: 0x8)
SGTacticalPistolAnimationSet.TacticalPutDownMontage = 0x20 // AnimMontage* (Size: 0x8)
SGTacticalPistolAnimationSet.TacticalRightHandNegAdditiveSequence = 0x28 // AnimSequence* (Size: 0x8)
SGTacticalPistolAnimationSet.DefaultTacticalPisotlGrip = 0x30 // AnimSequence* (Size: 0x8)
SGTakeDamageItem.HPChangedEvent = 0x310 // FMulticastInlineDelegate (Size: 0x10)
SGTakeDamageItem.MaxHP = 0x320 // float (Size: 0x4)
SGTakeDamageItem.CurrentHP = 0x324 // float (Size: 0x4)
SGTakeDamageItem.bFighting = 0x328 // bool (Size: 0x1)
SGTakeDamageItem.bEnableCollision = 0x329 // bool (Size: 0x1)
SGTakeHitInfo.TakeHitBlendSpace = 0x0 // BlendSpace* (Size: 0x8)
SGTakeHitInfo.TakeHitAnimationPlayRate = 0x8 // float (Size: 0x4)
SGTakeHitInfo.bBlendShapeSwitch = 0xc // bool (Size: 0x1)
SGTakeHitInfo.TakeHitDir = 0x10 // FVector2D (Size: 0x8)
SGTakeHitInfo.TakeHitAlpha = 0x18 // float (Size: 0x4)
SGTakeHitInfo.StartPos = 0x1c // float (Size: 0x4)
SGTakeOutReplaceRaw.ReplaceType = 0x0 // EESGTakeOutReplaceType (Size: 0x1)
SGTakeOutReplaceRaw.Faction = 0x1 // EEFactionType (Size: 0x1)
SGTakeOutReplaceRaw.FromItemID = 0x8 // uint64_t (Size: 0x8)
SGTakeOutReplaceRaw.ToItemID = 0x10 // uint64_t (Size: 0x8)
SGTakeOutReplaceRaw.ToItemNum = 0x18 // uint64_t (Size: 0x8)
SGTakeOutReplaceRaw.ExtraCondition0 = 0x20 // int64_t (Size: 0x8)
SGTakeOutReplaceTable.ReplaceRuleArr = 0x20 // TArray<FSGTakeOutReplaceRaw> (Size: 0x10)
SGTask_AttachExtraMesh.Weapon = 0x78 // SGWeapon* (Size: 0x8)
SGTask_AttachExtraMesh.BaseInv = 0x80 // SGInventory* (Size: 0x8)
SGTask_AttachExtraMesh.ExtraMeshID = 0x88 // uint32_t (Size: 0x4)
SGTask_AttachExtraMesh.BaseItemID = 0x8c // uint32_t (Size: 0x4)
SGTask_AttachExtraMesh.AssembleItemID = 0x90 // uint32_t (Size: 0x4)
SGTask_AttachExtraMesh.ActionType = 0x94 // uint32_t (Size: 0x4)
SGTask_AttachExtraMesh.Assets = 0x98 // TArray<Object*> (Size: 0x10)
SGTask_AttachExtraMesh.BlackSocketInfos = 0xa8 // TArray<FBlackSocketInfo> (Size: 0x10)
SGTask_AttachExtraMesh.BoneHiddenPairs = 0xb8 // TArray<FName> (Size: 0x10)
SGTask_AttachExtraMesh.CreatedMeshComp = 0xd8 // MeshComponent* (Size: 0x8)
SGTask_AttachExtraMesh.bIsUsingDynamicZoomClipMaterials = 0xe0 // bool (Size: 0x1)
SGTask_AttachExtraMesh.OriginMaterials = 0xe8 // TArray<MaterialInterface*> (Size: 0x10)
SGTask_AttachExtraMesh.ZoomClipMaterials = 0xf8 // TArray<MaterialInterface*> (Size: 0x10)
SGTask_AttachExtraMesh_HD.BaseInventory = 0x68 // SGInventory* (Size: 0x8)
SGTask_AttachExtraMesh_HD.MeshComponent = 0x70 // MeshComponent* (Size: 0x8)
SGTask_AttachExtraMesh_HD.OriginMaterials = 0x78 // TArray<MaterialInterface*> (Size: 0x10)
SGTask_AttachExtraMesh_HD.ZoomClipMaterials = 0x88 // TArray<MaterialInterface*> (Size: 0x10)
SGTeam.TeamMembers = 0x318 // TArray<Actor*> (Size: 0x10)
SGTeam.FactionComponent = 0x328 // SGActorFactionComponent* (Size: 0x8)
SGTeamDMGLimitInfo.RowNum = 0x0 // int32_t (Size: 0x4)
SGTeamDMGLimitInfo.ItemId = 0x8 // uint64_t (Size: 0x8)
SGTeamDMGLimitInfo.HitGroup = 0x10 // uint32_t (Size: 0x4)
SGTeamDMGLimitInfo.HealthThreshold = 0x14 // float (Size: 0x4)
SGTeamDMGLimitInfo.ReduceFactor = 0x18 // float (Size: 0x4)
SGTeamInfo.TeamInfoType = 0x340 // EETeamInfoType (Size: 0x1)
SGTeamInfo.TeamIndex = 0x344 // int32_t (Size: 0x4)
SGTeamInfo.TeamMemberCount = 0x348 // int32_t (Size: 0x4)
SGTeamInfo.MaxTeamMemberCount = 0x34c // int32_t (Size: 0x4)
SGTeamInfo.TeamName = 0x350 // FText (Size: 0x18)
SGTeamInfo.TeamLogo = 0x368 // int32_t (Size: 0x4)
SGTeamInfo.bPeriodicalDBNOWipeOut = 0x36c // bool (Size: 0x1)
SGTeamInfo.OBTeamMembers = 0x378 // TArray<Actor*> (Size: 0x10)
SGTeamInfo.TeamMemberPlayerStates = 0x388 // TArray<PlayerState*> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberPlayerStates = 0x398 // TArray<PlayerState*> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberPlayerNames = 0x3a8 // TArray<FString> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberIconInfo = 0x3b8 // TArray<FSGPlayerIconInfo> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberBannerInfo = 0x3c8 // TArray<FSGPlayerBannerInfo> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberPlayerNationalFlagIsos = 0x3d8 // TArray<int32_t> (Size: 0x10)
SGTeamInfo.InBattleTeamMemberPlayerCondition = 0x3e8 // TArray<EESGPlayerCondition> (Size: 0x10)
SGTeamInfo.TeamMemberAICharacters = 0x3f8 // TArray<SGAICharacter*> (Size: 0x10)
SGTeamInfo.TeamGuid2VisualIdxMapKey = 0x408 // TArray<int64_t> (Size: 0x10)
SGTeamInfo.TeamGuid2VisualIdxMapValue = 0x418 // TArray<int32_t> (Size: 0x10)
SGTeamInfo.TeamGuidIncludeNotConnect = 0x428 // TArray<int64_t> (Size: 0x10)
SGTeamInfo.CurVisualIdx = 0x438 // int32_t (Size: 0x4)
SGTeamInfo.CheckDBNOWipeOutPeriod = 0x43c // float (Size: 0x4)
SGTeamInfo.bOpenContainerLootProtectByTeammate = 0x440 // bool (Size: 0x1)
SGTeamInfo.AIGroupInfo = 0x448 // NPCAITeam* (Size: 0x8)
SGTeamInfo.TeamMemberDeathLocationArray = 0x450 // TArray<FVector2D> (Size: 0x10)
SGTeamInfo.TeamAreaIDArray = 0x460 // TArray<int32_t> (Size: 0x10)
SGTeamInfo.OnAreaIDArrayChange = 0x470 // FMulticastInlineDelegate (Size: 0x10)
SGTeamInfo.OnTeamMemberKillOther = 0x480 // FMulticastInlineDelegate (Size: 0x10)
SGTeamInfo.OnTeamMemberCauseDamage = 0x490 // FMulticastInlineDelegate (Size: 0x10)
SGTeamInfo.OnTeamMemberAddInventory = 0x4a0 // FMulticastInlineDelegate (Size: 0x10)
SGTempleteDataComponent.DataClass = 0xf8 // ClassProperty (Size: 0x8)
SGTextureMerge.InputTextures = 0x8 // TArray<Texture2D*> (Size: 0x10)
SGTextureMerge.PackedTexture = 0x18 // Texture2D* (Size: 0x8)
SGThermalImagerParams.Type = 0x0 // EESGThermalImagerType (Size: 0x1)
SGThermalImagerParams.ThermalModeParameter = 0x4 // float (Size: 0x4)
SGThermalImagerParams.BloomIntensity = 0x8 // float (Size: 0x4)
SGThermalImagerParams.BloomThreshold = 0xc // float (Size: 0x4)
SGThermalImagerParams.ChromaticAberrationIntensity = 0x10 // float (Size: 0x4)
SGThirdPersonCameraMode.FollowingCameraVelThreshold = 0xb8 // float (Size: 0x4)
SGThirdPersonCameraMode.bDoPredictiveAvoidance = 0xbc // bool (Size: 0x1)
SGThirdPersonCameraMode.bValidateWorstLoc = 0xbd // bool (Size: 0x1)
SGThirdPersonCameraMode.bSkipCameraCollision = 0xbe // bool (Size: 0x1)
SGThirdPersonCameraMode.bNoFOVPostProcess = 0xbf // bool (Size: 0x1)
SGThirdPersonCameraMode.bLockedToViewTarget = 0xc0 // bool (Size: 0x1)
SGThirdPersonCameraMode.bDirectLook = 0xc1 // bool (Size: 0x1)
SGThirdPersonCameraMode.bFollowTarget = 0xc2 // bool (Size: 0x1)
SGThirdPersonCameraMode.FollowingInterpSpeed_Pitch = 0xc4 // float (Size: 0x4)
SGThirdPersonCameraMode.FollowingInterpSpeed_Yaw = 0xc8 // float (Size: 0x4)
SGThirdPersonCameraMode.FollowingInterpSpeed_Roll = 0xcc // float (Size: 0x4)
SGThirdPersonCameraMode.WorstLocOffset = 0xd0 // FVector (Size: 0xc)
SGThirdPersonCameraMode.TargetRelativeCameraOriginOffset = 0xdc // FVector (Size: 0xc)
SGThirdPersonCameraMode.ViewOffset = 0xe8 // FViewOffsetData (Size: 0x24)
SGThirdPersonCameraMode.ViewOffsetAdjustments_InRoom = 0x10c // FViewOffsetData (Size: 0x24)
SGThirdPersonCameraMode.ViewRotatorOffset = 0x130 // FRotator (Size: 0xc)
SGThirdPersonCameraMode.bSmoothViewOffsetPitchChanges = 0x13c // bool (Size: 0x1)
SGThirdPersonCameraMode.ViewOffset_ViewportAdjustments = 0x140 // FViewOffsetData (Size: 0x24)
SGThirdPersonCameraMode.OffsetAdjustmentInterpSpeed = 0x21c // float (Size: 0x4)
SGThirdPersonCameraMode.CurrentViewportType = 0x220 // uint8_t (Size: 0x1)
SGThirdPersonCameraMode.SpectatorCameraRotInterpSpeed = 0x224 // float (Size: 0x4)
SGThirdPersonCameraMode.FOVAngle_ViewportAdjustments = 0x228 // float (Size: 0x4)
SGThirdPersonCameraMode.TemporaryPivotInterpSpeed = 0x240 // float (Size: 0x4)
SGThirdPersonCameraMode_Death.FocusPointInterpSpeedDecaySpeed = 0x258 // float (Size: 0x4)
SGThirdPersonCameraMode_Death.FocusPointInterpSpeed = 0x25c // float (Size: 0x4)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.PerWeaponAnimSetToDuplicate = 0x0 // Object* (Size: 0x8)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.OutPathSet = 0x8 // FString (Size: 0x10)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.OutPathHand = 0x18 // FString (Size: 0x10)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.OutPathWeapon = 0x28 // FString (Size: 0x10)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.bAutoSave = 0x38 // bool (Size: 0x1)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.BaseWeaponName = 0x40 // FString (Size: 0x10)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.TargetWeaponName = 0x50 // FString (Size: 0x10)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.SlotNameToUseOldAnim = 0x60 // FName (Size: 0x8)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.SourceHandMontageByPropertyNameMap = 0x68 // TMap<...> (Size: 0x50)
SGThrowWeaponPerWeaponAnimSetDuplicateConfig.SourceWeaponMontageByPropertyNameMap = 0xb8 // TMap<...> (Size: 0x50)
SGThrowableProjectile.CollisionComponent = 0x318 // SphereComponent* (Size: 0x8)
SGThrowableProjectile.ProjectileMovementComponent = 0x320 // SGProjectileMovementComponent* (Size: 0x8)
SGThrowableProjectile.bDestroyOnBounce = 0x328 // bool (Size: 0x1)
SGThrowableProjectile.bUseEffectTimer = 0x329 // bool (Size: 0x1)
SGThrowableProjectile.bDestroyWeapon = 0x32a // bool (Size: 0x1)
SGThrowableProjectile.TraceDownSize = 0x32c // float (Size: 0x4)
SGThrowableProjectile.bIsSticky = 0x330 // bool (Size: 0x1)
SGThrowableProjectile.bAirBlast = 0x331 // bool (Size: 0x1)
SGThrowableProjectile.HeightForAirBlast = 0x334 // float (Size: 0x4)
SGThrowableProjectile.DistanceForAirBlast = 0x338 // float (Size: 0x4)
SGThrowableProjectile.BroadcastHeight = 0x33c // float (Size: 0x4)
SGThrowableProjectile.NotReachHeightToastKey = 0x348 // FString (Size: 0x10)
SGThrowableProjectile.StickyMeshPath = 0x358 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.PoisonGas = 0x380 // ClassProperty (Size: 0x8)
SGThrowableProjectile.Trigger = 0x388 // ClassProperty (Size: 0x8)
SGThrowableProjectile.bUsedForTripMine = 0x390 // bool (Size: 0x1)
SGThrowableProjectile.ProjectileInfo = 0x3a8 // FSGThrowableProjectileInfo (Size: 0xd8)
SGThrowableProjectile.bGrenadeBeHold = 0x480 // bool (Size: 0x1)
SGThrowableProjectile.bGrenadeBeThrow = 0x481 // bool (Size: 0x1)
SGThrowableProjectile.TempVelocity = 0x484 // FVector (Size: 0xc)
SGThrowableProjectile.PlayEffectTimeForClient = 0x490 // float (Size: 0x4)
SGThrowableProjectile.FireLocation = 0x494 // FVector (Size: 0xc)
SGThrowableProjectile.MeshPath = 0x4a0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.SkeletalMeshPath = 0x4c8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.SkeletalMeshAnimClass = 0x4f0 // TSoftClassPtr<UObject> (Size: 0x28)
SGThrowableProjectile.SkeletalMeshOperateAnim = 0x518 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.SkeletalMeshOperateAnimLoaded = 0x540 // AnimMontage* (Size: 0x8)
SGThrowableProjectile.Particle = 0x548 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.OwnerWeaponItemID = 0x570 // int64_t (Size: 0x8)
SGThrowableProjectile.GothroughBodyDistanceSquared = 0x578 // float (Size: 0x4)
SGThrowableProjectile.ParticleOB = 0x580 // TSoftObjectPtr<UObject> (Size: 0x28)
SGThrowableProjectile.DelaySetParticleTime = 0x5a8 // float (Size: 0x4)
SGThrowableProjectile.DefaultGravityScale = 0x5ac // float (Size: 0x4)
SGThrowableProjectile.ServerRealLocation = 0x5b0 // FVector (Size: 0xc)
SGThrowableProjectile.OwnerWeapon = 0x5c0 // SGWeapon* (Size: 0x8)
SGThrowableProjectile.ThrowableType = 0x5c8 // EESGThrowSubType (Size: 0x1)
SGThrowableProjectile.Teammates = 0x5d0 // TArray<Character*> (Size: 0x10)
SGThrowableProjectile.FactionType = 0x5e0 // EEFactionType (Size: 0x1)
SGThrowableProjectile.PrePerformanceProjectile = 0x5e8 // SGThrowableProjectile* (Size: 0x8)
SGThrowableProjectile.ReplicatedProjectile = 0x5f0 // SGThrowableProjectile* (Size: 0x8)
SGThrowableProjectile.EffectInsDyna = 0x5f8 // MaterialInstanceDynamic* (Size: 0x8)
SGThrowableProjectile.bApplyVisionPersistentEffect = 0x600 // bool (Size: 0x1)
SGThrowableProjectile.BackupOwnerData = 0x608 // FKillerStaticData (Size: 0x198)
SGThrowableProjectile.SetUpDirection = 0x7e4 // FVector (Size: 0xc)
SGThrowableProjectile.PhysicalMaterialStayedOn = 0x810 // PhysicalMaterial* (Size: 0x8)
SGThrowableProjectile.TriggerWaterMaterial = 0x828 // PhysicalMaterial* (Size: 0x8)
SGThrowableProjectile.MeshInitialOffset = 0x858 // FVector (Size: 0xc)
SGThrowableProjectile.bEnableStopRotation = 0x878 // bool (Size: 0x1)
SGThrowableProjectile.PitchRange = 0x87c // FFloatRange (Size: 0x10)
SGThrowableProjectile.YawRange = 0x88c // FFloatRange (Size: 0x10)
SGThrowableProjectile.RollRange = 0x89c // FFloatRange (Size: 0x10)
SGThrowableProjectile.DownPitchRange = 0x8ac // FFloatRange (Size: 0x10)
SGThrowableProjectile.DownYawRange = 0x8bc // FFloatRange (Size: 0x10)
SGThrowableProjectile.DownRollRange = 0x8cc // FFloatRange (Size: 0x10)
SGThrowableProjectile.StopZOffset = 0x8dc // float (Size: 0x4)
SGThrowableProjectile.StopDuration = 0x8e0 // float (Size: 0x4)
SGThrowableProjectile.ProjectileComponents = 0x998 // TArray<ActorComponent*> (Size: 0x10)
SGThrowableProjectileInfo.OwnerWeapon = 0x0 // SGWeapon* (Size: 0x8)
SGThrowableProjectileInfo.ItemId = 0x8 // int32_t (Size: 0x4)
SGThrowableProjectileInfo.InitSpeed = 0xc // FVector (Size: 0xc)
SGThrowableProjectileInfo.MaxSpeed = 0x18 // float (Size: 0x4)
SGThrowableProjectileInfo.LifeSpan = 0x1c // float (Size: 0x4)
SGThrowableProjectileInfo.PlayEffectTime = 0x20 // float (Size: 0x4)
SGThrowableProjectileInfo.bFiredByOvertime = 0x24 // bool (Size: 0x1)
SGThrowableProjectileInfo.bGoThrowBody = 0x25 // bool (Size: 0x1)
SGThrowableProjectileInfo.Count = 0x28 // int32_t (Size: 0x4)
SGThrowableProjectileInfo.bHasPlayedEffect = 0x2c // bool (Size: 0x1)
SGThrowableProjectileInfo.SpawnCharacter = 0x30 // Character* (Size: 0x8)
SGThrowableProjectileInfo.ImpactResult = 0x38 // FHitResult (Size: 0x98)
SGThrowableProjectileInfo.ZWhenGenrated = 0xd0 // float (Size: 0x4)
SGThrowableProjectileInfo.ServerSpawnTime = 0xd4 // float (Size: 0x4)
SGTooltipButton.HoldTime = 0x498 // float (Size: 0x4)
SGTooltipButton.TooltipClass = 0x4a0 // ClassProperty (Size: 0x8)
SGTooltipButton.HorizontalPosition = 0x4a8 // EETooltipShowPositionHorizontal (Size: 0x1)
SGTooltipButton.VerticalPosition = 0x4a9 // EETooltipShowPositionVertical (Size: 0x1)
SGTooltipButton.MouseButtonUpDetected = 0x4aa // bool (Size: 0x1)
SGTooltipButton.CanClick = 0x4ab // bool (Size: 0x1)
SGTooltipButton.OnHeldStart = 0x4b0 // FMulticastInlineDelegate (Size: 0x10)
SGTooltipButton.OnHeldEnd = 0x4c0 // FMulticastInlineDelegate (Size: 0x10)
SGTrapComponent.fDamagePerSec = 0xf8 // float (Size: 0x4)
SGTrapComponent.TriggerTrapSound = 0x100 // AkAudioEvent* (Size: 0x8)
SGTrapComponent.fWalkSpeedScale = 0x108 // float (Size: 0x4)
SGTrapComponent.fSoundTimerRate = 0x10c // float (Size: 0x4)
SGTreeView.bScrollable = 0x958 // bool (Size: 0x1)
SGTrigger.SpawnCharacter = 0x320 // SGCharacter* (Size: 0x8)
SGTrigger.bSpawnCharacterIsAI = 0x328 // bool (Size: 0x1)
SGTrigger.bActivityUse = 0x329 // bool (Size: 0x1)
SGTrigger.SpawnWeapon = 0x330 // SGInventory* (Size: 0x8)
SGTrigger.SpawnItemID = 0x338 // uint64_t (Size: 0x8)
SGTrigger.ImpactResultWrapper = 0x340 // FImpactResultWrapper (Size: 0xa0)
SGTrigger.bAttractAI = 0x3e0 // bool (Size: 0x1)
SGTrigger.ConfigLifeSpan = 0x3e4 // float (Size: 0x4)
SGTrigger.bEffectLifeExpired = 0x3e8 // bool (Size: 0x1)
SGTrigger.WeaponName = 0x3f0 // FString (Size: 0x10)
SGTrigger.WeaponAddTime = 0x400 // float (Size: 0x4)
SGTrigger.TriggerWaterMaterial = 0x408 // PhysicalMaterial* (Size: 0x8)
SGTripMineBase.TripMineName = 0x380 // FString (Size: 0x10)
SGTripMineBase.TripMineStateInfo = 0x390 // FTripMineStateInfo (Size: 0x34)
SGTripMineBase.MineAttachPos = 0x3c8 // SceneComponent* (Size: 0x8)
SGTripMineBase.TripMine_Wire = 0x3d0 // StaticMeshComponent* (Size: 0x8)
SGTripMineBase.TripMine_Pillar1 = 0x3d8 // StaticMeshComponent* (Size: 0x8)
SGTripMineBase.TripMine_Pillar2 = 0x3e0 // StaticMeshComponent* (Size: 0x8)
SGTripMineBase.ShowControlComp = 0x3e8 // SGShowControlComponent* (Size: 0x8)
SGTripMineBase.TripthunderStartLocation = 0x3f0 // FVector (Size: 0xc)
SGTripMineBase.TripthunderEndLocation = 0x3fc // FVector (Size: 0xc)
SGTripMineBase.bIsReadyForExplode = 0x408 // bool (Size: 0x1)
SGTripMineBase.MineInvItemID = 0x40c // int32_t (Size: 0x4)
SGTripMineBase.ThrowableProjcetileClass = 0x410 // ClassProperty (Size: 0x8)
SGTripMineBase.ExplodeDelayTimeSeconds = 0x418 // float (Size: 0x4)
SGTripMineBase.SpawnedMineInv = 0x420 // SGWeapon* (Size: 0x8)
SGTripMineBase.bReplcaceOnGameInit = 0x428 // bool (Size: 0x1)
SGTripMineBase.NoneSpawnProbabilityInPercent = 0x42c // int32_t (Size: 0x4)
SGTripMineBase.ReplacedTripMineInfos = 0x430 // TArray<FTripMineReplaceInfo> (Size: 0x10)
SGTurnInPlaceAnimSequenceConfig.TurnLeft90 = 0x0 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimSequenceConfig.TurnRight90 = 0x8 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimSequenceConfig.TurnLeft90_Casual = 0x10 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimSequenceConfig.TurnRight90_Casual = 0x18 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimSequenceConfig.TurnLeft90_EmptyHands = 0x20 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimSequenceConfig.TurnRight90_EmptyHands = 0x28 // AnimSequence* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnLeft90 = 0x0 // AnimMontage* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnRight90 = 0x8 // AnimMontage* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnLeft90_Casual = 0x10 // AnimMontage* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnRight90_Casual = 0x18 // AnimMontage* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnLeft90_EmptyHands = 0x20 // AnimMontage* (Size: 0x8)
SGTurnInPlaceAnimationConfig.TurnRight90_EmptyHands = 0x28 // AnimMontage* (Size: 0x8)
SGTutorialAIFireComponent.AimTarget = 0x100 // SGCharacter* (Size: 0x8)
SGTutorialAIFireComponent.bKillTarget = 0x108 // bool (Size: 0x1)
SGTutorialAIFireComponent.InstantBullet = 0x110 // SGProjectile_InstantBullet* (Size: 0x8)
SGTwoWayDoorPlankComponent.DoorOwner = 0x680 // SGDoorBase* (Size: 0x8)
SGTwoWayDoorPlankComponent.DoorOpenAngle = 0x688 // float (Size: 0x4)
SGTwoWayDoorPlankComponent.DoorHandleDir = 0x68c // FVector (Size: 0xc)
SGTwoWayDoorPlankComponent.DoorPlankThickness = 0x698 // float (Size: 0x4)
SGTwoWayDoorPlankComponent.VLMSampleClampHeight = 0x69c // float (Size: 0x4)
SGUAMCameraShake_WeaponBob.BobScaleWithSpeedCurve = 0x50 // CurveFloat* (Size: 0x8)
SGUAMCameraShake_WeaponBob.MaxVelocityToNormalize = 0x58 // float (Size: 0x4)
SGUAMCharacterLeanComponent.StandLeanRollOffset = 0x100 // float (Size: 0x4)
SGUAMCharacterLeanComponent.ProneLeanRollOffset = 0x104 // float (Size: 0x4)
SGUAMCharacterLeanComponent.LeanHorizontalOffset = 0x108 // float (Size: 0x4)
SGUAMCharacterLeanComponent.LeanDuration = 0x10c // float (Size: 0x4)
SGUAMCharacterPoseCacheComponent.OwnerCharacter = 0x108 // SGCharacter* (Size: 0x8)
SGUAMCharacterPoseCacheComponent.CachedPoseList = 0x120 // TMap<...> (Size: 0x50)
SGUAMDeathAnimationSet.StandDeathSet = 0x0 // FSGUAMPerBodyPartDeathAnimationSet (Size: 0xd0)
SGUAMDeathAnimationSet.CrouchDeathSet = 0xd0 // FSGUAMPerBodyPartDeathAnimationSet (Size: 0xd0)
SGUAMDeathAnimationSet.ProneDeathSet = 0x1a0 // FSGUAMPerBodyPartDeathAnimationSet (Size: 0xd0)
SGUAMDeathAnimationSet.DBNODeathSet = 0x270 // FSGUAMPerBodyPartDeathAnimationSet (Size: 0xd0)
SGUAMDiveAnimationSet.DiveStart = 0x0 // AnimSequence* (Size: 0x8)
SGUAMDiveAnimationSet.DiveLoop = 0x8 // AnimSequence* (Size: 0x8)
SGUAMDiveAnimationSet.DiveEnd = 0x10 // AnimSequence* (Size: 0x8)
SGUAMDiveAnimationSet.AimOffset = 0x18 // AimOffsetBlendSpace* (Size: 0x8)
SGUAMDiveAnimationSet.Dive360AnimAdditive = 0x20 // AnimSequence* (Size: 0x8)
SGUAMDiveAnimationSet.Prone360_AimOffset = 0x28 // AimOffsetBlendSpace* (Size: 0x8)
SGUAMDiveAnimationSet.Prone360IdleAnimAdditive = 0x30 // AnimSequence* (Size: 0x8)
SGUAMDiveAnimationSet.Prone360LocomotionByAngle = 0x38 // TArray<FSGProne360BlendSpace> (Size: 0x10)
SGUAMDiveAnimationSet.Prone360ToStandByAngle = 0x48 // TArray<FSGProne360Sequence> (Size: 0x10)
SGUAMDiveAnimationSet.Prone360ToCrouchByAngle = 0x58 // TArray<FSGProne360Sequence> (Size: 0x10)
SGUAMHandAnimationSet.IdleSeqBasePose = 0x0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq = 0x8 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq3P = 0x10 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq3P_Prone = 0x18 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq_Additive = 0x20 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq_Additive_Prone = 0x28 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.FireAdditive_Seq = 0x30 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.FireAdditive_Seq_Prone = 0x38 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq_Additive_3P = 0x40 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.IdleSeq_Additive_3P_Prone = 0x48 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.ADS_IdleSeq_Additive = 0x50 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.Idle_FixUpRightHandAdditive = 0x58 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.GripIdleBS = 0x60 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.GripPoseAdditive_3P = 0x68 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.GripPoseAdditive_3P_Prone = 0x70 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.GripIdleBS_3P = 0x78 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.GripIdleBS_3P_Prone = 0x80 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.FP_LeftHandADSAdditive = 0x88 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.Grip3PIdleBS = 0x90 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.GripProne3PIdleBS = 0x98 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.RearGripIdleBS = 0xa0 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.RearGripIdleBS_3P = 0xa8 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.RearGripIdleBS_3P_Prone = 0xb0 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualRearGripIdleBS_Female = 0xb8 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualIdleSeq = 0xc0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalPistolStandBasePose_1P = 0xc8 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalPistolStandBasePose_3P = 0xd0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalPistolCrouchBasePose_1P = 0xd8 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalPistolCrouchBasePose_3P = 0xe0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalRightHandGripPose = 0xe8 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.CasualIdleSeq_Female = 0xf0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.bEnableInGameCasual = 0xf8 // bool (Size: 0x1)
SGUAMHandAnimationSet.CasualGripIdleBS = 0x100 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualGripIdleBS_Female = 0x108 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualGripAdjustmentBS = 0x110 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualGripAdjustmentBS_Female = 0x118 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.CasualRearGripIdleBS = 0x120 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.LFingerAdaptiveBS = 0x128 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.LFingerAdaptiveBS_Lobby = 0x130 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.LFingerAdaptiveBS_Lobby_Female = 0x138 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.WeaponShakeBS = 0x140 // BlendSpace1D* (Size: 0x8)
SGUAMHandAnimationSet.FireSeq = 0x148 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneFireSeq = 0x170 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.AutoBurstFireSeq = 0x198 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.MeleeFireFirstIndexInSprint = 0x1c0 // int32_t (Size: 0x4)
SGUAMHandAnimationSet.MeleeFireSeq = 0x1c8 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGUAMHandAnimationSet.MeleeFirePostShowcaseSeq = 0x1d8 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGUAMHandAnimationSet.MeleeFireProneSeq = 0x1e8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.MeleeFirePronePostShowcaseSeq = 0x210 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.LoopFireSeq = 0x238 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.LoopFireEndSeq = 0x260 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ZoomFireSeq = 0x288 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EmptyFireSeq = 0x2b0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ThrowDownSeq = 0x2d8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneThrowDownSeq = 0x300 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.FireWithoutChargeSeq = 0x328 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.FastThrowFireSeq = 0x350 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneFastThrowFireSeq = 0x378 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ClearBoresSeq = 0x3a0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.PushBoresSeq = 0x3c8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresOneByOneStartSeq = 0x3f0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresOneByOneEndSeq = 0x418 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresPushOneBulletSeq = 0x440 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresChangeOneBulletSeq = 0x468 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresRotateClockwiseSeq = 0x490 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadBoresRotateCounterClockwiseSeq = 0x4b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadSeq = 0x4e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.CheckMagazineSeq = 0x508 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.UnloadMagSeq = 0x530 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.LoadMagSeq = 0x558 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.OpenBoltBeforeReloadingSeq = 0x580 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EmptyBoreOpenBoltBeforeReloadingSeq = 0x5a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.CloseBoltAfterReloadingSeq = 0x5d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.BeltOutSeq = 0x5f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.BeltInSeq = 0x620 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadLoopSeq = 0x648 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadLoopBeginSeq = 0x670 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadLoopEndSeq = 0x698 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EmptyBoreLeverActionReloadLoopBeginSeq = 0x6c0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReloadLoopBeginCatchBulletSeq = 0x6e8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.PullBoltSeq = 0x710 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.PullBoltADSSeq = 0x738 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndEquipSeq = 0x760 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndEquipSeq_Left = 0x788 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndEquipSeq_Right = 0x7b0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.DropEquipSeq = 0x7d8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EquipSeq = 0x800 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EquipSeq_Left = 0x828 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EquipSeq_Right = 0x850 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EquipWithChargeSeq = 0x878 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.TacticalGrip1P = 0x8a0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalGrip3P = 0x8a8 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.TacticalADSGrip1P = 0x8b0 // AnimSequence* (Size: 0x8)
SGUAMHandAnimationSet.RifleToTacticalSeq = 0x8b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ZoomingRifleToTacticalSeq = 0x8e0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.TacticalToRifleSeq = 0x908 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.TacticalPutDownSeq = 0x930 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.TacticalToPistolSeq = 0x958 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.TacticalFireSeq = 0x980 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.RifleToTacticalPickUpSeq = 0x9a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ZoomingRifleToTacticalPickUpSeq = 0x9d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.HoldOpenSeq = 0x9f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneHoldOpenSeq = 0xa20 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ReleaseHoldSeq = 0xa48 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.CheckFireModeSeq = 0xa70 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneReleaseHoldSeq = 0xa98 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SwitchFireMode0Seq = 0xac0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SwitchFireMode1Seq = 0xae8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SwitchFireMode2Seq = 0xb10 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SetBipodOnSeq = 0xb38 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SetBipodOffSeq = 0xb60 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.AddNewMagzineSeq = 0xb88 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EmptyBorePushBoresSeq = 0xbb0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.MeleeFireCompleteSeq = 0xbd8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.AddNewMagzineSeqMap = 0xc00 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.CheckMagzineSeqMap = 0xc50 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.ReloadSeqMap = 0xca0 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.TacticalReloadSeqMap = 0xcf0 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.FastReloadSeqMap = 0xd40 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.BeginBagOpenSeq = 0xd90 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndBagOpenSeq = 0xdb8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.BeginBagOpenSeq_Prone = 0xde0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndBagOpenSeq_Prone = 0xe08 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndKeepPreFireMontage = 0xe30 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ProneEndKeepPreFireMontage = 0xe58 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.SetupAdapterMontage = 0xe80 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.BeginLowReadyeMontage = 0xea8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.EndLowReadyeMontage = 0xed0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.LootSeq = 0xef8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ViewWeaponMontage = 0xf20 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ViewWeaponGripMontage = 0xf48 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.HoldOpenViewWeaponMontage = 0xf70 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.HoldOpenViewWeaponGripMontage = 0xf98 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.NoMagViewWeaponMontage = 0xfc0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.NoMagViewWeaponGripMontage = 0xfe8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.FoldScopeSeq = 0x1010 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.FoldScopeADSSeq = 0x1038 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.UnfoldScopeSeq = 0x1060 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.UnfoldScopeADSSeq = 0x1088 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.DTCustomSequences_Male = 0x10b0 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.DTCustomSequences_Female = 0x1100 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.DTFacialAnimaSequences_Male = 0x1150 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.DTFacialAnimaSequences_Female = 0x11a0 // TMap<...> (Size: 0x50)
SGUAMHandAnimationSet.PushDoor = 0x11f0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.PullDoor = 0x1218 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.KeyDoor = 0x1240 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.CardDoor = 0x1268 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ExplodeDoor = 0x1290 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMHandAnimationSet.ForceBreakDoor = 0x12b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.Pickup = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.Pickup_Prone = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.PushDoor = 0x50 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.PullDoor = 0x78 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.KeyDoor = 0xa0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.CardDoor = 0xc8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.ExplodeDoor = 0xf0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.ForceBreakDoor = 0x118 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.Rescue = 0x140 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.RescueSeqMap = 0x168 // TMap<...> (Size: 0x50)
SGUAMInteractionAnimationSet.RescueInventoryMesh = 0x1b8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.RescueInventoryMeshMap = 0x1e0 // TMap<...> (Size: 0x50)
SGUAMInteractionAnimationSet.RescueInventory = 0x230 // TSoftObjectPtr<UObject> (Size: 0x28)
SGUAMInteractionAnimationSet.RescueInventorySeqMap = 0x258 // TMap<...> (Size: 0x50)
SGUAMInteractionAnimationSet.InteractionSeqMap = 0x2a8 // TMap<...> (Size: 0x50)
SGUAMJumpAnimationSet.JumpStart = 0x0 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.JumpLoop = 0x8 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.JumpEnd = 0x10 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.JumpHighEnd = 0x18 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.JumpLand = 0x20 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.RunJumpLand = 0x28 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.SprintJumpLand = 0x30 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.RunJumpStart = 0x38 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.RunJumpLoop = 0x40 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.RunJumpEnd = 0x48 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.RunJumpHighEnd = 0x50 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.PreJump = 0x58 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.SprintJumpStart = 0x60 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.SprintJumpLoop = 0x68 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.SprintJumpEnd = 0x70 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.SprintToRunJumpEnd = 0x78 // BlendSpace* (Size: 0x8)
SGUAMJumpAnimationSet.RunToIdleJumpEnd = 0x80 // AnimSequence* (Size: 0x8)
SGUAMJumpAnimationSet.SprintToIdleJumpEnd = 0x88 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.Idle = 0x0 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.IdleLeanLeft = 0x8 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.IdleLeanRight = 0x10 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.Idle_AO = 0x18 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.Idle_AO_LeanLeft = 0x20 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.Idle_AO_LeanRight = 0x28 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.AimOffset = 0x30 // AimOffsetBlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.AimOffsetLeanLeft = 0x38 // AimOffsetBlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.AimOffsetLeanRight = 0x40 // AimOffsetBlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion = 0x48 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion_Fracture = 0x50 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion_Fracture_ADS = 0x58 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion_FractureClear_ADS = 0x60 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion_HandSway = 0x68 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.WalkLocomotion = 0x70 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.RunLocomotion = 0x78 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.SprintLocomotion = 0x80 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.SprintLocomotion_Fracture = 0x88 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.Locomotion_FractureClear = 0x90 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovementAccelerationLeanBS = 0x98 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.SprintAccelerationLeanBS = 0xa0 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.SprintSharpTurnLeanBS = 0xa8 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.SprintAdditiveBS = 0xb0 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.TurnLeft90 = 0xb8 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.TurnRight90 = 0xc0 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.TurnLeft180 = 0xc8 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.TurnRight180 = 0xd0 // AnimSequence* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovingStartBS = 0xd8 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovingStopBS = 0xe0 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovingStopBS_L = 0xe8 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovingStopBS_R = 0xf0 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.MovingPivotBS = 0xf8 // BlendSpace* (Size: 0x8)
SGUAMLocomotionAnimationSet.PivotCardinals = 0x100 // FSGPivotCardinalsAnimation (Size: 0x20)
SGUAMLocomotionAnimationSet.SilentWalkPivotCardinals = 0x120 // FSGPivotCardinalsAnimation (Size: 0x20)
SGUAMPerBodyPartDeathAnimationSet.DefaultAnimtionPool = 0x0 // TArray<AnimMontage*> (Size: 0x10)
SGUAMPerBodyPartDeathAnimationSet.HitHeadDeathset = 0x10 // FSGUAMPerDirectionDeathAnimationSet (Size: 0x40)
SGUAMPerBodyPartDeathAnimationSet.HitBodyDeathset = 0x50 // FSGUAMPerDirectionDeathAnimationSet (Size: 0x40)
SGUAMPerBodyPartDeathAnimationSet.HitLegDeathset = 0x90 // FSGUAMPerDirectionDeathAnimationSet (Size: 0x40)
SGUAMPerDirectionDeathAnimationSet.FrontHitPool = 0x0 // TArray<AnimMontage*> (Size: 0x10)
SGUAMPerDirectionDeathAnimationSet.BackHitPool = 0x10 // TArray<AnimMontage*> (Size: 0x10)
SGUAMPerDirectionDeathAnimationSet.LeftHitPool = 0x20 // TArray<AnimMontage*> (Size: 0x10)
SGUAMPerDirectionDeathAnimationSet.RightHitPool = 0x30 // TArray<AnimMontage*> (Size: 0x10)
SGUAMPerWeaponAnimationSets.UAMHandAnimationSet = 0x28 // FSGUAMHandAnimationSet (Size: 0x12e0)
SGUAMPerWeaponAnimationSets.UAMWeaponAnimationSet = 0x1308 // FSGUAMWeaponAnimationSet (Size: 0xe60)
SGUAMTakeHitAnimationSet.TakeHitHead = 0x0 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTakeHitAnimationSet.TakeHitChest = 0x10 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTakeHitAnimationSet.TakeHitLeftLeg = 0x20 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTakeHitAnimationSet.TakeHitRightLeg = 0x30 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTakeHitAnimationSet.TakeHitRightArm = 0x40 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTakeHitAnimationSet.TakeHitLeftArm = 0x50 // TArray<BlendSpace*> (Size: 0x10)
SGUAMTransitionAnimationSet.TransitionAnimationSet = 0x0 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.FractureTransitionAnimationSet = 0x8 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.RunToSprint = 0x10 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToRun = 0x18 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.RunToSprintRight = 0x20 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToRunRight = 0x28 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.StandToCrouch = 0x30 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.StandToProne = 0x38 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToProne = 0x40 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.StandToProneBS = 0x48 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.CrouchToProneBS = 0x50 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.CrouchToStand = 0x58 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.CrouchToProne = 0x60 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.ProneToStand = 0x68 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.ProneToCrouch = 0x70 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.StandToDBNO = 0x78 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToDBNO = 0x80 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.CrouchToDBNO = 0x88 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.ProneToDBNO = 0x90 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.DBNOToCrouch = 0x98 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.DBNOToProne = 0xa0 // AnimSequence* (Size: 0x8)
SGUAMTransitionAnimationSet.StandToSprint = 0xa8 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToStand = 0xb0 // BlendSpace* (Size: 0x8)
SGUAMTransitionAnimationSet.SprintToCrouch = 0xb8 // BlendSpace* (Size: 0x8)
SGUAMWeaponAnimationComponent.PerWeaponAnimationSets = 0xbd0 // SGUAMPerWeaponAnimationSets* (Size: 0x8)
SGUAMWeaponAnimationSet.MeleeFireSeq = 0x0 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGUAMWeaponAnimationSet.MeleeFirePostShowcaseSeq = 0x10 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SGUAMWeaponAnimationSet.WeaponFireResource = 0x20 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponZoomFireResource = 0x50 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponFireResource = 0x80 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.LoopFireResource = 0xb0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.LoopFireEndResource = 0xe0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponFirePostShowcaseResource = 0x110 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponAutoBurstFireResource = 0x140 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponDownFireResource = 0x170 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponDownFireResource = 0x1a0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponFastFireResource = 0x1d0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponFastFireResource = 0x200 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEmptyFireResource = 0x230 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponClearBoresResource = 0x260 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponPushBoresResource = 0x290 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponReloadResource = 0x2c0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.TacticalFireResource = 0x2f0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.RifleToTacticalPickUpResource = 0x320 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponTacticalReloadResource = 0x350 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponUnloadMagResource = 0x380 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponLoadMagResource = 0x3b0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.MagazineCheckResource = 0x3e0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadLoopEndResource = 0x410 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadLoopResource = 0x440 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadLoopBeginResource = 0x470 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadBoresOneByOneStartResource = 0x4a0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadBoresOneByOneEndResource = 0x4d0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.EmptyBoreLeverActionReloadLoopBeginResource = 0x500 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ReloadLoopBeginCatchBulletResource = 0x530 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponPullBoltResource = 0x560 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponPullBoltADSResource = 0x590 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEndEquipResource = 0x5c0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEquipResource = 0x5f0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponOpenBoltBeforeReloadResource = 0x620 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEmptyBoreOpenBoltBeforeReloadResource = 0x650 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponCloseBoltAfterReloadResource = 0x680 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponBeltOutResource = 0x6b0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponBeltInResource = 0x6e0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEquipWithChargeResource = 0x710 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponHoldOpenResource = 0x740 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponHoldOpenResource = 0x770 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponReleaseOpenResource = 0x7a0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponCheckFireModeResource = 0x7d0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponReleaseOpenResource = 0x800 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSwitchFireMode0Resource = 0x830 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSwitchFireMode1Resource = 0x860 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSwitchFireMode2Resource = 0x890 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSetBipodOnResource = 0x8c0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSetBipodOffResource = 0x8f0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.AddNewMagzineResource = 0x920 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.EmptyBorePushBoresResource = 0x950 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.AddNewMagzineSeqMap = 0x980 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.CheckMagzineSeqMap = 0x9d0 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.ReloadSeqMap = 0xa20 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.TacticalReloadSeqMap = 0xa70 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.FastReloadSeqMap = 0xac0 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.WeaponBeginBagOpenResource = 0xb10 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponBagOpenResource = 0xb40 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEndBagOpenResource = 0xb70 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponEndKeepPreFireResource = 0xba0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ProneWeaponEndKeepPreFireResource = 0xbd0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponSetupAdapterResource = 0xc00 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ViewWeaponResource = 0xc30 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.ViewWeaponGripResource = 0xc60 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.HoldOpenViewWeaponResource = 0xc90 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.HoldOpenViewWeaponGripResource = 0xcc0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.NoMagViewWeaponResource = 0xcf0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.NoMagViewWeaponGripResource = 0xd20 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.CustomAnimations = 0xd50 // TMap<...> (Size: 0x50)
SGUAMWeaponAnimationSet.WeaponFoldScopeResource = 0xda0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponFoldScopeADSResource = 0xdd0 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponUnfoldScopeResource = 0xe00 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponAnimationSet.WeaponUnfoldScopeADSResource = 0xe30 // FSGMontargeWithPlayRate (Size: 0x30)
SGUAMWeaponModifyBoneComponent.BoneRotationModifier_Fire = 0x100 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.BoneLocationModifier_Fire = 0x108 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.ADSBoneRotationModifier_Fire = 0x110 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.ADSBoneLocationModifier_Fire = 0x118 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.CurrentLocationCurve = 0x128 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.CurrentRotationCurve = 0x130 // CurveVector* (Size: 0x8)
SGUAMWeaponModifyBoneComponent.CurrentLocationValue = 0x140 // FVector (Size: 0xc)
SGUAMWeaponModifyBoneComponent.CurrentRotationValue = 0x14c // FVector (Size: 0xc)
SGUserWidget.ComponentTags = 0x298 // TArray<FName> (Size: 0x10)
SGUserWidget.ZOrderOnHud = 0x2a8 // int32_t (Size: 0x4)
SGUserWidget.bConditionalUpdateEnable = 0x2ac // bool (Size: 0x1)
SGUserWidget.bFrameUpdateEnable = 0x2ad // bool (Size: 0x1)
SGUserWidget.bDontRemoveWhileLoadMap = 0x2ae // bool (Size: 0x1)
SGUserWidget.DynamicContentPoolList = 0x2b0 // TArray<UserWidget*> (Size: 0x10)
SGUserWidget.bReceiveTouchEvent = 0x2c4 // bool (Size: 0x1)
SGUserWidget.bShouldVisibleDisabled = 0x2c5 // bool (Size: 0x1)
SGUserWidget.bShouldUpdateWhenRenderingSkipped = 0x2c6 // bool (Size: 0x1)
SGUserWidget.OldVisibility = 0x2c7 // bool (Size: 0x1)
SGUserWidget.TickInterval = 0x2cc // float (Size: 0x4)
SGUserWidget.LoadedWidgetPool = 0x2e0 // TArray<UserWidget*> (Size: 0x10)
SGUsingInventoryRepAnimInfo.CharacterMontage = 0x0 // AnimMontage* (Size: 0x8)
SGUsingInventoryRepAnimInfo.InventoryMontage = 0x8 // AnimMontage* (Size: 0x8)
SGUsingInventoryRepAnimInfo.InventoryMesh = 0x10 // SkeletalMesh* (Size: 0x8)
SGUsingInventoryRepAnimInfo.Rate = 0x18 // float (Size: 0x4)
SGUsingInventoryRepAnimInfo.StartSection = 0x1c // FName (Size: 0x8)
SGUsingInventoryRepAnimInfo.AttachSocket = 0x24 // FName (Size: 0x8)
SGUsingInventoryRepAnimInfo.StartTimeStamp = 0x2c // float (Size: 0x4)
SGUsingInventoryRepAnimInfo.PlayBit = 0x30 // bool (Size: 0x1)
SGVaultAnimationConfig.VaultChoice = 0x0 // EEVaultChoice (Size: 0x1)
SGVaultAnimationConfig.ObstacleHeightLevel = 0x1 // EEObstacleHeightLevel (Size: 0x1)
SGVaultAnimationConfig.PassabilityMinRadius = 0x4 // float (Size: 0x4)
SGVaultAnimationConfig.PassabilityMinHalfHeight = 0x8 // float (Size: 0x4)
SGVaultAnimationConfig.PassabilityHeightOffset = 0xc // float (Size: 0x4)
SGVaultAnimationConfig.ApexEdgeDistance = 0x10 // float (Size: 0x4)
SGVaultAnimationConfig.HoriMoveDistancePreJump = 0x14 // float (Size: 0x4)
SGVaultAnimationConfig.HoriMoveDistancePreApex = 0x18 // float (Size: 0x4)
SGVaultAnimationConfig.HoriMoveDistancePostApex = 0x1c // float (Size: 0x4)
SGVaultAnimationConfig.HoriMoveDistancePostFall = 0x20 // float (Size: 0x4)
SGVaultAnimationConfig.VerticalMoveDistanceApex = 0x24 // float (Size: 0x4)
SGVaultAnimationConfig.PlayRateNormal = 0x28 // float (Size: 0x4)
SGVaultAnimationConfig.PlayRateOverWeight = 0x2c // float (Size: 0x4)
SGVaultAnimationSet.VaultAnimationList = 0x0 // TArray<AnimMontage*> (Size: 0x10)
SGVaultAnimationSet.ClimbAnimationList = 0x10 // TArray<AnimMontage*> (Size: 0x10)
SGVaultInfo.VaultType = 0x0 // FSGVaultType (Size: 0x2)
SGVaultInfo.VaultAnimation = 0x8 // AnimSequence* (Size: 0x8)
SGVaultInfo.VaultAnimationPlayRate = 0x10 // float (Size: 0x4)
SGVaultInfo.AnimLengthToApex = 0x14 // float (Size: 0x4)
SGVaultInfo.AnimLengthToActualLand = 0x18 // float (Size: 0x4)
SGVaultInfo.AnimLengthToFalling = 0x1c // float (Size: 0x4)
SGVaultInfo.HoriMoveDistancePreApex = 0x20 // float (Size: 0x4)
SGVaultInfo.HoriMoveDistancePostApex = 0x24 // float (Size: 0x4)
SGVaultInfo.VerticalMoveDistanceApex = 0x28 // float (Size: 0x4)
SGVaultRepInfo.TargetVaultType = 0x0 // FSGVaultType (Size: 0x2)
SGVaultRepInfo.TargetVaultChoice = 0x2 // EEClimbVaultChoice (Size: 0x1)
SGVaultRepInfo.TargetWallFaceDir = 0x4 // FVector (Size: 0xc)
SGVaultRepInfo.TargetVaultStartPoint = 0x10 // FVector (Size: 0xc)
SGVaultRepInfo.TargetVaultApexPoint = 0x1c // FVector (Size: 0xc)
SGVaultRepInfo.TargetVaultEndPoint = 0x28 // FVector (Size: 0xc)
SGVaultType.VaultHeightType = 0x0 // EEObstacleHeightType (Size: 0x1)
SGVaultType.VaultAnimType = 0x1 // EEVaultAnimType (Size: 0x1)
SGVehicleBoostComponent.bIsBoost = 0x110 // bool (Size: 0x1)
SGVehicleBoostComponent.MaxEngineRPMBoostFactor = 0x114 // float (Size: 0x4)
SGVehicleBoostComponent.TorqueCurveBoostFactor = 0x118 // float (Size: 0x4)
SGVehicleCameraComponent.CachedFirstPersonSpringArmComponent = 0x100 // SpringArmComponent* (Size: 0x8)
SGVehicleCameraComponent.CachedFirstPersonCamera = 0x108 // CameraComponent* (Size: 0x8)
SGVehicleCameraComponent.CachedThirdPersonSpringArmComponent = 0x110 // SpringArmComponent* (Size: 0x8)
SGVehicleCameraComponent.CachedThirdPersonCamera = 0x118 // CameraComponent* (Size: 0x8)
SGVehicleCameraComponent.DriverViewYawMin = 0x120 // float (Size: 0x4)
SGVehicleCameraComponent.DriverViewYawMax = 0x124 // float (Size: 0x4)
SGVehicleCameraComponent.DriverViewPitchMin = 0x128 // float (Size: 0x4)
SGVehicleCameraComponent.DriverViewPitchMax = 0x12c // float (Size: 0x4)
SGVehicleCameraComponent.AutoResetDriverViewDelay = 0x130 // float (Size: 0x4)
SGVehicleCommonComp.OwnerVehicle = 0x110 // Pawn* (Size: 0x8)
SGVehicleDustType.WheelEffectsByPhysicMaterial = 0x30 // TArray<FWheelDustTypeByPhysicsMaterial> (Size: 0x10)
SGVehicleDustType.DefaultWheelEffect = 0x40 // ParticleSystem* (Size: 0x8)
SGVehicleDustType.DefaultActiveThresholdSpeed = 0x48 // float (Size: 0x4)
SGVehicleEnterLeaveComponent.MaxEnterVehicleDistance = 0x100 // float (Size: 0x4)
SGVehicleEnterLeaveComponent.LastWayPointDistSquaredThreshold = 0x104 // float (Size: 0x4)
SGVehicleEnterLeaveComponent.LastWayPoint = 0x108 // FVector (Size: 0xc)
SGVehicleFactory.Mesh = 0x310 // SkeletalMeshComponent* (Size: 0x8)
SGVehicleFactory.VehicleClass = 0x318 // ClassProperty (Size: 0x8)
SGVehicleFactory.SpawnRadius = 0x320 // float (Size: 0x4)
SGVehicleFactory.SpawnZOffset = 0x324 // float (Size: 0x4)
SGVehicleFactory.RespawnProgress = 0x328 // float (Size: 0x4)
SGVehicleFactory.ChildVehicle = 0x330 // Pawn* (Size: 0x8)
SGVehicleImpactEffect.DefaultFX = 0x310 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.AsphaltFX = 0x318 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.DirtFX = 0x320 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.WaterFX = 0x328 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.WoodFX = 0x330 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.StoneFX = 0x338 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.MetalFX = 0x340 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.GrassFX = 0x348 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.GravelFX = 0x350 // ParticleSystem* (Size: 0x8)
SGVehicleImpactEffect.HitSurface = 0x358 // FHitResult (Size: 0x98)
SGVehicleImpactEffect.HitForce = 0x3f0 // FVector (Size: 0xc)
SGVehicleMotoCycle.ForceLeaveVehicleAngleThreshold = 0x890 // float (Size: 0x4)
SGVehicleMotoCycle.ExitLocationOffsetZ = 0x894 // float (Size: 0x4)
SGVehicleParams.VehicleName = 0x8 // FString (Size: 0x10)
SGVehicleParams.bUseBPDefault = 0x18 // bool (Size: 0x1)
SGVehicleParams.MaxHealth = 0x1c // float (Size: 0x4)
SGVehicleParams.ExplodeDamage = 0x20 // float (Size: 0x4)
SGVehicleParams.ExplodeDamageRadius = 0x24 // float (Size: 0x4)
SGVehicleParams.HitPawnDamageVelocityThreshold = 0x28 // float (Size: 0x4)
SGVehicleParams.HitWallDamageVelocityThreshold = 0x2c // float (Size: 0x4)
SGVehicleParams.HitWallPassengerHurtDamageCurve = 0x30 // FRuntimeFloatCurve (Size: 0x88)
SGVehicleParams.HitWallVehicleHurtDamageCurve = 0xb8 // FRuntimeFloatCurve (Size: 0x88)
SGVehicleParams.HitWallDamageMaxPitch = 0x140 // float (Size: 0x4)
SGVehicleParams.OverlapCarForceCurve = 0x148 // FRuntimeFloatCurve (Size: 0x88)
SGVehicleParams.OverlapCarDamageCurve = 0x1d0 // FRuntimeFloatCurve (Size: 0x88)
SGVehicleParams.JumpCarDamageCurve = 0x258 // FRuntimeFloatCurve (Size: 0x88)
SGVehicleParams.FuelAmountMax = 0x2e0 // float (Size: 0x4)
SGVehicleParams.FuelConsumeNormalPerMinute = 0x2e4 // float (Size: 0x4)
SGVehicleParams.FuelConsumeAccelPerMinute = 0x2e8 // float (Size: 0x4)
SGVehicleParams.RandFuelRateMin = 0x2ec // float (Size: 0x4)
SGVehicleParams.RandFuelRateMax = 0x2f0 // float (Size: 0x4)
SGVehicleParams.Broken1WheelSpeedFactor = 0x2f4 // float (Size: 0x4)
SGVehicleParams.Broken2WheelSpeedFactor = 0x2f8 // float (Size: 0x4)
SGVehicleParams.Broken3WheelSpeedFactor = 0x2fc // float (Size: 0x4)
SGVehicleParams.Broken4WheelSpeedFactor = 0x300 // float (Size: 0x4)
SGVehicleParams.FinalRatio = 0x304 // float (Size: 0x4)
SGVehicleSeatComponent.VehicleSeatData = 0x100 // FVehicleSeatData (Size: 0x40)
SGVehicleSeatComponent.SeatCharacterList = 0x140 // TArray<Character*> (Size: 0x10)
SGVehicleSeatComponent.PlayerCount = 0x150 // int32_t (Size: 0x4)
SGVehicleSkeletalMeshComponent.VehiclePawn = 0x10f0 // Pawn* (Size: 0x8)
SGVehicleSoundComponent.DirveComponent = 0x100 // AkComponent* (Size: 0x8)
SGVehicleSoundComponent.MaxRPMForAudio = 0x108 // float (Size: 0x4)
SGVehicleSoundComponent.AudioBanks = 0x110 // TArray<AkAudioBank*> (Size: 0x10)
SGVehicleSoundComponent.LocalVehicleEmgineStartUpEvent = 0x120 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.RemoteVehicleEmgineStartUpEvent = 0x128 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleEmgineStopEvent = 0x130 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleEmgineEvent = 0x138 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleBoostStartEvent = 0x140 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleBoostEndEvent = 0x148 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleLatSlipStartEvent = 0x150 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleLatSlipStopEvent = 0x158 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleTireExplodeEvent = 0x160 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleImpactEvent = 0x168 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleHornPressedEvent_Local = 0x170 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleHornReleasedEvent_Local = 0x178 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleHornPressedEvent_Remote = 0x180 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleHornReleasedEvent_Remote = 0x188 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleExplodeEvent = 0x190 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleBurningEvent = 0x198 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleStopBurningEvent = 0x1a0 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleHitPlayerEvent = 0x1a8 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleCommonHitEvent = 0x1b0 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleBrakeEvent = 0x1b8 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleDriveIntoWaterEvent = 0x1c0 // AkAudioEvent* (Size: 0x8)
SGVehicleSoundComponent.VehicleLandingSound = 0x1c8 // FVehicleHitSoundConfig (Size: 0x10)
SGVehicleSpawnPoint.CapsuleComponent = 0x310 // CapsuleComponent* (Size: 0x8)
SGVehicleSpawnPoint.GroupID = 0x31c // int32_t (Size: 0x4)
SGVehicleSpawnPoint.SpawnType = 0x320 // EEVehicleSpawnType (Size: 0x1)
SGVehicleSpawnPoint.SpawnWeight = 0x324 // float (Size: 0x4)
SGVehicleSpawnPoint.MinSpawnCount = 0x328 // int32_t (Size: 0x4)
SGVehicleSpawnPoint.MaxSpawnCount = 0x32c // int32_t (Size: 0x4)
SGVehicleSpawnPoint.VehicleTypeList = 0x330 // TArray<EESGVehicleType> (Size: 0x10)
SGVehicleSpawnPoint.WeightPerCategory = 0x340 // TArray<FVehicleSpawnWeightData> (Size: 0x10)
SGVehicleSpawnPoint.bRandomRotaion = 0x350 // bool (Size: 0x1)
SGVehicleSpawnPoint.ThingSpotComponent = 0x358 // SGThingSpotComponent* (Size: 0x8)
SGVehicleSpringArmComponent.bBlockWaterVolume = 0x2c0 // bool (Size: 0x1)
SGVehicleSpringArmComponent.bInsideWater = 0x2c1 // bool (Size: 0x1)
SGVehicleSyncPhysicStateComponent.MaxIgnoreDeltaTime = 0x238 // float (Size: 0x4)
SGVehicle_OffRoadSkined.CarMaterial = 0x890 // MaterialInstanceDynamic* (Size: 0x8)
SGVehicle_OffRoadSkined.GlassMaterial = 0x898 // MaterialInstanceDynamic* (Size: 0x8)
SGVehicle_OffRoadSkined.RooBar = 0x8a0 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.DoorFL = 0x8a8 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.DoorFR = 0x8b0 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.DoorBL = 0x8b8 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.DoorBR = 0x8c0 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.Hatch = 0x8c8 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.Siren = 0x8d0 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.Stepney = 0x8d8 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.Trunk = 0x8e0 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.Whell4 = 0x8e8 // StaticMeshComponent* (Size: 0x8)
SGVehicle_OffRoadSkined.bAddRooBar = 0x8f0 // bool (Size: 0x1)
SGVehicle_OffRoadSkined.bAddFlashingLight = 0x8f1 // bool (Size: 0x1)
SGVehicle_OffRoadSkined.bAddBackWhell = 0x8f2 // bool (Size: 0x1)
SGVehicle_OffRoadSkined.bAddTrunk = 0x8f3 // bool (Size: 0x1)
SGVehicle_OffRoadSkined.DoorRotatorFL = 0x8f4 // float (Size: 0x4)
SGVehicle_OffRoadSkined.DoorRotatorFR = 0x8f8 // float (Size: 0x4)
SGVehicle_OffRoadSkined.DoorRotatorBL = 0x8fc // float (Size: 0x4)
SGVehicle_OffRoadSkined.DoorRotatorBR = 0x900 // float (Size: 0x4)
SGVehicle_OffRoadSkined.CarColor1 = 0x904 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.CarColor2 = 0x914 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.Roughness = 0x924 // float (Size: 0x4)
SGVehicle_OffRoadSkined.Specular = 0x928 // float (Size: 0x4)
SGVehicle_OffRoadSkined.ColorMaskTexture = 0x930 // Texture2D* (Size: 0x8)
SGVehicle_OffRoadSkined.DirtColor = 0x938 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.DirtStr = 0x948 // float (Size: 0x4)
SGVehicle_OffRoadSkined.DirtNormalStr = 0x94c // float (Size: 0x4)
SGVehicle_OffRoadSkined.DirtRoughness = 0x950 // float (Size: 0x4)
SGVehicle_OffRoadSkined.FlashingLightVar = 0x954 // int32_t (Size: 0x4)
SGVehicle_OffRoadSkined.FlashingLightEmissiveStr = 0x958 // float (Size: 0x4)
SGVehicle_OffRoadSkined.FlashingLightBlinkingSpeed = 0x95c // float (Size: 0x4)
SGVehicle_OffRoadSkined.EmissiveStr = 0x960 // float (Size: 0x4)
SGVehicle_OffRoadSkined.FresnelColor1 = 0x964 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.FresnelColor2 = 0x974 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.FresnelExponent = 0x984 // float (Size: 0x4)
SGVehicle_OffRoadSkined.FresnelMultiply = 0x988 // float (Size: 0x4)
SGVehicle_OffRoadSkined.FlashingLightTexture1 = 0x990 // Texture2D* (Size: 0x8)
SGVehicle_OffRoadSkined.FlashingLightTexture2 = 0x998 // Texture2D* (Size: 0x8)
SGVehicle_OffRoadSkined.GlassSourceMaterial = 0x9a0 // MaterialInstanceConstant* (Size: 0x8)
SGVehicle_OffRoadSkined.GlassDirtColor = 0x9a8 // FLinearColor (Size: 0x10)
SGVehicle_OffRoadSkined.GlassDirtOpacity = 0x9b8 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassDirtRoughness = 0x9bc // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassDirtSpecular = 0x9c0 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassDirtStr = 0x9c4 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassNormalStr = 0x9c8 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassFresnelPower = 0x9cc // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassHDRStr = 0x9d0 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassMaxOpacity = 0x9d4 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassMinOpacity = 0x9d8 // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassRoughness = 0x9dc // float (Size: 0x4)
SGVehicle_OffRoadSkined.GlassSpecular = 0x9e0 // float (Size: 0x4)
SGVehicle_OffRoadSkined.DirtMaskTexture1 = 0x9e8 // Texture2D* (Size: 0x8)
SGVehicle_OffRoadSkined.DirtMaskTexture2 = 0x9f0 // Texture2D* (Size: 0x8)
SGVehicle_WheeledExtend.RandomMaterialList = 0x890 // TArray<MaterialInstanceConstant*> (Size: 0x10)
SGVehicle_WheeledExtend.RandomMaterialListLow = 0x8a0 // TArray<MaterialInstanceConstant*> (Size: 0x10)
SGView.Components = 0x408 // TArray<SGUserWidget*> (Size: 0x10)
SGView.BasePanelWidgetClass = 0x418 // ClassProperty (Size: 0x8)
SGView.BasePanelWidget = 0x420 // UserWidget* (Size: 0x8)
SGView.BasePanelZOrder = 0x428 // int32_t (Size: 0x4)
SGView.BasePanelArray = 0x430 // TArray<PanelWidget*> (Size: 0x10)
SGView.BasePanelWidgetArray = 0x440 // TArray<UserWidget*> (Size: 0x10)
SGViewSignificanceComponent.ViewSignPrimitives = 0x100 // TArray<PrimitiveComponent*> (Size: 0x10)
SGViewTable.WidgetViewId = 0x8 // int32_t (Size: 0x4)
SGViewTable.TemplateUMG_Resource = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
SGViewTable.Hierachy = 0x38 // EEHUDHierarchy (Size: 0x1)
SGViewTable.position = 0x3c // FVector2D (Size: 0x8)
SGViewTable.Anchor = 0x44 // FAnchors (Size: 0x10)
SGViewTable.Alignment = 0x54 // FVector2D (Size: 0x8)
SGViewTable.SizeToContent = 0x5c // bool (Size: 0x1)
SGVirtualItemInfo.ItemId = 0x0 // int32_t (Size: 0x4)
SGVirtualItemInfo.Num = 0x4 // int32_t (Size: 0x4)
SGVirtualItemInfo.ID = 0x8 // int32_t (Size: 0x4)
SGVirtualItemInfo.ExpireTime = 0xc // int32_t (Size: 0x4)
SGVolume.VolumeComponentClasses = 0x358 // TArray<ClassProperty> (Size: 0x10)
SGVolume.VolumeComponents = 0x368 // TArray<ActorComponent*> (Size: 0x10)
SGVolume.VolumeID = 0x378 // int32_t (Size: 0x4)
SGVolume.VolumeName = 0x380 // FString (Size: 0x10)
SGVolume.KeyItemID = 0x390 // int64_t (Size: 0x8)
SGVolumeInsulateComponent.TeamIndex = 0x100 // int32_t (Size: 0x4)
SGVolumeSpeedScaleComponent.SpeedScaleEffectClass = 0x100 // ClassProperty (Size: 0x8)
SGWatchGameSettleData.MurderName = 0x0 // FString (Size: 0x10)
SGWatchGameSettleData.MurderID = 0x10 // uint64_t (Size: 0x8)
SGWatchGameSettleData.MurderIsAI = 0x18 // bool (Size: 0x1)
SGWatchGameSettleData.Result = 0x1c // int32_t (Size: 0x4)
SGWatchGameSettleData.TeamType = 0x20 // int32_t (Size: 0x4)
SGWatchGameSettleData.GameTime = 0x24 // int32_t (Size: 0x4)
SGWatchGameSettleData.game_mode = 0x28 // int32_t (Size: 0x4)
SGWatchGameSettleData.bHas_Teammate = 0x2c // bool (Size: 0x1)
SGWatchGameSettleData.KillerTeamtype = 0x30 // int32_t (Size: 0x4)
SGWatchGameSettleData.MurderNationalFlagIso = 0x34 // int32_t (Size: 0x4)
SGWatchGameSettleData.KillerWeaponId = 0x38 // int32_t (Size: 0x4)
SGWatchGameSettleData.WatchShowData = 0x40 // FSGWatchShowData (Size: 0xc8)
SGWatchShowData.KillPMCNum = 0x0 // int32_t (Size: 0x4)
SGWatchShowData.KillEnemyNum = 0x4 // int32_t (Size: 0x4)
SGWatchShowData.TakeOutValue = 0x8 // int32_t (Size: 0x4)
SGWatchShowData.MurderCharacterType = 0xc // EECharacterType (Size: 0x1)
SGWatchShowData.MurderIconInfo = 0x10 // FSGPlayerIconInfo (Size: 0x58)
SGWatchShowData.MurderBannerInfo = 0x68 // FSGPlayerBannerInfo (Size: 0x28)
SGWatchShowData.AliveState = 0x90 // EEPlayerAliveState (Size: 0x1)
SGWatchShowData.PrivilegeLevel = 0x94 // uint32_t (Size: 0x4)
SGWatchShowData.BannerInfo = 0x98 // FSGPlayerBannerInfo (Size: 0x28)
SGWatchShowData.IntelligenceKeyTookOut = 0xc0 // bool (Size: 0x1)
SGWater.bSpawnWaterImpactForProjectile = 0x328 // bool (Size: 0x1)
SGWeapon.WeaponType = 0x8a8 // EESGWeaponType (Size: 0x1)
SGWeapon.GunWeaponSubType = 0x8a9 // EESGGunWeaponSubType (Size: 0x1)
SGWeapon.MeleeWeaponSubType = 0x8aa // EESGMeleeWeaponSubType (Size: 0x1)
SGWeapon.MeleeWeaponAnimType = 0x8ab // EESGMeleeWeaponAnimType (Size: 0x1)
SGWeapon.WeaponDetectorType = 0x8ac // EESGWeaponDetectorType (Size: 0x1)
SGWeapon.bValuableInventoryMeleeWeapon = 0x8ad // bool (Size: 0x1)
SGWeapon.bThrowableWeaponHasFired = 0x8ae // bool (Size: 0x1)
SGWeapon.CurrentWeaponViewEffectComp = 0x8b0 // SGWeaponViewEffectComponent* (Size: 0x8)
SGWeapon.OnProcessWeaponInnerEvent = 0x8c0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnFinishAssemble = 0x8d0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.ChangeWeaponOwner = 0x8e0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponAdapterAssembled = 0x8f0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponLeftHandMeshActive = 0x900 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponAdapterDisassembled = 0x910 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnMeleeWeaponCanReenterFire = 0x920 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnMeleeWeaponCanNextPhase = 0x930 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnMeleeWeaponCanNotNextPhase = 0x940 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnEnterAnimRecovery = 0x950 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnAnimationSetLoaded = 0x960 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponMergeFinished = 0x970 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnAllWeaponMeshLoaded = 0x980 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnSightListChanged = 0x990 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponRemoved = 0x9a0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponAttachedToHand = 0x9b0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponDetachedFromHand = 0x9c0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponPlayedMontage = 0x9d0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnZoomProgressChanged = 0x9e0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnWeaponAdapterDetach = 0x9f0 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.OnUpdateExtraMeshInfo = 0xa00 // FMulticastInlineDelegate (Size: 0x10)
SGWeapon.NeedRecoverTickComponentsSet = 0xa70 // TSet<...> (Size: 0x50)
SGWeapon.EnemyCharacters = 0xac8 // TArray<Character*> (Size: 0x10)
SGWeapon.EngageAngle = 0xad8 // float (Size: 0x4)
SGWeapon.RecoilData = 0xae0 // SGWeaponRecoilDataAsset_HD* (Size: 0x8)
SGWeapon.WeaponStabilityToBreathScaleCurve = 0xae8 // CurveLinearColor* (Size: 0x8)
SGWeapon.WeaponStabilityToImpactResistanceCurve = 0xaf0 // CurveFloat* (Size: 0x8)
SGWeapon.CurrentEngageEnemy = 0xb00 // SGCharacter* (Size: 0x8)
SGWeapon.DestWeaponCharacter = 0xb10 // SGCharacter* (Size: 0x8)
SGWeapon.WeaponAssembleComp = 0xb20 // SGWeaponAssembleComponent* (Size: 0x8)
SGWeapon.WeaponMeshComp = 0xb28 // SGWeaponMeshComponent* (Size: 0x8)
SGWeapon.WeaponMergeComp = 0xb30 // SGWeaponMergeComponent* (Size: 0x8)
SGWeapon.WeaponZoomComp = 0xb38 // SGWeaponZoomComponent* (Size: 0x8)
SGWeapon.WeaponFiringComp = 0xb40 // SGWeaponFiringComponent* (Size: 0x8)
SGWeapon.WeaponImpactComp = 0xb48 // SGWeaponImpactComponent* (Size: 0x8)
SGWeapon.WeaponRecoilComp = 0xb50 // SGWeaponRecoilComponent* (Size: 0x8)
SGWeapon.WeaponAnimationComp = 0xb58 // SGUAMWeaponAnimationComponent* (Size: 0x8)
SGWeapon.WeaponAppearanceComp = 0xb60 // SGWeaponAppearanceComponent* (Size: 0x8)
SGWeapon.WeaponMovementComp = 0xb68 // SGWeaponMovementComponent* (Size: 0x8)
SGWeapon.WeaponBoreComp = 0xb70 // SGWeaponBoreComponent* (Size: 0x8)
SGWeapon.WeaponFireIntervalComp = 0xb78 // SGWeaponFireIntervalComponent* (Size: 0x8)
SGWeapon.GunSoundComp = 0xb80 // SGGunSoundComponent* (Size: 0x8)
SGWeapon.ModifyBoneComp = 0xb88 // SGUAMWeaponModifyBoneComponent* (Size: 0x8)
SGWeapon.WeaponCameraComp = 0xb90 // SGWeaponCameraComponent* (Size: 0x8)
SGWeapon.WeaponSpreadComp = 0xb98 // SGWeaponSpreadComponent* (Size: 0x8)
SGWeapon.WeaponAmmoComp = 0xba0 // SGWeaponAmmoComponent* (Size: 0x8)
SGWeapon.WeaponDurabilityComp = 0xba8 // SGWeaponDurabilityComponent* (Size: 0x8)
SGWeapon.WeaponValidationComp = 0xbb0 // SGWeaponValidationComponent* (Size: 0x8)
SGWeapon.WeaponTacticalInvStateComp = 0xbb8 // SGWeaponTacticalInvStateComponent* (Size: 0x8)
SGWeapon.WeaponHeatComp = 0xbc0 // SGWeaponHeatComponent_HD* (Size: 0x8)
SGWeapon.WeaponASC = 0xbc8 // AbilitySystemComponent* (Size: 0x8)
SGWeapon.WeaponCustomSkill = 0xbd0 // EESGActionAbilityType (Size: 0x1)
SGWeapon.FlashLightComponents = 0xbd8 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGWeapon.bWeaponCanTacticalPistol = 0xbf0 // uint8_t (Size: 0x1)
SGWeapon.bIgnoreWeaponLODPolicy = 0xbf0 // uint8_t (Size: 0x1)
SGWeapon.bLeverAction = 0xbf0 // uint8_t (Size: 0x1)
SGWeaponAbilitySystemComponent.DefaultWeaponAttributeClass = 0x14a8 // ClassProperty (Size: 0x8)
SGWeaponAccesoryAnimationSet.EndFireSeq = 0x0 // AnimMontage* (Size: 0x8)
SGWeaponAdapterInfo.AdapterSocketType = 0x0 // EEAdapterType (Size: 0x1)
SGWeaponAdapterInfo.AdapterSubType = 0x1 // EESGWeapAdapterItemType (Size: 0x1)
SGWeaponAdapterInfo.AdapterString = 0x8 // FString (Size: 0x10)
SGWeaponAdapterInfo.bDisplaySocket = 0x18 // bool (Size: 0x1)
SGWeaponAdapterItem.MeshAttachSocket_1P = 0x28 // FName (Size: 0x8)
SGWeaponAdapterItem.MeshResouceRef_1P = 0x30 // FSoftObjectPath (Size: 0x18)
SGWeaponAdapterItem.MeshAttachSocket_3P = 0x48 // FName (Size: 0x8)
SGWeaponAdapterItem.MeshResouceRef_3P = 0x50 // FSoftObjectPath (Size: 0x18)
SGWeaponAdapterItem.MeshResouceRef_3P_Low = 0x68 // FSoftObjectPath (Size: 0x18)
SGWeaponAdapterItem.ParticlesSocket = 0x80 // FName (Size: 0x8)
SGWeaponAdapterItem.ParticlesTemplate = 0x88 // FSoftObjectPath (Size: 0x18)
SGWeaponAdapterItem.AdapterAnimFactor = 0xa0 // int32_t (Size: 0x4)
SGWeaponAdapterItem.OwnerWeapon = 0xa8 // SGWeapon* (Size: 0x8)
SGWeaponAdapterItem.WeaponMeshComp = 0xb0 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponAdapterItem.AttachSocketName = 0xb8 // FName (Size: 0x8)
SGWeaponAdapterItem.AttachHandSocketName = 0xc0 // FName (Size: 0x8)
SGWeaponAdapterItem.LocalAttachInfo = 0xc8 // FWeaponAdapterAttchingInfo (Size: 0x10)
SGWeaponAdapterItem.bItemAttached = 0xd8 // bool (Size: 0x1)
SGWeaponAdapterItem.bShouldAttached = 0xd9 // bool (Size: 0x1)
SGWeaponAdapterItem.MeshAttachTimerHandler = 0xe0 // FTimerHandle (Size: 0x8)
SGWeaponAdapterItem.bAsyncLoading = 0xe8 // bool (Size: 0x1)
SGWeaponAdapterItem.AdapterInventory = 0x110 // SGInventory* (Size: 0x8)
SGWeaponAdapterItem.AdapterParticleComponent = 0x118 // ParticleSystemComponent* (Size: 0x8)
SGWeaponAdapterItem.MeshPath = 0x120 // FSoftObjectPath (Size: 0x18)
SGWeaponAdapterItem.AdapterMeshComponent = 0x138 // StaticMeshComponent* (Size: 0x8)
SGWeaponAdapter_RangeScore.ZoomFOVSwitchArray = 0x140 // TArray<float> (Size: 0x10)
SGWeaponAdapter_RangeScore.IsArrayMode = 0x150 // bool (Size: 0x1)
SGWeaponAdapter_RangeScore.ZoomOffsetArray = 0x158 // TArray<float> (Size: 0x10)
SGWeaponAdapter_RangeScore.ZoomOffsetAimLength = 0x168 // float (Size: 0x4)
SGWeaponAdapter_RangeScore.ZoomOffsetAimDistance = 0x16c // float (Size: 0x4)
SGWeaponAdapter_RangeScore.ZoomScopeHigh = 0x170 // int32_t (Size: 0x4)
SGWeaponAdapter_RangeScore.ZoomScopeLow = 0x174 // int32_t (Size: 0x4)
SGWeaponAdapter_RangeScore.MovingRateDecPerc = 0x178 // float (Size: 0x4)
SGWeaponAdapter_RangeScore.ScopeZoomRate = 0x17c // float (Size: 0x4)
SGWeaponAdapter_RangeScore.CrosshairShowTimeRate = 0x180 // float (Size: 0x4)
SGWeaponAdapter_RangeScore.ScopeCrosshairStyleClass = 0x188 // ClassProperty (Size: 0x8)
SGWeaponAdapter_RangeScore.CrosshairDisplayHandler = 0x190 // FTimerHandle (Size: 0x8)
SGWeaponAdapter_RangeScore.ZoomFOV = 0x1b0 // float (Size: 0x4)
SGWeaponAmmoComponent.OriginalClipAmmoCount = 0x108 // int32_t (Size: 0x4)
SGWeaponAmmoComponent.bInitialAmmoEmpty = 0x10c // bool (Size: 0x1)
SGWeaponAmmoComponent.bAllowAutoChangeMagazineNative = 0x127 // bool (Size: 0x1)
SGWeaponAmmoComponent.WeaponAmmoCost = 0x128 // int32_t (Size: 0x4)
SGWeaponAmmoComponent.ClipAmmoCount = 0x12c // int32_t (Size: 0x4)
SGWeaponAmmoComponent.AmmoGravityScale = 0x130 // float (Size: 0x4)
SGWeaponAmmoComponent.AmmoResistanceFactorScale = 0x134 // float (Size: 0x4)
SGWeaponAmmoComponent.bIsReloading = 0x138 // bool (Size: 0x1)
SGWeaponAmmoComponent.CachedToFillAmmo = 0x140 // Actor* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Grip = 0x2b8 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Grip_Prone = 0x2c0 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Grip_3P = 0x2c8 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Grip_3P_Prone = 0x2d0 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Grip_Lobby = 0x2d8 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_FireMode_Single = 0x2e0 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_FireMode_Auto = 0x2e8 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_FireMode_Triple = 0x2f0 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_FireMode_HoldOpen = 0x2f8 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_Unloaded = 0x300 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_LostCatch = 0x308 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_HammerReady = 0x310 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_HammerUnready = 0x318 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.Sequence_WeaponCylinderRot = 0x320 // AnimSequence* (Size: 0x8)
SGWeaponAnimInstance.CylinderRotDeltaThreshold = 0x328 // float (Size: 0x4)
SGWeaponAnimInstance.LocalProxy = 0x330 // FSGWeaponAnimInstanceProxy (Size: 0x980)
SGWeaponAnimInstanceProxy.AnimInstance = 0x860 // SGWeaponAnimInstance* (Size: 0x8)
SGWeaponAnimInstanceProxy.bAutoFireMode = 0x868 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bBurstFireMode = 0x869 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsHammerReady = 0x86a // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.HammerStateBlendWeight = 0x86c // float (Size: 0x4)
SGWeaponAnimInstanceProxy.HoldOpenAlpha = 0x870 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.LostCatchAlpha = 0x874 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.UnloadedAlpha = 0x878 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.ChamberingAlpha = 0x87c // float (Size: 0x4)
SGWeaponAnimInstanceProxy.bIs1PWeapon = 0x880 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsOwnerCharacterProne = 0x881 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.Enalbe_Weapon_L_Hand_Marker = 0x884 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.bInLobby = 0x888 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsMelee = 0x889 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsGun = 0x88a // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsShowPhysicAnim = 0x88b // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.CharProneRatio = 0x88c // float (Size: 0x4)
SGWeaponAnimInstanceProxy.Translation_Hand_L = 0x890 // FVector (Size: 0xc)
SGWeaponAnimInstanceProxy.Rotation_Hand_L = 0x89c // FRotator (Size: 0xc)
SGWeaponAnimInstanceProxy.bCharacterOwnerIs1P = 0x8a8 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.Translation_Magazine = 0x8ac // FVector (Size: 0xc)
SGWeaponAnimInstanceProxy.Rotation_Magazine = 0x8b8 // FRotator (Size: 0xc)
SGWeaponAnimInstanceProxy.Enable_Magazine_Follows_Hand_L = 0x8c4 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.AnimReducer_Bore = 0x8c8 // FSGWeaponAnimReducer_Bore (Size: 0x18)
SGWeaponAnimInstanceProxy.Enable_BoreOverride = 0x8e0 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.Disable_BoltAnim = 0x8e4 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.EnableLobbyWeaponGripPose = 0x8e8 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.WeaponCylinderAnimTime = 0x8ec // float (Size: 0x4)
SGWeaponAnimInstanceProxy.CylinderRotInCurve = 0x8f0 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.CylinderRotExtra = 0x8f4 // float (Size: 0x4)
SGWeaponAnimInstanceProxy.bEnableWeaponCylinderAnim = 0x8f8 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsCurWeapon = 0x900 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.bIsWeaponAttachedByAnimation = 0x901 // bool (Size: 0x1)
SGWeaponAnimInstanceProxy.FollowTarget = 0x908 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponAnimInstanceProxy.FollowTargetRootTrans = 0x910 // FTransform (Size: 0x30)
SGWeaponAnimInstanceProxy.FollowTargetPelvisTrans = 0x940 // FTransform (Size: 0x30)
SGWeaponAnimInstanceProxy.CharNoWeaponPhysicSimulateCurveValue = 0x970 // float (Size: 0x4)
SGWeaponAnimReducer_Bore.BoreOpenRatio = 0x8 // float (Size: 0x4)
SGWeaponAnimationComponent.bImmediateOrDefferLoadAnimationSet_InGame = 0x108 // bool (Size: 0x1)
SGWeaponAnimationComponent.bImmediateOrDefferLoadAnimationSet_Lobby = 0x109 // bool (Size: 0x1)
SGWeaponAnimationComponent.CharacterAnimationSetsPath = 0x110 // FSoftObjectPath (Size: 0x18)
SGWeaponAnimationComponent.PerWeaponAnimationSetsPath = 0x128 // FSoftObjectPath (Size: 0x18)
SGWeaponAnimationComponent.CharacterAnimationSetsClass = 0x140 // ClassProperty (Size: 0x8)
SGWeaponAnimationComponent.PerWeaponAnimationSetsClass = 0x148 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponAnimationComponent.PerWeaponAnimationSetsClassForSkin = 0x170 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponAnimationComponent.CharacterEquipAnimInstanceClass = 0x198 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponAnimationComponent.LobbySuperIdleAnimInstanceClass = 0x1c0 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponAnimationComponent.CurrentPerWeaponAnimationSetsClass = 0x1e8 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponAnimationComponent.LeftArmOffset = 0x210 // FVector (Size: 0xc)
SGWeaponAnimationComponent.RightHandOffset = 0x21c // FVector (Size: 0xc)
SGWeaponAnimationComponent.RightArmAimOffset = 0x228 // FVector (Size: 0xc)
SGWeaponAnimationComponent.TacticalLeftHandOffset = 0x234 // FVector (Size: 0xc)
SGWeaponAnimationComponent.TacticalRightHandOffset = 0x240 // FVector (Size: 0xc)
SGWeaponAnimationComponent.WeaponSwaySpringInfo = 0x264 // FSGWeaponSwaySpringInfo (Size: 0x24)
SGWeaponAnimationComponent.WeaponSwayADSInfo = 0x288 // FSGWeaponSwayADSInfo (Size: 0x58)
SGWeaponAnimationComponent.WeaponOriginBoneName = 0x2e0 // FName (Size: 0x8)
SGWeaponAnimationComponent.WeaponGripBoneName = 0x2e8 // FName (Size: 0x8)
SGWeaponAnimationComponent.TacticalFiringAnimationAlpha_LeftHand = 0x2f0 // float (Size: 0x4)
SGWeaponAnimationComponent.TacticalFiringAnimationAlpha_RightHand = 0x2f4 // float (Size: 0x4)
SGWeaponAnimationComponent.WeaponOffset3P = 0x2f8 // FVector (Size: 0xc)
SGWeaponAnimationComponent.WeaponOffsetSprinting1P = 0x310 // FTransform (Size: 0x30)
SGWeaponAnimationComponent.WeaponOffsetSprintingViewWeapon = 0x340 // FVector (Size: 0xc)
SGWeaponAnimationComponent.TPPWeaponOffsetCrouchMoving = 0x34c // FVector (Size: 0xc)
SGWeaponAnimationComponent.WeaponSprintLeftArmRot = 0x358 // FRotator (Size: 0xc)
SGWeaponAnimationComponent.ProneMoveWeaponOffset = 0x364 // FVector (Size: 0xc)
SGWeaponAnimationComponent.SwitchWeaponTakeUpReverseCompensationTime_Server = 0x370 // float (Size: 0x4)
SGWeaponAnimationComponent.SwitchToWeaponWithHandDownReverseCompensationTime_Server = 0x374 // float (Size: 0x4)
SGWeaponAnimationComponent.SwitchWeaponTakeUpReverseCompensationTime_Local = 0x378 // float (Size: 0x4)
SGWeaponAnimationComponent.SwitchWeaponTakeUpReverseCompensationTime_Local_MeleeToMain = 0x37c // float (Size: 0x4)
SGWeaponAnimationComponent.CaptureCharacterWeaponOffset = 0x380 // FTransform (Size: 0x30)
SGWeaponAnimationComponent.DTCharacterWeaponOffset = 0x3b0 // FTransform (Size: 0x30)
SGWeaponAnimationComponent.ZDCharacterWeaponOffsetMap = 0x3e0 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.JSCharacterWeaponOffsetMap = 0x430 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.bIsUseSelfCollapseDataRun = 0x480 // bool (Size: 0x1)
SGWeaponAnimationComponent.CollapseOffsetOverrideRun_1P = 0x484 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGWeaponAnimationComponent.CollapseOffsetOverrideRun_3P = 0x4b4 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGWeaponAnimationComponent.CollapseTraceDistanceRun = 0x4e4 // float (Size: 0x4)
SGWeaponAnimationComponent.CollapsePullBackRangeRun = 0x4e8 // FVector2D (Size: 0x8)
SGWeaponAnimationComponent.CollapseFoldRangeRun = 0x4f0 // FVector2D (Size: 0x8)
SGWeaponAnimationComponent.CollapseTraceStartBoneRun = 0x4f8 // FName (Size: 0x8)
SGWeaponAnimationComponent.bIsUseSelfCollapseDataSprint = 0x500 // bool (Size: 0x1)
SGWeaponAnimationComponent.CollapseOffsetOverrideSprint_1P = 0x504 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGWeaponAnimationComponent.CollapseOffsetOverrideSprint_3P = 0x534 // FWeaponTraceRightHandOffsetParam (Size: 0x30)
SGWeaponAnimationComponent.CollapseTraceDistanceSprint = 0x564 // float (Size: 0x4)
SGWeaponAnimationComponent.CollapsePullBackRangeSprint = 0x568 // FVector2D (Size: 0x8)
SGWeaponAnimationComponent.CollapseFoldRangeSprint = 0x570 // FVector2D (Size: 0x8)
SGWeaponAnimationComponent.CollapseTraceStartBoneSprint = 0x578 // FName (Size: 0x8)
SGWeaponAnimationComponent.IsAlwaysOverrideUpperBody3P_Stand = 0x580 // bool (Size: 0x1)
SGWeaponAnimationComponent.IsAlwaysOverrideUpperBody3P_Crouch = 0x581 // bool (Size: 0x1)
SGWeaponAnimationComponent.IsAlwaysOverrideUpperBody3P_Prone = 0x582 // bool (Size: 0x1)
SGWeaponAnimationComponent.IsAlwaysOverrideUpperBody3P_Sprint = 0x583 // bool (Size: 0x1)
SGWeaponAnimationComponent.IsAlwaysOverrideUpperBody3P_DBNO = 0x584 // bool (Size: 0x1)
SGWeaponAnimationComponent.IsBindItemLtoR = 0x585 // bool (Size: 0x1)
SGWeaponAnimationComponent.BindItemLtoR_RelativeTrans = 0x590 // FTransform (Size: 0x30)
SGWeaponAnimationComponent.WeaponAnimationTag = 0x5c0 // FName (Size: 0x8)
SGWeaponAnimationComponent.AnimTagToLeftHandFollowsMagazineOffset = 0x5c8 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.LeftHandFollowsMagazineSocketName = 0x618 // FName (Size: 0x8)
SGWeaponAnimationComponent.PreloadCustomAnimationsForAI = 0x638 // TArray<FString> (Size: 0x10)
SGWeaponAnimationComponent.InventoryTagToGripTypeList = 0x648 // TArray<FSGWeaponInventoryTagToGripType> (Size: 0x10)
SGWeaponAnimationComponent.BaseForeGrips = 0x658 // TArray<AnimSequence*> (Size: 0x10)
SGWeaponAnimationComponent.BaseForeCharacterGrips = 0x668 // TSet<...> (Size: 0x50)
SGWeaponAnimationComponent.BaseGripOffsetCurveName_X = 0x6b8 // FName (Size: 0x8)
SGWeaponAnimationComponent.BaseGripOffsetCurveName_Y = 0x6c0 // FName (Size: 0x8)
SGWeaponAnimationComponent.BaseGripOffsetCurveName_Z = 0x6c8 // FName (Size: 0x8)
SGWeaponAnimationComponent.DefaultRearGripHandType = 0x6d0 // EESGWeaponReargripType (Size: 0x1)
SGWeaponAnimationComponent.ForeGripOffset = 0x728 // FVector (Size: 0xc)
SGWeaponAnimationComponent.SkinIDSet = 0x740 // TSet<...> (Size: 0x50)
SGWeaponAnimationComponent.InvIDSet = 0x790 // TSet<...> (Size: 0x50)
SGWeaponAnimationComponent.SkinIDToInventory = 0x7e0 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.CachedSpecialSpecAnimation = 0x830 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.CurrentOverrideAnimation = 0x880 // TMap<...> (Size: 0x50)
SGWeaponAnimationComponent.CurrentWeaponOwner = 0x900 // SGCharacter* (Size: 0x8)
SGWeaponAnimationComponent.CurrentPreloadAnimationMode = 0x908 // EEPreloadAnimationMode (Size: 0x1)
SGWeaponAnimationComponent.DetachMeshTimePercent = 0x90c // float (Size: 0x4)
SGWeaponAnimationComponent.AttachMeshTimePercent = 0x910 // float (Size: 0x4)
SGWeaponAnimationComponent.bEnableBaseAkmTriggerOffset = 0x914 // bool (Size: 0x1)
SGWeaponAnimationComponent.LocalAnimInfo = 0x918 // FSGWeaponLocalAnimInfo (Size: 0xa8)
SGWeaponAnimationComponent.RepAnimInfo = 0x9c0 // FSGWeaponRepAnimInfo (Size: 0xd8)
SGWeaponAnimationComponent.RepStopAnimInfo = 0xa98 // FSGWeaponRepStopAnimInfo (Size: 0x98)
SGWeaponAnimationComponent.LastPlayAnimMontage3P = 0xb30 // AnimMontage* (Size: 0x8)
SGWeaponAnimationComponent.ReloadBoresOneByOneAnimParams = 0xb78 // FSGReloadBoresOneByOneAnimParams (Size: 0x28)
SGWeaponAnimationComponent.CharacterLobbySuperIdleInstance = 0xbc8 // SGCharacterLobbySuperIdleAnimInstance* (Size: 0x8)
SGWeaponAppearanceComponent.PlayerAnimInst = 0x110 // AnimInstance* (Size: 0x8)
SGWeaponAppearanceComponent.TargetParentMesh = 0x118 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponAppearanceComponent.ForceAttachIndex = 0x120 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.BackWeaponAttachTransform = 0x130 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.bDifferentWeaponAttachTransform = 0x160 // bool (Size: 0x1)
SGWeaponAppearanceComponent.DTBackWeaponAttachTransform = 0x170 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.HandWeaponOffset = 0x1a0 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.RightHandWeaponOffsetWhenSprint = 0x1b0 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.WeaponBackAttachCustomSocket = 0x1e0 // FName (Size: 0x8)
SGWeaponAppearanceComponent.WeaponBackAttachType = 0x1e8 // EESGBackWeaponAttachType (Size: 0x1)
SGWeaponAppearanceComponent.DeferredCreatedWeaponMesh = 0x1f0 // SkeletalMesh* (Size: 0x8)
SGWeaponAppearanceComponent.MeshAttachCharacterSocket = 0x210 // FName (Size: 0x8)
SGWeaponAppearanceComponent.MeshAttachCharacterSocket_Left = 0x218 // FName (Size: 0x8)
SGWeaponAppearanceComponent.MeshAttachCharacterSocket_Hang = 0x220 // FName (Size: 0x8)
SGWeaponAppearanceComponent.MeshAttachCharacterSocket_FPP = 0x228 // FName (Size: 0x8)
SGWeaponAppearanceComponent.MeshAttachCharacterSocket_Tactical = 0x230 // FName (Size: 0x8)
SGWeaponAppearanceComponent.bHangToBackWhenDetach = 0x238 // bool (Size: 0x1)
SGWeaponAppearanceComponent.bIsUseABAttach_OnHand = 0x239 // bool (Size: 0x1)
SGWeaponAppearanceComponent.SimpleMeshAttachSocketName = 0x23c // FName (Size: 0x8)
SGWeaponAppearanceComponent.BackWeaponLeftAttachOffsetInLobby = 0x244 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.HideOnBack = 0x250 // bool (Size: 0x1)
SGWeaponAppearanceComponent.WeaponAttachHandRelativeTrans_1P = 0x260 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.WeaponAttachHandRelativeTrans_3P = 0x290 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.WeaponAttachHandRelativeTrans_Lobby = 0x2c0 // FTransform (Size: 0x30)
SGWeaponAppearanceComponent.WeaponMeshComp = 0x2f0 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponAppearanceComponent.WeaponAttachSocket = 0x2f8 // FName (Size: 0x8)
SGWeaponAppearanceComponent.WeaponGripOffset = 0x300 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FPFireTemplate = 0x310 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.TPFireTemplate = 0x360 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.FogTemplate = 0x3b0 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.FireLightTemplate = 0x400 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.IntensityOfFireLight = 0x450 // float (Size: 0x4)
SGWeaponAppearanceComponent.FireLightSize = 0x454 // float (Size: 0x4)
SGWeaponAppearanceComponent.FireLightTemplate_LDR = 0x458 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.IntensityColorOfFireLight_LDR = 0x4a8 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FireLightSize_LDR = 0x4b4 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FireLightTemplate3P = 0x4c0 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.IntensityOfFireLight3P = 0x510 // float (Size: 0x4)
SGWeaponAppearanceComponent.FireLightSize3P = 0x514 // float (Size: 0x4)
SGWeaponAppearanceComponent.FireLightTemplate3P_LDR = 0x518 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.IntensityColorOfFireLight3P_LDR = 0x568 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FireLightSize3P_LDR = 0x574 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FPMergeFireHDRTemplate = 0x580 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.FPMergeFireLDRTemplate = 0x5d0 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.TPMergeFireHDRTemplate = 0x620 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.TPMergeFireLDRTemplate = 0x670 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.FPFireLightOffset = 0x6c0 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.FPFireLightOffset_ADS = 0x6cc // FVector (Size: 0xc)
SGWeaponAppearanceComponent.CompositeFireTemplate3P = 0x6d8 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.CompositeFireTemplate = 0x728 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.FireMotionBlurCurve = 0x778 // CurveFloat* (Size: 0x8)
SGWeaponAppearanceComponent.AliveShotFireEffectNum = 0x780 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.AliveShotFogEffectNum = 0x784 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.AliveMergedEffectNum = 0x788 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.AliveBulletShellEffectNum = 0x78c // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.LastRenderTimeNotPlayEffect = 0x790 // float (Size: 0x4)
SGWeaponAppearanceComponent.BulletTraceParticleLiveCountMax = 0x794 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.FireCountShowContinuousFireFog = 0x798 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.ShellTemplate = 0x7a0 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.bCustomShellADS = 0x7f0 // bool (Size: 0x1)
SGWeaponAppearanceComponent.ShellADSTemplate = 0x7f8 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.bCustomShellParam = 0x848 // bool (Size: 0x1)
SGWeaponAppearanceComponent.ShellParticleInfo = 0x84c // FShellParticleInfo (Size: 0xa0)
SGWeaponAppearanceComponent.ShellParticleADSInfo = 0x8ec // FShellParticleInfo (Size: 0xa0)
SGWeaponAppearanceComponent.GrenadeBlotTemplate = 0x990 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.ShellEffectInfo_1P = 0x9e0 // FShellEffectInfo_HD (Size: 0x34)
SGWeaponAppearanceComponent.ShellEffectInfo_3P = 0xa14 // FShellEffectInfo_HD (Size: 0x34)
SGWeaponAppearanceComponent.SmokeTemplate = 0xa48 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.SmokeEffectContinuousCount = 0xa98 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.SmokeEffectHeatThreshold = 0xa9c // float (Size: 0x4)
SGWeaponAppearanceComponent.CompositeFireLightSize = 0xaa0 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.CompositeFireLightColor = 0xaac // FVector (Size: 0xc)
SGWeaponAppearanceComponent.CompositeFireLightSize3P = 0xab8 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.CompositeFireLightColor3P = 0xac4 // FVector (Size: 0xc)
SGWeaponAppearanceComponent.BarrelSmokeTemplates = 0xad0 // TArray<FEffectParticleInfo> (Size: 0x10)
SGWeaponAppearanceComponent.BarrelSmokeHeatThreshold = 0xae0 // float (Size: 0x4)
SGWeaponAppearanceComponent.BarrelSmokeFXSCs = 0xae8 // TArray<FXSystemComponent*> (Size: 0x10)
SGWeaponAppearanceComponent.HeatDistortRange = 0xb00 // FVector2D (Size: 0x8)
SGWeaponAppearanceComponent.DefaultFirstShootProbability = 0xb08 // float (Size: 0x4)
SGWeaponAppearanceComponent.DefaultContinuousShootProbability = 0xb0c // float (Size: 0x4)
SGWeaponAppearanceComponent.PooledFogEffect = 0xb10 // SGPooledFireEffect* (Size: 0x8)
SGWeaponAppearanceComponent.FogEffectPSC = 0xb18 // ParticleSystemComponent* (Size: 0x8)
SGWeaponAppearanceComponent.FogOpacityDecSpeed = 0xb20 // float (Size: 0x4)
SGWeaponAppearanceComponent.PooledEffectLiveQueuesMap = 0xb30 // TMap<...> (Size: 0x50)
SGWeaponAppearanceComponent.PooledPSCQueuesMap = 0xb80 // TMap<...> (Size: 0x50)
SGWeaponAppearanceComponent.WeaponPSC = 0xbd0 // NiagaraComponent* (Size: 0x8)
SGWeaponAppearanceComponent.WeaponShellPSC = 0xbd8 // NiagaraComponent* (Size: 0x8)
SGWeaponAppearanceComponent.MuzzleSocket = 0xbe0 // FName (Size: 0x8)
SGWeaponAppearanceComponent.AdapterMuzzleSocket = 0xbe8 // FName (Size: 0x8)
SGWeaponAppearanceComponent.BlastingFuseTemplate = 0xbf0 // FEffectParticleInfo (Size: 0x50)
SGWeaponAppearanceComponent.BlastingFusePooledEffect = 0xc40 // SGPooledFireEffect* (Size: 0x8)
SGWeaponAppearanceComponent.BlastingFuseFXSC = 0xc48 // FXSystemComponent* (Size: 0x8)
SGWeaponAppearanceComponent.MolotovLoopAudioEvent = 0xc50 // AkAudioEvent* (Size: 0x8)
SGWeaponAppearanceComponent.MaxCachedShellNum = 0xc58 // int32_t (Size: 0x4)
SGWeaponAppearanceComponent.Timer_FireShellPSCCooldown = 0xd88 // FTimerHandle (Size: 0x8)
SGWeaponAssembleCaptureEditor.CaptureInterval = 0x990 // float (Size: 0x4)
SGWeaponAssembleCaptureEditor.ImgSizeScale = 0x994 // float (Size: 0x4)
SGWeaponAssembleCaptureEditor.RTWidthList = 0x998 // TArray<float> (Size: 0x10)
SGWeaponAssembleCaptureEditor.DisplayRTWidth = 0x9a8 // float (Size: 0x4)
SGWeaponAssembleCaptureEditor.ItemSize = 0x9b0 // TMap<...> (Size: 0x50)
SGWeaponAssembleCaptureEditor.ItemConf = 0xa00 // DataTable* (Size: 0x8)
SGWeaponAssembleCaptureEditor.MeshObjMap = 0xa08 // TMap<...> (Size: 0x50)
SGWeaponAssembleComponent.CurrentFrontSight = 0x108 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.SightListByPriority = 0x110 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.IllegalSightList = 0x120 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedRangedScopeList = 0x130 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedRearSightList = 0x140 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedFrontSightList = 0x150 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedTiltingRearSightList = 0x160 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedTiltingFrontSightList = 0x170 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedMechanicalAim = 0x180 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedMuzzleInventory = 0x188 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedBarrelInventory = 0x190 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedGastubeInventory = 0x198 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedRecieverInventory = 0x1a0 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedBipodInventory = 0x1a8 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedStockInventory = 0x1b0 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedForegripInventory = 0x1b8 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedReargripInventory = 0x1c0 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedHandguardInventory = 0x1c8 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedStockList = 0x1d0 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.CachedOrnamentInventory = 0x1e0 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedSightBlockTestAdapters = 0x1e8 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.AssembledInventoryList = 0x1f8 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.AssembledInventoryList_CachedOnRefresh = 0x208 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.bEnableDebug = 0x218 // bool (Size: 0x1)
SGWeaponAssembleComponent.CachedForegripComponentTransform = 0x220 // FTransform (Size: 0x30)
SGWeaponAssembleComponent.SightGroupList = 0x250 // TArray<FSightGroup> (Size: 0x10)
SGWeaponAssembleComponent.PistolGripAssembleTag = 0x260 // FGameplayTag (Size: 0x8)
SGWeaponAssembleComponent.AttachHandSocketName = 0x268 // FName (Size: 0x8)
SGWeaponAssembleComponent.MagazineSocketName = 0x270 // FName (Size: 0x8)
SGWeaponAssembleComponent.AssembledAdapterTotalCount_Server = 0x278 // int32_t (Size: 0x4)
SGWeaponAssembleComponent.CachedMagazine = 0x280 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.bClientPredictCurrentSight = 0x292 // bool (Size: 0x1)
SGWeaponAssembleComponent.CurrentSight = 0x298 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CurrentSight_Server = 0x2a0 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.WeaponWidth = 0x2ac // int32_t (Size: 0x4)
SGWeaponAssembleComponent.WeaponHeight = 0x2b0 // int32_t (Size: 0x4)
SGWeaponAssembleComponent.ErrorIronSightXAngle = 0x2b4 // float (Size: 0x4)
SGWeaponAssembleComponent.ErrorIronSightYAngle = 0x2b8 // float (Size: 0x4)
SGWeaponAssembleComponent.FireRequireTagList = 0x2c0 // FGameplayTagContainer (Size: 0x20)
SGWeaponAssembleComponent.AddedFireRequireTagList = 0x2e0 // TArray<FFireRequireInfo> (Size: 0x10)
SGWeaponAssembleComponent.EnableIllegaSight = 0x2f0 // bool (Size: 0x1)
SGWeaponAssembleComponent.BipCheckSocketName = 0x2f4 // FName (Size: 0x8)
SGWeaponAssembleComponent.BipCheckVec = 0x2fc // FVector (Size: 0xc)
SGWeaponAssembleComponent.ResetSightTimeHandler = 0x310 // FTimerHandle (Size: 0x8)
SGWeaponAssembleComponent.AssembledInventory_Server = 0x318 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.AssembledInventory_Client = 0x328 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAssembleComponent.bCanEverCaptureWeaponRT = 0x33a // bool (Size: 0x1)
SGWeaponAssembleComponent.bIsInFoldStockState = 0x33c // bool (Size: 0x1)
SGWeaponAssembleComponent.FoldScopeMontageHandOffset = 0x340 // FVector (Size: 0xc)
SGWeaponAssembleComponent.CurrentAimCameraInv = 0x350 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CurrentAlignFrontInv = 0x358 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CurrentAimBaseInv = 0x360 // SGInventory* (Size: 0x8)
SGWeaponAssembleComponent.CachedSightPositionMap = 0x368 // TMap<...> (Size: 0x50)
SGWeaponAssembleComponent.CachedLargestSightPosition = 0x3b8 // float (Size: 0x4)
SGWeaponAssembleComponent.EyePieceSocketName = 0x3bc // FName (Size: 0x8)
SGWeaponAssembleComponent.bForceCapture = 0x3c4 // bool (Size: 0x1)
SGWeaponAssembleComponent.BringInPendantID = 0x3d4 // int32_t (Size: 0x4)
SGWeaponAssembleComponent.CheckAllMeshLoadedHandle = 0x3d8 // FTimerHandle (Size: 0x8)
SGWeaponAssembleComponent.IronSightsMatchRotationRange = 0x3e4 // FRotator (Size: 0xc)
SGWeaponAssembleEnvironment.CaputureInited = 0x650 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.Saturate = 0x654 // float (Size: 0x4)
SGWeaponAssembleEnvironment.MarginPixel = 0x658 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.CachedRTInfoMap = 0x660 // TMap<...> (Size: 0x50)
SGWeaponAssembleEnvironment.SaveRT = 0x6d0 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.SaveRTUsingItemID = 0x6d1 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.AutoCalcZeroRotator = 0x6d3 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.RTWidthForUnassembled = 0x6d4 // float (Size: 0x4)
SGWeaponAssembleEnvironment.RTWidth = 0x6d8 // float (Size: 0x4)
SGWeaponAssembleEnvironment.bGenerateMipmap = 0x6dc // bool (Size: 0x1)
SGWeaponAssembleEnvironment.ScaleCurve = 0x6e0 // CurveFloat* (Size: 0x8)
SGWeaponAssembleEnvironment.RotatorConf = 0x6e8 // DataTable* (Size: 0x8)
SGWeaponAssembleEnvironment.SceneCaptureComponent = 0x6f0 // SceneCaptureComponent2D* (Size: 0x8)
SGWeaponAssembleEnvironment.UseCache = 0x6f8 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.UseLocalImage = 0x6f9 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.DebugEnableCapture = 0x6fa // bool (Size: 0x1)
SGWeaponAssembleEnvironment.bResetMesh = 0x6fb // bool (Size: 0x1)
SGWeaponAssembleEnvironment.DebugTestItemID = 0x700 // TArray<int64_t> (Size: 0x10)
SGWeaponAssembleEnvironment.DebugTestUniqueID = 0x710 // FString (Size: 0x10)
SGWeaponAssembleEnvironment.DebugTestFullWeaponID = 0x720 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.bForceReplaceWeaponAdapterIcon = 0x724 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.bForceReplaceUnassembledArmorIcon = 0x725 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.bForceReplaceAssembledWeapon = 0x726 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.bDebugWeaponCaptureSize = 0x729 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.DebugWeaponCaptureSizeTable = 0x730 // DataTable* (Size: 0x8)
SGWeaponAssembleEnvironment.MaterialTemplate = 0x738 // MaterialInterface* (Size: 0x8)
SGWeaponAssembleEnvironment.bEnableShadow = 0x740 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.CacheValidateTime = 0x744 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.MaterialParameterCollection = 0x748 // MaterialParameterCollection* (Size: 0x8)
SGWeaponAssembleEnvironment.ExBaseMeshRot = 0x750 // FRotator (Size: 0xc)
SGWeaponAssembleEnvironment.ExCameraPosForCollapseHelmet = 0x75c // FVector (Size: 0xc)
SGWeaponAssembleEnvironment.ExCameraPosForCollapseWeapon = 0x768 // FVector (Size: 0xc)
SGWeaponAssembleEnvironment.GridSize = 0x774 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.Rot_1x1 = 0x778 // FRotator (Size: 0xc)
SGWeaponAssembleEnvironment.Rot_1x2 = 0x784 // FRotator (Size: 0xc)
SGWeaponAssembleEnvironment.Rot_1x3 = 0x790 // FRotator (Size: 0xc)
SGWeaponAssembleEnvironment.NearClippingPlaneForUnassembledAdapter = 0x79c // float (Size: 0x4)
SGWeaponAssembleEnvironment.DefineRTSize = 0x7a4 // FVector2D (Size: 0x8)
SGWeaponAssembleEnvironment.CaptureComponent = 0x7b0 // SphereReflectionCaptureComponent* (Size: 0x8)
SGWeaponAssembleEnvironment.bAutoCapture = 0x7b8 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.ExistOfflineIcons = 0x7c0 // TArray<FString> (Size: 0x10)
SGWeaponAssembleEnvironment.LoadedInventoryIDMap = 0x7d0 // TMap<...> (Size: 0x50)
SGWeaponAssembleEnvironment.bGenSkinInv = 0x820 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.bRestrictMaxPixel = 0x821 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.MaxPixelPerGrid = 0x824 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.MaxPixel = 0x828 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.MaxPixel_1x1 = 0x82c // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.bSaveUnassembledAdapter = 0x830 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.ActorComps = 0x838 // TArray<ActorComponent*> (Size: 0x10)
SGWeaponAssembleEnvironment.WeaponWaitCaptureMap = 0x848 // TMap<...> (Size: 0x50)
SGWeaponAssembleEnvironment.PivotComp = 0x8a8 // SceneComponent* (Size: 0x8)
SGWeaponAssembleEnvironment.MaxCachedMaterailNumInLobby = 0x904 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.MaxCachedMaterailNumInBattle = 0x908 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.MaxCachedMaterailSizeInLobby = 0x90c // int32_t (Size: 0x4)
SGWeaponAssembleEnvironment.AssembleEnvs = 0x910 // TArray<SGWeaponAssembleEnvironment*> (Size: 0x10)
SGWeaponAssembleEnvironment.ShouldCheckExist = 0x970 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.IsEditorTool = 0x971 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.MaxAllowStreamingTime = 0x980 // float (Size: 0x4)
SGWeaponAssembleEnvironment.CreateInvsFinished = 0x985 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.CreateWeaponWaitCaptureMapFinished = 0x986 // bool (Size: 0x1)
SGWeaponAssembleEnvironment.IgnoreOfflineIcon = 0x987 // bool (Size: 0x1)
SGWeaponAssembleEnvironmentConfig.TouchRotateSpeed = 0xf8 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MaxPitch = 0xfc // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MaxYaw = 0x100 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MaxRoll = 0x104 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MinPitch = 0x108 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MinYaw = 0x10c // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MinRoll = 0x110 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.RotChangeSpeed = 0x114 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.PosChangeSpeed = 0x118 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.FixCamMaxPosX = 0x11c // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.FocusCamPosXScale = 0x120 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.ShakeAnimPeriod = 0x124 // int32_t (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.Tolerance = 0x128 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.OnePEffectDis = 0x12c // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.PinchSpeed = 0x130 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MinPinchDisPercent = 0x134 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.MaxPinchDisPercent = 0x138 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.FocusPartCfgMap = 0x140 // TMap<...> (Size: 0x50)
SGWeaponAssembleEnvironmentConfig.FixCamFullScreenPosX = 0x190 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.FocusCamFullScreenPosXScale = 0x194 // float (Size: 0x4)
SGWeaponAssembleEnvironmentConfig.CameraPosOffset = 0x198 // FVector (Size: 0xc)
SGWeaponAssemblePreview.EnableAutoSize = 0x650 // bool (Size: 0x1)
SGWeaponAssemblePreview.MaxBounds = 0x654 // FVector (Size: 0xc)
SGWeaponAssemblePreview.MaxScale = 0x660 // float (Size: 0x4)
SGWeaponAssemblePreview.MinScale = 0x664 // float (Size: 0x4)
SGWeaponAssemblePreview.xPercent = 0x668 // float (Size: 0x4)
SGWeaponAssemblePreview.yPercent = 0x66c // float (Size: 0x4)
SGWeaponAssemblePreview.CameraName = 0x670 // FString (Size: 0x10)
SGWeaponAssemblePreview.BoundsSizeInScreen = 0x680 // FVector2D (Size: 0x8)
SGWeaponAssemblePreview.NewScale = 0x688 // float (Size: 0x4)
SGWeaponAssemblePreview.NewExtends = 0x68c // FVector (Size: 0xc)
SGWeaponAssemblePreview.RenderOverTime = 0x698 // float (Size: 0x4)
SGWeaponAssemblePreview.Debug = 0x69c // bool (Size: 0x1)
SGWeaponAssemblePreview.PivotComp = 0x6a0 // SceneComponent* (Size: 0x8)
SGWeaponAssemblePreview.CurrentAssembleWeapon = 0x6a8 // SGInventory* (Size: 0x8)
SGWeaponAssemblePreview.WeaponRotBeforeFocus = 0x6b0 // FRotator (Size: 0xc)
SGWeaponAssemblePreview.OutLinedMesh = 0x6e8 // MeshComponent* (Size: 0x8)
SGWeaponAssemblePreview.CamActor = 0x6f0 // CameraActor* (Size: 0x8)
SGWeaponAssemblePreview.FocusSpeed = 0x6f8 // float (Size: 0x4)
SGWeaponAssemblePreview.FixCamMaxPosX = 0x6fc // float (Size: 0x4)
SGWeaponAssemblePreview.CameraFullScreenPos = 0x700 // FVector (Size: 0xc)
SGWeaponAssemblePreview.RotChangeSpeed = 0x720 // float (Size: 0x4)
SGWeaponAssemblePreview.RotateResetSpeedPitch = 0x728 // float (Size: 0x4)
SGWeaponAssemblePreview.RotateResetSpeedYaw = 0x72c // float (Size: 0x4)
SGWeaponAssemblePreview.TransparentMaterial = 0x738 // MaterialInterface* (Size: 0x8)
SGWeaponAttachmentComponent.LocalAttachmentRecycleBin = 0x118 // TArray<SGInventory*> (Size: 0x10)
SGWeaponAttachmentComponent.EmptyHandAttachment = 0x128 // SGInventory* (Size: 0x8)
SGWeaponAttachmentComponent.TimerHandler = 0x130 // FTimerHandle (Size: 0x8)
SGWeaponAttachmentComponent.TimerInterval = 0x138 // float (Size: 0x4)
SGWeaponAttachmentComponent.WeaponRepInfoList = 0x140 // TArray<FSGWeaponRepInfo> (Size: 0x10)
SGWeaponAttachmentComponent.DisplayDistanceFor3PRepHitInfo = 0x150 // float (Size: 0x4)
SGWeaponAttachmentComponent.MaxReplicatedHitInfoInOneFrame = 0x154 // int32_t (Size: 0x4)
SGWeaponAttachmentComponent.ProcessdRepMaxCount = 0x168 // int32_t (Size: 0x4)
SGWeaponAttributeSet.WeaponTestAttribute = 0x48 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.RecoilAccuracyForAdapter_Vertical_Scale = 0x58 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.RecoilAccuracyForAdapter_Horizental_Scale = 0x68 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.RecoilAccuracyForAdapter_Vertical_Value = 0x78 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.RecoilAccuracyForAdapter_Horizental_Value = 0x88 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.WeaponReloadForAdapter_Ratio = 0x98 // FGameplayAttributeData (Size: 0x10)
SGWeaponAttributeSet.WeaponStability = 0xa8 // FGameplayAttributeData (Size: 0x10)
SGWeaponBoreComponent.bOpenBolt = 0x138 // bool (Size: 0x1)
SGWeaponBoreComponent.bCanFillAmmoOneByOne = 0x139 // bool (Size: 0x1)
SGWeaponBoreComponent.bNeedOpenBoltBeforeReloading = 0x13a // bool (Size: 0x1)
SGWeaponBoreComponent.bPullBoltOnStopFireCmd = 0x13b // bool (Size: 0x1)
SGWeaponBoreComponent.bPumpAction = 0x13c // bool (Size: 0x1)
SGWeaponBoreComponent.bFillAmmoOnOpenBolt = 0x13d // bool (Size: 0x1)
SGWeaponBoreComponent.bLastRoundHoldOpen = 0x13e // bool (Size: 0x1)
SGWeaponBoreComponent.ReentryTimeAfterFireEvent = 0x140 // float (Size: 0x4)
SGWeaponBoreComponent.ChargeTimeAfterPullBolt = 0x144 // float (Size: 0x4)
SGWeaponBoreComponent.ReentryTimeAfterOpenByHandEvent = 0x148 // float (Size: 0x4)
SGWeaponBoreComponent.bNeedRemoveMagBeforeCheckBore = 0x14c // bool (Size: 0x1)
SGWeaponBoreComponent.bClearShellOnShot = 0x14d // bool (Size: 0x1)
SGWeaponBoreComponent.BoltMeshCloseAfterOpenTime = 0x150 // float (Size: 0x4)
SGWeaponBoreComponent.CurShotBulletClass = 0x158 // ClassProperty (Size: 0x8)
SGWeaponBoreComponent.ShellCacheNum = 0x160 // int32_t (Size: 0x4)
SGWeaponBoreComponent.CachedFillingBullet = 0x188 // SGInventory* (Size: 0x8)
SGWeaponBoreComponent.BoreCheckState = 0x190 // EESGMagazineCheckState (Size: 0x1)
SGWeaponBoreComponent.BoreCheckCharacter = 0x198 // Character* (Size: 0x8)
SGWeaponBoreComponent.BulletName = 0x1a0 // FString (Size: 0x10)
SGWeaponBoreComponent.MaxBoreNum = 0x1b0 // int32_t (Size: 0x4)
SGWeaponBoreComponent.bBoreLoop = 0x1b4 // bool (Size: 0x1)
SGWeaponBoreComponent.DefaultBulletClass = 0x1b8 // TArray<ClassProperty> (Size: 0x10)
SGWeaponBoreComponent.bBoresPumpFromMag = 0x1c8 // bool (Size: 0x1)
SGWeaponBoreComponent.CaliberClass = 0x1d0 // ClassProperty (Size: 0x8)
SGWeaponBoreComponent.bForbiddenFireOnFoldStock = 0x1d8 // bool (Size: 0x1)
SGWeaponBoreComponent.bForbiddenPullBoltOnFoldStock = 0x1d9 // bool (Size: 0x1)
SGWeaponBoreComponent.bForbiddenReloadOnFoldStock = 0x1da // bool (Size: 0x1)
SGWeaponBoreComponent.bSingleAction = 0x1db // bool (Size: 0x1)
SGWeaponBoreComponent.bWeaponCylinderRotateClockwiseWhenFire = 0x1dc // bool (Size: 0x1)
SGWeaponBoreComponent.bCanReloadBoresOneByOne = 0x1dd // bool (Size: 0x1)
SGWeaponBoreComponent.PickupPullBoltTimeout = 0x1e0 // float (Size: 0x4)
SGWeaponBoreComponent.CachedAssembleComponent = 0x1e8 // SGInventoryAssembleComponent* (Size: 0x8)
SGWeaponBoreComponent.BoreList = 0x1f0 // TArray<FBoreInfo> (Size: 0x10)
SGWeaponBoreComponent.BoreListForRep = 0x200 // TArray<FBoreInfo> (Size: 0x10)
SGWeaponBoreComponent.ClientBoreList = 0x210 // TArray<FBoreInfo> (Size: 0x10)
SGWeaponBoreComponent.BulletClass = 0x220 // ClassProperty (Size: 0x8)
SGWeaponBoreComponent.BulletFromPlayerInfo = 0x228 // FStackableItemSourceInfo (Size: 0x18)
SGWeaponBoreComponent.BulletClassForRep = 0x240 // ClassProperty (Size: 0x8)
SGWeaponBoreComponent.bHolding = 0x248 // bool (Size: 0x1)
SGWeaponBoreComponent.bHoldingBolt = 0x249 // bool (Size: 0x1)
SGWeaponBoreComponent.bIsHammerReady = 0x24a // bool (Size: 0x1)
SGWeaponBoreComponent.TimerHandle = 0x250 // FTimerHandle (Size: 0x8)
SGWeaponBoreComponent.BoltOpenTimerHandle = 0x258 // FTimerHandle (Size: 0x8)
SGWeaponBoreComponent.HoldOpenTimerHandle = 0x260 // FTimerHandle (Size: 0x8)
SGWeaponBoreComponent.BoresPumpDelay = 0x29c // float (Size: 0x4)
SGWeaponBoreComponent.BoresPumpTimerHandle = 0x2a0 // FTimerHandle (Size: 0x8)
SGWeaponCameraComponent.bEnableCameraShake = 0x348 // bool (Size: 0x1)
SGWeaponCameraComponent.ShotCameraShake = 0x350 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.ShotCameraShakeFirstShot = 0x358 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.ShotCameraShakeIronsight = 0x360 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.ShotCameraShakeIronsightFirstShot = 0x368 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.ShotCameraShakeADS = 0x370 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.ShotCameraShakeADSFirstShot = 0x378 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.CameraShakeScale = 0x380 // float (Size: 0x4)
SGWeaponCameraComponent.FOVToCameraShakeScaleCurve = 0x388 // CurveFloat* (Size: 0x8)
SGWeaponCameraComponent.RecoilToCameraShakeScaleCurve = 0x390 // CurveFloat* (Size: 0x8)
SGWeaponCameraComponent.TakeHitCameraShakeADS = 0x398 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.TakeHitCameraShake = 0x3a0 // ClassProperty (Size: 0x8)
SGWeaponCameraComponent.CrosshairDisplayHandler = 0x3b0 // FTimerHandle (Size: 0x8)
SGWeaponCameraParams.CameraRecoilExpandTime = 0x0 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilRecoverTime = 0x4 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilBase = 0x8 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilModifier = 0xc // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilMax = 0x10 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilZoomInitSpeed = 0x14 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilZoomDampingRate = 0x18 // float (Size: 0x4)
SGWeaponCameraParams.CameraRecoilZoomFrictionRate = 0x1c // float (Size: 0x4)
SGWeaponCameraParams.CameraStretchMin = 0x20 // float (Size: 0x4)
SGWeaponCameraParams.CameraStretchMax = 0x24 // float (Size: 0x4)
SGWeaponCameraParams.CameraStretchMin_FPP = 0x28 // float (Size: 0x4)
SGWeaponCameraParams.CameraStretchMax_FPP = 0x2c // float (Size: 0x4)
SGWeaponCaptureSizeTableRow.ID = 0x8 // uint64_t (Size: 0x8)
SGWeaponCaptureSizeTableRow.Column = 0x10 // int32_t (Size: 0x4)
SGWeaponCaptureSizeTableRow.Row = 0x14 // int32_t (Size: 0x4)
SGWeaponCaptureSizeTableRow.Width = 0x18 // float (Size: 0x4)
SGWeaponCaptureSizeTableRow.Height = 0x1c // float (Size: 0x4)
SGWeaponCaptureSizeTableRow.ColumnWidthRatio = 0x20 // float (Size: 0x4)
SGWeaponCaptureSizeTableRow.RowHeightRatio = 0x24 // float (Size: 0x4)
SGWeaponChangedInfo.DestWeapon = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
SGWeaponChangedInfo.LastWeapon = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
SGWeaponChangedInfo.CharacterMontageParams = 0x10 // FSGMontagePlayParams (Size: 0x48)
SGWeaponChangedInfo.WeaponMontageParams = 0x58 // FSGMontagePlayParams (Size: 0x48)
SGWeaponChangedInfo.BlendOutTime = 0xa0 // float (Size: 0x4)
SGWeaponChangedInfo.BlendInTime = 0xa4 // float (Size: 0x4)
SGWeaponChangedInfo.PlayMontageFirst = 0xa8 // bool (Size: 0x1)
SGWeaponChangedInfo.bDisableBlendIn = 0xa9 // bool (Size: 0x1)
SGWeaponChangedInfo.bDisableBlendOut = 0xaa // bool (Size: 0x1)
SGWeaponChangedInfo.bUseTacticalTrans = 0xab // bool (Size: 0x1)
SGWeaponContainerComponent.CaliberClass = 0x100 // ClassProperty (Size: 0x8)
SGWeaponContainerComponent.DefaultBulletClass = 0x108 // ClassProperty (Size: 0x8)
SGWeaponContainerComponent.BulletClassFilledWhenBeginPlay = 0x110 // TArray<FBulletContainerInfo> (Size: 0x10)
SGWeaponContainerComponent.MaxStackCount = 0x120 // int32_t (Size: 0x4)
SGWeaponContainerComponent.bFillOneByOne = 0x124 // bool (Size: 0x1)
SGWeaponContainerComponent.FillOneByOneCountPerLoop = 0x128 // int32_t (Size: 0x4)
SGWeaponContainerComponent.bNeedAmmoInBeforeReloading = 0x12c // bool (Size: 0x1)
SGWeaponContainerComponent.bAlwaysShowBullets = 0x12d // bool (Size: 0x1)
SGWeaponContainerComponent.ShowBulletNum = 0x130 // int32_t (Size: 0x4)
SGWeaponContainerComponent.FillContainerBasicTime = 0x134 // float (Size: 0x4)
SGWeaponContainerComponent.FillMagazineTimeDefaultPerBullet = 0x138 // float (Size: 0x4)
SGWeaponContainerComponent.FillMagazineTimeInBagPerBullet = 0x13c // float (Size: 0x4)
SGWeaponContainerComponent.FillMagazineTimeInVestBagPerBullet = 0x140 // float (Size: 0x4)
SGWeaponContainerComponent.FillMagazineTimeInGunPerBullet = 0x144 // float (Size: 0x4)
SGWeaponContainerComponent.UnfillContainerBasicTime = 0x148 // float (Size: 0x4)
SGWeaponContainerComponent.UnfillMagazineTimeDefaultPerBullet = 0x14c // float (Size: 0x4)
SGWeaponContainerComponent.UnfillMagazineTimeInBagPerBullet = 0x150 // float (Size: 0x4)
SGWeaponContainerComponent.UnfillMagazineTimeInVestBagPerBullet = 0x154 // float (Size: 0x4)
SGWeaponContainerComponent.UnfillMagazineTimeInGunPerBullet = 0x158 // float (Size: 0x4)
SGWeaponContainerComponent.BulletSockets = 0x160 // TArray<FBulletMeshInfo> (Size: 0x10)
SGWeaponContainerComponent.FillMagazineMontage = 0x170 // FSoftObjectPath (Size: 0x18)
SGWeaponContainerComponent.UnfillMagazineMontage = 0x188 // FSoftObjectPath (Size: 0x18)
SGWeaponContainerComponent.FillMagazineAnimInstance = 0x1a0 // ClassProperty (Size: 0x8)
SGWeaponContainerComponent.SkinIDToFillAnimSet = 0x1a8 // TMap<...> (Size: 0x50)
SGWeaponContainerComponent.bBelt = 0x1f8 // bool (Size: 0x1)
SGWeaponContainerComponent.CheckRangeMin = 0x1fc // int32_t (Size: 0x4)
SGWeaponContainerComponent.CheckRangeMax = 0x200 // int32_t (Size: 0x4)
SGWeaponContainerComponent.ContainDataList = 0x208 // TArray<FBulletContainerInfo> (Size: 0x10)
SGWeaponContainerComponent.ContainDataListForRep = 0x218 // TArray<FBulletContainerInfo> (Size: 0x10)
SGWeaponContainerComponent.MagazineCheckState = 0x230 // EESGMagazineCheckState (Size: 0x1)
SGWeaponContainerComponent.ShowBulletWhenSpectated = 0x231 // bool (Size: 0x1)
SGWeaponContainerComponent.bInBagState = 0x232 // bool (Size: 0x1)
SGWeaponContainerComponent.MagazineCheckCharacter = 0x238 // Character* (Size: 0x8)
SGWeaponContainerComponent.BulletClassFindMap = 0x268 // TMap<...> (Size: 0x50)
SGWeaponContainerComponent.BulletClassCacheMap = 0x2b8 // TMap<...> (Size: 0x50)
SGWeaponContainerComponent.BulletSourceInfos = 0x308 // TArray<FStackableItemSourceInfo> (Size: 0x10)
SGWeaponContainerComponent.CheckMagazineTimeInBag = 0x328 // float (Size: 0x4)
SGWeaponContainerComponent.FillRateAnimation = 0x330 // FSoftObjectPath (Size: 0x18)
SGWeaponCrosshairComponent.bCentralDotVisible = 0x100 // bool (Size: 0x1)
SGWeaponCrosshairComponent.CrosshairStyleWidgetClass = 0x108 // ClassProperty (Size: 0x8)
SGWeaponCrosshairComponent.OverriddenCrosshairStyleWidgetClass = 0x110 // ClassProperty (Size: 0x8)
SGWeaponCrosshairComponent.CrosshairExpandRatio = 0x118 // float (Size: 0x4)
SGWeaponDamageComponent.WeapDamageParams = 0x100 // TArray<FWeaponDamageInfo> (Size: 0x10)
SGWeaponDamageComponent.MeleeBaseDamage = 0x110 // TArray<float> (Size: 0x10)
SGWeaponDamageComponent.MeleeArmorDamage = 0x120 // float (Size: 0x4)
SGWeaponDamageComponent.MeleeDamageReductionArray = 0x128 // TArray<float> (Size: 0x10)
SGWeaponDamageComponent.MeleeArmorDamageRatio = 0x138 // float (Size: 0x4)
SGWeaponDamageComponent.MeleeBleedTriggerChance = 0x13c // float (Size: 0x4)
SGWeaponDamageComponent.MeleeTraceRange = 0x140 // TArray<float> (Size: 0x10)
SGWeaponDamageComponent.MeleeDamageScaleHead = 0x150 // float (Size: 0x4)
SGWeaponDamageComponent.MeleeDamageScaleArms = 0x154 // float (Size: 0x4)
SGWeaponDamageComponent.MeleeDamageScaleLegs = 0x158 // float (Size: 0x4)
SGWeaponDamageComponent.MeleeDamageScaleStomach = 0x15c // float (Size: 0x4)
SGWeaponDamageComponent.MeleeDamageScaleChest = 0x160 // float (Size: 0x4)
SGWeaponDamageComponent.EnergyReduceAbilityByMeleeAtk = 0x168 // ClassProperty (Size: 0x8)
SGWeaponDamageComponent.MeleeAtkEnergyConsume = 0x170 // float (Size: 0x4)
SGWeaponDamagePhysActor.Damage = 0x310 // float (Size: 0x4)
SGWeaponDamagePhysActor.HitNormal = 0x314 // FVector (Size: 0xc)
SGWeaponDamagePhysActor.DamageLevel = 0x320 // int32_t (Size: 0x4)
SGWeaponDataAsset.bDrawWeaponDir = 0x2e0 // bool (Size: 0x1)
SGWeaponDataAsset.bAllowAutoChangeMagazineNative = 0x2e1 // bool (Size: 0x1)
SGWeaponDataAsset.WeaponAmmoCost = 0x2e4 // int32_t (Size: 0x4)
SGWeaponDataAsset.ClipAmmoCount = 0x2e8 // int32_t (Size: 0x4)
SGWeaponDataAsset.AmmoGravityScale = 0x2ec // float (Size: 0x4)
SGWeaponDataAsset.AmmoResistanceFactorScale = 0x2f0 // float (Size: 0x4)
SGWeaponDataAsset.bImmediateOrDefferLoadAnimationSet_InGame = 0x2f4 // bool (Size: 0x1)
SGWeaponDataAsset.bImmediateOrDefferLoadAnimationSet_Lobby = 0x2f5 // bool (Size: 0x1)
SGWeaponDataAsset.CharacterAnimationSetsClass = 0x2f8 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.PerWeaponAnimationSetsClass = 0x320 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.LeftArmOffset = 0x348 // FVector (Size: 0xc)
SGWeaponDataAsset.WeaponSwaySpringInfo = 0x354 // FSGWeaponSwaySpringInfo (Size: 0x24)
SGWeaponDataAsset.WeaponOriginBoneName = 0x378 // FName (Size: 0x8)
SGWeaponDataAsset.WeaponGripBoneName = 0x380 // FName (Size: 0x8)
SGWeaponDataAsset.BaseForeGrips = 0x388 // TArray<AnimSequence*> (Size: 0x10)
SGWeaponDataAsset.BaseForeCharacterGrips = 0x398 // TSet<...> (Size: 0x50)
SGWeaponDataAsset.DetachMeshTimePercent = 0x3e8 // float (Size: 0x4)
SGWeaponDataAsset.AttachMeshTimePercent = 0x3ec // float (Size: 0x4)
SGWeaponDataAsset.ForceAttachIndex = 0x3f0 // int32_t (Size: 0x4)
SGWeaponDataAsset.BackWeaponAttachTransform = 0x400 // FTransform (Size: 0x30)
SGWeaponDataAsset.HandWeaponOffset = 0x430 // FVector (Size: 0xc)
SGWeaponDataAsset.RightHandWeaponOffsetWhenSprint = 0x440 // FTransform (Size: 0x30)
SGWeaponDataAsset.WeaponBackAttachCustomSocket = 0x470 // FName (Size: 0x8)
SGWeaponDataAsset.WeaponBackAttachType = 0x478 // EESGBackWeaponAttachType (Size: 0x1)
SGWeaponDataAsset.MeshAttachCharacterSocket = 0x47c // FName (Size: 0x8)
SGWeaponDataAsset.MeshAttachCharacterSocket_Left = 0x484 // FName (Size: 0x8)
SGWeaponDataAsset.MeshAttachCharacterSocket_Hang = 0x48c // FName (Size: 0x8)
SGWeaponDataAsset.MeshAttachCharacterSocket_FPP = 0x494 // FName (Size: 0x8)
SGWeaponDataAsset.bHangToBackWhenDetach = 0x49c // bool (Size: 0x1)
SGWeaponDataAsset.SimpleMeshAttachSocketName = 0x4a0 // FName (Size: 0x8)
SGWeaponDataAsset.BackWeaponLeftAttachOffsetInLobby = 0x4a8 // FVector (Size: 0xc)
SGWeaponDataAsset.HideOnBack = 0x4b4 // bool (Size: 0x1)
SGWeaponDataAsset.FPFireTemplate = 0x4b8 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.TPFireTemplate = 0x508 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.FogTemplate = 0x558 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.FireLightTemplate = 0x5a8 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.IntensityOfFireLight = 0x5f8 // float (Size: 0x4)
SGWeaponDataAsset.FireLightSize = 0x5fc // float (Size: 0x4)
SGWeaponDataAsset.FireLightTemplate_LDR = 0x600 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.IntensityColorOfFireLight_LDR = 0x650 // FVector (Size: 0xc)
SGWeaponDataAsset.FireLightSize_LDR = 0x65c // FVector (Size: 0xc)
SGWeaponDataAsset.FireLightTemplate3P = 0x668 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.IntensityOfFireLight3P = 0x6b8 // float (Size: 0x4)
SGWeaponDataAsset.FireLightSize3P = 0x6bc // float (Size: 0x4)
SGWeaponDataAsset.FireLightTemplate3P_LDR = 0x6c0 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.IntensityColorOfFireLight3P_LDR = 0x710 // FVector (Size: 0xc)
SGWeaponDataAsset.FireLightSize3P_LDR = 0x71c // FVector (Size: 0xc)
SGWeaponDataAsset.FPMergeFireHDRTemplate = 0x728 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.FPMergeFireLDRTemplate = 0x778 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.TPMergeFireHDRTemplate = 0x7c8 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.TPMergeFireLDRTemplate = 0x818 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.AliveShotFireEffectNum = 0x868 // int32_t (Size: 0x4)
SGWeaponDataAsset.AliveShotFogEffectNum = 0x86c // int32_t (Size: 0x4)
SGWeaponDataAsset.AliveMergedEffectNum = 0x870 // int32_t (Size: 0x4)
SGWeaponDataAsset.AliveBulletShellEffectNum = 0x874 // int32_t (Size: 0x4)
SGWeaponDataAsset.LastRenderTimeNotPlayEffect = 0x878 // float (Size: 0x4)
SGWeaponDataAsset.BulletTraceParticleLiveCountMax = 0x87c // int32_t (Size: 0x4)
SGWeaponDataAsset.ShellTemplate = 0x880 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.SmokeTemplate = 0x8d0 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.SmokeEffectContinuousCount = 0x920 // int32_t (Size: 0x4)
SGWeaponDataAsset.FogOpacityDecSpeed = 0x924 // float (Size: 0x4)
SGWeaponDataAsset.MuzzleSocket = 0x928 // FName (Size: 0x8)
SGWeaponDataAsset.AdapterMuzzleSocket = 0x930 // FName (Size: 0x8)
SGWeaponDataAsset.BlastingFuseTemplate = 0x938 // FEffectParticleInfo (Size: 0x50)
SGWeaponDataAsset.bEnableDebug = 0x988 // bool (Size: 0x1)
SGWeaponDataAsset.AttachHandSocketName = 0x98c // FName (Size: 0x8)
SGWeaponDataAsset.MagazineSocketName = 0x994 // FName (Size: 0x8)
SGWeaponDataAsset.WeaponWidth = 0x99c // int32_t (Size: 0x4)
SGWeaponDataAsset.WeaponHeight = 0x9a0 // int32_t (Size: 0x4)
SGWeaponDataAsset.ErrorIronSightXAngle = 0x9a4 // float (Size: 0x4)
SGWeaponDataAsset.ErrorIronSightYAngle = 0x9a8 // float (Size: 0x4)
SGWeaponDataAsset.FireRequireTagList = 0x9b0 // FGameplayTagContainer (Size: 0x20)
SGWeaponDataAsset.EnableIllegaSight = 0x9d0 // bool (Size: 0x1)
SGWeaponDataAsset.BipCheckSocketName = 0x9d4 // FName (Size: 0x8)
SGWeaponDataAsset.BipCheckVec = 0x9dc // FVector (Size: 0xc)
SGWeaponDataAsset.bOpenBolt = 0x9e8 // bool (Size: 0x1)
SGWeaponDataAsset.bCanFillAmmoOneByOne = 0x9e9 // bool (Size: 0x1)
SGWeaponDataAsset.bNeedOpenBoltBeforeReloading = 0x9ea // bool (Size: 0x1)
SGWeaponDataAsset.bPullBoltOnStopFireCmd = 0x9eb // bool (Size: 0x1)
SGWeaponDataAsset.bFillAmmoOnOpenBolt = 0x9ec // bool (Size: 0x1)
SGWeaponDataAsset.bLastRoundHoldOpen = 0x9ed // bool (Size: 0x1)
SGWeaponDataAsset.ReentryTimeAfterFireEvent = 0x9f0 // float (Size: 0x4)
SGWeaponDataAsset.ChargeTimeAfterPullBolt = 0x9f4 // float (Size: 0x4)
SGWeaponDataAsset.ReentryTimeAfterOpenByHandEvent = 0x9f8 // float (Size: 0x4)
SGWeaponDataAsset.bNeedRemoveMagBeforeCheckBore = 0x9fc // bool (Size: 0x1)
SGWeaponDataAsset.bClearShellOnShot = 0x9fd // bool (Size: 0x1)
SGWeaponDataAsset.BoltMeshCloseAfterOpenTime = 0xa00 // float (Size: 0x4)
SGWeaponDataAsset.MaxBoreNum = 0xa04 // int32_t (Size: 0x4)
SGWeaponDataAsset.bBoreLoop = 0xa08 // bool (Size: 0x1)
SGWeaponDataAsset.DefaultBulletClass = 0xa10 // TArray<ClassProperty> (Size: 0x10)
SGWeaponDataAsset.CaliberClass = 0xa20 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.bForbiddenFireOnFoldStock = 0xa28 // bool (Size: 0x1)
SGWeaponDataAsset.bForbiddenPullBoltOnFoldStock = 0xa29 // bool (Size: 0x1)
SGWeaponDataAsset.bForbiddenReloadOnFoldStock = 0xa2a // bool (Size: 0x1)
SGWeaponDataAsset.TimerInterval = 0xa2c // float (Size: 0x4)
SGWeaponDataAsset.bEnableCameraShake = 0xa30 // bool (Size: 0x1)
SGWeaponDataAsset.ShotCameraShake = 0xa38 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ShotCameraShakeFirstShot = 0xa40 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ShotCameraShakeIronsight = 0xa48 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ShotCameraShakeIronsightFirstShot = 0xa50 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ShotCameraShakeADS = 0xa58 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ShotCameraShakeADSFirstShot = 0xa60 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.CameraShakeScale = 0xa68 // float (Size: 0x4)
SGWeaponDataAsset.FOVToCameraShakeScaleCurve = 0xa70 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.RecoilToCameraShakeScaleCurve = 0xa78 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.TakeHitCameraShakeADS = 0xa80 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.TakeHitCameraShake = 0xa88 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.SubCameraInfoList = 0xa90 // TArray<FSubCameraInfo> (Size: 0x10)
SGWeaponDataAsset.SubMagnificationInfoList = 0xaa0 // TArray<FSubCameraInfo> (Size: 0x10)
SGWeaponDataAsset.SightPriority = 0xab0 // int32_t (Size: 0x4)
SGWeaponDataAsset.ScopeLevel = 0xab4 // int32_t (Size: 0x4)
SGWeaponDataAsset.ZoomingSensitivity = 0xab8 // float (Size: 0x4)
SGWeaponDataAsset.ShoulderZoomingSensitivity = 0xabc // float (Size: 0x4)
SGWeaponDataAsset.BlurRadius = 0xac0 // float (Size: 0x4)
SGWeaponDataAsset.BlurThresHold = 0xac4 // float (Size: 0x4)
SGWeaponDataAsset.FiringZoomInVector = 0xac8 // FVector (Size: 0xc)
SGWeaponDataAsset.NormalFireSensitivity = 0xad4 // float (Size: 0x4)
SGWeaponDataAsset.FiringAnimTranslationWeight = 0xad8 // float (Size: 0x4)
SGWeaponDataAsset.FiringAnimRotationWeight = 0xadc // float (Size: 0x4)
SGWeaponDataAsset.ADSGunKickWeight = 0xae0 // float (Size: 0x4)
SGWeaponDataAsset.AimingBase = 0xae4 // FName (Size: 0x8)
SGWeaponDataAsset.AimingPivotSocket = 0xaec // FName (Size: 0x8)
SGWeaponDataAsset.SwitchAnim = 0xaf4 // EEAdapterAnimationType (Size: 0x1)
SGWeaponDataAsset.ZoomFOV = 0xaf8 // float (Size: 0x4)
SGWeaponDataAsset.HoldingBreathZoomFOV = 0xafc // float (Size: 0x4)
SGWeaponDataAsset.DefaultCameraGunKickWeight = 0xb00 // float (Size: 0x4)
SGWeaponDataAsset.bIsThermalScope = 0xb04 // bool (Size: 0x1)
SGWeaponDataAsset.bShouldForceRebaseOrigin = 0xb05 // bool (Size: 0x1)
SGWeaponDataAsset.SuspendThermalScopeTags = 0xb08 // FGameplayTagContainer (Size: 0x20)
SGWeaponDataAsset.SuspendThermalScopeTimeInProneTransition = 0xb28 // float (Size: 0x4)
SGWeaponDataAsset.WeapDamageParams = 0xb30 // TArray<FWeaponDamageInfo> (Size: 0x10)
SGWeaponDataAsset.MeleeBaseDamage = 0xb40 // TArray<float> (Size: 0x10)
SGWeaponDataAsset.MeleeArmorDamage = 0xb50 // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageReductionArray = 0xb58 // TArray<float> (Size: 0x10)
SGWeaponDataAsset.MeleeArmorDamageRatio = 0xb68 // float (Size: 0x4)
SGWeaponDataAsset.MeleeBleedTriggerChance = 0xb6c // float (Size: 0x4)
SGWeaponDataAsset.MeleeTraceRange = 0xb70 // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageScaleHead = 0xb74 // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageScaleArms = 0xb78 // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageScaleLegs = 0xb7c // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageScaleStomach = 0xb80 // float (Size: 0x4)
SGWeaponDataAsset.MeleeDamageScaleChest = 0xb84 // float (Size: 0x4)
SGWeaponDataAsset.EnergyReduceAbilityByMeleeAtk = 0xb88 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.JumpFireInterval = 0xb90 // float (Size: 0x4)
SGWeaponDataAsset.ContinuousFirePersistTime = 0xb94 // float (Size: 0x4)
SGWeaponDataAsset.ContinuousFireInterval = 0xb98 // float (Size: 0x4)
SGWeaponDataAsset.FireIntervalCurveList = 0xba0 // TArray<CurveFloat*> (Size: 0x10)
SGWeaponDataAsset.FireAnimTime = 0xbb0 // float (Size: 0x4)
SGWeaponDataAsset.FireAnimBlendOutTime = 0xbb4 // float (Size: 0x4)
SGWeaponDataAsset.SupportFireModeList = 0xbb8 // TArray<ClassProperty> (Size: 0x10)
SGWeaponDataAsset.PreFireTime = 0xbc8 // float (Size: 0x4)
SGWeaponDataAsset.EndPreFireTime = 0xbcc // float (Size: 0x4)
SGWeaponDataAsset.KeepPreFireTime = 0xbd0 // float (Size: 0x4)
SGWeaponDataAsset.DelaySpawnProjectileTimeForThrowDown = 0xbd4 // float (Size: 0x4)
SGWeaponDataAsset.DelaySpawnProjectileTimeForThrowUp = 0xbd8 // float (Size: 0x4)
SGWeaponDataAsset.DelaySpawnProjectileTimeForFastThrow = 0xbdc // float (Size: 0x4)
SGWeaponDataAsset.DelayHideWeaponTime = 0xbe0 // float (Size: 0x4)
SGWeaponDataAsset.CoolDownTimeAfterFire = 0xbe4 // float (Size: 0x4)
SGWeaponDataAsset.bEndZoomWhenStopFire = 0xbe8 // bool (Size: 0x1)
SGWeaponDataAsset.bEndAndRestoreZoomWhenStopFire = 0xbe9 // bool (Size: 0x1)
SGWeaponDataAsset.DirectFlyDistance = 0xbec // float (Size: 0x4)
SGWeaponDataAsset.bGrenadeCanHold = 0xbf0 // bool (Size: 0x1)
SGWeaponDataAsset.FlyVelocityToDistanceCurve = 0xbf8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.SpecializedFlyVelocityToDistanceCurveMap = 0xc00 // TMap<...> (Size: 0x50)
SGWeaponDataAsset.EnableFireRequestCacheDelay = 0xc50 // float (Size: 0x4)
SGWeaponDataAsset.DamageScaleCurve = 0xc58 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.DefaultPenetration = 0xc60 // float (Size: 0x4)
SGWeaponDataAsset.Radius = 0xc64 // float (Size: 0x4)
SGWeaponDataAsset.SupportShootingMode = 0xc68 // TArray<EESGWeaponShootingMode> (Size: 0x10)
SGWeaponDataAsset.MaxBurstShotCount = 0xc78 // int32_t (Size: 0x4)
SGWeaponDataAsset.bSupportAimAssist = 0xc7c // bool (Size: 0x1)
SGWeaponDataAsset.ControlledWeaponClass = 0xc80 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.ControllerWeaponClass = 0xc88 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.BulletTrajectoryType = 0xc90 // FName (Size: 0x8)
SGWeaponDataAsset.ZoomSupportCheckHeight = 0xc98 // float (Size: 0x4)
SGWeaponDataAsset.ShootAimingDelayEnterTime = 0xc9c // float (Size: 0x4)
SGWeaponDataAsset.ShootAimingFOV = 0xca0 // float (Size: 0x4)
SGWeaponDataAsset.MeleeWeaponPhaseNumber = 0xca4 // int32_t (Size: 0x4)
SGWeaponDataAsset.MeleeWeaponCurPhase = 0xca8 // int32_t (Size: 0x4)
SGWeaponDataAsset.CrosshairAccuracyRatios = 0xcac // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.ProjectileClass = 0xce0 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.ProjectileInitSpeed = 0xd08 // float (Size: 0x4)
SGWeaponDataAsset.ProjectileGravityZeroDistance = 0xd0c // float (Size: 0x4)
SGWeaponDataAsset.ProjectileHorizontalVelocityDecRate = 0xd10 // float (Size: 0x4)
SGWeaponDataAsset.ProjectileZeroHorizontalVelocityDecDistance = 0xd14 // float (Size: 0x4)
SGWeaponDataAsset.JudgeFireEndTime = 0xd18 // float (Size: 0x4)
SGWeaponDataAsset.WeaponZoomingMovingScale = 0xd1c // float (Size: 0x4)
SGWeaponDataAsset.WeaponShoulderZoomMovingScale = 0xd20 // float (Size: 0x4)
SGWeaponDataAsset.WeaponChangeClipMovingScale = 0xd24 // float (Size: 0x4)
SGWeaponDataAsset.WeaponShootingMovingScale = 0xd28 // float (Size: 0x4)
SGWeaponDataAsset.ADSMoveSpeedRatioByWeaponAccessory = 0xd2c // float (Size: 0x4)
SGWeaponDataAsset.MoveSpeedRatioByWeaponAccessory = 0xd30 // float (Size: 0x4)
SGWeaponDataAsset.MoveSpeedRatioByMeleeWeapon = 0xd34 // float (Size: 0x4)
SGWeaponDataAsset.SpreadShowScale = 0xd38 // float (Size: 0x4)
SGWeaponDataAsset.NormalShotSpreadRatio = 0xd3c // float (Size: 0x4)
SGWeaponDataAsset.SpreadInterpSpeed = 0xd40 // float (Size: 0x4)
SGWeaponDataAsset.SpreadParams = 0xd44 // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponDataAsset.SpreadParams_ShoulderZoom = 0xd6c // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponDataAsset.SpreadRadiusPDF = 0xd98 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.SpreadAnglePDF = 0xda0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.SpreadRadiusScaleCurve = 0xda8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.SpreadScaleForArmBreak = 0xdb0 // float (Size: 0x4)
SGWeaponDataAsset.BuckshotSpreadParams = 0xdb4 // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponDataAsset.BuckshotSpreadRadiusPDF = 0xde0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.BuckshotSpreadAnglePDF = 0xde8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.InnerRadiusScaleWhenMultiShots = 0xdf0 // float (Size: 0x4)
SGWeaponDataAsset.OutterRadiusScaleWhenMultiShots = 0xdf4 // float (Size: 0x4)
SGWeaponDataAsset.ShotNumInInnerRadiusPercent = 0xdf8 // float (Size: 0x4)
SGWeaponDataAsset.SpreadToGunRotScale = 0xdfc // float (Size: 0x4)
SGWeaponDataAsset.AccuracyValue = 0xe00 // float (Size: 0x4)
SGWeaponDataAsset.AccuracyValue_Multiplier = 0xe04 // float (Size: 0x4)
SGWeaponDataAsset.AccToSpreadScaleCurve = 0xe08 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.ShootAimingSpreadValue = 0xe10 // float (Size: 0x4)
SGWeaponDataAsset.SpreadAccuracyRatios = 0xe14 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.SpreadAccuracyRatios_ShoulderZoom = 0xe44 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.MaxSpreadGunRotValue = 0xe74 // float (Size: 0x4)
SGWeaponDataAsset.GunRotSpeed = 0xe78 // float (Size: 0x4)
SGWeaponDataAsset.AdsMoaX = 0xe7c // float (Size: 0x4)
SGWeaponDataAsset.AdsMoaY = 0xe80 // float (Size: 0x4)
SGWeaponDataAsset.AdapterMoaScaleX_Multiplier = 0xe84 // float (Size: 0x4)
SGWeaponDataAsset.AdapterMoaScaleY_Multiplier = 0xe88 // float (Size: 0x4)
SGWeaponDataAsset.MoaPDF = 0xe90 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.MoaScaleCurveByShootCount = 0xe98 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.MoaCurveForMultiShots = 0xea0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.MoaCurveForOneShot = 0xea8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.WeaponZoomTime = 0xeb0 // float (Size: 0x4)
SGWeaponDataAsset.WeaponUnZoomTime = 0xeb4 // float (Size: 0x4)
SGWeaponDataAsset.CameraBaseCharacterSocket = 0xeb8 // FName (Size: 0x8)
SGWeaponDataAsset.AimLimitPlaneSocketName = 0xec0 // FName (Size: 0x8)
SGWeaponDataAsset.bOnlyAdsOnSupport = 0xec8 // bool (Size: 0x1)
SGWeaponDataAsset.Curve_ZoominOffset = 0xed0 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.Curve_ZoominRotation = 0xed8 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.Curve_ZoomOutOffset = 0xee0 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.Curve_ZoomOutRotation = 0xee8 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.ZoomInAnimation_GripBased = 0xef0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.ZoomOutAnimation_GripBased = 0xf18 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.WeaponZoomAnimTime = 0xf40 // float (Size: 0x4)
SGWeaponDataAsset.WeaponUnZoomAnimTime = 0xf44 // float (Size: 0x4)
SGWeaponDataAsset.ZoomOffset_Location_3P = 0xf48 // FVector (Size: 0xc)
SGWeaponDataAsset.bEnableZoomFOVOptimization = 0xf54 // bool (Size: 0x1)
SGWeaponDataAsset.WeaponZoomFOVBlendTime = 0xf58 // float (Size: 0x4)
SGWeaponDataAsset.WeaponUnZoomFOVBlendTime = 0xf5c // float (Size: 0x4)
SGWeaponDataAsset.WeaponZoomFOVBlendDelay = 0xf60 // float (Size: 0x4)
SGWeaponDataAsset.WeaponUnZoomFOVBlendDelay = 0xf64 // float (Size: 0x4)
SGWeaponDataAsset.Curve_SwitchScope = 0xf68 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.SwitchScopeParams = 0xf70 // TArray<FWeaponSwitchScopeParams> (Size: 0x10)
SGWeaponDataAsset.MaxRecoilRotator = 0xf80 // FRotator (Size: 0xc)
SGWeaponDataAsset.RecoilPitchScale = 0xf8c // float (Size: 0x4)
SGWeaponDataAsset.RecoilYawScale = 0xf90 // float (Size: 0x4)
SGWeaponDataAsset.RecoilRollScale = 0xf94 // float (Size: 0x4)
SGWeaponDataAsset.GunRotSpeed_2 = 0xf98 // float (Size: 0x4)
SGWeaponDataAsset.ErgonomicsBase = 0xf9c // float (Size: 0x4)
SGWeaponDataAsset.ErgADSTimeScaleCurve = 0xfa0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.ErgEnergyCostScaleCurve = 0xfa8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.ErgBreathScaleCurve = 0xfb0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.bSupportShoulderZoom = 0xfb8 // bool (Size: 0x1)
SGWeaponDataAsset.ZoomingType = 0xfb9 // EESGZoomType (Size: 0x1)
SGWeaponDataAsset.AimScale = 0xfbc // float (Size: 0x4)
SGWeaponDataAsset.bCachedZoom = 0xfc0 // bool (Size: 0x1)
SGWeaponDataAsset.AfterFiringDelta = 0xfc4 // float (Size: 0x4)
SGWeaponDataAsset.bCanDrop = 0xfc8 // bool (Size: 0x1)
SGWeaponDataAsset.IsCanPickup = 0xfc9 // bool (Size: 0x1)
SGWeaponDataAsset.AttachSocketName = 0xfcc // FName (Size: 0x8)
SGWeaponDataAsset.SkeletalMeshTemplate_InGame = 0xfd8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.SkeletalMeshTemplate_InLobby = 0x1000 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.StaticMeshTemplate_InGame = 0x1028 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.StaticMeshTemplate_InLobby = 0x1050 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.SimpleMeshTemplate = 0x1078 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.SimpleMeshDefaultAnimInstance = 0x10a0 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.ProjectileMeshTemplate = 0x10c8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.InnerScopeBlurMaterial = 0x10f0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.ThermalScopeUnlitMaterial = 0x1118 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.ScopeMaterialElementIndex = 0x1140 // int32_t (Size: 0x4)
SGWeaponDataAsset.ThermalViewOpaqueMaterialElementIndex = 0x1144 // int32_t (Size: 0x4)
SGWeaponDataAsset.ThermalScopeUnlitMaterialElementIndex = 0x1148 // int32_t (Size: 0x4)
SGWeaponDataAsset.MeshTickPolicy = 0x114c // EEMeshTickPolicy (Size: 0x1)
SGWeaponDataAsset.bEnableMeshOptimization = 0x114d // bool (Size: 0x1)
SGWeaponDataAsset.bAdsLod0 = 0x114e // bool (Size: 0x1)
SGWeaponDataAsset.PickupTrans_2 = 0x1150 // FVector (Size: 0xc)
SGWeaponDataAsset.PickupRot_2 = 0x115c // FRotator (Size: 0xc)
SGWeaponDataAsset.bForceUseLobby = 0x1168 // bool (Size: 0x1)
SGWeaponDataAsset.PickUpMaterialColor_2 = 0x116c // FLinearColor (Size: 0x10)
SGWeaponDataAsset.FresnelColorName_2 = 0x117c // FName (Size: 0x8)
SGWeaponDataAsset.CustomIndex = 0x1184 // int8_t (Size: 0x1)
SGWeaponDataAsset.bWithZoomMatiral = 0x1185 // bool (Size: 0x1)
SGWeaponDataAsset.TurnOnZoomMatiralThreshold = 0x1188 // float (Size: 0x4)
SGWeaponDataAsset.LocalScopeParamAndRadius = 0x1190 // FVector4 (Size: 0x10)
SGWeaponDataAsset.ThermalViewInstanceEnabledName = 0x11a0 // FName (Size: 0x8)
SGWeaponDataAsset.ThermalScopeOpaqueOverrideName = 0x11a8 // FName (Size: 0x8)
SGWeaponDataAsset.SkeletalMeshAnimClass = 0x11b0 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponDataAsset.bUseComplexPickupMesh = 0x11d8 // bool (Size: 0x1)
SGWeaponDataAsset.bRemarkableAppearance = 0x11d9 // bool (Size: 0x1)
SGWeaponDataAsset.bEnableImpactEffects = 0x11da // bool (Size: 0x1)
SGWeaponDataAsset.ImpactEffectSkipDistance = 0x11dc // float (Size: 0x4)
SGWeaponDataAsset.MaxImpactEffectSkipTime = 0x11e0 // float (Size: 0x4)
SGWeaponDataAsset.MaxDistanceToPlayEffect = 0x11e4 // float (Size: 0x4)
SGWeaponDataAsset.ImpactMaterialAndAudioEventList = 0x11e8 // TArray<FImpactMaterialAndAudioEvent> (Size: 0x10)
SGWeaponDataAsset.MeleeRecoilRot = 0x11f8 // FRotator (Size: 0xc)
SGWeaponDataAsset.DecalRotationOffset = 0x1204 // FRotator (Size: 0xc)
SGWeaponDataAsset.MeleeRecoilTarRot = 0x1210 // FRotator (Size: 0xc)
SGWeaponDataAsset.MeleeRecoilAnimSpeed = 0x121c // float (Size: 0x4)
SGWeaponDataAsset.bEnableMeleeRecoil = 0x1220 // bool (Size: 0x1)
SGWeaponDataAsset.AliveImpactPSCNumConf = 0x1224 // int32_t (Size: 0x4)
SGWeaponDataAsset.FireIntervalCheckMaxTolerance = 0x1228 // float (Size: 0x4)
SGWeaponDataAsset.FireIntervalCheckFailPunishShots = 0x122c // int32_t (Size: 0x4)
SGWeaponDataAsset.FireIntervalCheckFailPunishDuration = 0x1230 // float (Size: 0x4)
SGWeaponDataAsset.AmmoCountCheckFailPunishShots = 0x1234 // int32_t (Size: 0x4)
SGWeaponDataAsset.MaxPlayerOwnerDistanceToleranceSq = 0x1238 // float (Size: 0x4)
SGWeaponDataAsset.MaxDriverDistanceToleranceSq = 0x123c // float (Size: 0x4)
SGWeaponDataAsset.MaxTargetDistanceToleranceSq = 0x1240 // float (Size: 0x4)
SGWeaponDataAsset.MaxHitPointDistanceToleranceSq = 0x1244 // float (Size: 0x4)
SGWeaponDataAsset.ClientRotationCosTolerance = 0x1248 // float (Size: 0x4)
SGWeaponDataAsset.ServerRotationCosTolerance = 0x124c // float (Size: 0x4)
SGWeaponDataAsset.bUseLagCompensation = 0x1250 // bool (Size: 0x1)
SGWeaponDataAsset.bCentralDotVisible = 0x1251 // bool (Size: 0x1)
SGWeaponDataAsset.CrosshairStyleWidgetClass = 0x1258 // ClassProperty (Size: 0x8)
SGWeaponDataAsset.CrosshairExpandRatio = 0x1260 // float (Size: 0x4)
SGWeaponDataAsset.IntensityHorizontalBase = 0x1264 // float (Size: 0x4)
SGWeaponDataAsset.IntensityVerticalBase = 0x1268 // float (Size: 0x4)
SGWeaponDataAsset.bViewKickFromGunKick = 0x126c // bool (Size: 0x1)
SGWeaponDataAsset.bIgnoreTranslation = 0x126d // bool (Size: 0x1)
SGWeaponDataAsset.bIgnoreRotation = 0x126e // bool (Size: 0x1)
SGWeaponDataAsset.ViewKickScale = 0x1270 // float (Size: 0x4)
SGWeaponDataAsset.bEnableRecoil_Pitch = 0x1274 // bool (Size: 0x1)
SGWeaponDataAsset.bEnableRecoil_Yaw = 0x1275 // bool (Size: 0x1)
SGWeaponDataAsset.FirstRecoilToRightChance = 0x1278 // float (Size: 0x4)
SGWeaponDataAsset.MaxVerticalRecoil = 0x127c // float (Size: 0x4)
SGWeaponDataAsset.MaxHorizontalRecoil = 0x1280 // float (Size: 0x4)
SGWeaponDataAsset.BeginRecoverTime = 0x1284 // float (Size: 0x4)
SGWeaponDataAsset.BurstStateEndTime = 0x1288 // float (Size: 0x4)
SGWeaponDataAsset.bAlwaysUseMaxRandNumber = 0x128c // bool (Size: 0x1)
SGWeaponDataAsset.OverrideRecoilInfoList = 0x1290 // TArray<FSGWeaponOverrideRecoilInfo> (Size: 0x10)
SGWeaponDataAsset.VerticalRecoilSpeedCurve = 0x12a0 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.HorizontalRecoilSpeedCurve = 0x12a8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.RecoilAccuracyRatios = 0x12b0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.RecoilAccuracyRatios_ShoulderZoom = 0x12e0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.RecoilAccuracyRatios_ADS = 0x1310 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponDataAsset.RecoverAlgorithm = 0x1340 // EESGRecoilRecoverAlgorithm (Size: 0x1)
SGWeaponDataAsset.ConfigDisturbRecoverSpeed = 0x1344 // float (Size: 0x4)
SGWeaponDataAsset.MaxVerticalRecoilDisturbRange = 0x1348 // float (Size: 0x4)
SGWeaponDataAsset.RecoverScale = 0x134c // float (Size: 0x4)
SGWeaponDataAsset.ConfigRecoverTime = 0x1350 // float (Size: 0x4)
SGWeaponDataAsset.MinBeginRecoverSpeed_Yaw = 0x1354 // float (Size: 0x4)
SGWeaponDataAsset.MinBeginRecoverSpeed_Pitch = 0x1358 // float (Size: 0x4)
SGWeaponDataAsset.MinVerticalSpeedDiffOfRecoilAndRecover = 0x135c // float (Size: 0x4)
SGWeaponDataAsset.RecoverSpeedCurve = 0x1360 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.PadMeshCheckDistance = 0x1368 // float (Size: 0x4)
SGWeaponDataAsset.ConfigPadMeshRecoilScale_Horizontal = 0x136c // float (Size: 0x4)
SGWeaponDataAsset.ConfigPadMeshRecoilScale_Vertical = 0x1370 // float (Size: 0x4)
SGWeaponDataAsset.ConfigPadMeshSpreadScale = 0x1374 // float (Size: 0x4)
SGWeaponDataAsset.IntensityHorizontalValueCurve = 0x1378 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.IntensityVerticalValueCurve = 0x1380 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.VerticalRecoilScaleOnMaxVertical = 0x1388 // float (Size: 0x4)
SGWeaponDataAsset.VerticalRecoilOnMaxVertical_Max = 0x138c // float (Size: 0x4)
SGWeaponDataAsset.VerticalRecoilOnMaxVertical_Min = 0x1390 // float (Size: 0x4)
SGWeaponDataAsset.VerticalRecoilValueCurveByShotCount = 0x1398 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.VerticalRecoilDistributionByShotCount = 0x13a0 // FSGRandomDistributionCurve (Size: 0x8)
SGWeaponDataAsset.HorizontalRecoilValueCurveByShotCount = 0x13a8 // CurveVector* (Size: 0x8)
SGWeaponDataAsset.HorizontalRecoilDistributionByShotCount = 0x13b0 // FSGRandomDistributionCurve (Size: 0x8)
SGWeaponDataAsset.MaxVerticalRecoverSpeedInStateRecoil = 0x13b8 // float (Size: 0x4)
SGWeaponDataAsset.VerticalRecoilTime = 0x13bc // float (Size: 0x4)
SGWeaponDataAsset.MaxHorizonRecoverSpeedInStateRecoil = 0x13c0 // float (Size: 0x4)
SGWeaponDataAsset.HorizonRecoilTime = 0x13c4 // float (Size: 0x4)
SGWeaponDataAsset.AdapterReocoilOnFireNumCurve = 0x13c8 // CurveFloat* (Size: 0x8)
SGWeaponDataAsset.bEnableDataAssetOverride = 0x13d0 // bool (Size: 0x1)
SGWeaponDataAsset.RecoilAnimConfigDataAssetOverride = 0x13d8 // WeaponRecoilDataSet* (Size: 0x8)
SGWeaponDataAsset.ADSFireRecoilAnimConfig = 0x13e0 // FWeaponRecoilAnimConfig (Size: 0x48)
SGWeaponDataAsset.FireRecoilAnimConfig = 0x1428 // FWeaponRecoilAnimConfig (Size: 0x48)
SGWeaponDataAsset.WeaponTypeSwitchGroup = 0x1470 // FString (Size: 0x10)
SGWeaponDataAsset.WeaponNameSwitch = 0x1480 // FString (Size: 0x10)
SGWeaponDataAsset.BasePriority = 0x1490 // float (Size: 0x4)
SGWeaponDataAsset.PriorityDropPerMeter = 0x1494 // float (Size: 0x4)
SGWeaponDataAsset.PriorityDropPerDegree = 0x1498 // float (Size: 0x4)
SGWeaponDataAsset.PlayBulletDropSound = 0x149c // bool (Size: 0x1)
SGWeaponDataAsset.BulletSizeSwitch = 0x14a0 // FString (Size: 0x10)
SGWeaponDataAsset.BulletDropDelay = 0x14b0 // float (Size: 0x4)
SGWeaponDataAsset.GenSoundVisualInterval = 0x14b4 // float (Size: 0x4)
SGWeaponDataAsset.ZeroingDistance = 0x14b8 // float (Size: 0x4)
SGWeaponDataAsset.ManagedTags = 0x14c0 // TArray<FGameplayTag> (Size: 0x10)
SGWeaponDataAsset.SharedMaterial = 0x14d0 // MaterialInterface* (Size: 0x8)
SGWeaponDataAsset.bCanEverMergeWeapon = 0x14d8 // bool (Size: 0x1)
SGWeaponDataAsset.bAllWeaponPartsRemarkable = 0x14d9 // bool (Size: 0x1)
SGWeaponDataAsset.DelayTimeToMergeWeapon = 0x14dc // float (Size: 0x4)
SGWeaponDataAsset.MaxDelayMergeTimes = 0x14e0 // int32_t (Size: 0x4)
SGWeaponDataAsset.ImportantAdapterNameList = 0x14e8 // TArray<FString> (Size: 0x10)
SGWeaponDataAsset.AutoAimParamsSet = 0x14f8 // AutoAimParamsSet* (Size: 0x8)
SGWeaponDataAsset.AutoAimParamsSetAdditional = 0x1500 // TArray<AutoAimParamsSet*> (Size: 0x10)
SGWeaponDataAsset.BulletTraceDataAsset = 0x1510 // BulletTraceDataAsset* (Size: 0x8)
SGWeaponDataAsset.TouchRotateSpeed = 0x1518 // float (Size: 0x4)
SGWeaponDataAsset.MaxPitch = 0x151c // float (Size: 0x4)
SGWeaponDataAsset.MaxYaw = 0x1520 // float (Size: 0x4)
SGWeaponDataAsset.MaxRoll = 0x1524 // float (Size: 0x4)
SGWeaponDataAsset.MinPitch = 0x1528 // float (Size: 0x4)
SGWeaponDataAsset.MinYaw = 0x152c // float (Size: 0x4)
SGWeaponDataAsset.MinRoll = 0x1530 // float (Size: 0x4)
SGWeaponDataAsset.RotChangeSpeed = 0x1534 // float (Size: 0x4)
SGWeaponDataAsset.PosChangeSpeed = 0x1538 // float (Size: 0x4)
SGWeaponDataAsset.FixCamMaxPosX = 0x153c // float (Size: 0x4)
SGWeaponDataAsset.FocusCamPosXScale = 0x1540 // float (Size: 0x4)
SGWeaponDataAsset.ShakeAnimPeriod = 0x1544 // int32_t (Size: 0x4)
SGWeaponDataAsset.Tolerance = 0x1548 // float (Size: 0x4)
SGWeaponDataAsset.OnePEffectDis = 0x154c // float (Size: 0x4)
SGWeaponDataAsset.PinchSpeed = 0x1550 // float (Size: 0x4)
SGWeaponDataAsset.MinPinchDisPercent = 0x1554 // float (Size: 0x4)
SGWeaponDataAsset.MaxPinchDisPercent = 0x1558 // float (Size: 0x4)
SGWeaponDataAsset.FocusPartCfgMap = 0x1560 // TMap<...> (Size: 0x50)
SGWeaponDataAsset.FixCamFullScreenPosX = 0x15b0 // float (Size: 0x4)
SGWeaponDataAsset.FocusCamFullScreenPosXScale = 0x15b4 // float (Size: 0x4)
SGWeaponDataAsset.CameraPosOffset = 0x15b8 // FVector (Size: 0xc)
SGWeaponDataComponent.AutoAimParamsSet = 0x100 // AutoAimParamsSet* (Size: 0x8)
SGWeaponDataComponent.AutoAimParamsSetAdditional = 0x108 // TArray<AutoAimParamsSet*> (Size: 0x10)
SGWeaponDataComponent.BulletTraceDataAsset = 0x118 // BulletTraceDataAsset* (Size: 0x8)
SGWeaponDebugComponent.bDrawWeaponDir = 0x101 // bool (Size: 0x1)
SGWeaponDurabilityComponent.HintMalfunctionChance = 0x108 // float (Size: 0x4)
SGWeaponDurabilityComponent.DurabilityCostPreFireOnBarrel = 0x10c // float (Size: 0x4)
SGWeaponDurabilityComponent.DurabilityCostPreFireOnGunBase = 0x110 // float (Size: 0x4)
SGWeaponDurabilityComponent.DurabilityCostWhenDeathOnBarrel = 0x114 // float (Size: 0x4)
SGWeaponDurabilityComponent.DurabilityCostWhenDeathOnGunBase = 0x118 // float (Size: 0x4)
SGWeaponDurabilityComponent.DurabilityPercentToMOA = 0x120 // CurveFloat* (Size: 0x8)
SGWeaponDurabilityComponent.DurabilityPercentToAccuracy = 0x128 // CurveFloat* (Size: 0x8)
SGWeaponDurabilityComponent.DurabilityPercentToMalfunction = 0x130 // CurveFloat* (Size: 0x8)
SGWeaponDurabilityComponent.ContinuousFireCountToMalfunction = 0x138 // CurveFloat* (Size: 0x8)
SGWeaponDurabilityComponent.JamSoundConfigs = 0x140 // TArray<FJamBreakSoundConfig> (Size: 0x10)
SGWeaponDurabilityComponent.ServerConfigJammingEnable = 0x150 // bool (Size: 0x1)
SGWeaponDurabilityComponent.bIsJamming = 0x151 // bool (Size: 0x1)
SGWeaponDurabilityComponent.BarrelDurability = 0x154 // float (Size: 0x4)
SGWeaponDurabilityComponent.BarrelDurabilityMax = 0x158 // float (Size: 0x4)
SGWeaponDurabilityComponent.GunBaseDurability = 0x15c // float (Size: 0x4)
SGWeaponDurabilityComponent.GunBaseDurabilityMax = 0x160 // float (Size: 0x4)
SGWeaponEffectFOVComponent.CharacterOwner = 0x168 // SGCharacter* (Size: 0x8)
SGWeaponEvents.BulletStartEvent = 0x30 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.BulletEndEvent = 0x40 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.BulletPredestinedShotEvent = 0x50 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.DrawLineEvent = 0x60 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnPushBullet = 0x70 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnWeaponAssembled = 0x80 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnWeaponDisassembled = 0x90 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnBulletSpawned = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnAdapterTotalCountChanged = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnPullBoltFailed = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponEvents.OnProjectileAboveSpecifiedHeight = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFireIntervalComponent.JumpFireInterval = 0x108 // float (Size: 0x4)
SGWeaponFireIntervalComponent.ContinuousFirePersistTime = 0x10c // float (Size: 0x4)
SGWeaponFireIntervalComponent.ContinuousFireInterval = 0x110 // float (Size: 0x4)
SGWeaponFireIntervalComponent.FireIntervalCurveList = 0x118 // TArray<CurveFloat*> (Size: 0x10)
SGWeaponFireIntervalComponent.ShootingModeToFireIntervalCurveMap = 0x128 // TMap<...> (Size: 0x50)
SGWeaponFireIntervalComponent.FireAnimTime = 0x178 // float (Size: 0x4)
SGWeaponFireIntervalComponent.FireAnimBlendOutTime = 0x17c // float (Size: 0x4)
SGWeaponFireIntervalComponent.FireEndContinusTime = 0x180 // float (Size: 0x4)
SGWeaponFireMode.OwnerWeapon = 0x28 // SGWeapon* (Size: 0x8)
SGWeaponFireMode.FireMode = 0x30 // EESGWeaponFireMode (Size: 0x1)
SGWeaponFireMode.ModeTraceRange = 0x34 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamage = 0x40 // int32_t (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageMin = 0x44 // int32_t (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageScaleToHead = 0x48 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageScaleToArms = 0x4c // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageScaleToChest = 0x50 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageScaleToLegs = 0x54 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageScaleToStomach = 0x58 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeDamageDistanceModifier = 0x5c // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeZeroModifyDistance = 0x60 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeBulletBeginDropDistance = 0x64 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeBulletFakeDropZ = 0x68 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.ModeHitDamageType = 0x70 // ClassProperty (Size: 0x8)
SGWeaponFireMode_InstantHit.NoBlockActorType = 0x78 // TArray<ClassProperty> (Size: 0x10)
SGWeaponFireMode_InstantHit.ModeHitMomentum = 0x88 // float (Size: 0x4)
SGWeaponFireMode_InstantHit.LastRandSpreadRange = 0x8c // float (Size: 0x4)
SGWeaponFireMode_InstantHit.RecordLastHitResult = 0x98 // FHitResult (Size: 0x98)
SGWeaponFireMode_InstantHit.RecordLastShootDir = 0x130 // FVector (Size: 0xc)
SGWeaponFireMode_InstantHit.RecordTargetDistance = 0x13c // float (Size: 0x4)
SGWeaponFireMode_InstantHit.RecordDesireDamageValue = 0x140 // int32_t (Size: 0x4)
SGWeaponFireMode_InstantHit.RecordLastHitAmmo = 0x148 // ClassProperty (Size: 0x8)
SGWeaponFireMode_MeleeHit.LocalHitInfo = 0x48 // FWeaponMeleeHitInfo (Size: 0x40)
SGWeaponFireMode_MeleeHit.DamageType = 0xb8 // ClassProperty (Size: 0x8)
SGWeaponFireMode_MeleeHit.SphereTraceRadius = 0xc0 // float (Size: 0x4)
SGWeaponFireMode_MeleeHit.ExtraHitDeltaRotators = 0xc8 // TArray<FExtraHitDeltaRotators> (Size: 0x10)
SGWeaponFireMode_MeleeHit.ProneExtraHitDeltaRotators = 0xd8 // TArray<FExtraHitDeltaRotators> (Size: 0x10)
SGWeaponFireMode_MeleeHit.BreakGlassNormalRotOffset = 0xe8 // float (Size: 0x4)
SGWeaponFireMode_MeleeHitByMotion.DamagePoint = 0x50 // BoxComponent* (Size: 0x8)
SGWeaponFireMode_MeleeHitByMotion.BeHitActors = 0x58 // TSet<...> (Size: 0x50)
SGWeaponFireMode_MeleeHitByMotion.HitInfoDamageType = 0xc0 // ClassProperty (Size: 0x8)
SGWeaponFireMode_MeleeHitByMotion.bDebugHit = 0xc8 // bool (Size: 0x1)
SGWeaponFireMode_MeleeHitByMotion.TraceConfArray = 0xd0 // TArray<FMeleeTraceConf> (Size: 0x10)
SGWeaponFireMode_PhysicSimulate.BulletProjClass = 0x40 // ClassProperty (Size: 0x8)
SGWeaponFireMode_PhysicSimulate.ModeDamage = 0x48 // int32_t (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageMin = 0x4c // int32_t (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToStomach = 0x50 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToHead = 0x54 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToArms = 0x58 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToChest = 0x5c // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToLegs = 0x60 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageScaleToLimb = 0x64 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageDistanceModifier = 0x68 // float (Size: 0x4)
SGWeaponFireMode_PhysicSimulate.ModeDamageModifyZeroDistance = 0x6c // float (Size: 0x4)
SGWeaponFireMode_ProjectileGrenade.ThrowableProjcetileClass = 0x150 // ClassProperty (Size: 0x8)
SGWeaponFireMode_ProjectileGrenade.PlayEffectTime = 0x158 // float (Size: 0x4)
SGWeaponFireMode_ProjectileGrenade.PlayEffectTimeRandLimit = 0x15c // float (Size: 0x4)
SGWeaponFireMode_ProjectileGrenade.ThrowableProjectile = 0x160 // SGThrowableProjectile* (Size: 0x8)
SGWeaponFireMode_ProjectileGrenade.DefaultGravityScale = 0x168 // float (Size: 0x4)
SGWeaponFireMode_ProjectileGrenade.CachedThrowableWeapon = 0x170 // SGWeapon* (Size: 0x8)
SGWeaponFireMode_ProjectileHit.ThrowableProjcetileClass = 0x158 // ClassProperty (Size: 0x8)
SGWeaponFireMode_ProjectileHit.StandFireDelay = 0x160 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.ProneFireDelay = 0x164 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.CrouchFireDelay = 0x168 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.PlayEffectTime = 0x16c // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.PlayEffectTimeRandLimit = 0x170 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.bAutoCountdownFireTime = 0x174 // bool (Size: 0x1)
SGWeaponFireMode_ProjectileHit.AutoFireDelay = 0x178 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.ThrowableProjectile = 0x180 // SGThrowableProjectile* (Size: 0x8)
SGWeaponFireMode_ProjectileHit.DefaultGravityScale = 0x188 // float (Size: 0x4)
SGWeaponFireMode_ProjectileHit.PrePerformanceProjectile = 0x190 // SGThrowableProjectile* (Size: 0x8)
SGWeaponFireMode_ProjectileHit.CachedThrowableWeapon = 0x1d8 // SGWeapon* (Size: 0x8)
SGWeaponFireMode_ProjectileHit.CachedOwnerCharacter = 0x1e0 // SGCharacter* (Size: 0x8)
SGWeaponFireMode_ProjectileLauncherHit.bShowProjectileTrajectory = 0x40 // bool (Size: 0x1)
SGWeaponFireMode_ProjectileLauncherHit.ThrowableProjcetileClass = 0x48 // ClassProperty (Size: 0x8)
SGWeaponFireMode_ProjectileLauncherHit.InitSpeed = 0x50 // float (Size: 0x4)
SGWeaponFireMode_ProjectileLauncherHit.MaxSpeed = 0x54 // float (Size: 0x4)
SGWeaponFireMode_ProjectileLauncherHit.ProjectileLifeSpan = 0x58 // float (Size: 0x4)
SGWeaponFireMode_StickOnInterface.ThrowableProjectileClass = 0x1f8 // ClassProperty (Size: 0x8)
SGWeaponFireMode_StickOnInterface.ThrowableType = 0x200 // EESGThrowSubType (Size: 0x1)
SGWeaponFireMode_StickOnInterface.SetupTime = 0x204 // float (Size: 0x4)
SGWeaponFireMode_StickOnInterface.MaxDistances = 0x208 // float (Size: 0x4)
SGWeaponFireMode_StickOnInterface.PlayEffectTime = 0x20c // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.bShowProjectileTrajectory = 0x40 // bool (Size: 0x1)
SGWeaponFireMode_WithProjectileTrajectory.ProjectileTrajectory = 0x50 // SGProjectileTrajectory* (Size: 0x8)
SGWeaponFireMode_WithProjectileTrajectory.PreviewActor = 0x58 // Actor* (Size: 0x8)
SGWeaponFireMode_WithProjectileTrajectory.PreviewActorClass = 0x80 // ClassProperty (Size: 0x8)
SGWeaponFireMode_WithProjectileTrajectory.PreviewTowardDistance = 0x88 // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.ProjectileTrajectoryClass = 0x90 // ClassProperty (Size: 0x8)
SGWeaponFireMode_WithProjectileTrajectory.ProjcetileClass = 0x98 // ClassProperty (Size: 0x8)
SGWeaponFireMode_WithProjectileTrajectory.InitSpeed = 0xa0 // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.MaxSpeed = 0xa4 // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.ProjectileTraceRadius = 0xa8 // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.CharacterLocationOffset = 0xac // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.LeanRightOffset = 0xb8 // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.LeanLeftOffset = 0xbc // float (Size: 0x4)
SGWeaponFireMode_WithProjectileTrajectory.ProneFireLocationOffset = 0xc0 // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.StandFireLocationOffset = 0xcc // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.CrouchFireLocationOffset = 0xd8 // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.ProneFireRotationOffset = 0xe4 // FRotator (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.StandFireRotationOffset = 0xf0 // FRotator (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.CrouchFireRotationOffset = 0xfc // FRotator (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.ProneFireLocationOffsetThrowDown = 0x108 // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.StandFireLocationOffsetThrowDown = 0x114 // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.CrouchFireLocationOffsetThrowDown = 0x120 // FVector (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.ProneFireRotationOffsetThrowDown = 0x12c // FRotator (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.StandFireRotationOffsetThrowDown = 0x138 // FRotator (Size: 0xc)
SGWeaponFireMode_WithProjectileTrajectory.CrouchFireRotationOffsetThrowDown = 0x144 // FRotator (Size: 0xc)
SGWeaponFiringComponent.CacheLocalPC = 0x118 // PlayerController* (Size: 0x8)
SGWeaponFiringComponent.SupportFireModeList = 0x120 // TArray<ClassProperty> (Size: 0x10)
SGWeaponFiringComponent.OnFiringEvent = 0x130 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.OnHoldGrenadeEvent = 0x140 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.OnGrenadeTimeoutEvent = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.ContinuousFireCountIncreasedEvent = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.OnClientNotifyFireFailed = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.DoFireEvent = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SGWeaponFiringComponent.PerWeaponAnimationSets = 0x190 // SGUAMPerWeaponAnimationSets* (Size: 0x8)
SGWeaponFiringComponent.ThrowableProjectileSpawnLocation = 0x198 // FVector (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectileSpawnRotation = 0x1a4 // FRotator (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectileLaunchDirection = 0x1b0 // FVector (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectileSpawnLocationCA = 0x1bc // FVector (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectileSpawnRotationCA = 0x1c8 // FRotator (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectileLaunchDirectionCA = 0x1d4 // FVector (Size: 0xc)
SGWeaponFiringComponent.ThrowableProjectile = 0x1e0 // SGThrowableProjectile* (Size: 0x8)
SGWeaponFiringComponent.PrePerformanceProjectile = 0x1e8 // SGThrowableProjectile* (Size: 0x8)
SGWeaponFiringComponent.TrajectoryOBCount = 0x1f0 // int32_t (Size: 0x4)
SGWeaponFiringComponent.FireModeList = 0x1f8 // TArray<SGWeaponFireMode*> (Size: 0x10)
SGWeaponFiringComponent.FireRepInfos3P = 0x210 // TArray<FSGFireRepInfo3P> (Size: 0x10)
SGWeaponFiringComponent.ServerHitInfos = 0x248 // TArray<FSGServerHitInfo> (Size: 0x10)
SGWeaponFiringComponent.PreFireTime = 0x30c // float (Size: 0x4)
SGWeaponFiringComponent.EndPreFireTime = 0x310 // float (Size: 0x4)
SGWeaponFiringComponent.KeepPreFireTime = 0x314 // float (Size: 0x4)
SGWeaponFiringComponent.DelaySpawnProjectileTimeForThrowDown = 0x318 // float (Size: 0x4)
SGWeaponFiringComponent.DelaySpawnProjectileTimeForThrowUp = 0x31c // float (Size: 0x4)
SGWeaponFiringComponent.DelaySpawnProjectileTimeForFastThrow = 0x320 // float (Size: 0x4)
SGWeaponFiringComponent.DelayHideWeaponTime = 0x324 // float (Size: 0x4)
SGWeaponFiringComponent.CoolDownTimeAfterFire = 0x328 // float (Size: 0x4)
SGWeaponFiringComponent.WeaponFireTime = 0x32c // float (Size: 0x4)
SGWeaponFiringComponent.bEndZoomWhenStopFire = 0x330 // bool (Size: 0x1)
SGWeaponFiringComponent.bEndAndRestoreZoomWhenStopFire = 0x331 // bool (Size: 0x1)
SGWeaponFiringComponent.bIsShooting = 0x332 // bool (Size: 0x1)
SGWeaponFiringComponent.DirectFlyDistance = 0x334 // float (Size: 0x4)
SGWeaponFiringComponent.bGrenadeCanHold = 0x338 // bool (Size: 0x1)
SGWeaponFiringComponent.bGrenadeCanSetUp = 0x339 // bool (Size: 0x1)
SGWeaponFiringComponent.DamageType = 0x33a // EESGGrenadeDamageType (Size: 0x1)
SGWeaponFiringComponent.bCanBeUsedWhenDBNO = 0x33b // bool (Size: 0x1)
SGWeaponFiringComponent.AutoModeFrontBurstNum = 0x340 // int32_t (Size: 0x4)
SGWeaponFiringComponent.GrenadeBeHold = 0x344 // bool (Size: 0x1)
SGWeaponFiringComponent.GrenadeCancel = 0x345 // bool (Size: 0x1)
SGWeaponFiringComponent.GrenadeBeThrow = 0x346 // bool (Size: 0x1)
SGWeaponFiringComponent.GrenadeInHand = 0x347 // bool (Size: 0x1)
SGWeaponFiringComponent.bGrenadeTimeout = 0x348 // bool (Size: 0x1)
SGWeaponFiringComponent.bIsHoldGrenadeButtonVisible = 0x349 // bool (Size: 0x1)
SGWeaponFiringComponent.bIsHoldGreande = 0x34a // bool (Size: 0x1)
SGWeaponFiringComponent.MeleeOrThrowableFireInfo = 0x350 // FSGFireRepInfo (Size: 0x70)
SGWeaponFiringComponent.FlyVelocityToDistanceCurve = 0x3c0 // CurveFloat* (Size: 0x8)
SGWeaponFiringComponent.SpecializedFlyVelocityToDistanceCurveMap = 0x3c8 // TMap<...> (Size: 0x50)
SGWeaponFiringComponent.AdapterAdjustingDamage = 0x41c // float (Size: 0x4)
SGWeaponFiringComponent.ReloadSpeedRatioByWeaponAccessory = 0x420 // float (Size: 0x4)
SGWeaponFiringComponent.EnergyCostPerFire = 0x424 // float (Size: 0x4)
SGWeaponFiringComponent.EnableFireRequestCacheDelay = 0x428 // float (Size: 0x4)
SGWeaponFiringComponent.CurrentShootMode = 0x42c // EESGWeaponShootingMode (Size: 0x1)
SGWeaponFiringComponent.ModifyCurve = 0x430 // CurveFloat* (Size: 0x8)
SGWeaponFiringComponent.DamageScaleCurve = 0x438 // CurveFloat* (Size: 0x8)
SGWeaponFiringComponent.DefaultPenetration = 0x440 // float (Size: 0x4)
SGWeaponFiringComponent.Radius = 0x444 // float (Size: 0x4)
SGWeaponFiringComponent.SupportShootingMode = 0x448 // TArray<EESGWeaponShootingMode> (Size: 0x10)
SGWeaponFiringComponent.bZoomDynamicFireMode = 0x458 // bool (Size: 0x1)
SGWeaponFiringComponent.MaxBurstShotCount = 0x45c // int32_t (Size: 0x4)
SGWeaponFiringComponent.BurstStopMode = 0x460 // EEBurstStopMode (Size: 0x1)
SGWeaponFiringComponent.bSupportAimAssist = 0x461 // bool (Size: 0x1)
SGWeaponFiringComponent.ControlledWeaponClass = 0x468 // ClassProperty (Size: 0x8)
SGWeaponFiringComponent.ControllerWeaponClass = 0x470 // ClassProperty (Size: 0x8)
SGWeaponFiringComponent.BulletTrajectoryType = 0x478 // FName (Size: 0x8)
SGWeaponFiringComponent.ZoomSupportCheckHeight = 0x480 // float (Size: 0x4)
SGWeaponFiringComponent.bBipOn = 0x484 // bool (Size: 0x1)
SGWeaponFiringComponent.bProjectileWeap = 0x485 // bool (Size: 0x1)
SGWeaponFiringComponent.bIsShootAiming = 0x48e // bool (Size: 0x1)
SGWeaponFiringComponent.BulletZeroFlyDistance = 0x498 // float (Size: 0x4)
SGWeaponFiringComponent.ShootAimingDelayEnterTime = 0x4a4 // float (Size: 0x4)
SGWeaponFiringComponent.ShootAimingFOV = 0x4a8 // float (Size: 0x4)
SGWeaponFiringComponent.MeleeWeaponPhaseNumber = 0x4ac // int32_t (Size: 0x4)
SGWeaponFiringComponent.MeleeWeaponCurPhase = 0x4b0 // int32_t (Size: 0x4)
SGWeaponFiringComponent.IsInSprintMeleeFire = 0x4b4 // bool (Size: 0x1)
SGWeaponFiringComponent.MeleeWeaponMaxHitNumberPerPhase = 0x4b8 // int32_t (Size: 0x4)
SGWeaponFiringComponent.CrosshairAccuracyRatios = 0x4e0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponFiringComponent.ProjectileClass = 0x510 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponFiringComponent.ProjectileClassHD = 0x538 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponFiringComponent.ProjectileInitSpeed = 0x560 // float (Size: 0x4)
SGWeaponFiringComponent.ProjectileGravityZeroDistance = 0x564 // float (Size: 0x4)
SGWeaponFiringComponent.ProjectileHorizontalVelocityDecRate = 0x568 // float (Size: 0x4)
SGWeaponFiringComponent.ProjectileZeroHorizontalVelocityDecDistance = 0x56c // float (Size: 0x4)
SGWeaponFiringComponent.BipodHeight = 0x578 // float (Size: 0x4)
SGWeaponFiringComponent.bInSupportOnState = 0x57c // bool (Size: 0x1)
SGWeaponFiringComponent.LastHitLoc = 0x580 // FVector (Size: 0xc)
SGWeaponFiringComponent.LastFireAmmo = 0x5a0 // ClassProperty (Size: 0x8)
SGWeaponFiringComponent.JudgeFireEndTime = 0x5bc // float (Size: 0x4)
SGWeaponFiringComponent.LastGetBulletDropDistanceCurve = 0x648 // CurveFloat* (Size: 0x8)
SGWeaponFiringComponent.StopFireTimerHandle = 0x660 // FTimerHandle (Size: 0x8)
SGWeaponFiringComponent.CurrWeaponOwner = 0x670 // SGCharacter* (Size: 0x8)
SGWeaponFiringComponent.TmpWeaponOwner = 0x678 // SGCharacter* (Size: 0x8)
SGWeaponFiringComponent.bDisableAutoPullBoltOnStopFire = 0x680 // bool (Size: 0x1)
SGWeaponFiringComponent.BaseDamage = 0x684 // float (Size: 0x4)
SGWeaponFiringComponent.ZeroingDistance = 0x688 // float (Size: 0x4)
SGWeaponFiringComponent.FireInitSpeed = 0x68c // float (Size: 0x4)
SGWeaponFiringComponent.ImpactForceFactor = 0x694 // float (Size: 0x4)
SGWeaponFiringComponent.ImpactResistanceFactor = 0x698 // float (Size: 0x4)
SGWeaponFiringComponent.FireInfoLocationForReplay = 0x6c0 // TArray<FVector> (Size: 0x10)
SGWeaponGiveComponent.bCanDrop = 0x128 // bool (Size: 0x1)
SGWeaponHeatComponent.HeatReduceSpeedCurve = 0x100 // CurveFloat* (Size: 0x8)
SGWeaponHeatComponent.HeatIncreaseCurve = 0x108 // CurveFloat* (Size: 0x8)
SGWeaponHeatComponent_HD.TemperatureGainOnFire = 0x118 // float (Size: 0x4)
SGWeaponHeatComponent_HD.ThermalConductivity = 0x11c // float (Size: 0x4)
SGWeaponHeatComponent_HD.BarrelHeatCapacity = 0x120 // float (Size: 0x4)
SGWeaponHeatComponent_HD.AirHeatCapacity = 0x124 // float (Size: 0x4)
SGWeaponImpactComponent.bEnableImpactEffects = 0x118 // bool (Size: 0x1)
SGWeaponImpactComponent.ImpactEffectSkipDistance = 0x11c // float (Size: 0x4)
SGWeaponImpactComponent.MaxImpactEffectSkipTime = 0x120 // float (Size: 0x4)
SGWeaponImpactComponent.ConeAxisParamName = 0x124 // FName (Size: 0x8)
SGWeaponImpactComponent.MaxDistanceToPlayEffect = 0x12c // float (Size: 0x4)
SGWeaponImpactComponent.ImpactMaterialAndAudioEventList = 0x130 // TArray<FImpactMaterialAndAudioEvent> (Size: 0x10)
SGWeaponImpactComponent.MeleeRecoilRot = 0x140 // FRotator (Size: 0xc)
SGWeaponImpactComponent.DecalRotationOffset = 0x14c // FRotator (Size: 0xc)
SGWeaponImpactComponent.OwnerWeapon = 0x158 // SGWeapon* (Size: 0x8)
SGWeaponImpactComponent.LastHitTargetResult = 0x160 // FHitResult (Size: 0x98)
SGWeaponImpactComponent.MeleeImpactInfo = 0x1f8 // FMeleeImpactProperty (Size: 0xa8)
SGWeaponImpactComponent.MeleeRecoilTarRot = 0x2a0 // FRotator (Size: 0xc)
SGWeaponImpactComponent.MeleeRecoilAnimSpeed = 0x2ac // float (Size: 0x4)
SGWeaponImpactComponent.bEnableMeleeRecoil = 0x2b0 // bool (Size: 0x1)
SGWeaponImpactComponent.AliveImpactPSCNumConf = 0x2c4 // int32_t (Size: 0x4)
SGWeaponImpactComponent.ImpactEffectData = 0x2d8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponImpactComponent.ImpactAudioData = 0x300 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponImpactComponent.BloodSplatterData = 0x328 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponImpactComponent.RicochetData = 0x350 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponInventoryTagToGripType.InventoryTag = 0x0 // FGameplayTag (Size: 0x8)
SGWeaponInventoryTagToGripType.GripType = 0x8 // EESGWeaponForegripType (Size: 0x1)
SGWeaponLocalAnimInfo.CharacterMontageParams = 0x0 // FSGMontagePlayParams (Size: 0x48)
SGWeaponLocalAnimInfo.WeaponMontageParams = 0x48 // FSGMontagePlayParams (Size: 0x48)
SGWeaponLocalAnimInfo.AdapterAnimationList = 0x90 // TArray<FSGWeaponSpecialSpecAdapterAnimation> (Size: 0x10)
SGWeaponLocalAnimInfo.PlayBit = 0xa0 // bool (Size: 0x1)
SGWeaponManagerAttributeSet.HaveExtraMainWeaponSlot = 0x48 // float (Size: 0x4)
SGWeaponManagerAttributeSet.ChangeClipDurationScaleMultiplier = 0x4c // float (Size: 0x4)
SGWeaponManagerAttributeSet.FillContainerDurationScaleMultiplier = 0x50 // float (Size: 0x4)
SGWeaponManagerAttributeSet.SwitchWeaponDurationScaleMultiplier = 0x54 // float (Size: 0x4)
SGWeaponManagerAttributeSet.RecoilScaleMultiplier = 0x58 // float (Size: 0x4)
SGWeaponManagerAttributeSet.SpreadScaleMultiplier = 0x5c // float (Size: 0x4)
SGWeaponManagerAttributeSet.AimingScaleMultiplier = 0x60 // float (Size: 0x4)
SGWeaponMergeComponent.SharedMaterial = 0x100 // MaterialInterface* (Size: 0x8)
SGWeaponMergeComponent.bCanEverMergeWeapon = 0x108 // bool (Size: 0x1)
SGWeaponMergeComponent.bAllWeaponPartsRemarkable = 0x109 // bool (Size: 0x1)
SGWeaponMergeComponent.DelayTimeToMergeWeapon = 0x10c // float (Size: 0x4)
SGWeaponMergeComponent.MaxDelayMergeTimes = 0x110 // int32_t (Size: 0x4)
SGWeaponMergeComponent.CachedMeshComponents = 0x158 // TArray<MeshComponent*> (Size: 0x10)
SGWeaponMergeComponent.CachedWeaponActors = 0x168 // TArray<SGInventory*> (Size: 0x10)
SGWeaponMergeComponent.MergedStaticMesh = 0x190 // StaticMesh* (Size: 0x8)
SGWeaponMergeComponent.CachedSourceMeshComponents = 0x1c0 // TArray<MeshComponent*> (Size: 0x10)
SGWeaponMergeComponent.MergedBMTexture = 0x1e0 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.MergedORNTexture = 0x1e8 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.MergedAMTexture = 0x1f0 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.MergedPatternTexture = 0x1f8 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.ToMergeBMTextureList = 0x210 // TArray<Texture2D*> (Size: 0x10)
SGWeaponMergeComponent.ToMergeORNTextureList = 0x220 // TArray<Texture2D*> (Size: 0x10)
SGWeaponMergeComponent.ToMergeAMTextureList = 0x230 // TArray<Texture2D*> (Size: 0x10)
SGWeaponMergeComponent.ToMergePatternTextureList = 0x240 // TArray<Texture2D*> (Size: 0x10)
SGWeaponMergeComponent.DMI = 0x250 // MaterialInstanceDynamic* (Size: 0x8)
SGWeaponMergeComponent.MaxMergeDeviceLevel = 0x268 // int32_t (Size: 0x4)
SGWeaponMergeComponent.DefualtTexture = 0x270 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.TextureMergeMaterial = 0x278 // MaterialInterface* (Size: 0x8)
SGWeaponMergeComponent.AlterTextureMergeMaterials = 0x280 // TArray<MaterialInterface*> (Size: 0x10)
SGWeaponMergeComponent.DefaultORN = 0x290 // Texture2D* (Size: 0x8)
SGWeaponMergeComponent.DefaultAM = 0x298 // Texture2D* (Size: 0x8)
SGWeaponMeshComponent.SimpleMeshComponent = 0x100 // MeshComponent* (Size: 0x8)
SGWeaponMeshComponent.ConstructSkeletalMeshComponent = 0x108 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponMeshComponent.ConstructStaticMeshComponent = 0x110 // StaticMeshComponent* (Size: 0x8)
SGWeaponMeshComponent.SimpleSkeletalMesh = 0x128 // SkeletalMesh* (Size: 0x8)
SGWeaponMeshComponent.SimpleSkeletalMeshAnim = 0x130 // ClassProperty (Size: 0x8)
SGWeaponMeshComponent.ImportantAdapterNameList = 0x138 // TArray<FString> (Size: 0x10)
SGWeaponMeshComponent.SavedSockets = 0x148 // TArray<StaticMeshSocket*> (Size: 0x10)
SGWeaponMeshComponent.ModularBaseSkelMeshComp = 0x158 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponMeshComponent.LeftWeaponSocketName = 0x1a0 // FName (Size: 0x8)
SGWeaponMeshComponent.bHasCaptureActorMesh_OnHand = 0x1a8 // bool (Size: 0x1)
SGWeaponMeshComponent.WeaponCaptureActorMeshAry_OnHand = 0x1b0 // TArray<FSimpleMeshInfo> (Size: 0x10)
SGWeaponMeshComponent.bHasLeftWeaponMesh = 0x1c1 // bool (Size: 0x1)
SGWeaponMeshComponent.LeftHandWeaponMeshComp = 0x1c8 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponMeshComponent.LeftHandWeaponMesh = 0x1d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.LeftHandWeaponMesh_Lobby = 0x1f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.bHasOnBackMesh = 0x230 // bool (Size: 0x1)
SGWeaponMeshComponent.bHasOnBackMeshPhysic = 0x231 // bool (Size: 0x1)
SGWeaponMeshComponent.AttachToBackMesh = 0x238 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.AttachToBackMesh3P = 0x260 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.AttachToBackMesh_Lobby = 0x288 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.bHasSheathMesh = 0x2c0 // bool (Size: 0x1)
SGWeaponMeshComponent.SheathMeshComp = 0x2c8 // SkeletalMeshComponent* (Size: 0x8)
SGWeaponMeshComponent.bSheathHiddenWhenWeaponOnBack = 0x2d0 // bool (Size: 0x1)
SGWeaponMeshComponent.bHasSheathPhysic = 0x2d1 // bool (Size: 0x1)
SGWeaponMeshComponent.WeaponSheathMesh = 0x2d8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.WeaponSheathMesh3P = 0x300 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.WeaponSheathMesh_Lobby = 0x328 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.WeaponSheathMeshAnimClass = 0x350 // TSoftClassPtr<UObject> (Size: 0x28)
SGWeaponMeshComponent.bRigSheathMeshByPos = 0x388 // bool (Size: 0x1)
SGWeaponMeshComponent.bRigBackMeshByPos = 0x389 // bool (Size: 0x1)
SGWeaponMeshComponent.RigTransMap = 0x390 // TMap<...> (Size: 0x50)
SGWeaponMeshComponent.RigSpeed = 0x3e0 // float (Size: 0x4)
SGWeaponMeshRes.MeshAttachSocket = 0x0 // FName (Size: 0x8)
SGWeaponMeshRes.MeshAttachSocket_Left = 0x8 // FName (Size: 0x8)
SGWeaponMeshRes.MeshAttachSocket_Hang = 0x10 // FName (Size: 0x8)
SGWeaponMeshRes.MeshResouceRef = 0x18 // FSoftObjectPath (Size: 0x18)
SGWeaponMeshRes.MeshAnimClass = 0x30 // ClassProperty (Size: 0x8)
SGWeaponMeshRes.bNeedBlockBullet = 0x38 // bool (Size: 0x1)
SGWeaponMeshRes.Material1P = 0x40 // TArray<MaterialInterface*> (Size: 0x10)
SGWeaponMeshRes.Material3P = 0x50 // TArray<MaterialInterface*> (Size: 0x10)
SGWeaponMovementComponent.WeaponZoomingMovingScale = 0x100 // float (Size: 0x4)
SGWeaponMovementComponent.WeaponShoulderZoomMovingScale = 0x104 // float (Size: 0x4)
SGWeaponMovementComponent.WeaponChangeClipMovingScale = 0x108 // float (Size: 0x4)
SGWeaponMovementComponent.DisableSprintTags = 0x110 // FGameplayTagContainer (Size: 0x20)
SGWeaponMovementComponent.ADSMoveSpeedRatioByWeaponAccessory = 0x134 // float (Size: 0x4)
SGWeaponMovementComponent.MoveSpeedRatioByWeaponAccessory = 0x138 // float (Size: 0x4)
SGWeaponMovementComponent.MoveSpeedRatioByWeaponAccessory_Walk = 0x13c // float (Size: 0x4)
SGWeaponMovementComponent.MoveSpeedRatioByWeaponAccessory_Sprint = 0x140 // float (Size: 0x4)
SGWeaponMovementComponent.MoveSpeedRatioByWeaponAccessory_SilentWalk = 0x144 // float (Size: 0x4)
SGWeaponMovementComponent.SprintToIdleConefficient = 0x148 // float (Size: 0x4)
SGWeaponMovementComponent.MoveSpeedRatioByMeleeWeapon = 0x14c // float (Size: 0x4)
SGWeaponMovementComponent.LeanRateCoefficient = 0x150 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_Jump = 0x0 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_Prone = 0x4 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_ProneWalk = 0x8 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_Stand = 0xc // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_StandWalk = 0x10 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_Sprint = 0x14 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_Crouch = 0x18 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_CrouchWalk = 0x1c // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_StandBlindFire = 0x20 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_CrouchBlindFire = 0x24 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_SlientWalkFire = 0x28 // float (Size: 0x4)
SGWeaponMovingRatioParams.AccuracyRatio_SlientCrouchWalkFire = 0x2c // float (Size: 0x4)
SGWeaponOrnamentComponent.CurrentOrnament = 0x108 // SGInventory* (Size: 0x8)
SGWeaponOverrideRecoilInfo.ShotCount = 0x0 // uint8_t (Size: 0x1)
SGWeaponOverrideRecoilInfo.ModifyRecoil_Vertical = 0x4 // float (Size: 0x4)
SGWeaponOverrideRecoilInfo.ModifyRecoil_Horizontal = 0x8 // float (Size: 0x4)
SGWeaponParamsTable.SpreadAccuracyRatios = 0x0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponParamsTable.CrosshairAccuracyRatios = 0x30 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponParamsTable.SpreadParamTable = 0x60 // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponParamsTable.RecoilParamTable = 0x88 // FSGWeaponRecoilParams (Size: 0x24)
SGWeaponParamsTable.CameraRecoilParamTable = 0xac // FSGWeaponCameraParams (Size: 0x30)
SGWeaponPostAnimInstance.LocalProxy = 0x2c0 // FSGWeaponPostAnimInstanceProxy (Size: 0x870)
SGWeaponPostAnimInstanceProxy.AnimInstance = 0x860 // SGWeaponPostAnimInstance* (Size: 0x8)
SGWeaponRecoilComponent.RepRecoilInfo = 0x108 // FWeaponRecoilRepInfo (Size: 0x30)
SGWeaponRecoilComponent.bEnableRecoil_Pitch = 0x158 // bool (Size: 0x1)
SGWeaponRecoilComponent.bEnableRecoil_Yaw = 0x159 // bool (Size: 0x1)
SGWeaponRecoilComponent.FirstRecoilToRightChance = 0x15c // float (Size: 0x4)
SGWeaponRecoilComponent.MaxVerticalRecoil = 0x160 // float (Size: 0x4)
SGWeaponRecoilComponent.MaxHorizontalRecoil = 0x164 // float (Size: 0x4)
SGWeaponRecoilComponent.BurstStateEndTime = 0x168 // float (Size: 0x4)
SGWeaponRecoilComponent.bAlwaysUseMaxRandNumber = 0x16c // bool (Size: 0x1)
SGWeaponRecoilComponent.OverrideRecoilInfoList = 0x170 // TArray<FSGWeaponOverrideRecoilInfo> (Size: 0x10)
SGWeaponRecoilComponent.VerticalRecoilSpeedCurve = 0x180 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.HorizontalRecoilSpeedCurve = 0x188 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.RecoilAccuracyRatios = 0x190 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponRecoilComponent.RecoilAccuracyRatios_ShoulderZoom = 0x1c0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponRecoilComponent.RecoilAccuracyRatios_ADS = 0x1f0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponRecoilComponent.MaxVerticalRecoilDisturbRange = 0x220 // float (Size: 0x4)
SGWeaponRecoilComponent.BeginRecoverTime = 0x224 // float (Size: 0x4)
SGWeaponRecoilComponent.RecoverAlgorithm = 0x228 // EESGRecoilRecoverAlgorithm (Size: 0x1)
SGWeaponRecoilComponent.ConfigDisturbRecoverSpeed = 0x22c // float (Size: 0x4)
SGWeaponRecoilComponent.RecoverScale = 0x230 // float (Size: 0x4)
SGWeaponRecoilComponent.ConfigRecoverTime = 0x234 // float (Size: 0x4)
SGWeaponRecoilComponent.MinBeginRecoverSpeed_Yaw = 0x238 // float (Size: 0x4)
SGWeaponRecoilComponent.MinBeginRecoverSpeed_Pitch = 0x23c // float (Size: 0x4)
SGWeaponRecoilComponent.RecoverSpeedCurve = 0x240 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.RecoverParamsOverrideConfig = 0x248 // TMap<...> (Size: 0x50)
SGWeaponRecoilComponent.PadMeshCheckDistance = 0x298 // float (Size: 0x4)
SGWeaponRecoilComponent.ConfigPadMeshRecoilScale_Horizontal = 0x29c // float (Size: 0x4)
SGWeaponRecoilComponent.ConfigPadMeshRecoilScale_Vertical = 0x2a0 // float (Size: 0x4)
SGWeaponRecoilComponent.ConfigPadMeshSpreadScale = 0x2a4 // float (Size: 0x4)
SGWeaponRecoilComponent.IntensityHorizontalValueCurve = 0x2a8 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.IntensityVerticalValueCurve = 0x2b0 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.VerticalRecoilScaleOnMaxVertical = 0x2b8 // float (Size: 0x4)
SGWeaponRecoilComponent.VerticalRecoilOnMaxVertical_Max = 0x2bc // float (Size: 0x4)
SGWeaponRecoilComponent.VerticalRecoilOnMaxVertical_Min = 0x2c0 // float (Size: 0x4)
SGWeaponRecoilComponent.VerticalRecoilValueCurveByShotCount = 0x2c8 // CurveVector* (Size: 0x8)
SGWeaponRecoilComponent.VerticalRecoilDistributionByShotCount = 0x2d0 // FSGRandomDistributionCurve (Size: 0x8)
SGWeaponRecoilComponent.HorizontalRecoilValueCurveByShotCount = 0x2d8 // CurveVector* (Size: 0x8)
SGWeaponRecoilComponent.HorizontalRecoilDistributionByShotCount = 0x2e0 // FSGRandomDistributionCurve (Size: 0x8)
SGWeaponRecoilComponent.MaxVerticalRecoverSpeedInStateRecoil = 0x2e8 // float (Size: 0x4)
SGWeaponRecoilComponent.VerticalRecoilTime = 0x2ec // float (Size: 0x4)
SGWeaponRecoilComponent.MaxHorizonRecoverSpeedInStateRecoil = 0x2f0 // float (Size: 0x4)
SGWeaponRecoilComponent.HorizonRecoilTime = 0x2f4 // float (Size: 0x4)
SGWeaponRecoilComponent.AdapterReocoilOnFireNumCurve = 0x2f8 // CurveFloat* (Size: 0x8)
SGWeaponRecoilComponent.RecoverTimeHandler = 0x3d0 // FTimerHandle (Size: 0x8)
SGWeaponRecoilComponent.CurrentShootingMode = 0x3f0 // EESGWeaponShootingMode (Size: 0x1)
SGWeaponRecoilComponent.RecoverParamsByShootingMode = 0x3f8 // TMap<...> (Size: 0x50)
SGWeaponRecoilComponent.bEnableDataAssetOverride = 0x4bc // bool (Size: 0x1)
SGWeaponRecoilComponent.RecoilAnimConfigDataAssetOverride = 0x4c0 // WeaponRecoilDataSet* (Size: 0x8)
SGWeaponRecoilComponent.ADSFireRecoilAnimConfig = 0x4c8 // FWeaponRecoilAnimConfig (Size: 0x48)
SGWeaponRecoilComponent.ADSFireRecoilAnimConfigInstance = 0x510 // FWeaponRecoilAnimConfigInstance (Size: 0x18)
SGWeaponRecoilComponent.FireRecoilAnimConfig = 0x528 // FWeaponRecoilAnimConfig (Size: 0x48)
SGWeaponRecoilComponent.FireRecoilAnimConfigInstance = 0x570 // FWeaponRecoilAnimConfigInstance (Size: 0x18)
SGWeaponRecoilComponent.RecoilKickEnable_ByFireCount = 0x588 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.RecoilSpringStiffness = 0x30 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.RecoilSpringDamping = 0x34 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.CameraRecoilSpringStiffness = 0x38 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.CameraRecoilSpringDamping = 0x3c // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.DartleRecoilSpringParams = 0x40 // FAnimationSpringOverrideParams (Size: 0x10)
SGWeaponRecoilDataAsset_HD.DartleHandTranslationSpringParams = 0x50 // FAnimationSpringOverrideParams (Size: 0x10)
SGWeaponRecoilDataAsset_HD.bDartleRecoilMode = 0x60 // bool (Size: 0x1)
SGWeaponRecoilDataAsset_HD.DartleCameraRecoilSpringParams = 0x64 // FAnimationSpringOverrideParams (Size: 0x10)
SGWeaponRecoilDataAsset_HD.bDartleCameraRecoilMode = 0x74 // bool (Size: 0x1)
SGWeaponRecoilDataAsset_HD.RecoilForce = 0x78 // FSGForceMagnitudeVector4 (Size: 0x280)
SGWeaponRecoilDataAsset_HD.RecoilDispersion = 0x2f8 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.HandTranslationIntensity = 0x2fc // FVector (Size: 0xc)
SGWeaponRecoilDataAsset_HD.RecoilIntensity = 0x308 // FVector (Size: 0xc)
SGWeaponRecoilDataAsset_HD.CameraTranslationIntensity = 0x314 // FVector (Size: 0xc)
SGWeaponRecoilDataAsset_HD.CameraRotationIntensity = 0x320 // FVector (Size: 0xc)
SGWeaponRecoilDataAsset_HD.RecoilScaleByShootCount = 0x330 // CurveVector* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.RecoilScaleByAdsShootCount = 0x338 // CurveVector* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.FOVCurve = 0x340 // FRuntimeFloatCurve (Size: 0x88)
SGWeaponRecoilDataAsset_HD.Delay = 0x3c8 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.AimingAlignSpeed = 0x3cc // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.AccuracyMessing = 0x3d0 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.SpreadStrengthRange = 0x3d4 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.VerticalAttributeToUpForce = 0x3d8 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.HorizontalAttributeToBackForce = 0x3e0 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.HorizontalAttributeToDispersion = 0x3e8 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.HorizontalAttributeToSpreadForce = 0x3f0 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.AccuracyAttributeToSpreadStiffness = 0x3f8 // CurveFloat* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.ScopeScaleCurve = 0x400 // CurveVector* (Size: 0x8)
SGWeaponRecoilDataAsset_HD.SightScaleOverrideMap = 0x408 // TMap<...> (Size: 0x50)
SGWeaponRecoilDataAsset_HD.SightAdsSwayScaleMap = 0x458 // TMap<...> (Size: 0x50)
SGWeaponRecoilDataAsset_HD.WeaponShakePivotSocket = 0x4a8 // FName (Size: 0x8)
SGWeaponRecoilDataAsset_HD.WeaponShakeTranslationSpringParams = 0x4b0 // FAnimationSpringOverrideParamsV4 (Size: 0x30)
SGWeaponRecoilDataAsset_HD.WeaponShakeRotationSpringParams = 0x4e0 // FAnimationSpringOverrideParamsV4 (Size: 0x30)
SGWeaponRecoilDataAsset_HD.WeaponShakeForce = 0x510 // FSGForceMagnitudeVector4 (Size: 0x280)
SGWeaponRecoilDataAsset_HD.WeaponShakeTranslationIntensity = 0x790 // FVector (Size: 0xc)
SGWeaponRecoilDataAsset_HD.WeaponShakeRotationIntensity = 0x7a0 // FVector4 (Size: 0x10)
SGWeaponRecoilDataAsset_HD.WeaponShakeTranslationForce = 0x7b0 // FSGForceMagnitudeVector4 (Size: 0x280)
SGWeaponRecoilDataAsset_HD.WeaponShakeRotationForce = 0xa30 // FSGForceMagnitudeVector4 (Size: 0x280)
SGWeaponRecoilDataAsset_HD.RecoilBackForceRange = 0xcb0 // FVector2D (Size: 0x8)
SGWeaponRecoilDataAsset_HD.RecoilUpForceRange = 0xcb8 // FVector2D (Size: 0x8)
SGWeaponRecoilDataAsset_HD.RecoilBackForceCurve = 0xcc0 // FRuntimeFloatCurve (Size: 0x88)
SGWeaponRecoilDataAsset_HD.RecoilUpForceCurve = 0xd48 // FRuntimeFloatCurve (Size: 0x88)
SGWeaponRecoilDataAsset_HD.AccuracyRecoverDelay = 0xdd0 // float (Size: 0x4)
SGWeaponRecoilDataAsset_HD.AccuracyRecoverSpeed = 0xdd4 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilTime = 0x0 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilUpMin = 0x4 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilUpModifier = 0x8 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilUpMax = 0xc // float (Size: 0x4)
SGWeaponRecoilParams.RecoilUpTotalMax = 0x10 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilSideMin = 0x14 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilSideModifier = 0x18 // float (Size: 0x4)
SGWeaponRecoilParams.RecoilSideMax = 0x1c // float (Size: 0x4)
SGWeaponRecoilParams.RecoilSideRange = 0x20 // float (Size: 0x4)
SGWeaponRenderView.RotateAngularSpeedYaw = 0x650 // float (Size: 0x4)
SGWeaponRenderView.RotateAngularSpeedPitch = 0x654 // float (Size: 0x4)
SGWeaponRenderView.RotateInertiaInterpSpeed = 0x658 // float (Size: 0x4)
SGWeaponRenderView.ClearRotateInertiaDelay = 0x65c // float (Size: 0x4)
SGWeaponRenderView.MaxTouchTimeSpanForClick = 0x660 // float (Size: 0x4)
SGWeaponRenderView.MaxTimeGapForDoubleClick = 0x664 // float (Size: 0x4)
SGWeaponRenderView.RotationResetInterpSpeed = 0x668 // float (Size: 0x4)
SGWeaponRenderView.MaxPitch = 0x68c // float (Size: 0x4)
SGWeaponRenderView.MaxYaw = 0x690 // float (Size: 0x4)
SGWeaponRenderView.MaxRoll = 0x694 // float (Size: 0x4)
SGWeaponRenderView.MinPitch = 0x698 // float (Size: 0x4)
SGWeaponRenderView.MinYaw = 0x69c // float (Size: 0x4)
SGWeaponRenderView.MinRoll = 0x6a0 // float (Size: 0x4)
SGWeaponRenderView.RotChangeSpeed = 0x6a4 // float (Size: 0x4)
SGWeaponRenderView.PosChangeSpeed = 0x6a8 // float (Size: 0x4)
SGWeaponRenderView.FixCamMaxPosX = 0x6ac // float (Size: 0x4)
SGWeaponRenderView.FixCamMinPosX = 0x6b0 // float (Size: 0x4)
SGWeaponRenderView.FixCamFullScreenPosX = 0x6b4 // float (Size: 0x4)
SGWeaponRenderView.FocusCamPosXScale = 0x6b8 // float (Size: 0x4)
SGWeaponRenderView.Tolerance = 0x6bc // float (Size: 0x4)
SGWeaponRenderView.OnePEffectDis = 0x6c0 // float (Size: 0x4)
SGWeaponRenderView.PinchSpeed = 0x6c4 // float (Size: 0x4)
SGWeaponRenderView.MinPinchDisPercent = 0x6c8 // float (Size: 0x4)
SGWeaponRenderView.MaxPinchDisPercent = 0x6cc // float (Size: 0x4)
SGWeaponRenderView.PartFullFillPercent = 0x6d0 // float (Size: 0x4)
SGWeaponRenderView.FocusDistance = 0x6d4 // float (Size: 0x4)
SGWeaponRenderView.DefaultWeaponRotAfterFocus = 0x6d8 // FRotator (Size: 0xc)
SGWeaponRenderView.CamActorClass = 0x6e8 // ClassProperty (Size: 0x8)
SGWeaponRenderView.FullCamPullClosePercent = 0x6f0 // float (Size: 0x4)
SGWeaponRenderView.RenderOverTime = 0x6f4 // float (Size: 0x4)
SGWeaponRenderView.Debug = 0x6fc // bool (Size: 0x1)
SGWeaponRenderView.CameraOffsetCurve = 0x700 // CurveVector* (Size: 0x8)
SGWeaponRenderView.FinishAssembleWeaponEndRot = 0x708 // FRotator (Size: 0xc)
SGWeaponRenderView.FinishAssembleWeaponStartRot = 0x714 // FRotator (Size: 0xc)
SGWeaponRenderView.AccelOfFinishAssembleAnim = 0x720 // float (Size: 0x4)
SGWeaponRenderView.InitSpeedOfFinishAssembleAnim = 0x724 // float (Size: 0x4)
SGWeaponRenderView.NewSpeedOfFinishAssembleAnim = 0x728 // float (Size: 0x4)
SGWeaponRenderView.StartChangeSpeedTime = 0x72c // float (Size: 0x4)
SGWeaponRenderView.CameraPos = 0x730 // FVector (Size: 0xc)
SGWeaponRenderView.DefaultWeaponLength = 0x73c // float (Size: 0x4)
SGWeaponRenderView.PosOffsetOfFinalState = 0x740 // FVector (Size: 0xc)
SGWeaponRenderView.WeaponPosOffsetOfStateFocus = 0x74c // FVector (Size: 0xc)
SGWeaponRenderView.IgnoreRotateSockets = 0x758 // TArray<FName> (Size: 0x10)
SGWeaponRenderView.IgnoreRotateWeapons = 0x768 // TArray<int32_t> (Size: 0x10)
SGWeaponRenderView.CenterPosOffset = 0x778 // float (Size: 0x4)
SGWeaponRenderView.MaxConeAngle = 0x77c // float (Size: 0x4)
SGWeaponRenderView.BaseWeaponLen = 0x780 // float (Size: 0x4)
SGWeaponRenderView.MaterialTemplate = 0x788 // MaterialInterface* (Size: 0x8)
SGWeaponRenderView.PivotComp = 0x790 // SceneComponent* (Size: 0x8)
SGWeaponRenderView.CamActor = 0x798 // CameraActor* (Size: 0x8)
SGWeaponRenderView.SGPlayerController = 0x7a0 // SGPlayerController* (Size: 0x8)
SGWeaponRenderView.LastOutlinedMeshComp = 0x7a8 // TArray<MeshComponent*> (Size: 0x10)
SGWeaponRenderView.CurrentAssembleWeapon = 0x7b8 // SGInventory* (Size: 0x8)
SGWeaponRenderView.AllActors = 0x7c0 // TArray<Actor*> (Size: 0x10)
SGWeaponRenderView.SkyLightActors = 0x7d0 // TArray<Actor*> (Size: 0x10)
SGWeaponRenderView.DirectionalLightActors = 0x7e0 // TArray<Actor*> (Size: 0x10)
SGWeaponRenderView.AllActorComps = 0x7f0 // TArray<ActorComponent*> (Size: 0x10)
SGWeaponRenderView.SpotLightComponent = 0x800 // SpotLightComponent* (Size: 0x8)
SGWeaponRenderView.SceneCaptureComp = 0x808 // SceneCaptureComponent2D* (Size: 0x8)
SGWeaponRenderView.BGComp = 0x810 // StaticMeshComponent* (Size: 0x8)
SGWeaponRenderView.WeaponRotBeforeFocus = 0x880 // FRotator (Size: 0xc)
SGWeaponRepAnimInfo.CharacterMontageParams = 0x0 // FSGMontagePlayParams (Size: 0x48)
SGWeaponRepAnimInfo.WeaponMontageParams = 0x48 // FSGMontagePlayParams (Size: 0x48)
SGWeaponRepAnimInfo.AdapterAnimationList = 0x90 // TArray<FSGWeaponSpecialSpecAdapterAnimation> (Size: 0x10)
SGWeaponRepAnimInfo.Timestamp = 0xa0 // float (Size: 0x4)
SGWeaponRepAnimInfo.BlendOutTime = 0xa4 // float (Size: 0x4)
SGWeaponRepAnimInfo.PlayBit = 0xa8 // uint8_t (Size: 0x1)
SGWeaponRepAnimInfo.bJumpSection = 0xa8 // uint8_t (Size: 0x1)
SGWeaponRepAnimInfo.PlayConfig = 0xb0 // FSGMontagePlayConfig (Size: 0x18)
SGWeaponRepAnimInfo.Dependencies = 0xc8 // TArray<FRepDependency> (Size: 0x10)
SGWeaponRepInfo.RepCount = 0x0 // float (Size: 0x4)
SGWeaponRepInfo.EventType = 0x4 // EESGInnerWeaponEvent (Size: 0x1)
SGWeaponRepInfo.EventObject = 0x8 // Object* (Size: 0x8)
SGWeaponRepInfo.RepTime = 0x10 // float (Size: 0x4)
SGWeaponRepInfoInner.bShouldReserveLastWeapon = 0x0 // bool (Size: 0x1)
SGWeaponRepInfoInner.CurrentWeapon = 0x8 // SGInventory* (Size: 0x8)
SGWeaponRepInfoInner.Count = 0x10 // int32_t (Size: 0x4)
SGWeaponRepStopAnimInfo.CharacterMontageParams = 0x0 // FSGMontagePlayParams (Size: 0x48)
SGWeaponRepStopAnimInfo.WeaponMontageParams = 0x48 // FSGMontagePlayParams (Size: 0x48)
SGWeaponRepStopAnimInfo.Timestamp = 0x90 // float (Size: 0x4)
SGWeaponRepStopAnimInfo.BlendOutTime = 0x94 // float (Size: 0x4)
SGWeaponScopeRenderComponent.bEnable = 0xa72 // bool (Size: 0x1)
SGWeaponScopeRenderComponent.Level = 0xa74 // int32_t (Size: 0x4)
SGWeaponSettings_HD.MaterialAntiPenetrationMap = 0x48 // TMap<...> (Size: 0x50)
SGWeaponSettings_HD.FireParticlePrimeSize = 0x98 // uint32_t (Size: 0x4)
SGWeaponSettings_HD.BulletShellParticlePrimeSize = 0x9c // uint32_t (Size: 0x4)
SGWeaponSettings_HD.BulletTraceParticlePrimeSize = 0xa0 // uint32_t (Size: 0x4)
SGWeaponSettings_HD.ImpactAoDecalMaterial = 0xa8 // FSoftObjectPath (Size: 0x18)
SGWeaponSettings_HD.ImpactColorSettingMap = 0xc0 // TMap<...> (Size: 0x50)
SGWeaponSettings_HD.ImpactAoDecalMaterialObj = 0x110 // MaterialInterface* (Size: 0x8)
SGWeaponSkinStainData.SkinID = 0x0 // int32_t (Size: 0x4)
SGWeaponSkinStainData.AdapterItemID = 0x4 // int32_t (Size: 0x4)
SGWeaponSkinStainData.Mesh = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponSkinStainData.OverrideBaseMaterial = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponSkinStainData.bStaticMesh = 0x58 // bool (Size: 0x1)
SGWeaponSkinStainData.MaterialParameters = 0x60 // TArray<FSGMaterialParameters> (Size: 0x10)
SGWeaponSoundComponent.SpecialStanceSwitchName = 0x130 // FString (Size: 0x10)
SGWeaponSoundComponent.ExtraSwitchPair = 0x140 // TMap<...> (Size: 0x50)
SGWeaponSpecialSpecAdapterAnimation.Adapter = 0x0 // SGInventory* (Size: 0x8)
SGWeaponSpecialSpecAdapterAnimation.Animation = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponSpecialSpecAnimation.CharacterAnim = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponSpecialSpecAnimation.WeaponAnim = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponSpecialSpecAnimation.AdapterAnim = 0x50 // TArray<FSGWeaponSpecialSpecAdapterAnimation> (Size: 0x10)
SGWeaponSpecialSpecAnimationRow.WeaponSkinID = 0x8 // int32_t (Size: 0x4)
SGWeaponSpecialSpecAnimationRow.SkinGroup = 0x10 // TArray<int32_t> (Size: 0x10)
SGWeaponSpecialSpecAnimationRow.InvIDGroup = 0x20 // TArray<int32_t> (Size: 0x10)
SGWeaponSpecialSpecAnimationRow.Priority = 0x30 // int32_t (Size: 0x4)
SGWeaponSpecialSpecAnimationRow.OverrideAnimEnum = 0x34 // EESpecialSpecAnimType (Size: 0x1)
SGWeaponSpecialSpecAnimationRow.SpecialSpecAnimationList = 0x38 // TArray<FSpecialSpecAnimation> (Size: 0x10)
SGWeaponSpreadComponent.SpreadShowScale = 0x110 // float (Size: 0x4)
SGWeaponSpreadComponent.NormalShotSpreadRatio = 0x114 // float (Size: 0x4)
SGWeaponSpreadComponent.SpreadInterpSpeed = 0x118 // float (Size: 0x4)
SGWeaponSpreadComponent.SpreadParams = 0x11c // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponSpreadComponent.SpreadParams_ShoulderZoom = 0x144 // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponSpreadComponent.SpreadRadiusPDF = 0x170 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.SpreadAnglePDF = 0x178 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.SpreadRadiusScaleCurve = 0x180 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.SpreadScaleForArmBreak = 0x188 // float (Size: 0x4)
SGWeaponSpreadComponent.ReduceSpreadValueWhenJump = 0x18c // float (Size: 0x4)
SGWeaponSpreadComponent.ReduceSpreadValueEndJumpDelayTime = 0x190 // float (Size: 0x4)
SGWeaponSpreadComponent.ReduceSpreadValueWhenSprint = 0x194 // float (Size: 0x4)
SGWeaponSpreadComponent.ReduceSpreadValueEndSprintDelayTime = 0x198 // float (Size: 0x4)
SGWeaponSpreadComponent.UpEnergyInfluenceToSpreadValue = 0x1a0 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.BuckshotSpreadParams = 0x1a8 // FSGWeaponSpreadParams (Size: 0x28)
SGWeaponSpreadComponent.BuckshotSpreadAccuracyRatios = 0x1d0 // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponSpreadComponent.BuckshotSpreadRadiusPDF = 0x200 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.BuckshotSpreadAnglePDF = 0x208 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.InnerRadiusScaleWhenMultiShots = 0x210 // float (Size: 0x4)
SGWeaponSpreadComponent.OutterRadiusScaleWhenMultiShots = 0x214 // float (Size: 0x4)
SGWeaponSpreadComponent.ShotNumInInnerRadiusPercent = 0x218 // float (Size: 0x4)
SGWeaponSpreadComponent.SpreadToGunRotScale = 0x22c // float (Size: 0x4)
SGWeaponSpreadComponent.AccuracyValue = 0x230 // float (Size: 0x4)
SGWeaponSpreadComponent.AccuracyValue_Multiplier = 0x234 // float (Size: 0x4)
SGWeaponSpreadComponent.AccuracyPunishRatio_Multiplier = 0x238 // float (Size: 0x4)
SGWeaponSpreadComponent.AccToSpreadScaleCurve = 0x240 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.ShootAimingSpreadValue = 0x248 // float (Size: 0x4)
SGWeaponSpreadComponent.SpreadAccuracyRatios = 0x24c // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponSpreadComponent.SpreadAccuracyRatios_ShoulderZoom = 0x27c // FSGWeaponMovingRatioParams (Size: 0x30)
SGWeaponSpreadComponent.MaxSpreadGunRotValue = 0x2ac // float (Size: 0x4)
SGWeaponSpreadComponent.GunRotSpeed = 0x2b0 // float (Size: 0x4)
SGWeaponSpreadComponent.AdsMoaX = 0x2b4 // float (Size: 0x4)
SGWeaponSpreadComponent.AdsMoaY = 0x2b8 // float (Size: 0x4)
SGWeaponSpreadComponent.AdapterMoaScaleX_Multiplier = 0x2bc // float (Size: 0x4)
SGWeaponSpreadComponent.AdapterMoaScaleY_Multiplier = 0x2c0 // float (Size: 0x4)
SGWeaponSpreadComponent.MoaPDF = 0x2c8 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.MoaScaleCurveByShootCount = 0x2d0 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.MoaCurveForMultiShots = 0x2d8 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.MoaCurveForOneShot = 0x2e0 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.AngleOfOneMoa = 0x2f8 // float (Size: 0x4)
SGWeaponSpreadComponent.MoaBiasRadius = 0x2fc // float (Size: 0x4)
SGWeaponSpreadComponent.MoaConvertCurve = 0x388 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.AccuracyConvertCurve = 0x390 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.MoaPhiDistributionCurve = 0x398 // CurveFloat* (Size: 0x8)
SGWeaponSpreadComponent.SpreadData = 0x3a0 // SGWeaponSpreadDataAsset_HD* (Size: 0x8)
SGWeaponSpreadComponent.NonAdsMOA = 0x3a8 // float (Size: 0x4)
SGWeaponSpreadComponent.MoaFinalScale = 0x3ac // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.SpreadRange = 0x30 // FVector2D (Size: 0x8)
SGWeaponSpreadDataAsset_HD.FireRatioGainMax = 0x38 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.FireRatioGrowth = 0x3c // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.FireRatioRecoverSpeed = 0x40 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.FireRatioRecoverDelay = 0x44 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.StandRatio = 0x48 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.CrouchRatio = 0x4c // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.ProneRatio = 0x50 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.StanceRatiosBlendTime = 0x54 // float (Size: 0x4)
SGWeaponSpreadDataAsset_HD.AccuracyToSpreadCurve = 0x58 // CurveFloat* (Size: 0x8)
SGWeaponSpreadDataAsset_HD.MoveSpeedToSpreadRatioCurve = 0x60 // CurveFloat* (Size: 0x8)
SGWeaponSpreadParams.SpreadMin = 0x0 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadMax = 0x4 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadModifierBase = 0x8 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadModifierInc = 0xc // float (Size: 0x4)
SGWeaponSpreadParams.SpreadModifierMax = 0x10 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadIncreaseSpeed = 0x14 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadIncreaseSpeed_Firing = 0x18 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadDecreaseSpeed = 0x1c // float (Size: 0x4)
SGWeaponSpreadParams.SpreadDecreaseSpeed_Firing = 0x20 // float (Size: 0x4)
SGWeaponSpreadParams.SpreadDelayRecoverTime = 0x24 // float (Size: 0x4)
SGWeaponStateComponent.WeaponEquipWithChargeTime = 0x100 // float (Size: 0x4)
SGWeaponStateComponent.WeaponUnequipTime = 0x104 // float (Size: 0x4)
SGWeaponStateComponent.WeaponChangeClipTime = 0x108 // float (Size: 0x4)
SGWeaponStateComponent.WeaponAddMagazineTime = 0x10c // float (Size: 0x4)
SGWeaponStateComponent.WeaponChangeClipTimeMap = 0x110 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.WeaponOutMagazineAnimationTimeMap = 0x160 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.WeaponAddCommonMagazineTime = 0x1b0 // float (Size: 0x4)
SGWeaponStateComponent.bOverrideAddMagazineAnimTime = 0x1b4 // bool (Size: 0x1)
SGWeaponStateComponent.WeaponAddMagazineTimeMap = 0x1b8 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.WeaponAddMagazineAnimationTimeMap = 0x208 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.bOverrideEmptyBoreAddMagazineAnimTime = 0x258 // bool (Size: 0x1)
SGWeaponStateComponent.WeaponEmptyBoreAddMagazineTimeMap = 0x260 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.WeaponCheckCommonMagazineTime = 0x2b0 // float (Size: 0x4)
SGWeaponStateComponent.bOverrideCheckMagazineAnimTime = 0x2b4 // bool (Size: 0x1)
SGWeaponStateComponent.WeaponCheckMagazineTimeMap = 0x2b8 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.WeaponCheckMagazineAnimationTimeMap = 0x308 // TMap<...> (Size: 0x50)
SGWeaponStateComponent.OpenBoltBeforeReloadingTimeSeconds = 0x358 // float (Size: 0x4)
SGWeaponStateComponent.CloseBoltBeforeReloadingTimeSeconds = 0x35c // float (Size: 0x4)
SGWeaponStateComponent.FireDecreaseHearingEndurance = 0x360 // float (Size: 0x4)
SGWeaponStateComponent.MagazineCheckTime = 0x364 // float (Size: 0x4)
SGWeaponStateComponent.CheckMagTimeFromAdapterRatio = 0x368 // float (Size: 0x4)
SGWeaponStateComponent.OneByOneChangeClipTime_Loop_PerBullet = 0x36c // float (Size: 0x4)
SGWeaponStateComponent.OneByOneChangeClipTime_End = 0x370 // float (Size: 0x4)
SGWeaponStateComponent.OneByOneReloadScale = 0x374 // float (Size: 0x4)
SGWeaponStateComponent.WeaponPullBoltTime = 0x378 // float (Size: 0x4)
SGWeaponStateComponent.bOverrideReleaseHoldOpenAnimTime = 0x37c // bool (Size: 0x1)
SGWeaponStateComponent.WeaponReleaseHoldOpenTime = 0x380 // float (Size: 0x4)
SGWeaponStateComponent.BaseLeverSpeed = 0x384 // float (Size: 0x4)
SGWeaponStateComponent.AssembledLeverSpeed = 0x388 // float (Size: 0x4)
SGWeaponStateComponent.ErgoLeverSpeed = 0x390 // CurveFloat* (Size: 0x8)
SGWeaponStateComponent.WeaponSwitchFireModeTime = 0x398 // float (Size: 0x4)
SGWeaponStateComponent.HoldOpenTimeAfterFire = 0x39c // float (Size: 0x4)
SGWeaponStateComponent.bEnable = 0x3a0 // bool (Size: 0x1)
SGWeaponSwayADSInfo.SmoothAngularVelocityInterpSpeed = 0x0 // float (Size: 0x4)
SGWeaponSwayADSInfo.AngularVelocityNormalizedRange_Yaw = 0x4 // FVector2D (Size: 0x8)
SGWeaponSwayADSInfo.AngularVelocityNormalizedRange_Pitch = 0xc // FVector2D (Size: 0x8)
SGWeaponSwayADSInfo.ADSWeaponSwayClamp_Yaw = 0x14 // FVector2D (Size: 0x8)
SGWeaponSwayADSInfo.ADSWeaponSwayClamp_Pitch = 0x1c // FVector2D (Size: 0x8)
SGWeaponSwayADSInfo.WeaponSwayDelay_Yaw = 0x24 // float (Size: 0x4)
SGWeaponSwayADSInfo.WeaponSwayDelay_Pitch = 0x28 // float (Size: 0x4)
SGWeaponSwayADSInfo.WeaponSwayOffsetScaler_ADS = 0x2c // float (Size: 0x4)
SGWeaponSwayADSInfo.WeaponSwayADSScaler_Yaw = 0x30 // CurveFloat* (Size: 0x8)
SGWeaponSwayADSInfo.WeaponSwayADSScaler_Pitch = 0x38 // CurveFloat* (Size: 0x8)
SGWeaponSwayADSInfo.WeaponSwayADSScaler_FOV = 0x40 // CurveFloat* (Size: 0x8)
SGWeaponSwayADSInfo.WeaponSwayClampCurve_Yaw = 0x48 // CurveFloat* (Size: 0x8)
SGWeaponSwayADSInfo.WeaponSwayClampCurve_Pitch = 0x50 // CurveFloat* (Size: 0x8)
SGWeaponSwaySpringInfo.SpringStiffness = 0x0 // float (Size: 0x4)
SGWeaponSwaySpringInfo.SpringDamping = 0x4 // float (Size: 0x4)
SGWeaponSwaySpringInfo.SpringClamp = 0x8 // float (Size: 0x4)
SGWeaponSwaySpringInfo.SpringAlpha = 0xc // float (Size: 0x4)
SGWeaponSwaySpringInfo.SpringInterpSpeed = 0x10 // float (Size: 0x4)
SGWeaponSwaySpringInfo.SpringPivotOffset = 0x14 // FVector (Size: 0xc)
SGWeaponSwaySpringInfo.AngularVelocityToMaxWeaponShake = 0x20 // float (Size: 0x4)
SGWeaponTacticalInvStateComponent.ZeroingDistance = 0x148 // float (Size: 0x4)
SGWeaponTimerComponent.WeaponTimerHandler = 0x100 // FTimerHandle (Size: 0x8)
SGWeaponTimerComponent.TimerInterval = 0x108 // float (Size: 0x4)
SGWeaponTypeComponent.WeaponType = 0x100 // EESGWeaponType (Size: 0x1)
SGWeaponTypeComponent.SpecialWeaponSubType = 0x101 // EESGSpecialWeaponSubType (Size: 0x1)
SGWeaponTypeComponent.GunWeaponSubType = 0x102 // EESGGunWeaponSubType (Size: 0x1)
SGWeaponTypeComponent.bUsedAsLeftHandWeapon = 0x103 // bool (Size: 0x1)
SGWeaponValidationComponent.FireIntervalCheckMaxTolerance = 0x100 // float (Size: 0x4)
SGWeaponValidationComponent.FireIntervalCheckFailPunishShots = 0x104 // int32_t (Size: 0x4)
SGWeaponValidationComponent.FireIntervalCheckFailPunishDuration = 0x108 // float (Size: 0x4)
SGWeaponValidationComponent.AmmoCountCheckFailPunishShots = 0x10c // int32_t (Size: 0x4)
SGWeaponValidationComponent.MaxPlayerOwnerDistanceToleranceSq = 0x110 // float (Size: 0x4)
SGWeaponValidationComponent.MaxDriverDistanceToleranceSq = 0x114 // float (Size: 0x4)
SGWeaponValidationComponent.MaxTargetDistanceToleranceSq = 0x118 // float (Size: 0x4)
SGWeaponValidationComponent.MaxHitPointDistanceToleranceSq = 0x11c // float (Size: 0x4)
SGWeaponValidationComponent.ClientRotationCosTolerance = 0x120 // float (Size: 0x4)
SGWeaponValidationComponent.ServerRotationCosTolerance = 0x124 // float (Size: 0x4)
SGWeaponValidationComponent.NoBlockActorType = 0x128 // TArray<ClassProperty> (Size: 0x10)
SGWeaponValidationComponent.bUseLagCompensation = 0x138 // bool (Size: 0x1)
SGWeaponValidationComponent.CurHitTarget = 0x148 // Actor* (Size: 0x8)
SGWeaponX5EffectComponent.TwinkleEmitterTemplate = 0x108 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponX5EffectComponent.PSC = 0x130 // ParticleSystemComponent* (Size: 0x8)
SGWeaponZoomComponent.WeaponZoomTime = 0x110 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomTime = 0x114 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomTimeInTacticalTransitionState = 0x118 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomTimeWhenHandDown = 0x11c // float (Size: 0x4)
SGWeaponZoomComponent.ScopeAdsScale = 0x120 // float (Size: 0x4)
SGWeaponZoomComponent.CameraBaseCharacterSocket = 0x124 // FName (Size: 0x8)
SGWeaponZoomComponent.AimLimitPlaneSocketName = 0x12c // FName (Size: 0x8)
SGWeaponZoomComponent.bOnlyAdsOnSupport = 0x134 // bool (Size: 0x1)
SGWeaponZoomComponent.Curve_ZoominOffset = 0x138 // CurveVector* (Size: 0x8)
SGWeaponZoomComponent.Curve_ZoominRotation = 0x140 // CurveVector* (Size: 0x8)
SGWeaponZoomComponent.Curve_ZoomOutOffset = 0x148 // CurveVector* (Size: 0x8)
SGWeaponZoomComponent.Curve_ZoomOutRotation = 0x150 // CurveVector* (Size: 0x8)
SGWeaponZoomComponent.ZoomInAnimation_GripBased = 0x158 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomOutAnimation_GripBased = 0x180 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomInAnimation_GripBased_TacticalPistol = 0x1a8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomOutAnimation_GripBased_TacticalPistol = 0x1d0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomInAnimation_3P_GripBased = 0x1f8 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomOutAnimation_3P_GripBased = 0x220 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomInAnimation_3P_Prone_GripBased = 0x248 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.ZoomOutAnimation_3P_Prone_GripBased = 0x270 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.TacticalZoomInAnimation_3P_GripBased = 0x298 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.TacticalZoomOutAnimation_3P_GripBased = 0x2c0 // TSoftObjectPtr<UObject> (Size: 0x28)
SGWeaponZoomComponent.WeaponZoomAnimTime = 0x2e8 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomAnimTime = 0x2ec // float (Size: 0x4)
SGWeaponZoomComponent.ZoomOffset_Location_3P = 0x300 // FVector (Size: 0xc)
SGWeaponZoomComponent.bEnableZoomFOVOptimization = 0x30c // bool (Size: 0x1)
SGWeaponZoomComponent.WeaponZoomFOVBlendTime = 0x310 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomFOVBlendTime = 0x314 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponZoomFOVBlendDelay = 0x318 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomFOVBlendDelay = 0x31c // float (Size: 0x4)
SGWeaponZoomComponent.WeaponZoomDualFOVBlendTime = 0x320 // float (Size: 0x4)
SGWeaponZoomComponent.WeaponUnZoomDualFOVBlendTime = 0x324 // float (Size: 0x4)
SGWeaponZoomComponent.DualFOVBlendInCurve = 0x328 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.DualFOVBlendOutCurve = 0x330 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.SceneFOVBlendInCurve = 0x338 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.SceneFOVBlendOutCurve = 0x340 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.DualFOVEnterLeaveMachine = 0x348 // FSGEnterLoopLeaveStateMachine (Size: 0x24)
SGWeaponZoomComponent.SceneFOVEnterLeaveMachine = 0x36c // FSGEnterLoopLeaveStateMachine (Size: 0x24)
SGWeaponZoomComponent.Curve_SwitchScope = 0x390 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.SwitchScopeParams = 0x398 // TArray<FWeaponSwitchScopeParams> (Size: 0x10)
SGWeaponZoomComponent.MaxRecoilRotator = 0x3a8 // FRotator (Size: 0xc)
SGWeaponZoomComponent.RecoilPitchScale = 0x3b4 // float (Size: 0x4)
SGWeaponZoomComponent.RecoilYawScale = 0x3b8 // float (Size: 0x4)
SGWeaponZoomComponent.RecoilRollScale = 0x3bc // float (Size: 0x4)
SGWeaponZoomComponent.GunRotSpeed = 0x3c0 // float (Size: 0x4)
SGWeaponZoomComponent.ErgonomicsBase = 0x3c4 // float (Size: 0x4)
SGWeaponZoomComponent.ErgADSTimeScaleCurve = 0x3c8 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.ErgADSSceneFOVTimeScaleCurve = 0x3d0 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.ErgADSDualFOVTimeScaleCurve = 0x3d8 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.ErgEnergyCostScaleCurve = 0x3e0 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.ErgBreathScaleCurve = 0x3e8 // CurveFloat* (Size: 0x8)
SGWeaponZoomComponent.bSupportShoulderZoom = 0x3f0 // bool (Size: 0x1)
SGWeaponZoomComponent.ZoomingType = 0x3f1 // EESGZoomType (Size: 0x1)
SGWeaponZoomComponent.AimScale = 0x3f4 // float (Size: 0x4)
SGWeaponZoomComponent.ZoomProgressRate = 0x404 // float (Size: 0x4)
SGWeaponZoomComponent.MaterialCollection = 0x440 // MaterialParameterCollection* (Size: 0x8)
SGWeaponZoomComponent.AimingBaseLocalPositionName = 0x448 // FName (Size: 0x8)
SGWeaponZoomComponent.AimingBaseWorldPositionName = 0x450 // FName (Size: 0x8)
SGWeaponZoomComponent.AimingBaseCameraPositionName = 0x458 // FName (Size: 0x8)
SGWeaponZoomComponent.bCachedZoom = 0x460 // bool (Size: 0x1)
SGWeaponZoomComponent.AfterFiringDelta = 0x464 // float (Size: 0x4)
SGWeaponZoomComponent.LastSight = 0x490 // SGInventory* (Size: 0x8)
SGWeaponZoomComponent.LastSight_OnCurrentSightChangedInternalUse = 0x498 // SGInventory* (Size: 0x8)
SGWeaponZoomComponent.ZoomingCheckThreshold = 0x4b0 // float (Size: 0x4)
SGWeaponZoomComponent.ScopeMagnification = 0x578 // float (Size: 0x4)
SGWheeledVehicle.bIsSpeedUp = 0x3a1 // bool (Size: 0x1)
SGWheeledVehicle.bFirstCam = 0x3a2 // bool (Size: 0x1)
SGWheeledVehicle.bWhistle = 0x3a3 // bool (Size: 0x1)
SGWheeledVehicle.OverlappingCharacters = 0x440 // TArray<SGCharacter*> (Size: 0x10)
SGWheeledVehicle.bEnableClientReportHitDamageCfg = 0x450 // bool (Size: 0x1)
SGWheeledVehicle.bEnableClientReportHitDamage = 0x451 // bool (Size: 0x1)
SGWheeledVehicle.OnVehicleHitDamage = 0x458 // FMulticastInlineDelegate (Size: 0x10)
SGWheeledVehicle.BPConfigVehicleType = 0x468 // EESGVehicleType (Size: 0x1)
SGWheeledVehicle.VehicleSeatData = 0x470 // FVehicleSeatData (Size: 0x40)
SGWheeledVehicle.ExtendSeatCount = 0x4b0 // int32_t (Size: 0x4)
SGWheeledVehicle.SGWheeledMovementComp = 0x4b8 // SGWheeledVehicleMovementComponent* (Size: 0x8)
SGWheeledVehicle.SpringArm = 0x4c0 // SpringArmComponent* (Size: 0x8)
SGWheeledVehicle.EllipseMinDistance = 0x4c8 // float (Size: 0x4)
SGWheeledVehicle.Camera = 0x4d0 // CameraComponent* (Size: 0x8)
SGWheeledVehicle.CameraFirstPerson = 0x4d8 // CameraComponent* (Size: 0x8)
SGWheeledVehicle.FuelComponent = 0x4e0 // VehicleFuelComponent* (Size: 0x8)
SGWheeledVehicle.BoxCollisionForPawn = 0x4e8 // BoxComponent* (Size: 0x8)
SGWheeledVehicle.BoxOverlapFront = 0x4f0 // BoxComponent* (Size: 0x8)
SGWheeledVehicle.BoxOverlapBack = 0x4f8 // BoxComponent* (Size: 0x8)
SGWheeledVehicle.HitPawnDamageVelocityThreshold = 0x500 // float (Size: 0x4)
SGWheeledVehicle.HitWallDamageVelocityThreshold = 0x504 // float (Size: 0x4)
SGWheeledVehicle.HitWallPassengerHurtDamageCurve = 0x508 // CurveFloat* (Size: 0x8)
SGWheeledVehicle.HitWallVehicleHurtDamageCurve = 0x510 // CurveFloat* (Size: 0x8)
SGWheeledVehicle.HitWallDamageMaxPitch = 0x518 // float (Size: 0x4)
SGWheeledVehicle.DestroyFenceSpeedThreshold = 0x520 // float (Size: 0x4)
SGWheeledVehicle.TurnOverAngleThreshold = 0x524 // float (Size: 0x4)
SGWheeledVehicle.Broken1WheelSpeedFactor = 0x528 // float (Size: 0x4)
SGWheeledVehicle.Broken2WheelSpeedFactor = 0x52c // float (Size: 0x4)
SGWheeledVehicle.Broken3WheelSpeedFactor = 0x530 // float (Size: 0x4)
SGWheeledVehicle.Broken4WheelSpeedFactor = 0x534 // float (Size: 0x4)
SGWheeledVehicle.BrokenWheelRadius = 0x538 // float (Size: 0x4)
SGWheeledVehicle.BrokenWheelAddForce = 0x53c // float (Size: 0x4)
SGWheeledVehicle.SpeedUpEngineRPMFactor = 0x540 // float (Size: 0x4)
SGWheeledVehicle.TorqueMultiplierForBoosting = 0x544 // float (Size: 0x4)
SGWheeledVehicle.WheelBoneNames = 0x548 // TArray<FName> (Size: 0x10)
SGWheeledVehicle.WheelTireBoneNames = 0x558 // TArray<FName> (Size: 0x10)
SGWheeledVehicle.WheelRadius = 0x568 // float (Size: 0x4)
SGWheeledVehicle.bUseFakeHitWheelHandler = 0x56c // bool (Size: 0x1)
SGWheeledVehicle.bWheel1Broken = 0x56d // bool (Size: 0x1)
SGWheeledVehicle.bWheel2Broken = 0x56e // bool (Size: 0x1)
SGWheeledVehicle.bWheel3Broken = 0x56f // bool (Size: 0x1)
SGWheeledVehicle.bWheel4Broken = 0x570 // bool (Size: 0x1)
SGWheeledVehicle.DeadBodyExistTime = 0x574 // float (Size: 0x4)
SGWheeledVehicle.bVehicleDebugMode = 0x578 // bool (Size: 0x1)
SGWheeledVehicle.bDebugMovementSync = 0x579 // bool (Size: 0x1)
SGWheeledVehicle.InWaterLinearDamping = 0x57c // float (Size: 0x4)
SGWheeledVehicle.NewFinalRatio = 0x580 // float (Size: 0x4)
SGWheeledVehicle.bIngoreMoveForward = 0x584 // bool (Size: 0x1)
SGWheeledVehicle.bIngoreMoveRight = 0x585 // bool (Size: 0x1)
SGWheeledVehicle.MoreForwardAreaTanValue = 0x598 // float (Size: 0x4)
SGWheeledVehicle.VehicleSpeed = 0x5a0 // float (Size: 0x4)
SGWheeledVehicle.bPlayDying = 0x5b0 // bool (Size: 0x1)
SGWheeledVehicle.MaxEnterVehicleDistance = 0x5b4 // float (Size: 0x4)
SGWheeledVehicle.bEnableVehicleEnroachCheck = 0x5b8 // bool (Size: 0x1)
SGWheeledVehicle.MaxHealth = 0x5c0 // int32_t (Size: 0x4)
SGWheeledVehicle.DamageScale = 0x5c8 // TArray<FVehicleDamageScale> (Size: 0x10)
SGWheeledVehicle.Health = 0x5d8 // int32_t (Size: 0x4)
SGWheeledVehicle.OverlapCarForceCurve = 0x5e0 // CurveFloat* (Size: 0x8)
SGWheeledVehicle.OverlapCarDamageCurve = 0x5e8 // CurveFloat* (Size: 0x8)
SGWheeledVehicle.JumpCarDamageCurve = 0x5f0 // CurveFloat* (Size: 0x8)
SGWheeledVehicle.OverlapForceAdditive = 0x5f8 // FVector (Size: 0xc)
SGWheeledVehicle.ImpacetPlayerAdditionalMaxSpeed = 0x604 // float (Size: 0x4)
SGWheeledVehicle.ExploreDamage = 0x608 // float (Size: 0x4)
SGWheeledVehicle.ExploreDamageRadius = 0x60c // float (Size: 0x4)
SGWheeledVehicle.DustType = 0x610 // SGVehicleDustType* (Size: 0x8)
SGWheeledVehicle.ImpactTemplate = 0x618 // ClassProperty (Size: 0x8)
SGWheeledVehicle.ImpactEffectNormalForceThreshold = 0x620 // float (Size: 0x4)
SGWheeledVehicle.LowHealthEffect = 0x628 // TArray<FVehicleLowHealthEffect> (Size: 0x10)
SGWheeledVehicle.DestroyedMaterial = 0x638 // MaterialInstanceConstant* (Size: 0x8)
SGWheeledVehicle.DestroyedMaterialLow = 0x640 // MaterialInstanceConstant* (Size: 0x8)
SGWheeledVehicle.CurrentLowHealthPSC = 0x648 // ParticleSystemComponent* (Size: 0x8)
SGWheeledVehicle.VehicleMeshMI = 0x650 // MaterialInstanceDynamic* (Size: 0x8)
SGWheeledVehicle.VehicleSlipEffect = 0x658 // ParticleSystem* (Size: 0x8)
SGWheeledVehicle.SlipEffectPSCArray = 0x660 // ParticleSystemComponent* (Size: 0x8)
SGWheeledVehicle.SoundComponent = 0x680 // SGVehicleSoundComponent* (Size: 0x8)
SGWheeledVehicle.VehicleCommonComp = 0x688 // SGVehicleCommonComp* (Size: 0x8)
SGWheeledVehicle.DustPSC = 0x698 // ParticleSystemComponent* (Size: 0x8)
SGWheeledVehicle.SkidThresholdVelocity = 0x6b8 // float (Size: 0x4)
SGWheeledVehicle.LongSlipSkidThreshold = 0x6bc // float (Size: 0x4)
SGWheeledVehicle.LateralSlipSkidThreshold = 0x6c0 // float (Size: 0x4)
SGWheeledVehicle.VehicleExhaustAttachSocketName = 0x6c4 // FName (Size: 0x8)
SGWheeledVehicle.VehicleExhaustAttachSocketName2 = 0x6cc // FName (Size: 0x8)
SGWheeledVehicle.VehicleExhaustEffect = 0x6d8 // ParticleSystem* (Size: 0x8)
SGWheeledVehicle.FirstVehicleExhaustEffectPSC = 0x6e0 // ParticleSystemComponent* (Size: 0x8)
SGWheeledVehicle.SecondVehicleExhaustEffectPSC = 0x6e8 // ParticleSystemComponent* (Size: 0x8)
SGWheeledVehicle.TireExplosionEffect = 0x6f0 // ParticleSystem* (Size: 0x8)
SGWheeledVehicle.WheelTireTracksEffect = 0x6f8 // MaterialInstanceConstant* (Size: 0x8)
SGWheeledVehicle.bBrakeLightOn = 0x704 // bool (Size: 0x1)
SGWheeledVehicle.bEnterWater = 0x705 // bool (Size: 0x1)
SGWheeledVehicle.VehicleType = 0x706 // uint8_t (Size: 0x1)
SGWheeledVehicle.bAirControlUp = 0x707 // bool (Size: 0x1)
SGWheeledVehicle.bAirControlDown = 0x708 // bool (Size: 0x1)
SGWheeledVehicle.Driver = 0x710 // Pawn* (Size: 0x8)
SGWheeledVehicle.SeatRepData = 0x718 // FVehicleSeatRepData (Size: 0x38)
SGWheeledVehicle.TireData = 0x750 // FVehicleTireData (Size: 0x10)
SGWheeledVehicle.SpringCompressionLandingThreshold = 0x760 // float (Size: 0x4)
SGWheeledVehicle.MaxSuspensionFactor = 0x764 // float (Size: 0x4)
SGWheeledVehicle.DriverHalfHeight = 0x77c // float (Size: 0x4)
SGWheeledVehicle.DriverRadius = 0x780 // float (Size: 0x4)
SGWheeledVehicle.ImpactCameraShake = 0x788 // ClassProperty (Size: 0x8)
SGWheeledVehicle.IsFreeRotationCamera = 0x790 // bool (Size: 0x1)
SGWheeledVehicle.DriverCameraRotateFactor = 0x794 // float (Size: 0x4)
SGWheeledVehicle.EyeButtonCameraRotateFactor = 0x798 // float (Size: 0x4)
SGWheeledVehicle.DriverCameraYawMin = 0x79c // float (Size: 0x4)
SGWheeledVehicle.DriverCameraYawMax = 0x7a0 // float (Size: 0x4)
SGWheeledVehicle.DriverCameraPitchMin = 0x7a4 // float (Size: 0x4)
SGWheeledVehicle.DriverCameraPitchMax = 0x7a8 // float (Size: 0x4)
SGWheeledVehicle.SeatSpringArmOffSetX = 0x7ac // float (Size: 0x4)
SGWheeledVehicle.SeatSpringArmOffSetY = 0x7b0 // float (Size: 0x4)
SGWheeledVehicle.SeatSpringArmOffSetZ = 0x7b4 // float (Size: 0x4)
SGWheeledVehicle.InitialSpringArmPitch = 0x7b8 // float (Size: 0x4)
SGWheeledVehicle.SpringArmPitchFollowVehicleRate = 0x7bc // float (Size: 0x4)
SGWheeledVehicle.VehicleSupportColorList = 0x7e0 // TArray<FVehicleColorData> (Size: 0x10)
SGWheeledVehicle.VehicleColorIndex = 0x7f0 // int32_t (Size: 0x4)
SGWheeledVehicle.bToggleReverseMoveSound = 0x7f4 // bool (Size: 0x1)
SGWheeledVehicle.bToggleBrakeSound = 0x7f5 // bool (Size: 0x1)
SGWheeledVehicle.LastWayPointDistSqThreshold = 0x804 // float (Size: 0x4)
SGWheeledVehicle.RecordLastWayPoint = 0x808 // FVector (Size: 0xc)
SGWheeledVehicle.TempLastWayPoint = 0x814 // FVector (Size: 0xc)
SGWheeledVehicle.bEnableVehiceSleep = 0x829 // bool (Size: 0x1)
SGWheeledVehicle.VehicleSleepDelay = 0x82c // float (Size: 0x4)
SGWheeledVehicle.SyncPhysicStateComponent = 0x840 // SGVehicleSyncPhysicStateComponent* (Size: 0x8)
SGWheeledVehicle.DSStableDragRemoteCount = 0x84c // int32_t (Size: 0x4)
SGWheeledVehicle.VehicleParamsTable = 0x850 // DataTable* (Size: 0x8)
SGWheeledVehicle.VehicleMaxSpeedInDS = 0x858 // float (Size: 0x4)
SGWheeledVehicle.VehicleMaxSpeedTolerateRate = 0x85c // float (Size: 0x4)
SGWheeledVehicle.bIngoreSteerInputValue = 0x860 // bool (Size: 0x1)
SGWheeledVehicle.bEnableRotateCameraOptimize = 0x861 // bool (Size: 0x1)
SGWheeledVehicle.RotateCameraSpeed = 0x864 // float (Size: 0x4)
SGWheeledVehicleMovementComponent.bEnableVehiclePhyxOpt = 0x451 // bool (Size: 0x1)
SGWheeledVehicleMovementComponent.bEnableSpeedAntiCheat = 0x452 // bool (Size: 0x1)
SGWheeledVehicleMovementComponent.OwnerVehicle = 0x458 // SGWheeledVehicle* (Size: 0x8)
SGWheeledVehicleMovementComponent.ReleaseSpeedUpGear = 0x4a0 // float (Size: 0x4)
SGWheeledVehicleMovementComponent.IsBraking = 0x4a4 // bool (Size: 0x1)
SGWheeledVehicleMovementComponent.ThrottleInputRateNormalState = 0x4a8 // float (Size: 0x4)
SGWheeledVehicleMovementComponent.ThrottleInputRateSpeedUpState = 0x4ac // float (Size: 0x4)
SGWidgetToRenderTargetComponent.CarvingHightNormal = 0x150 // MaterialInterface* (Size: 0x8)
SGWidgetToRenderTargetComponent.RenderTargetFormat = 0x158 // uint8_t (Size: 0x1)
SGWidgetToRenderTargetComponent.RenderTargetSize = 0x15c // int32_t (Size: 0x4)
SGWidgetToRenderTargetComponent.RenderTexParameterName = 0x160 // FName (Size: 0x8)
SGWidgetToRenderTargetComponent.CarvingMIDIndex = 0x168 // int32_t (Size: 0x4)
SGWidgetToRenderTargetComponent.NormalRTInstance = 0x170 // TextureRenderTarget2D* (Size: 0x8)
SGWidgetToRenderTargetComponent.DefaultRTInstance = 0x190 // TextureRenderTarget2D* (Size: 0x8)
SGWidgetToRenderTargetComponent.TickTPCarvingTimer = 0x198 // FTimerHandle (Size: 0x8)
SGWidgetToRenderTargetComponent.CarvingHightNormalMID = 0x1a0 // MaterialInstanceDynamic* (Size: 0x8)
SGWishListItemInfo.ItemId = 0x0 // int32_t (Size: 0x4)
SGWishListItemInfo.HaveNum = 0x4 // int32_t (Size: 0x4)
SGWishListItemInfo.RequireNum = 0x8 // int32_t (Size: 0x4)
SGWishListItemInfo.CurrentOwnedNum = 0xc // int32_t (Size: 0x4)
SGWishListItemInfo.SellItemID = 0x10 // int32_t (Size: 0x4)
SGWishListItemInfo.LastReduceFromFulfillFrame = 0x14 // int32_t (Size: 0x4)
SGWorldAvatarSubsystem.PendingCharacterList = 0x30 // TArray<Character*> (Size: 0x10)
SGWorldCharacterSubsystem.DevelopServerFilters = 0x38 // TArray<FString> (Size: 0x10)
SGWorldCharacterSubsystem.CharacterList = 0x48 // TArray<Character*> (Size: 0x10)
SGWorldCharacterSubsystem.WithOutCharactorOwnerWeaponList = 0x58 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SGWorldCharacterSubsystem.LocalPC = 0x80 // PlayerController* (Size: 0x8)
SGWorldCharacterSubsystem.GProcessTotalTimeBudget = 0x8c // float (Size: 0x4)
SGWorldCharacterSubsystem.GProcessTotalCount = 0x90 // int32_t (Size: 0x4)
SGWorldCharacterSubsystem.AnimationSwitchValueMapLOD1 = 0xa8 // TMap<...> (Size: 0x50)
SGWorldCharacterSubsystem.AnimationSwitchValueMapLOD2 = 0xf8 // TMap<...> (Size: 0x50)
SGWorldCharacterSubsystem.AnimationSwitchValueMapLOD3 = 0x148 // TMap<...> (Size: 0x50)
SGWorldCharacterSubsystem.AnimationSwitchValueMapLOD4 = 0x198 // TMap<...> (Size: 0x50)
SGWorldCharacterSubsystem.OptTransformDistFromFirstPlayerSquare = 0x1f8 // float (Size: 0x4)
SGWorldInventorySubsystem.InventoryAsyncloadQueue = 0x38 // TArray<FInventoryLoadQueueInfoStruct> (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCHairMesh = 0x50 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCHeadMesh = 0x60 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCTorsoMesh = 0x70 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCGloveMesh = 0x80 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCLegMesh = 0x90 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultNPCShoeMesh = 0xa0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultMalePMCHeadMesh = 0xb0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultMalePMCTorsoMesh = 0xc0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultMalePMCGloveMesh = 0xd0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultMalePMCLegMesh = 0xe0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultMalePMCShoeMesh = 0xf0 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultFemalePMCHeadMesh = 0x100 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultFemalePMCTorsoMesh = 0x110 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultFemalePMCGloveMesh = 0x120 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultFemalePMCLegMesh = 0x130 // FString (Size: 0x10)
SGWorldInventorySubsystem.DefaultFemalePMCShoeMesh = 0x140 // FString (Size: 0x10)
SGWorldSettings.TimedEffects = 0x4e8 // TArray<FTimedImpactEffect> (Size: 0x10)
SGWorldSettingsActor.WorldSettingsComponentClasses = 0x310 // TArray<ClassProperty> (Size: 0x10)
SGWorldSettingsActor.WorldSettingsComponents = 0x320 // TArray<ActorComponent*> (Size: 0x10)
SGWorldSettingsMapInfoComponent.CoreRawData = 0x100 // TArray<int64_t> (Size: 0x10)
SGWorldSettingsMapInfoComponent.CoreWidth = 0x110 // int32_t (Size: 0x4)
SGWorldSettingsMapInfoComponent.CoreHeight = 0x114 // int32_t (Size: 0x4)
SGWorldSettingsRespawnInfoComponent.RespawnInterval = 0x100 // float (Size: 0x4)
SGWorldSettingsRespawnInfoComponent.TotalLifes = 0x104 // int32_t (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.TotalRounds = 0x100 // int32_t (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.PreRoundWaitingTime = 0x104 // float (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.PreparingTime = 0x108 // float (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.InProgressTime = 0x10c // float (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.EndRoundTime = 0x110 // float (Size: 0x4)
SGWorldSettingsRoundGameInfoComponent.PostRoundWaitingTime = 0x114 // float (Size: 0x4)
SGWorldSettingsTeamInfoComponent.TeamCount = 0x100 // int32_t (Size: 0x4)
SGWorldSettingsTicketInfoComponent.DesiredTickets = 0x100 // int32_t (Size: 0x4)
SGWorldWeaponSubsystem.PendingWeaponList = 0x40 // TArray<SGInventory*> (Size: 0x10)
SGZonePlayerInfo.PlayerId = 0x0 // uint64_t (Size: 0x8)
SGZonePlayerInfo.roomid = 0x8 // uint64_t (Size: 0x8)
SGZonePlayerInfo.TeamIndex = 0x10 // uint32_t (Size: 0x4)
SGZonePlayerInfo.TeamPos = 0x14 // uint32_t (Size: 0x4)
SGZonePlayerInfo.PlayerName = 0x18 // FString (Size: 0x10)
SGZonePlayerInfo.Level = 0x28 // uint32_t (Size: 0x4)
SGZonePlayerInfo.ZoneId = 0x2c // uint32_t (Size: 0x4)
SGZonePlayerInfo.HasEscapeSaveEquip = 0x30 // bool (Size: 0x1)
SGZonePlayerInfo.PlayerEquipInfo = 0x38 // FSGPlayerEquipInfo (Size: 0x60)
SGZonePlayerInfo.SettleSiteInfo = 0x98 // FZoneSettleSiteInfo (Size: 0x28)
SGZonePlayerInfo.HeadEndurance = 0xc0 // uint32_t (Size: 0x4)
SGZonePlayerInfo.ChestEndurance = 0xc4 // uint32_t (Size: 0x4)
SGZonePlayerInfo.StomchEndurance = 0xc8 // uint32_t (Size: 0x4)
SGZonePlayerInfo.LeftArmEndurance = 0xcc // uint32_t (Size: 0x4)
SGZonePlayerInfo.RightArmEndurance = 0xd0 // uint32_t (Size: 0x4)
SGZonePlayerInfo.LeftLegEndurance = 0xd4 // uint32_t (Size: 0x4)
SGZonePlayerInfo.RightLegEndurance = 0xd8 // uint32_t (Size: 0x4)
SGZonePlayerInfo.Food = 0xdc // uint32_t (Size: 0x4)
SGZonePlayerInfo.Water = 0xe0 // uint32_t (Size: 0x4)
SGZonePlayerInfo.BuffList = 0xe8 // TArray<SGPlayerDebuffInfoBase*> (Size: 0x10)
SGZonePlayerInfo.CliVersion = 0xf8 // uint64_t (Size: 0x8)
SGZonePlayerInfo.ranked_Level = 0x100 // uint32_t (Size: 0x4)
SGZonePlayerInfo.ranked_Score = 0x104 // uint32_t (Size: 0x4)
SGZonePlayerInfo.ranking = 0x108 // uint32_t (Size: 0x4)
SGZonePlayerInfo.pranking = 0x10c // uint32_t (Size: 0x4)
SGZonePlayerInfo.ranked_rd = 0x110 // uint32_t (Size: 0x4)
SGZonePlayerInfo.Rank = 0x114 // uint32_t (Size: 0x4)
SGZonePlayerInfo.PrivilegeLevel = 0x118 // uint32_t (Size: 0x4)
SGZonePlayerInfo.PlatPrivilegeType = 0x11c // uint32_t (Size: 0x4)
SGZonePlayerInfo.PlayerWishList = 0x120 // TArray<FSGWishListItemInfo> (Size: 0x10)
SGZonePlayerInfo.NewInspectedItemIDs = 0x130 // TArray<int32_t> (Size: 0x10)
SGZonePlayerInfo.DogTagType = 0x140 // int32_t (Size: 0x4)
SGZonePlayerInfo.HeadBoxID = 0x144 // int32_t (Size: 0x4)
SGZonePlayerInfo.HeadPicID = 0x148 // int32_t (Size: 0x4)
SGZonePlayerInfo.NameCard = 0x14c // int32_t (Size: 0x4)
SGZonePlayerInfo.title_id = 0x150 // uint32_t (Size: 0x4)
SGZonePlayerInfo.title_num = 0x154 // uint32_t (Size: 0x4)
SGZonePlayerInfo.title_rank = 0x158 // uint32_t (Size: 0x4)
SGZonePlayerInfo.HighestRankedLevel = 0x15c // uint32_t (Size: 0x4)
SGZonePlayerInfo.PlayerBannerInfo = 0x160 // FSGPlayerBannerInfo (Size: 0x28)
SGZonePlayerInfo.NationalFlagIso = 0x188 // uint32_t (Size: 0x4)
SGZonePlayerInfo.EnterDsZone = 0x18c // uint32_t (Size: 0x4)
SGZonePlayerInfo.IdealDsZone = 0x190 // uint32_t (Size: 0x4)
SGZonePlayerInfo.NetbarLevel = 0x194 // uint32_t (Size: 0x4)
SGZonePlayerInfo.NetbarExpGainRate = 0x198 // uint32_t (Size: 0x4)
SGZonePlayerInfo.VirtualItemList = 0x1a0 // TArray<FSGVirtualItemInfo> (Size: 0x10)
SafeZoneCache.SafeZonePadX = 0x0 // int32_t (Size: 0x4)
SafeZoneCache.SafeZonePadY = 0x4 // int32_t (Size: 0x4)
SafeZoneCache.SafeZonePadEX = 0x8 // int32_t (Size: 0x4)
SafeZoneCache.SafeZonePadEY = 0xc // int32_t (Size: 0x4)
SavedProjectileMovement.Location = 0x0 // FVector (Size: 0xc)
SavedProjectileMovement.Velocity = 0xc // FVector (Size: 0xc)
ScavInfo.SquadID = 0x0 // int32_t (Size: 0x4)
ScavInfo.MaxNum = 0x8 // TArray<int32_t> (Size: 0x10)
ScavInfo.LimitMin = 0x18 // int32_t (Size: 0x4)
ScavInfo.LimitMax = 0x1c // int32_t (Size: 0x4)
ScavInfo.ALiveNum = 0x20 // int32_t (Size: 0x4)
ScavInfo.DeadNum = 0x24 // int32_t (Size: 0x4)
ScavInfo.TotalNum = 0x28 // int32_t (Size: 0x4)
ScavInfo.BossNum = 0x2c // int32_t (Size: 0x4)
ScavInfo.FollowerNum = 0x30 // int32_t (Size: 0x4)
ScavInfo.PMCNum = 0x34 // int32_t (Size: 0x4)
ScavInfo.AIIDNum = 0x38 // TArray<FAIIDNum> (Size: 0x10)
ScavInfo.WaveNum = 0x48 // TArray<FWaveInfo> (Size: 0x10)
ScavInfo.DestroyedNum = 0x58 // int32_t (Size: 0x4)
ScavInfo.FirstSpawnTime = 0x5c // float (Size: 0x4)
ScavInfo.bIsPrioritySquad = 0x60 // bool (Size: 0x1)
ScavInfo.SquadType = 0x64 // int32_t (Size: 0x4)
ScavInfo.PendingInfo = 0x68 // TArray<FPendingSpawnAIDebugInfo> (Size: 0x10)
ScavInfo.CharacterArray = 0x78 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
SceneCompArr.SceneCompArr = 0x0 // TArray<SceneComponent*> (Size: 0x10)
ScopeRangeForTeammateIcon.ShowRangeForScopePosition = 0x0 // FBox2D (Size: 0x14)
ScopeRangeForTeammateIcon.HideRangeForWorldPosition = 0x14 // FBox2D (Size: 0x14)
ScopeRangeForTeammateIcon.ShowRadius = 0x28 // float (Size: 0x4)
ScopeZoomParamOnMaterials.ScopeMeshComponent = 0x8 // SGInventoryMeshComponent* (Size: 0x8)
ScopeZoomParamOnMaterials.ScopeInv = 0x10 // SGInventory* (Size: 0x8)
ScopeZoomParamOnMaterials.bIsCameraPrepared = 0x18 // bool (Size: 0x1)
ScorePanelConfig.ScoreConfig = 0x0 // FScorePanelConfig_Score (Size: 0x20)
ScorePanelConfig.TimeConfig = 0x20 // FScorePanelConfig_Time (Size: 0xc)
ScorePanelConfig_Score.RedFaction = 0x0 // EEFactionType (Size: 0x1)
ScorePanelConfig_Score.BlueFaction = 0x1 // EEFactionType (Size: 0x1)
ScorePanelConfig_Score.HudMaxScore = 0x4 // int32_t (Size: 0x4)
ScorePanelConfig_Score.FreezeText = 0x8 // FString (Size: 0x10)
ScorePanelConfig_Score.bHideTens = 0x18 // bool (Size: 0x1)
ScorePanelConfig_Score.TDMHudMaxScore = 0x1c // int32_t (Size: 0x4)
ScorePanelConfig_Time.TimeType = 0x0 // EEScorePanelTimeType (Size: 0x1)
ScorePanelConfig_Time.Seconds = 0x4 // float (Size: 0x4)
ScorePanelConfig_Time.HideTimeWhenZero = 0x8 // bool (Size: 0x1)
ScreenEffectConfArray.ParameterName = 0x0 // FName (Size: 0x8)
ScreenEffectConfArray.ApplyCurve = 0x8 // bool (Size: 0x1)
ScreenEffectConfArray.DefaultValue = 0xc // float (Size: 0x4)
ScreenEffectConfArray.Curve = 0x10 // CurveFloat* (Size: 0x8)
SearchContainerInfo.ContainerSearchState = 0x0 // bool (Size: 0x1)
SearchContainerInfo.UnSearchItemCount = 0x4 // int32_t (Size: 0x4)
SensitivityData.NoGlass = 0x0 // int32_t (Size: 0x4)
SensitivityData.RedSpot = 0x4 // int32_t (Size: 0x4)
SensitivityData.Holographic = 0x8 // int32_t (Size: 0x4)
SensitivityData.MechinicalAim = 0xc // int32_t (Size: 0x4)
SensitivityData.VSS = 0x10 // int32_t (Size: 0x4)
SensitivityData.Scale2 = 0x14 // int32_t (Size: 0x4)
SensitivityData.Scale3 = 0x18 // int32_t (Size: 0x4)
SensitivityData.Scale4 = 0x1c // int32_t (Size: 0x4)
SensitivityData.Scale6 = 0x20 // int32_t (Size: 0x4)
SensitivityData.Scale8 = 0x24 // int32_t (Size: 0x4)
ServerKey2Text.ServerKey = 0x8 // FString (Size: 0x10)
ServerKey2Text.ServerText = 0x18 // FText (Size: 0x18)
ShellEffectInfo_HD.InitVelocityMin = 0x0 // FVector (Size: 0xc)
ShellEffectInfo_HD.InitVelocityMax = 0xc // FVector (Size: 0xc)
ShellEffectInfo_HD.InitAngularVelocityMin = 0x18 // FVector (Size: 0xc)
ShellEffectInfo_HD.InitAngularVelocityMax = 0x24 // FVector (Size: 0xc)
ShellEffectInfo_HD.LifeSpan = 0x30 // float (Size: 0x4)
ShellParticleInfo.ShellParticleAccMin = 0x0 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleAccMax = 0xc // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleVelocityMin = 0x18 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleVelocityMax = 0x24 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleRateMin = 0x30 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleRateMax = 0x3c // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleLocationMin = 0x48 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleLocationMax = 0x54 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleRotaMin = 0x60 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleRotaMax = 0x6c // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleSizeMin = 0x78 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleSizeMax = 0x84 // FVector (Size: 0xc)
ShellParticleInfo.ShellParticleLifeTimeMin = 0x90 // float (Size: 0x4)
ShellParticleInfo.ShellParticleLifeTimeMax = 0x94 // float (Size: 0x4)
ShellParticleInfo.ShellParticleDragMin = 0x98 // float (Size: 0x4)
ShellParticleInfo.ShellParticleDragMax = 0x9c // float (Size: 0x4)
ShootInputFlowData.InputFlowDataSlice = 0x0 // FString (Size: 0x10)
ShootInputFlowData.bComplete = 0x10 // bool (Size: 0x1)
ShootInputFlowData.SequenceNum = 0x14 // int32_t (Size: 0x4)
SightBlockArea.Offset = 0x0 // FVector (Size: 0xc)
SightBlockArea.Radius = 0xc // float (Size: 0x4)
SightGroup.MostNegativeErgonomic = 0x0 // int32_t (Size: 0x4)
SightGroup.RootSight = 0x8 // SGInventory* (Size: 0x8)
SightGroup.SightList = 0x10 // TArray<SGInventory*> (Size: 0x10)
SimpHelicopterMovementComponent.UpFlightMaxSpeed = 0x188 // float (Size: 0x4)
SimpHelicopterMovementComponent.LandingMaxSpeed = 0x18c // float (Size: 0x4)
SimpHelicopterMovementComponent.UpAcceleration = 0x190 // float (Size: 0x4)
SimpHelicopterMovementComponent.UpDeceleration = 0x194 // float (Size: 0x4)
SimpHelicopterMovementComponent.FrontFlightMaxSpeed = 0x198 // float (Size: 0x4)
SimpHelicopterMovementComponent.FrontAcceleration = 0x19c // float (Size: 0x4)
SimpHelicopterMovementComponent.FrontDeceleration = 0x1a0 // float (Size: 0x4)
SimpHelicopterMovementComponent.SideFlightMaxSpeed = 0x1a4 // float (Size: 0x4)
SimpHelicopterMovementComponent.SideAcceleration = 0x1a8 // float (Size: 0x4)
SimpHelicopterMovementComponent.SideDeceleration = 0x1ac // float (Size: 0x4)
SimpHelicopterMovementComponent.YawMaxAngularVelocity = 0x1b0 // float (Size: 0x4)
SimpHelicopterMovementComponent.YawAngularAcceleration = 0x1b4 // float (Size: 0x4)
SimpHelicopterMovementComponent.YawAngularDeceleration = 0x1b8 // float (Size: 0x4)
SimpHelicopterMovementComponent.RotationRate = 0x1bc // FRotator (Size: 0xc)
SimpHelicopterMovementComponent.RollMax = 0x1c8 // float (Size: 0x4)
SimpHelicopterMovementComponent.PitchMax = 0x1cc // float (Size: 0x4)
SimpHelicopterMovementComponent.ReplicatedData = 0x1e0 // FSimpHelicopterMovementRepData (Size: 0x14)
SimpHelicopterMovementRepData.Acceleration = 0x0 // FVector (Size: 0xc)
SimpHelicopterMovementRepData.YawAcceleration = 0xc // float (Size: 0x4)
SimpHelicopterMovementRepData.YawVelocity = 0x10 // float (Size: 0x4)
SimpleMeshInfo.MeshRes = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
SimpleMeshInfo.SocketName = 0x28 // FName (Size: 0x8)
SinRandom.Amplitude = 0x0 // FValueNoiseInRange (Size: 0xc)
SinRandom.Period = 0xc // float (Size: 0x4)
SineOscillator.DurationTime = 0x0 // float (Size: 0x4)
SineOscillator.SingleFireDurationTime = 0x4 // float (Size: 0x4)
SineOscillator.bSkipBlendIn = 0x8 // bool (Size: 0x1)
SineOscillator.BlendInTime = 0xc // float (Size: 0x4)
SineOscillator.BlendOutTime = 0x10 // float (Size: 0x4)
SineOscillator.AmplitudeAdditiveTime = 0x14 // float (Size: 0x4)
SineOscillator.Period = 0x18 // float (Size: 0x4)
SineOscillator.bUseRandomInitialOffset = 0x1c // bool (Size: 0x1)
SineOscillator.Delay = 0x20 // float (Size: 0x4)
SineOscillator.BaseAmplitude = 0x24 // float (Size: 0x4)
SineOscillator.PerAmplitudeAdd = 0x28 // float (Size: 0x4)
SineOscillator.MinAmplitudeScale = 0x2c // float (Size: 0x4)
SineOscillator.MaxAmplitudeScale = 0x30 // float (Size: 0x4)
SineOscillator.AmplitudeCurve = 0x38 // CurveFloat* (Size: 0x8)
SkelMeshMergeSectionMapping_BP.SectionIDs = 0x0 // TArray<int32_t> (Size: 0x10)
SkelMeshMergeUVTransform.UVTransforms = 0x0 // TArray<FTransform> (Size: 0x10)
SkelMeshMergeUVTransformMappingTK.UVTransformsPerMesh = 0x0 // TArray<FSkelMeshMergeUVTransform> (Size: 0x10)
SkeletalMeshAssetUserData.BadgeBoneMorphOffsetList = 0x28 // TMap<...> (Size: 0x50)
SkeletalMeshAssetUserData.SkinTypeKeyWord = 0x78 // FString (Size: 0x10)
SkeletalMeshBeardAssetUserData.BeardIndex = 0x28 // int32_t (Size: 0x4)
SkeletalMeshMergeParams.MeshSectionMappings = 0x0 // TArray<FSkelMeshMergeSectionMapping_BP> (Size: 0x10)
SkeletalMeshMergeParams.UVTransformsPerMesh = 0x10 // TArray<FSkelMeshMergeUVTransformMappingTK> (Size: 0x10)
SkeletalMeshMergeParams.MeshesToMerge = 0x20 // TArray<SkeletalMesh*> (Size: 0x10)
SkeletalMeshMergeParams.StripTopLODS = 0x30 // int32_t (Size: 0x4)
SkeletalMeshMergeParams.bNeedsCpuAccess = 0x34 // uint8_t (Size: 0x1)
SkeletalMeshMergeParams.bSkeletonBefore = 0x34 // uint8_t (Size: 0x1)
SkeletalMeshMergeParams.Skeleton = 0x38 // Skeleton* (Size: 0x8)
SkeletalMeshMergeParams.ReferenceSkeletalMesh = 0x40 // SkeletalMesh* (Size: 0x8)
SkeletalMeshMergeParams.MergedMeshName = 0x48 // FName (Size: 0x8)
SkeletalMeshMergeParams.bNeverStream = 0x50 // bool (Size: 0x1)
SkeletalMeshMergeParams.CommonMaterial = 0x58 // MaterialInterface* (Size: 0x8)
SkeletalMeshMergeParams.SkinType = 0x60 // FLinearColor (Size: 0x10)
SkeletalMeshMergeParams.b1PUse = 0x70 // bool (Size: 0x1)
SkeletalMeshMergeParams.bMergeMorphTarget = 0x71 // bool (Size: 0x1)
SkeletalMeshMergeParams.bUseSingleUVMultiSectionUVTransform = 0x72 // bool (Size: 0x1)
SkeletalMeshMergeParams.MergedBMTexture = 0x78 // Texture2D* (Size: 0x8)
SkeletalMeshMergeParams.MergedORNTexture = 0x80 // Texture2D* (Size: 0x8)
SkeletalMeshMergeParams.CommonParentMaterial = 0x98 // MaterialInterface* (Size: 0x8)
SmoothDamper.SmoothTime = 0x0 // float (Size: 0x4)
SocketOffsetInfo.OffsetName = 0x0 // FName (Size: 0x8)
SocketOffsetInfo.OffsetLoc = 0x8 // FVector (Size: 0xc)
SoundDiffusionFactorConfTableRow.SoundDiffusionLevelFactor = 0x8 // float (Size: 0x4)
SoundDiffusionFactorConfTableRow.SoundDiffusionMaxDistanceFactor = 0xc // float (Size: 0x4)
SoundDiffusionFactorConfTableRow.SuppressorSoundScale = 0x10 // float (Size: 0x4)
SoundIndicator.SoundIndicatorConfig = 0x30 // TMap<...> (Size: 0x50)
SoundIndicator.SoundSelfInfluenceFactorConfig = 0x80 // TMap<...> (Size: 0x50)
SoundIndicator.SoundInfluenceAdditiveParams = 0xd0 // FSoundInfluenceAdditiveParams (Size: 0xa0)
SoundIndicator.DefaultHiddenType = 0x170 // TSet<...> (Size: 0x50)
SoundIndicator.GunSilencerInfluenceMap = 0x1c0 // TMap<...> (Size: 0x50)
SoundIndicator.IntervalAdditiveArr = 0x210 // TArray<FSoundIndicatorIntervalAdditive> (Size: 0x10)
SoundIndicator.EMPDistanceIntervalCurve = 0x220 // CurveFloat* (Size: 0x8)
SoundIndicator.SelfSoundLevelFactorCurve = 0x228 // CurveFloat* (Size: 0x8)
SoundIndicator.SelfSoundTriggerLevel = 0x230 // int32_t (Size: 0x4)
SoundIndicator.ReportRatio = 0x234 // float (Size: 0x4)
SoundIndicator.ReportDistance = 0x238 // float (Size: 0x4)
SoundIndicator.IndicatorObserveTimer = 0x23c // float (Size: 0x4)
SoundIndicator.IndicatorReportScoreMap = 0x240 // TMap<...> (Size: 0x50)
SoundIndicator.SoundTypeFliter = 0x290 // TSet<...> (Size: 0x50)
SoundIndicator.SoundIndicatorReportInfoMap = 0x2e0 // TMap<...> (Size: 0x50)
SoundIndicator.TLogData = 0x330 // FString (Size: 0x10)
SoundIndicator.IndicatorCount = 0x340 // int32_t (Size: 0x4)
SoundIndicator.CombineCount = 0x344 // int32_t (Size: 0x4)
SoundIndicator.LocalPC = 0x348 // PlayerController* (Size: 0x8)
SoundIndicator.ViewChar = 0x350 // SGCharacter* (Size: 0x8)
SoundIndicatorAdditive.BaseLevelAdditive = 0x0 // float (Size: 0x4)
SoundIndicatorAdditive.DurationAdditive = 0x4 // float (Size: 0x4)
SoundIndicatorAdditive.FadeTimeAdditive = 0x8 // float (Size: 0x4)
SoundIndicatorAdditive.MaxDistanceAdditive = 0xc // float (Size: 0x4)
SoundIndicatorConfig.BaseLevel = 0x0 // float (Size: 0x4)
SoundIndicatorConfig.Duration = 0x4 // float (Size: 0x4)
SoundIndicatorConfig.FadeTime = 0x8 // float (Size: 0x4)
SoundIndicatorConfig.IconIndex = 0xc // int32_t (Size: 0x4)
SoundIndicatorConfig.Interval = 0x10 // float (Size: 0x4)
SoundIndicatorConfig.MaxDistance = 0x14 // float (Size: 0x4)
SoundIndicatorConfig.Frequency = 0x18 // float (Size: 0x4)
SoundIndicatorConfig.OpacityCurve = 0x20 // CurveFloat* (Size: 0x8)
SoundIndicatorConfig.AnimSpeedCurve = 0x28 // CurveFloat* (Size: 0x8)
SoundIndicatorConfig.SoundWaveHeightCurve = 0x30 // CurveFloat* (Size: 0x8)
SoundIndicatorConfig.HeightSideContrast = 0x38 // CurveFloat* (Size: 0x8)
SoundIndicatorConfig.LevelFactor = 0x40 // CurveFloat* (Size: 0x8)
SoundIndicatorConfig.MatUpper = 0x48 // MaterialInterface* (Size: 0x8)
SoundIndicatorConfig.MatMiddle = 0x50 // MaterialInterface* (Size: 0x8)
SoundIndicatorConfig.MatLower = 0x58 // MaterialInterface* (Size: 0x8)
SoundIndicatorConfig.WaveColor = 0x60 // FLinearColor (Size: 0x10)
SoundIndicatorConfig.Priority = 0x70 // int32_t (Size: 0x4)
SoundIndicatorIntervalAdditive.SoundTypes = 0x0 // TSet<...> (Size: 0x50)
SoundIndicatorIntervalAdditive.Factor = 0x50 // float (Size: 0x4)
SoundIndicatorReportInfo.Location = 0x0 // FVector (Size: 0xc)
SoundIndicatorReportInfo.SourceLocation = 0xc // FVector (Size: 0xc)
SoundIndicatorReportInfo.TriggerTime = 0x18 // float (Size: 0x4)
SoundIndicatorReportInfo.CurrentTime = 0x1c // float (Size: 0x4)
SoundIndicatorReportInfo.CurrentScore = 0x20 // float (Size: 0x4)
SoundIndicatorReportInfo.Distance = 0x24 // float (Size: 0x4)
SoundIndicatorReportInfo.SourceActor = 0x28 // Actor* (Size: 0x8)
SoundIndicatorReportInfo.BehaviorCachedSet = 0x30 // TSet<...> (Size: 0x50)
SoundIndicatorTLogData.Score = 0x0 // float (Size: 0x4)
SoundIndicatorTLogData.Distance = 0x4 // float (Size: 0x4)
SoundIndicatorTLogData.bIsDead = 0x8 // bool (Size: 0x1)
SoundInfluenceAdditiveParams.SoundSourceTypeSet = 0x0 // TSet<...> (Size: 0x50)
SoundInfluenceAdditiveParams.SoundInfluenceAdditiveMap = 0x50 // TMap<...> (Size: 0x50)
SoundInfluenceFactor.LevelInfluence = 0x0 // float (Size: 0x4)
SoundInfluenceFactor.MaxDistanceInfluence = 0x4 // float (Size: 0x4)
SoundInfoInfo.AkEvent = 0x0 // AkAudioEvent* (Size: 0x8)
SoundInfoInfo.bLoadAtBeginning = 0x8 // bool (Size: 0x1)
SoundInfoInfo.bUnLoadWhenEnd = 0x9 // bool (Size: 0x1)
SoundSourceActorParam.ActorType = 0x0 // EESoundSourceActorType (Size: 0x1)
SoundSourceActorParam.SourceActor = 0x8 // Actor* (Size: 0x8)
SoundSourceTypeFSoundInfluenceFactor.SourceTypeInfluenceFactor = 0x0 // TMap<...> (Size: 0x50)
SoundSourceTypeSet.SoundSourceTypeSet = 0x0 // TSet<...> (Size: 0x50)
SpawnActorInfo.PreviewActor = 0x0 // Actor* (Size: 0x8)
SpawnActorInfo.PreviewDis = 0x8 // float (Size: 0x4)
SpawnActorInfo.MinDisSquared = 0xc // float (Size: 0x4)
SpawnActorInfo.ActorToSpawnClass = 0x10 // ClassProperty (Size: 0x8)
SpawnActorInfo.BoxExtent = 0x18 // FVector (Size: 0xc)
SpawnActorInfo.ActorLocUpTraceDis = 0x24 // float (Size: 0x4)
SpawnActorInfo.ActorLocDownTraceDis = 0x28 // float (Size: 0x4)
SpawnActorInfo.CameraLoc = 0x2c // FVector (Size: 0xc)
SpawnActorInfo.TargetLoc = 0x38 // FVector (Size: 0xc)
SpawnInventoryBGTickFunction.SpawnInvBGSubSystem = 0x38 // SGSpawnInventoryBGWorldSubsystem* (Size: 0x8)
SpawnPointInfo.SpawnPoint = 0x28 // Actor* (Size: 0x8)
SpawnRecord.SpawnPoint = 0x8 // Actor* (Size: 0x8)
SpawnRecord.SpawnPosition = 0x10 // FVector (Size: 0xc)
SpawnRecord.SpawnSquadID = 0x1c // int32_t (Size: 0x4)
SpawnRecord.SpawnArea = 0x20 // FString (Size: 0x10)
SpawnRecord.AI_UID = 0x30 // int64_t (Size: 0x8)
SpawnRecord.SpawnReason = 0x3c // EESpawnReason (Size: 0x1)
SpawnRecord.CampID = 0x40 // int32_t (Size: 0x4)
SpawnRecord.TriggerString = 0x48 // FString (Size: 0x10)
SpawnRecord.GroupID = 0x5c // FName (Size: 0x8)
SpawnRecord.ReadyTime = 0x74 // float (Size: 0x4)
SpawnedAIInfoForDebug.Character = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
SpawnedAIInfoForDebug.SpawnTime = 0x8 // float (Size: 0x4)
SpawnedAIInfoForDebug.DeadTime = 0xc // float (Size: 0x4)
SpawnedAIInfoForDebug.position = 0x10 // FVector (Size: 0xc)
SpawnedAIInfoForDebug.AIType = 0x1c // EEAIMainType (Size: 0x1)
SpawnedAIInfoForDebug.IsAlive = 0x1d // bool (Size: 0x1)
SpawnedAIInfoForDebug.DeadReason = 0x20 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.SquadID = 0x24 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.FatherSquadID = 0x28 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.CurrentAllyNum = 0x2c // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.MaxAllyNum = 0x30 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.EquipmentID = 0x34 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.Difficulty = 0x38 // int32_t (Size: 0x4)
SpawnedAIInfoForDebug.AreaID = 0x40 // FString (Size: 0x10)
SpawnedAIInfoForDebug.SpawnPointName = 0x50 // FString (Size: 0x10)
SpawnedAIInfoForDebug.SpawnPointGroupIndex = 0x60 // int32_t (Size: 0x4)
SpecialAdapterAnimation.AdapterSkinID = 0x0 // int32_t (Size: 0x4)
SpecialAdapterAnimation.AdapterAnimation = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SpecialInventoryConfig.IconPath = 0x0 // FString (Size: 0x10)
SpecialInventoryConfig.InventorySpecialTypeName = 0x10 // FText (Size: 0x18)
SpecialInventoryConfig.InventorySpecialTypeDetail = 0x28 // FText (Size: 0x18)
SpecialSpecAnimation.Weight = 0x0 // float (Size: 0x4)
SpecialSpecAnimation.CharacterAnimation = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
SpecialSpecAnimation.WeaponAnimation = 0x30 // TSoftObjectPtr<UObject> (Size: 0x28)
SpecialSpecAnimation.AdapterAnimationList = 0x58 // TArray<FSpecialAdapterAnimation> (Size: 0x10)
SpectatingFlowData.eventId = 0x0 // int32_t (Size: 0x4)
SpectatingFlowData.SpectatedOpenID = 0x8 // FString (Size: 0x10)
SpectatingFlowData.SpectatedGUID = 0x18 // FString (Size: 0x10)
SpectatingFlowData.SpectatingTime = 0x28 // float (Size: 0x4)
SpectatingFlowData.BattleTime = 0x2c // float (Size: 0x4)
SpectatingFlowData.AliveTime = 0x30 // float (Size: 0x4)
SpineOffsetPreset.TranslationOffset = 0x0 // FVector (Size: 0xc)
SpineOffsetPreset.TranslationOffsetAccordingToPitch = 0xc // FVector (Size: 0xc)
SprayActors.SprayActors = 0x0 // TArray<SGSprayActor*> (Size: 0x10)
StackableItemSourceInfo.FromPlayerGID = 0x0 // int64_t (Size: 0x8)
StackableItemSourceInfo.FromTeamIndex = 0x8 // int32_t (Size: 0x4)
StackableItemSourceInfo.Count = 0xc // int32_t (Size: 0x4)
StackableItemSourceInfo.FromCharacterType = 0x10 // EECharacterType (Size: 0x1)
StackableItemSourceInfo.FromSpawnSourceType = 0x11 // EESGInventorySpawnSourceType (Size: 0x1)
StackableItemSourceInfo.LootLimitPoolID = 0x14 // int32_t (Size: 0x4)
StatisDefaultParams.FrameRateJitterThreshold = 0x0 // float (Size: 0x4)
StatisDefaultParams.APMReportPeriod = 0x4 // float (Size: 0x4)
StatisDefaultParams.MaxLocDiff = 0x8 // float (Size: 0x4)
StatisDefaultParams.Max3PLocDiff = 0xc // float (Size: 0x4)
StatisDefaultParams.FrameRateJitterLagerWaveRate = 0x10 // float (Size: 0x4)
StatisDefaultParams.SpawnActorMaxMilliseconds = 0x14 // float (Size: 0x4)
StunGrenadeEffectInfo.bHasDeafEffect = 0x0 // uint8_t (Size: 0x1)
StunGrenadeEffectInfo.DeafDuration = 0x4 // float (Size: 0x4)
StunGrenadeEffectInfo.bHasFlashedEffect = 0x8 // uint8_t (Size: 0x1)
StunGrenadeEffectInfo.FlashedDuration = 0xc // float (Size: 0x4)
SubCameraInfo.ScopeLevel = 0x0 // int32_t (Size: 0x4)
SubCameraInfo.ZoomingSensitivity = 0x4 // float (Size: 0x4)
SubCameraInfo.ShoulderZoomingSensitivity = 0x8 // float (Size: 0x4)
SubCameraInfo.NormalFireSensitivity = 0xc // float (Size: 0x4)
SubCameraInfo.ZoomFOV = 0x10 // float (Size: 0x4)
SubCameraInfo.HoldingBreathZoomFOV = 0x14 // float (Size: 0x4)
SubCameraInfo.FiringZoomInVector = 0x18 // FVector (Size: 0xc)
SubCameraInfo.BlurRadius = 0x24 // float (Size: 0x4)
SubCameraInfo.BlurThresHold = 0x28 // float (Size: 0x4)
SubCameraInfo.FiringAnimTranslationWeight = 0x2c // float (Size: 0x4)
SubCameraInfo.FiringAnimRotationWeight = 0x30 // float (Size: 0x4)
SubCameraInfo.AimingBase = 0x34 // FName (Size: 0x8)
SubCameraInfo.AimingPivotSocket = 0x3c // FName (Size: 0x8)
SubCameraInfo.AimingDOF = 0x44 // FName (Size: 0x8)
SubCameraInfo.SwitchAnim = 0x4c // EEAdapterAnimationType (Size: 0x1)
SubCameraInfo.CameraGunkickWeight = 0x50 // float (Size: 0x4)
SubCameraInfo.AimingBaseOffset = 0x54 // FVector (Size: 0xc)
SubCameraInfo.ScopeMaterialElementIndex = 0x60 // int32_t (Size: 0x4)
SubCameraInfo.InnerScopeBlurMaterial = 0x68 // TSoftObjectPtr<UObject> (Size: 0x28)
SubCameraInfo.LocalScopeParamAndRadius = 0x90 // FVector4 (Size: 0x10)
SubCameraInfo.BackupScopeMI = 0xa0 // MaterialInstanceDynamic* (Size: 0x8)
SubCameraInfo.InnerScopeBlurMI = 0xa8 // MaterialInstanceDynamic* (Size: 0x8)
SubCameraInfo.LensDistortionImageScale = 0xb0 // float (Size: 0x4)
SubCameraInfo.Magnification = 0xb4 // float (Size: 0x4)
SubCameraInfo.BlurMaterial = 0xb8 // MaterialInterface* (Size: 0x8)
SubCameraInfo.LensDistortMaterial = 0xc0 // MaterialInterface* (Size: 0x8)
SubCameraInfo.ZeroingDistance = 0xc8 // float (Size: 0x4)
SubCameraInfo.bIsIronSight = 0xcc // bool (Size: 0x1)
SubCameraInfo.DisplayName = 0xd0 // FText (Size: 0x18)
SubCameraInfo.bUsingScopeSceneCapture = 0xe8 // bool (Size: 0x1)
SubCameraInfo.ScopeReticleTexture = 0xf0 // Texture* (Size: 0x8)
SubCameraInfo.ScopeReticleScale = 0xf8 // float (Size: 0x4)
SubCameraInfo.ScopeReticleList = 0x100 // TArray<FCrossHairTexInfo> (Size: 0x10)
SubCameraInfo.ScopeMaterialIndex = 0x110 // int32_t (Size: 0x4)
SubCameraInfo.SwitchMagnificationAnim = 0x118 // AnimSequenceBase* (Size: 0x8)
SuitGroupInfo.GroupIndex = 0x0 // int32_t (Size: 0x4)
SuitGroupInfo.SuitAry = 0x8 // TArray<FSuitInfo> (Size: 0x10)
SuitInfo.TemplateID = 0x0 // int32_t (Size: 0x4)
SuitInfo.bRecommend = 0x4 // bool (Size: 0x1)
SuitInfo.ColumnIndex = 0x8 // int32_t (Size: 0x4)
SuitInfo.CustomRule = 0x10 // FString (Size: 0x10)
SuitInfo.TargetGameMode = 0x20 // int32_t (Size: 0x4)
SuitInfo.IsClose = 0x24 // int32_t (Size: 0x4)
SuitInfo.DisplayInfo_MainWeaponID = 0x28 // int32_t (Size: 0x4)
SuitInfo.DisplayInfo_MainWeaponPos = 0x2c // int32_t (Size: 0x4)
SuitInfo.TemplateItems = 0x30 // TArray<FSuitItemInfo> (Size: 0x10)
SuitItemInfo.ItemId = 0x0 // uint64_t (Size: 0x8)
SuitItemInfo.Num = 0x8 // int32_t (Size: 0x4)
SuitItemInfo.ParentID = 0xc // int32_t (Size: 0x4)
SuitItemInfo.ID = 0x10 // int32_t (Size: 0x4)
SuitItemInfo.AttachPosition = 0x14 // int32_t (Size: 0x4)
SupplyStationBuyInfo.ItemId = 0x0 // uint32_t (Size: 0x4)
SupplyStationBuyInfo.UniqueID = 0x4 // int32_t (Size: 0x4)
SupplyStationBuyInfo.BuyNum = 0x8 // int32_t (Size: 0x4)
SupplyStationBuyInfo.bIsEquipment = 0xc // bool (Size: 0x1)
SupplyStationBuyInfo.Inventory = 0x10 // SGInventory* (Size: 0x8)
SyncVehilceStopData.ServerLocation = 0x0 // FVector (Size: 0xc)
SyncVehilceStopData.ServerRotation = 0xc // FRotator (Size: 0xc)
SyncVehilceStopData.bVehicleStopped = 0x18 // bool (Size: 0x1)
TLogSuitSelectInfo.Round = 0x0 // int32_t (Size: 0x4)
TLogSuitSelectInfo.SuitID = 0x4 // int32_t (Size: 0x4)
TLogSuitSelectInfo.Time = 0x8 // int32_t (Size: 0x4)
TLogSuitSelectInfo.StartTime = 0xc // int32_t (Size: 0x4)
TLogSuitSelectInfo.KillCount = 0x10 // int32_t (Size: 0x4)
TLogSuitSelectInfo.GameModeType = 0x14 // int32_t (Size: 0x4)
TacticalInvStateInfo.TacticTag = 0x0 // FGameplayTag (Size: 0x8)
TacticalInvStateInfo.AttachedTacticalComponents = 0x8 // TArray<SGInventoryTacticComponent*> (Size: 0x10)
TacticalInvStateInfo.bShouldEnableSwitch = 0x18 // bool (Size: 0x1)
TacticalInvStateInfo.bSwitchStateOn = 0x19 // bool (Size: 0x1)
TacticalInvStateInfo.bTacticalInvsActive = 0x1a // bool (Size: 0x1)
TacticalInvStateInfo.bCachedSwitchStateOn = 0x1b // bool (Size: 0x1)
TacticalInvStateInfo.bCachedShouldEnableSwitch = 0x1c // bool (Size: 0x1)
TacticalPistolRepInfo.TacticalPistolStatus = 0x0 // EETacticalPistolStatus (Size: 0x1)
TacticalPistolRepInfo.LeftHandWeapon = 0x8 // SGInventory* (Size: 0x8)
TacticalPistolRepInfo.RightHandWeapon = 0x10 // SGInventory* (Size: 0x8)
TacticalPistolRepInfo.UpdateWeaponEquipPos = 0x18 // bool (Size: 0x1)
TacticalPistolRepInfo.bPlayingMontage = 0x19 // bool (Size: 0x1)
TacticalPistolRepInfo.bUseFastTrans = 0x1a // bool (Size: 0x1)
TakeDamageInfo.CauserController = 0x0 // Controller* (Size: 0x8)
TakeDamageInfo.VictimController = 0x8 // Controller* (Size: 0x8)
TakeDamageInfo.CauserPawn = 0x10 // Pawn* (Size: 0x8)
TakeDamageInfo.VictimPawn = 0x18 // Pawn* (Size: 0x8)
TakeDamageInfo.CauserWeapon = 0x20 // Actor* (Size: 0x8)
TakeDamageInfo.AttemptedDamage = 0x28 // float (Size: 0x4)
TakeDamageInfo.ActuralDamage = 0x2c // float (Size: 0x4)
TakeDamageInfo.DamageEventObject = 0x30 // DamageEventObject* (Size: 0x8)
TakeDamageRecord.PlayerGid = 0x0 // int64_t (Size: 0x8)
TakeDamageRecord.Damage = 0x8 // float (Size: 0x4)
TakeDamageRecord.HitGroup = 0xc // uint8_t (Size: 0x1)
TakeDamageRecord.ServerTime = 0x10 // float (Size: 0x4)
TakeHitInfo.Damage = 0x0 // float (Size: 0x4)
TakeHitInfo.RelHitLocation = 0x4 // FVector_NetQuantize (Size: 0xc)
TakeHitInfo.Momentum = 0x10 // FVector_NetQuantize (Size: 0xc)
TakeHitInfo.ShotDirPitch = 0x1c // uint8_t (Size: 0x1)
TakeHitInfo.ShotDirYaw = 0x1d // uint8_t (Size: 0x1)
TakeHitInfo.HitGroup = 0x1e // EEHitGroupType (Size: 0x1)
TakeHitInfo.bPenerateArmor = 0x1f // bool (Size: 0x1)
TakeHitInfo.HitArmorItemID = 0x20 // uint64_t (Size: 0x8)
TakeHitInfo.Causer = 0x28 // Actor* (Size: 0x8)
TakeHitInfo.DamageCauser = 0x30 // Actor* (Size: 0x8)
TakeHitInfo.DamageTypeEnum = 0x38 // EEDamageTypeEnum (Size: 0x1)
TakeHitInfo.AmmoClass = 0x40 // ClassProperty (Size: 0x8)
TakeHitInfo.FlyDistance = 0x48 // float (Size: 0x4)
TakeHitInfo.bTerminal = 0x4c // bool (Size: 0x1)
TakeHitInfo.HitFlags = 0x4d // uint8_t (Size: 0x1)
TakeHitInfo.BulletID = 0x50 // FSGBulletID (Size: 0x10)
TeamPlayerOrderInfo.PlayerState = 0x0 // PlayerState* (Size: 0x8)
TeamPlayerOrderInfo.Name = 0x8 // FString (Size: 0x10)
TeamPlayerOrderInfo.Order = 0x18 // uint8_t (Size: 0x1)
TeammateCurseInfo.SelfGID = 0x0 // uint64_t (Size: 0x8)
TeammateCurseInfo.CursedCharacters = 0x8 // TArray<uint64_t> (Size: 0x10)
TeammateCurseInfo.bAffectAllFaction = 0x18 // bool (Size: 0x1)
TeammateCurseInfo.TeammateKillerGID = 0x20 // uint64_t (Size: 0x8)
TeammateCurseInfo.TeammateGIDs = 0x28 // TArray<uint64_t> (Size: 0x10)
TempBurningInfo.bIsBurning = 0x0 // bool (Size: 0x1)
TempBurningInfo.Count = 0x4 // int32_t (Size: 0x4)
TempBurningMaterialParamInfo.ParamName = 0x0 // FName (Size: 0x8)
TempBurningMaterialParamInfo.MaxValue = 0x8 // float (Size: 0x4)
TempBurningMaterialParamInfo.CurrValue = 0xc // float (Size: 0x4)
TempBurningMaterialParamInfo.ValuePerSec = 0x10 // float (Size: 0x4)
TestActivityInfo.ActivityID = 0x0 // int32_t (Size: 0x4)
TestActivityInfo.DisplayOrder = 0x4 // int32_t (Size: 0x4)
TestActivityInfo.ActivityType = 0x8 // int32_t (Size: 0x4)
ThrowableWeaponBanInfo.RowNum = 0x0 // int32_t (Size: 0x4)
ThrowableWeaponBanInfo.GrenadeItemId = 0x8 // uint64_t (Size: 0x8)
ThrowableWeaponBanInfo.HitGroup = 0x10 // uint32_t (Size: 0x4)
ThrowableWeaponBanInfo.DamageThres = 0x14 // float (Size: 0x4)
ThrowableWeaponBanInfo.DamageTimes = 0x18 // int32_t (Size: 0x4)
ThrowableWeaponBanInfo.TimesThres = 0x20 // TArray<int32_t> (Size: 0x10)
ThrowableWeaponBanInfo.BanNumber = 0x30 // uint64_t (Size: 0x8)
ThunderInfo.StartTimeStamp = 0x0 // FDateTime (Size: 0x8)
ThunderInfo.FirstStageTime = 0x8 // float (Size: 0x4)
ThunderInfo.SecondStageTime = 0xc // float (Size: 0x4)
ThunderInfo.ThirdStageTime = 0x10 // float (Size: 0x4)
ThunderInfo.ThunderTypeIndex = 0x14 // int32_t (Size: 0x4)
ThunderInfo.CurrentState = 0x18 // EEThunderstormStage (Size: 0x1)
TickSettingBaseOnURO.URO = 0x0 // TArray<FTickSettingPerURO> (Size: 0x10)
TickSettingPerURO.bEnableUpdate = 0x0 // bool (Size: 0x1)
TickSettingPerURO.TickInternal = 0x4 // float (Size: 0x4)
TickSettingPerURO.TickAccumulate = 0x8 // float (Size: 0x4)
TimedImpactEffect.EffectComp = 0x0 // SceneComponent* (Size: 0x8)
TimedImpactEffect.CreationTime = 0x8 // float (Size: 0x4)
TimedImpactEffect.LifetimeScaling = 0xc // float (Size: 0x4)
TimedImpactEffect.FadeMultiplier = 0x10 // float (Size: 0x4)
TransformBySex.Transform_Male = 0x0 // FTransform (Size: 0x30)
TransformBySex.Transform_Female = 0x30 // FTransform (Size: 0x30)
TripMineReplaceInfo.ReplacedTripMineClass = 0x0 // ClassProperty (Size: 0x8)
TripMineReplaceInfo.Probability = 0x8 // float (Size: 0x4)
TripMineStateInfo.bIsReadyForExplode = 0x0 // bool (Size: 0x1)
TripMineStateInfo.bIsLootead = 0x1 // bool (Size: 0x1)
TripMineStateInfo.bNeedReplcaceInit = 0x2 // bool (Size: 0x1)
TripMineStateInfo.WorldPos = 0x4 // FVector (Size: 0xc)
TripMineStateInfo.WorldRot = 0x10 // FRotator (Size: 0xc)
TripMineStateInfo.Pillar1Pos = 0x1c // FVector (Size: 0xc)
TripMineStateInfo.Pillar2Pos = 0x28 // FVector (Size: 0xc)
TssAntiData.bIsOverLength = 0x0 // bool (Size: 0x1)
TssAntiData.Data = 0x8 // TArray<uint8_t> (Size: 0x10)
TssAntiData.bGotData = 0x18 // bool (Size: 0x1)
UAGameBigMapConfigModeTable.BigMapInfoActor = 0x20 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameBigMapConfigModeTable.BigMapEffectDataTablePath = 0x48 // FSoftObjectPath (Size: 0x18)
UAGameModeReplayTable.OpenReplay = 0x20 // bool (Size: 0x1)
UAModeAIDifficultyTable.AIPathLevelName = 0x20 // FString (Size: 0x10)
UAModeAIDifficultyTable.AISpawnLevelName = 0x30 // FString (Size: 0x10)
UAModeAIDifficultyTable.AIPortraitToAIID = 0x40 // DataTable* (Size: 0x8)
UAModeAIDifficultyTable.AISpawnConfigID = 0x48 // int32_t (Size: 0x4)
UAModeReplicationRuleTable.ReplicationRule = 0x20 // int32_t (Size: 0x4)
UAModeReplicationRuleTable.DistanceAlwaysRelevant_Policy1 = 0x24 // float (Size: 0x4)
UAModeReplicationRuleTable.DistanceAlwaysRelevant_Policy2 = 0x28 // float (Size: 0x4)
UAModeReplicationRuleTable.DistanceAlwaysRelevant_Policy3 = 0x2c // float (Size: 0x4)
UAModeReplicationRuleTable.IsHorizontalHide = 0x30 // bool (Size: 0x1)
UAModeReplicationRuleTable.HiddenLocationX = 0x34 // float (Size: 0x4)
UAModeReplicationRuleTable.HiddenLocationY = 0x38 // float (Size: 0x4)
UAModeReplicationRuleTable.HiddenLocationZ = 0x3c // float (Size: 0x4)
UAModeThunderTable.ThunderCount = 0x20 // int32_t (Size: 0x4)
UAModeThunderTable.PlayThunderTimeInfoArray = 0x28 // TArray<FModeThunderTimeInfo> (Size: 0x10)
UAThunderDetailTable.ThunderTypeIndex = 0x8 // int32_t (Size: 0x4)
UAThunderDetailTable.FirstStageTime = 0xc // float (Size: 0x4)
UAThunderDetailTable.SecondStageTime = 0x10 // float (Size: 0x4)
UAThunderDetailTable.ThirdStageTime = 0x14 // float (Size: 0x4)
UAUFStruct.cnt = 0x0 // int32_t (Size: 0x4)
UAUFStruct.Parent = 0x8 // TMap<...> (Size: 0x50)
UAUFStruct.Rank = 0x58 // TMap<...> (Size: 0x50)
UAUFStruct.bConnected = 0xa8 // bool (Size: 0x1)
UIOpStruct.Op = 0x0 // EESGUIOperationForSpectating (Size: 0x1)
UIOpStruct.bOpen = 0x1 // bool (Size: 0x1)
UIOpStruct.Inventory = 0x8 // Actor* (Size: 0x8)
USGPasswordDoorBookComponent.IndexArea = 0x100 // FVector2D (Size: 0x8)
USGPasswordDoorBookComponent.MappingInfo = 0x108 // TArray<FPasswordDoorMappingInfo> (Size: 0x10)
UserWidgetDetailInfoNode.WidgetClass = 0x28 // ClassProperty (Size: 0x8)
UserWidgetDetailInfoNode.WidgetCount = 0x30 // int32_t (Size: 0x4)
UserWidgetDetailInfoNode.ChildNodes = 0x38 // TArray<UserWidgetDetailInfoNode*> (Size: 0x10)
UserWidgetDetailInfoNode.SelfWidgetCountList = 0x48 // TArray<int32_t> (Size: 0x10)
UserWidgetDetailInfoNode.TotalWidgetCountList = 0x58 // TArray<int32_t> (Size: 0x10)
UserWidgetPopInfo.UserWidgetClass = 0x0 // ClassProperty (Size: 0x8)
UserWidgetPopInfo.DisplaySprite = 0x8 // Object* (Size: 0x8)
UserWidgetPopInfo.DisplayText = 0x10 // FText (Size: 0x18)
UserWidgetPopInfo.UsingDisplayText = 0x28 // FText (Size: 0x18)
UserWidgetPopInfo.InteractRequireTime = 0x40 // float (Size: 0x4)
ValueNoise.Amplitude = 0x0 // float (Size: 0x4)
ValueNoise.FrequencyScale = 0x4 // float (Size: 0x4)
ValueNoiseInRange.Min = 0x0 // float (Size: 0x4)
ValueNoiseInRange.Max = 0x4 // float (Size: 0x4)
ValueTracker.TrackSize = 0x0 // int32_t (Size: 0x4)
VaultRepInfo.VaultPhase = 0x0 // EEVaultPhase (Size: 0x1)
VaultRepInfo.VaultChoice = 0x1 // EEVaultChoice (Size: 0x1)
VaultRepInfo.ObstacleHeightLevel = 0x2 // EEObstacleHeightLevel (Size: 0x1)
VaultRepInfo.CharacterForwardDiretion = 0x4 // FVector (Size: 0xc)
VaultRepInfo.CharacterTowardsObstacleDiretion = 0x10 // FVector (Size: 0xc)
VaultRepInfo.PathNodes = 0x20 // TArray<FSGPredictPathNode> (Size: 0x10)
VaultResult.VaultFailReason = 0x0 // EEVaultFailReason (Size: 0x1)
VaultResult.CharacterWantsToVaultLocation = 0x4 // FVector (Size: 0xc)
VaultResult.CharacterLocation = 0x10 // FVector (Size: 0xc)
VaultResult.CharacterFloorLocation = 0x1c // FVector (Size: 0xc)
VaultResult.CharacterForwardDiretion = 0x28 // FVector (Size: 0xc)
VaultResult.CharacterTowardsObstacleDiretion = 0x34 // FVector (Size: 0xc)
VaultResult.CharacterTowardsObstacleDegree = 0x40 // float (Size: 0x4)
VaultResult.CharacterVelocity_Horizontal = 0x44 // float (Size: 0x4)
VaultResult.CharacterAcceleration = 0x48 // FVector (Size: 0xc)
VaultResult.CharacterRotation = 0x54 // FRotator (Size: 0xc)
VaultResult.ForwardTraceDistance = 0x60 // float (Size: 0x4)
VaultResult.VaultChoice = 0x64 // EEVaultChoice (Size: 0x1)
VaultResult.FallHeight = 0x68 // float (Size: 0x4)
VaultResult.ObstacleHeight = 0x6c // float (Size: 0x4)
VaultResult.ObstacleHeightLevel = 0x70 // EEObstacleHeightLevel (Size: 0x1)
VaultResult.VaultApexPoint = 0x74 // FVector (Size: 0xc)
VaultResult.ObstacleImpactPoint = 0x80 // FVector (Size: 0xc)
VaultResult.ObstacleImpactNormal = 0x8c // FVector (Size: 0xc)
VaultResult.MovementModeAfterVault = 0x98 // uint8_t (Size: 0x1)
VaultResult.PathNodes = 0xa8 // TArray<FSGPredictPathNode> (Size: 0x10)
VectorAndDist.X = 0x0 // int32_t (Size: 0x4)
VectorAndDist.Y = 0x4 // int32_t (Size: 0x4)
VectorAndDist.Z = 0x8 // int32_t (Size: 0x4)
VectorAndDist.ManhattanDistance = 0xc // int32_t (Size: 0x4)
VehicleColorData.VehicleColor = 0x0 // FLinearColor (Size: 0x10)
VehicleColorData.RandomWeight = 0x10 // float (Size: 0x4)
VehicleDamageScale.BoneName = 0x0 // FName (Size: 0x8)
VehicleDamageScale.DamageScale = 0x8 // float (Size: 0x4)
VehicleFuelComponent.FuelAmountMax = 0xf8 // int32_t (Size: 0x4)
VehicleFuelComponent.FuelConsumeNormalPerMinute = 0xfc // float (Size: 0x4)
VehicleFuelComponent.FuelConsumeAccelPerMinute = 0x100 // float (Size: 0x4)
VehicleFuelComponent.FuelAmountCurrent = 0x104 // float (Size: 0x4)
VehicleFuelComponent.RandFuleRateMin = 0x108 // float (Size: 0x4)
VehicleFuelComponent.RandFuleRateMax = 0x10c // float (Size: 0x4)
VehicleHitInfo.HitTypeName = 0x0 // FString (Size: 0x10)
VehicleHitInfo.HitVelocity = 0x10 // float (Size: 0x4)
VehicleHitInfo.DamageValue = 0x14 // float (Size: 0x4)
VehicleHitRepInfo.bHitPlayer = 0x0 // bool (Size: 0x1)
VehicleHitRepInfo.bTurnOver = 0x1 // bool (Size: 0x1)
VehicleHitRepInfo.ToggleRep = 0x2 // bool (Size: 0x1)
VehicleHitRepInfo.OtherActor = 0x8 // Actor* (Size: 0x8)
VehicleHitSoundConfig.GrassSoundAk = 0x0 // AkAudioEvent* (Size: 0x8)
VehicleHitSoundConfig.ConcreteSoundAk = 0x8 // AkAudioEvent* (Size: 0x8)
VehicleLowHealthEffect.HealthPercent = 0x0 // float (Size: 0x4)
VehicleLowHealthEffect.IsTriggered = 0x4 // bool (Size: 0x1)
VehicleLowHealthEffect.IsAttached = 0x5 // bool (Size: 0x1)
VehicleLowHealthEffect.BoneNmae = 0x8 // FName (Size: 0x8)
VehicleLowHealthEffect.PS = 0x10 // ParticleSystem* (Size: 0x8)
VehicleLowHealthEffect.Sound = 0x18 // SoundCue* (Size: 0x8)
VehicleSeatData.SeatDataList = 0x0 // TArray<FOneSeatData> (Size: 0x10)
VehicleSeatData.MaxSeatCount = 0x14 // int32_t (Size: 0x4)
VehicleSeatData.bSeatPlayerVisible = 0x18 // bool (Size: 0x1)
VehicleSeatData.SeatSockets = 0x20 // TArray<FName> (Size: 0x10)
VehicleSeatData.LeaveVehicleSockets = 0x30 // TArray<FName> (Size: 0x10)
VehicleSeatRepData.FirstSeatChar = 0x0 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.SecondSeatChar = 0x8 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.ThirdSeatChar = 0x10 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.ForthSeatChar = 0x18 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.FiveSeatChar = 0x20 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.SixSeatChar = 0x28 // SGCharacter* (Size: 0x8)
VehicleSeatRepData.CurrentPlayerCount = 0x30 // int32_t (Size: 0x4)
VehicleSpawnWeightData.VehicleType = 0x0 // EESGVehicleType (Size: 0x1)
VehicleSpawnWeightData.Weight = 0x4 // float (Size: 0x4)
VehicleTireData.FLTireHP = 0x0 // int32_t (Size: 0x4)
VehicleTireData.FRTireHP = 0x4 // int32_t (Size: 0x4)
VehicleTireData.RLTireHP = 0x8 // int32_t (Size: 0x4)
VehicleTireData.RRTireHP = 0xc // int32_t (Size: 0x4)
ViewOffsetData.OffsetHigh = 0x0 // FVector (Size: 0xc)
ViewOffsetData.OffsetMid = 0xc // FVector (Size: 0xc)
ViewOffsetData.OffsetLow = 0x18 // FVector (Size: 0xc)
WaveInfo.WaveIndex = 0x0 // int32_t (Size: 0x4)
WaveInfo.Total = 0x4 // int32_t (Size: 0x4)
WaveInfo.Dead = 0x8 // int32_t (Size: 0x4)
WaveInfo.Destroyed = 0xc // int32_t (Size: 0x4)
WeapAdapterRepInfo.AdapterSocketRep_Muzzle = 0x0 // uint8_t (Size: 0x1)
WeapAdapterRepInfo.AdapterSocketRep_UpperRail = 0x1 // uint8_t (Size: 0x1)
WeapAdapterRepInfo.AdapterSocketRep_Magazines = 0x2 // uint8_t (Size: 0x1)
WeapAdapterRepInfo.AdapterSocketRep_LowerRail = 0x3 // uint8_t (Size: 0x1)
WeapAdapterRepInfo.AdapterSocketRep_Stocks = 0x4 // uint8_t (Size: 0x1)
WeaponAdapterAttchingInfo.AdapterClass = 0x0 // ClassProperty (Size: 0x8)
WeaponAdapterAttchingInfo.AttachingScale_1P = 0x8 // float (Size: 0x4)
WeaponAdapterAttchingInfo.AttachingScale_3P = 0xc // float (Size: 0x4)
WeaponAssembleEnvironmentInfo.SocketName = 0x0 // FName (Size: 0x8)
WeaponAssembleEnvironmentInfo.SocketIndex = 0x8 // int32_t (Size: 0x4)
WeaponAssembleEnvironmentInfo.SocketInfo = 0x10 // FAssembleSocketInfo (Size: 0x80)
WeaponAssembleEnvironmentInfo.StaticMeshComp = 0x90 // StaticMeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.SkeletalMeshComp = 0x98 // SkeletalMeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.ParentStaticMeshComp = 0xa0 // StaticMeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.ParentSkeletalMeshComp = 0xa8 // SkeletalMeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.AttachedInv = 0xb0 // SGInventory* (Size: 0x8)
WeaponAssembleEnvironmentInfo.ParentInv = 0xb8 // SGInventory* (Size: 0x8)
WeaponAssembleEnvironmentInfo.bStatic = 0xc0 // bool (Size: 0x1)
WeaponAssembleEnvironmentInfo.StaticMeshComp_Rollup = 0xc8 // SkeletalMeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.OwnedParticleSystemComponents = 0xd0 // TArray<FXSystemComponent*> (Size: 0x10)
WeaponAssembleEnvironmentInfo.ExtraMeshComponents = 0xe0 // TArray<MeshComponent*> (Size: 0x10)
WeaponAssembleEnvironmentInfo.CollectionShelfMeshComponent = 0xf0 // MeshComponent* (Size: 0x8)
WeaponAssembleEnvironmentInfo.SocketLocation = 0xfc // FVector (Size: 0xc)
WeaponAssembleEnvironmentInfo.SocketPrimitiveLocation = 0x108 // FVector (Size: 0xc)
WeaponAssembleEnvironmentInfo.SocketLocalLocation = 0x114 // FVector (Size: 0xc)
WeaponAssembleEnvironmentInfo.ParentItemID = 0x120 // int64_t (Size: 0x8)
WeaponAttachInfoStruct.TargetWeapon = 0x0 // SGInventory* (Size: 0x8)
WeaponAttachInfoStruct.SocketIndex = 0x8 // int32_t (Size: 0x4)
WeaponAttachInfoStruct.OriginalTransform = 0x10 // FTransform (Size: 0x30)
WeaponAttachTargetInfoStruct.AttachedMeshComponent = 0x0 // MeshComponent* (Size: 0x8)
WeaponAttachTargetInfoStruct.AttachedSocketName = 0x8 // FString (Size: 0x10)
WeaponAttachTargetInfoStruct.AttachedSocketOffset = 0x20 // FTransform (Size: 0x30)
WeaponDamageInfo.FireModeType = 0x0 // EESGWeaponFireMode (Size: 0x1)
WeaponDamageInfo.Damage = 0x4 // int32_t (Size: 0x4)
WeaponDamageInfo.DamageMin = 0x8 // int32_t (Size: 0x4)
WeaponDamageInfo.DamageModifyZeroDistance = 0xc // float (Size: 0x4)
WeaponDamageInfo.DamageDistanceModifier = 0x10 // float (Size: 0x4)
WeaponDamageInfo.BulletBeginDropDistance = 0x14 // float (Size: 0x4)
WeaponDamageInfo.DistanceBulletDropZ = 0x18 // float (Size: 0x4)
WeaponDamageInfo.DamageScale_Head = 0x1c // float (Size: 0x4)
WeaponDamageInfo.DamageScale_Arms = 0x20 // float (Size: 0x4)
WeaponDamageInfo.DamageScale_Stomach = 0x24 // float (Size: 0x4)
WeaponDamageInfo.DamageScale_Chest = 0x28 // float (Size: 0x4)
WeaponDamageInfo.DamageScale_Legs = 0x2c // float (Size: 0x4)
WeaponDamageInfo.TraceRange = 0x30 // float (Size: 0x4)
WeaponDamageInfo.TraceHalfAngle = 0x34 // float (Size: 0x4)
WeaponDamageInfo.DamageType = 0x38 // ClassProperty (Size: 0x8)
WeaponDamageInfo.Momentum = 0x40 // float (Size: 0x4)
WeaponDamageInfo.ImpluseRange = 0x44 // FVector (Size: 0xc)
WeaponDamageInfo.SubWeaponWallID = 0x50 // int32_t (Size: 0x4)
WeaponDamageInfo.BleedTriggerChance = 0x54 // float (Size: 0x4)
WeaponDamageStruct.WeaponName = 0x0 // FString (Size: 0x10)
WeaponDamageStruct.BulletName = 0x10 // FString (Size: 0x10)
WeaponDamageStruct.BulletID = 0x20 // uint32_t (Size: 0x4)
WeaponDamageStruct.WeaponType = 0x28 // FString (Size: 0x10)
WeaponDamageStruct.VestLevel = 0x38 // int32_t (Size: 0x4)
WeaponDamageStruct.VestId = 0x3c // int32_t (Size: 0x4)
WeaponDamageStruct.HelmetId = 0x40 // int32_t (Size: 0x4)
WeaponDamageStruct.VestName = 0x48 // FString (Size: 0x10)
WeaponDamageStruct.HelmetLevel = 0x58 // int32_t (Size: 0x4)
WeaponDamageStruct.HelmetName = 0x60 // FString (Size: 0x10)
WeaponDamageStruct.DamageHitType = 0x70 // FString (Size: 0x10)
WeaponDamageStruct.DamageHitTypeInt = 0x80 // int32_t (Size: 0x4)
WeaponDamageStruct.ShootDistance = 0x84 // float (Size: 0x4)
WeaponDamageStruct.BaseDamage = 0x88 // float (Size: 0x4)
WeaponDamageStruct.PenetrateDamage = 0x8c // float (Size: 0x4)
WeaponDamageStruct.ResultDamage = 0x90 // float (Size: 0x4)
WeaponDamageStruct.BaseMomentum = 0x94 // float (Size: 0x4)
WeaponDamageStruct.ResultMomentum = 0x98 // float (Size: 0x4)
WeaponDamageStruct.ArmorConsume = 0x9c // float (Size: 0x4)
WeaponDamageStruct.bPenetrateArmor = 0xa0 // bool (Size: 0x1)
WeaponDamageStruct.PenetrationProbability = 0xa4 // float (Size: 0x4)
WeaponDamageStruct.bBulletDeflected = 0xa8 // bool (Size: 0x1)
WeaponDamageStruct.bBrokenBullet = 0xa9 // bool (Size: 0x1)
WeaponDamageStruct.CharacterAllEndurance = 0xac // float (Size: 0x4)
WeaponDamageStruct.HitArmorName = 0xb0 // FString (Size: 0x10)
WeaponDamageStruct.CurWeaponADSTime = 0xc0 // float (Size: 0x4)
WeaponDamageStruct.CurWeaponFireInterval = 0xc4 // float (Size: 0x4)
WeaponDamageStruct.ValidAimTime = 0xc8 // float (Size: 0x4)
WeaponDamageStruct.ArmorReduceDamage = 0xcc // float (Size: 0x4)
WeaponDamageStruct.HitSubEndurance = 0xd0 // int32_t (Size: 0x4)
WeaponDamageStruct.HitArmorId = 0xd8 // int64_t (Size: 0x8)
WeaponDamageStruct.VerticalRecoil = 0xe0 // float (Size: 0x4)
WeaponDamageStruct.HorizontalRecoil = 0xe4 // float (Size: 0x4)
WeaponDamageStruct.SightName = 0xe8 // FString (Size: 0x10)
WeaponDamageStruct.WeaponId = 0xf8 // int32_t (Size: 0x4)
WeaponDamageStruct.MapID = 0xfc // int32_t (Size: 0x4)
WeaponDamageStruct.Weatherid = 0x100 // int32_t (Size: 0x4)
WeaponDamageStruct.EnemyRoleType = 0x104 // int32_t (Size: 0x4)
WeaponDamageStruct.EnemyRoleID = 0x108 // FString (Size: 0x10)
WeaponDamageStruct.EnemyUserName = 0x118 // FString (Size: 0x10)
WeaponDamageStruct.HurtTime = 0x128 // int32_t (Size: 0x4)
WeaponDamageStruct.HurtType = 0x12c // int32_t (Size: 0x4)
WeaponDamageStruct.DamageStart = 0x130 // int32_t (Size: 0x4)
WeaponDamageStruct.DamageReduce = 0x134 // int32_t (Size: 0x4)
WeaponDamageStruct.HPstart = 0x138 // int32_t (Size: 0x4)
WeaponDamageStruct.HPEnd = 0x13c // int32_t (Size: 0x4)
WeaponDamageStruct.HelmetHPStart = 0x140 // int32_t (Size: 0x4)
WeaponDamageStruct.HelmetHPEnd = 0x144 // int32_t (Size: 0x4)
WeaponDamageStruct.ArmorHPStart = 0x148 // int32_t (Size: 0x4)
WeaponDamageStruct.ArmorHPEnd = 0x14c // int32_t (Size: 0x4)
WeaponDamageStruct.HitArmorHPStart = 0x150 // float (Size: 0x4)
WeaponDamageStruct.FallHeight = 0x154 // int32_t (Size: 0x4)
WeaponDamageStruct.PlayerKilled = 0x158 // int32_t (Size: 0x4)
WeaponDamageStruct.DebuffStartList = 0x160 // FString (Size: 0x10)
WeaponDamageStruct.DebuffEndList = 0x170 // FString (Size: 0x10)
WeaponDamageStruct.HitPosition = 0x180 // FVector (Size: 0xc)
WeaponDamageStruct.HitMovableArmorID = 0x190 // int64_t (Size: 0x8)
WeaponDamageStruct.MovableArmorConsume = 0x198 // float (Size: 0x4)
WeaponDamageStruct.MovableArmorBlockDamage = 0x19c // float (Size: 0x4)
WeaponDamageStruct.TargetVestArmorID = 0x1a0 // uint32_t (Size: 0x4)
WeaponDamageStruct.TargetHelmetArmorID = 0x1a4 // uint32_t (Size: 0x4)
WeaponDamageStruct.TargetFaceShieldID = 0x1a8 // uint32_t (Size: 0x4)
WeaponDamageStruct.TargetThighArmorID = 0x1ac // uint32_t (Size: 0x4)
WeaponEventRepInfo.WeaponRepStateEventType = 0x0 // uint8_t (Size: 0x1)
WeaponEventRepInfo.WeapRepContTimes = 0x1 // uint8_t (Size: 0x1)
WeaponMeleeHitInfo.Damage = 0x0 // TArray<float> (Size: 0x10)
WeaponMeleeHitInfo.TraceRange = 0x10 // TArray<float> (Size: 0x10)
WeaponMeleeHitInfo.TraceHalfAngle = 0x20 // float (Size: 0x4)
WeaponMeleeHitInfo.DamageType = 0x28 // ClassProperty (Size: 0x8)
WeaponMeleeHitInfo.Momentum = 0x30 // float (Size: 0x4)
WeaponMeleeHitInfo.SubWeaponType = 0x34 // int32_t (Size: 0x4)
WeaponMeleeHitInfo.CheckRangeYZ = 0x38 // FVector2D (Size: 0x8)
WeaponMergeMeshShareInfo.MergedWeaponMesh = 0x18 // StaticMesh* (Size: 0x8)
WeaponMergeMeshShareInfo.DebugInfo = 0x20 // FString (Size: 0x10)
WeaponMergeMeshShareInfo.SharedCount = 0x30 // int32_t (Size: 0x4)
WeaponMergeMeshShareInfo.bValid = 0x34 // bool (Size: 0x1)
WeaponMergeMeshShareInfo.MergeStatus = 0x35 // uint8_t (Size: 0x1)
WeaponMeshWaitToAttach.WaitToAttachMap = 0x0 // TMap<...> (Size: 0x50)
WeaponRecoilAnimConfig.RecoilAnimParams = 0x0 // TArray<FWeaponRecoilAnimParams> (Size: 0x10)
WeaponRecoilAnimConfig.PivotSocket = 0x10 // FName (Size: 0x8)
WeaponRecoilAnimConfig.PivotSocketOffset = 0x18 // FVector (Size: 0xc)
WeaponRecoilAnimConfig.Curve_FOVWeight = 0x28 // CurveFloat* (Size: 0x8)
WeaponRecoilAnimConfig.WAR_RotRollOffsetMin = 0x30 // float (Size: 0x4)
WeaponRecoilAnimConfig.WAR_RotRollOffsetMax = 0x34 // float (Size: 0x4)
WeaponRecoilAnimConfig.WAR_RotPitchoffsetMin = 0x38 // float (Size: 0x4)
WeaponRecoilAnimConfig.WAR_RotPitchOffsetMax = 0x3c // float (Size: 0x4)
WeaponRecoilAnimConfig.WAR_RotYawOffsetMin = 0x40 // float (Size: 0x4)
WeaponRecoilAnimConfig.WAR_RotYawOffsetMax = 0x44 // float (Size: 0x4)
WeaponRecoilAnimConfigInstance.RecoilAnimParamInstances = 0x0 // TArray<FWeaponRecoilAnimParamsInstance> (Size: 0x10)
WeaponRecoilAnimParams.bSingleInstance = 0x0 // bool (Size: 0x1)
WeaponRecoilAnimParams.bKeepCurrentValueOnReset = 0x1 // bool (Size: 0x1)
WeaponRecoilAnimParams.bSkipFirstShot = 0x2 // bool (Size: 0x1)
WeaponRecoilAnimParams.WeapAnimRecoilType = 0x3 // EEWeapAnimRecoil (Size: 0x1)
WeaponRecoilAnimParams.AnimOffsetType = 0x4 // EEAnimOffsetType (Size: 0x1)
WeaponRecoilAnimParams.Axis = 0x5 // uint8_t (Size: 0x1)
WeaponRecoilAnimParams.WeaponAnimRecoilCurve = 0x8 // CurveVector* (Size: 0x8)
WeaponRecoilAnimParams.RandomRecoilValueGenerationParam = 0x10 // FRandomNumberGenerationParam (Size: 0x10)
WeaponRecoilAnimParams.InitialOffsetType = 0x20 // uint8_t (Size: 0x1)
WeaponRecoilAnimParams.Duration = 0x24 // float (Size: 0x4)
WeaponRecoilAnimParams.Waveform = 0x28 // EEOscillatorWaveform (Size: 0x1)
WeaponRecoilAnimParams.WaveAmplitude = 0x2c // float (Size: 0x4)
WeaponRecoilAnimParams.WavePeriod = 0x30 // float (Size: 0x4)
WeaponRecoilAnimParams.PowerBaseValue = 0x34 // float (Size: 0x4)
WeaponRecoilAnimParams.PowerFrequency = 0x38 // float (Size: 0x4)
WeaponRecoilAnimParams.BlendInTime = 0x3c // float (Size: 0x4)
WeaponRecoilAnimParams.BlendInProgressCurve = 0x40 // CurveFloat* (Size: 0x8)
WeaponRecoilAnimParams.BlendOutTime = 0x48 // float (Size: 0x4)
WeaponRecoilAnimParams.BlendOutProgressCurve = 0x50 // CurveFloat* (Size: 0x8)
WeaponRecoilAnimParams.bTimeSyncWithFire = 0x58 // bool (Size: 0x1)
WeaponRecoilAnimParams.Curve_FOVWeight = 0x60 // CurveFloat* (Size: 0x8)
WeaponRecoilAnimParams.InterpSpeed = 0x68 // float (Size: 0x4)
WeaponRecoilAnimParams.Curve_Interp = 0x70 // CurveFloat* (Size: 0x8)
WeaponRecoilAnimParams.MaxSpringSpeed = 0x78 // float (Size: 0x4)
WeaponRecoilAnimParams.SpringAccel = 0x7c // float (Size: 0x4)
WeaponRecoilAnimParams.SpeedDecay = 0x80 // float (Size: 0x4)
WeaponRecoilAnimParams.StaticDecay = 0x84 // float (Size: 0x4)
WeaponRecoilAnimParams.ResetMinSpeedThresh = 0x88 // float (Size: 0x4)
WeaponRecoilAnimParams.MinKickValue = 0x8c // float (Size: 0x4)
WeaponRecoilAnimParams.MaxKickValue = 0x90 // float (Size: 0x4)
WeaponRecoilDataSet.ADSFireRecoilAnimConfig = 0x30 // FWeaponRecoilAnimConfig (Size: 0x48)
WeaponRecoilDataSet.FireRecoilAnimConfig = 0x78 // FWeaponRecoilAnimConfig (Size: 0x48)
WeaponRecoilDataSet.RecoilKickEnable_ByFireCount = 0xc0 // CurveFloat* (Size: 0x8)
WeaponRecoilDataSet.OnRecoilConfigChanged = 0xc8 // FMulticastInlineDelegate (Size: 0x10)
WeaponRecoilRecoverParams.BeginRecoverTime = 0x0 // float (Size: 0x4)
WeaponRecoilRecoverParams.RecoverAlgorithm = 0x4 // EESGRecoilRecoverAlgorithm (Size: 0x1)
WeaponRecoilRecoverParams.ConfigDisturbRecoverSpeed = 0x8 // float (Size: 0x4)
WeaponRecoilRecoverParams.RecoverScale = 0xc // float (Size: 0x4)
WeaponRecoilRecoverParams.ConfigRecoverTime = 0x10 // float (Size: 0x4)
WeaponRecoilRecoverParams.MinBeginRecoverSpeed_Yaw = 0x14 // float (Size: 0x4)
WeaponRecoilRecoverParams.MinBeginRecoverSpeed_Pitch = 0x18 // float (Size: 0x4)
WeaponRecoilRecoverParams.RecoverSpeedCurve = 0x20 // CurveFloat* (Size: 0x8)
WeaponRecoilRepInfo.ShotNum = 0x0 // int32_t (Size: 0x4)
WeaponRecoilRepInfo.FireRecoil = 0x4 // FRotator (Size: 0xc)
WeaponRecoilRepInfo.BulletHorzRecoil = 0x10 // float (Size: 0x4)
WeaponRecoilRepInfo.BulletVertRecoil = 0x14 // float (Size: 0x4)
WeaponRecoilRepInfo.RotatorDelta = 0x18 // FRotator (Size: 0xc)
WeaponRecoilRepInfo.TargetRecoil = 0x24 // FRotator (Size: 0xc)
WeaponRepInfo.WeaponRepInfoInner = 0x0 // FSGWeaponRepInfoInner (Size: 0x18)
WeaponRepInfo.Count = 0x18 // int32_t (Size: 0x4)
WeaponScopeScaleConfigTableRow.ID = 0x8 // uint64_t (Size: 0x8)
WeaponScopeScaleConfigTableRow.WeaponScopeScale = 0x10 // TArray<FWeaponScopeScaleSG> (Size: 0x10)
WeaponScopeScaleSG.ID = 0x0 // uint64_t (Size: 0x8)
WeaponScopeScaleSG.WeaponName = 0x8 // FText (Size: 0x18)
WeaponScopeScaleSG.RoScale = 0x20 // float (Size: 0x4)
WeaponScopeScaleSG.LoScale = 0x24 // float (Size: 0x4)
WeaponScopeScaleSG.ADSGunKickScale = 0x28 // float (Size: 0x4)
WeaponSwitchScopeParams.AnimOffsetType = 0x0 // EEAnimOffsetType (Size: 0x1)
WeaponSwitchScopeParams.Axis = 0x1 // uint8_t (Size: 0x1)
WeaponSwitchScopeParams.MinValue = 0x4 // float (Size: 0x4)
WeaponSwitchScopeParams.MaxValue = 0x8 // float (Size: 0x4)
WeaponSwitchScopeParams.Curve_ScaleInterp = 0x10 // CurveFloat* (Size: 0x8)
WeaponTraceRightHandOffsetParam.LocationOffset_PullBack = 0x0 // FVector (Size: 0xc)
WeaponTraceRightHandOffsetParam.RotationOffset_PullBack = 0xc // FRotator (Size: 0xc)
WeaponTraceRightHandOffsetParam.LocationOffset_Fold = 0x18 // FVector (Size: 0xc)
WeaponTraceRightHandOffsetParam.RotationOffset = 0x24 // FRotator (Size: 0xc)
WearableMaterialSection.Tag = 0x0 // FName (Size: 0x8)
WearableMaterialSection.bSelectMaterialByKeyword = 0x8 // bool (Size: 0x1)
WearableMaterialSection.MaterialKeyWord = 0x10 // FString (Size: 0x10)
WearableMaterialSection.MaterialID = 0x20 // int32_t (Size: 0x4)
WearableMaterialSection.SectionIndex = 0x24 // int32_t (Size: 0x4)
WearableMesh.bForceTickMeshComponent = 0x0 // bool (Size: 0x1)
WearableMesh.bSwitchPrefab = 0x1 // bool (Size: 0x1)
WearableMesh.PrefabForMale = 0x8 // FWearableMeshPrefab (Size: 0x1b0)
WearableMesh.PrefabForFemale = 0x1b8 // FWearableMeshPrefab (Size: 0x1b0)
WearableMesh.Tag = 0x368 // FName (Size: 0x8)
WearableMesh.TargetSkeletalMeshAsset = 0x370 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMesh.SkeletalMesh1P = 0x398 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMesh.SkeletalMesh3P = 0x3c0 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMesh.TargetStaticMeshAsset = 0x3f0 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMesh.MeshComponent = 0x418 // MeshComponent* (Size: 0x8)
WearableMesh.AnimInstance = 0x420 // ClassProperty (Size: 0x8)
WearableMesh.AnimInstanceInGame = 0x428 // ClassProperty (Size: 0x8)
WearableMesh.AnimInstanceInLobby = 0x430 // ClassProperty (Size: 0x8)
WearableMesh.AnimInstanceUseType = 0x438 // EEAnimInstanceUseType (Size: 0x1)
WearableMesh.AttachSocket = 0x43c // FName (Size: 0x8)
WearableMesh.SkeletalMeshAttachSocket = 0x444 // FName (Size: 0x8)
WearableMesh.bUseLegacyPrefab = 0x44c // bool (Size: 0x1)
WearableMesh.bCastShadowInLobby = 0x44d // bool (Size: 0x1)
WearableMesh.HiddenFlag = 0x44e // uint8_t (Size: 0x1)
WearableMesh.DisableTickFlag = 0x44f // uint8_t (Size: 0x1)
WearableMeshAssetData.DefaultHiddenMaterialSection = 0x0 // TArray<FWearableMaterialSection> (Size: 0x10)
WearableMeshAssetData.UnderMorphTargets = 0x10 // TArray<FWearableMorphTarget> (Size: 0x10)
WearableMeshAssetData.UnderHiddenTags = 0x20 // TArray<FName> (Size: 0x10)
WearableMeshAssetData.UnderVisibleMaterialSectionTags = 0x30 // TArray<FWearableMaterialSection> (Size: 0x10)
WearableMeshEffect.EffectTemplate = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMeshEffect.SocketName = 0x28 // FName (Size: 0x8)
WearableMeshEffect.Offset = 0x30 // FVector (Size: 0xc)
WearableMeshMaterialParamOverride.MaterialIndex = 0x0 // int32_t (Size: 0x4)
WearableMeshMaterialParamOverride.ParameterName = 0x4 // FName (Size: 0x8)
WearableMeshMaterialParamOverride.Value = 0xc // FMaterialParamValue (Size: 0x1c)
WearableMeshPrefab.EnablePolicy = 0x0 // EEWearableEnablePolicy (Size: 0x1)
WearableMeshPrefab.MeshResource = 0x8 // FWearableMeshResource (Size: 0xb0)
WearableMeshPrefab.DefaultHiddenMaterialSections = 0xb8 // TArray<FWearableMaterialSection> (Size: 0x10)
WearableMeshPrefab.UnderMorphTargets = 0xc8 // TArray<FWearableMorphTarget> (Size: 0x10)
WearableMeshPrefab.UnderMorphTargetsSharing = 0xd8 // TArray<FWearableMorphTarget> (Size: 0x10)
WearableMeshPrefab.UnderHiddenTags = 0xe8 // TArray<FName> (Size: 0x10)
WearableMeshPrefab.UnderHiddenMaterialSectionTags = 0xf8 // TArray<FWearableMaterialSection> (Size: 0x10)
WearableMeshPrefab.UnderVisibleMaterialSectionTags = 0x108 // TArray<FWearableMaterialSection> (Size: 0x10)
WearableMeshPrefab.bShowMeshEffectsOn1PCharacter = 0x118 // bool (Size: 0x1)
WearableMeshPrefab.Effects = 0x120 // TArray<FWearableMeshEffect> (Size: 0x10)
WearableMeshPrefab.MaterialParamOverrides = 0x130 // TArray<FWearableMeshMaterialParamOverride> (Size: 0x10)
WearableMeshPrefab.BackAttachingSocketOffsets = 0x140 // TArray<FBackAttachSocketOffset> (Size: 0x10)
WearableMeshPrefab.BadgeAttachingSocketOffsets = 0x150 // TMap<...> (Size: 0x50)
WearableMeshPrefab.HiddenOnBackWeapons = 0x1a0 // TArray<EESGWeaponType> (Size: 0x10)
WearableMeshResource.SkeletalMeshInGame = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMeshResource.SkeletalMeshInGame1P = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMeshResource.SkeletalMeshInLobby = 0x50 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMeshResource.StaticMesh = 0x78 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMeshResource.SwitchMeshByTargetAvatarSizeAry = 0xa0 // TArray<FWearableMeshSwitchInfo> (Size: 0x10)
WearableMeshSwitchInfo.TargetvatarSlot = 0x0 // EESGAvatarType (Size: 0x1)
WearableMeshSwitchInfo.TargetSizeType = 0x1 // EEWearableMeshSizeType (Size: 0x1)
WearableMeshSwitchInfo.SwitchMeshRes = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
WearableMorphTarget.MorphTargetName = 0x0 // FName (Size: 0x8)
WearableMorphTarget.MorphTargetValue = 0x8 // float (Size: 0x4)
WeatherFootPrintMap.MapName = 0x0 // FString (Size: 0x10)
WeatherFootPrintMap.WeatherIndex = 0x10 // TArray<int32_t> (Size: 0x10)
WeatherFootPrintMap.WeatherFootPrintType = 0x20 // EFWeatherFootPrintType (Size: 0x1)
WeatherInfo.Time = 0x0 // int32_t (Size: 0x4)
WeatherInfo.WeatherList = 0x8 // TArray<int32_t> (Size: 0x10)
WeatherOverrideSettings.WeatherDefaultFootPrintType = 0x0 // EEFootPrintType (Size: 0x1)
WeatherOverrideSettings.OverrideFadeOutTime = 0x4 // float (Size: 0x4)
WeatherOverrideSettings.DecalSize = 0x8 // FVector (Size: 0xc)
WeatherOverrideSettings.FootPrintTypeTextureIndex = 0x18 // TMap<...> (Size: 0x50)
WeatherOverrideSettings.OverrideFootPrintBrightnessSettings = 0x68 // TArray<FFootPrintBrightness> (Size: 0x10)
WeatherOverrideSettings.OverrideISMMesh = 0x78 // StaticMesh* (Size: 0x8)
WeatherOverrideSettings.OverrideMaterial = 0x80 // MaterialInterface* (Size: 0x8)
WeatherOverrideSettings.OverrideFadeOutCurve = 0x88 // CurveFloat* (Size: 0x8)
WheelDustTypeByPhysicsMaterial.PhysMaterial = 0x0 // uint8_t (Size: 0x1)
WheelDustTypeByPhysicsMaterial.WheelEffect = 0x8 // ParticleSystem* (Size: 0x8)
WheelDustTypeByPhysicsMaterial.ActiveThresholdSpeed = 0x10 // float (Size: 0x4)
WheelDustTypeByPhysicsMaterial.MaterialName = 0x14 // FName (Size: 0x8)
WidgetCountDebugInfo.InstNum = 0x0 // int32_t (Size: 0x4)
WidgetCountDebugInfo.TotalChildNum = 0x4 // int32_t (Size: 0x4)
ZoneSettleSiteInfo.svr_id = 0x0 // uint64_t (Size: 0x8)
ZoneSettleSiteInfo.cmd_begin = 0x8 // uint32_t (Size: 0x4)
ZoneSettleSiteInfo.cmd_over = 0xc // uint32_t (Size: 0x4)
ZoneSettleSiteInfo.business_id = 0x10 // uint32_t (Size: 0x4)
ZoneSettleSiteInfo.GID = 0x18 // uint64_t (Size: 0x8)
ZoneSettleSiteInfo.ZoneId = 0x20 // uint32_t (Size: 0x4)
irePositionPair.position = 0x0 // FVector (Size: 0xc)
irePositionPair.ImpactNormal = 0xc // FVector (Size: 0xc)
StructSerializerArrayTestStruct.Int32Array = 0x0 // TArray<int32_t> (Size: 0x10)
StructSerializerArrayTestStruct.ByteArray = 0x10 // TArray<uint8_t> (Size: 0x10)
StructSerializerArrayTestStruct.StaticSingleElement = 0x20 // int32_t (Size: 0x4)
StructSerializerArrayTestStruct.StaticInt32Array = 0x24 // int32_t (Size: 0x4)
StructSerializerArrayTestStruct.StaticFloatArray = 0x30 // float (Size: 0x4)
StructSerializerArrayTestStruct.VectorArray = 0x40 // TArray<FVector> (Size: 0x10)
StructSerializerArrayTestStruct.StructArray = 0x50 // TArray<FStructSerializerBuiltinTestStruct> (Size: 0x10)
StructSerializerBooleanTestStruct.BoolFalse = 0x0 // bool (Size: 0x1)
StructSerializerBooleanTestStruct.BoolTrue = 0x1 // bool (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield0 = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield1 = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield2Set = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield3 = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield4Set = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield5Set = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield6 = 0x2 // uint8_t (Size: 0x1)
StructSerializerBooleanTestStruct.Bitfield7Set = 0x2 // uint8_t (Size: 0x1)
StructSerializerBuiltinTestStruct.Guid = 0x0 // FGuid (Size: 0x10)
StructSerializerBuiltinTestStruct.Name = 0x10 // FName (Size: 0x8)
StructSerializerBuiltinTestStruct.String = 0x18 // FString (Size: 0x10)
StructSerializerBuiltinTestStruct.Text = 0x28 // FText (Size: 0x18)
StructSerializerBuiltinTestStruct.Vector = 0x40 // FVector (Size: 0xc)
StructSerializerBuiltinTestStruct.Vector4 = 0x50 // FVector4 (Size: 0x10)
StructSerializerBuiltinTestStruct.Rotator = 0x60 // FRotator (Size: 0xc)
StructSerializerBuiltinTestStruct.Quat = 0x70 // FQuat (Size: 0x10)
StructSerializerBuiltinTestStruct.Color = 0x80 // FColor (Size: 0x4)
StructSerializerByteArray.Dummy1 = 0x0 // int32_t (Size: 0x4)
StructSerializerByteArray.ByteArray = 0x8 // TArray<uint8_t> (Size: 0x10)
StructSerializerByteArray.Dummy2 = 0x18 // int32_t (Size: 0x4)
StructSerializerByteArray.Int8Array = 0x20 // TArray<int8_t> (Size: 0x10)
StructSerializerByteArray.Dummy3 = 0x30 // int32_t (Size: 0x4)
StructSerializerMapTestStruct.IntToStr = 0x0 // TMap<...> (Size: 0x50)
StructSerializerMapTestStruct.StrToStr = 0x50 // TMap<...> (Size: 0x50)
StructSerializerMapTestStruct.StrToVec = 0xa0 // TMap<...> (Size: 0x50)
StructSerializerMapTestStruct.StrToStruct = 0xf0 // TMap<...> (Size: 0x50)
StructSerializerNumericTestStruct.int8 = 0x0 // int8_t (Size: 0x1)
StructSerializerNumericTestStruct.int16 = 0x2 // int16_t (Size: 0x2)
StructSerializerNumericTestStruct.int32 = 0x4 // int32_t (Size: 0x4)
StructSerializerNumericTestStruct.int64 = 0x8 // int64_t (Size: 0x8)
StructSerializerNumericTestStruct.uint8 = 0x10 // uint8_t (Size: 0x1)
StructSerializerNumericTestStruct.uint16 = 0x12 // uint16_t (Size: 0x2)
StructSerializerNumericTestStruct.uint32 = 0x14 // uint32_t (Size: 0x4)
StructSerializerNumericTestStruct.uint64 = 0x18 // uint64_t (Size: 0x8)
StructSerializerNumericTestStruct.float = 0x20 // float (Size: 0x4)
StructSerializerNumericTestStruct.Double = 0x28 // double (Size: 0x8)
StructSerializerObjectTestStruct.Class = 0x0 // ClassProperty (Size: 0x8)
StructSerializerObjectTestStruct.SubClass = 0x8 // ClassProperty (Size: 0x8)
StructSerializerObjectTestStruct.SoftClass = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
StructSerializerObjectTestStruct.Object = 0x38 // Object* (Size: 0x8)
StructSerializerObjectTestStruct.WeakObject = 0x40 // TWeakObjectPtr<UObject> (Size: 0x8)
StructSerializerObjectTestStruct.SoftObject = 0x48 // TSoftObjectPtr<UObject> (Size: 0x28)
StructSerializerObjectTestStruct.ClassPath = 0x70 // FSoftClassPath (Size: 0x18)
StructSerializerObjectTestStruct.ObjectPath = 0x88 // FSoftObjectPath (Size: 0x18)
StructSerializerSetTestStruct.StrSet = 0x0 // TSet<...> (Size: 0x50)
StructSerializerSetTestStruct.IntSet = 0x50 // TSet<...> (Size: 0x50)
StructSerializerSetTestStruct.NameSet = 0xa0 // TSet<...> (Size: 0x50)
StructSerializerSetTestStruct.StructSet = 0xf0 // TSet<...> (Size: 0x50)
StructSerializerTestStruct.Numerics = 0x0 // FStructSerializerNumericTestStruct (Size: 0x30)
StructSerializerTestStruct.Booleans = 0x30 // FStructSerializerBooleanTestStruct (Size: 0x3)
StructSerializerTestStruct.Objects = 0x38 // FStructSerializerObjectTestStruct (Size: 0xa0)
StructSerializerTestStruct.Builtins = 0xe0 // FStructSerializerBuiltinTestStruct (Size: 0x90)
StructSerializerTestStruct.Arrays = 0x170 // FStructSerializerArrayTestStruct (Size: 0x60)
StructSerializerTestStruct.Maps = 0x1d0 // FStructSerializerMapTestStruct (Size: 0x140)
StructSerializerTestStruct.Sets = 0x310 // FStructSerializerSetTestStruct (Size: 0x140)
SessionServiceLog.Category = 0x0 // FName (Size: 0x8)
SessionServiceLog.Data = 0x8 // FString (Size: 0x10)
SessionServiceLog.InstanceId = 0x18 // FGuid (Size: 0x10)
SessionServiceLog.TimeSeconds = 0x28 // double (Size: 0x8)
SessionServiceLog.Verbosity = 0x30 // uint8_t (Size: 0x1)
SessionServicePing.userName = 0x0 // FString (Size: 0x10)
SessionServicePong.Authorized = 0x0 // bool (Size: 0x1)
SessionServicePong.BuildDate = 0x8 // FString (Size: 0x10)
SessionServicePong.DeviceName = 0x18 // FString (Size: 0x10)
SessionServicePong.InstanceId = 0x28 // FGuid (Size: 0x10)
SessionServicePong.InstanceName = 0x38 // FString (Size: 0x10)
SessionServicePong.PlatformName = 0x48 // FString (Size: 0x10)
SessionServicePong.SessionId = 0x58 // FGuid (Size: 0x10)
SessionServicePong.SessionName = 0x68 // FString (Size: 0x10)
SessionServicePong.SessionOwner = 0x78 // FString (Size: 0x10)
SessionServicePong.Standalone = 0x88 // bool (Size: 0x1)
SignificanceManager.SignificanceManagerClassName = 0x108 // FSoftClassPath (Size: 0x18)
Anchors.Minimum = 0x0 // FVector2D (Size: 0x8)
Anchors.Maximum = 0x8 // FVector2D (Size: 0x8)
ButtonWidgetStyle.ButtonStyle = 0x30 // FButtonStyle (Size: 0x298)
CheckBoxWidgetStyle.CheckBoxStyle = 0x30 // FCheckBoxStyle (Size: 0x5c8)
ComboBoxWidgetStyle.ComboBoxStyle = 0x30 // FComboBoxStyle (Size: 0x420)
ComboButtonWidgetStyle.ComboButtonStyle = 0x30 // FComboButtonStyle (Size: 0x3e8)
CustomizedToolMenu.Name = 0x0 // FName (Size: 0x8)
CustomizedToolMenu.Entries = 0x8 // TMap<...> (Size: 0x50)
CustomizedToolMenu.Sections = 0x58 // TMap<...> (Size: 0x50)
CustomizedToolMenu.EntryOrder = 0xa8 // TMap<...> (Size: 0x50)
CustomizedToolMenu.SectionOrder = 0xf8 // TArray<FName> (Size: 0x10)
CustomizedToolMenuEntry.Visibility = 0x0 // EECustomizedToolMenuVisibility (Size: 0x4)
CustomizedToolMenuNameArray.Names = 0x0 // TArray<FName> (Size: 0x10)
CustomizedToolMenuSection.Visibility = 0x0 // EECustomizedToolMenuVisibility (Size: 0x4)
EditableTextBoxWidgetStyle.EditableTextBoxStyle = 0x30 // FEditableTextBoxStyle (Size: 0x868)
EditableTextWidgetStyle.EditableTextStyle = 0x30 // FEditableTextStyle (Size: 0x240)
InputChord.Key = 0x0 // FKey (Size: 0x18)
InputChord.bShift = 0x18 // uint8_t (Size: 0x1)
InputChord.bCtrl = 0x18 // uint8_t (Size: 0x1)
InputChord.bAlt = 0x18 // uint8_t (Size: 0x1)
InputChord.bCmd = 0x18 // uint8_t (Size: 0x1)
ProgressWidgetStyle.ProgressBarStyle = 0x30 // FProgressBarStyle (Size: 0x1b8)
ScrollBarWidgetStyle.ScrollBarStyle = 0x30 // FScrollBarStyle (Size: 0x518)
ScrollBoxWidgetStyle.ScrollBoxStyle = 0x30 // FScrollBoxStyle (Size: 0x248)
SlateSettings.bExplicitCanvasChildZOrder = 0x28 // bool (Size: 0x1)
SpinBoxWidgetStyle.SpinBoxStyle = 0x30 // FSpinBoxStyle (Size: 0x310)
TextBlockWidgetStyle.TextBlockStyle = 0x30 // FTextBlockStyle (Size: 0x290)
VirtualKeyboardOptions.bEnableAutocorrect = 0x0 // bool (Size: 0x1)
ButtonStyle.Normal = 0x8 // FSlateBrush (Size: 0x90)
ButtonStyle.Hovered = 0x98 // FSlateBrush (Size: 0x90)
ButtonStyle.Pressed = 0x128 // FSlateBrush (Size: 0x90)
ButtonStyle.Disabled = 0x1b8 // FSlateBrush (Size: 0x90)
ButtonStyle.NormalPadding = 0x248 // FMargin (Size: 0x10)
ButtonStyle.PressedPadding = 0x258 // FMargin (Size: 0x10)
ButtonStyle.PressedSlateSound = 0x268 // FSlateSound (Size: 0x18)
ButtonStyle.HoveredSlateSound = 0x280 // FSlateSound (Size: 0x18)
CheckBoxStyle.CheckBoxType = 0x8 // uint8_t (Size: 0x1)
CheckBoxStyle.UncheckedImage = 0x10 // FSlateBrush (Size: 0x90)
CheckBoxStyle.UncheckedHoveredImage = 0xa0 // FSlateBrush (Size: 0x90)
CheckBoxStyle.UncheckedPressedImage = 0x130 // FSlateBrush (Size: 0x90)
CheckBoxStyle.CheckedImage = 0x1c0 // FSlateBrush (Size: 0x90)
CheckBoxStyle.CheckedHoveredImage = 0x250 // FSlateBrush (Size: 0x90)
CheckBoxStyle.CheckedPressedImage = 0x2e0 // FSlateBrush (Size: 0x90)
CheckBoxStyle.UndeterminedImage = 0x370 // FSlateBrush (Size: 0x90)
CheckBoxStyle.UndeterminedHoveredImage = 0x400 // FSlateBrush (Size: 0x90)
CheckBoxStyle.UndeterminedPressedImage = 0x490 // FSlateBrush (Size: 0x90)
CheckBoxStyle.Padding = 0x520 // FMargin (Size: 0x10)
CheckBoxStyle.ForegroundColor = 0x530 // FSlateColor (Size: 0x28)
CheckBoxStyle.BorderBackgroundColor = 0x558 // FSlateColor (Size: 0x28)
CheckBoxStyle.CheckedSlateSound = 0x580 // FSlateSound (Size: 0x18)
CheckBoxStyle.UncheckedSlateSound = 0x598 // FSlateSound (Size: 0x18)
CheckBoxStyle.HoveredSlateSound = 0x5b0 // FSlateSound (Size: 0x18)
ComboBoxStyle.ComboButtonStyle = 0x8 // FComboButtonStyle (Size: 0x3e8)
ComboBoxStyle.PressedSlateSound = 0x3f0 // FSlateSound (Size: 0x18)
ComboBoxStyle.SelectionChangeSlateSound = 0x408 // FSlateSound (Size: 0x18)
ComboButtonStyle.ButtonStyle = 0x8 // FButtonStyle (Size: 0x298)
ComboButtonStyle.DownArrowImage = 0x2a0 // FSlateBrush (Size: 0x90)
ComboButtonStyle.ShadowOffset = 0x330 // FVector2D (Size: 0x8)
ComboButtonStyle.ShadowColorAndOpacity = 0x338 // FLinearColor (Size: 0x10)
ComboButtonStyle.MenuBorderBrush = 0x348 // FSlateBrush (Size: 0x90)
ComboButtonStyle.MenuBorderPadding = 0x3d8 // FMargin (Size: 0x10)
CompositeFallbackFont.Typeface = 0x0 // FTypeface (Size: 0x10)
CompositeFallbackFont.ScalingFactor = 0x10 // float (Size: 0x4)
CompositeFont.DefaultTypeface = 0x0 // FTypeface (Size: 0x10)
CompositeFont.FallbackTypeface = 0x10 // FCompositeFallbackFont (Size: 0x18)
CompositeFont.SubTypefaces = 0x28 // TArray<FCompositeSubFont> (Size: 0x10)
CompositeSubFont.CharacterRanges = 0x18 // TArray<FInt32Range> (Size: 0x10)
CompositeSubFont.Cultures = 0x28 // FString (Size: 0x10)
DockTabStyle.CloseButtonStyle = 0x8 // FButtonStyle (Size: 0x298)
DockTabStyle.NormalBrush = 0x2a0 // FSlateBrush (Size: 0x90)
DockTabStyle.ActiveBrush = 0x330 // FSlateBrush (Size: 0x90)
DockTabStyle.ColorOverlayTabBrush = 0x3c0 // FSlateBrush (Size: 0x90)
DockTabStyle.ColorOverlayIconBrush = 0x450 // FSlateBrush (Size: 0x90)
DockTabStyle.ForegroundBrush = 0x4e0 // FSlateBrush (Size: 0x90)
DockTabStyle.HoveredBrush = 0x570 // FSlateBrush (Size: 0x90)
DockTabStyle.ContentAreaBrush = 0x600 // FSlateBrush (Size: 0x90)
DockTabStyle.TabWellBrush = 0x690 // FSlateBrush (Size: 0x90)
DockTabStyle.TabPadding = 0x720 // FMargin (Size: 0x10)
DockTabStyle.OverlapWidth = 0x730 // float (Size: 0x4)
DockTabStyle.FlashColor = 0x738 // FSlateColor (Size: 0x28)
EditableTextBoxStyle.BackgroundImageNormal = 0x8 // FSlateBrush (Size: 0x90)
EditableTextBoxStyle.BackgroundImageHovered = 0x98 // FSlateBrush (Size: 0x90)
EditableTextBoxStyle.BackgroundImageFocused = 0x128 // FSlateBrush (Size: 0x90)
EditableTextBoxStyle.BackgroundImageReadOnly = 0x1b8 // FSlateBrush (Size: 0x90)
EditableTextBoxStyle.Padding = 0x248 // FMargin (Size: 0x10)
EditableTextBoxStyle.Font = 0x258 // FSlateFontInfo (Size: 0x60)
EditableTextBoxStyle.ForegroundColor = 0x2b8 // FSlateColor (Size: 0x28)
EditableTextBoxStyle.BackgroundColor = 0x2e0 // FSlateColor (Size: 0x28)
EditableTextBoxStyle.ReadOnlyForegroundColor = 0x308 // FSlateColor (Size: 0x28)
EditableTextBoxStyle.HScrollBarPadding = 0x330 // FMargin (Size: 0x10)
EditableTextBoxStyle.VScrollBarPadding = 0x340 // FMargin (Size: 0x10)
EditableTextBoxStyle.ScrollBarStyle = 0x350 // FScrollBarStyle (Size: 0x518)
EditableTextStyle.Font = 0x8 // FSlateFontInfo (Size: 0x60)
EditableTextStyle.ColorAndOpacity = 0x68 // FSlateColor (Size: 0x28)
EditableTextStyle.BackgroundImageSelected = 0x90 // FSlateBrush (Size: 0x90)
EditableTextStyle.BackgroundImageComposing = 0x120 // FSlateBrush (Size: 0x90)
EditableTextStyle.CaretImage = 0x1b0 // FSlateBrush (Size: 0x90)
ExpandableAreaStyle.CollapsedImage = 0x8 // FSlateBrush (Size: 0x90)
ExpandableAreaStyle.ExpandedImage = 0x98 // FSlateBrush (Size: 0x90)
ExpandableAreaStyle.RolloutAnimationSeconds = 0x128 // float (Size: 0x4)
FontData.FontFilename = 0x0 // FString (Size: 0x10)
FontData.Hinting = 0x10 // EEFontHinting (Size: 0x1)
FontData.LoadingPolicy = 0x11 // EEFontLoadingPolicy (Size: 0x1)
FontData.SubFaceIndex = 0x14 // int32_t (Size: 0x4)
FontData.FontFaceAsset = 0x18 // Object* (Size: 0x8)
FontOutlineSettings.OutlineSize = 0x0 // int32_t (Size: 0x4)
FontOutlineSettings.bSeparateFillAlpha = 0x4 // bool (Size: 0x1)
FontOutlineSettings.bApplyOutlineToDropShadows = 0x5 // bool (Size: 0x1)
FontOutlineSettings.OutlineMaterial = 0x8 // Object* (Size: 0x8)
FontOutlineSettings.OutlineColor = 0x10 // FLinearColor (Size: 0x10)
HeaderRowStyle.ColumnStyle = 0x8 // FTableColumnHeaderStyle (Size: 0x518)
HeaderRowStyle.LastColumnStyle = 0x520 // FTableColumnHeaderStyle (Size: 0x518)
HeaderRowStyle.ColumnSplitterStyle = 0xa38 // FSplitterStyle (Size: 0x128)
HeaderRowStyle.BackgroundBrush = 0xb60 // FSlateBrush (Size: 0x90)
HeaderRowStyle.ForegroundColor = 0xbf0 // FSlateColor (Size: 0x28)
HyperlinkStyle.UnderlineStyle = 0x8 // FButtonStyle (Size: 0x298)
HyperlinkStyle.TextStyle = 0x2a0 // FTextBlockStyle (Size: 0x290)
HyperlinkStyle.Padding = 0x530 // FMargin (Size: 0x10)
InlineEditableTextBlockStyle.EditableTextBoxStyle = 0x8 // FEditableTextBoxStyle (Size: 0x868)
InlineEditableTextBlockStyle.TextStyle = 0x870 // FTextBlockStyle (Size: 0x290)
InlineTextImageStyle.Image = 0x8 // FSlateBrush (Size: 0x90)
InlineTextImageStyle.Baseline = 0x98 // int16_t (Size: 0x2)
Margin.Left = 0x0 // float (Size: 0x4)
Margin.Top = 0x4 // float (Size: 0x4)
Margin.Right = 0x8 // float (Size: 0x4)
Margin.Bottom = 0xc // float (Size: 0x4)
ProgressBarStyle.BackgroundImage = 0x8 // FSlateBrush (Size: 0x90)
ProgressBarStyle.FillImage = 0x98 // FSlateBrush (Size: 0x90)
ProgressBarStyle.MarqueeImage = 0x128 // FSlateBrush (Size: 0x90)
ScrollBarStyle.HorizontalBackgroundImage = 0x8 // FSlateBrush (Size: 0x90)
ScrollBarStyle.VerticalBackgroundImage = 0x98 // FSlateBrush (Size: 0x90)
ScrollBarStyle.VerticalTopSlotImage = 0x128 // FSlateBrush (Size: 0x90)
ScrollBarStyle.HorizontalTopSlotImage = 0x1b8 // FSlateBrush (Size: 0x90)
ScrollBarStyle.VerticalBottomSlotImage = 0x248 // FSlateBrush (Size: 0x90)
ScrollBarStyle.HorizontalBottomSlotImage = 0x2d8 // FSlateBrush (Size: 0x90)
ScrollBarStyle.NormalThumbImage = 0x368 // FSlateBrush (Size: 0x90)
ScrollBarStyle.HoveredThumbImage = 0x3f8 // FSlateBrush (Size: 0x90)
ScrollBarStyle.DraggedThumbImage = 0x488 // FSlateBrush (Size: 0x90)
ScrollBorderStyle.TopShadowBrush = 0x8 // FSlateBrush (Size: 0x90)
ScrollBorderStyle.BottomShadowBrush = 0x98 // FSlateBrush (Size: 0x90)
ScrollBoxStyle.TopShadowBrush = 0x8 // FSlateBrush (Size: 0x90)
ScrollBoxStyle.BottomShadowBrush = 0x98 // FSlateBrush (Size: 0x90)
ScrollBoxStyle.LeftShadowBrush = 0x128 // FSlateBrush (Size: 0x90)
ScrollBoxStyle.RightShadowBrush = 0x1b8 // FSlateBrush (Size: 0x90)
SearchBoxStyle.TextBoxStyle = 0x8 // FEditableTextBoxStyle (Size: 0x868)
SearchBoxStyle.ActiveFontInfo = 0x870 // FSlateFontInfo (Size: 0x60)
SearchBoxStyle.UpArrowImage = 0x8d0 // FSlateBrush (Size: 0x90)
SearchBoxStyle.DownArrowImage = 0x960 // FSlateBrush (Size: 0x90)
SearchBoxStyle.GlassImage = 0x9f0 // FSlateBrush (Size: 0x90)
SearchBoxStyle.ClearImage = 0xa80 // FSlateBrush (Size: 0x90)
SearchBoxStyle.ImagePadding = 0xb10 // FMargin (Size: 0x10)
SearchBoxStyle.bLeftAlignButtons = 0xb20 // bool (Size: 0x1)
SlateBrush.ImageSize = 0x8 // FVector2D (Size: 0x8)
SlateBrush.Margin = 0x10 // FMargin (Size: 0x10)
SlateBrush.TintColor = 0x20 // FSlateColor (Size: 0x28)
SlateBrush.ResourceObject = 0x48 // Object* (Size: 0x8)
SlateBrush.ResourceName = 0x50 // FName (Size: 0x8)
SlateBrush.UVRegion = 0x58 // FBox2D (Size: 0x14)
SlateBrush.DrawAs = 0x6c // uint8_t (Size: 0x1)
SlateBrush.Tiling = 0x6d // uint8_t (Size: 0x1)
SlateBrush.Mirroring = 0x6e // uint8_t (Size: 0x1)
SlateBrush.ImageType = 0x6f // uint8_t (Size: 0x1)
SlateBrush.UseImageUV = 0x70 // uint8_t (Size: 0x1)
SlateBrush.IsDrawAsCircle = 0x70 // uint8_t (Size: 0x1)
SlateBrush.bIsDynamicallyLoaded = 0x88 // uint8_t (Size: 0x1)
SlateBrush.bHasUObject = 0x88 // uint8_t (Size: 0x1)
SlateColor.SpecifiedColor = 0x0 // FLinearColor (Size: 0x10)
SlateColor.ColorUseRule = 0x10 // uint8_t (Size: 0x1)
SlateFontInfo.FontObject = 0x0 // Object* (Size: 0x8)
SlateFontInfo.FontMaterial = 0x8 // Object* (Size: 0x8)
SlateFontInfo.OutlineSettings = 0x10 // FFontOutlineSettings (Size: 0x20)
SlateFontInfo.TypefaceFontName = 0x40 // FName (Size: 0x8)
SlateFontInfo.Size = 0x48 // int32_t (Size: 0x4)
SlateFontInfo.Size_Oversea = 0x4c // int32_t (Size: 0x4)
SlateFontInfo.LetterSpacing = 0x50 // int32_t (Size: 0x4)
SlateFontInfo.LetterSpacing_Oversea = 0x54 // int32_t (Size: 0x4)
SlateSound.ResourceObject = 0x0 // Object* (Size: 0x8)
SlateWidgetStyleAsset.CustomStyle = 0x28 // SlateWidgetStyleContainerBase* (Size: 0x8)
SliderStyle.NormalBarImage = 0x8 // FSlateBrush (Size: 0x90)
SliderStyle.HoveredBarImage = 0x98 // FSlateBrush (Size: 0x90)
SliderStyle.DisabledBarImage = 0x128 // FSlateBrush (Size: 0x90)
SliderStyle.NormalThumbImage = 0x1b8 // FSlateBrush (Size: 0x90)
SliderStyle.HoveredThumbImage = 0x248 // FSlateBrush (Size: 0x90)
SliderStyle.DisabledThumbImage = 0x2d8 // FSlateBrush (Size: 0x90)
SliderStyle.BarThickness = 0x368 // float (Size: 0x4)
SpinBoxStyle.BackgroundBrush = 0x8 // FSlateBrush (Size: 0x90)
SpinBoxStyle.HoveredBackgroundBrush = 0x98 // FSlateBrush (Size: 0x90)
SpinBoxStyle.ActiveFillBrush = 0x128 // FSlateBrush (Size: 0x90)
SpinBoxStyle.InactiveFillBrush = 0x1b8 // FSlateBrush (Size: 0x90)
SpinBoxStyle.ArrowsImage = 0x248 // FSlateBrush (Size: 0x90)
SpinBoxStyle.ForegroundColor = 0x2d8 // FSlateColor (Size: 0x28)
SpinBoxStyle.TextPadding = 0x300 // FMargin (Size: 0x10)
SplitterStyle.HandleNormalBrush = 0x8 // FSlateBrush (Size: 0x90)
SplitterStyle.HandleHighlightBrush = 0x98 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.SortPrimaryAscendingImage = 0x8 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.SortPrimaryDescendingImage = 0x98 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.SortSecondaryAscendingImage = 0x128 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.SortSecondaryDescendingImage = 0x1b8 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.NormalBrush = 0x248 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.HoveredBrush = 0x2d8 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.MenuDropdownImage = 0x368 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.MenuDropdownNormalBorderBrush = 0x3f8 // FSlateBrush (Size: 0x90)
TableColumnHeaderStyle.MenuDropdownHoveredBorderBrush = 0x488 // FSlateBrush (Size: 0x90)
TableRowStyle.SelectorFocusedBrush = 0x8 // FSlateBrush (Size: 0x90)
TableRowStyle.ActiveHoveredBrush = 0x98 // FSlateBrush (Size: 0x90)
TableRowStyle.ActiveBrush = 0x128 // FSlateBrush (Size: 0x90)
TableRowStyle.InactiveHoveredBrush = 0x1b8 // FSlateBrush (Size: 0x90)
TableRowStyle.InactiveBrush = 0x248 // FSlateBrush (Size: 0x90)
TableRowStyle.EvenRowBackgroundHoveredBrush = 0x2d8 // FSlateBrush (Size: 0x90)
TableRowStyle.EvenRowBackgroundBrush = 0x368 // FSlateBrush (Size: 0x90)
TableRowStyle.OddRowBackgroundHoveredBrush = 0x3f8 // FSlateBrush (Size: 0x90)
TableRowStyle.OddRowBackgroundBrush = 0x488 // FSlateBrush (Size: 0x90)
TableRowStyle.TextColor = 0x518 // FSlateColor (Size: 0x28)
TableRowStyle.SelectedTextColor = 0x540 // FSlateColor (Size: 0x28)
TableRowStyle.DropIndicator_Above = 0x568 // FSlateBrush (Size: 0x90)
TableRowStyle.DropIndicator_Onto = 0x5f8 // FSlateBrush (Size: 0x90)
TableRowStyle.DropIndicator_Below = 0x688 // FSlateBrush (Size: 0x90)
TableRowStyle.ActiveHighlightedBrush = 0x718 // FSlateBrush (Size: 0x90)
TableRowStyle.InactiveHighlightedBrush = 0x7a8 // FSlateBrush (Size: 0x90)
TextBlockStyle.Font = 0x8 // FSlateFontInfo (Size: 0x60)
TextBlockStyle.ColorAndOpacity = 0x68 // FSlateColor (Size: 0x28)
TextBlockStyle.ShadowOffset = 0x90 // FVector2D (Size: 0x8)
TextBlockStyle.ShadowColorAndOpacity = 0x98 // FLinearColor (Size: 0x10)
TextBlockStyle.SelectedBackgroundColor = 0xa8 // FSlateColor (Size: 0x28)
TextBlockStyle.HighlightColor = 0xd0 // FLinearColor (Size: 0x10)
TextBlockStyle.HighlightShape = 0xe0 // FSlateBrush (Size: 0x90)
TextBlockStyle.StrikeBrush = 0x170 // FSlateBrush (Size: 0x90)
TextBlockStyle.UnderlineBrush = 0x200 // FSlateBrush (Size: 0x90)
Typeface.Fonts = 0x0 // TArray<FTypefaceEntry> (Size: 0x10)
TypefaceEntry.Name = 0x0 // FName (Size: 0x8)
TypefaceEntry.Font = 0x8 // FFontData (Size: 0x20)
VolumeControlStyle.SliderStyle = 0x8 // FSliderStyle (Size: 0x370)
VolumeControlStyle.HighVolumeImage = 0x378 // FSlateBrush (Size: 0x90)
VolumeControlStyle.MidVolumeImage = 0x408 // FSlateBrush (Size: 0x90)
VolumeControlStyle.LowVolumeImage = 0x498 // FSlateBrush (Size: 0x90)
VolumeControlStyle.NoVolumeImage = 0x528 // FSlateBrush (Size: 0x90)
VolumeControlStyle.MutedImage = 0x5b8 // FSlateBrush (Size: 0x90)
WindowStyle.MinimizeButtonStyle = 0x8 // FButtonStyle (Size: 0x298)
WindowStyle.MaximizeButtonStyle = 0x2a0 // FButtonStyle (Size: 0x298)
WindowStyle.RestoreButtonStyle = 0x538 // FButtonStyle (Size: 0x298)
WindowStyle.CloseButtonStyle = 0x7d0 // FButtonStyle (Size: 0x298)
WindowStyle.TitleTextStyle = 0xa68 // FTextBlockStyle (Size: 0x290)
WindowStyle.ActiveTitleBrush = 0xcf8 // FSlateBrush (Size: 0x90)
WindowStyle.InactiveTitleBrush = 0xd88 // FSlateBrush (Size: 0x90)
WindowStyle.FlashTitleBrush = 0xe18 // FSlateBrush (Size: 0x90)
WindowStyle.BackgroundColor = 0xea8 // FSlateColor (Size: 0x28)
WindowStyle.OutlineBrush = 0xed0 // FSlateBrush (Size: 0x90)
WindowStyle.OutlineColor = 0xf60 // FSlateColor (Size: 0x28)
WindowStyle.BorderBrush = 0xf88 // FSlateBrush (Size: 0x90)
WindowStyle.BackgroundBrush = 0x1018 // FSlateBrush (Size: 0x90)
WindowStyle.ChildBackgroundBrush = 0x10a8 // FSlateBrush (Size: 0x90)
SpineAnimationStateMixData.From = 0x0 // FString (Size: 0x10)
SpineAnimationStateMixData.To = 0x10 // FString (Size: 0x10)
SpineAnimationStateMixData.Mix = 0x20 // float (Size: 0x4)
SpineAtlasAsset.atlasPages = 0x30 // TArray<Texture2D*> (Size: 0x10)
SpineAtlasAsset.rawData = 0x48 // FString (Size: 0x10)
SpineAtlasAsset.atlasFileName = 0x58 // FName (Size: 0x8)
SpineBoneDriverComponent.Target = 0x238 // Actor* (Size: 0x8)
SpineBoneDriverComponent.BoneName = 0x240 // FString (Size: 0x10)
SpineBoneDriverComponent.UseComponentTransform = 0x250 // bool (Size: 0x1)
SpineBoneDriverComponent.UsePosition = 0x251 // bool (Size: 0x1)
SpineBoneDriverComponent.UseRotation = 0x252 // bool (Size: 0x1)
SpineBoneDriverComponent.UseScale = 0x253 // bool (Size: 0x1)
SpineBoneFollowerComponent.Target = 0x238 // Actor* (Size: 0x8)
SpineBoneFollowerComponent.BoneName = 0x240 // FString (Size: 0x10)
SpineBoneFollowerComponent.UseComponentTransform = 0x250 // bool (Size: 0x1)
SpineBoneFollowerComponent.UsePosition = 0x251 // bool (Size: 0x1)
SpineBoneFollowerComponent.UseRotation = 0x252 // bool (Size: 0x1)
SpineBoneFollowerComponent.UseScale = 0x253 // bool (Size: 0x1)
SpineEvent.Name = 0x0 // FString (Size: 0x10)
SpineEvent.StringValue = 0x10 // FString (Size: 0x10)
SpineEvent.IntValue = 0x20 // int32_t (Size: 0x4)
SpineEvent.FloatValue = 0x24 // float (Size: 0x4)
SpineEvent.Time = 0x28 // float (Size: 0x4)
SpineSkeletonAnimationComponent.animationStart = 0x150 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.AnimationInterrupt = 0x160 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.AnimationEvent = 0x170 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.AnimationComplete = 0x180 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.animationEnd = 0x190 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.AnimationDispose = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonAnimationComponent.PreviewAnimation = 0x1b0 // FString (Size: 0x10)
SpineSkeletonAnimationComponent.PreviewSkin = 0x1c0 // FString (Size: 0x10)
SpineSkeletonAnimationComponent.trackEntries = 0x1d8 // TSet<...> (Size: 0x50)
SpineSkeletonAnimationComponent.bAutoPlaying = 0x228 // bool (Size: 0x1)
SpineSkeletonComponent.Atlas = 0xf8 // SpineAtlasAsset* (Size: 0x8)
SpineSkeletonComponent.SkeletonData = 0x100 // SpineSkeletonDataAsset* (Size: 0x8)
SpineSkeletonComponent.BeforeUpdateWorldTransform = 0x108 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonComponent.AfterUpdateWorldTransform = 0x118 // FMulticastInlineDelegate (Size: 0x10)
SpineSkeletonDataAsset.DefaultMix = 0x28 // float (Size: 0x4)
SpineSkeletonDataAsset.MixData = 0x30 // TArray<FSpineAnimationStateMixData> (Size: 0x10)
SpineSkeletonDataAsset.Bones = 0x40 // TArray<FString> (Size: 0x10)
SpineSkeletonDataAsset.Slots = 0x50 // TArray<FString> (Size: 0x10)
SpineSkeletonDataAsset.Skins = 0x60 // TArray<FString> (Size: 0x10)
SpineSkeletonDataAsset.animations = 0x70 // TArray<FString> (Size: 0x10)
SpineSkeletonDataAsset.Events = 0x80 // TArray<FString> (Size: 0x10)
SpineSkeletonDataAsset.rawData = 0x90 // TArray<uint8_t> (Size: 0x10)
SpineSkeletonDataAsset.skeletonDataFileName = 0xa0 // FName (Size: 0x8)
SpineSkeletonRendererComponent.NormalBlendMaterial = 0x668 // MaterialInterface* (Size: 0x8)
SpineSkeletonRendererComponent.AdditiveBlendMaterial = 0x670 // MaterialInterface* (Size: 0x8)
SpineSkeletonRendererComponent.MultiplyBlendMaterial = 0x678 // MaterialInterface* (Size: 0x8)
SpineSkeletonRendererComponent.ScreenBlendMaterial = 0x680 // MaterialInterface* (Size: 0x8)
SpineSkeletonRendererComponent.atlasNormalBlendMaterials = 0x688 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineSkeletonRendererComponent.atlasAdditiveBlendMaterials = 0x698 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineSkeletonRendererComponent.atlasMultiplyBlendMaterials = 0x6a8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineSkeletonRendererComponent.atlasScreenBlendMaterials = 0x6b8 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineSkeletonRendererComponent.DepthOffset = 0x6c8 // float (Size: 0x4)
SpineSkeletonRendererComponent.TextureParameterName = 0x6cc // FName (Size: 0x8)
SpineSkeletonRendererComponent.Color = 0x6d4 // FLinearColor (Size: 0x10)
SpineSkeletonRendererComponent.bCreateCollision = 0x6e4 // bool (Size: 0x1)
SpineSkeletonRendererComponent.Vertices = 0x8d8 // TArray<FVector> (Size: 0x10)
SpineSkeletonRendererComponent.Indices = 0x8e8 // TArray<int32_t> (Size: 0x10)
SpineSkeletonRendererComponent.Normals = 0x8f8 // TArray<FVector> (Size: 0x10)
SpineSkeletonRendererComponent.UVs = 0x908 // TArray<FVector2D> (Size: 0x10)
SpineSkeletonRendererComponent.Colors = 0x918 // TArray<FColor> (Size: 0x10)
SpineWidget.InitialSkin = 0x130 // FString (Size: 0x10)
SpineWidget.Atlas = 0x140 // SpineAtlasAsset* (Size: 0x8)
SpineWidget.SkeletonData = 0x148 // SpineSkeletonDataAsset* (Size: 0x8)
SpineWidget.NormalBlendMaterial = 0x150 // MaterialInterface* (Size: 0x8)
SpineWidget.AdditiveBlendMaterial = 0x158 // MaterialInterface* (Size: 0x8)
SpineWidget.MultiplyBlendMaterial = 0x160 // MaterialInterface* (Size: 0x8)
SpineWidget.ScreenBlendMaterial = 0x168 // MaterialInterface* (Size: 0x8)
SpineWidget.TextureParameterName = 0x170 // FName (Size: 0x8)
SpineWidget.DepthOffset = 0x178 // float (Size: 0x4)
SpineWidget.Color = 0x17c // FLinearColor (Size: 0x10)
SpineWidget.Brush = 0x190 // FSlateBrush (Size: 0x90)
SpineWidget.BeforeUpdateWorldTransform = 0x220 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.AfterUpdateWorldTransform = 0x230 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.animationStart = 0x240 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.AnimationInterrupt = 0x250 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.AnimationEvent = 0x260 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.AnimationComplete = 0x270 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.animationEnd = 0x280 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.AnimationDispose = 0x290 // FMulticastInlineDelegate (Size: 0x10)
SpineWidget.atlasNormalBlendMaterials = 0x2e0 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineWidget.atlasAdditiveBlendMaterials = 0x340 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineWidget.atlasMultiplyBlendMaterials = 0x3a0 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineWidget.atlasScreenBlendMaterials = 0x400 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
SpineWidget.trackEntries = 0x650 // TSet<...> (Size: 0x50)
SpineWidget.bAutoPlaying = 0x6a0 // bool (Size: 0x1)
TrackEntry.animationStart = 0x28 // FMulticastInlineDelegate (Size: 0x10)
TrackEntry.AnimationInterrupt = 0x38 // FMulticastInlineDelegate (Size: 0x10)
TrackEntry.AnimationEvent = 0x48 // FMulticastInlineDelegate (Size: 0x10)
TrackEntry.AnimationComplete = 0x58 // FMulticastInlineDelegate (Size: 0x10)
TrackEntry.animationEnd = 0x68 // FMulticastInlineDelegate (Size: 0x10)
TrackEntry.AnimationDispose = 0x78 // FMulticastInlineDelegate (Size: 0x10)
UVMapSettings.Size = 0x0 // FVector (Size: 0xc)
UVMapSettings.UVTile = 0xc // FVector2D (Size: 0x8)
UVMapSettings.position = 0x14 // FVector (Size: 0xc)
UVMapSettings.Rotation = 0x20 // FRotator (Size: 0xc)
UVMapSettings.Scale = 0x2c // FVector (Size: 0xc)
StreamlineFeatureRequirements.Support = 0x0 // EEStreamlineFeatureSupport (Size: 0x1)
StreamlineFeatureRequirements.Requirements = 0x1 // EEStreamlineFeatureRequirementsFlags (Size: 0x1)
StreamlineFeatureRequirements.RequiredOperatingSystemVersion = 0x4 // FStreamlineVersion (Size: 0xc)
StreamlineFeatureRequirements.DetectedOperatingSystemVersion = 0x10 // FStreamlineVersion (Size: 0xc)
StreamlineFeatureRequirements.RequiredDriverVersion = 0x1c // FStreamlineVersion (Size: 0xc)
StreamlineFeatureRequirements.DetectedDriverVersion = 0x28 // FStreamlineVersion (Size: 0xc)
StreamlineVersion.Major = 0x0 // int32_t (Size: 0x4)
StreamlineVersion.Minor = 0x4 // int32_t (Size: 0x4)
StreamlineVersion.Build = 0x8 // int32_t (Size: 0x4)
StreamlineOverrideSettings.EnableDLSSFGInPlayInEditorViewportsOverride = 0x28 // EEStreamlineSettingOverride (Size: 0x1)
StreamlineOverrideSettings.LoadDebugOverlayOverride = 0x29 // EEStreamlineSettingOverride (Size: 0x1)
StreamlineSettings.bEnableStreamlineD3D12 = 0x28 // bool (Size: 0x1)
StreamlineSettings.bEnableStreamlineD3D11 = 0x29 // bool (Size: 0x1)
StreamlineSettings.bEnableDLSSFGInPlayInEditorViewports = 0x2a // bool (Size: 0x1)
StreamlineSettings.bLoadDebugOverlay = 0x2b // bool (Size: 0x1)
StreamlineSettings.bAllowOTAUpdate = 0x2c // bool (Size: 0x1)
StreamlineSettings.NVIDIANGXApplicationId = 0x30 // int32_t (Size: 0x4)
SubstanceConnection.OutputIdentifier = 0x0 // FString (Size: 0x10)
SubstanceConnection.InputImageIdentifier = 0x10 // FString (Size: 0x10)
SubstanceFloatInputDesc.Min = 0x18 // TArray<float> (Size: 0x10)
SubstanceFloatInputDesc.Max = 0x28 // TArray<float> (Size: 0x10)
SubstanceFloatInputDesc.Default = 0x38 // TArray<float> (Size: 0x10)
SubstanceGraphInstance.PackageURL = 0x38 // FString (Size: 0x10)
SubstanceGraphInstance.ParentFactory = 0x48 // SubstanceInstanceFactory* (Size: 0x8)
SubstanceGraphInstance.ImageSources = 0x50 // TMap<...> (Size: 0x50)
SubstanceGraphInstance.CreatedMaterial = 0xa0 // Material* (Size: 0x8)
SubstanceGraphInstance.OutputTextureLinkData = 0xa8 // TMap<...> (Size: 0x50)
SubstanceGraphInstance.bIsFrozen = 0xf8 // bool (Size: 0x1)
SubstanceImageInput.CompressionLevelRGB = 0x80 // int32_t (Size: 0x4)
SubstanceImageInput.CompressionLevelAlpha = 0x84 // int32_t (Size: 0x4)
SubstanceImageInput.SizeX = 0x88 // int32_t (Size: 0x4)
SubstanceImageInput.SizeY = 0x8c // int32_t (Size: 0x4)
SubstanceImageInput.NumComponents = 0x90 // int32_t (Size: 0x4)
SubstanceImageInput.SourceFilePath = 0x98 // FString (Size: 0x10)
SubstanceImageInput.SourceFileTimestamp = 0xa8 // FString (Size: 0x10)
SubstanceImageInput.Consumers = 0xb8 // TArray<SubstanceGraphInstance*> (Size: 0x10)
SubstanceInputDesc.Name = 0x0 // FString (Size: 0x10)
SubstanceInputDesc.Type = 0x10 // uint8_t (Size: 0x1)
SubstanceInstanceDesc.Name = 0x0 // FString (Size: 0x10)
SubstanceInstanceDesc.Inputs = 0x10 // TArray<FSubstanceInputDesc> (Size: 0x10)
SubstanceInstanceFactory.mGraphInstances = 0x28 // TArray<SubstanceGraphInstance*> (Size: 0x10)
SubstanceInstanceFactory.RelativeSourceFilePath = 0x50 // FString (Size: 0x10)
SubstanceInstanceFactory.AbsoluteSourceFilePath = 0x60 // FString (Size: 0x10)
SubstanceInstanceFactory.SourceFileTimestamp = 0x70 // FString (Size: 0x10)
SubstanceInstanceFactory.GenerationMode = 0x80 // uint8_t (Size: 0x1)
SubstanceIntInputDesc.Min = 0x18 // TArray<int32_t> (Size: 0x10)
SubstanceIntInputDesc.Max = 0x28 // TArray<int32_t> (Size: 0x10)
SubstanceIntInputDesc.Default = 0x38 // TArray<int32_t> (Size: 0x10)
SubstanceSettings.MemoryBudgetMb = 0x28 // int32_t (Size: 0x4)
SubstanceSettings.CPUCores = 0x2c // int32_t (Size: 0x4)
SubstanceSettings.AsyncLoadMipClip = 0x30 // int32_t (Size: 0x4)
SubstanceSettings.MaxAsyncSubstancesRenderedPerFrame = 0x34 // int32_t (Size: 0x4)
SubstanceSettings.DefaultGenerationMode = 0x38 // uint8_t (Size: 0x1)
SubstanceSettings.SubstanceEngine = 0x39 // uint8_t (Size: 0x1)
SubstanceSettings.DefaultSubstanceOutputSizeX = 0x3a // uint8_t (Size: 0x1)
SubstanceSettings.DefaultSubstanceOutputSizeY = 0x3b // uint8_t (Size: 0x1)
SubstanceTexture2D.ParentInstance = 0x138 // SubstanceGraphInstance* (Size: 0x8)
SubstanceTexture2D.AddressX = 0x140 // uint8_t (Size: 0x1)
SubstanceTexture2D.AddressY = 0x141 // uint8_t (Size: 0x1)
SubstanceTexture2D.bCooked = 0x142 // bool (Size: 0x1)
TcpMessagingSettings.EnableTransport = 0x28 // bool (Size: 0x1)
TcpMessagingSettings.ListenEndpoint = 0x30 // FString (Size: 0x10)
TcpMessagingSettings.ConnectToEndpoints = 0x40 // TArray<FString> (Size: 0x10)
TcpMessagingSettings.ConnectionRetryDelay = 0x50 // int32_t (Size: 0x4)
TcpMessagingSettings.bStopServiceWhenAppDeactivates = 0x54 // bool (Size: 0x1)
FixedFrameRateCustomTimeStep.FixedFrameRate = 0x28 // FFrameRate (Size: 0x8)
GenlockedTimecodeProvider.bUseGenlockToCount = 0x30 // bool (Size: 0x1)
TimeSynchronizationSource.bUseForSynchronization = 0x28 // bool (Size: 0x1)
TimeSynchronizationSource.FrameOffset = 0x2c // int32_t (Size: 0x4)
TimedDataInputEvaluationData.DistanceToNewestSampleSeconds = 0x0 // float (Size: 0x4)
TimedDataInputEvaluationData.DistanceToOldestSampleSeconds = 0x4 // float (Size: 0x4)
ActionTip.ActionTip = 0x0 // FString (Size: 0x10)
ActionTip.ActionName = 0x10 // FString (Size: 0x10)
ActiveLoosePoint.LoosePoint = 0x8 // FLoosePoint (Size: 0x18)
ActiveLoosePoint.ActiveId = 0x20 // int32_t (Size: 0x4)
ActivityMissionConfig.LevelName = 0x40 // FString (Size: 0x10)
ActivityMissionConfig.ResidentMission = 0x50 // FActivityResidentMissionConfig (Size: 0x10)
ActivityMissionConfig.RandomMission = 0x60 // FActivityRandomMissionConfig (Size: 0x18)
ActivityMissionConfig.MaxActivityTaskNum = 0x78 // int32_t (Size: 0x4)
ActivityMissionConfig.bCloseDynamicMission = 0x7c // bool (Size: 0x1)
ActivityMissionConfig.bCloseOtherActivities = 0x7d // bool (Size: 0x1)
ActivityMissionConfig.CloseOtherActivityIDs = 0x80 // TArray<int32_t> (Size: 0x10)
ActivityQuestDistributer.ActivityQuestDistributers = 0x0 // TArray<FQuestDistributerClassWithWeight> (Size: 0x10)
ActivityRandomMissionConfig.Probability = 0x0 // float (Size: 0x4)
ActivityRandomMissionConfig.RandomTimes = 0x4 // int32_t (Size: 0x4)
ActivityRandomMissionConfig.MissionList = 0x8 // TArray<FMissionClassWeightConfig> (Size: 0x10)
ActivityResidentMissionConfig.MissionList = 0x0 // TArray<FMissionClassProbabilityConfig> (Size: 0x10)
Aliases.Rate = 0x0 // float (Size: 0x4)
Aliases.Idx = 0x4 // int32_t (Size: 0x4)
AliasesTableMessage.AliasesTable = 0x0 // TMap<...> (Size: 0x50)
AliasesTableMessage.LoosePointMessages = 0x50 // TArray<FLoosePoint> (Size: 0x10)
AsyncTaskCopyFile.OnCompleted = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AsyncTaskDownloadFile.DownloadFileDelegate = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AuctionIconScaleOverrideConfTable.item_id = 0x8 // int32_t (Size: 0x4)
AuctionIconScaleOverrideConfTable.Scale = 0xc // float (Size: 0x4)
BuglyData.URL = 0x0 // FString (Size: 0x10)
BuglyData.Time = 0x10 // FString (Size: 0x10)
CAButtonWidget.OnClicked = 0x290 // FMulticastInlineDelegate (Size: 0x10)
CAButtonWidget._button = 0x2a0 // Button* (Size: 0x8)
CACustomFixedBorder.LeftSize = 0x270 // int32_t (Size: 0x4)
CACustomFixedBorder.RightSize = 0x274 // int32_t (Size: 0x4)
CACustomFixedBorder.TopSize = 0x278 // int32_t (Size: 0x4)
CACustomFixedBorder.BottomSize = 0x27c // int32_t (Size: 0x4)
CAImage.TemplateMaterail = 0x270 // MaterialInterface* (Size: 0x8)
CAImage.DynamicTemplateMaterial = 0x278 // MaterialInstanceDynamic* (Size: 0x8)
CARuleTypeNameTableRow.Describe = 0x8 // FText (Size: 0x18)
CASearchableComboBoxString.DefaultOptions = 0x130 // TArray<FString> (Size: 0x10)
CASearchableComboBoxString.SelectedOption = 0x140 // FString (Size: 0x10)
CASearchableComboBoxString.WidgetStyle = 0x150 // FComboBoxStyle (Size: 0x420)
CASearchableComboBoxString.ItemStyle = 0x570 // FTableRowStyle (Size: 0x838)
CASearchableComboBoxString.ContentPadding = 0xda8 // FMargin (Size: 0x10)
CASearchableComboBoxString.MaxListHeight = 0xdb8 // float (Size: 0x4)
CASearchableComboBoxString.HasDownArrow = 0xdbc // bool (Size: 0x1)
CASearchableComboBoxString.EnableGamepadNavigationMode = 0xdbd // bool (Size: 0x1)
CASearchableComboBoxString.Font = 0xdc0 // FSlateFontInfo (Size: 0x60)
CASearchableComboBoxString.ForegroundColor = 0xe20 // FSlateColor (Size: 0x28)
CASearchableComboBoxString.bIsFocusable = 0xe48 // bool (Size: 0x1)
CASearchableComboBoxString.OnGenerateWidgetEvent = 0xe4c // FDelegate (Size: 0x10)
CASearchableComboBoxString.OnSelectionChanged = 0xe60 // FMulticastInlineDelegate (Size: 0x10)
CASearchableComboBoxString.OnOpening = 0xe70 // FMulticastInlineDelegate (Size: 0x10)
CommonActionKeyNameConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.ActionName = 0x10 // FText (Size: 0x18)
CommonActionKeyNameConfTableRow.OperationName = 0x28 // FText (Size: 0x18)
CommonActionKeyNameConfTableRow.Scale = 0x40 // int32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.KeyDescribeName = 0x48 // FText (Size: 0x18)
CommonActionKeyNameConfTableRow.typeId = 0x60 // int32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.KeyTypeName = 0x68 // FText (Size: 0x18)
CommonActionKeyNameConfTableRow.subTypeId = 0x80 // int32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.RelationCounts = 0x84 // int32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.ShowModeList = 0x88 // TArray<int32_t> (Size: 0x10)
CommonActionKeyNameConfTableRow.HideModeList = 0x98 // TArray<int32_t> (Size: 0x10)
CommonActionKeyNameConfTableRow.MinLevel = 0xa8 // int32_t (Size: 0x4)
CommonActionKeyNameConfTableRow.MaxLevel = 0xac // int32_t (Size: 0x4)
DynamicRandomMissionConfig.Probability = 0x0 // float (Size: 0x4)
DynamicRandomMissionConfig.RandomTimes = 0x4 // int32_t (Size: 0x4)
DynamicRandomMissionConfig.MissionList = 0x8 // TArray<FMissionClassWeightConfig> (Size: 0x10)
DynamicResidentMissionConfig.MissionList = 0x0 // TArray<FMissionClassProbabilityConfig> (Size: 0x10)
EscapePreset.PresetIndex = 0x0 // int32_t (Size: 0x4)
EscapePreset.ConstantEscapePointIDs = 0x8 // TArray<int32_t> (Size: 0x10)
EscapePreset.ConstantNum = 0x18 // int32_t (Size: 0x4)
EscapePreset.RandomEscapePointIDs = 0x20 // TArray<int32_t> (Size: 0x10)
EscapePreset.RandomNum = 0x30 // int32_t (Size: 0x4)
EscapePreset.RandomArr = 0x38 // TArray<FUAEscapeRandomStruct> (Size: 0x10)
EscapePreset.DelayedEvacuation = 0x48 // FUADelayedEvacuationStruct (Size: 0x20)
EscapeProbabilityReset.OpenProbability = 0x0 // float (Size: 0x4)
EscapeProbabilityReset.ShowProbability = 0x4 // float (Size: 0x4)
GeoSensitiveWidget.OnPaintSizeChange = 0x298 // FMulticastInlineDelegate (Size: 0x10)
GeoSensitiveWidget.OnViewportSizeChange = 0x2a8 // FMulticastInlineDelegate (Size: 0x10)
GroupedDynamicRandomMissionConfig.Probability = 0x0 // float (Size: 0x4)
GroupedDynamicRandomMissionConfig.RandomTimes = 0x4 // int32_t (Size: 0x4)
GroupedDynamicRandomMissionConfig.GroupList = 0x8 // TArray<FGroupedDynamicRandomMissionConfigItem> (Size: 0x10)
GroupedDynamicRandomMissionConfigItem.Weight = 0x0 // float (Size: 0x4)
GroupedDynamicRandomMissionConfigItem.RandomTimes = 0x4 // int32_t (Size: 0x4)
GroupedDynamicRandomMissionConfigItem.MissionList = 0x8 // TArray<FMissionClassWeightConfig> (Size: 0x10)
HttpHelper.HttpHelperDelegate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
HttpTask.HttpResponseDelegate = 0x28 // FMulticastInlineDelegate (Size: 0x10)
HttpTask.HttpGetResponseDelegate = 0x38 // FMulticastInlineDelegate (Size: 0x10)
HttpTask.HttpGetThirdPartyChannelsFriendListDelegate = 0x48 // FMulticastInlineDelegate (Size: 0x10)
HttpTask.HttpGetSupperPlayerRedPoinStateDelegate = 0x58 // FMulticastInlineDelegate (Size: 0x10)
HttpTask.ScreenNotifyName = 0x68 // FString (Size: 0x10)
HttpTask.LuaNotifyName = 0x78 // FString (Size: 0x10)
HyperlinkClickCallLuaEventData.ModuleName = 0x0 // FString (Size: 0x10)
HyperlinkClickCallLuaEventData.EventName = 0x10 // FString (Size: 0x10)
ImageLoader.LoadCompleted = 0x38 // FMulticastInlineDelegate (Size: 0x10)
ImageLoader.LoadFailed = 0x48 // FMulticastInlineDelegate (Size: 0x10)
ImageLoader.Texture = 0x58 // Texture2DDynamic* (Size: 0x8)
IniFileBackup.IniName = 0x0 // FString (Size: 0x10)
IniFileBackup.ClassesReloaded = 0x10 // TArray<FString> (Size: 0x10)
InitInventoryParams.item = 0x0 // SGPlayerItemInfoBase* (Size: 0x8)
InitInventoryParams.ParentInventory = 0x8 // Actor* (Size: 0x8)
ItemCamOffsetOverrideConf.ItemId = 0x8 // uint32_t (Size: 0x4)
ItemCamOffsetOverrideConf.Offset = 0xc // FVector (Size: 0xc)
ItemCamOffsetOverrideConf.bOverrideRotator = 0x18 // bool (Size: 0x1)
ItemCamOffsetOverrideConf.overrideRotator = 0x1c // FRotator (Size: 0xc)
ItemColorConf.Color = 0x8 // FLinearColor (Size: 0x10)
ItemColorConf.SupportTypes = 0x18 // TArray<uint32_t> (Size: 0x10)
ItemColorConf.IgnoreTypes = 0x28 // TArray<uint32_t> (Size: 0x10)
ItemColorConf.Rarity = 0x38 // TArray<int32_t> (Size: 0x10)
ItemConfTableRowBPProxy.ItemId = 0x8 // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.Name = 0x10 // FString (Size: 0x10)
ItemConfTableRowBPProxy.ShortName = 0x20 // FString (Size: 0x10)
ItemConfTableRowBPProxy.IconId = 0x30 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.Describe = 0x38 // FString (Size: 0x10)
ItemConfTableRowBPProxy.SizeX = 0x48 // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.SizeY = 0x4c // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.Weight = 0x50 // float (Size: 0x4)
ItemConfTableRowBPProxy.pickup_sound = 0x58 // FString (Size: 0x10)
ItemConfTableRowBPProxy.use_sound = 0x68 // FString (Size: 0x10)
ItemConfTableRowBPProxy.drop_sound = 0x78 // FString (Size: 0x10)
ItemConfTableRowBPProxy.sell_price = 0x88 // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.can_sell = 0x8c // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.standard_price = 0x90 // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.StackMax = 0x94 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.not_discard = 0x98 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.Bind = 0x9c // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.Rarity = 0xa0 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.Durability = 0xa4 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.UseExp = 0xa8 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.LootExp = 0xac // int32_t (Size: 0x4)
ItemConfTableRowBPProxy.RejectSlot = 0xb0 // TArray<uint8_t> (Size: 0x10)
ItemConfTableRowBPProxy.sort = 0xc0 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.jump_goto = 0xc4 // uint32_t (Size: 0x4)
ItemConfTableRowBPProxy.RarityColorIndex = 0xc8 // uint32_t (Size: 0x4)
ItemCornerIconConf.TypeName = 0x8 // FString (Size: 0x10)
ItemCornerIconConf.icon = 0x18 // PaperSprite* (Size: 0x8)
ItemInfoForRand.SuitItemsInfo = 0x0 // TMap<...> (Size: 0x50)
ItemInfoForRand.Weight = 0x50 // int32_t (Size: 0x4)
ItemIntervalTable.Item_type = 0x8 // int32_t (Size: 0x4)
ItemIntervalTable.Interval = 0xc // float (Size: 0x4)
ItemIntervalTable.item_id_interval_map = 0x10 // TMap<...> (Size: 0x50)
ItemRenderShowSizeOverrideConf.ItemType = 0x8 // int32_t (Size: 0x4)
ItemRenderShowSizeOverrideConf.Multiplier = 0xc // float (Size: 0x4)
KeyInputBlockingConfTableRow.ActionName = 0x8 // EEPCInputButton (Size: 0x1)
KeyInputBlockingConfTableRow.FrontEnd = 0x9 // bool (Size: 0x1)
KeyInputBlockingConfTableRow.InBattle = 0xa // bool (Size: 0x1)
KeyInputBlockingConfTableRow.notBagOpen = 0xb // bool (Size: 0x1)
KeyInputBlockingConfTableRow.notMapOpen = 0xc // bool (Size: 0x1)
KeyInputBlockingConfTableRow.notGamesettingOpen = 0xd // bool (Size: 0x1)
LandMarkGuide.GuideImages = 0x0 // TArray<FSoftObjectPath> (Size: 0x10)
LandMarkGuide.GuideDescription = 0x10 // TArray<FText> (Size: 0x10)
LandMarkGuide.MediaSource = 0x20 // TSoftObjectPtr<UObject> (Size: 0x28)
LandMarkGuide.AudioCallbackTypes = 0x48 // int32_t (Size: 0x4)
LandMarkGuide.AdditionalInfoURL = 0x50 // FString (Size: 0x10)
LandMarkGuide.AdditionalInfoURLOverseas = 0x60 // FString (Size: 0x10)
LoopedPanel.DefaultElementIndex = 0x158 // int32_t (Size: 0x4)
LoopedPanel.NextElementIndex = 0x15c // int32_t (Size: 0x4)
LoopedPanel.SlotPadding = 0x160 // FMargin (Size: 0x10)
LoopedPanel.AnimTime = 0x170 // float (Size: 0x4)
LoopedPanel.EnableTouchEvent = 0x174 // bool (Size: 0x1)
LoopedPanel.bTestAnimation = 0x175 // bool (Size: 0x1)
LoopedPanel.bReverseAnim = 0x176 // bool (Size: 0x1)
LoopedPanel.MinTouchDelta = 0x178 // float (Size: 0x4)
LoopedPanel.OnScrollEvent = 0x180 // FMulticastInlineDelegate (Size: 0x10)
LoopedPanel.OnAnimEndEvent = 0x190 // FMulticastInlineDelegate (Size: 0x10)
LoopedPanel.OnButtonClickedEvent = 0x1a0 // FMulticastInlineDelegate (Size: 0x10)
LoosePoint.Distribution = 0x8 // int32_t (Size: 0x4)
LoosePoint.ItemId = 0xc // int32_t (Size: 0x4)
LoosePoint.MinCount = 0x10 // int32_t (Size: 0x4)
LoosePoint.MaxCount = 0x14 // int32_t (Size: 0x4)
LoosePointAliasesTable.LinkLoosePointDetailID = 0x8 // FName (Size: 0x8)
LoosePointAliasesTable.AliasesTableMessage = 0x10 // FAliasesTableMessage (Size: 0x60)
LoosePointDetail.ID = 0x8 // int32_t (Size: 0x4)
LoosePointDetail.desc = 0x10 // FString (Size: 0x10)
LoosePointDetail.LoosePoints = 0x20 // TArray<FLoosePoint> (Size: 0x10)
LoosePointManager.LoosePointMapMessageTable = 0x310 // DataTable* (Size: 0x8)
LoosePointManager.AliasesTables = 0x318 // DataTable* (Size: 0x8)
LoosePointManager.MapLootTable = 0x320 // DataTable* (Size: 0x8)
LoosePointManager.LootDetailTable = 0x328 // DataTable* (Size: 0x8)
LoosePointManager.LoosePointsTable = 0x330 // DataTable* (Size: 0x8)
LoosePointManager.LoosePointsDetailTable = 0x338 // DataTable* (Size: 0x8)
LoosePointManager.StaticContainersTable = 0x340 // DataTable* (Size: 0x8)
LoosePointManager.MapID = 0x348 // int32_t (Size: 0x4)
LoosePointManager.RuleID = 0x34c // int32_t (Size: 0x4)
LoosePointManager.TargetCount = 0x350 // int32_t (Size: 0x4)
LoosePointManager.LooseRuleConfig = 0x358 // TArray<FMapRuleConfig> (Size: 0x10)
LoosePointMapMessage.MapID = 0x8 // int32_t (Size: 0x4)
LoosePointMapMessage.TotalWeight = 0xc // int32_t (Size: 0x4)
LoosePointMapMessage.SortLoosePoints = 0x10 // TArray<FMapLoosePoint> (Size: 0x10)
LootDetailTable.ID = 0x8 // int32_t (Size: 0x4)
LootDetailTable.Count = 0x10 // TArray<FNumDistribute> (Size: 0x10)
LootDetailTable.LoosePoints = 0x20 // TArray<FLoosePoint> (Size: 0x10)
LootDetailTable.FixedLoosePoints = 0x30 // TArray<FLoosePoint> (Size: 0x10)
LootDetailTable.ActivateLoosePoints = 0x40 // TArray<FActiveLoosePoint> (Size: 0x10)
LootDropTableRowBPProxy.ID = 0x8 // int64_t (Size: 0x8)
LootDropTableRowBPProxy.desc = 0x10 // FString (Size: 0x10)
LootDropTableRowBPProxy.ItemType = 0x20 // uint8_t (Size: 0x1)
LootDropTableRowBPProxy.ItemId = 0x28 // int64_t (Size: 0x8)
LootDropTableRowBPProxy.ItemNum = 0x30 // TArray<int32_t> (Size: 0x10)
LootDropTableRowBPProxy.SubItemTable = 0x40 // TArray<int64_t> (Size: 0x10)
LootDropTableRowBPProxy.Weight = 0x50 // int32_t (Size: 0x4)
LootDropTableRowBPProxy.Percent = 0x54 // float (Size: 0x4)
LootDropTableRowBPProxy.RandTimes = 0x58 // float (Size: 0x4)
LootDropTableRowBPProxy.OperationType = 0x5c // uint8_t (Size: 0x1)
LootDropTableRowBPProxy.IsPermanent = 0x5d // uint8_t (Size: 0x1)
LootDropTableRowBPProxy.ActID = 0x60 // uint32_t (Size: 0x4)
LootDropTableRowBPProxy.LootPointWhite = 0x68 // TArray<uint64_t> (Size: 0x10)
LootDropTableRowBPProxy.LootPointBlack = 0x78 // TArray<uint64_t> (Size: 0x10)
LootDropTableRowBPProxy.Describe = 0x88 // FString (Size: 0x10)
LootStaticPointDetailTable.ID = 0x8 // int32_t (Size: 0x4)
LootStaticPointDetailTable.desc = 0x10 // FString (Size: 0x10)
LootStaticPointDetailTable.LootDetail = 0x20 // TMap<...> (Size: 0x50)
MagazineIconConfTable.item_id = 0x8 // int32_t (Size: 0x4)
MagazineIconConfTable.min_num = 0xc // int32_t (Size: 0x4)
MapDetailTableRowBPProxy.ID = 0x8 // int32_t (Size: 0x4)
MapDetailTableRowBPProxy.map_level = 0x10 // FString (Size: 0x10)
MapDetailTableRowBPProxy.mobile_map_level = 0x20 // FString (Size: 0x10)
MapDetailTableRowBPProxy.Name = 0x30 // FString (Size: 0x10)
MapDetailTableRowBPProxy.level_path = 0x40 // FString (Size: 0x10)
MapDetailTableRowBPProxy.Picture = 0x50 // FString (Size: 0x10)
MapDetailTableRowBPProxy.desc = 0x60 // FString (Size: 0x10)
MapDetailTableRowBPProxy.MapSize = 0x70 // FVector2D (Size: 0x8)
MapDetailTableRowBPProxy.SampleScenePoints = 0x78 // TArray<FVector2D> (Size: 0x10)
MapDetailTableRowBPProxy.SampleMapPoints = 0x88 // TArray<FVector2D> (Size: 0x10)
MapLoosePoint.MapID = 0x8 // int32_t (Size: 0x4)
MapLoosePoint.RuleID = 0xc // int32_t (Size: 0x4)
MapLoosePoint.PointName = 0x10 // FString (Size: 0x10)
MapLoosePoint.Root = 0x20 // FTransform (Size: 0x30)
MapLoosePoint.LoosePointType = 0x50 // EELoosePointType (Size: 0x1)
MapLoosePoint.Comments = 0x58 // FString (Size: 0x10)
MapLoosePoint.RandomPos = 0x68 // TArray<FTransform> (Size: 0x10)
MapLoosePoint.LinkLoosePointDetailID = 0x78 // FName (Size: 0x8)
MapLoosePoint.Distributed = 0x80 // int32_t (Size: 0x4)
MapRuleConfig.RuleID = 0x0 // int32_t (Size: 0x4)
MapRuleConfig.MinCount = 0x4 // int32_t (Size: 0x4)
MapRuleConfig.MaxCount = 0x8 // int32_t (Size: 0x4)
MapStaticPointTable.MapID = 0x8 // int32_t (Size: 0x4)
MapStaticPointTable.RuleID = 0xc // int32_t (Size: 0x4)
MapStaticPointTable.LevelDifficult = 0x10 // EELevelDifficult (Size: 0x1)
MapStaticPointTable.PointName = 0x18 // FString (Size: 0x10)
MapStaticPointTable.Transform = 0x30 // FTransform (Size: 0x30)
MapStaticPointTable.LootPointType = 0x60 // int32_t (Size: 0x4)
MapStaticPointTable.InvClass = 0x68 // ClassProperty (Size: 0x8)
MapStaticPointTable.LinkStaticPointDetailId = 0x70 // int32_t (Size: 0x4)
MapStaticPointTable.Comments = 0x78 // FString (Size: 0x10)
MissionClassConfigBase.EnableSpecialIDs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionClassConfigBase.DisableSpecialIDs = 0x10 // TArray<int32_t> (Size: 0x10)
MissionClassConfigBase.EnableDifficulties = 0x20 // TArray<int32_t> (Size: 0x10)
MissionClassConfigBase.DisableDifficulties = 0x30 // TArray<int32_t> (Size: 0x10)
MissionClassProbabilityConfig.MissionFlowAsset = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
MissionClassProbabilityConfig.Probability = 0x68 // float (Size: 0x4)
MissionClassProbabilityConfig.bIgnoreActivitiy = 0x6c // bool (Size: 0x1)
MissionClassWeightConfig.MissionFlowAsset = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
MissionClassWeightConfig.Weight = 0x68 // int32_t (Size: 0x4)
ModuleConfTableRow.Name = 0x8 // FString (Size: 0x10)
ModuleConfTableRow.Context = 0x18 // FString (Size: 0x10)
ModuleConfTableRow.desc = 0x28 // FString (Size: 0x10)
ModuleContextConfTableRow.Name = 0x8 // FString (Size: 0x10)
ModuleContextConfTableRow.LevelPath = 0x18 // FString (Size: 0x10)
ModuleContextConfTableRow.desc = 0x28 // FString (Size: 0x10)
NumDistribute.Distribution = 0x8 // int32_t (Size: 0x4)
NumDistribute.Num = 0xc // int32_t (Size: 0x4)
OperationSettingVersionTableRow.VersionId = 0x8 // int32_t (Size: 0x4)
OperationSettingVersionTableRow.VersionUpgradeTip = 0x10 // FText (Size: 0x18)
PanelConfTableRow.Name = 0x8 // FString (Size: 0x10)
PanelConfTableRow.OwnerModule = 0x18 // FString (Size: 0x10)
PanelConfTableRow.AssetMobileName = 0x28 // FString (Size: 0x10)
PanelConfTableRow.LayerName = 0x38 // FString (Size: 0x10)
PanelConfTableRow.OwnerPanel = 0x48 // TArray<FString> (Size: 0x10)
PanelLayerTableRow.LayerName = 0x8 // FString (Size: 0x10)
PanelLayerTableRow.StartZOrder = 0x18 // uint32_t (Size: 0x4)
PanelProfilerStack.theStack = 0x0 // TArray<double> (Size: 0x10)
PosSensitiveWidget.OnPaintPosChange = 0x2a0 // FMulticastInlineDelegate (Size: 0x10)
QuestDistributerClassWithWeight.QuestDistributerClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
QuestDistributerClassWithWeight.Weight = 0x28 // int32_t (Size: 0x4)
RichHyperlinkStyleRow.LinkStyle = 0x8 // FHyperlinkStyle (Size: 0x540)
RicochetTable.armor_ricochetangle = 0x8 // float (Size: 0x4)
RicochetTable.armor_ricochetprobabilitymin = 0xc // float (Size: 0x4)
RicochetTable.armor_ricochetprobabilitymax = 0x10 // float (Size: 0x4)
RookieLimitTable.ID = 0x8 // int32_t (Size: 0x4)
RookieLimitTable.sys_id_changes = 0x10 // TMap<...> (Size: 0x50)
RookieTipTable.tip_id = 0x8 // int32_t (Size: 0x4)
RookieTipTable.Type = 0xc // EERookieTipType (Size: 0x1)
RookieTipTable.Text = 0x10 // FText (Size: 0x18)
RookieTipTable.listen_action = 0x28 // FString (Size: 0x10)
RookieTipTable.next_ids = 0x38 // TArray<int32_t> (Size: 0x10)
RookieTipTable.is_key = 0x48 // bool (Size: 0x1)
RookieTipTable.talkcharacter = 0x4c // int32_t (Size: 0x4)
RookieTipTable.sound_name = 0x50 // FString (Size: 0x10)
RookieTipTable.remain_time = 0x60 // float (Size: 0x4)
RookieTipTable.exec_action = 0x68 // TArray<FString> (Size: 0x10)
RookieTipTable.face_paint_ids = 0x78 // TArray<int32_t> (Size: 0x10)
RookieTipTable.delete_on_finish = 0x88 // bool (Size: 0x1)
RookieTipTable.add_to_top = 0x89 // bool (Size: 0x1)
SceneCaptureConfig.CameraTransform = 0x0 // FTransform (Size: 0x30)
SceneCaptureConfig.FOV = 0x30 // float (Size: 0x4)
SceneCaptureConfig.TextureTarget = 0x38 // TextureRenderTarget2D* (Size: 0x8)
SceneCaptureConfig.bIsCasual = 0x40 // bool (Size: 0x1)
SceneCaptureConfig.Light_Rifle_Male = 0x48 // FString (Size: 0x10)
SceneCaptureConfig.Light_Pistol_Male = 0x58 // FString (Size: 0x10)
SceneCaptureConfig.Light_Melee_Male = 0x68 // FString (Size: 0x10)
SceneCaptureConfig.Light_Rifle_Female = 0x78 // FString (Size: 0x10)
SceneCaptureConfig.Light_Pistol_Female = 0x88 // FString (Size: 0x10)
SceneCaptureConfig.Light_Melee_Female = 0x98 // FString (Size: 0x10)
ServiceConfTableRow.Name = 0x8 // FString (Size: 0x10)
ServiceConfTableRow.InitContext = 0x18 // FString (Size: 0x10)
ServiceConfTableRow.ResetContext = 0x28 // FString (Size: 0x10)
ServiceConfTableRow.desc = 0x38 // FString (Size: 0x10)
ServiceConfTableRow.ServiceType = 0x48 // FString (Size: 0x10)
ShowBtnOutlineHelper.TheOutlineMaterial = 0x310 // Material* (Size: 0x8)
ShowBtnOutlineHelper.ButtonTempId = 0x318 // int32_t (Size: 0x4)
ShowBtnOutlineHelper.BtnOriginFSlateBrush = 0x370 // TMap<...> (Size: 0x50)
ShowBtnOutlineHelper.BtnOriginAlpha = 0x3c0 // TMap<...> (Size: 0x50)
ShowBtnOutlineHelper.RefreshTimerValue = 0x410 // float (Size: 0x4)
ShowBtnOutlineHelper.RefreshTimerThreshold = 0x414 // float (Size: 0x4)
ShowBtnOutlineHelper.ShouldTransSize = 0x418 // bool (Size: 0x1)
ShowBtnOutlineHelper.IsAutomat = 0x419 // bool (Size: 0x1)
ShowBtnOutlineHelper.IsOutlineOn = 0x41a // bool (Size: 0x1)
SlicedInitParams.InitEquipmentParamsList = 0x40 // TArray<FInitInventoryParams> (Size: 0x10)
SlicedInitParams.InitItemParamsList = 0x50 // TArray<FInitInventoryParams> (Size: 0x10)
SystemUnlockTable.sys_id = 0x8 // int32_t (Size: 0x4)
SystemUnlockTable.NeedUnlockAnim = 0xc // bool (Size: 0x1)
TaskDescription.ETag = 0x0 // FString (Size: 0x10)
TaskDescription.FileSize = 0x10 // int32_t (Size: 0x4)
TextLocalizationPatch.NativeCulture = 0x0 // FString (Size: 0x10)
TextLocalizationPatch.Namespace = 0x10 // FString (Size: 0x10)
TextLocalizationPatch.Key = 0x20 // FString (Size: 0x10)
TextLocalizationPatch.NativeString = 0x30 // FString (Size: 0x10)
TextLocalizationPatch.LocalizedStrings = 0x40 // TMap<...> (Size: 0x50)
TutorialModeInputProcessor.OnPointerDownEvent = 0x28 // FDelegate (Size: 0x10)
TutorialModeInputProcessor.OnPointerUpEvent = 0x38 // FDelegate (Size: 0x10)
TutorialModeInputProcessor.OnScrollEvent = 0x48 // FDelegate (Size: 0x10)
UAAIStartGroupData.GroupIndex = 0x0 // int32_t (Size: 0x4)
UAAIStartGroupData.StartPointType = 0x4 // EEPlayerTeamType (Size: 0x1)
UAAIUniqueItemInfoTable.ItemId = 0x8 // int32_t (Size: 0x4)
UAAdviseInvPriorityTable.characterState = 0x8 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType1 = 0x18 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType2 = 0x28 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType3 = 0x38 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType4 = 0x48 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType5 = 0x58 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType6 = 0x68 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType7 = 0x78 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType8 = 0x88 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType9 = 0x98 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvType10 = 0xa8 // FString (Size: 0x10)
UAAdviseInvPriorityTable.AdviseInvTypeEnd = 0xb8 // FString (Size: 0x10)
UABattleEventTable.Describe = 0x8 // FString (Size: 0x10)
UABattleEventTable.Enabled = 0x18 // bool (Size: 0x1)
UABattleEventTable.StatisMethod = 0x19 // EEUAStatisMethod (Size: 0x1)
UABattleEventTable.ExcludeSameTeam = 0x1a // bool (Size: 0x1)
UABattleEventTable.Params = 0x20 // TArray<FUAStatisParamInfo> (Size: 0x10)
UABattleEventTable.MaxTimesInSecond = 0x30 // int32_t (Size: 0x4)
UABattleEventTable.CutGroup = 0x34 // int32_t (Size: 0x4)
UABattleEventTable.ShouldCombine = 0x38 // bool (Size: 0x1)
UABattleEventTable.Weight = 0x3c // int32_t (Size: 0x4)
UABattleEventTable.CutTrendArgsOnConstant = 0x40 // float (Size: 0x4)
UABattleEventTable.CutTrendArgsOnDistance = 0x48 // TArray<FUACutTrendArgs> (Size: 0x10)
UABattleEventTable.CutTrendArgsOnDeltaTime = 0x58 // TArray<FUACutTrendArgs> (Size: 0x10)
UABattleEventTable.CutTrendArgsOnEventValue = 0x68 // TArray<FUACutTrendArgs> (Size: 0x10)
UABattleEventTable.DescribeWord = 0x78 // FString (Size: 0x10)
UABattleEventTable.DescribeWordArgsList = 0x88 // TArray<FUADescribeWordArgs> (Size: 0x10)
UABattleEventTable.CombinedDescribeWord = 0x98 // FString (Size: 0x10)
UABattleEventTable.CombinedDescribeWordArgsList = 0xa8 // TArray<FUADescribeWordArgs> (Size: 0x10)
UABattleMapTable.MapLevel = 0x8 // FString (Size: 0x10)
UABattleMapTable.MobileMapLevel = 0x18 // FString (Size: 0x10)
UABattleMapTable.ShowIndex = 0x28 // uint32_t (Size: 0x4)
UABattleMapTable.Name = 0x30 // FString (Size: 0x10)
UABattleMapTable.Picture = 0x40 // FString (Size: 0x10)
UABattleMapTable.desc = 0x50 // FString (Size: 0x10)
UABattleMapTable.Time = 0x60 // uint32_t (Size: 0x4)
UABattleMapTable.DayStartTime = 0x64 // uint32_t (Size: 0x4)
UABattleMapTable.MinPMC = 0x68 // uint32_t (Size: 0x4)
UABattleMapTable.MaxPMC = 0x6c // uint32_t (Size: 0x4)
UABattleMapTable.IsScavJoin = 0x70 // uint32_t (Size: 0x4)
UABattleMapTable.ScavJoinTimeBegin = 0x74 // uint32_t (Size: 0x4)
UABattleMapTable.ScavJoinTimeEnd = 0x78 // uint32_t (Size: 0x4)
UABattleMapTable.NormalBeginTime = 0x7c // uint32_t (Size: 0x4)
UABattleMapTable.NormalBeginPersonNum = 0x80 // uint32_t (Size: 0x4)
UABattleMapTable.LongTimeBeginTime = 0x84 // uint32_t (Size: 0x4)
UABattleMapTable.LongTimeBeginPersonNum = 0x88 // uint32_t (Size: 0x4)
UABattleMapTable.TimeoutTime = 0x8c // uint32_t (Size: 0x4)
UABattleMapTable.SpawnAIPersonNum = 0x90 // uint32_t (Size: 0x4)
UABattleQuickChat.Messageid = 0x8 // int32_t (Size: 0x4)
UABattleQuickChat.ChatType = 0x10 // FString (Size: 0x10)
UABattleQuickChat.ListName = 0x20 // FText (Size: 0x18)
UABattleQuickChat.ChatContent = 0x38 // FText (Size: 0x18)
UABattleQuickChat.ChatSound = 0x50 // FText (Size: 0x18)
UABattleresultTable.dataid = 0x8 // uint32_t (Size: 0x4)
UABattleresultTable.AttributeType = 0xc // uint32_t (Size: 0x4)
UABattleresultTable.Proportion = 0x10 // uint32_t (Size: 0x4)
UABattleresultTable.Describe = 0x18 // FString (Size: 0x10)
UABrilliantTimeReplayTableRow.typeId = 0x8 // int32_t (Size: 0x4)
UABrilliantTimeReplayTableRow.MapID = 0xc // int32_t (Size: 0x4)
UABrilliantTimeReplayTableRow.MissionFlow = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
UABrilliantTimeReplayTableRow.MinCountToSubmit = 0x38 // int32_t (Size: 0x4)
UABrilliantTimeReplayTableRow.NeedEscapeAliveToSubmit = 0x3c // bool (Size: 0x1)
UAButtonWidget.ClickTime = 0x290 // float (Size: 0x4)
UAButtonWidget.BannedClick = 0x294 // bool (Size: 0x1)
UAButtonWidget.normalTxtShowColor = 0x298 // FLinearColor (Size: 0x10)
UAButtonWidget.pressTxtShowColor = 0x2a8 // FLinearColor (Size: 0x10)
UAButtonWidget.normalShadowOffect = 0x2b8 // FVector2D (Size: 0x8)
UAButtonWidget.pressShadowOffect = 0x2c0 // FVector2D (Size: 0x8)
UAButtonWidget.ForceUpper = 0x2c8 // bool (Size: 0x1)
UAButtonWidget.ImagePaddingLeft = 0x2cc // float (Size: 0x4)
UAButtonWidget.ImagePaddingTop = 0x2d0 // float (Size: 0x4)
UAButtonWidget.ImagePaddingRight = 0x2d4 // float (Size: 0x4)
UAButtonWidget.ImagePaddingButtom = 0x2d8 // float (Size: 0x4)
UAButtonWidget.TxtPaddingLeft = 0x2dc // float (Size: 0x4)
UAButtonWidget.TxtPaddingTop = 0x2e0 // float (Size: 0x4)
UAButtonWidget.TxtPaddingRight = 0x2e4 // float (Size: 0x4)
UAButtonWidget.TxtPaddingButtom = 0x2e8 // float (Size: 0x4)
UAButtonWidget.PressedPaddingLeft = 0x2ec // float (Size: 0x4)
UAButtonWidget.PressedPaddingTop = 0x2f0 // float (Size: 0x4)
UAButtonWidget.PressedPaddingRight = 0x2f4 // float (Size: 0x4)
UAButtonWidget.PressedPaddingButtom = 0x2f8 // float (Size: 0x4)
UAButtonWidget.isGray = 0x2fc // bool (Size: 0x1)
UAButtonWidget.OnClicked = 0x300 // FMulticastInlineDelegate (Size: 0x10)
UAButtonWidget.OnPressed = 0x310 // FMulticastInlineDelegate (Size: 0x10)
UAButtonWidget.OnReleased = 0x320 // FMulticastInlineDelegate (Size: 0x10)
UAButtonWidget.OnHovered = 0x330 // FMulticastInlineDelegate (Size: 0x10)
UAButtonWidget.OnUnhovered = 0x340 // FMulticastInlineDelegate (Size: 0x10)
UAButtonWidget.LastButtonIsPressed = 0x350 // bool (Size: 0x1)
UAButtonWidget._button = 0x358 // Button* (Size: 0x8)
UAButtonWidget._imageNormal = 0x360 // Image* (Size: 0x8)
UAButtonWidget._imagePress = 0x368 // Image* (Size: 0x8)
UAButtonWidget._imageHover = 0x370 // Image* (Size: 0x8)
UAButtonWidget._imageGray = 0x378 // Image* (Size: 0x8)
UAButtonWidget._textNormal = 0x380 // TextBlock* (Size: 0x8)
UAButtonWidget._textPress = 0x388 // TextBlock* (Size: 0x8)
UAButtonWidget._textHover = 0x390 // TextBlock* (Size: 0x8)
UAButtonWidget._textGray = 0x398 // TextBlock* (Size: 0x8)
UAButtonWidget._imageNormalSlot = 0x3a0 // OverlaySlot* (Size: 0x8)
UAButtonWidget._imagePressSlot = 0x3a8 // OverlaySlot* (Size: 0x8)
UAButtonWidget._imageHoverSlot = 0x3b0 // OverlaySlot* (Size: 0x8)
UAButtonWidget._imageGraySlot = 0x3b8 // OverlaySlot* (Size: 0x8)
UAButtonWidget._textNormalSlot = 0x3c0 // OverlaySlot* (Size: 0x8)
UAButtonWidget._textPressSlot = 0x3c8 // OverlaySlot* (Size: 0x8)
UAButtonWidget._textHoverSlot = 0x3d0 // OverlaySlot* (Size: 0x8)
UAButtonWidget._textGraySlot = 0x3d8 // OverlaySlot* (Size: 0x8)
UACaptureTableRow.ID = 0x8 // uint32_t (Size: 0x4)
UACaptureTableRow.X = 0xc // int32_t (Size: 0x4)
UACaptureTableRow.Y = 0x10 // int32_t (Size: 0x4)
UACaptureTableRow.Z = 0x14 // int32_t (Size: 0x4)
UACharacterAIRandomInventoryComponent.TryTimesBeforeUsingDefault = 0x2e8 // int32_t (Size: 0x4)
UACharacterAIRandomInventoryComponent.TryInterval = 0x2ec // float (Size: 0x4)
UACharacterAIRandomInventoryComponent.TryTimesBeforeUsingDefault_WeaponConfig = 0x2f0 // int32_t (Size: 0x4)
UACharacterAIRandomInventoryComponent.TryInterval_WeaponConfig = 0x2f4 // float (Size: 0x4)
UACharacterAIRandomInventoryComponent.InitWeapon = 0x2f8 // SGInventory* (Size: 0x8)
UACharacterAIRandomInventoryComponent.SuitArray = 0x358 // TArray<FItemInfoForRand> (Size: 0x10)
UACharacterAIRandomInventoryComponent.SuitArrayNoRandomTest = 0x368 // TArray<FItemInfoForRand> (Size: 0x10)
UACharacterAIRandomInventoryComponent.InventoryInUsing = 0x378 // SGInventory* (Size: 0x8)
UACharacterAIRandomInventoryComponent.LastTimeUseInventory = 0x380 // float (Size: 0x4)
UACharacterDefaultInventoryComp.bForceGiveInventory = 0x2e0 // bool (Size: 0x1)
UACharacterDefaultInventoryComp.bDelayBeginPlayOver = 0x2e1 // bool (Size: 0x1)
UACharacterDefaultInventoryComp.StandAloneAvatarArray = 0x2e8 // TArray<int64_t> (Size: 0x10)
UACharacterDefaultInventoryCompBase.bOwnedByAI = 0x138 // bool (Size: 0x1)
UACharacterDefaultInventoryCompBase.bUseSlicedInit = 0x139 // bool (Size: 0x1)
UACharacterDefaultInventoryCompBase.MaxSlicedinterval = 0x13c // float (Size: 0x4)
UACharacterDefaultInventoryCompBase.FakeAvatar_Head = 0x140 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.FakeAvatar_Torse = 0x150 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.FakeAvatar_Gloves = 0x160 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.FakeAvatar_Legs = 0x170 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.FakeAvatar_Shoes = 0x180 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.FakeAvatar_Watch = 0x190 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.bTestMultiAvatar = 0x1a0 // bool (Size: 0x1)
UACharacterDefaultInventoryCompBase.bSpawnSecondMainWeapon = 0x1a1 // bool (Size: 0x1)
UACharacterDefaultInventoryCompBase.PlayerItemIdtoInventoryMap = 0x1a8 // TMap<...> (Size: 0x50)
UACharacterDefaultInventoryCompBase.SlicedInitParams = 0x1f8 // SlicedInitParams* (Size: 0x8)
UACharacterDefaultInventoryCompBase.InventoryGiveComponent = 0x200 // SGCharacterInventoryGiveComponent* (Size: 0x8)
UACharacterDefaultInventoryCompBase.CachedDropItems = 0x220 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
UACharacterDefaultInventoryCompBase.CacheInventoryValues = 0x230 // TMap<...> (Size: 0x50)
UACharacterDefaultInventoryCompBase.TestInventoryPool_Weapon = 0x280 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.TestInventoryPool_MeleeWeapon = 0x290 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.TestInventoryPool_Bag = 0x2a0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.TestInventoryPool_VestBag = 0x2b0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.TestInventoryPool_Helmet = 0x2c0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterDefaultInventoryCompBase.TestInventoryPool_Vest = 0x2d0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterPreviewComponent.CaptureMaterialParameterCollection = 0x448 // MaterialParameterCollection* (Size: 0x8)
UACharacterPreviewComponent.HairSpecularLight = 0x450 // FLinearColor (Size: 0x10)
UACharacterPreviewComponent.SceneCaptureConfigs = 0x460 // TMap<...> (Size: 0x50)
UACharacterPreviewComponent.CaptureLightSets = 0x4b0 // ClassProperty (Size: 0x8)
UACharacterPreviewComponent.CaptureCharacterFacialSequenceName = 0x4b8 // TMap<...> (Size: 0x50)
UACharacterPreviewComponent.BadgeVelcroAsset = 0x508 // TSoftObjectPtr<UObject> (Size: 0x28)
UACharacterPreviewComponent.CaptureCharacterSequenceName = 0x530 // TMap<...> (Size: 0x50)
UACharacterPreviewComponent.PreviewCharacterFPTag = 0x580 // FName (Size: 0x8)
UACharacterPreviewComponent.BadgeVelcroAttachBoneTag = 0x588 // FName (Size: 0x8)
UACharacterPreviewComponent.BadgeAttachBoneTag = 0x590 // FName (Size: 0x8)
UACharacterPreviewComponent.CurCaptureSceneName = 0x598 // FString (Size: 0x10)
UACharacterPreviewComponent.bPistolGrip = 0x5a8 // bool (Size: 0x1)
UACharacterPreviewComponent.IsStopCapture = 0x5a9 // bool (Size: 0x1)
UACharacterPreviewComponent.CacheGestureMontage = 0x5b0 // AnimMontage* (Size: 0x8)
UACharacterPreviewComponent.BadgeMeshComponent = 0x5c8 // SkeletalMeshComponent* (Size: 0x8)
UACharacterPreviewComponent.BadgeVelcroMeshComponent = 0x5d0 // SkeletalMeshComponent* (Size: 0x8)
UACharacterPreviewComponent.CaptureLight = 0x5f8 // SGCaptureCharacterLights* (Size: 0x8)
UACharacterPreviewComponent.AnimNotifyConfig = 0x600 // AnimNotify_CaptureCharacterConfig* (Size: 0x8)
UACutTrendArgs.A = 0x8 // float (Size: 0x4)
UACutTrendArgs.B = 0xc // float (Size: 0x4)
UACutTrendArgs.N = 0x10 // float (Size: 0x4)
UADelayedEvacuationStruct.GameSeconds = 0x0 // int32_t (Size: 0x4)
UADelayedEvacuationStruct.Probability = 0x4 // int32_t (Size: 0x4)
UADelayedEvacuationStruct.EscapePointIDs = 0x8 // TArray<FUAEscapeRandomWeightStruct> (Size: 0x10)
UADelayedEvacuationStruct.RandomNum = 0x18 // int32_t (Size: 0x4)
UADelayedEvacuationStruct.ReportID = 0x1c // int32_t (Size: 0x4)
UADescribeWordArgs.arg = 0x8 // FString (Size: 0x10)
UADescribeWordArgs.ResolveMethod = 0x18 // EEUAArgResolveMethod (Size: 0x1)
UAEditableTextBox.OnContextMenuOpeningDelegate = 0xad8 // FDelegate (Size: 0x10)
UAEscapeInteractTextTable.EscapeInteractID = 0x8 // int32_t (Size: 0x4)
UAEscapeInteractTextTable.InteractText = 0x10 // FText (Size: 0x18)
UAEscapeRandomStruct.EscapePointIDs = 0x0 // TArray<FUAEscapeRandomWeightStruct> (Size: 0x10)
UAEscapeRandomStruct.RandomNum = 0x10 // int32_t (Size: 0x4)
UAEscapeRandomWeightStruct.EscapePointID = 0x0 // int32_t (Size: 0x4)
UAEscapeRandomWeightStruct.Weight = 0x4 // int32_t (Size: 0x4)
UAEscapeTextTableRow.EscapePointID = 0x8 // int32_t (Size: 0x4)
UAEscapeTextTableRow.EscapeName = 0x10 // FText (Size: 0x18)
UAEscapeTextTableRow.ConditionDescription = 0x28 // FText (Size: 0x18)
UAEscapeTextTableRow.ConditionDescShort = 0x40 // FText (Size: 0x18)
UAEscapeTextTableRow.ConditionPassText = 0x58 // FText (Size: 0x18)
UAEscapeTextTableRow.EscapeDescription = 0x70 // FText (Size: 0x18)
UAEscapeTextTableRow.RemainTimeText = 0x88 // FText (Size: 0x18)
UAEscapeTextTableRow.AlreadyFailText = 0xa0 // FText (Size: 0x18)
UAEscapeTextTableRow.EscapeReportID = 0xb8 // int32_t (Size: 0x4)
UAEscapeTextTableRow.PersonHitContent = 0xc0 // FText (Size: 0x18)
UAEscapeTextTableRow.GlobalHitContent = 0xd8 // FText (Size: 0x18)
UAEscapeTextTableRow.GlobalCloseHitContent = 0xf0 // FText (Size: 0x18)
UAEscapeTextTableRow.Location = 0x108 // FVector (Size: 0xc)
UAEscapeTextTableRow.GlobalLeftTimeHitContent_OpenEscape = 0x118 // FText (Size: 0x18)
UAEscapeTextTableRow.GlobalLeftTimeHitContent_CloseEscape = 0x130 // FText (Size: 0x18)
UAEscapeTextTableRow.bPreConditionCheck = 0x148 // bool (Size: 0x1)
UAEscapeTextTableRow.bNotifyOnEscapeAvailable = 0x149 // bool (Size: 0x1)
UAEscapeTextTableRow.bOverrideCostInventory = 0x14a // bool (Size: 0x1)
UAEscapeTextTableRow.CostInventoryInfo = 0x150 // FInteractInventoryInfo (Size: 0x10)
UAFactionMappingTable.FactionID = 0x8 // int32_t (Size: 0x4)
UAFactionMappingTable.FactionType = 0xc // EEFactionType (Size: 0x1)
UAFactionRelationTable.NormalPMC = 0x8 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.NormalScav = 0x9 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.PlayerScav = 0xa // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.RebelFaction = 0xb // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.LakeFaction = 0xc // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.GangsterFaction = 0xd // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.KurtTeam = 0xe // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.NavyFaction = 0xf // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.Blackgold = 0x10 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.Gnesk = 0x11 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.MadDog = 0x12 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.RoleplayA = 0x13 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.RoleplayB = 0x14 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.Cleaner = 0x15 // EEFactionRelationType (Size: 0x1)
UAFactionRelationTable.Kamona = 0x16 // EEFactionRelationType (Size: 0x1)
UAFontMeasure.bSingleMode = 0x38 // bool (Size: 0x1)
UAFontMeasure.SelectIndex = 0x3c // uint32_t (Size: 0x4)
UAFontMeasure.ExtraInfo = 0x40 // FString (Size: 0x10)
UAFrontEndStageTableRow.ID = 0x8 // uint32_t (Size: 0x4)
UAFrontEndStageTableRow.CameraTag = 0x10 // FString (Size: 0x10)
UAFrontEndStageTableRow.SequenceTag = 0x20 // FString (Size: 0x10)
UAFrontEndStageTableRow.bReversePlay = 0x30 // bool (Size: 0x1)
UAFrontEndStageTableRow.CameraStartFocus = 0x38 // FString (Size: 0x10)
UAFrontEndStageTableRow.CameraEndFocus = 0x48 // FString (Size: 0x10)
UAFrontEndStageTableRow.CameraMoveSpeed = 0x58 // float (Size: 0x4)
UAFrontEndStageTableRow.bNeedSfx = 0x5c // bool (Size: 0x1)
UAFrontEndStageTableRow.Comment = 0x60 // FString (Size: 0x10)
UAGachaMapTable.ItemId = 0x8 // uint64_t (Size: 0x8)
UAGachaMapTable.WeaponId = 0x10 // uint32_t (Size: 0x4)
UAGachaMapTable.Num = 0x14 // uint32_t (Size: 0x4)
UAGachaMapTable.Weight = 0x18 // uint32_t (Size: 0x4)
UAGameBigMapEffectTable.Messageid = 0x8 // int32_t (Size: 0x4)
UAGameBigMapEffectTable.MapID = 0xc // int32_t (Size: 0x4)
UAGameBigMapEffectTable.LandMarkID = 0x10 // int32_t (Size: 0x4)
UAGameBigMapEffectTable.TemplateUMG_Resource = 0x18 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameBigMapEffectTable.StartAtScale = 0x40 // float (Size: 0x4)
UAGameBigMapEffectTable.EndAtScale = 0x44 // float (Size: 0x4)
UAGameBigMapEffectTable.ShowAtInit = 0x48 // bool (Size: 0x1)
UAGameBigMapEffectTable.DynamicSize = 0x49 // bool (Size: 0x1)
UAGameBigMapEffectTable.InitSize = 0x4c // int32_t (Size: 0x4)
UAGameBigMapEffectTable.AreaIDs = 0x50 // TArray<int32_t> (Size: 0x10)
UAGameBigMapModuleModeTable.BigMapModule = 0x8 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameBigMapModuleModeTable.DisplayName = 0x30 // FText (Size: 0x18)
UAGameBigMapModuleModeTable.enable = 0x48 // bool (Size: 0x1)
UAGameBigMapModuleModeTable.Switchable = 0x49 // bool (Size: 0x1)
UAGameBigMapModuleModeTable.DefaultState = 0x4a // bool (Size: 0x1)
UAGameHUDTable.Messageid = 0x8 // int32_t (Size: 0x4)
UAGameHUDTable.TemplateUMG_Resource = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameHUDTable.Location_Type = 0x38 // EEUAHUDPreInstallLoc (Size: 0x1)
UAGameHUDTable.background_img = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
UAGameHUDTable.Content_Img = 0x68 // TSoftObjectPtr<UObject> (Size: 0x28)
UAGameHUDTable.bUseContent_Img_Color = 0x90 // bool (Size: 0x1)
UAGameHUDTable.Content_Img_Color = 0x98 // FSlateColor (Size: 0x28)
UAGameHUDTable.Normal_Text = 0xc0 // FText (Size: 0x18)
UAGameHUDTable.RemainTime = 0xd8 // int32_t (Size: 0x4)
UAGameHUDTable.bWaitWidgetFinish = 0xdc // bool (Size: 0x1)
UAGameHUDTable.AudioEvent = 0xe0 // AkAudioEvent* (Size: 0x8)
UAGameLandmarkTable.MapID = 0x8 // int32_t (Size: 0x4)
UAGameLandmarkTable.LandMarkID = 0xc // int32_t (Size: 0x4)
UAGameLandmarkTable.LandMarkName = 0x10 // FText (Size: 0x18)
UAGameLandmarkTable.WorldLocation = 0x28 // FVector2D (Size: 0x8)
UAGameLandmarkTable.LandMarkGuide = 0x30 // FLandMarkGuide (Size: 0x70)
UAGameModeTableRow.Index = 0x8 // uint32_t (Size: 0x4)
UAGameModeTableRow.MainModeID = 0xc // uint32_t (Size: 0x4)
UAGameModeTableRow.MainModeName = 0x10 // FText (Size: 0x18)
UAGameModeTableRow.SubModeID = 0x28 // uint32_t (Size: 0x4)
UAGameModeTableRow.SubModeName = 0x30 // FText (Size: 0x18)
UAGameModeTableRow.GameModeClass = 0x48 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameModeTableRow.GameStateClass = 0x70 // TSoftClassPtr<UObject> (Size: 0x28)
UAGameModeTableRow.bShowKillCamBtn = 0x98 // bool (Size: 0x1)
UAGamePadMessageTable.Messageid = 0x8 // int32_t (Size: 0x4)
UAGamePadMessageTable.GamePadWidgets = 0xc // EEUAGamePadTable (Size: 0x1)
UAGamePadMessageTable.GamePadWidgetVisibility = 0xd // bool (Size: 0x1)
UAGamePadMessageTable.GamePadEffectWidgets = 0xe // EEGamePadEffectTable (Size: 0x1)
UAGamePadMessageTable.GamePadEffectWidgetVisibility = 0xf // bool (Size: 0x1)
UAGamePadVisibilityTableRow.ID = 0x8 // uint32_t (Size: 0x4)
UAGamePadVisibilityTableRow.WidgetName = 0x10 // FString (Size: 0x10)
UAGamePadVisibilityTableRow.SettingKey = 0x20 // FString (Size: 0x10)
UAGamePadVisibilityTableRow.bHideOnBagOpen = 0x30 // bool (Size: 0x1)
UAGamePadVisibilityTableRow.UIStateVisiblity = 0x38 // TMap<...> (Size: 0x50)
UAGlobalNumTable.Name = 0x8 // FText (Size: 0x18)
UAGlobalNumTable.Val = 0x20 // float (Size: 0x4)
UAGridScroll.OnContentSizeChange = 0x920 // FMulticastInlineDelegate (Size: 0x10)
UAGridScroll.ScrollWidgetAnimationEnd2 = 0x930 // FMulticastInlineDelegate (Size: 0x10)
UAInventoryIconTableRow.Describe = 0x8 // FString (Size: 0x10)
UAInventoryIconTableRow.ItemId = 0x18 // int32_t (Size: 0x4)
UAInventoryIconTableRow.SketchIconPath = 0x20 // FSoftObjectPath (Size: 0x18)
UAItemContextMenuTable.DisplayName = 0x8 // FText (Size: 0x18)
UAItemContextMenuTable.DisplayIconID = 0x20 // uint32_t (Size: 0x4)
UAItemContextMenuTable.ShowIndex = 0x24 // uint32_t (Size: 0x4)
UAItemContextMenuTable.UseTip = 0x28 // FString (Size: 0x10)
UALimitAreaPointConfigTable.Name = 0x20 // FString (Size: 0x10)
UALimitAreaPointConfigTable.bForceFirstAreaUseSpecialCenter = 0x30 // bool (Size: 0x1)
UALimitAreaPointConfigTable.SpecialCenter = 0x34 // FVector (Size: 0xc)
UALimitAreaPointConfigTable.RandomAreaPointWavePickArray = 0x40 // TArray<FRandomAreaPointStructData> (Size: 0x10)
UALimitAreaPointConfigTable.bForceUseDefaultAreaPointArray = 0x50 // bool (Size: 0x1)
UALimitAreaPointConfigTable.DefaultAreaPointArray = 0x58 // TArray<FVector> (Size: 0x10)
UAListView.ClickAudioEvents = 0x908 // TArray<AkAudioEvent*> (Size: 0x10)
UAListView.bScrollable = 0x918 // bool (Size: 0x1)
UAListView.ScrollBarVisibility = 0x919 // EESlateVisibility (Size: 0x1)
UAListView.CanRightClickScrolling = 0x91a // bool (Size: 0x1)
UAListView.AnimationDelay = 0x91c // float (Size: 0x4)
UALootDataInfosTable.LootDataInfoID = 0x8 // int32_t (Size: 0x4)
UALootDataInfosTable.Description = 0x10 // FString (Size: 0x10)
UALootDataInfosTable.LootPointType = 0x20 // int32_t (Size: 0x4)
UALootDataInfosTable.LootPointIcon = 0x28 // PaperSprite* (Size: 0x8)
UALootPointInfo.MapID = 0x8 // int32_t (Size: 0x4)
UALootPointInfo.LootPointID = 0xc // int32_t (Size: 0x4)
UALootPointInfo.Location = 0x10 // FVector (Size: 0xc)
UALootPointInfo.AreaName = 0x20 // FText (Size: 0x18)
UALootPointInfo.AreaID = 0x38 // int32_t (Size: 0x4)
UALootPointInfo.LevelPath = 0x40 // FString (Size: 0x10)
UALootPointInfo.LabelName = 0x50 // FString (Size: 0x10)
UALootPointInfo.LootPointType = 0x60 // int32_t (Size: 0x4)
UALootPointInfo.InBigMapAreaID = 0x64 // int32_t (Size: 0x4)
UALootPointInfo.CustomIndex = 0x68 // int32_t (Size: 0x4)
UALootPointInfo.InPickupGroup = 0x70 // FString (Size: 0x10)
UALootPointInfo.ActivePropInPickupGroup = 0x80 // float (Size: 0x4)
UAModeActivityMissionTable.ActivityMissionMap = 0x20 // TMap<...> (Size: 0x50)
UAModeBigMapModuleConfigTable.AdditionModules = 0x20 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAModeBigMapModuleConfigTable.RemoveModules = 0x30 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAModeDynamicMissionTable.LevelName = 0x20 // FString (Size: 0x10)
UAModeDynamicMissionTable.ResidentMission = 0x30 // FDynamicResidentMissionConfig (Size: 0x10)
UAModeDynamicMissionTable.RandomMission = 0x40 // FDynamicRandomMissionConfig (Size: 0x18)
UAModeDynamicMissionTable.GroupedRandomMission = 0x58 // FGroupedDynamicRandomMissionConfig (Size: 0x18)
UAModeDynamicMissionTable.MaxDynamicTaskNum = 0x70 // int32_t (Size: 0x4)
UAModeLootConfigTable.LootID = 0x20 // int32_t (Size: 0x4)
UAModeLootConfigTable.LootDropSubTable = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
UAModeLootConfigTable.LootMaps = 0x50 // TArray<FString> (Size: 0x10)
UAModeLootConfigTable.RoughSearchModifyScale = 0x60 // float (Size: 0x4)
UAModeLootConfigTable.DetailSearchModifyScale = 0x64 // float (Size: 0x4)
UAModeLootConfigTable.AdditionalFastRecycleCount = 0x68 // int32_t (Size: 0x4)
UAModeLootConfigTable.AdditionalGashaCoinCount = 0x6c // int32_t (Size: 0x4)
UAModeQuestDistributerConfigTable.LoadDistributerProbability = 0x20 // float (Size: 0x4)
UAModeQuestDistributerConfigTable.NeedLoadQuestDistributer = 0x28 // TArray<FQuestDistributerClassWithWeight> (Size: 0x10)
UAModeQuestDistributerConfigTable.RandomTimes = 0x38 // int32_t (Size: 0x4)
UAModeQuestDistributerConfigTable.ActivityLoadDistributerProbability = 0x3c // float (Size: 0x4)
UAModeQuestDistributerConfigTable.ActivityNeedLoadQuestDistributer = 0x40 // TMap<...> (Size: 0x50)
UAModeQuestDistributerConfigTable.ActivityRandomTimes = 0x90 // int32_t (Size: 0x4)
UAModeStartAndEscapeTable.LevelName = 0x20 // FString (Size: 0x10)
UAModeStartAndEscapeTable.AdditionLevelName = 0x30 // TArray<FString> (Size: 0x10)
UAModeStartAndEscapeTable.PlayerStart = 0x40 // TArray<FUAPlayerStartGroupData> (Size: 0x10)
UAModeStartAndEscapeTable.AIStartAddition = 0x50 // TArray<FUAAIStartGroupData> (Size: 0x10)
UAModeStartAndEscapeTable.EscapePresetMap = 0x60 // TMap<...> (Size: 0x50)
UAModeStartAndEscapeTable.GlobalRandomEscapePointIDs = 0xb0 // TArray<int32_t> (Size: 0x10)
UAModeStartAndEscapeTable.GlobalEscapePointProbabilityMap = 0xc0 // TMap<...> (Size: 0x50)
UAModeStartAndEscapeTable.EscapeProbabilityResetMap = 0x110 // TMap<...> (Size: 0x50)
UAModeStartAndEscapeTable.EscapeVolumeRemapping = 0x160 // TMap<...> (Size: 0x50)
UAModeStartAndEscapeTable.PMCCheckRadius = 0x1b0 // float (Size: 0x4)
UAModeStartAndEscapeTable.EnemyCheckRadius = 0x1b4 // float (Size: 0x4)
UAModeStartAndEscapeTable.SecondEnemyCheckRadius = 0x1b8 // float (Size: 0x4)
UAModeStartAndEscapeTable.TeamCheckRadius = 0x1bc // float (Size: 0x4)
UAModuleContextTable.Name = 0x8 // FString (Size: 0x10)
UAModuleContextTable.LevelPath = 0x18 // FString (Size: 0x10)
UAModuleTable.Context = 0x8 // FString (Size: 0x10)
UAModuleTable.DefaultPanel = 0x18 // FString (Size: 0x10)
UAMultiLineEditableTextBox.OnContextMenuOpeningDelegate = 0xd58 // FDelegate (Size: 0x10)
UAMultiModeWidgetTable.ID = 0x8 // int32_t (Size: 0x4)
UAMultiModeWidgetTable.Name = 0x10 // FText (Size: 0x18)
UAMultiModeWidgetTable.sysIds = 0x28 // FString (Size: 0x10)
UAMultiModeWidgetTable.isShowMode = 0x38 // bool (Size: 0x1)
UAMultiModeWidgetTable.use_ticket = 0x3c // int32_t (Size: 0x4)
UAMultiModeWidgetTable.need_take_in_threshold = 0x40 // int32_t (Size: 0x4)
UAMultiModeWidgetTable.default_avatar_set_id = 0x44 // int32_t (Size: 0x4)
UANewTraceConfigTable.MarkType = 0x8 // EENewTraceableMarkType (Size: 0x1)
UANewTraceConfigTable.TraceRuleRowName = 0x10 // FString (Size: 0x10)
UANewTraceConfigTable.TraceStyleID = 0x20 // int32_t (Size: 0x4)
UANewTraceConfigTable.DataSyncInverval = 0x24 // float (Size: 0x4)
UANewTraceConfigTable.CanInteract = 0x28 // bool (Size: 0x1)
UANewTraceConfigTable.TraceInfoInitMode = 0x29 // EETraceableMarkInitMode (Size: 0x1)
UANewTraceConfigTable.TraceTitle = 0x30 // FText (Size: 0x18)
UANewTraceConfigTable.TraceDesc = 0x48 // FText (Size: 0x18)
UANewTraceConfigTable.TargetTitle = 0x60 // FText (Size: 0x18)
UANewTraceConfigTable.TargetDesc = 0x78 // FText (Size: 0x18)
UANewTraceRuleTable.SyncRule = 0x8 // EENewTraceSyncRule (Size: 0x1)
UANewTraceRuleTable.SceneRuleParams = 0xc // FUATraceSceneRuleParams (Size: 0xc)
UANewTraceRuleTable.NewMapRuleParams = 0x18 // FUATraceNewMapRuleParams (Size: 0xc)
UANewTraceRuleTable.DirectionalBarRuleParams = 0x24 // FUATraceDirectionalBarRuleParams (Size: 0xc)
UANewTraceStyleTable.Annotation = 0x8 // FString (Size: 0x10)
UANewTraceStyleTable.Color = 0x18 // FSlateColor (Size: 0x28)
UANewTraceStyleTable.MarkIconResource = 0x40 // FSoftObjectPath (Size: 0x18)
UANewTraceStyleTable.BackgroundResource = 0x58 // FSoftObjectPath (Size: 0x18)
UANewTraceStyleTable.SubUMGType = 0x70 // TSoftClassPtr<UObject> (Size: 0x28)
UANewTraceStyleTable.SceneStyleParams = 0x98 // FUATraceSceneStyleParams (Size: 0x68)
UANewTraceStyleTable.NewMapStyleParams = 0x100 // FUATraceNewMapStyleParams (Size: 0xc8)
UANewTraceStyleTable.DirectionalBarStyleParams = 0x1c8 // FUATraceDirectionalBarStyleParams (Size: 0x28)
UAOverlaySlot.ZOrder = 0x80 // int32_t (Size: 0x4)
UAPlayerEscapeShowRow.enable = 0x8 // bool (Size: 0x1)
UAPlayerEscapeShowRow.EscapePointID = 0xc // int32_t (Size: 0x4)
UAPlayerEscapeShowRow.MaxPlayerNum = 0x10 // int32_t (Size: 0x4)
UAPlayerEscapeShowRow.PlayTime = 0x14 // float (Size: 0x4)
UAPlayerEscapeShowRow.PCArr = 0x18 // TArray<PlayerController*> (Size: 0x10)
UAPlayerStartGroupData.GroupIndex = 0x0 // int32_t (Size: 0x4)
UAPlayerStartGroupData.StartPointType = 0x4 // EEPlayerTeamType (Size: 0x1)
UAPlayerStartGroupData.BigGroup = 0x8 // int32_t (Size: 0x4)
UAPlayerStartGroupData.BigGroupPriority = 0xc // int32_t (Size: 0x4)
UAPlayerStartGroupData.SecondGroup = 0x10 // int32_t (Size: 0x4)
UAPlayerStartGroupData.Priority = 0x14 // int32_t (Size: 0x4)
UAPlayerStartGroupData.Weight = 0x18 // int32_t (Size: 0x4)
UAPlayerStartGroupData.EscapePreset = 0x20 // FString (Size: 0x10)
UAPlayerStartGroupData.ExclusiveGroup = 0x30 // int32_t (Size: 0x4)
UAPlayerStartGroupData.ExclusiveGroupWeight = 0x34 // int32_t (Size: 0x4)
UARedPointWidget.RedPointType = 0x290 // FString (Size: 0x10)
UARedPointWidget.AutoRegist = 0x2a0 // bool (Size: 0x1)
UARichTextBlockHyperLinkDecorator.HyperlinkSet = 0x38 // DataTable* (Size: 0x8)
UARichTextBlockHyperLinkDecorator.LuaEventDataArray = 0x40 // TArray<FHyperlinkClickCallLuaEventData> (Size: 0x10)
UARichTextBlockHyperLinkDecorator.LuaEventDataId = 0x50 // FName (Size: 0x8)
UAScanDeviceUIConfig.UISize = 0x8 // FVector2D (Size: 0x8)
UAScanDeviceUIConfig.UIOffset = 0x10 // FVector2D (Size: 0x8)
UAScanDeviceUIConfig.RotateAngle = 0x18 // float (Size: 0x4)
UAScriptLevelTable.ScriptMaps = 0x20 // TArray<FString> (Size: 0x10)
UAScriptLevelTable.AdditionIgnores = 0x30 // TArray<FString> (Size: 0x10)
UAServiceTable.InitContext = 0x8 // FString (Size: 0x10)
UAServiceTable.ResetContext = 0x18 // FString (Size: 0x10)
UAStatisParamInfo.CompareType = 0x8 // EEUAStatisParamFilterType (Size: 0x1)
UAStatisParamInfo.CompareValue = 0x10 // int64_t (Size: 0x8)
UAStatisParamInfo.CompareValueExt = 0x18 // int64_t (Size: 0x8)
UAStatisParamInfo.Detail = 0x20 // bool (Size: 0x1)
UAStatisParamInfo.ValueList = 0x28 // TArray<int64_t> (Size: 0x10)
UAStatisTable.Describe = 0x8 // FText (Size: 0x18)
UAStatisTable.StatisMethod = 0x20 // EEUAStatisMethod (Size: 0x1)
UAStatisTable.ExcludeSameTeam = 0x21 // bool (Size: 0x1)
UAStatisTable.ExcludeSameInst = 0x22 // bool (Size: 0x1)
UAStatisTable.RecordEvent = 0x23 // bool (Size: 0x1)
UAStatisTable.Params = 0x28 // TArray<FUAStatisParamInfo> (Size: 0x10)
UAStatisTable.EventCount = 0x38 // int32_t (Size: 0x4)
UAStatisTable.ExpCaculator = 0x40 // FSoftClassPath (Size: 0x18)
UASubTitleTextTable.TextMessageId = 0x8 // int32_t (Size: 0x4)
UASubTitleTextTable.Text = 0x10 // FText (Size: 0x18)
UASubTitleTextTable.GameHUDTypeID = 0x28 // int32_t (Size: 0x4)
UASubTitleVOTable.Messageid = 0x8 // int32_t (Size: 0x4)
UASubTitleVOTable.SoundResource = 0x10 // FString (Size: 0x10)
UASubTitleVOTable.TextMessageId = 0x20 // int32_t (Size: 0x4)
UASubTitleVOTable.SoundType = 0x24 // FName (Size: 0x8)
UASubmitBug.ScreenShotEvent = 0x28 // FMulticastInlineDelegate (Size: 0x10)
UASubmitBug.SubmitHttpResponseDelegate = 0x38 // FMulticastInlineDelegate (Size: 0x10)
UATaskTypeTable.Type = 0x8 // uint32_t (Size: 0x4)
UATaskTypeTable.TypeDesc = 0x10 // FText (Size: 0x18)
UATaskTypeTable.IconPath = 0x28 // FString (Size: 0x10)
UATileView.ClickAudioEvents = 0x930 // TArray<AkAudioEvent*> (Size: 0x10)
UATraceDirectionalBarRuleParams.bCanShow = 0x0 // bool (Size: 0x1)
UATraceDirectionalBarRuleParams.ShowDistance = 0x4 // float (Size: 0x4)
UATraceDirectionalBarRuleParams.DrawInverval = 0x8 // float (Size: 0x4)
UATraceDirectionalBarStyleParams.HighlightAniName = 0x0 // FString (Size: 0x10)
UATraceDirectionalBarStyleParams.AniLoopTimes = 0x10 // int32_t (Size: 0x4)
UATraceDirectionalBarStyleParams.bIsAlwaysShow = 0x14 // bool (Size: 0x1)
UATraceDirectionalBarStyleParams.Params = 0x18 // TArray<FString> (Size: 0x10)
UATraceNewMapRuleParams.bCanShow = 0x0 // bool (Size: 0x1)
UATraceNewMapRuleParams.ShowDistance = 0x4 // float (Size: 0x4)
UATraceNewMapRuleParams.DrawInverval = 0x8 // float (Size: 0x4)
UATraceNewMapStyleParams.UMGType = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
UATraceNewMapStyleParams.ZOrder = 0x28 // int32_t (Size: 0x4)
UATraceNewMapStyleParams.bShowArea = 0x2c // bool (Size: 0x1)
UATraceNewMapStyleParams.ShowAreaType = 0x2d // EEUATraceNewMapShowAreaType (Size: 0x1)
UATraceNewMapStyleParams.AreaColor = 0x30 // FSlateColor (Size: 0x28)
UATraceNewMapStyleParams.AreaRadius = 0x58 // float (Size: 0x4)
UATraceNewMapStyleParams.bEnableHover = 0x5c // bool (Size: 0x1)
UATraceNewMapStyleParams.DetailBoardType = 0x60 // FString (Size: 0x10)
UATraceNewMapStyleParams.bHideOnDiffLayer = 0x70 // bool (Size: 0x1)
UATraceNewMapStyleParams.IconScale = 0x74 // float (Size: 0x4)
UATraceNewMapStyleParams.Params = 0x78 // TMap<...> (Size: 0x50)
UATraceSceneRuleParams.bCanShow = 0x0 // bool (Size: 0x1)
UATraceSceneRuleParams.bActiveCanShow = 0x1 // bool (Size: 0x1)
UATraceSceneRuleParams.ShowDistance = 0x4 // float (Size: 0x4)
UATraceSceneRuleParams.DrawInverval = 0x8 // float (Size: 0x4)
UATraceSceneStyleParams.SceneUMGType = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
UATraceSceneStyleParams.OpactiyInVision = 0x28 // float (Size: 0x4)
UATraceSceneStyleParams.OpactiyNotInVision = 0x2c // float (Size: 0x4)
UATraceSceneStyleParams.OpacityOutofDistance = 0x30 // float (Size: 0x4)
UATraceSceneStyleParams.ShortShowDistance = 0x34 // float (Size: 0x4)
UATraceSceneStyleParams.HideDistance = 0x38 // float (Size: 0x4)
UATraceSceneStyleParams.Params = 0x58 // TArray<FString> (Size: 0x10)
UATraceStyleTable.StyleID = 0x8 // int32_t (Size: 0x4)
UATraceStyleTable.Annotation = 0x10 // FString (Size: 0x10)
UATraceStyleTable.TemplateUMG_Resource = 0x20 // TSoftClassPtr<UObject> (Size: 0x28)
UATraceStyleTable.ZOrder = 0x48 // int32_t (Size: 0x4)
UATraceStyleTable.EffectDistance = 0x4c // float (Size: 0x4)
UATraceStyleTable.OpacityOnVisible = 0x50 // float (Size: 0x4)
UATraceStyleTable.OpacityOnInvisible = 0x54 // float (Size: 0x4)
UATraceStyleTable.Image_Circle_Color_Normal = 0x58 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_Circle_Color_Teamate = 0x80 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_Circle_Color_Enemy = 0xa8 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_BG_Path = 0xd0 // FString (Size: 0x10)
UATraceStyleTable.Image_BG_Color_Normal = 0xe0 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_BG_Color_Teamate = 0x108 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_BG_Color_Enemy = 0x130 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_Icon_Path = 0x158 // FString (Size: 0x10)
UATraceStyleTable.Image_Icon_Color_Normal = 0x168 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_Icon_Color_Teamate = 0x190 // FSlateColor (Size: 0x28)
UATraceStyleTable.Image_Icon_Color_Enemy = 0x1b8 // FSlateColor (Size: 0x28)
UATraceStyleTable.Params = 0x1e0 // TArray<FString> (Size: 0x10)
UATraceTargetTable.TargetId = 0x8 // int32_t (Size: 0x4)
UATraceTargetTable.TargetTitle = 0x10 // FText (Size: 0x18)
UATraceTargetTable.TargetDesc = 0x28 // FText (Size: 0x18)
UATraceTargetTable.bShowTrace = 0x40 // bool (Size: 0x1)
UATraceTargetTable.bIsClick = 0x41 // bool (Size: 0x1)
UATraceTargetTable.bIsAutoSelect = 0x42 // bool (Size: 0x1)
UATraceTargetTable.TraceTitle = 0x48 // FText (Size: 0x18)
UATraceTargetTable.TraceDesc = 0x60 // FText (Size: 0x18)
UATraceTargetTable.AnimName = 0x78 // FString (Size: 0x10)
UATraceTargetTable.StyleID = 0x88 // int32_t (Size: 0x4)
UATreeView.ClickAudioEvents = 0x958 // TArray<AkAudioEvent*> (Size: 0x10)
UATutorialEventTable.EventName = 0x8 // FString (Size: 0x10)
UATutorialEventTable.MaxTimesInGame = 0x18 // int32_t (Size: 0x4)
UATutorialEventTable.MaxTimesInCareer = 0x1c // int32_t (Size: 0x4)
UATutorialEventTable.NotTriggerTimesInCareer = 0x20 // int32_t (Size: 0x4)
UATutorialEventTable.CD = 0x24 // int32_t (Size: 0x4)
UATutorialEventTable.ExtraParaText1 = 0x28 // FString (Size: 0x10)
UATutorialEventTable.ExtraPara1 = 0x38 // int32_t (Size: 0x4)
UATutorialEventTable.ExtraParaText2 = 0x40 // FString (Size: 0x10)
UATutorialEventTable.ExtraPara2 = 0x50 // int32_t (Size: 0x4)
UATutorialEventTable.ExtraParaText3 = 0x58 // FString (Size: 0x10)
UATutorialEventTable.ExtraPara3 = 0x68 // int32_t (Size: 0x4)
UAVestBagGridTable.Name = 0x8 // FString (Size: 0x10)
UAVestBagGridTable.Seperated = 0x18 // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeX_2 = 0x1c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_2 = 0x20 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_2 = 0x24 // float (Size: 0x4)
UAVestBagGridTable.PosY_2 = 0x28 // float (Size: 0x4)
UAVestBagGridTable.SizeX_3 = 0x2c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_3 = 0x30 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_3 = 0x34 // float (Size: 0x4)
UAVestBagGridTable.PosY_3 = 0x38 // float (Size: 0x4)
UAVestBagGridTable.SizeX_4 = 0x3c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_4 = 0x40 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_4 = 0x44 // float (Size: 0x4)
UAVestBagGridTable.PosY_4 = 0x48 // float (Size: 0x4)
UAVestBagGridTable.SizeX_5 = 0x4c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_5 = 0x50 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_5 = 0x54 // float (Size: 0x4)
UAVestBagGridTable.PosY_5 = 0x58 // float (Size: 0x4)
UAVestBagGridTable.SizeX_6 = 0x5c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_6 = 0x60 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_6 = 0x64 // float (Size: 0x4)
UAVestBagGridTable.PosY_6 = 0x68 // float (Size: 0x4)
UAVestBagGridTable.SizeX_7 = 0x6c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_7 = 0x70 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_7 = 0x74 // float (Size: 0x4)
UAVestBagGridTable.PosY_7 = 0x78 // float (Size: 0x4)
UAVestBagGridTable.SizeX_8 = 0x7c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_8 = 0x80 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_8 = 0x84 // float (Size: 0x4)
UAVestBagGridTable.PosY_8 = 0x88 // float (Size: 0x4)
UAVestBagGridTable.SizeX_9 = 0x8c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_9 = 0x90 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_9 = 0x94 // float (Size: 0x4)
UAVestBagGridTable.PosY_9 = 0x98 // float (Size: 0x4)
UAVestBagGridTable.SizeX_10 = 0x9c // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_10 = 0xa0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_10 = 0xa4 // float (Size: 0x4)
UAVestBagGridTable.PosY_10 = 0xa8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_11 = 0xac // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_11 = 0xb0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_11 = 0xb4 // float (Size: 0x4)
UAVestBagGridTable.PosY_11 = 0xb8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_12 = 0xbc // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_12 = 0xc0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_12 = 0xc4 // float (Size: 0x4)
UAVestBagGridTable.PosY_12 = 0xc8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_13 = 0xcc // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_13 = 0xd0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_13 = 0xd4 // float (Size: 0x4)
UAVestBagGridTable.PosY_13 = 0xd8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_14 = 0xdc // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_14 = 0xe0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_14 = 0xe4 // float (Size: 0x4)
UAVestBagGridTable.PosY_14 = 0xe8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_15 = 0xec // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_15 = 0xf0 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_15 = 0xf4 // float (Size: 0x4)
UAVestBagGridTable.PosY_15 = 0xf8 // float (Size: 0x4)
UAVestBagGridTable.SizeX_16 = 0xfc // uint32_t (Size: 0x4)
UAVestBagGridTable.SizeY_16 = 0x100 // uint32_t (Size: 0x4)
UAVestBagGridTable.PosX_16 = 0x104 // float (Size: 0x4)
UAVestBagGridTable.PosY_16 = 0x108 // float (Size: 0x4)
UAWareHouseComponent.DefaulWareHouseInventory = 0x100 // ClassProperty (Size: 0x8)
WidgetReferenceTable.WidgetClass = 0x8 // ClassProperty (Size: 0x8)
AIPool.ID = 0x0 // FString (Size: 0x10)
AIPool.Equip = 0x10 // int32_t (Size: 0x4)
AIPool.Weight = 0x14 // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
AISpawnAreaInfoTableRow.eventId = 0x20 // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.Weather = 0x28 // TArray<float> (Size: 0x10)
AISpawnAreaInfoTableRow.AreaID = 0x38 // FString (Size: 0x10)
AISpawnAreaInfoTableRow.CampID = 0x48 // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.MaxAINumber = 0x4c // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.PoolType = 0x50 // int32_t (Size: 0x4)
AISpawnAreaInfoTableRow.AIPool = 0x58 // TArray<FAIPool> (Size: 0x10)
AISpawnBossSpawnControllerTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
AISpawnBossSpawnControllerTableRow.Weather = 0x20 // TArray<float> (Size: 0x10)
AISpawnBossSpawnControllerTableRow.SquadID = 0x30 // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.BossID = 0x34 // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.eventId = 0x38 // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.PlayerAroundRadius = 0x3c // float (Size: 0x4)
AISpawnBossSpawnControllerTableRow.PlayerLineOfSight = 0x40 // float (Size: 0x4)
AISpawnBossSpawnControllerTableRow.PlayerViewAngle = 0x44 // float (Size: 0x4)
AISpawnBossSpawnControllerTableRow.Probability = 0x48 // float (Size: 0x4)
AISpawnBossSpawnControllerTableRow.Weight = 0x4c // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.MaxNumber = 0x50 // FText (Size: 0x18)
AISpawnBossSpawnControllerTableRow.FirstSpawnTime = 0x68 // float (Size: 0x4)
AISpawnBossSpawnControllerTableRow.FactionType = 0x6c // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.GroupType = 0x70 // int32_t (Size: 0x4)
AISpawnBossSpawnControllerTableRow.BossArea = 0x78 // TArray<FTriggerArea> (Size: 0x10)
AISpawnPMCConfigTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.eventId = 0x20 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.Weather = 0x28 // TArray<float> (Size: 0x10)
AISpawnPMCConfigTableRow.MinPMCNum = 0x38 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MaxPMCNum = 0x3c // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.Plan1Weight = 0x40 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.PMCAIDelayTime = 0x44 // float (Size: 0x4)
AISpawnPMCConfigTableRow.MinPMCAITeamUpNum = 0x48 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MaxPMCAITeamUpNum = 0x4c // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.PlayerAroundRadius = 0x50 // float (Size: 0x4)
AISpawnPMCConfigTableRow.PlayerLineOfSight = 0x54 // float (Size: 0x4)
AISpawnPMCConfigTableRow.PlayerViewAngle = 0x58 // float (Size: 0x4)
AISpawnPMCConfigTableRow.RankRange = 0x60 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIIDPool_Rank0 = 0x70 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIIDPool_Rank1 = 0x80 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIIDPool_Rank2 = 0x90 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIEquipPool = 0xa0 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIEquipmentLimit = 0xb0 // TArray<FPMCAIEquipmentLimit> (Size: 0x10)
AISpawnPMCConfigTableRow.Plan2Wieght = 0xc0 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.PMCAIDelayTime2 = 0xc4 // float (Size: 0x4)
AISpawnPMCConfigTableRow.MinPMCAITeamUpNum2 = 0xc8 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MaxPMCAITeamUpNum2 = 0xcc // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.PMCAIIDPool2 = 0xd0 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCAIEquipPool2 = 0xe0 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.ScanInterval = 0xf0 // float (Size: 0x4)
AISpawnPMCConfigTableRow.SpawnInterval = 0xf4 // float (Size: 0x4)
AISpawnPMCConfigTableRow.DetectionTime = 0xf8 // float (Size: 0x4)
AISpawnPMCConfigTableRow.BattleIntensity = 0xfc // float (Size: 0x4)
AISpawnPMCConfigTableRow.HitNum = 0x100 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.KillNum = 0x104 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MinPMCAITeammateNum = 0x108 // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.MaxPMCAITeammateNum = 0x10c // int32_t (Size: 0x4)
AISpawnPMCConfigTableRow.PMCTeammateAIIDPool = 0x110 // TArray<int32_t> (Size: 0x10)
AISpawnPMCConfigTableRow.PMCTeammateAIEquipPool = 0x120 // TArray<int32_t> (Size: 0x10)
AISpawnPMCSpawnControllerTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.AISpawnConfigID = 0x10 // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.SquadID = 0x14 // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.MinSquadNum = 0x18 // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.MaxSquadNum = 0x1c // int32_t (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.PlayerAroundRadius = 0x20 // float (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.PlayerLineOfSight = 0x24 // float (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.PlayerViewAngle = 0x28 // float (Size: 0x4)
AISpawnPMCSpawnControllerTableRow.Priority = 0x2c // bool (Size: 0x1)
AISpawnPMCSpawnControllerTableRow.AreaInfo = 0x30 // TArray<FAreaInfo> (Size: 0x10)
AISpawnPlayerScavConfigTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnPlayerScavConfigTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnPlayerScavConfigTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
AISpawnPlayerScavConfigTableRow.eventId = 0x20 // int32_t (Size: 0x4)
AISpawnPlayerScavConfigTableRow.Weather = 0x28 // TArray<float> (Size: 0x10)
AISpawnPlayerScavConfigTableRow.MinPlayerScavAINum = 0x38 // int32_t (Size: 0x4)
AISpawnPlayerScavConfigTableRow.MaxPlayerScavAINum = 0x3c // int32_t (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerScavAIDelayTime = 0x40 // float (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerScavAIEndTime = 0x44 // float (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerScavAISpawnInterval = 0x48 // float (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerScavAIIDPool = 0x50 // TArray<int32_t> (Size: 0x10)
AISpawnPlayerScavConfigTableRow.PlayerScavAIEquipPool = 0x60 // TArray<int32_t> (Size: 0x10)
AISpawnPlayerScavConfigTableRow.PlayerAroundRadius = 0x70 // float (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerLineOfSight = 0x74 // float (Size: 0x4)
AISpawnPlayerScavConfigTableRow.PlayerViewAngle = 0x78 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.MapID = 0xc // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
AISpawnScavSpawnControllerTableRow.eventId = 0x20 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.Weather = 0x28 // TArray<float> (Size: 0x10)
AISpawnScavSpawnControllerTableRow.SquadID = 0x38 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.FatherSquadID = 0x3c // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.PlayerAroundRadius = 0x40 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.PlayerLineOfSight = 0x44 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.PlayerViewAngle = 0x48 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.AIRandLimitationMin = 0x4c // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.AIRandLimitationMax = 0x50 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.Loop = 0x54 // bool (Size: 0x1)
AISpawnScavSpawnControllerTableRow.FirstSpawnTime = 0x58 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.TriggerVolumeID = 0x5c // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.DeathDelay = 0x60 // float (Size: 0x4)
AISpawnScavSpawnControllerTableRow.Reinforce = 0x64 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.IsPatrol = 0x68 // bool (Size: 0x1)
AISpawnScavSpawnControllerTableRow.SingleArea = 0x69 // bool (Size: 0x1)
AISpawnScavSpawnControllerTableRow.Priority = 0x6c // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.FactionType = 0x70 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.GroupType = 0x74 // int32_t (Size: 0x4)
AISpawnScavSpawnControllerTableRow.ScavWaveInfoArray = 0x78 // TArray<FScavWaveInfoArray> (Size: 0x10)
AISpawnScavSpawnControllerTableRow.AreaInfo = 0x88 // TArray<FAreaInfo> (Size: 0x10)
AISpawnScavSpawnControllerTableRow.Reinforcement = 0x98 // TArray<FAreaInfo> (Size: 0x10)
AccessDurabilityArchIdConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AccessDurabilityArchIdConfTableRow.durability_price_arch_id = 0xc // uint32_t (Size: 0x4)
AccessDurabilityPriceConf.armor_level = 0x0 // uint32_t (Size: 0x4)
AccessDurabilityPriceConf.durability_price = 0x4 // uint32_t (Size: 0x4)
AccessMatArchIdConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AccessMatArchIdConfTableRow.material_arch_id = 0xc // uint32_t (Size: 0x4)
AccessRepairDurabilityConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AccessRepairDurabilityConfTableRow.durability_price_conf = 0x10 // TArray<FAccessDurabilityPriceConf> (Size: 0x10)
AccessoryAvatarSetCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AccessoryAvatarSetCfgTableRow.avatar_set = 0x10 // TArray<uint32_t> (Size: 0x10)
AccountBanReasonTableRow.AccountBanID = 0x8 // FString (Size: 0x10)
AccountBanReasonTableRow.AccountBanReason = 0x18 // FText (Size: 0x18)
AchieveBadgeSlotTableRow.slot_id = 0x8 // uint32_t (Size: 0x4)
AchieveBadgeSlotTableRow.slot_name = 0x10 // FText (Size: 0x18)
AchieveBadgeSlotTableRow.slot_icon = 0x28 // FText (Size: 0x18)
AchieveBadgeSlotTableRow.is_unlock = 0x40 // uint32_t (Size: 0x4)
AchieveBadgeSlotTableRow.sort = 0x44 // uint32_t (Size: 0x4)
AchieveBadgeSlotTableRow.check_wear = 0x48 // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.Name = 0x10 // FText (Size: 0x18)
AchieveTaskConfTableRow.finish_name = 0x28 // FText (Size: 0x18)
AchieveTaskConfTableRow.desc = 0x40 // FText (Size: 0x18)
AchieveTaskConfTableRow.finish_desc = 0x58 // FText (Size: 0x18)
AchieveTaskConfTableRow.target_type = 0x70 // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.Param1 = 0x74 // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.Param2 = 0x78 // uint32_t (Size: 0x4)
AchieveTaskConfTableRow.sub_tasks = 0x80 // TArray<uint32_t> (Size: 0x10)
AchieveTaskConfTableRow.Progress = 0x90 // uint32_t (Size: 0x4)
AchievementConfTableRow.badge_id = 0x8 // uint32_t (Size: 0x4)
AchievementConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
AchievementConfTableRow.sub_type = 0x10 // uint32_t (Size: 0x4)
AchievementConfTableRow.season_id = 0x14 // uint32_t (Size: 0x4)
AchievementConfTableRow.badge_name = 0x18 // FText (Size: 0x18)
AchievementConfTableRow.badge_desc = 0x30 // FText (Size: 0x18)
AchievementConfTableRow.need_finish_num = 0x48 // uint32_t (Size: 0x4)
AchievementConfTableRow.task_ids = 0x50 // TArray<uint32_t> (Size: 0x10)
AchievementConfTableRow.icon_path = 0x60 // FText (Size: 0x18)
ActBankruptConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActBankruptConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
ActBankruptConfTableRow.Str = 0x18 // FString (Size: 0x10)
ActConfigTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActConfigTableRow.display_order = 0xc // uint32_t (Size: 0x4)
ActConfigTableRow.Type = 0x10 // uint32_t (Size: 0x4)
ActConfigTableRow.icon_sys_id = 0x14 // uint32_t (Size: 0x4)
ActConfigTableRow.Name = 0x18 // FText (Size: 0x18)
ActConfigTableRow.rp_type = 0x30 // uint32_t (Size: 0x4)
ActConfigTableRow.is_open = 0x34 // uint32_t (Size: 0x4)
ActConfigTableRow.closed_env_id = 0x38 // TArray<uint32_t> (Size: 0x10)
ActConfigTableRow.open_condition = 0x48 // TArray<uint32_t> (Size: 0x10)
ActConfigTableRow.tab_name = 0x58 // FString (Size: 0x10)
ActConfigTableRow.tab_order = 0x68 // uint32_t (Size: 0x4)
ActConfigTableRow.theme_act_id = 0x6c // uint32_t (Size: 0x4)
ActConfigTableRow.tab_cdn = 0x70 // FString (Size: 0x10)
ActConfigTableRow.precondition = 0x80 // uint32_t (Size: 0x4)
ActConfigTableRow.disappear = 0x84 // uint32_t (Size: 0x4)
ActConfigTableRow.min_level = 0x88 // uint32_t (Size: 0x4)
ActConfigTableRow.max_level = 0x8c // uint32_t (Size: 0x4)
ActConfigTableRow.parent_id = 0x90 // uint32_t (Size: 0x4)
ActConfigTableRow.is_logic = 0x94 // uint32_t (Size: 0x4)
ActConfigTableRow.begin_time = 0x98 // FDateTime (Size: 0x8)
ActConfigTableRow.begin_time_deadline = 0xa0 // FDateTime (Size: 0x8)
ActConfigTableRow.end_time = 0xa8 // FDateTime (Size: 0x8)
ActConfigTableRow.continue_time = 0xb0 // uint32_t (Size: 0x4)
ActConfigTableRow.des = 0xb8 // FString (Size: 0x10)
ActConfigTableRow.act_time_des = 0xc8 // FString (Size: 0x10)
ActConfigTableRow.notice = 0xd8 // FString (Size: 0x10)
ActConfigTableRow.json_param = 0xe8 // FString (Size: 0x10)
ActConfigTableRow.reward_list = 0xf8 // FString (Size: 0x10)
ActConfigTableRow.pic = 0x108 // FString (Size: 0x10)
ActConfigTableRow.Jump = 0x118 // FString (Size: 0x10)
ActConfigTableRow.preview_begin_time = 0x128 // FDateTime (Size: 0x8)
ActConfigTableRow.forbidden_account_channel = 0x130 // TArray<uint32_t> (Size: 0x10)
ActConfigTableRow.forbidden_plat_type = 0x140 // TArray<uint32_t> (Size: 0x10)
ActConfigTableRow.client_version_low = 0x150 // FString (Size: 0x10)
ActConfigTableRow.client_version_up = 0x160 // FString (Size: 0x10)
ActConfigTableRow.bp_path = 0x170 // FString (Size: 0x10)
ActConfigTableRow.URL = 0x180 // FString (Size: 0x10)
ActConfigTableRow.tag_type = 0x190 // uint32_t (Size: 0x4)
ActConfigTableRow.tag_time = 0x194 // uint32_t (Size: 0x4)
ActConfigTableRow.countdown_time = 0x198 // uint32_t (Size: 0x4)
ActConfigTableRow.core_item_id = 0x19c // uint32_t (Size: 0x4)
ActConfigTableRow.core_item_num = 0x1a0 // uint32_t (Size: 0x4)
ActConfigTableRow.country_group_id = 0x1a4 // uint32_t (Size: 0x4)
ActConfigTableRow.through_season = 0x1a8 // uint32_t (Size: 0x4)
ActConfigTableRow.can_rate = 0x1ac // uint32_t (Size: 0x4)
ActConfigTableRow.rate_prereq = 0x1b0 // uint32_t (Size: 0x4)
ActConfigTableRow.is_share = 0x1b4 // uint32_t (Size: 0x4)
ActConfigTableRow.share_reward_list = 0x1b8 // FString (Size: 0x10)
ActConfigTableRow.share_cdn = 0x1c8 // FString (Size: 0x10)
ActConfigTableRow.open_user_type = 0x1d8 // uint32_t (Size: 0x4)
ActConfigTableRow.not_open_by_parent = 0x1dc // uint32_t (Size: 0x4)
ActConfigTableRow.is_rookie_act = 0x1e0 // uint32_t (Size: 0x4)
ActConfigTableRow.check_active = 0x1e4 // uint32_t (Size: 0x4)
ActConfigTableRow.force_refresh = 0x1e8 // uint32_t (Size: 0x4)
ActDialogConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActDialogConfTableRow.Title = 0x10 // FText (Size: 0x18)
ActDialogConfTableRow.Command = 0x28 // uint32_t (Size: 0x4)
ActDialogConfTableRow.Param = 0x2c // uint32_t (Size: 0x4)
ActDialogDetailConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActDialogDetailConfTableRow.character_id = 0xc // uint32_t (Size: 0x4)
ActDialogDetailConfTableRow.Anim = 0x10 // FText (Size: 0x18)
ActDialogDetailConfTableRow.Sound = 0x28 // FText (Size: 0x18)
ActDialogDetailConfTableRow.Content = 0x40 // FText (Size: 0x18)
ActDialogDetailConfTableRow.next_id = 0x58 // uint32_t (Size: 0x4)
ActDialogDetailConfTableRow.Command = 0x5c // uint32_t (Size: 0x4)
ActDialogDetailConfTableRow.Param = 0x60 // uint32_t (Size: 0x4)
ActGoodCommentConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActGoodCommentConfTableRow.trigger_task = 0x10 // TArray<uint32_t> (Size: 0x10)
ActGoodCommentConfTableRow.trigger_task2 = 0x20 // TArray<uint32_t> (Size: 0x10)
ActGoodCommentConfTableRow.trigger_interval = 0x30 // uint32_t (Size: 0x4)
ActGoodCommentConfTableRow.max_trigger_count = 0x34 // uint32_t (Size: 0x4)
ActGoodCommentConfTableRow.channel_infos = 0x38 // TArray<FChannelInfo> (Size: 0x10)
ActKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ActKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
ActLink.link_id = 0x0 // uint32_t (Size: 0x4)
ActLink.Index = 0x4 // uint32_t (Size: 0x4)
ActivityLootDropInfoConf.activity_id = 0x0 // uint32_t (Size: 0x4)
ActivityLootDropInfoConf.activity_weight = 0x4 // uint32_t (Size: 0x4)
ActivityLootDropInfoConf.in_game_time = 0x8 // uint32_t (Size: 0x4)
ActivityLootDropInfoConf.Weather = 0xc // uint32_t (Size: 0x4)
ActivityLootDropInfoConf.pool_id = 0x10 // uint32_t (Size: 0x4)
AdcodeConfTableRow.ADCode = 0x8 // uint32_t (Size: 0x4)
AdcodeConfTableRow.Region = 0x10 // TArray<FText> (Size: 0x10)
AdditionMeshAnimInfo.AnimType = 0x0 // uint32_t (Size: 0x4)
AdditionMeshAnimInfo.SkeletalMeshPath = 0x8 // FSoftObjectPath (Size: 0x18)
AdditionMeshAnimInfo.bAttachToCharacter = 0x20 // bool (Size: 0x1)
AdditionMeshAnimInfo.AttachSocketName = 0x24 // FName (Size: 0x8)
AdditionMeshAnimInfo.AdditionMeshAnimInstance = 0x30 // FSoftClassPath (Size: 0x18)
AdditionMeshAnimInfo.AdditionMeshAnim = 0x48 // FSoftObjectPath (Size: 0x18)
AllowTakeInItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AllowTakeInItemConfTableRow.is_blackset = 0xc // uint32_t (Size: 0x4)
AllowTakeInItemConfTableRow.item_limit_vec = 0x10 // TArray<FMultiModeItemLimitConf> (Size: 0x10)
AllowTakeInItemConfTableRow.item_out_vec = 0x20 // TArray<FMultiModeItemOutConf> (Size: 0x10)
AmmoMagazineRelationTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
AmmoMagazineRelationTableRow.ammo_count = 0xc // uint32_t (Size: 0x4)
AmmoMagazineRelationTableRow.ammo_count_mul = 0x10 // uint32_t (Size: 0x4)
AmmoMagazineRelationTableRow.capacity_ratio = 0x14 // uint32_t (Size: 0x4)
AmmoMagazineRelationTableRow.filling_ratio = 0x18 // uint32_t (Size: 0x4)
AmmoNumTableRow.magazine_id = 0x8 // uint64_t (Size: 0x8)
AmmoNumTableRow.Type = 0x10 // int32_t (Size: 0x4)
AmmoNumTableRow.full_name = 0x18 // FText (Size: 0x18)
AmmoNumTableRow.full_max = 0x30 // uint32_t (Size: 0x4)
AmmoNumTableRow.full_min = 0x34 // uint32_t (Size: 0x4)
AmmoNumTableRow.almostfull_name = 0x38 // FText (Size: 0x18)
AmmoNumTableRow.almostfull_max = 0x50 // int32_t (Size: 0x4)
AmmoNumTableRow.almostfull_min = 0x54 // int32_t (Size: 0x4)
AmmoNumTableRow.morethanhalf_name = 0x58 // FText (Size: 0x18)
AmmoNumTableRow.morethanhalf_max = 0x70 // int32_t (Size: 0x4)
AmmoNumTableRow.morethanhalf_min = 0x74 // int32_t (Size: 0x4)
AmmoNumTableRow.abouthalf_name = 0x78 // FText (Size: 0x18)
AmmoNumTableRow.abouthalf_max = 0x90 // int32_t (Size: 0x4)
AmmoNumTableRow.abouthalf_min = 0x94 // int32_t (Size: 0x4)
AmmoNumTableRow.lessthanhalf_name = 0x98 // FText (Size: 0x18)
AmmoNumTableRow.lessthanhalf_max = 0xb0 // int32_t (Size: 0x4)
AmmoNumTableRow.lessthanhalf_min = 0xb4 // int32_t (Size: 0x4)
AmmoNumTableRow.almostempty_name = 0xb8 // FText (Size: 0x18)
AmmoNumTableRow.almostempty_max = 0xd0 // int32_t (Size: 0x4)
AmmoNumTableRow.almostempty_min = 0xd4 // int32_t (Size: 0x4)
AmmoNumTableRow.empty_name = 0xd8 // FText (Size: 0x18)
AmmoNumTableRow.Empty = 0xf0 // int32_t (Size: 0x4)
AntipenetrationConfTableRow.material_id = 0x8 // uint32_t (Size: 0x4)
AntipenetrationConfTableRow.material_coef = 0xc // uint32_t (Size: 0x4)
AppearancePresetConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
AppearancePresetConfTableRow.Name = 0x10 // FText (Size: 0x18)
AppraiseConditionConf.expression = 0x0 // FText (Size: 0x18)
AppraiseConditionConf.Op = 0x18 // uint32_t (Size: 0x4)
AppraiseConditionConf.Val = 0x20 // int64_t (Size: 0x8)
AreaInfo.AreaID = 0x0 // FString (Size: 0x10)
AreaInfo.Weight = 0x10 // int32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_id = 0x8 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_protecttype = 0xc // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_level = 0x10 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_protectmask = 0x14 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_protectdisplay = 0x18 // TArray<uint32_t> (Size: 0x10)
ArmorDetailConfTableRow.armor_headdetailprotectmask = 0x28 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_antipenetrationfactor = 0x2c // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.armor_damagescaleforblock = 0x30 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_penetrate_coefficient = 0x34 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_penetrate_coefficient_constant = 0x38 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_destructibility = 0x3c // float (Size: 0x4)
ArmorDetailConfTableRow.ArmorDestructibilityScaleByPart = 0x40 // TArray<float> (Size: 0x10)
ArmorDetailConfTableRow.armor_material_id = 0x50 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.size_ext = 0x58 // TArray<uint32_t> (Size: 0x10)
ArmorDetailConfTableRow.armor_materialname = 0x68 // FText (Size: 0x18)
ArmorDetailConfTableRow.armor_ricochetangle = 0x80 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_ricochetprobabilitymin = 0x84 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_ricochetprobabilitymax = 0x88 // float (Size: 0x4)
ArmorDetailConfTableRow.armor_ricochetcooldown = 0x8c // float (Size: 0x4)
ArmorDetailConfTableRow.MoveSpeed = 0x90 // float (Size: 0x4)
ArmorDetailConfTableRow.TurnSpeed = 0x94 // float (Size: 0x4)
ArmorDetailConfTableRow.Engonomics = 0x98 // float (Size: 0x4)
ArmorDetailConfTableRow.ImpactResistance = 0x9c // float (Size: 0x4)
ArmorDetailConfTableRow.SoundPick = 0xa0 // FText (Size: 0x18)
ArmorDetailConfTableRow.NoiseReduce = 0xb8 // FText (Size: 0x18)
ArmorDetailConfTableRow.DefenseFlash = 0xd0 // FText (Size: 0x18)
ArmorDetailConfTableRow.DefensePoison = 0xe8 // FText (Size: 0x18)
ArmorDetailConfTableRow.SoundBlock = 0x100 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.SoundLevelInfluence = 0x104 // float (Size: 0x4)
ArmorDetailConfTableRow.SoundMaxDistanceInfluenceFactor = 0x108 // float (Size: 0x4)
ArmorDetailConfTableRow.SoundIndicatorLevelInfluence = 0x10c // float (Size: 0x4)
ArmorDetailConfTableRow.SoundIndicatorMaxDistanceInfluenceFactor = 0x110 // float (Size: 0x4)
ArmorDetailConfTableRow.FlashTimeInfluenceFactor = 0x114 // float (Size: 0x4)
ArmorDetailConfTableRow.FlashEffectInfluenceFactor = 0x118 // float (Size: 0x4)
ArmorDetailConfTableRow.StaticScreenEffectPath = 0x120 // FString (Size: 0x10)
ArmorDetailConfTableRow.MaterialScreenEffectPath = 0x130 // FString (Size: 0x10)
ArmorDetailConfTableRow.HasBrokenScreenEffect = 0x140 // uint32_t (Size: 0x4)
ArmorDetailConfTableRow.AssembleTag = 0x148 // FString (Size: 0x10)
ArmorDetailConfTableRow.SubAssembleTag = 0x158 // FString (Size: 0x10)
ArmorDetailConfTableRow.slot_type = 0x168 // uint64_t (Size: 0x8)
ArmorDetailConfTableRow.sub_slot_type = 0x170 // uint64_t (Size: 0x8)
ArmorDetailConfTableRow.Sockets = 0x178 // TArray<FWeaponSocket> (Size: 0x10)
ArmorDetailConfTableRow.ConflictedItemIds = 0x188 // TArray<uint32_t> (Size: 0x10)
ArmorDetailConfTableRow.IgnoreSoundIndicatorType = 0x198 // TArray<uint32_t> (Size: 0x10)
ArmorDetailValueToAttributeTableRow.DetailValueName = 0x8 // FString (Size: 0x10)
ArmorDetailValueToAttributeTableRow.ConvertType = 0x18 // uint32_t (Size: 0x4)
ArmorDetailValueToAttributeTableRow.ConvertTargetName = 0x20 // FString (Size: 0x10)
ArmorDetailValueToAttributeTableRow.OperationType = 0x30 // uint32_t (Size: 0x4)
ArmorDetailValueToAttributeTableRow.SubOperationType = 0x34 // uint32_t (Size: 0x4)
ArmorMaterialConfTableRow.material_id = 0x8 // uint32_t (Size: 0x4)
ArmorMaterialConfTableRow.material_coef = 0xc // float (Size: 0x4)
ArmorProtectConfTableRow.protect_id = 0x8 // uint32_t (Size: 0x4)
ArmorProtectConfTableRow.protect_type = 0xc // uint32_t (Size: 0x4)
ArmorProtectConfTableRow.protect_part_hex = 0x10 // uint32_t (Size: 0x4)
ArmorProtectConfTableRow.protect_part_dec = 0x14 // uint32_t (Size: 0x4)
ArmorProtectDisplayConfTableRow.protect_display_id = 0x8 // uint32_t (Size: 0x4)
ArmorProtectDisplayConfTableRow.protect_display_type = 0xc // uint32_t (Size: 0x4)
ArmorProtectDisplayConfTableRow.protect_part_name = 0x10 // FText (Size: 0x18)
ArmorProtectDisplayConfTableRow.protect_part_dec = 0x28 // uint32_t (Size: 0x4)
ArmorProtectDisplayConfTableRow.protect_pic = 0x30 // FString (Size: 0x10)
AuctionContextMenuWhiteListTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionContextMenuWhiteListTableRow.Search_Related = 0xc // uint32_t (Size: 0x4)
AuctionContextMenuWhiteListTableRow.Search_This = 0x10 // uint32_t (Size: 0x4)
AuctionContextMenuWhiteListTableRow.Search_Ammo = 0x14 // uint32_t (Size: 0x4)
AuctionGetRightsWayTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionGetRightsWayTableRow.desc = 0x10 // FText (Size: 0x18)
AuctionGetRightsWayTableRow.jump_goto = 0x28 // uint32_t (Size: 0x4)
AuctionGetRightsWayTableRow.btn_title = 0x30 // FText (Size: 0x18)
AuctionGetRightsWayTableRow.is_check = 0x48 // uint32_t (Size: 0x4)
AuctionItemTableRow.ID = 0x8 // uint64_t (Size: 0x8)
AuctionItemTableRow.Parent = 0x10 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.weapon_parent = 0x20 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.durability_rate = 0x30 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.durability_sale_num_rate = 0x40 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.on_the_shelf = 0x50 // uint32_t (Size: 0x4)
AuctionItemTableRow.begin_time = 0x58 // FDateTime (Size: 0x8)
AuctionItemTableRow.end_time = 0x60 // FDateTime (Size: 0x8)
AuctionItemTableRow.act_id = 0x68 // uint32_t (Size: 0x4)
AuctionItemTableRow.sort = 0x70 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.combinable = 0x80 // uint32_t (Size: 0x4)
AuctionItemTableRow.one_way_auction = 0x84 // uint32_t (Size: 0x4)
AuctionItemTableRow.min_sell_num = 0x88 // uint32_t (Size: 0x4)
AuctionItemTableRow.minimum_sell_num = 0x8c // uint32_t (Size: 0x4)
AuctionItemTableRow.max_buy_num = 0x90 // uint32_t (Size: 0x4)
AuctionItemTableRow.max_sale_num = 0x94 // uint32_t (Size: 0x4)
AuctionItemTableRow.display_weapon = 0x98 // uint64_t (Size: 0x8)
AuctionItemTableRow.auto_order = 0xa0 // uint32_t (Size: 0x4)
AuctionItemTableRow.sale_price_rate_min = 0xa4 // float (Size: 0x4)
AuctionItemTableRow.sale_price_rate_max = 0xa8 // float (Size: 0x4)
AuctionItemTableRow.sale_price_u = 0xac // float (Size: 0x4)
AuctionItemTableRow.sale_price_s = 0xb0 // float (Size: 0x4)
AuctionItemTableRow.sale_num_rate_min = 0xb4 // float (Size: 0x4)
AuctionItemTableRow.sale_num_rate_max = 0xb8 // float (Size: 0x4)
AuctionItemTableRow.merge_sale_price_step_rate = 0xbc // uint32_t (Size: 0x4)
AuctionItemTableRow.Tags = 0xc0 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.official_order_calc_params = 0xd0 // FString (Size: 0x10)
AuctionItemTableRow.official_order_delay_time = 0xe0 // uint32_t (Size: 0x4)
AuctionItemTableRow.min_price_scale = 0xe4 // float (Size: 0x4)
AuctionItemTableRow.max_price_scale = 0xe8 // float (Size: 0x4)
AuctionItemTableRow.replace_order_price_rate = 0xf0 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.replace_order_random = 0x100 // TArray<uint32_t> (Size: 0x10)
AuctionItemTableRow.hour_official_place_rate = 0x110 // float (Size: 0x4)
AuctionItemTableRow.once_official_place_rate = 0x114 // float (Size: 0x4)
AuctionItemTableRow.official_place_price_step = 0x118 // float (Size: 0x4)
AuctionItemTableRow.official_place_limit_rate = 0x11c // float (Size: 0x4)
AuctionItemTableRow.item_flag = 0x120 // uint32_t (Size: 0x4)
AuctionItemTableRow.standprice_a1 = 0x124 // uint32_t (Size: 0x4)
AuctionItemTableRow.standprice_b1 = 0x128 // uint32_t (Size: 0x4)
AuctionItemTableRow.avgprice_a2 = 0x12c // uint32_t (Size: 0x4)
AuctionItemTableRow.avgprice_b2 = 0x130 // uint32_t (Size: 0x4)
AuctionItemTableRow.step_len = 0x134 // uint32_t (Size: 0x4)
AuctionMajorTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionMajorTableRow.Name = 0x10 // FText (Size: 0x18)
AuctionMajorTableRow.sort = 0x28 // uint32_t (Size: 0x4)
AuctionMajorTableRow.Show = 0x2c // uint32_t (Size: 0x4)
AuctionMajorTableRow.skip_minor = 0x30 // uint32_t (Size: 0x4)
AuctionMajorTableRow.icon_path = 0x38 // FString (Size: 0x10)
AuctionMajorTableRow.icon_path_id = 0x48 // uint32_t (Size: 0x4)
AuctionMajorTableRow.filter_option_id = 0x4c // uint32_t (Size: 0x4)
AuctionMinorTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionMinorTableRow.Name = 0x10 // FText (Size: 0x18)
AuctionMinorTableRow.sort = 0x28 // uint32_t (Size: 0x4)
AuctionMinorTableRow.Parent = 0x30 // TArray<uint32_t> (Size: 0x10)
AuctionMinorTableRow.Show = 0x40 // uint32_t (Size: 0x4)
AuctionMinorTableRow.show_summary = 0x44 // uint32_t (Size: 0x4)
AuctionMinorTableRow.icon_path = 0x48 // FString (Size: 0x10)
AuctionMinorTableRow.icon_path_id = 0x58 // uint32_t (Size: 0x4)
AuctionMinorTableRow.show_titles = 0x60 // TArray<uint32_t> (Size: 0x10)
AuctionMinorTableRow.filter_option_id = 0x70 // uint32_t (Size: 0x4)
AuctionOrderParamsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionOrderParamsTableRow.params_a = 0xc // uint32_t (Size: 0x4)
AuctionOrderParamsTableRow.params_b = 0x10 // uint32_t (Size: 0x4)
AuctionOrderParamsTableRow.params_c = 0x14 // uint32_t (Size: 0x4)
AuctionOrderParamsTableRow.params_d = 0x18 // uint32_t (Size: 0x4)
AuctionSafeQuestionConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionSafeQuestionConfTableRow.number1 = 0xc // uint32_t (Size: 0x4)
AuctionSafeQuestionConfTableRow.symbol = 0x10 // FText (Size: 0x18)
AuctionSafeQuestionConfTableRow.number2 = 0x28 // uint32_t (Size: 0x4)
AuctionSafeQuestionConfTableRow.Answer = 0x2c // uint32_t (Size: 0x4)
AuctionScaleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionScaleConfTableRow.DistancePercentA = 0xc // float (Size: 0x4)
AuctionTagsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AuctionTagsTableRow.Name = 0x10 // FText (Size: 0x18)
AuctionTagsTableRow.icon_path = 0x28 // FString (Size: 0x10)
AvatarCompleteShareConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarCompleteShareConfTableRow.cdn_url = 0x10 // FString (Size: 0x10)
AvatarFactoryCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarFactoryCfgTableRow.Name = 0x10 // FString (Size: 0x10)
AvatarFactoryCfgTableRow.icon = 0x20 // FString (Size: 0x10)
AvatarFactoryCfgTableRow.desc = 0x30 // FString (Size: 0x10)
AvatarFactoryCfgTableRow.series = 0x40 // TArray<uint32_t> (Size: 0x10)
AvatarFilterGroupConf.option_type = 0x0 // uint32_t (Size: 0x4)
AvatarFilterGroupConf.Name = 0x8 // FText (Size: 0x18)
AvatarFilterGroupConf.useAll = 0x20 // uint32_t (Size: 0x4)
AvatarFilterGroupConf.isSingleSelect = 0x24 // uint32_t (Size: 0x4)
AvatarFilterGroupConf.IsShow = 0x28 // uint32_t (Size: 0x4)
AvatarFilterGroupConf.Item_type = 0x2c // uint32_t (Size: 0x4)
AvatarFilterGroupConf.custom_items_func = 0x30 // FString (Size: 0x10)
AvatarFilterGroupConf.custom_items_type = 0x40 // uint32_t (Size: 0x4)
AvatarFilterGroupConf.filter_items = 0x48 // TArray<uint32_t> (Size: 0x10)
AvatarHairOptionsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarHairOptionsTableRow.hair = 0xc // uint32_t (Size: 0x4)
AvatarHairOptionsTableRow.Color = 0x10 // uint32_t (Size: 0x4)
AvatarHairOptionsTableRow.composite_id = 0x14 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.sex = 0xc // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.is_show = 0x10 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.Score = 0x14 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.replace_itemid = 0x18 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.replace_num = 0x1c // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.jump_goto = 0x20 // TArray<uint32_t> (Size: 0x10)
AvatarItemCfgTableRow.no_source_description = 0x30 // FText (Size: 0x18)
AvatarItemCfgTableRow.factory_id = 0x48 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.effect_bg_path = 0x50 // FString (Size: 0x10)
AvatarItemCfgTableRow.is_dynamic_logo = 0x60 // uint32_t (Size: 0x4)
AvatarItemCfgTableRow.activity_info = 0x68 // FString (Size: 0x10)
AvatarItemCfgTableRow.Tags = 0x78 // TArray<uint32_t> (Size: 0x10)
AvatarItemCfgTableRow.series = 0x88 // uint32_t (Size: 0x4)
AvatarItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarItemConfTableRow.conflect_types = 0x10 // TArray<uint32_t> (Size: 0x10)
AvatarPartTabCfgTableRow.PartId = 0x8 // uint32_t (Size: 0x4)
AvatarPartTabCfgTableRow.Name = 0x10 // FString (Size: 0x10)
AvatarPartTabCfgTableRow.icon = 0x20 // FString (Size: 0x10)
AvatarPartTabCfgTableRow.not_show_empty = 0x30 // uint32_t (Size: 0x4)
AvatarPartTabCfgTableRow.show_default_item = 0x34 // uint32_t (Size: 0x4)
AvatarPartTabCfgTableRow.filter_option_id = 0x38 // uint32_t (Size: 0x4)
AvatarPartTabFilterCfgTableRow.PlanId = 0x8 // uint32_t (Size: 0x4)
AvatarPartTabFilterCfgTableRow.Options = 0x10 // TArray<FAvatarFilterGroupConf> (Size: 0x10)
AvatarPartTabFilterItemCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarPartTabFilterItemCfgTableRow.Name = 0x10 // FText (Size: 0x18)
AvatarPartTabFilterItemCfgTableRow.Type = 0x28 // uint32_t (Size: 0x4)
AvatarPartTabFilterItemCfgTableRow.Param = 0x2c // uint32_t (Size: 0x4)
AvatarSet.avatars = 0x0 // TArray<uint32_t> (Size: 0x10)
AvatarSetCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarSetCfgTableRow.Level = 0x10 // FString (Size: 0x10)
AvatarSetCfgTableRow.special_voice = 0x20 // FString (Size: 0x10)
AvatarSetCfgTableRow.is_show_list = 0x30 // uint32_t (Size: 0x4)
AvatarSetCfgTableRow.avatar_gender = 0x34 // uint32_t (Size: 0x4)
AvatarSetCfgTableRow.IsIntergral = 0x38 // uint32_t (Size: 0x4)
AvatarSetCfgTableRow.avatar_set = 0x40 // TArray<uint32_t> (Size: 0x10)
AvatarTabCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarTabCfgTableRow.Index = 0xc // uint32_t (Size: 0x4)
AvatarTabCfgTableRow.head_index = 0x10 // uint32_t (Size: 0x4)
AvatarTabCfgTableRow.sub_part_id = 0x18 // TArray<uint32_t> (Size: 0x10)
AvatarTabCfgTableRow.Name = 0x28 // FString (Size: 0x10)
AvatarTabCfgTableRow.icon = 0x38 // FString (Size: 0x10)
AvatarTabCfgTableRow.show_sub_tab = 0x48 // uint32_t (Size: 0x4)
AvatarTagCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarTagCfgTableRow.Name = 0x10 // FText (Size: 0x18)
AvatarTagCfgTableRow.Level = 0x28 // uint32_t (Size: 0x4)
AvatarTagCfgTableRow.Describe = 0x30 // FText (Size: 0x18)
AvatarValueNameTableRow.ID = 0x8 // uint32_t (Size: 0x4)
AvatarValueNameTableRow.Name = 0x10 // FString (Size: 0x10)
AvatarValueShowTableRow.avatar_id = 0x8 // uint32_t (Size: 0x4)
AvatarValueShowTableRow.buff_list = 0x10 // TArray<FBuffInfo> (Size: 0x10)
AwardItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
AwardItemConf.Num = 0x4 // uint32_t (Size: 0x4)
AwardItemConf.is_black = 0x8 // uint32_t (Size: 0x4)
AwardItemConf.is_faction = 0xc // uint32_t (Size: 0x4)
BadgeConfTableRow.badge_id = 0x8 // uint32_t (Size: 0x4)
BadgeConfTableRow.badge_name = 0x10 // FText (Size: 0x18)
BadgeConfTableRow.is_dynamic_logo = 0x28 // uint32_t (Size: 0x4)
BadgeConfTableRow.activity_info = 0x30 // FString (Size: 0x10)
BadgeConfTableRow.jump_goto = 0x40 // TArray<uint32_t> (Size: 0x10)
BadgeConfTableRow.no_source_description = 0x50 // FText (Size: 0x18)
BadgeSlotConfTableRow.slot_id = 0x8 // uint32_t (Size: 0x4)
BadgeSlotConfTableRow.is_unlock = 0xc // uint32_t (Size: 0x4)
BadgeSlotConfTableRow.slot_name = 0x10 // FText (Size: 0x18)
BadgeSlotConfTableRow.sort = 0x28 // uint32_t (Size: 0x4)
BadgeSlotConfTableRow.check_wear = 0x2c // uint32_t (Size: 0x4)
BadgeSlotConfTableRow.slot_icon = 0x30 // FString (Size: 0x10)
BanChatCountryConfTableRow.country_code = 0x8 // uint32_t (Size: 0x4)
BanMatchModeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BanMatchModeConfTableRow.SubModeID = 0xc // uint32_t (Size: 0x4)
BanMatchModeConfTableRow.RuleID = 0x10 // uint32_t (Size: 0x4)
BanMatchModeConfTableRow.Content = 0x18 // FText (Size: 0x18)
BanReasonConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BanReasonConfTableRow.Content = 0x10 // FText (Size: 0x18)
BanThrowsconfTableRow.RowNum = 0x8 // int32_t (Size: 0x4)
BanThrowsconfTableRow.ItemId = 0x10 // uint64_t (Size: 0x8)
BanThrowsconfTableRow.HitGroup = 0x18 // uint32_t (Size: 0x4)
BanThrowsconfTableRow.DamageThres = 0x1c // float (Size: 0x4)
BanThrowsconfTableRow.DamageTimes = 0x20 // int32_t (Size: 0x4)
BanThrowsconfTableRow.TimeThres = 0x28 // TArray<int32_t> (Size: 0x10)
BanThrowsconfTableRow.BanTime = 0x38 // uint64_t (Size: 0x8)
BanTypeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BanTypeConfTableRow.Content = 0x10 // FText (Size: 0x18)
BanTypeConfTableRow.ban_tips = 0x28 // TArray<FText> (Size: 0x10)
BattlePassAwardItemsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassAwardItemsConfTableRow.award = 0x10 // TArray<FBlackItemConf> (Size: 0x10)
BattlePassConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassConfTableRow.max_level = 0xc // uint32_t (Size: 0x4)
BattlePassConfTableRow.award_max_level = 0x10 // uint32_t (Size: 0x4)
BattlePassConfTableRow.need_exp = 0x14 // uint32_t (Size: 0x4)
BattlePassConfTableRow.game_exp_2_bp_ratio = 0x18 // uint32_t (Size: 0x4)
BattlePassConfTableRow.buy_exp_item = 0x1c // uint32_t (Size: 0x4)
BattlePassConfTableRow.buy_exp_cost = 0x20 // uint32_t (Size: 0x4)
BattlePassConfTableRow.overview_default_select_id = 0x24 // uint32_t (Size: 0x4)
BattlePassConfTableRow.show_time = 0x28 // FText (Size: 0x18)
BattlePassConfTableRow.entry_img_cdn_path = 0x40 // FString (Size: 0x10)
BattlePassConfTableRow.img_cdn_path = 0x50 // FString (Size: 0x10)
BattlePassConfTableRow.try_wear_list = 0x60 // TArray<uint32_t> (Size: 0x10)
BattlePassConfTableRow.exchange_bg = 0x70 // uint32_t (Size: 0x4)
BattlePassConfTableRow.first_pop_img_path = 0x78 // TArray<FText> (Size: 0x10)
BattlePassConfTableRow.upgrade_step = 0x88 // uint32_t (Size: 0x4)
BattlePassConfTableRow.growup_items_desc = 0x90 // FText (Size: 0x18)
BattlePassLastSeasonAwardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.level_min = 0x10 // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.level_max = 0x14 // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.login_day_min = 0x18 // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.login_day_max = 0x1c // uint32_t (Size: 0x4)
BattlePassLastSeasonAwardConfTableRow.award = 0x20 // TArray<uint32_t> (Size: 0x10)
BattlePassLastSeasonAwardConfTableRow.desc = 0x30 // FText (Size: 0x18)
BattlePassLevelConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassLevelConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
BattlePassLevelConfTableRow.group_id = 0x10 // uint32_t (Size: 0x4)
BattlePassLevelConfTableRow.award = 0x18 // TArray<FBattlePassLevelItem> (Size: 0x10)
BattlePassLevelConfTableRow.extra_award = 0x28 // TArray<FBattlePassLevelItem> (Size: 0x10)
BattlePassLevelItem.item_id = 0x0 // uint32_t (Size: 0x4)
BattlePassLevelItem.Num = 0x4 // uint32_t (Size: 0x4)
BattlePassLevelItem.is_black = 0x8 // uint32_t (Size: 0x4)
BattlePassOtherWayTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassOtherWayTableRow.unlock_level = 0xc // uint32_t (Size: 0x4)
BattlePassOtherWayTableRow.is_new = 0x10 // uint32_t (Size: 0x4)
BattlePassOtherWayTableRow.start_time = 0x18 // FDateTime (Size: 0x8)
BattlePassOtherWayTableRow.end_time = 0x20 // FDateTime (Size: 0x8)
BattlePassOtherWayTableRow.desc = 0x28 // FText (Size: 0x18)
BattlePassOtherWayTableRow.jump_goto = 0x40 // uint32_t (Size: 0x4)
BattlePassOtherWayTableRow.btn_title = 0x48 // FText (Size: 0x18)
BattlePassShowTypeTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassShowTypeTableRow.show_type = 0xc // uint32_t (Size: 0x4)
BattlePassShowTypeTableRow.show_location = 0x10 // FVector (Size: 0xc)
BattlePassShowTypeTableRow.show_rotation = 0x1c // FVector (Size: 0xc)
BattlePassShowTypeTableRow.show_scale = 0x28 // FVector (Size: 0xc)
BattlePassShowTypeTableRow.cell_image = 0x38 // FString (Size: 0x10)
BattlePassShowTypeTableRow.big_image = 0x48 // FString (Size: 0x10)
BattlePassShowTypeTableRow.is_showtips = 0x58 // uint32_t (Size: 0x4)
BattlePassShowTypeTableRow.show_tips = 0x60 // FText (Size: 0x18)
BattlePassShowTypeTableRow.btn_tips = 0x78 // FText (Size: 0x18)
BattlePassShowTypeTableRow.jump_goto = 0x90 // uint32_t (Size: 0x4)
BattlePassShowTypeTableRow.reward_sort_Index = 0x94 // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.pre_vip_lv = 0x10 // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.vip_lv = 0x14 // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.Name = 0x18 // FText (Size: 0x18)
BattlePassVipConfTableRow.purchase_id = 0x30 // uint32_t (Size: 0x4)
BattlePassVipConfTableRow.award = 0x38 // TArray<FBattlePassVipItem> (Size: 0x10)
BattlePassVipItem.item_id = 0x0 // uint32_t (Size: 0x4)
BattlePassVipItem.Num = 0x4 // uint32_t (Size: 0x4)
BattlePassVipItem.show_type = 0x8 // uint32_t (Size: 0x4)
BattlePassVipItem.is_black = 0xc // uint32_t (Size: 0x4)
BattlePassVipShowConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattlePassVipShowConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
BattlePassVipShowConfTableRow.vip_id = 0x10 // uint32_t (Size: 0x4)
BattlePassVipShowConfTableRow.award = 0x18 // TArray<FBattlePassVipShowItem> (Size: 0x10)
BattlePassVipShowItem.item_id = 0x0 // uint32_t (Size: 0x4)
BattlePassVipShowItem.Num = 0x4 // uint32_t (Size: 0x4)
BattlePassVipShowItem.Type = 0x8 // FText (Size: 0x18)
BattlePassVipShowItem.is_black = 0x20 // uint32_t (Size: 0x4)
BattlePassVipShowItem.is_jump = 0x24 // uint32_t (Size: 0x4)
BattlePassVipShowItem.unlock_desc = 0x28 // FText (Size: 0x18)
BattlePassVipShowItem.item_desc = 0x40 // FText (Size: 0x18)
BattlePassWorldLevelConfTableRow.week_idx = 0x8 // uint32_t (Size: 0x4)
BattlePassWorldLevelConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
BattlePassWorldLevelConfTableRow.delta_level = 0x10 // uint32_t (Size: 0x4)
BattleResultAppraiseSeasonConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultAppraiseSeasonConfTableRow.appraise_id_list = 0x10 // TArray<uint32_t> (Size: 0x10)
BattleResultAppraiseTableRow.AppraiseId = 0x8 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.AppraiseName = 0x10 // FText (Size: 0x18)
BattleResultAppraiseTableRow.Describe = 0x28 // FText (Size: 0x18)
BattleResultAppraiseTableRow.DesWords = 0x40 // FText (Size: 0x18)
BattleResultAppraiseTableRow.event_id_array = 0x58 // TArray<int64_t> (Size: 0x10)
BattleResultAppraiseTableRow.event_val_array = 0x68 // TArray<int64_t> (Size: 0x10)
BattleResultAppraiseTableRow.ignore_multi_mode_list = 0x78 // TArray<uint32_t> (Size: 0x10)
BattleResultAppraiseTableRow.Conditions = 0x88 // TArray<FAppraiseConditionConf> (Size: 0x10)
BattleResultAppraiseTableRow.icon = 0x98 // FString (Size: 0x10)
BattleResultAppraiseTableRow.Group = 0xa8 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.GroupShowIndex = 0xac // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Class = 0xb0 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.ClassIndex = 0xb4 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.quality = 0xb8 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.FacePicMapUnlockIds = 0xc0 // TArray<uint32_t> (Size: 0x10)
BattleResultAppraiseTableRow.SeasonPropotion = 0xd0 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Proportion = 0xd4 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.PlatformCDNImageURLID = 0xd8 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.MagazineShareDesc = 0xe0 // FText (Size: 0x18)
BattleResultAppraiseTableRow.AppraiseImageIndex = 0xf8 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.DataDes = 0x100 // FText (Size: 0x18)
BattleResultAppraiseTableRow.ShareDescribe = 0x118 // FText (Size: 0x18)
BattleResultAppraiseTableRow.ShareDesWords = 0x130 // FText (Size: 0x18)
BattleResultAppraiseTableRow.CanShare = 0x148 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.SeasonForceShowType = 0x14c // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.ForceShowType = 0x150 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Type = 0x154 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Param1 = 0x158 // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Param2 = 0x15c // uint32_t (Size: 0x4)
BattleResultAppraiseTableRow.Param3 = 0x160 // uint32_t (Size: 0x4)
BattleResultAreaConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultAreaConfTableRow.AreaName = 0x10 // FText (Size: 0x18)
BattleResultConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
BattleResultConfTableRow.AttributeType = 0x10 // uint32_t (Size: 0x4)
BattleResultConfTableRow.Proportion = 0x14 // uint32_t (Size: 0x4)
BattleResultConfTableRow.Describe = 0x18 // FText (Size: 0x18)
BattleResultConfTableRow.FromType = 0x30 // uint32_t (Size: 0x4)
BattleResultConfTableRow.AppendId = 0x38 // TArray<uint32_t> (Size: 0x10)
BattleResultConfTableRow.Scale = 0x48 // FText (Size: 0x18)
BattleResultConfTableRow.Format = 0x60 // FString (Size: 0x10)
BattleResultConfTableRow.Unit = 0x70 // FText (Size: 0x18)
BattleResultConfTableRow.RoundingType = 0x88 // uint32_t (Size: 0x4)
BattleResultDieTipsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultDieTipsTableRow.Tips = 0x10 // FText (Size: 0x18)
BattleResultDieTypeTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.DieType = 0xc // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.DetailBodyPart = 0x10 // FString (Size: 0x10)
BattleResultDieTypeTableRow.BodyPart = 0x20 // FString (Size: 0x10)
BattleResultDieTypeTableRow.SpreadBodyPart = 0x30 // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.HitArmor = 0x34 // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.IsThough = 0x38 // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.OverBulletKill = 0x3c // uint32_t (Size: 0x4)
BattleResultDieTypeTableRow.DeathCauserIdList = 0x40 // TArray<uint32_t> (Size: 0x10)
BattleResultDieTypeTableRow.ResultTitle = 0x50 // FText (Size: 0x18)
BattleResultDieTypeTableRow.TipsArray = 0x68 // FString (Size: 0x10)
BattleResultEXPRatioTableRow.ResultId = 0x8 // uint32_t (Size: 0x4)
BattleResultEXPRatioTableRow.EXPRatio = 0xc // uint32_t (Size: 0x4)
BattleResultEXPRatioTableRow.Describe = 0x10 // FText (Size: 0x18)
BattleResultEnemyTipsFuncTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultEnemyTipsFuncTableRow.CheckFunc = 0x10 // FText (Size: 0x18)
BattleResultEnemyTipsFuncTableRow.Params = 0x28 // TArray<FText> (Size: 0x10)
BattleResultEnemyTipsFuncTableRow.ParamsType = 0x38 // TArray<FText> (Size: 0x10)
BattleResultEnemyTipsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultEnemyTipsTableRow.CheckFuncIds = 0x10 // TArray<uint32_t> (Size: 0x10)
BattleResultEnemyTipsTableRow.Priority = 0x20 // uint32_t (Size: 0x4)
BattleResultEnemyTipsTableRow.JudgeResults = 0x28 // TArray<bool> (Size: 0x10)
BattleResultEnemyTipsTableRow.Tips = 0x38 // FText (Size: 0x18)
BattleResultInjuredRecordTableRow.InjuredId = 0x8 // uint32_t (Size: 0x4)
BattleResultInjuredRecordTableRow.InjuredRecordDescribe = 0x10 // FText (Size: 0x18)
BattleResultInjuredRecordTableRow.InjuredFormType = 0x28 // FString (Size: 0x10)
BattleResultLoadingImageTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultLoadingImageTableRow.Path = 0x10 // FString (Size: 0x10)
BattleResultLoadingImageTableRow.Weight = 0x20 // uint32_t (Size: 0x4)
BattleResultLoadingImageTableRow.BattleResult = 0x24 // uint32_t (Size: 0x4)
BattleResultLoadingImageTableRow.MapName = 0x28 // FString (Size: 0x10)
BattleResultLoadingTipsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultLoadingTipsTableRow.Tip = 0x10 // FText (Size: 0x18)
BattleResultLoadingTipsTableRow.Weight = 0x28 // uint32_t (Size: 0x4)
BattleResultLoadingTipsTableRow.BattleResult = 0x2c // uint32_t (Size: 0x4)
BattleResultLootBoxConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultLootBoxConfTableRow.LootBoxKey = 0x10 // FString (Size: 0x10)
BattleResultLootBoxConfTableRow.LootBoxName = 0x20 // FText (Size: 0x18)
BattleResultMapTextureConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.MainModeID = 0xc // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.SubModeID = 0x10 // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.MapID = 0x14 // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.SpecialID = 0x18 // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.Difficulty = 0x1c // uint32_t (Size: 0x4)
BattleResultMapTextureConfTableRow.TexturePath = 0x20 // FText (Size: 0x18)
BattleResultPointEventConfTableRow.eventId = 0x8 // uint32_t (Size: 0x4)
BattleResultPointEventConfTableRow.EventTypeDes = 0x10 // FText (Size: 0x18)
BattleResultPointEventConfTableRow.EventTitle = 0x28 // FText (Size: 0x18)
BattleResultPointEventConfTableRow.DescribeWord = 0x40 // FText (Size: 0x18)
BattleResultPointEventConfTableRow.Weight = 0x58 // uint32_t (Size: 0x4)
BattleResultPointEventConfTableRow.DescribeWordArgsList = 0x60 // TArray<FDescribeArg> (Size: 0x10)
BattleResultPointEventConfTableRow.CombinedDescribeWord = 0x70 // FText (Size: 0x18)
BattleResultPointEventConfTableRow.CombinedDescribeWordArgsList = 0x88 // TArray<FDescribeArg> (Size: 0x10)
BattleResultReferTableRow.StatisticsId = 0x8 // uint32_t (Size: 0x4)
BattleResultReferTableRow.Describe = 0x10 // FText (Size: 0x18)
BattleResultTransConfTableRow.trans_id = 0x8 // uint32_t (Size: 0x4)
BattleResultTransConfTableRow.event_id = 0x10 // int64_t (Size: 0x8)
BattleResultTransConfTableRow.coeff = 0x18 // int64_t (Size: 0x8)
BattleResultTransConfTableRow.item_id = 0x20 // uint32_t (Size: 0x4)
BattleResultTransConfTableRow.max_num = 0x24 // uint32_t (Size: 0x4)
BattleResultTransConfTableRow.EventName = 0x28 // FText (Size: 0x18)
BattleResultTransConfTableRow.DescType = 0x40 // uint32_t (Size: 0x4)
BattleResultTransConfTableRow.Scale = 0x48 // FText (Size: 0x18)
BattleResultTransConfTableRow.Format = 0x60 // FString (Size: 0x10)
BattleResultTransConfTableRow.Unit = 0x70 // FText (Size: 0x18)
BattleResultTransConfTableRow.RoundingType = 0x88 // uint32_t (Size: 0x4)
BattleResultTransTemplateConfTableRow.template_id = 0x8 // uint32_t (Size: 0x4)
BattleResultTransTemplateConfTableRow.trans_id_list = 0x10 // TArray<uint32_t> (Size: 0x10)
BattleStatConfTableRow.stat_type = 0x8 // uint32_t (Size: 0x4)
BlackItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
BlackItemConf.Num = 0x4 // uint32_t (Size: 0x4)
BlackItemConf.is_black = 0x8 // uint32_t (Size: 0x4)
BlackSocketInfo.ParentItemID = 0x0 // uint32_t (Size: 0x4)
BlackSocketInfo.SocketName = 0x4 // FName (Size: 0x8)
BlackStoreDropInfo.item_randomId = 0x0 // uint64_t (Size: 0x8)
BlackStoreDropInfo.item_num = 0x8 // uint32_t (Size: 0x4)
BlackStoreDropListConfigTableRow.ID = 0x8 // uint64_t (Size: 0x8)
BlackStoreDropListConfigTableRow.Items = 0x10 // TArray<FBlackStoreDropInfo> (Size: 0x10)
BlackStoreItemRandomConfigTableRow.ID = 0x8 // uint64_t (Size: 0x8)
BlackStoreItemRandomConfigTableRow.planItems = 0x10 // TArray<FItemsDropPool> (Size: 0x10)
BodyDetailsPartsTableTableRow.PositionId = 0x8 // uint64_t (Size: 0x8)
BodyDetailsPartsTableTableRow.BodyPartId = 0x10 // uint64_t (Size: 0x8)
BodyDetailsPartsTableTableRow.Describe = 0x18 // FText (Size: 0x18)
BodyPartsTableTableRow.PositionId = 0x8 // uint64_t (Size: 0x8)
BodyPartsTableTableRow.Describe = 0x10 // FText (Size: 0x18)
BossTokenConfTableRow.GroupID = 0x8 // uint32_t (Size: 0x4)
BossTokenConfTableRow.ItemId = 0xc // uint32_t (Size: 0x4)
BrokenImageConfTableRow.Index = 0x8 // uint32_t (Size: 0x4)
BrokenImageConfTableRow.FilePath = 0x10 // FString (Size: 0x10)
BrokenImageConfTableRow.Left = 0x20 // float (Size: 0x4)
BrokenImageConfTableRow.Top = 0x24 // float (Size: 0x4)
BrokenImageConfTableRow.Right = 0x28 // float (Size: 0x4)
BrokenImageConfTableRow.Bottom = 0x2c // float (Size: 0x4)
BuffIconConfTableRow.buff_id = 0x8 // uint32_t (Size: 0x4)
BuffIconConfTableRow.buff_name = 0x10 // FString (Size: 0x10)
BuffIconConfTableRow.icon_path = 0x20 // FString (Size: 0x10)
BuffIconConfTableRow.inspecticon_path = 0x30 // FString (Size: 0x10)
BuffIconConfTableRow.display_name = 0x40 // FText (Size: 0x18)
BuffIconConfTableRow.Describe = 0x58 // FText (Size: 0x18)
BuffIconConfTableRow.Type = 0x70 // uint32_t (Size: 0x4)
BuffIconConfTableRow.buff_color = 0x74 // uint32_t (Size: 0x4)
BuffIconConfTableRow.showicon = 0x78 // uint32_t (Size: 0x4)
BuffIconConfTableRow.Priority = 0x7c // uint32_t (Size: 0x4)
BuffIconConfTableRow.show_type = 0x80 // FString (Size: 0x10)
BuffIconConfTableRow.part_head = 0x90 // FString (Size: 0x10)
BuffIconConfTableRow.part_chest = 0xa0 // FString (Size: 0x10)
BuffIconConfTableRow.part_stomach = 0xb0 // FString (Size: 0x10)
BuffIconConfTableRow.part_leftarm = 0xc0 // FString (Size: 0x10)
BuffIconConfTableRow.part_rightarm = 0xd0 // FString (Size: 0x10)
BuffIconConfTableRow.part_leftleg = 0xe0 // FString (Size: 0x10)
BuffIconConfTableRow.part_rightleg = 0xf0 // FString (Size: 0x10)
BuffInfo.ID = 0x0 // uint32_t (Size: 0x4)
BuffInfo.Value = 0x8 // FString (Size: 0x10)
BugSubmitConfTableRow.show_order = 0x8 // uint32_t (Size: 0x4)
BugSubmitConfTableRow.battle_question = 0x10 // FText (Size: 0x18)
BugSubmitConfTableRow.other_question = 0x28 // FText (Size: 0x18)
BulletConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BulletConfTableRow.GunId = 0xc // uint32_t (Size: 0x4)
BulletConfTableRow.MagazineBulletList = 0x10 // TArray<FMagazineBulletPack> (Size: 0x10)
BulletDetailConfTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
BulletDetailConfTableRow.BaseDamage = 0xc // float (Size: 0x4)
BulletDetailConfTableRow.BaseSpeed = 0x10 // float (Size: 0x4)
BulletDetailConfTableRow.PenetrationFactor = 0x14 // float (Size: 0x4)
BulletDetailConfTableRow.PenetrationLevel = 0x18 // int32_t (Size: 0x4)
BulletDetailConfTableRow.BrokenProbability = 0x1c // float (Size: 0x4)
BulletDetailConfTableRow.BrokenDamageScale = 0x20 // float (Size: 0x4)
BulletDetailConfTableRow.ArmorDamage = 0x24 // float (Size: 0x4)
BulletDetailConfTableRow.BleedProbabilityForPenetration = 0x28 // float (Size: 0x4)
BulletDetailConfTableRow.BleedProbabilityForBlock = 0x2c // float (Size: 0x4)
BulletDetailConfTableRow.BleedProbabilityForBody = 0x30 // float (Size: 0x4)
BulletDetailConfTableRow.BleedProbabilityDisplay = 0x38 // FText (Size: 0x18)
BulletDetailConfTableRow.AssembleTag = 0x50 // FString (Size: 0x10)
BulletDetailConfTableRow.slot_type = 0x60 // uint64_t (Size: 0x8)
BulletDetailConfTableRow.ShotsInOneBullet = 0x68 // int32_t (Size: 0x4)
BulletDetailConfTableRow.BodyHitThroughDamageFactor = 0x6c // float (Size: 0x4)
BulletDetailConfTableRow.BodyHitThroughProbability = 0x70 // float (Size: 0x4)
BulletDetailConfTableRow.PrimaryHitBones = 0x78 // FString (Size: 0x10)
BulletDetailConfTableRow.SecondaryHitBones = 0x88 // FString (Size: 0x10)
BulletDetailConfTableRow.MOA = 0x98 // float (Size: 0x4)
BulletDetailConfTableRow.MoaX = 0x9c // float (Size: 0x4)
BulletDetailConfTableRow.MoaY = 0xa0 // float (Size: 0x4)
BulletDetailConfTableRow.HorizontalRecoil = 0xa4 // float (Size: 0x4)
BulletDetailConfTableRow.VerticalRecoil = 0xa8 // float (Size: 0x4)
BulletDetailConfTableRow.ZeroDropDistance = 0xac // uint32_t (Size: 0x4)
BulletDetailConfTableRow.EnergyBreak = 0xb0 // float (Size: 0x4)
BulletDetailConfTableRow.ImpactForce = 0xb4 // float (Size: 0x4)
BusinessBaseInfoVec.Name = 0x0 // FText (Size: 0x18)
BusinessBaseInfoVec.Description = 0x18 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BusinessGrateDescribeConfTableRow.leveldescribe = 0x10 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.selltype = 0x28 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.selltypeicon = 0x40 // FString (Size: 0x10)
BusinessGrateDescribeConfTableRow.leveltextdes = 0x50 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.loyaltyonedata = 0x68 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.loyaltytwodata = 0x80 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.loyaltythreedata = 0x98 // FText (Size: 0x18)
BusinessGrateDescribeConfTableRow.loyaltyfourdata = 0xb0 // FText (Size: 0x18)
BusinessHeadConf.Path_2 = 0x0 // FString (Size: 0x10)
BusinessHeadConf.Path_3 = 0x10 // FString (Size: 0x10)
BusinessHeadConf.Path_4 = 0x20 // FString (Size: 0x10)
BusinessHeadConf.Path_5 = 0x30 // FString (Size: 0x10)
BusinessHeadConf.Path_6 = 0x40 // FString (Size: 0x10)
BusinessHeadConf.Path_7 = 0x50 // FString (Size: 0x10)
BusinessHeadConf.Path_8 = 0x60 // FString (Size: 0x10)
BusinessHeadConf.Path_9 = 0x70 // FString (Size: 0x10)
BusinessHeadConf.Path_10 = 0x80 // FString (Size: 0x10)
BusinessHeadConf.Path_11 = 0x90 // FString (Size: 0x10)
BusinessHeadConf.Path_12 = 0xa0 // FString (Size: 0x10)
BusinessHeadConf.Path_13 = 0xb0 // FString (Size: 0x10)
BusinessHeadConf.Path_14 = 0xc0 // FString (Size: 0x10)
BusinessHeadConf.Path_15 = 0xd0 // FString (Size: 0x10)
BusinessHeadConf.Path_16 = 0xe0 // FString (Size: 0x10)
BusinessHeadConf.Path_17 = 0xf0 // FString (Size: 0x10)
BusinessHeadConf.Path_18 = 0x100 // FString (Size: 0x10)
BusinessmanConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.businessman_type = 0xc // uint32_t (Size: 0x4)
BusinessmanConfTableRow.system_lock_id = 0x10 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.is_hide = 0x14 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.base_info_vec = 0x18 // TArray<FBusinessBaseInfoVec> (Size: 0x10)
BusinessmanConfTableRow.icon_path = 0x28 // FString (Size: 0x10)
BusinessmanConfTableRow.init_reputation = 0x38 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.init_total_sell = 0x3c // uint32_t (Size: 0x4)
BusinessmanConfTableRow.refresh_begin_time = 0x40 // FDateTime (Size: 0x8)
BusinessmanConfTableRow.refresh_period = 0x48 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.refresh_recover_money = 0x4c // uint32_t (Size: 0x4)
BusinessmanConfTableRow.act_unlock_level = 0x50 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.money_id = 0x54 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.total_money = 0x58 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.loyalty = 0x60 // TArray<uint32_t> (Size: 0x10)
BusinessmanConfTableRow.item_types = 0x70 // TArray<uint64_t> (Size: 0x10)
BusinessmanConfTableRow.point_key_unlock = 0x80 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.point_key_trade_unlock = 0x84 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.can_sell = 0x88 // uint32_t (Size: 0x4)
BusinessmanConfTableRow.can_buy = 0x8c // uint32_t (Size: 0x4)
BusinessmanConfTableRow.show_time_vec = 0x90 // TArray<FShowTimeConf> (Size: 0x10)
CGVoiceConfTableRow.cg_name = 0x8 // FString (Size: 0x10)
CGVoiceConfTableRow.voice_name = 0x18 // FString (Size: 0x10)
CalExtendConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CalExtendConfTableRow.Lower_Price = 0xc // uint32_t (Size: 0x4)
CalExtendConfTableRow.Upper_Price = 0x10 // uint32_t (Size: 0x4)
CalExtendConfTableRow.Lower_Extend = 0x14 // uint32_t (Size: 0x4)
CalExtendConfTableRow.Upper_Extend = 0x18 // uint32_t (Size: 0x4)
CaptureTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CaptureTableRow.X = 0xc // int32_t (Size: 0x4)
CaptureTableRow.Y = 0x10 // int32_t (Size: 0x4)
CaptureTableRow.Z = 0x14 // int32_t (Size: 0x4)
CaptureTableRow.LightGroupType = 0x18 // uint32_t (Size: 0x4)
CardConfTableRow.card_id = 0x8 // uint32_t (Size: 0x4)
CardConfTableRow.start_time = 0x10 // FDateTime (Size: 0x8)
CardConfTableRow.end_time = 0x18 // FDateTime (Size: 0x8)
CardConfTableRow.is_open = 0x20 // uint32_t (Size: 0x4)
CardConfTableRow.asset_id = 0x28 // FString (Size: 0x10)
CardConfTableRow.is_dynamic = 0x38 // uint32_t (Size: 0x4)
CardConfTableRow.jump_id = 0x3c // uint32_t (Size: 0x4)
CardConfTableRow.get_tip = 0x40 // FText (Size: 0x18)
CardConfTableRow.is_cannot_get = 0x58 // uint32_t (Size: 0x4)
CardConfTableRow.is_dynamic_logo = 0x5c // uint32_t (Size: 0x4)
CardConfTableRow.activity_info = 0x60 // FString (Size: 0x10)
CarvingShowConfTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
CarvingShowConfTableRow.MeleeName = 0x10 // FText (Size: 0x18)
CarvingShowConfTableRow.LevelName = 0x28 // FString (Size: 0x10)
CarvingShowConfTableRow.DressList = 0x38 // TArray<uint32_t> (Size: 0x10)
CarvingShowConfTableRow.Gender = 0x48 // uint32_t (Size: 0x4)
CarvingShowConfTableRow.status = 0x4c // uint32_t (Size: 0x4)
ChannelInfo.ID = 0x0 // uint32_t (Size: 0x4)
ChannelInfo.URL = 0x8 // FString (Size: 0x10)
ChatDialogBubbleConfTableRow.bubbleId = 0x8 // uint32_t (Size: 0x4)
ChatDialogBubbleConfTableRow.isListed = 0xc // uint32_t (Size: 0x4)
ChatDialogBubbleConfTableRow.getMethodDesc = 0x10 // FText (Size: 0x18)
ChatDialogBubbleConfTableRow.bubbleLevel = 0x28 // int32_t (Size: 0x4)
ChatDialogBubbleConfTableRow.start_time = 0x30 // FDateTime (Size: 0x8)
ChatDialogBubbleConfTableRow.end_time = 0x38 // FDateTime (Size: 0x8)
ChatShareLanguageTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ChatShareLanguageTableRow.LanguageKey = 0x10 // FString (Size: 0x10)
ChatShareLanguageTableRow.Languages = 0x20 // TArray<FString> (Size: 0x10)
CityConfTableRow.ADCode = 0x8 // uint32_t (Size: 0x4)
CityConfTableRow.ID = 0xc // uint32_t (Size: 0x4)
ClassBanner.begin_time = 0x0 // FDateTime (Size: 0x8)
ClassBanner.end_time = 0x8 // FDateTime (Size: 0x8)
ClassBanner.cdn = 0x10 // FString (Size: 0x10)
CollectRewardItems.item_id = 0x0 // uint32_t (Size: 0x4)
CollectRewardItems.Num = 0x4 // uint32_t (Size: 0x4)
CollectionNeedItem.item_id = 0x0 // uint32_t (Size: 0x4)
CollectionNeedItem.Num = 0x4 // uint32_t (Size: 0x4)
CollectsvrKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CollectsvrKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
CombatReadinessConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
CombatReadinessConfTableRow.recommend_list = 0x10 // TArray<uint32_t> (Size: 0x10)
CombatReadinessInitConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
CombatReadinessInitConfTableRow.Version = 0xc // uint32_t (Size: 0x4)
CombatReadinessInitConfTableRow.initializer_list = 0x10 // TArray<uint32_t> (Size: 0x10)
CombatReadinessInitConfTableRow.discard_list = 0x20 // TArray<uint32_t> (Size: 0x10)
CommercialSchemeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CommercialSchemeConfTableRow.SchemeConf = 0x10 // FString (Size: 0x10)
CommonAffixsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.FieldName = 0x10 // FString (Size: 0x10)
CommonAffixsConfTableRow.ShowIndex = 0x20 // int8_t (Size: 0x1)
CommonAffixsConfTableRow.AccesoryShowIndex = 0x21 // int8_t (Size: 0x1)
CommonAffixsConfTableRow.DisplayName = 0x28 // FText (Size: 0x18)
CommonAffixsConfTableRow.Algorithm = 0x40 // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.IsWeaponBase = 0x44 // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.AccesoryFormat = 0x48 // FString (Size: 0x10)
CommonAffixsConfTableRow.WeaponFormat = 0x58 // FString (Size: 0x10)
CommonAffixsConfTableRow.WeaponUnit = 0x68 // FText (Size: 0x18)
CommonAffixsConfTableRow.AccesoryUnit = 0x80 // FText (Size: 0x18)
CommonAffixsConfTableRow.Rato = 0x98 // float (Size: 0x4)
CommonAffixsConfTableRow.LessIsBetter = 0x9c // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.MaxValue = 0xa0 // int32_t (Size: 0x4)
CommonAffixsConfTableRow.displayType = 0xa4 // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.IsBaseAttr = 0xa8 // uint32_t (Size: 0x4)
CommonAffixsConfTableRow.AffixDiscription = 0xb0 // FText (Size: 0x18)
CommonItemConfItem.item_id = 0x0 // uint32_t (Size: 0x4)
CommonItemConfItem.Num = 0x4 // uint32_t (Size: 0x4)
CommonKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CommonKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
CommonKVConfTableRow.val_array = 0x18 // TArray<int64_t> (Size: 0x10)
CommonKVConfTableRow.Str = 0x28 // FText (Size: 0x18)
CompetitionAuthorityConfTableRow.GOpenID = 0x8 // uint64_t (Size: 0x8)
CompetitionAuthorityConfTableRow.authority = 0x10 // uint32_t (Size: 0x4)
CompetitionDefaultTeamNameConfTableRow.team_id = 0x8 // uint32_t (Size: 0x4)
CompetitionDefaultTeamNameConfTableRow.default_team_name = 0x10 // FText (Size: 0x18)
CompetitionDefaultTeamNameConfTableRow.team_color = 0x28 // FText (Size: 0x18)
CompetitionTeamFaction.team_id = 0x0 // uint32_t (Size: 0x4)
CompetitionTeamFaction.faction_index = 0x4 // uint32_t (Size: 0x4)
CompetitionTeamFactionConfTableRow.play_mode_id = 0x8 // uint32_t (Size: 0x4)
CompetitionTeamFactionConfTableRow.team_faction = 0x10 // TArray<FCompetitionTeamFaction> (Size: 0x10)
CompetitionTeamLogoConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CompetitionTeamLogoConfTableRow.logo_cdn = 0x10 // FString (Size: 0x10)
ConfGShopGood.item_id = 0x0 // uint32_t (Size: 0x4)
ConsumablesBuffConfTableRow.buff_id = 0x8 // uint32_t (Size: 0x4)
ConsumablesBuffConfTableRow.logic_id = 0x10 // FString (Size: 0x10)
ConsumablesBuffConfTableRow.Name = 0x20 // FText (Size: 0x18)
ConsumablesBuffConfTableRow.icon = 0x38 // FString (Size: 0x10)
ConsumablesBuffConfTableRow.delay_time = 0x48 // uint64_t (Size: 0x8)
ConsumablesBuffConfTableRow.total_time = 0x50 // uint64_t (Size: 0x8)
ConsumablesBuffConfTableRow.Value = 0x58 // uint64_t (Size: 0x8)
ConsumablesBuffConfTableRow.Describe = 0x60 // FText (Size: 0x18)
ConsumablesConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ConsumablesConfTableRow.Price = 0xc // uint32_t (Size: 0x4)
ConsumablesConfTableRow.RecommandSuppliesPackList = 0x10 // TArray<FRecommandSuppliesPack> (Size: 0x10)
ConsumablesDetailConfTableRow.consumables_id = 0x8 // uint32_t (Size: 0x4)
ConsumablesDetailConfTableRow.start_time = 0xc // uint32_t (Size: 0x4)
ConsumablesDetailConfTableRow.energy_value = 0x10 // uint32_t (Size: 0x4)
ConsumablesDetailConfTableRow.hydration_value = 0x14 // int32_t (Size: 0x4)
ConsumablesDetailConfTableRow.food_value = 0x18 // int32_t (Size: 0x4)
ConsumablesDetailConfTableRow.Treat_speed = 0x1c // float (Size: 0x4)
ConsumablesDetailConfTableRow.minus_healthupper_value = 0x20 // int32_t (Size: 0x4)
ConsumablesDetailConfTableRow.recover_health_value = 0x24 // int32_t (Size: 0x4)
ConsumablesDetailConfTableRow.energy_recover_desc = 0x28 // FText (Size: 0x18)
ConsumablesDetailConfTableRow.remove_all_parts_buff = 0x40 // uint32_t (Size: 0x4)
ConsumablesDetailConfTableRow.remove_status_vec = 0x48 // TArray<FConsumeRemoveStatusConf> (Size: 0x10)
ConsumablesDetailConfTableRow.buff_extend_desc = 0x58 // FText (Size: 0x18)
ConsumablesDetailConfTableRow.buff_vec = 0x70 // TArray<FConsumeBuffConf> (Size: 0x10)
ConsumablesUseAward.item_id = 0x0 // uint32_t (Size: 0x4)
ConsumablesUseAward.Num = 0x4 // uint32_t (Size: 0x4)
ConsumablesUseAward.prob = 0x8 // uint32_t (Size: 0x4)
ConsumablesUseAwardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ConsumablesUseAwardConfTableRow.awards = 0x10 // TArray<FConsumablesUseAward> (Size: 0x10)
ConsumeBuffConf.buff_id = 0x0 // uint32_t (Size: 0x4)
ConsumeBuffConf.is_buff = 0x4 // uint32_t (Size: 0x4)
ConsumeRemoveStatusConf.remove_id = 0x0 // uint32_t (Size: 0x4)
ConsumeRemoveStatusConf.durability_consume = 0x4 // uint32_t (Size: 0x4)
ContainerArmorConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ContainerArmorConfTableRow.Price = 0xc // uint32_t (Size: 0x4)
ContainerArmorConfTableRow.Vest = 0x10 // uint32_t (Size: 0x4)
ContainerArmorConfTableRow.Armor = 0x14 // uint32_t (Size: 0x4)
ContainerArmorConfTableRow.Backpack = 0x18 // uint32_t (Size: 0x4)
ContainerConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ContainerConfTableRow.rollup_size_x = 0xc // int32_t (Size: 0x4)
ContainerConfTableRow.rollup_size_y = 0x10 // int32_t (Size: 0x4)
ContainerConfTableRow.rollup_time = 0x14 // float (Size: 0x4)
ContainerConfTableRow.rule_id = 0x18 // uint32_t (Size: 0x4)
ContainerConfTableRow.open_sound = 0x20 // FString (Size: 0x10)
ContainerConfTableRow.close_sound = 0x30 // FString (Size: 0x10)
ContainerConfTableRow.sizes = 0x40 // TArray<FContainerSizeConfItem> (Size: 0x10)
ContainerConfTableRow.hide_renew = 0x50 // uint32_t (Size: 0x4)
ContainerRuleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ContainerRuleConfTableRow.need_roll_up = 0xc // uint32_t (Size: 0x4)
ContainerRuleConfTableRow.black_list = 0x10 // TArray<uint32_t> (Size: 0x10)
ContainerRuleConfTableRow.white_list = 0x20 // TArray<uint32_t> (Size: 0x10)
ContainerSizeConfItem.PosX = 0x0 // TArray<float> (Size: 0x10)
ContainerSizeConfItem.PosY = 0x10 // TArray<float> (Size: 0x10)
ContainerSizeConfItem.col = 0x20 // uint32_t (Size: 0x4)
ContainerSizeConfItem.Row = 0x24 // uint32_t (Size: 0x4)
ContestBattlePassLevelConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ContestBattlePassLevelConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
ContestBattlePassLevelConfTableRow.award = 0x10 // TArray<FContestBattlePassLevelItem> (Size: 0x10)
ContestBattlePassLevelConfTableRow.extra_award = 0x20 // TArray<FContestBattlePassLevelItem> (Size: 0x10)
ContestBattlePassLevelItem.item_id = 0x0 // uint32_t (Size: 0x4)
ContestBattlePassLevelItem.Num = 0x4 // uint32_t (Size: 0x4)
ContestBattlePassLevelItem.is_black = 0x8 // uint32_t (Size: 0x4)
ContestBattlePassLevelItem.is_faction = 0xc // uint32_t (Size: 0x4)
ContextMenuLevel1ConfTableRow.ID = 0x8 // uint16_t (Size: 0x2)
ContextMenuLevel1ConfTableRow.DisplayName = 0x10 // FText (Size: 0x18)
ContextMenuLevel1ConfTableRow.ShowIndex = 0x28 // uint8_t (Size: 0x1)
ContextMenuLevel1ConfTableRow.displayType = 0x29 // uint8_t (Size: 0x1)
ContextMenuLevel1ConfTableRow.ExecFunc = 0x30 // FString (Size: 0x10)
ContextMenuLevel1ConfTableRow.ItemTypes = 0x40 // TArray<uint64_t> (Size: 0x10)
ContextMenuLevel1ConfTableRow.ItemTypeMode = 0x50 // uint8_t (Size: 0x1)
ContextMenuLevel1ConfTableRow.PickTypeIds = 0x58 // TArray<uint16_t> (Size: 0x10)
ContextMenuLevel1ConfTableRow.isEquiped = 0x68 // uint8_t (Size: 0x1)
ContextMenuLevel1ConfTableRow.IsLendItem = 0x69 // uint8_t (Size: 0x1)
ContextMenuLevel1ConfTableRow.SysId = 0x6c // uint32_t (Size: 0x4)
ContextMenuLevel1ConfTableRow.IsHintMode = 0x70 // uint32_t (Size: 0x4)
ContextMenuLevel1ConfTableRow.IsInspect = 0x74 // uint32_t (Size: 0x4)
ContextMenuLevel1ConfTableRow.IsTraining = 0x78 // uint32_t (Size: 0x4)
ContextMenuLevel1ConfTableRow.IsDressEliteSuite = 0x7c // uint32_t (Size: 0x4)
ContextMenuLevel2ConfTableRow.ID = 0x8 // uint16_t (Size: 0x2)
ContextMenuLevel2ConfTableRow.DisplayName = 0x10 // FText (Size: 0x18)
ContextMenuLevel2ConfTableRow.ShowIndex = 0x28 // uint8_t (Size: 0x1)
ContextMenuLevel2ConfTableRow.displayType = 0x29 // uint8_t (Size: 0x1)
ContextMenuLevel2ConfTableRow.ExecFunc = 0x30 // FString (Size: 0x10)
ContextMenuLevel2ConfTableRow.ItemTypes = 0x40 // TArray<uint64_t> (Size: 0x10)
ContextMenuLevel2ConfTableRow.ItemTypeMode = 0x50 // uint8_t (Size: 0x1)
ContextMenuLevel2ConfTableRow.PickTypeIds = 0x58 // TArray<uint16_t> (Size: 0x10)
ContextMenuLevel2ConfTableRow.isEquiped = 0x68 // uint8_t (Size: 0x1)
ContextMenuLevel2ConfTableRow.IsLendItem = 0x69 // uint8_t (Size: 0x1)
ContextMenuLevel2ConfTableRow.SysId = 0x6c // uint32_t (Size: 0x4)
ContextMenuPickUpConfTableRow.ID = 0x8 // uint16_t (Size: 0x2)
ContextMenuPickUpConfTableRow.PanelType = 0x10 // FString (Size: 0x10)
ContextMenuPickUpConfTableRow.PickUpType = 0x20 // FString (Size: 0x10)
CosBucketConfTableRow.bucket_id = 0x8 // uint32_t (Size: 0x4)
CosBucketConfTableRow.bucket_name = 0x10 // FString (Size: 0x10)
CosBucketConfTableRow.day_upload_limit = 0x20 // uint32_t (Size: 0x4)
CosBucketConfTableRow.valid_days = 0x24 // uint32_t (Size: 0x4)
CountryConfTableRow.country_code = 0x8 // uint32_t (Size: 0x4)
CountryConfTableRow.country_name = 0x10 // FText (Size: 0x18)
CountryCurrencyExchangeConfTableRow.CountryCode = 0x8 // uint32_t (Size: 0x4)
CountryCurrencyExchangeConfTableRow.CurrencyName = 0x10 // FString (Size: 0x10)
CountryCurrencyExchangeConfTableRow.CurrencyCount = 0x20 // float (Size: 0x4)
CountryRankConfTableRow.country_code = 0x8 // uint32_t (Size: 0x4)
CountryRankConfTableRow.ID = 0xc // uint32_t (Size: 0x4)
CreateRoleAvatarConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
CreateRoleAvatarConfTableRow.avatar_sets = 0x10 // TArray<FAvatarSet> (Size: 0x10)
CreateRoleAvatarShowConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
CreateRoleAvatarShowConfTableRow.avatar_set = 0x10 // TArray<uint32_t> (Size: 0x10)
CreateRoleAvatarShowConfTableRow.avatar_set_female = 0x20 // TArray<uint32_t> (Size: 0x10)
CreditBehaviorDescConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CreditBehaviorDescConfTableRow.isPositive = 0xc // uint32_t (Size: 0x4)
CreditBehaviorDescConfTableRow.desc = 0x10 // FText (Size: 0x18)
CreditEventConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CreditEventConfTableRow.reason = 0x10 // FText (Size: 0x18)
CreditEventConfTableRow.event_type = 0x28 // int32_t (Size: 0x4)
CreditEventConfTableRow.credit_change = 0x2c // uint32_t (Size: 0x4)
CreditEventConfTableRow.max_count = 0x30 // uint32_t (Size: 0x4)
CreditLevelConfTableRow.credit_upperbound = 0x8 // uint32_t (Size: 0x4)
CreditLevelConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
CreditLevelConfTableRow.daily_attainable_credit = 0x10 // uint32_t (Size: 0x4)
CreditLevelConfTableRow.deduct_coeff_percent = 0x14 // uint32_t (Size: 0x4)
CreditLevelConfTableRow.panelty = 0x18 // TArray<uint32_t> (Size: 0x10)
CreditLevelConfTableRow.reward = 0x28 // uint32_t (Size: 0x4)
CreditLevelConfTableRow.desc = 0x30 // FText (Size: 0x18)
CreditPaneltyConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CreditPaneltyConfTableRow.Description = 0x10 // FString (Size: 0x10)
CrossOverAwardsConfTableRow.award_id = 0x8 // uint32_t (Size: 0x4)
CrossOverAwardsConfTableRow.season_id = 0xc // uint32_t (Size: 0x4)
CrossOverAwardsConfTableRow.task_num = 0x10 // uint32_t (Size: 0x4)
CrossOverAwardsConfTableRow.rewardgroup_name = 0x18 // FText (Size: 0x18)
CrossOverAwardsConfTableRow.rewardgroup_picture = 0x30 // TArray<uint32_t> (Size: 0x10)
CrossOverAwardsConfTableRow.is_down = 0x40 // uint32_t (Size: 0x4)
CrossOverAwardsConfTableRow.awards = 0x48 // TArray<FAwardItemConf> (Size: 0x10)
CurrencyExchangeConfTableRow.CurrencyName = 0x8 // FString (Size: 0x10)
CurrencyExchangeConfTableRow.CurrencyCount = 0x18 // float (Size: 0x4)
CustomizedExchangeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.businessman_id = 0xc // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.Seq = 0x10 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.buy_limit = 0x14 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.is_hide = 0x18 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.sell_item_id = 0x1c // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.sell_num = 0x20 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.is_faction = 0x24 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.exchange_item_vec = 0x28 // TArray<FCustomizedExchangeItemConf> (Size: 0x10)
CustomizedExchangeConfTableRow.loyalty_level = 0x38 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.min_level = 0x3c // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.max_level = 0x40 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.min_player_wealth = 0x44 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.max_player_wealth = 0x48 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.min_escape_percent = 0x4c // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.max_escape_percent = 0x50 // uint32_t (Size: 0x4)
CustomizedExchangeConfTableRow.Weight = 0x54 // uint32_t (Size: 0x4)
CustomizedExchangeItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
CustomizedExchangeItemConf.Num = 0x4 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.businessman_id = 0xc // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.loyalty_level = 0x10 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.Level = 0x14 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.Num = 0x18 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.refresh_number = 0x1c // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.refresh_period = 0x20 // uint32_t (Size: 0x4)
CustomizedExchangeRuleConfTableRow.daily_reset_time = 0x28 // FString (Size: 0x10)
DMGLimitConfTableRow.RowNum = 0x8 // int32_t (Size: 0x4)
DMGLimitConfTableRow.ItemId = 0x10 // uint64_t (Size: 0x8)
DMGLimitConfTableRow.HitGroup = 0x18 // uint32_t (Size: 0x4)
DMGLimitConfTableRow.HealthThreshold = 0x1c // float (Size: 0x4)
DMGLimitConfTableRow.ReduceFactor = 0x20 // float (Size: 0x4)
DMGLimitMapidConfTableRow.mapIDPrefix = 0x8 // uint32_t (Size: 0x4)
DMGLimitMapidConfTableRow.mapIDFactor = 0xc // float (Size: 0x4)
DailyTimeConf.daily_begin_time = 0x0 // FText (Size: 0x18)
DailyTimeConf.daily_end_time = 0x18 // FText (Size: 0x18)
DataPathTableRow.PathID = 0x8 // uint32_t (Size: 0x4)
DataPathTableRow.PathName = 0x10 // FString (Size: 0x10)
DeathDropReplaceATableRow.item_id = 0x8 // uint32_t (Size: 0x4)
DeathDropReplaceATableRow.pool_id = 0xc // uint32_t (Size: 0x4)
DeathDropReplaceATableRow.Weight = 0x10 // uint32_t (Size: 0x4)
DeathDropReplaceATableRow.special_replace_item_id = 0x14 // uint32_t (Size: 0x4)
DeathDropReplaceATableRow.replace_count = 0x18 // uint32_t (Size: 0x4)
DeathDropReplaceBTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
DeathDropReplaceBTableRow.death_drop_replace_pool_infos = 0x10 // TArray<FDeathDropReplacePoolInfo> (Size: 0x10)
DeathDropReplacePoolInfo.pool_id = 0x0 // uint32_t (Size: 0x4)
DeathDropReplacePoolInfo.Weight = 0x4 // uint32_t (Size: 0x4)
DeathDropReplacePoolTableRow.pool_id = 0x8 // uint32_t (Size: 0x4)
DeathDropReplacePoolTableRow.item_ids = 0x10 // TArray<uint32_t> (Size: 0x10)
DecorateSceneConf.scene_index = 0x0 // uint32_t (Size: 0x4)
DecorateSceneConf.scene_name = 0x8 // FText (Size: 0x18)
DecorateSceneConf.Slots = 0x20 // TArray<uint32_t> (Size: 0x10)
DescribeArg.arg = 0x0 // FString (Size: 0x10)
DescribeArg.ResolveMethod = 0x10 // uint32_t (Size: 0x4)
DescribeArg.LocalizationKey = 0x18 // FString (Size: 0x10)
DispelExpTableRow.ID = 0x8 // int32_t (Size: 0x4)
DispelExpTableRow.part_id = 0xc // int32_t (Size: 0x4)
DispelExpTableRow.dispel_exp = 0x10 // int32_t (Size: 0x4)
DropNonAvatarItemConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
DropNonAvatarItemConfTableRow.Rarity = 0xc // uint32_t (Size: 0x4)
DropPicShowConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
DropPicShowConfTableRow.pic_path = 0x10 // FString (Size: 0x10)
DurabilityChangeTableRow.ID = 0x8 // uint32_t (Size: 0x4)
DurabilityChangeTableRow.Version = 0xc // uint32_t (Size: 0x4)
DurabilityPriceConf.armor_level = 0x0 // uint32_t (Size: 0x4)
DurabilityPriceConf.durability_price = 0x4 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.gacha_id = 0x8 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.ticket_id = 0x10 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.mall_item_id = 0x14 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.step_price_id = 0x18 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.single_drop_price = 0x1c // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.conseutive_drop_number = 0x20 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.consecutive_drop_price = 0x24 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.consecutive_discount_price = 0x28 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.max_count = 0x2c // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.first_hit_pool_id = 0x30 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.first_hit_floor = 0x34 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.first_hit_cell = 0x38 // uint32_t (Size: 0x4)
DynamicLotteryConfTableRow.lottery_pool_conf = 0x40 // TArray<FLotteryPoolGuaranteeConf> (Size: 0x10)
DynamicLotteryConfTableRow.reward_show_type = 0x50 // uint32_t (Size: 0x4)
EliminationExpTableRow.ID = 0x8 // int32_t (Size: 0x4)
EliminationExpTableRow.Level = 0xc // int32_t (Size: 0x4)
EliminationExpTableRow.Exp = 0x10 // int32_t (Size: 0x4)
EliteEnterCostVec.item_id = 0x0 // uint32_t (Size: 0x4)
EliteEnterCostVec.cost_num = 0x4 // uint32_t (Size: 0x4)
EliteRefreshCostVec.item_id = 0x0 // uint32_t (Size: 0x4)
EliteRefreshCostVec.cost_num = 0x4 // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.page_id = 0xc // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.page_name = 0x10 // FText (Size: 0x18)
EliteSuiteConfTableRow.page_icon = 0x28 // FText (Size: 0x18)
EliteSuiteConfTableRow.index_id = 0x40 // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.set_name = 0x48 // FText (Size: 0x18)
EliteSuiteConfTableRow.enter_cost_vec = 0x60 // TArray<FEliteEnterCostVec> (Size: 0x10)
EliteSuiteConfTableRow.refresh_group_id = 0x70 // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.set_value = 0x74 // uint32_t (Size: 0x4)
EliteSuiteConfTableRow.refresh_cost_vec = 0x78 // TArray<FEliteRefreshCostVec> (Size: 0x10)
EquipAvatarSetCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EquipAvatarSetCfgTableRow.avatar_set = 0x10 // TArray<uint32_t> (Size: 0x10)
EquipAvatarSetCfgTableRow.combined_id = 0x20 // uint32_t (Size: 0x4)
EquipReturnCardConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
EquipReturnCardConfTableRow.item_value = 0xc // uint32_t (Size: 0x4)
EquipReturnCardConfTableRow.icon_path = 0x10 // FString (Size: 0x10)
EquipSlotConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EquipSlotConfTableRow.MatchEquipType = 0x10 // TArray<uint32_t> (Size: 0x10)
EquipSlotConfTableRow.ShowIndex = 0x20 // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.is_recommand = 0xc // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.is_close = 0x10 // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.game_mode_type = 0x14 // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.column_index = 0x18 // uint32_t (Size: 0x4)
EquipTemplateConfTableRow.custom_rule = 0x20 // FText (Size: 0x18)
EquipTemplateConfTableRow.equip_template_list = 0x38 // TArray<FEquipTemplateInfo> (Size: 0x10)
EquipTemplateInfo.item_id = 0x0 // uint32_t (Size: 0x4)
EquipTemplateInfo.Num = 0x4 // uint32_t (Size: 0x4)
EquipTemplateInfo.parent_id = 0x8 // uint64_t (Size: 0x8)
EquipTemplateInfo.ID = 0x10 // uint64_t (Size: 0x8)
EquipmentSkinConfTableRow.SkinID = 0x8 // uint32_t (Size: 0x4)
EquipmentSkinConfTableRow.ItemId = 0xc // uint32_t (Size: 0x4)
EquipmentSkinConfTableRow.IsStaticMesh = 0x10 // bool (Size: 0x1)
EquipmentSkinConfTableRow.IsSwitchSexuality = 0x11 // bool (Size: 0x1)
EquipmentSkinConfTableRow.MeshPathGame = 0x18 // FSoftObjectPath (Size: 0x18)
EquipmentSkinConfTableRow.MeshPathLobby = 0x30 // FSoftObjectPath (Size: 0x18)
EquipmentSkinConfTableRow.OverrideMaterialsGame = 0x48 // TArray<FSkinMaterialInfo> (Size: 0x10)
EquipmentSkinConfTableRow.OverrideMaterialsLobby = 0x58 // TArray<FSkinMaterialInfo> (Size: 0x10)
EquipmentSkinConfTableRow.MeshPathGame_Female = 0x68 // FSoftObjectPath (Size: 0x18)
EquipmentSkinConfTableRow.MeshPathLobby_Female = 0x80 // FSoftObjectPath (Size: 0x18)
ErrorCodeTableRow.ErrorCode = 0x8 // int32_t (Size: 0x4)
ErrorCodeTableRow.Describe = 0x10 // FText (Size: 0x18)
ErrorCodeTableRow.ShowType = 0x28 // int8_t (Size: 0x1)
EvaluationCommConfTableRow.conf_type = 0x8 // uint32_t (Size: 0x4)
EvaluationCommConfTableRow.event_id = 0x10 // int64_t (Size: 0x8)
EvaluationCommConfTableRow.Val = 0x18 // int64_t (Size: 0x8)
EvaluationCommConfTableRow.Score = 0x20 // int64_t (Size: 0x8)
EvaluationConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EvaluationConfTableRow.show_name = 0x10 // FText (Size: 0x18)
EvaluationConfTableRow.emotion_type = 0x28 // uint32_t (Size: 0x4)
EvaluationConfTableRow.basic_weight = 0x30 // int64_t (Size: 0x8)
EvaluationConfTableRow.event_id_array = 0x38 // TArray<int64_t> (Size: 0x10)
EvaluationConfTableRow.event_weight_array = 0x48 // TArray<int64_t> (Size: 0x10)
EvaluationConfTableRow.is_show = 0x58 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.ID = 0x8 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.ActivityID = 0xc // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.Priority = 0x10 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.SourceCategory = 0x14 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.SourceCareer = 0x18 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.SourceTendency = 0x1c // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.SourceDifficulty = 0x20 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.TargetCategory = 0x24 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.TargetCareer = 0x28 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.TargetTendency = 0x2c // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.TargetDifficulty = 0x30 // uint32_t (Size: 0x4)
EventAIIDModifierDataTableTableRow.TargetEquipPoolID = 0x34 // uint32_t (Size: 0x4)
ExchangeEffect.item_id = 0x0 // uint32_t (Size: 0x4)
ExchangeEffect.Num = 0x4 // uint32_t (Size: 0x4)
ExchangeEffect.change_item_id = 0x8 // uint32_t (Size: 0x4)
ExchangeEffect.change_num = 0xc // uint32_t (Size: 0x4)
ExchangeItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
ExchangeItemConf.Num = 0x4 // uint32_t (Size: 0x4)
ExchangeRarityConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ExchangeRarityConfTableRow.Rarity = 0xc // uint32_t (Size: 0x4)
ExpConstantTableRow.ID = 0x8 // FString (Size: 0x10)
ExpConstantTableRow.Val = 0x18 // int64_t (Size: 0x8)
ExpConstantTableRow.ary = 0x20 // TArray<int32_t> (Size: 0x10)
ExpConstantTableRow.Str = 0x30 // FString (Size: 0x10)
ExtEquipConf.ID = 0x0 // uint32_t (Size: 0x4)
ExtEquipConf.Type = 0x4 // uint32_t (Size: 0x4)
ExtEquipConf.Num = 0x8 // uint32_t (Size: 0x4)
ExtraInfoItemTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
ExtraInfoItemTableRow.Level = 0xc // uint32_t (Size: 0x4)
ExtraInfoItemTableRow.Exp = 0x10 // uint32_t (Size: 0x4)
ExtraSkinConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ExtraSkinConfTableRow.BaseItemID = 0xc // uint32_t (Size: 0x4)
ExtraSkinConfTableRow.AssembleItemID = 0x10 // uint32_t (Size: 0x4)
ExtraSkinConfTableRow.ActionType = 0x14 // uint32_t (Size: 0x4)
ExtraSkinConfTableRow.MeshPathGame = 0x18 // FSoftObjectPath (Size: 0x18)
ExtraSkinConfTableRow.MeshPathLobby = 0x30 // FSoftObjectPath (Size: 0x18)
ExtraSkinConfTableRow.AnimBPPath = 0x48 // FSoftClassPath (Size: 0x18)
ExtraSkinConfTableRow.BoneHiddenPairs = 0x60 // TArray<FName> (Size: 0x10)
ExtraSkinConfTableRow.BlackSocketList = 0x70 // TArray<FBlackSocketInfo> (Size: 0x10)
FactionChoiceConfTableRow.choice_id = 0x8 // uint32_t (Size: 0x4)
FactionChoiceConfTableRow.season_id = 0xc // uint32_t (Size: 0x4)
FactionChoiceConfTableRow.pre_task_ids = 0x10 // TArray<FPreTaskId> (Size: 0x10)
FactionChoiceConfTableRow.faction_choice_items = 0x20 // TArray<FactionChoiceItem> (Size: 0x10)
FactionConfTableRow.faction_id = 0x8 // uint32_t (Size: 0x4)
FactionConfTableRow.avatar_set_id = 0xc // uint32_t (Size: 0x4)
FactionConfTableRow.faction_currency = 0x10 // uint64_t (Size: 0x8)
FactionConfTableRow.faction_npc_pic = 0x18 // FString (Size: 0x10)
FactionConfTableRow.faction_bg_pic = 0x28 // FString (Size: 0x10)
FactionConfTableRow.faction_name = 0x38 // FString (Size: 0x10)
FactionConfTableRow.faction_name_3 = 0x48 // FString (Size: 0x10)
FactionConfTableRow.faction_logo_select = 0x58 // FString (Size: 0x10)
FactionConfTableRow.faction_logo_teamup = 0x68 // FString (Size: 0x10)
FactionConfTableRow.faction_logo_teaminfo = 0x78 // FString (Size: 0x10)
FactionSelectConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
FactionSelectConfTableRow.map_mode_id = 0xc // uint32_t (Size: 0x4)
FactionSelectConfTableRow.index_id = 0x10 // uint32_t (Size: 0x4)
FactionSelectConfTableRow.faction_id = 0x14 // uint32_t (Size: 0x4)
FactionalItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
FactionalItemConfTableRow.Is_Factional_Item = 0xc // uint32_t (Size: 0x4)
FightTaskConfRewardTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
FightTaskConfRewardTableRow.playmoderewards = 0x10 // TArray<FPlayModeRewardConf> (Size: 0x10)
FriInviteCodeRewardTableRow.ID = 0x8 // uint32_t (Size: 0x4)
FriInviteCodeRewardTableRow.reward_list = 0x10 // TArray<FInviteRewardListConf> (Size: 0x10)
FriRecommConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
FriRecommConfTableRow.show_interact = 0xc // uint32_t (Size: 0x4)
FriRecommConfTableRow.show_pop_up = 0x10 // uint32_t (Size: 0x4)
FriRecommConfTableRow.Val = 0x14 // uint32_t (Size: 0x4)
FriRecommConfTableRow.Weight = 0x18 // uint32_t (Size: 0x4)
FriRecommConfTableRow.reason = 0x20 // FText (Size: 0x18)
FriRecommConfTableRow.friendPanelDisplay = 0x38 // FText (Size: 0x18)
FriRecommConfTableRow.battleReulstDisplay = 0x50 // FText (Size: 0x18)
FriRecommConfTableRow.battleResultDesc = 0x68 // FText (Size: 0x18)
FriRecommConfTableRow.battleResultDesc_paramTypes = 0x80 // TArray<uint32_t> (Size: 0x10)
FriRecommTagsTableRow.recom_id = 0x8 // uint32_t (Size: 0x4)
FriRecommTagsTableRow.tag_type = 0xc // uint32_t (Size: 0x4)
FriRecommTagsTableRow.tag_id = 0x10 // uint32_t (Size: 0x4)
FriRecommTagsTableRow.Weight = 0x14 // int32_t (Size: 0x4)
FriRecommTagsTableRow.Active = 0x18 // uint32_t (Size: 0x4)
FriRecommTagsTableRow.tag_name = 0x20 // FText (Size: 0x18)
FriRecommTagsTableRow.need_check = 0x38 // uint32_t (Size: 0x4)
FriRecommTagsTableRow.tag_tip = 0x40 // FText (Size: 0x18)
FunctionControlCfgTableRow.sys_id = 0x8 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.sys_type = 0xc // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.sys_param = 0x10 // FString (Size: 0x10)
FunctionControlCfgTableRow.is_backend = 0x20 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.active_platforms = 0x28 // TArray<uint32_t> (Size: 0x10)
FunctionControlCfgTableRow.Channel = 0x38 // FString (Size: 0x10)
FunctionControlCfgTableRow.ios_testfight_hide = 0x48 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.ios_audit_hide = 0x4c // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.android_exp_hide = 0x50 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.android_client_version = 0x58 // FString (Size: 0x10)
FunctionControlCfgTableRow.ios_client_version = 0x68 // FString (Size: 0x10)
FunctionControlCfgTableRow.season_level = 0x78 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.battle_pmc = 0x7c // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.Condition = 0x80 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.open_pmc_level = 0x84 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.history_max_level = 0x88 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.open_mission_id = 0x8c // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.open_bussiness_level = 0x90 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.open_date = 0x98 // FDateTime (Size: 0x8)
FunctionControlCfgTableRow.cloe_date = 0xa0 // FDateTime (Size: 0x8)
FunctionControlCfgTableRow.pre_sys = 0xa8 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.Tips = 0xb0 // FText (Size: 0x18)
FunctionControlCfgTableRow.btn_tips = 0xc8 // FText (Size: 0x18)
FunctionControlCfgTableRow.is_close = 0xe0 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.lockstate = 0xe4 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.country_group_id = 0xe8 // uint32_t (Size: 0x4)
FunctionControlCfgTableRow.regist_country_group_id = 0xec // uint32_t (Size: 0x4)
GShopOnshelfTime.start_time = 0x0 // FDateTime (Size: 0x8)
GShopOnshelfTime.end_time = 0x8 // FDateTime (Size: 0x8)
GachaClientConfTableRow.gacha_level = 0x8 // FString (Size: 0x10)
GachaClientConfTableRow.seq_audio = 0x18 // FString (Size: 0x10)
GachaClientConfTableRow.bgm = 0x28 // FString (Size: 0x10)
GachaClientConfTableRow.special_pick_sound_items = 0x38 // TArray<uint32_t> (Size: 0x10)
GachaClientConfTableRow.special_pick_sound_item_events = 0x48 // TArray<FString> (Size: 0x10)
GachaClientConfTableRow.open_laser = 0x58 // uint32_t (Size: 0x4)
GachaClientConfTableRow.montage_list = 0x60 // TArray<FString> (Size: 0x10)
GachaClientConfTableRow.sexuality_list = 0x70 // TArray<uint32_t> (Size: 0x10)
GachaClientConfTableRow.hood_status_list = 0x80 // TArray<uint32_t> (Size: 0x10)
GachaClientConfTableRow.inventory_list = 0x90 // TArray<FInvList> (Size: 0x10)
GachaClientConfTableRow.special_pick_montage = 0xa0 // TArray<FGachaSpecialPickMontageConf> (Size: 0x10)
GachaClientConfTableRow.special_pick_between_montage = 0xb0 // TArray<FGachaSpecialBetweenMontageConf> (Size: 0x10)
GachaClientConfTableRow.special_change_montage = 0xc0 // TArray<FGachaSpecialChangeMontageConf> (Size: 0x10)
GachaSpecialBetweenMontageConf.Key = 0x0 // FString (Size: 0x10)
GachaSpecialBetweenMontageConf.avatar_index = 0x10 // uint32_t (Size: 0x4)
GachaSpecialBetweenMontageConf.Montage = 0x18 // FString (Size: 0x10)
GachaSpecialChangeMontageConf.gacha_index = 0x0 // uint32_t (Size: 0x4)
GachaSpecialChangeMontageConf.avatar_index = 0x4 // uint32_t (Size: 0x4)
GachaSpecialChangeMontageConf.Montage = 0x8 // FString (Size: 0x10)
GachaSpecialPickMontageConf.item_id = 0x0 // uint32_t (Size: 0x4)
GachaSpecialPickMontageConf.avatar_index = 0x4 // uint32_t (Size: 0x4)
GachaSpecialPickMontageConf.Montage = 0x8 // FString (Size: 0x10)
GalleryAvatarPostureConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryAvatarPostureConfTableRow.posture_key = 0x10 // FString (Size: 0x10)
GalleryBuffConfTableRow.buff_id = 0x8 // uint32_t (Size: 0x4)
GalleryBuffConfTableRow.buff_type = 0xc // uint32_t (Size: 0x4)
GalleryBuffConfTableRow.Param1 = 0x10 // uint32_t (Size: 0x4)
GalleryCharacterConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryCharacterConfTableRow.Name = 0x10 // FText (Size: 0x18)
GalleryCharacterConfTableRow.avatar_set_id = 0x28 // uint32_t (Size: 0x4)
GalleryCharacterConfTableRow.forbid_types = 0x30 // TArray<uint32_t> (Size: 0x10)
GalleryCharacterConfTableRow.topics = 0x40 // TArray<uint32_t> (Size: 0x10)
GalleryCharacterConfTableRow.topics_weight = 0x50 // TArray<uint32_t> (Size: 0x10)
GalleryCharacterDialogConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryCharacterDialogConfTableRow.character_id = 0xc // uint32_t (Size: 0x4)
GalleryCharacterDialogConfTableRow.Anim = 0x10 // FText (Size: 0x18)
GalleryCharacterDialogConfTableRow.Sound = 0x28 // FText (Size: 0x18)
GalleryCharacterDialogConfTableRow.Content = 0x40 // FText (Size: 0x18)
GalleryCharacterDialogConfTableRow.Enable_LookAt = 0x58 // uint32_t (Size: 0x4)
GalleryCharacterDialogConfTableRow.lookat_blend_speed = 0x5c // float (Size: 0x4)
GalleryCharacterDialogConfTableRow.Command = 0x60 // uint32_t (Size: 0x4)
GalleryCharacterDialogConfTableRow.Param = 0x68 // TArray<uint32_t> (Size: 0x10)
GalleryCharacterPoseConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryCharacterPoseConfTableRow.character_id = 0xc // uint32_t (Size: 0x4)
GalleryCharacterPoseConfTableRow.pos_id = 0x10 // uint32_t (Size: 0x4)
GalleryCharacterPoseConfTableRow.idle_pose_key = 0x18 // FString (Size: 0x10)
GalleryCharacterPoseConfTableRow.dialog_in_pose_key = 0x28 // FString (Size: 0x10)
GalleryCharacterPoseConfTableRow.dialog_out_pose_key = 0x38 // FString (Size: 0x10)
GalleryCharacterPoseConfTableRow.dialog_camera_tag = 0x48 // FString (Size: 0x10)
GalleryCollectRewardConfTableRow.collect_reward_id = 0x8 // uint32_t (Size: 0x4)
GalleryCollectRewardConfTableRow.ID = 0xc // uint32_t (Size: 0x4)
GalleryCollectRewardConfTableRow.reward_level = 0x10 // uint32_t (Size: 0x4)
GalleryCollectRewardConfTableRow.collect_target_num = 0x14 // uint32_t (Size: 0x4)
GalleryCollectRewardConfTableRow.reward_items = 0x18 // TArray<FCollectRewardItems> (Size: 0x10)
GalleryCollectionExchangeConfTableRow.collection_id = 0x8 // uint32_t (Size: 0x4)
GalleryCollectionExchangeConfTableRow.abs_begin_time = 0x10 // FDateTime (Size: 0x8)
GalleryCollectionExchangeConfTableRow.abs_end_time = 0x18 // FDateTime (Size: 0x8)
GalleryCollectionExchangeConfTableRow.exchange_items = 0x20 // TArray<FexchangeItem> (Size: 0x10)
GalleryCollectionTaskConfTableRow.collection_id = 0x8 // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.display_order = 0xc // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.prev_level_id = 0x10 // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.sub_type = 0x14 // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.jump_id = 0x18 // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.abs_begin_time = 0x20 // FDateTime (Size: 0x8)
GalleryCollectionTaskConfTableRow.abs_end_time = 0x28 // FDateTime (Size: 0x8)
GalleryCollectionTaskConfTableRow.target_type = 0x30 // uint32_t (Size: 0x4)
GalleryCollectionTaskConfTableRow.need_items = 0x38 // TArray<FCollectionNeedItem> (Size: 0x10)
GalleryDecorateConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryDecorateConfTableRow.display_order = 0xc // uint32_t (Size: 0x4)
GalleryDecorateConfTableRow.abs_begin_time = 0x10 // FDateTime (Size: 0x8)
GalleryDecorateConfTableRow.abs_end_time = 0x18 // FDateTime (Size: 0x8)
GalleryDecorateConfTableRow.sub_redpoint_id = 0x20 // uint32_t (Size: 0x4)
GalleryDecorateConfTableRow.jump_id = 0x24 // uint32_t (Size: 0x4)
GalleryDecorateConfTableRow.target_type = 0x28 // uint32_t (Size: 0x4)
GalleryDecorateConfTableRow.need_items = 0x30 // TArray<FCommonItemConfItem> (Size: 0x10)
GalleryDecorateSlotConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryDecorateSlotConfTableRow.whitelist_item_type = 0xc // uint32_t (Size: 0x4)
GalleryDecorateSlotConfTableRow.default_item = 0x10 // uint32_t (Size: 0x4)
GalleryDecorateTabConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryDecorateTabConfTableRow.Name = 0x10 // FText (Size: 0x18)
GalleryDecorateTabConfTableRow.Type = 0x28 // uint32_t (Size: 0x4)
GalleryDecorateTabConfTableRow.is_base_decorate = 0x2c // bool (Size: 0x1)
GalleryDecorateTabConfTableRow.scene_list = 0x30 // TArray<FDecorateSceneConf> (Size: 0x10)
GalleryDogtagBoxConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryDogtagBoxConfTableRow.dogtag_num = 0xc // uint32_t (Size: 0x4)
GalleryDogtagBoxConfTableRow.bp_path = 0x10 // FSoftObjectPath (Size: 0x18)
GalleryDogtagBoxConfTableRow.guide_img_path = 0x28 // FSoftObjectPath (Size: 0x18)
GalleryFurnitureConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.display_order = 0x10 // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.max_child_num = 0x14 // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.start_lv = 0x18 // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.unlock_lv = 0x1c // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.Tag = 0x20 // FString (Size: 0x10)
GalleryFurnitureConfTableRow.unlock_redpoint_id = 0x30 // uint32_t (Size: 0x4)
GalleryFurnitureConfTableRow.virtual_furniture = 0x34 // bool (Size: 0x1)
GalleryFurnitureConfTableRow.Name = 0x38 // FText (Size: 0x18)
GalleryFurnitureConfTableRow.desc = 0x50 // FText (Size: 0x18)
GalleryFurnitureConfTableRow.unlock_preview_tip = 0x68 // FText (Size: 0x18)
GalleryFurnitureConfTableRow.unlock_tip = 0x80 // FText (Size: 0x18)
GalleryFurnitureConfTableRow.icon = 0x98 // FString (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.Index = 0x8 // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.ID = 0xc // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.Level = 0x10 // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.max_child_num = 0x14 // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.buff_list = 0x18 // TArray<uint32_t> (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.upgrade_targets = 0x28 // TArray<uint32_t> (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.cost_cash = 0x38 // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.cost_timestamp = 0x3c // uint32_t (Size: 0x4)
GalleryFurnitureUpgradeConfTableRow.cost_items = 0x40 // TArray<FUpgradeCostItems> (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.scene_display_list = 0x50 // TArray<uint32_t> (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.scene_names = 0x60 // TArray<FText> (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.bg_image_path = 0x70 // FString (Size: 0x10)
GalleryFurnitureUpgradeConfTableRow.background_path = 0x80 // FString (Size: 0x10)
GalleryGlobalConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryGlobalConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
GalleryGlobalConfTableRow.val_list = 0x18 // TArray<uint32_t> (Size: 0x10)
GalleryGlobalConfTableRow.str_val_list = 0x28 // TArray<FText> (Size: 0x10)
GalleryMedalTaskConfTableRow.medal_id = 0x8 // uint32_t (Size: 0x4)
GalleryMedalTaskConfTableRow.needitem = 0x10 // TArray<FNeedItemRef> (Size: 0x10)
GalleryMedalTaskConfTableRow.Season = 0x20 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.music_id = 0x8 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.has_vinyl = 0xc // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.vinyl_id = 0x10 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.display_order = 0x14 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.is_loop_audio = 0x18 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.event_duration = 0x1c // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.abs_begin_time = 0x20 // FDateTime (Size: 0x8)
GalleryMusicCollectionConfTableRow.abs_end_time = 0x28 // FDateTime (Size: 0x8)
GalleryMusicCollectionConfTableRow.lock_desc = 0x30 // FText (Size: 0x18)
GalleryMusicCollectionConfTableRow.audio_event = 0x48 // FString (Size: 0x10)
GalleryMusicCollectionConfTableRow.music_icon_path = 0x58 // FString (Size: 0x10)
GalleryMusicCollectionConfTableRow.music_cd_icon_path = 0x68 // FString (Size: 0x10)
GalleryMusicCollectionConfTableRow.tag_tips = 0x78 // FText (Size: 0x18)
GalleryMusicCollectionConfTableRow.music_tag = 0x90 // FText (Size: 0x18)
GalleryMusicCollectionConfTableRow.jump_id = 0xa8 // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.target_type = 0xac // uint32_t (Size: 0x4)
GalleryMusicCollectionConfTableRow.need_items = 0xb0 // TArray<FCommonItemConfItem> (Size: 0x10)
GalleryPositionConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryPositionConfTableRow.pos_tag = 0x10 // FString (Size: 0x10)
GalleryPositionConfTableRow.Weight = 0x20 // uint32_t (Size: 0x4)
GalleryShowWeaponConfTableRow.weapon_id = 0x8 // uint32_t (Size: 0x4)
GalleryShowWeaponConfTableRow.kill_num = 0xc // uint32_t (Size: 0x4)
GalleryShowWeaponConfTableRow.kill_num_list = 0x10 // TArray<uint32_t> (Size: 0x10)
GalleryShowWeaponConfTableRow.need_ruble = 0x20 // uint32_t (Size: 0x4)
GalleryShowWeaponConfTableRow.abs_begin_time = 0x28 // FDateTime (Size: 0x8)
GalleryShowWeaponConfTableRow.abs_end_time = 0x30 // FDateTime (Size: 0x8)
GalleryShowWeaponConfTableRow.assemble_id = 0x38 // uint32_t (Size: 0x4)
GalleryTopicConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryTopicConfTableRow.topic = 0xc // uint32_t (Size: 0x4)
GalleryTopicConfTableRow.Content = 0x10 // FText (Size: 0x18)
GalleryTopicConfTableRow.reward = 0x28 // TArray<FCommonItemConfItem> (Size: 0x10)
GalleryTreasuryCameraConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryTreasuryCameraConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
GalleryTreasuryCameraConfTableRow.show_items = 0x10 // TArray<uint32_t> (Size: 0x10)
GalleryTreasuryCameraConfTableRow.zoomout_id = 0x20 // uint32_t (Size: 0x4)
GalleryTreasuryCameraConfTableRow.accessable_in_level = 0x28 // TArray<uint32_t> (Size: 0x10)
GalleryTreasuryCameraConfTableRow.cabinet_combination = 0x38 // TArray<FTreasuryCabinetCombination> (Size: 0x10)
GalleryTreasuryConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryTreasuryConfTableRow.abs_begin_time = 0x10 // FDateTime (Size: 0x8)
GalleryTreasuryStepConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryTreasuryStepConfTableRow.Num = 0xc // uint32_t (Size: 0x4)
GalleryTreasuryStepConfTableRow.text_color = 0x10 // FString (Size: 0x10)
GalleryTreasuryStepConfTableRow.bg_path = 0x20 // FString (Size: 0x10)
GalleryTreasuryStepConfTableRow.large_bg_path = 0x30 // FString (Size: 0x10)
GalleryTreasuryValueTitleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryTreasuryValueTitleConfTableRow.Value = 0xc // uint32_t (Size: 0x4)
GalleryTreasuryValueTitleConfTableRow.title_name = 0x10 // FText (Size: 0x18)
GalleryTreasuryValueTitleConfTableRow.title_icon = 0x28 // FString (Size: 0x10)
GalleryTreasuryValueTitleConfTableRow.exclude_items = 0x38 // TArray<uint32_t> (Size: 0x10)
GalleryUpgradeTargetConfTableRow.target_id = 0x8 // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.target_type = 0xc // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.jump_id = 0x10 // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.Progress = 0x14 // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.Param1 = 0x18 // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.Param2 = 0x1c // uint32_t (Size: 0x4)
GalleryUpgradeTargetConfTableRow.Param3 = 0x20 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.abandon_level = 0x10 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.display_order = 0x14 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.replace_formula_id = 0x18 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.Duration = 0x1c // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.season_only = 0x20 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.Enabled = 0x24 // uint32_t (Size: 0x4)
GalleryWorkbenchFormulaConfTableRow.products = 0x28 // TArray<FCommonItemConfItem> (Size: 0x10)
GalleryWorkbenchFormulaConfTableRow.cost_items = 0x38 // TArray<FCommonItemConfItem> (Size: 0x10)
GameSettingDescriptionTableRow.GameSettingName = 0x8 // FText (Size: 0x18)
GameSettingDescriptionTableRow.PPTType = 0x20 // uint32_t (Size: 0x4)
GameSettingDescriptionTableRow.Title = 0x28 // FText (Size: 0x18)
GameSettingDescriptionTableRow.desc = 0x40 // FText (Size: 0x18)
GameSettingDescriptionTableRow.Img = 0x58 // FString (Size: 0x10)
GenericShopConfTableRow.shop_id = 0x8 // uint32_t (Size: 0x4)
GenericShopConfTableRow.shop_name = 0x10 // FText (Size: 0x18)
GenericShopConfTableRow.cost_items = 0x28 // TArray<FConfGShopGood> (Size: 0x10)
GenericShopConfTableRow.shop_detail = 0x38 // FText (Size: 0x18)
GenericShopConfTableRow.red_point_type = 0x50 // uint32_t (Size: 0x4)
GenericShopConfTableRow.red_point_id = 0x58 // TArray<uint32_t> (Size: 0x10)
GenericShopTagConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GenericShopTagConfTableRow.tag_name = 0x10 // FText (Size: 0x18)
GenericShopTagConfTableRow.tag_icon = 0x28 // FString (Size: 0x10)
GenericShopTagConfTableRow.sort = 0x38 // uint32_t (Size: 0x4)
GenericShopTagConfTableRow.desc = 0x40 // FString (Size: 0x10)
GenericShopTradeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.shop_id = 0xc // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.tag_id = 0x10 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.sell_item_id = 0x14 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.should_display = 0x18 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.sell_num = 0x1c // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.is_black = 0x20 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.is_faction = 0x24 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.cost_item_id = 0x28 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.cost_num = 0x2c // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.unlock_type = 0x30 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.unlock_param = 0x34 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.unlock_level = 0x38 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.buy_limit_type = 0x3c // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.buy_limit_num = 0x40 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.bind_season = 0x44 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.preshelf_seconds = 0x48 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.onshelf_time = 0x50 // TArray<FGShopOnshelfTime> (Size: 0x10)
GenericShopTradeConfTableRow.sort_param = 0x60 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.onshelf_style = 0x64 // uint32_t (Size: 0x4)
GenericShopTradeConfTableRow.item_show_main = 0x68 // uint32_t (Size: 0x4)
GestureIconMontageTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
GestureIconMontageTableRow.GestureIconPath = 0x10 // FString (Size: 0x10)
GestureIconMontageTableRow.GestureDescription = 0x20 // FText (Size: 0x18)
GestureIconMontageTableRow.GestureMontagesMapID = 0x38 // uint32_t (Size: 0x4)
GestureIconMontageTableRow.activity_info = 0x40 // FString (Size: 0x10)
GestureIconMontageTableRow.jump_goto = 0x50 // TArray<uint32_t> (Size: 0x10)
GestureIconMontageTableRow.no_source_description = 0x60 // FText (Size: 0x18)
GiftEquipItem.item_id = 0x0 // uint32_t (Size: 0x4)
GiftEquipItem.Num = 0x4 // uint32_t (Size: 0x4)
GiftEquipItem.Parent = 0x8 // uint32_t (Size: 0x4)
GiftEquipItem.is_black = 0xc // uint32_t (Size: 0x4)
GiftEquipItem.is_rotate = 0x10 // uint32_t (Size: 0x4)
GiftEquipItem.Index = 0x14 // uint32_t (Size: 0x4)
GiftEquipItem.pos_x = 0x18 // uint32_t (Size: 0x4)
GiftEquipItem.pos_y = 0x1c // uint32_t (Size: 0x4)
GiftGroupDescConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GiftGroupDescConfTableRow.Detail = 0x10 // FText (Size: 0x18)
GiftGroupDescConfTableRow.des = 0x28 // FText (Size: 0x18)
GiftPackageConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
GiftPackageConfTableRow.is_equip_package = 0x10 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.limit_batch_open = 0x14 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.auto_open = 0x18 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.Level = 0x1c // uint32_t (Size: 0x4)
GiftPackageConfTableRow.filter_type = 0x20 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.self_select_num = 0x24 // uint32_t (Size: 0x4)
GiftPackageConfTableRow.weight_limit = 0x28 // uint32_t (Size: 0x4)
GiftPackageEquipConfTableRow.Key = 0x8 // uint32_t (Size: 0x4)
GiftPackageEquipConfTableRow.ID = 0xc // uint32_t (Size: 0x4)
GiftPackageEquipConfTableRow.Items = 0x10 // TArray<FGiftEquipItem> (Size: 0x10)
GiftPackageEquipTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GiftPackageEquipTableRow.Equip = 0x10 // FString (Size: 0x10)
GiftPackageShowItemsConfTableRow.package_id = 0x8 // uint32_t (Size: 0x4)
GiftPackageShowItemsConfTableRow.item_id = 0x10 // TArray<uint32_t> (Size: 0x10)
GiftPackageShowItemsConfTableRow.is_black = 0x20 // TArray<uint32_t> (Size: 0x10)
GiftPackageShowItemsConfTableRow.item_num = 0x30 // TArray<uint32_t> (Size: 0x10)
GiftPackageShowItemsConfTableRow.Weight = 0x40 // TArray<uint32_t> (Size: 0x10)
GlobalConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GlobalConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
GlobalConfTableRow.ary = 0x18 // TArray<uint64_t> (Size: 0x10)
GlobalConfTableRow.iary = 0x28 // TArray<int64_t> (Size: 0x10)
GlobalConfTableRow.Str = 0x38 // FText (Size: 0x18)
GlobalConfTableRow.daily_time_vec = 0x50 // TArray<FGlobalDailyTimeConf> (Size: 0x10)
GlobalDailyTimeConf.daily_time = 0x0 // FText (Size: 0x18)
GoldDogTagConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
GoldDogTagConfTableRow.bgUrl = 0x10 // FString (Size: 0x10)
GuaranteeCheckItemTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteeCheckItemTableRow.check_group_id = 0xc // uint32_t (Size: 0x4)
GuaranteeCheckItemTableRow.check_item_id = 0x10 // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.play_mode_id = 0xc // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.lootpoint_type_id = 0x10 // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.guarantee_id = 0x14 // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.Value = 0x18 // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.check_group_id = 0x1c // uint32_t (Size: 0x4)
GuaranteeContainerTableRow.gen_group_id = 0x20 // uint32_t (Size: 0x4)
GuaranteeFactorConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteeFactorConfTableRow.PlayModeId = 0x10 // int64_t (Size: 0x8)
GuaranteeFactorConfTableRow.TotalValueMin = 0x18 // uint64_t (Size: 0x8)
GuaranteeFactorConfTableRow.TotalValueMax = 0x20 // uint64_t (Size: 0x8)
GuaranteeFactorConfTableRow.Factor = 0x28 // float (Size: 0x4)
GuaranteeGenItemTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteeGenItemTableRow.gen_group_id = 0xc // uint32_t (Size: 0x4)
GuaranteeGenItemTableRow.gen_item_id = 0x10 // uint32_t (Size: 0x4)
GuaranteeGenItemTableRow.Weight = 0x14 // uint32_t (Size: 0x4)
GuaranteeGenItemTableRow.item_num = 0x18 // TArray<uint32_t> (Size: 0x10)
GuaranteeLimitStrategyTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteeLimitStrategyTableRow.shield_type = 0xc // uint32_t (Size: 0x4)
GuaranteeLimitStrategyTableRow.sub_item_id = 0x10 // uint32_t (Size: 0x4)
GuaranteeLimitStrategyTableRow.sub_item_num = 0x18 // TArray<uint32_t> (Size: 0x10)
GuaranteedConditions.tag_id = 0x0 // uint32_t (Size: 0x4)
GuaranteedConditions.attr_id = 0x4 // uint32_t (Size: 0x4)
GuaranteedConditions.attr_low = 0x8 // int64_t (Size: 0x8)
GuaranteedConditions.attr_up = 0x10 // int64_t (Size: 0x8)
GuaranteedPoolConfTableRow.guaranteed_pool_id = 0x8 // uint32_t (Size: 0x4)
GuaranteedPoolConfTableRow.defalut_limit = 0xc // uint32_t (Size: 0x4)
GuaranteedPoolConfTableRow.max_limit = 0x10 // uint32_t (Size: 0x4)
GuaranteedPoolConfTableRow.min_limit = 0x14 // uint32_t (Size: 0x4)
GuaranteedPoolConfTableRow.stages = 0x18 // TArray<FGuaranteedPoolStage> (Size: 0x10)
GuaranteedPoolStage.times_count = 0x0 // uint32_t (Size: 0x4)
GuaranteedPoolStage.limit_value = 0x4 // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.ID = 0x8 // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.guaranteed_pool_id = 0xc // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.attr_value = 0x10 // int32_t (Size: 0x4)
GuaranteedUseAttrTableRow.loot_stage = 0x14 // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.loot_count = 0x18 // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.extra_value = 0x1c // int32_t (Size: 0x4)
GuaranteedUseAttrTableRow.calculate_time = 0x20 // uint32_t (Size: 0x4)
GuaranteedUseAttrTableRow.guaranteed_conditions = 0x28 // TArray<FGuaranteedConditions> (Size: 0x10)
H5MediaItem.h5BgIcon = 0x0 // FString (Size: 0x10)
H5MediaItem.h5Url = 0x10 // FString (Size: 0x10)
HardwareBenchmarkScoreTableRow.HardwareId = 0x8 // uint32_t (Size: 0x4)
HardwareBenchmarkScoreTableRow.HardwareName = 0x10 // FString (Size: 0x10)
HardwareBenchmarkScoreTableRow.CpuScore = 0x20 // float (Size: 0x4)
HardwareBenchmarkScoreTableRow.GpuScore = 0x24 // float (Size: 0x4)
HeadBoxItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HeadBoxItemConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
HeadBoxItemConfTableRow.Display = 0x10 // uint32_t (Size: 0x4)
HeadBoxItemConfTableRow.jump_goto = 0x14 // uint32_t (Size: 0x4)
HeadBoxItemConfTableRow.obtain = 0x18 // FText (Size: 0x18)
HeadBoxItemConfTableRow.Order = 0x30 // uint32_t (Size: 0x4)
HeadBoxItemConfTableRow.start_time = 0x38 // FDateTime (Size: 0x8)
HeadBoxItemConfTableRow.end_time = 0x40 // FDateTime (Size: 0x8)
HeadBoxItemConfTableRow.is_cannot_get = 0x48 // uint32_t (Size: 0x4)
HeadConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HeadConfTableRow.Price = 0xc // uint32_t (Size: 0x4)
HeadConfTableRow.Helmet = 0x10 // uint32_t (Size: 0x4)
HeadConfTableRow.Visor = 0x14 // uint32_t (Size: 0x4)
HeadConfTableRow.Headset = 0x18 // uint32_t (Size: 0x4)
HeadConfTableRow.Mask = 0x1c // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.Display = 0x10 // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.jump_goto = 0x14 // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.obtain = 0x18 // FText (Size: 0x18)
HeadIconItemConfTableRow.Order = 0x30 // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.start_time = 0x38 // FDateTime (Size: 0x8)
HeadIconItemConfTableRow.end_time = 0x40 // FDateTime (Size: 0x8)
HeadIconItemConfTableRow.is_cannot_get = 0x48 // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.is_dynamic_logo = 0x4c // uint32_t (Size: 0x4)
HeadIconItemConfTableRow.activity_info = 0x50 // FString (Size: 0x10)
HeadIconItemConfTableRow.asset_path = 0x60 // FString (Size: 0x10)
HeadIconItemConfTableRow.dynamic_asset_path = 0x70 // FString (Size: 0x10)
HealthThresholdTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HealthThresholdTableRow.State = 0x10 // FText (Size: 0x18)
HealthThresholdTableRow.Hierarchy = 0x28 // uint32_t (Size: 0x4)
HealthThresholdTableRow.Content = 0x30 // FText (Size: 0x18)
HealthThresholdTableRow.Parameter = 0x48 // uint32_t (Size: 0x4)
HealthThresholdTableRow.Alert = 0x4c // uint32_t (Size: 0x4)
HealthThresholdTableRow.Priority = 0x50 // uint32_t (Size: 0x4)
HealthThresholdTableRow.LevelLimit = 0x54 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
HelpDialogConfTableRow.Title = 0x10 // FText (Size: 0x18)
HelpDialogConfTableRow.rewardId = 0x28 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.canGetTime = 0x2c // uint32_t (Size: 0x4)
HelpDialogConfTableRow.rootType = 0x30 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.sortIndex = 0x34 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.functioncontrolId = 0x38 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.unlockLevel = 0x3c // uint32_t (Size: 0x4)
HelpDialogConfTableRow.isHidden = 0x40 // uint32_t (Size: 0x4)
HelpDialogConfTableRow.triggerIds = 0x48 // TArray<uint32_t> (Size: 0x10)
HelpDialogConfTableRow.mediaArray = 0x58 // TArray<uint32_t> (Size: 0x10)
HelpDialogConfTableRow.h5Media = 0x68 // TArray<FH5MediaItem> (Size: 0x10)
HelpDialogConfTableRow.Content = 0x78 // TArray<FHelpDialogContentItem> (Size: 0x10)
HelpDialogContentItem.contentTitle = 0x0 // FText (Size: 0x18)
HelpDialogContentItem.pageIndex = 0x18 // uint32_t (Size: 0x4)
HelpDialogContentItem.ContentText = 0x20 // FText (Size: 0x18)
HelpEntryInfoConfTableRow.entry_id = 0x8 // uint32_t (Size: 0x4)
HelpEntryInfoConfTableRow.main_title = 0x10 // FText (Size: 0x18)
HelpEntryInfoConfTableRow.tab_content = 0x28 // TArray<FTabDetailItem> (Size: 0x10)
HelpRootTypeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HelpRootTypeConfTableRow.Name = 0x10 // FText (Size: 0x18)
HelperConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HelperConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
HelperConfTableRow.Index = 0x10 // uint32_t (Size: 0x4)
HelperConfTableRow.Title = 0x18 // FText (Size: 0x18)
HelperConfTableRow.desc = 0x30 // FText (Size: 0x18)
HelperTypeConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
HelperTypeConfTableRow.TypeName = 0x10 // FText (Size: 0x18)
HotUpdateGlobalConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
HotUpdateGlobalConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
IconScaleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
IconScaleConfTableRow.DistancePercentA = 0xc // float (Size: 0x4)
ImageRefItem.ImageType = 0x0 // uint32_t (Size: 0x4)
ImageRefItem.Path = 0x8 // FString (Size: 0x10)
InflationRatio.start_day = 0x0 // uint32_t (Size: 0x4)
InflationRatio.Ratio = 0x4 // uint32_t (Size: 0x4)
InnerGameActConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InnerGameActConfTableRow.Name = 0x10 // FText (Size: 0x18)
InnerGameActConfTableRow.is_open = 0x28 // uint32_t (Size: 0x4)
InnerGameActConfTableRow.begin_time = 0x30 // FDateTime (Size: 0x8)
InnerGameActConfTableRow.end_time = 0x38 // FDateTime (Size: 0x8)
InnerGameActConfTableRow.inner_game_act_type = 0x40 // uint32_t (Size: 0x4)
InnerGameActConfTableRow.json_param = 0x48 // FText (Size: 0x18)
InnerGameActConfTableRow.notice = 0x60 // FText (Size: 0x18)
InnerGameActConfTableRow.des = 0x78 // FText (Size: 0x18)
InnerGameActConfTableRow.gameplay_related_items = 0x90 // TArray<uint32_t> (Size: 0x10)
InnerGameActConfTableRow.weekly_day_vec = 0xa0 // TArray<uint32_t> (Size: 0x10)
InnerGameActConfTableRow.daily_time_vec = 0xb0 // TArray<FDailyTimeConf> (Size: 0x10)
InnerGameActConfTableRow.open_map_mode_vec = 0xc0 // TArray<FOpenMapModeConf> (Size: 0x10)
InsureCombineItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InsureCombineItemConfTableRow.price_list = 0x10 // TArray<uint32_t> (Size: 0x10)
InsureCommonAccConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InsureCommonAccConfTableRow.price_list = 0x10 // TArray<uint32_t> (Size: 0x10)
InsureCommonItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InsureCommonItemConfTableRow.price_list = 0x10 // TArray<uint32_t> (Size: 0x10)
InsureQualityProbConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InsureQualityProbConfTableRow.prob = 0xc // uint32_t (Size: 0x4)
InsureTypeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
InsureTypeConfTableRow.insuretime_min = 0xc // uint32_t (Size: 0x4)
InsureTypeConfTableRow.insuretime_max = 0x10 // uint32_t (Size: 0x4)
InsureTypeConfTableRow.lootinglocktime = 0x14 // uint32_t (Size: 0x4)
IntelligenceLootPointTableRow.ID = 0x8 // uint32_t (Size: 0x4)
IntelligenceLootPointTableRow.loot_data_info_id_list = 0x10 // TArray<uint32_t> (Size: 0x10)
IntelligenceLootPointTableRow.announce_text = 0x20 // FText (Size: 0x18)
IntelligenceLootPointTableRow.Weight = 0x38 // uint32_t (Size: 0x4)
IntelligenceTableRow.ID = 0x8 // uint32_t (Size: 0x4)
IntelligenceTableRow.intelligence_id = 0xc // uint32_t (Size: 0x4)
IntelligenceTableRow.icon = 0x10 // uint32_t (Size: 0x4)
IntelligenceTableRow.Level = 0x14 // uint32_t (Size: 0x4)
IntelligenceTableRow.Type = 0x18 // FText (Size: 0x18)
IntelligenceTableRow.State = 0x30 // FText (Size: 0x18)
IntelligenceTableRow.coordinate = 0x48 // FString (Size: 0x10)
IntelligenceTableRow.desc = 0x58 // FText (Size: 0x18)
InvAnimationInfo.AnimType = 0x0 // uint32_t (Size: 0x4)
InvAnimationInfo.OverrideAnimation = 0x8 // FSoftObjectPath (Size: 0x18)
InvList.List = 0x0 // TArray<uint32_t> (Size: 0x10)
InviteRewardListConf.item_id = 0x0 // uint32_t (Size: 0x4)
InviteRewardListConf.Num = 0x4 // uint32_t (Size: 0x4)
InviteRewardListConf.is_black = 0x8 // uint32_t (Size: 0x4)
ItemCategoryIconPathTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemCategoryIconPathTableRow.category_name = 0x10 // FText (Size: 0x18)
ItemCategoryIconPathTableRow.seg = 0x28 // uint32_t (Size: 0x4)
ItemCategoryIconPathTableRow.icon_path = 0x30 // FString (Size: 0x10)
ItemCheckWhiteListConfTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
ItemClassifyGroupConfTableRow.ID = 0x8 // uint8_t (Size: 0x1)
ItemClassifyGroupConfTableRow.Types = 0x10 // TArray<uint64_t> (Size: 0x10)
ItemClassifyGroupConfTableRow.sortOrder = 0x20 // uint8_t (Size: 0x1)
ItemComponentsIconTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemComponentsIconTableRow.component_name = 0x10 // FText (Size: 0x18)
ItemComponentsIconTableRow.icon_name = 0x28 // FString (Size: 0x10)
ItemComponentsIconTableRow.icon_path = 0x38 // FString (Size: 0x10)
ItemConfTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
ItemConfTableRow.Name = 0x10 // FText (Size: 0x18)
ItemConfTableRow.ShortName = 0x28 // FText (Size: 0x18)
ItemConfTableRow.IconId = 0x40 // uint32_t (Size: 0x4)
ItemConfTableRow.Describe = 0x48 // FText (Size: 0x18)
ItemConfTableRow.SizeX = 0x60 // int32_t (Size: 0x4)
ItemConfTableRow.SizeY = 0x64 // int32_t (Size: 0x4)
ItemConfTableRow.Weight = 0x68 // float (Size: 0x4)
ItemConfTableRow.pickup_sound = 0x70 // FString (Size: 0x10)
ItemConfTableRow.use_sound = 0x80 // FString (Size: 0x10)
ItemConfTableRow.drop_sound = 0x90 // FString (Size: 0x10)
ItemConfTableRow.drop_on_ground_sound = 0xa0 // FString (Size: 0x10)
ItemConfTableRow.sell_price = 0xb0 // uint32_t (Size: 0x4)
ItemConfTableRow.sell_rate = 0xb4 // uint32_t (Size: 0x4)
ItemConfTableRow.can_sell = 0xb8 // uint32_t (Size: 0x4)
ItemConfTableRow.standard_price = 0xbc // uint32_t (Size: 0x4)
ItemConfTableRow.StackMax = 0xc0 // uint32_t (Size: 0x4)
ItemConfTableRow.TakeInCount = 0xc4 // int32_t (Size: 0x4)
ItemConfTableRow.expire_time = 0xc8 // FDateTime (Size: 0x8)
ItemConfTableRow.compensate = 0xd0 // TArray<FCommonItemConfItem> (Size: 0x10)
ItemConfTableRow.not_discard = 0xe0 // uint32_t (Size: 0x4)
ItemConfTableRow.Bind = 0xe4 // uint32_t (Size: 0x4)
ItemConfTableRow.Rarity = 0xe8 // uint32_t (Size: 0x4)
ItemConfTableRow.Durability = 0xec // uint32_t (Size: 0x4)
ItemConfTableRow.UseExp = 0xf0 // int32_t (Size: 0x4)
ItemConfTableRow.LootExp = 0xf4 // int32_t (Size: 0x4)
ItemConfTableRow.RejectSlot = 0xf8 // TArray<uint8_t> (Size: 0x10)
ItemConfTableRow.RejectItems = 0x108 // TArray<uint32_t> (Size: 0x10)
ItemConfTableRow.sort = 0x118 // uint32_t (Size: 0x4)
ItemConfTableRow.jump_goto = 0x11c // uint32_t (Size: 0x4)
ItemConfTableRow.PackageFlags = 0x120 // int32_t (Size: 0x4)
ItemConfTableRow.FactoryId = 0x124 // uint32_t (Size: 0x4)
ItemConfTableRow.is_Arenaitem = 0x128 // uint32_t (Size: 0x4)
ItemConfTableRow.RarityColor = 0x12c // uint32_t (Size: 0x4)
ItemConfTableRow.is_faction = 0x130 // uint32_t (Size: 0x4)
ItemConfTableRow.transfer_value_rate = 0x134 // int32_t (Size: 0x4)
ItemConfTableRow.limit_num = 0x138 // uint32_t (Size: 0x4)
ItemDynamicPriceTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemDynamicPriceTableRow.y_standard_price = 0xc // uint32_t (Size: 0x4)
ItemEffectConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.effect_type = 0xc // uint32_t (Size: 0x4)
ItemEffectConfTableRow.auto_use = 0x10 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.exchange_list = 0x18 // TArray<FExchangeEffect> (Size: 0x10)
ItemEffectConfTableRow.privilege_item_id = 0x28 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.privilege_num = 0x2c // uint32_t (Size: 0x4)
ItemEffectConfTableRow.another_privilege_item_id = 0x30 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.another_privilege_num = 0x34 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.bp_season = 0x38 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.bp_vip_lv = 0x3c // uint32_t (Size: 0x4)
ItemEffectConfTableRow.auction_week_sale_order_num = 0x40 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.auction_intime_sale_order_num = 0x44 // uint32_t (Size: 0x4)
ItemEffectConfTableRow.auction_effect_num = 0x48 // uint32_t (Size: 0x4)
ItemExchangePriceTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemExchangePriceTableRow.TicketPrice = 0xc // int32_t (Size: 0x4)
ItemExchangePriceTableRow.CoinPrice = 0x10 // int32_t (Size: 0x4)
ItemFactoryTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemFactoryTableRow.factory_name = 0x10 // FText (Size: 0x18)
ItemFactoryTableRow.IconPath = 0x28 // FString (Size: 0x10)
ItemInflationTypeTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemInflationTypeTableRow.low_inflation = 0xc // uint32_t (Size: 0x4)
ItemInflationTypeTableRow.high_inflation = 0x10 // uint32_t (Size: 0x4)
ItemLimitConf.Item_type = 0x0 // uint32_t (Size: 0x4)
ItemLimitConf.item_type_num = 0x4 // uint32_t (Size: 0x4)
ItemLimitConf.num_limit = 0x8 // uint32_t (Size: 0x4)
ItemLimitConf.value_limit = 0xc // uint32_t (Size: 0x4)
ItemLimitConf.tips_id = 0x10 // int32_t (Size: 0x4)
ItemPriceGearTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemPriceGearTableRow.PriceRange = 0xc // uint32_t (Size: 0x4)
ItemPriceGearTableRow.Step = 0x10 // uint32_t (Size: 0x4)
ItemShareConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemShareConfTableRow.iconUrl = 0x10 // FString (Size: 0x10)
ItemShareConfTableRow.bgUrl = 0x20 // FString (Size: 0x10)
ItemShareConfTableRow.itemShareType = 0x30 // uint32_t (Size: 0x4)
ItemShareConfTableRow.extraDesc = 0x38 // TArray<FText> (Size: 0x10)
ItemShelveConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemShelveConfTableRow.show_in_wardrobe = 0xc // uint32_t (Size: 0x4)
ItemShelveConfTableRow.start_time = 0x10 // FDateTime (Size: 0x8)
ItemShelveConfTableRow.end_time = 0x18 // FDateTime (Size: 0x8)
ItemShelveConfTableRow.need_change = 0x20 // uint32_t (Size: 0x4)
ItemShelveTestConfTableRow.EXPORT_TO_JSON = 0x8 // uint32_t (Size: 0x4)
ItemShelveTestConfTableRow.need_change = 0xc // uint32_t (Size: 0x4)
ItemSortTableRow.item_id = 0x8 // uint64_t (Size: 0x8)
ItemSortTableRow.icon = 0x10 // FString (Size: 0x10)
ItemTakeInLimitConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.total_value_limit = 0xc // uint32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.total_value_limit_tip_id = 0x10 // int32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.equip_value_limit = 0x14 // uint32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.equip_value_limit_tip_id = 0x18 // int32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.safebox_value_limit = 0x1c // uint32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.safebox_value_limit_tip_id = 0x20 // int32_t (Size: 0x4)
ItemTakeInLimitConfTableRow.item_limit_vec = 0x28 // TArray<FItemLimitConf> (Size: 0x10)
ItemsDropPool.item_id = 0x0 // uint32_t (Size: 0x4)
ItemsDropPool.Probability = 0x4 // uint32_t (Size: 0x4)
JumpGotoCfgTableRow.jump_id = 0x8 // uint32_t (Size: 0x4)
JumpGotoCfgTableRow.jump_button_name = 0x10 // FText (Size: 0x18)
JumpGotoCfgTableRow.jump_name = 0x28 // FText (Size: 0x18)
JumpGotoCfgTableRow.Command = 0x40 // FText (Size: 0x18)
JumpGotoCfgTableRow.jump_target = 0x58 // FText (Size: 0x18)
JumpGotoCfgTableRow.Param = 0x70 // FText (Size: 0x18)
JumpGotoCfgTableRow.open_tips = 0x88 // FText (Size: 0x18)
JumpGotoCfgTableRow.display_gray = 0xa0 // uint32_t (Size: 0x4)
JumpGotoCfgTableRow.replace_content = 0xa4 // uint32_t (Size: 0x4)
JumpGotoCfgTableRow.display_content = 0xa8 // FText (Size: 0x18)
KeyCabinetConfTableRow.Index = 0x8 // uint32_t (Size: 0x4)
KeyCabinetConfTableRow.map_id = 0xc // uint32_t (Size: 0x4)
KeyCabinetConfTableRow.is_enable = 0x10 // uint32_t (Size: 0x4)
KeyCabinetConfTableRow.key_Item_Type = 0x14 // uint32_t (Size: 0x4)
KeyCabinetConfTableRow.key_desc = 0x18 // FText (Size: 0x18)
KeyCabinetConfTableRow.mapunlockId = 0x30 // uint32_t (Size: 0x4)
KeyContainerConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
KeyContainerConfTableRow.container_id = 0xc // uint32_t (Size: 0x4)
KeyContainerConfTableRow.show_index = 0x10 // uint32_t (Size: 0x4)
KeyContainerConfTableRow.is_hidden = 0x14 // uint32_t (Size: 0x4)
KeyContainerConfTableRow.group_id = 0x18 // uint32_t (Size: 0x4)
KeyContainerConfTableRow.is_time = 0x1c // uint32_t (Size: 0x4)
KeyContainerConfTableRow.list_desc = 0x20 // FText (Size: 0x18)
KeyContainerConfTableRow.jump_goto = 0x38 // uint32_t (Size: 0x4)
LackFundTableRow.lack_fund_wealth1 = 0x8 // uint32_t (Size: 0x4)
LackFundTableRow.lack_fund_wealth2 = 0xc // uint32_t (Size: 0x4)
LackFundTableRow.lack_fund_cash = 0x10 // uint32_t (Size: 0x4)
LackFundTableRow.lack_fund_mud = 0x14 // uint32_t (Size: 0x4)
LackFundTableRow.lack_fund_gold = 0x18 // uint32_t (Size: 0x4)
LbsTitleConfTableRow.rank_type = 0x8 // uint32_t (Size: 0x4)
LbsTitleConfTableRow.item_id = 0xc // uint32_t (Size: 0x4)
LeaderboardDesConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LeaderboardDesConfTableRow.titledes = 0x10 // FText (Size: 0x18)
LeaderboardDesConfTableRow.tipdes = 0x28 // FText (Size: 0x18)
LeaderboardDesConfTableRow.Type = 0x40 // uint32_t (Size: 0x4)
LeaderboardDesConfTableRow.is_open = 0x44 // uint32_t (Size: 0x4)
LeaderboardDesConfTableRow.specialtype = 0x48 // uint32_t (Size: 0x4)
LeaderboardDesConfTableRow.titlecountdes = 0x50 // FText (Size: 0x18)
LeaderboardDesConfTableRow.nogetnumdes = 0x68 // FText (Size: 0x18)
LevelConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
LevelConfTableRow.PMCExpPerLevel = 0x10 // uint64_t (Size: 0x8)
LevelConfTableRow.PMCExpTotal = 0x18 // uint64_t (Size: 0x8)
LevelConfTableRow.PMCIcon = 0x20 // uint32_t (Size: 0x4)
LevelConfTableRow.ScavExpPerLevel = 0x28 // uint64_t (Size: 0x8)
LevelConfTableRow.ScavExpTotal = 0x30 // uint64_t (Size: 0x8)
LevelConfTableRow.ScavIcon = 0x38 // uint32_t (Size: 0x4)
LevelConfTableRow.level_exp_limit = 0x40 // uint64_t (Size: 0x8)
LevelFuncConf.unlock_func_name = 0x0 // FText (Size: 0x18)
LevelFuncConf.unlock_img_path = 0x18 // FString (Size: 0x10)
LevelFuncConf.unlock_bg_path = 0x28 // FString (Size: 0x10)
LevelFuncConf.is_map = 0x38 // uint32_t (Size: 0x4)
LevelFuncConf.panel_bg_path = 0x40 // FString (Size: 0x10)
LevelFuncConf.jump_id = 0x50 // uint32_t (Size: 0x4)
LevelFuncConf.desc = 0x58 // FText (Size: 0x18)
LevelRewardConf.item_id = 0x0 // uint32_t (Size: 0x4)
LevelRewardConf.is_unique = 0x4 // uint32_t (Size: 0x4)
LevelRewardConf.item_img_path = 0x8 // FString (Size: 0x10)
LevelRewardConf.panel_bg_path = 0x18 // FString (Size: 0x10)
LevelRewardConf.is_black = 0x28 // uint32_t (Size: 0x4)
LevelRewardConf.Num = 0x2c // uint32_t (Size: 0x4)
LimitPoolConf.shield_type = 0x0 // uint32_t (Size: 0x4)
LimitPoolConf.sub_item_id = 0x4 // uint32_t (Size: 0x4)
LimitPoolConf.sub_item_num = 0x8 // uint32_t (Size: 0x4)
LimitPoolConf.Probability = 0xc // uint32_t (Size: 0x4)
LimitPoolConf.pool_id = 0x10 // uint32_t (Size: 0x4)
LimitUserTagConditions.tag_id = 0x0 // uint32_t (Size: 0x4)
LimitUserTagConditions.attr_id = 0x4 // uint32_t (Size: 0x4)
LimitUserTagConditions.attr_down = 0x8 // int64_t (Size: 0x8)
LimitUserTagConditions.attr_up = 0x10 // int64_t (Size: 0x8)
LoadingImageTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LoadingImageTableRow.ModelID = 0xc // uint32_t (Size: 0x4)
LoadingImageTableRow.SubModID = 0x10 // uint32_t (Size: 0x4)
LoadingImageTableRow.MapID = 0x14 // uint32_t (Size: 0x4)
LoadingImageTableRow.RuleID = 0x18 // uint32_t (Size: 0x4)
LoadingImageTableRow.ActivityID = 0x1c // uint32_t (Size: 0x4)
LoadingImageTableRow.Activityweight = 0x20 // uint32_t (Size: 0x4)
LoadingImageTableRow.ImageRef = 0x28 // TArray<FImageRefItem> (Size: 0x10)
LoadingTipsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LoadingTipsTableRow.ModelID = 0xc // uint32_t (Size: 0x4)
LoadingTipsTableRow.SubModID = 0x10 // uint32_t (Size: 0x4)
LoadingTipsTableRow.MapID = 0x14 // uint32_t (Size: 0x4)
LoadingTipsTableRow.RuleID = 0x18 // uint32_t (Size: 0x4)
LoadingTipsTableRow.ActivityID = 0x1c // uint32_t (Size: 0x4)
LoadingTipsTableRow.Activityweight = 0x20 // uint32_t (Size: 0x4)
LoadingTipsTableRow.MinWealthy = 0x24 // float (Size: 0x4)
LoadingTipsTableRow.MaxWealthy = 0x28 // float (Size: 0x4)
LoadingTipsTableRow.MinLevel = 0x2c // uint32_t (Size: 0x4)
LoadingTipsTableRow.MaxLevel = 0x30 // uint32_t (Size: 0x4)
LoadingTipsTableRow.MinEscapeProbability = 0x34 // float (Size: 0x4)
LoadingTipsTableRow.MaxEscapeProbability = 0x38 // float (Size: 0x4)
LoadingTipsTableRow.Tips = 0x40 // TArray<FTipItem> (Size: 0x10)
LobbyBGMCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LobbyBGMCfgTableRow.Priority = 0xc // uint32_t (Size: 0x4)
LobbyBGMCfgTableRow.sound_res_name = 0x10 // FString (Size: 0x10)
LobbyBGMCfgTableRow.music_len = 0x20 // uint32_t (Size: 0x4)
LobbyBGMCfgTableRow.song_name = 0x28 // FString (Size: 0x10)
LobbyBGMCfgTableRow.play_normal_pic = 0x38 // FString (Size: 0x10)
LobbyBGMCfgTableRow.pause_normal_pic = 0x48 // FString (Size: 0x10)
LobbyBGMCfgTableRow.play_press_pic = 0x58 // FString (Size: 0x10)
LobbyBGMCfgTableRow.pause_press_pic = 0x68 // FString (Size: 0x10)
LobbyBGMCfgTableRow.play_hover_pic = 0x78 // FString (Size: 0x10)
LobbyBGMCfgTableRow.pause_hover_pic = 0x88 // FString (Size: 0x10)
LobbyBGMCfgTableRow.jump_id = 0x98 // uint32_t (Size: 0x4)
LobbyBGMCfgTableRow.begin_time = 0xa0 // FString (Size: 0x10)
LobbyBGMCfgTableRow.end_time = 0xb0 // FString (Size: 0x10)
LocalizationConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LocalizationConfTableRow.EnumName = 0x10 // FText (Size: 0x18)
LocalizationConfTableRow.LocalizedText = 0x28 // FText (Size: 0x18)
LoginLoadingImageTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LoginLoadingImageTableRow.Path = 0x10 // FString (Size: 0x10)
LoginLoadingImageTableRow.Weight = 0x20 // uint32_t (Size: 0x4)
LoginLoadingTipsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LoginLoadingTipsTableRow.Tip = 0x10 // FText (Size: 0x18)
LoginLoadingTipsTableRow.Weight = 0x28 // uint32_t (Size: 0x4)
LootDropActivityConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootDropActivityConfTableRow.map_id = 0x10 // uint64_t (Size: 0x8)
LootDropActivityConfTableRow.is_map_all = 0x18 // uint64_t (Size: 0x8)
LootDropActivityConfTableRow.box_id = 0x20 // uint64_t (Size: 0x8)
LootDropActivityConfTableRow.is_box_all = 0x28 // uint64_t (Size: 0x8)
LootDropActivityConfTableRow.loot_id = 0x30 // uint64_t (Size: 0x8)
LootDropActivityConfTableRow.activity_order = 0x38 // uint32_t (Size: 0x4)
LootDropActivityConfTableRow.Items = 0x40 // TArray<FNewActivityLootDropInfoConf> (Size: 0x10)
LootDropActivityPoolConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
LootDropActivityPoolConfTableRow.Items = 0x10 // TArray<FLootDropPoolInfo> (Size: 0x10)
LootDropControlConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootDropControlConfTableRow.map_id = 0x10 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.is_map_all = 0x18 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.box_id = 0x20 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.is_box_all = 0x28 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.loot_id = 0x30 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.activity_id = 0x38 // uint32_t (Size: 0x4)
LootDropControlConfTableRow.activity_order = 0x3c // uint32_t (Size: 0x4)
LootDropControlConfTableRow.in_game_time = 0x40 // uint32_t (Size: 0x4)
LootDropControlConfTableRow.Weather = 0x44 // uint32_t (Size: 0x4)
LootDropControlConfTableRow.commonitem_id_array = 0x48 // TArray<uint32_t> (Size: 0x10)
LootDropControlConfTableRow.relace_rate = 0x58 // uint64_t (Size: 0x8)
LootDropControlConfTableRow.pool_id = 0x60 // TArray<uint32_t> (Size: 0x10)
LootDropOperationConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
LootDropOperationConfTableRow.Items = 0x10 // TArray<FActivityLootDropInfoConf> (Size: 0x10)
LootDropPoolConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
LootDropPoolConfTableRow.Items = 0x10 // TArray<FLootDropPoolInfo> (Size: 0x10)
LootDropPoolInfo.item_id = 0x0 // uint64_t (Size: 0x8)
LootDropPoolInfo.item_num = 0x8 // uint32_t (Size: 0x4)
LootDropPoolInfo.Probability = 0xc // uint32_t (Size: 0x4)
LootDropTableRow.ID = 0x8 // uint64_t (Size: 0x8)
LootDropTableRow.desc = 0x10 // FString (Size: 0x10)
LootDropTableRow.ItemType = 0x20 // uint8_t (Size: 0x1)
LootDropTableRow.ItemId = 0x28 // uint64_t (Size: 0x8)
LootDropTableRow.ItemNum = 0x30 // TArray<uint32_t> (Size: 0x10)
LootDropTableRow.SubItemTable = 0x40 // TArray<uint64_t> (Size: 0x10)
LootDropTableRow.Weight = 0x50 // uint32_t (Size: 0x4)
LootDropTableRow.Percent = 0x54 // float (Size: 0x4)
LootDropTableRow.RandTimes = 0x58 // float (Size: 0x4)
LootDropTableRow.WeightTimes = 0x5c // float (Size: 0x4)
LootDropTableRow.OperationType = 0x60 // uint8_t (Size: 0x1)
LootDropTableRow.IsPermanent = 0x61 // uint8_t (Size: 0x1)
LootDropTableRow.ActID = 0x64 // uint32_t (Size: 0x4)
LootDropTableRow.LootPointWhite = 0x68 // TArray<uint64_t> (Size: 0x10)
LootDropTableRow.LootPointBlack = 0x78 // TArray<uint64_t> (Size: 0x10)
LootDropTableRow.Describe = 0x88 // FString (Size: 0x10)
LootDropTableRow.MaxRepeatRandomNum = 0x98 // uint32_t (Size: 0x4)
LootFactionItemConfTableRow.ItemId = 0x8 // uint64_t (Size: 0x8)
LootLimitConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootLimitConfTableRow.normal_value = 0xc // float (Size: 0x4)
LootLimitConfTableRow.redline_value = 0x10 // float (Size: 0x4)
LootLimitConfTableRow.calc_type = 0x14 // uint32_t (Size: 0x4)
LootLimitConfTableRow.loot_pool = 0x18 // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.tag_priority = 0xc // int32_t (Size: 0x4)
LootLimitUserTagTableRow.remove_guarantee_pr = 0x10 // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.remove_protect_pr = 0x14 // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.dont_remove_containers = 0x18 // TArray<uint32_t> (Size: 0x10)
LootLimitUserTagTableRow.extra_time = 0x28 // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.extra_time_pr = 0x2c // uint32_t (Size: 0x4)
LootLimitUserTagTableRow.limit_conditions = 0x30 // TArray<FLimitUserTagConditions> (Size: 0x10)
LootObjExpTableRow.ID = 0x8 // int32_t (Size: 0x4)
LootObjExpTableRow.subtype = 0xc // int32_t (Size: 0x4)
LootObjExpTableRow.loot_exp = 0x10 // int32_t (Size: 0x4)
LootPoolConfTableRow.play_mode_id = 0x8 // uint32_t (Size: 0x4)
LootPoolConfTableRow.loot_pool = 0xc // uint32_t (Size: 0x4)
LootProtectionConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootProtectionConfTableRow.ProtectionType = 0xc // uint32_t (Size: 0x4)
LootProtectionConfTableRow.ProtectionTime = 0x10 // float (Size: 0x4)
LootProtectionItemsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootProtectionItemsConfTableRow.item_id = 0xc // uint32_t (Size: 0x4)
LootReplaceConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootReplaceConfTableRow.is_consumable = 0xc // uint32_t (Size: 0x4)
LootReplaceConfTableRow.shield_type = 0x10 // uint32_t (Size: 0x4)
LootReplaceConfTableRow.sub_item_id = 0x14 // uint32_t (Size: 0x4)
LootReplaceConfTableRow.sub_item_num = 0x18 // uint32_t (Size: 0x4)
LootReplaceConfTableRow.need_sub_items = 0x1c // uint32_t (Size: 0x4)
LootReplaceConfTableRow.sub_scav_items = 0x20 // TArray<FCommonItemConfItem> (Size: 0x10)
LootResourceConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LootResourceConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
LootResourceConfTableRow.rare = 0x10 // uint8_t (Size: 0x1)
LootResourceConfTableRow.Priority = 0x11 // uint8_t (Size: 0x1)
LoseDropConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LotteryPoolGuaranteeConf.pool_id = 0x0 // uint32_t (Size: 0x4)
LotteryPoolGuaranteeConf.guarantee_hit = 0x4 // uint32_t (Size: 0x4)
LotteryStepPriceConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
LotteryStepPriceConfTableRow.lottery_step_price = 0x10 // TArray<uint32_t> (Size: 0x10)
LuckyLimitContainerTableRow.lootpoint_type_id = 0x8 // uint32_t (Size: 0x4)
MagazineBulletPack.item_id = 0x0 // uint32_t (Size: 0x4)
MagazineBulletPack.Num = 0x4 // uint32_t (Size: 0x4)
MailConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MailConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
MailConfTableRow.Title = 0x10 // FText (Size: 0x18)
MailConfTableRow.Content = 0x28 // FText (Size: 0x18)
MailConfTableRow.sender_type = 0x40 // uint32_t (Size: 0x4)
MailConfTableRow.sender = 0x48 // FText (Size: 0x18)
MailConfTableRow.sender_id = 0x60 // uint32_t (Size: 0x4)
MailConfTableRow.sender_head = 0x68 // FText (Size: 0x18)
MailConfTableRow.expire_time = 0x80 // uint32_t (Size: 0x4)
MailConfTableRow.expire_date = 0x88 // FDateTime (Size: 0x8)
MailConfTableRow.auto_delete = 0x90 // uint32_t (Size: 0x4)
MailConfTableRow.auto_award = 0x94 // uint32_t (Size: 0x4)
MailConfTableRow.auto_read = 0x98 // uint32_t (Size: 0x4)
MailConfTableRow.auto_suit_reward = 0x9c // uint32_t (Size: 0x4)
MailConfTableRow.through_season = 0xa0 // uint32_t (Size: 0x4)
MailConfTableRow.account_channel_type = 0xa8 // TArray<uint32_t> (Size: 0x10)
MailConfTableRow.client_plat_type = 0xb8 // TArray<uint32_t> (Size: 0x10)
MailConfTableRow.client_version_low = 0xc8 // FString (Size: 0x10)
MailConfTableRow.client_version_up = 0xd8 // FString (Size: 0x10)
MailConfTableRow.link_type = 0xe8 // uint32_t (Size: 0x4)
MailConfTableRow.link_dest = 0xf0 // FText (Size: 0x18)
MailConfTableRow.link_params = 0x108 // FString (Size: 0x10)
MailConfTableRow.link_text = 0x118 // FText (Size: 0x18)
MailConfTableRow.awards = 0x130 // TArray<FBlackItemConf> (Size: 0x10)
MailConfTableRow.mutil_lang_content_url = 0x140 // FString (Size: 0x10)
MailConfTableRow.country_group_id = 0x150 // uint32_t (Size: 0x4)
MailTypeConfTableRow.Type = 0x8 // uint32_t (Size: 0x4)
MailTypeConfTableRow.is_stage = 0xc // uint32_t (Size: 0x4)
MailTypeConfTableRow.mail_max_count = 0x10 // uint32_t (Size: 0x4)
MailTypeConfTableRow.extend_max_size = 0x14 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.show_order = 0x8 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child_len = 0xc // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.root_task_id = 0x10 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child1 = 0x14 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child2 = 0x18 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child3 = 0x1c // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child4 = 0x20 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child5 = 0x24 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child6 = 0x28 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child7 = 0x2c // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child8 = 0x30 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child9 = 0x34 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child10 = 0x38 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child11 = 0x3c // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child12 = 0x40 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child13 = 0x44 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child14 = 0x48 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child15 = 0x4c // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child16 = 0x50 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child17 = 0x54 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child18 = 0x58 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child19 = 0x5c // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child20 = 0x60 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child21 = 0x64 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child22 = 0x68 // uint32_t (Size: 0x4)
MainTaskTreeConfTableRow.child23 = 0x6c // uint32_t (Size: 0x4)
MallClassConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallClassConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
MallClassConfTableRow.Name = 0x10 // FText (Size: 0x18)
MallClassConfTableRow.parent_class = 0x28 // uint32_t (Size: 0x4)
MallClassConfTableRow.icon = 0x30 // FString (Size: 0x10)
MallClassConfTableRow.PageType = 0x40 // FString (Size: 0x10)
MallClassConfTableRow.parent_hide_empty = 0x50 // uint32_t (Size: 0x4)
MallClassConfTableRow.is_hide = 0x54 // uint32_t (Size: 0x4)
MallClassConfTableRow.begin_time = 0x58 // FDateTime (Size: 0x8)
MallClassConfTableRow.end_time = 0x60 // FDateTime (Size: 0x8)
MallClassConfTableRow.show_empty = 0x68 // uint32_t (Size: 0x4)
MallClassConfTableRow.red_point_id = 0x6c // uint32_t (Size: 0x4)
MallClassConfTableRow.display_order = 0x70 // uint32_t (Size: 0x4)
MallClassConfTableRow.banner_list = 0x78 // TArray<FClassBanner> (Size: 0x10)
MallDiscountDescConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallDiscountDescConfTableRow.lower_bound = 0xc // uint32_t (Size: 0x4)
MallDiscountDescConfTableRow.upper_bound = 0x10 // uint32_t (Size: 0x4)
MallDiscountDescConfTableRow.desc = 0x18 // FText (Size: 0x18)
MallItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallItemConfTableRow.jump_id = 0xc // uint32_t (Size: 0x4)
MallItemConfTableRow.first_class_order = 0x10 // uint32_t (Size: 0x4)
MallItemConfTableRow.second_class_order = 0x14 // uint32_t (Size: 0x4)
MallItemConfTableRow.third_class_order = 0x18 // uint32_t (Size: 0x4)
MallItemConfTableRow.item_tag = 0x1c // uint32_t (Size: 0x4)
MallItemConfTableRow.Seq = 0x20 // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_item_id = 0x24 // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_num = 0x28 // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_group_id = 0x2c // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_suit_id = 0x30 // uint32_t (Size: 0x4)
MallItemConfTableRow.can_multi_sell = 0x34 // uint32_t (Size: 0x4)
MallItemConfTableRow.purchase_id = 0x38 // uint32_t (Size: 0x4)
MallItemConfTableRow.is_black = 0x3c // uint32_t (Size: 0x4)
MallItemConfTableRow.exchange_item_id = 0x40 // uint32_t (Size: 0x4)
MallItemConfTableRow.exchange_num = 0x44 // uint32_t (Size: 0x4)
MallItemConfTableRow.discount_exchange_num = 0x48 // uint32_t (Size: 0x4)
MallItemConfTableRow.discount_begin_time = 0x50 // FDateTime (Size: 0x8)
MallItemConfTableRow.discount_end_time = 0x58 // FDateTime (Size: 0x8)
MallItemConfTableRow.promotion_id = 0x60 // uint32_t (Size: 0x4)
MallItemConfTableRow.promotion_offset = 0x64 // uint32_t (Size: 0x4)
MallItemConfTableRow.daily_differential_exchange_count_array = 0x68 // TArray<uint32_t> (Size: 0x10)
MallItemConfTableRow.daily_differential_exchange_num_array = 0x78 // TArray<uint32_t> (Size: 0x10)
MallItemConfTableRow.pre_begin_time = 0x88 // FDateTime (Size: 0x8)
MallItemConfTableRow.pre_end_time = 0x90 // FDateTime (Size: 0x8)
MallItemConfTableRow.begin_time = 0x98 // FDateTime (Size: 0x8)
MallItemConfTableRow.end_time = 0xa0 // FDateTime (Size: 0x8)
MallItemConfTableRow.quality = 0xa8 // uint32_t (Size: 0x4)
MallItemConfTableRow.preview_mode = 0xac // uint32_t (Size: 0x4)
MallItemConfTableRow.tag_list = 0xb0 // TArray<FTag> (Size: 0x10)
MallItemConfTableRow.first_sell_point = 0xc0 // uint32_t (Size: 0x4)
MallItemConfTableRow.second_sell_point = 0xc4 // uint32_t (Size: 0x4)
MallItemConfTableRow.third_sell_point = 0xc8 // uint32_t (Size: 0x4)
MallItemConfTableRow.fourth_sell_point = 0xcc // uint32_t (Size: 0x4)
MallItemConfTableRow.buy_limit = 0xd0 // uint32_t (Size: 0x4)
MallItemConfTableRow.buy_limit_num = 0xd4 // uint32_t (Size: 0x4)
MallItemConfTableRow.need_vip_level = 0xd8 // uint32_t (Size: 0x4)
MallItemConfTableRow.URL = 0xe0 // FString (Size: 0x10)
MallItemConfTableRow.need_version = 0xf0 // FString (Size: 0x10)
MallItemConfTableRow.is_backup = 0x100 // uint32_t (Size: 0x4)
MallItemConfTableRow.country_group_id = 0x104 // uint32_t (Size: 0x4)
MallItemConfTableRow.is_quick_give = 0x108 // uint32_t (Size: 0x4)
MallItemConfTableRow.need_level = 0x10c // uint32_t (Size: 0x4)
MallItemConfTableRow.need_bp_vip = 0x110 // uint32_t (Size: 0x4)
MallItemConfTableRow.need_bp_level = 0x114 // uint32_t (Size: 0x4)
MallItemConfTableRow.front_id = 0x118 // uint32_t (Size: 0x4)
MallItemConfTableRow.grade_id = 0x11c // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_channel = 0x120 // uint32_t (Size: 0x4)
MallItemConfTableRow.sell_channel_value = 0x124 // uint32_t (Size: 0x4)
MallItemConfTableRow.Style = 0x128 // FString (Size: 0x10)
MallItemHighlightsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallItemHighlightsConfTableRow.Name = 0x10 // FText (Size: 0x18)
MallItemHighlightsConfTableRow.icon = 0x28 // FString (Size: 0x10)
MallItemQualityConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallItemQualityConfTableRow.quality_RGB = 0x10 // TArray<uint32_t> (Size: 0x10)
MallItemTagConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallItemTagConfTableRow.Name = 0x10 // FText (Size: 0x18)
MallTagConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MallTagConfTableRow.Name = 0x10 // FText (Size: 0x18)
MapBanTaskConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MapBanTaskConfTableRow.banned_task_types = 0x10 // TArray<int32_t> (Size: 0x10)
MapDetailTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MapDetailTableRow.map_level = 0x10 // FText (Size: 0x18)
MapDetailTableRow.mobile_map_level = 0x28 // FString (Size: 0x10)
MapDetailTableRow.Name = 0x38 // FText (Size: 0x18)
MapDetailTableRow.level_path = 0x50 // FString (Size: 0x10)
MapDetailTableRow.Picture = 0x60 // FText (Size: 0x18)
MapDetailTableRow.desc = 0x78 // FText (Size: 0x18)
MapDetailTableRow.MapSize = 0x90 // FVector2D (Size: 0x8)
MapDetailTableRow.SampleScenePoints = 0x98 // TArray<FVector2D> (Size: 0x10)
MapDetailTableRow.SampleMapPoints = 0xa8 // TArray<FVector2D> (Size: 0x10)
MapGroupConfTableRow.group_id = 0x8 // uint32_t (Size: 0x4)
MapGroupConfTableRow.group_type = 0xc // uint32_t (Size: 0x4)
MapGroupConfTableRow.show_name = 0x10 // FText (Size: 0x18)
MapGroupConfTableRow.show_name_type = 0x28 // uint32_t (Size: 0x4)
MapGroupConfTableRow.desc = 0x30 // FText (Size: 0x18)
MapGroupConfTableRow.role_type = 0x48 // uint32_t (Size: 0x4)
MapGroupConfTableRow.game_mode = 0x4c // uint32_t (Size: 0x4)
MapGroupConfTableRow.sub_mode_id = 0x50 // uint32_t (Size: 0x4)
MapGroupConfTableRow.rule_id = 0x54 // uint32_t (Size: 0x4)
MapGroupConfTableRow.map_plug = 0x58 // uint32_t (Size: 0x4)
MapGroupConfTableRow.sub_group_id = 0x60 // TArray<uint32_t> (Size: 0x10)
MapGroupConfTableRow.map_show_type = 0x70 // uint32_t (Size: 0x4)
MapGroupConfTableRow.sub_map_id = 0x78 // TArray<uint32_t> (Size: 0x10)
MapGroupConfTableRow.show_empty = 0x88 // uint32_t (Size: 0x4)
MapGroupConfTableRow.jump_goto = 0x8c // uint32_t (Size: 0x4)
MapGroupConfTableRow.hovertips = 0x90 // FText (Size: 0x18)
MapGroupConfTableRow.show_recycle = 0xa8 // uint32_t (Size: 0x4)
MapGroupConfTableRow.show_navigation_bar = 0xac // uint32_t (Size: 0x4)
MapGroupConfTableRow.ban_sysid_list = 0xb0 // TArray<uint32_t> (Size: 0x10)
MapGroupConfTableRow.sys_enable_list = 0xc0 // TArray<uint32_t> (Size: 0x10)
MapGroupConfTableRow.openWareHouseWhenWin = 0xd0 // uint32_t (Size: 0x4)
MapLayoutTableRow.mapunlock_id = 0x8 // uint32_t (Size: 0x4)
MapLayoutTableRow.select_list = 0x10 // FString (Size: 0x10)
MapNewsInfoTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MapNewsInfoTableRow.Title = 0x10 // FString (Size: 0x10)
MapNewsInfoTableRow.desc = 0x20 // FString (Size: 0x10)
MapNewsInfoTableRow.pic = 0x30 // FString (Size: 0x10)
MapNewsInfoTableRow.show_open_time = 0x40 // FString (Size: 0x10)
MapNewsInfoTableRow.show_daily_time = 0x50 // FString (Size: 0x10)
MapNewsInfoTableRow.Order = 0x60 // uint32_t (Size: 0x4)
MapNewsInfoTableRow.mapunlockId = 0x64 // uint32_t (Size: 0x4)
MapNewsInfoTableRow.isPop = 0x68 // bool (Size: 0x1)
MapNewsInfoTableRow.pop_order = 0x6c // uint32_t (Size: 0x4)
MapUnlockTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MapUnlockTableRow.mode_id = 0xc // uint32_t (Size: 0x4)
MapUnlockTableRow.sub_mod_id = 0x10 // uint32_t (Size: 0x4)
MapUnlockTableRow.map_id = 0x14 // uint32_t (Size: 0x4)
MapUnlockTableRow.rule_id = 0x18 // uint32_t (Size: 0x4)
MapUnlockTableRow.ShowName = 0x20 // FText (Size: 0x18)
MapUnlockTableRow.ShowIndex = 0x38 // uint32_t (Size: 0x4)
MapUnlockTableRow.helpJumpId = 0x3c // uint32_t (Size: 0x4)
MapUnlockTableRow.unlock_type = 0x40 // uint32_t (Size: 0x4)
MapUnlockTableRow.unlock_param = 0x48 // TArray<uint64_t> (Size: 0x10)
MapUnlockTableRow.ticket = 0x58 // uint32_t (Size: 0x4)
MapUnlockTableRow.ticket_cash = 0x5c // uint32_t (Size: 0x4)
MapUnlockTableRow.is_scav_unlock = 0x60 // uint32_t (Size: 0x4)
MapUnlockTableRow.is_golden_scav_unlock = 0x64 // uint32_t (Size: 0x4)
MapUnlockTableRow.act_ticket = 0x68 // uint32_t (Size: 0x4)
MapUnlockTableRow.act_id = 0x6c // uint32_t (Size: 0x4)
MapUnlockTableRow.take_in_threshold = 0x70 // uint32_t (Size: 0x4)
MapUnlockTableRow.take_in_value_limit = 0x74 // uint32_t (Size: 0x4)
MapUnlockTableRow.stash_value_limit_lower = 0x78 // uint64_t (Size: 0x8)
MapUnlockTableRow.stash_value_limit_upper = 0x80 // uint64_t (Size: 0x8)
MapUnlockTableRow.sysIds = 0x88 // FString (Size: 0x10)
MapUnlockTableRow.intelligence = 0x98 // uint32_t (Size: 0x4)
MapUnlockTableRow.map_picture = 0x9c // uint32_t (Size: 0x4)
MapUnlockTableRow.map_mini_picture = 0xa0 // uint32_t (Size: 0x4)
MapUnlockTableRow.typeIcon = 0xa8 // FString (Size: 0x10)
MapUnlockTableRow.map_bg_name = 0xb8 // FString (Size: 0x10)
MapUnlockTableRow.ranked_level_limit = 0xc8 // uint32_t (Size: 0x4)
MapUnlockTableRow.map_desc = 0xd0 // FText (Size: 0x18)
MapUnlockTableRow.lock_reason = 0xe8 // TArray<FText> (Size: 0x10)
MapUnlockTableRow.item_take_in_limit = 0xf8 // uint32_t (Size: 0x4)
MapUnlockTableRow.wealth_elo_map_mode_id = 0xfc // uint32_t (Size: 0x4)
MapUnlockTableRow.wealth_elo_system_harvest_ratio = 0x100 // int32_t (Size: 0x4)
MapUnlockTableRow.map_exp_ratio = 0x104 // uint32_t (Size: 0x4)
MapUnlockTableRow.trans_template_id = 0x108 // uint32_t (Size: 0x4)
MapUnlockTableRow.allow_connect_time = 0x10c // uint32_t (Size: 0x4)
MapUnlockTableRow.transfer_value_rate = 0x110 // int32_t (Size: 0x4)
MapWeatherTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MapWeatherTableRow.cur_weather = 0xc // uint32_t (Size: 0x4)
MapWeatherTableRow.weather_list = 0x10 // TArray<FWeatherRateItem> (Size: 0x10)
MarketRecommendConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MarketRecommendConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
MarketRecommendConfTableRow.Items = 0x10 // TArray<uint32_t> (Size: 0x10)
MarqueeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MarqueeConfTableRow.Content = 0x10 // FString (Size: 0x10)
MatchKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MatchKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
MatchKVConfTableRow.val_array = 0x18 // TArray<int64_t> (Size: 0x10)
MatchKVConfTableRow.begin_time = 0x28 // FDateTime (Size: 0x8)
MatchKVConfTableRow.end_time = 0x30 // FDateTime (Size: 0x8)
MedGuidePageConfTableRow.IndexId = 0x8 // uint32_t (Size: 0x4)
MedGuidePageConfTableRow.icon = 0x10 // FString (Size: 0x10)
MedGuidePageConfTableRow.desc = 0x20 // FText (Size: 0x18)
MedGuidePageConfTableRow.CureItemId = 0x38 // TArray<uint64_t> (Size: 0x10)
MedGuidePageConfTableRow.ShowPage = 0x48 // uint32_t (Size: 0x4)
MeleeWeaponDetailTableRow.ItemId = 0x8 // uint64_t (Size: 0x8)
MeleeWeaponDetailTableRow.BaseDamage = 0x10 // TArray<float> (Size: 0x10)
MeleeWeaponDetailTableRow.ArmorDamage = 0x20 // float (Size: 0x4)
MeleeWeaponDetailTableRow.ArmorDamageRatio = 0x24 // float (Size: 0x4)
MeleeWeaponDetailTableRow.BleedChance = 0x28 // float (Size: 0x4)
MeleeWeaponDetailTableRow.EnergyConsume = 0x2c // float (Size: 0x4)
MeleeWeaponDetailTableRow.AttackSpeed = 0x30 // FText (Size: 0x18)
MeleeWeaponDetailTableRow.DamageReduction = 0x48 // TArray<float> (Size: 0x10)
MeleeWeaponDetailTableRow.TraceRange = 0x58 // TArray<float> (Size: 0x10)
MeleeWeaponDetailTableRow.BleedProbabilityDisplay = 0x68 // FText (Size: 0x18)
MeleeWeaponDetailTableRow.TraceRangeDisplay = 0x80 // FText (Size: 0x18)
MeleeWeaponDetailTableRow.MeleeMoveSpeedRatio = 0x98 // float (Size: 0x4)
MeleeWeaponDetailTableRow.DamageScaleHead = 0x9c // float (Size: 0x4)
MeleeWeaponDetailTableRow.DamageScaleArms = 0xa0 // float (Size: 0x4)
MeleeWeaponDetailTableRow.DamageScaleLegs = 0xa4 // float (Size: 0x4)
MeleeWeaponDetailTableRow.DamageScaleStomach = 0xa8 // float (Size: 0x4)
MeleeWeaponDetailTableRow.DamageScaleChest = 0xac // float (Size: 0x4)
MembershipLevelConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
MembershipLevelConfTableRow.need_exp = 0x10 // uint64_t (Size: 0x8)
MembershipLevelConfTableRow.level_exp_limit = 0x18 // uint64_t (Size: 0x8)
MembershipLevelConfTableRow.total_exp = 0x20 // uint64_t (Size: 0x8)
MomentTableRow.MomentId = 0x8 // uint32_t (Size: 0x4)
MomentTableRow.MomentTitle = 0x10 // FText (Size: 0x18)
MomentTableRow.Proportion = 0x28 // uint32_t (Size: 0x4)
MomentTableRow.Describe = 0x30 // FText (Size: 0x18)
MomentTableRow.UrlTitle = 0x48 // FText (Size: 0x18)
MomentTableRow.UrlDescribe = 0x60 // FText (Size: 0x18)
MultiModeItemLimitConf.Item_type = 0x0 // uint32_t (Size: 0x4)
MultiModeItemLimitConf.item_type_num = 0x4 // uint32_t (Size: 0x4)
MultiModeItemOutConf.Item_type = 0x0 // uint32_t (Size: 0x4)
MultiModeItemOutConf.item_type_num = 0x4 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.ID = 0x8 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.Name = 0x10 // FText (Size: 0x18)
MultiModeWidgetTableRow.calculate_elo = 0x28 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.elo_type = 0x2c // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.calculate_warm_score = 0x30 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.use_ticket = 0x34 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.need_take_in_threshold = 0x38 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.need_check_weapon_need_teammate = 0x3c // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.default_avatar_set_id = 0x40 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.settle_type = 0x44 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.use_self_equip = 0x48 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.ban_use_elite_suite = 0x4c // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.ban_use_lend_item = 0x50 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.use_self_avatar = 0x54 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.show_wash_white = 0x58 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.block_item_back_mail = 0x5c // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.is_take_in_key = 0x60 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.need_refresh_safe_box = 0x64 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.use_spray = 0x68 // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.bind_faction_id = 0x6c // uint32_t (Size: 0x4)
MultiModeWidgetTableRow.ignore_stat = 0x70 // uint32_t (Size: 0x4)
MusicLobbyDefaultConfTableRow.music_id = 0x8 // uint32_t (Size: 0x4)
MusicLobbyDefaultConfTableRow.abs_begin_time = 0x10 // FDateTime (Size: 0x8)
NationalFlagConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
NationalFlagConfTableRow.country_alpha = 0x10 // FText (Size: 0x18)
NationalFlagConfTableRow.country_img_url = 0x28 // FText (Size: 0x18)
NeedItemRef.has_items = 0x0 // TArray<uint32_t> (Size: 0x10)
NeedItemRef.desc = 0x10 // FText (Size: 0x18)
NeedItemRef.need_num = 0x28 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.Period = 0xc // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.begin_week_day = 0x10 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.begin_time = 0x18 // FText (Size: 0x18)
NetbarPrivilegeConfTableRow.end_week_day = 0x30 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.end_time = 0x38 // FText (Size: 0x18)
NetbarPrivilegeConfTableRow.safe_box_id = 0x50 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.Exp = 0x54 // uint32_t (Size: 0x4)
NetbarPrivilegeConfTableRow.avatar_id = 0x58 // TArray<uint32_t> (Size: 0x10)
NewActivityLootDropInfoConf.activity_id = 0x0 // uint32_t (Size: 0x4)
NewActivityLootDropInfoConf.activity_weight = 0x4 // uint32_t (Size: 0x4)
NewActivityLootDropInfoConf.in_game_time = 0x8 // uint32_t (Size: 0x4)
NewActivityLootDropInfoConf.Weather = 0xc // uint32_t (Size: 0x4)
NewActivityLootDropInfoConf.pool_id = 0x10 // TArray<uint32_t> (Size: 0x10)
NewbieLevelTableRow.newbie_level = 0x8 // uint32_t (Size: 0x4)
ObBusinessmanBasicConfTableRow.businessman_id = 0x8 // uint32_t (Size: 0x4)
ObBusinessmanBasicConfTableRow.businessman_loyalty = 0xc // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.are_all_tasks_done = 0x10 // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.bullion = 0x14 // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.gold = 0x18 // uint32_t (Size: 0x4)
ObRegistBasicConfTableRow.whether_start_rookie = 0x1c // uint32_t (Size: 0x4)
ObRegistEquipConfTableRow.Index = 0x8 // uint32_t (Size: 0x4)
ObRegistEquipConfTableRow.item_id = 0xc // uint32_t (Size: 0x4)
ObRegistEquipConfTableRow.Num = 0x10 // uint32_t (Size: 0x4)
ObRegistEquipConfTableRow.is_black = 0x14 // uint32_t (Size: 0x4)
ObRegistEquipConfTableRow.Items = 0x18 // TArray<FBlackItemConf> (Size: 0x10)
ObResetEquipConfTableRow.Index = 0x8 // uint32_t (Size: 0x4)
ObResetEquipConfTableRow.item_id = 0xc // uint32_t (Size: 0x4)
ObResetEquipConfTableRow.Num = 0x10 // uint32_t (Size: 0x4)
ObResetEquipConfTableRow.is_black = 0x14 // uint32_t (Size: 0x4)
ObResetEquipConfTableRow.Items = 0x18 // TArray<FBlackItemConf> (Size: 0x10)
OnShelfConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
OnShelfConfTableRow.on_the_shelf = 0xc // uint32_t (Size: 0x4)
OpenMapModeConf.map_mode_id = 0x0 // uint32_t (Size: 0x4)
OpenMapModeConf.time_seg = 0x4 // uint32_t (Size: 0x4)
OrderKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
OrderKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
OtherDetailConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
OtherDetailConfTableRow.AssembleTag = 0x10 // FString (Size: 0x10)
OtherDetailConfTableRow.SubAssembleTag = 0x20 // FString (Size: 0x10)
OtherDetailConfTableRow.slot_type = 0x30 // uint64_t (Size: 0x8)
OtherDetailConfTableRow.sub_slot_type = 0x38 // uint64_t (Size: 0x8)
OtherDetailConfTableRow.Sockets = 0x40 // TArray<FWeaponSocket> (Size: 0x10)
OverConsumptionValueTableRow.Item_type = 0x8 // uint32_t (Size: 0x4)
OverConsumptionValueTableRow.type_name = 0x10 // FText (Size: 0x18)
OverConsumptionValueTableRow.over_consumption_value = 0x28 // uint32_t (Size: 0x4)
OverSaleLackFundTableRow.lack_fund_wealth1 = 0x8 // uint32_t (Size: 0x4)
OverSaleLackFundTableRow.lack_fund_wealth2 = 0xc // uint32_t (Size: 0x4)
OverSaleLackFundTableRow.lack_fund_cash = 0x10 // uint32_t (Size: 0x4)
OverSaleLackFundTableRow.lack_fund_mud = 0x14 // uint32_t (Size: 0x4)
OverSaleLackFundTableRow.lack_fund_gold = 0x18 // uint32_t (Size: 0x4)
OverSaleNewbieLevelTableRow.newbie_level = 0x8 // uint32_t (Size: 0x4)
OverSaleValueTableRow.Item_type = 0x8 // uint32_t (Size: 0x4)
OverSaleValueTableRow.type_name = 0x10 // FText (Size: 0x18)
OverSaleValueTableRow.sale_warning_message = 0x28 // FText (Size: 0x18)
OverSaleValueTableRow.sale_warning_advice = 0x40 // FText (Size: 0x18)
PMCAIEquipmentLimit.EquipID = 0x0 // int32_t (Size: 0x4)
PMCAIEquipmentLimit.Limit = 0x4 // int32_t (Size: 0x4)
PMCAIEquipmentLimit.BackupID = 0x8 // int32_t (Size: 0x4)
PPTPageConfTableRow.pageID = 0x8 // uint32_t (Size: 0x4)
PPTPageConfTableRow.umgPath = 0xc // uint32_t (Size: 0x4)
PPTPageConfTableRow.animations = 0x10 // TArray<FString> (Size: 0x10)
PPTPageConfTableRow.showDesc = 0x20 // uint32_t (Size: 0x4)
PPTPageConfTableRow.Title = 0x28 // FText (Size: 0x18)
PPTPageConfTableRow.desc = 0x40 // FText (Size: 0x18)
PaybackConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PaybackConfTableRow.payback_base_value = 0xc // uint32_t (Size: 0x4)
PaybackConfTableRow.payback_max_single_value = 0x10 // uint32_t (Size: 0x4)
PaybackConfTableRow.is_protected = 0x14 // uint32_t (Size: 0x4)
PaybackConfTableRow.min_protect_level = 0x18 // uint32_t (Size: 0x4)
PaybackConfTableRow.payback_ratio = 0x1c // uint32_t (Size: 0x4)
PaybackConfTableRow.inflation_ratio = 0x20 // TArray<FInflationRatio> (Size: 0x10)
PersonalBattleOverviewTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.ShowName = 0x10 // FText (Size: 0x18)
PersonalBattleOverviewTableRow.Name = 0x28 // FString (Size: 0x10)
PersonalBattleOverviewTableRow.Format = 0x38 // FString (Size: 0x10)
PersonalBattleOverviewTableRow.suffix = 0x48 // FText (Size: 0x18)
PersonalBattleOverviewTableRow.desc = 0x60 // FText (Size: 0x18)
PersonalBattleOverviewTableRow.CaculateType = 0x78 // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.Show = 0x7c // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.Category = 0x80 // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.OuterWeight = 0x84 // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.SubCategory = 0x88 // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.Weight = 0x8c // uint32_t (Size: 0x4)
PersonalBattleOverviewTableRow.AppendId = 0x90 // TArray<uint64_t> (Size: 0x10)
PersonalBattleOverviewTableRow.ClientAppendId = 0xa0 // FString (Size: 0x10)
PersonalRadarFactorTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PersonalRadarFactorTableRow.MapCoefficient = 0xc // float (Size: 0x4)
PersonalRadarFactorTableRow.IsSegment = 0x10 // uint32_t (Size: 0x4)
PersonalRadarFactorTableRow.RadarType = 0x14 // uint32_t (Size: 0x4)
PersonalRadarFactorTableRow.RadarDataSourceType = 0x18 // uint32_t (Size: 0x4)
PersonalRadarFactorTableRow.AppendId = 0x20 // FText (Size: 0x18)
PersonalRadarFactorTableRow.Coefficient = 0x38 // uint32_t (Size: 0x4)
PersonalRadarFactorTableRow.ConvertId = 0x3c // uint32_t (Size: 0x4)
PersonalRadarMapTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PersonalRadarMapTableRow.score_list = 0x10 // TArray<float> (Size: 0x10)
PlanEquipItem.item_id = 0x0 // uint32_t (Size: 0x4)
PlanEquipItem.Num = 0x4 // uint32_t (Size: 0x4)
PlanEquipItem.is_rotate = 0x8 // uint32_t (Size: 0x4)
PlanEquipItem.Index = 0xc // uint32_t (Size: 0x4)
PlanEquipItem.pos_x = 0x10 // uint32_t (Size: 0x4)
PlanEquipItem.pos_y = 0x14 // uint32_t (Size: 0x4)
PlayModeRewardConf.main_mode_id = 0x0 // int32_t (Size: 0x4)
PlayModeRewardConf.sub_mode_id = 0x4 // int32_t (Size: 0x4)
PlayModeRewardConf.map_id = 0x8 // int32_t (Size: 0x4)
PlayModeRewardConf.special_id = 0xc // int32_t (Size: 0x4)
PlayModeRewardConf.Difficulty = 0x10 // int32_t (Size: 0x4)
PlayModeRewardConf.gift_ruble = 0x14 // uint32_t (Size: 0x4)
PlayModeTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PlayModeTableRow.mode_id = 0xc // uint32_t (Size: 0x4)
PlayModeTableRow.sub_mod_id = 0x10 // uint32_t (Size: 0x4)
PlayModeTableRow.map_id = 0x14 // uint32_t (Size: 0x4)
PlayModeTableRow.rule_id = 0x18 // uint32_t (Size: 0x4)
PlayModeTableRow.difficult = 0x1c // uint32_t (Size: 0x4)
PlayModeTableRow.Time = 0x20 // uint32_t (Size: 0x4)
PlayModeTableRow.base_time = 0x24 // uint32_t (Size: 0x4)
PlayModeTableRow.day_start_time = 0x28 // uint32_t (Size: 0x4)
PlayModeTableRow.day_end_time = 0x2c // uint32_t (Size: 0x4)
PlayModeTableRow.disable_ingame_timeflow = 0x30 // bool (Size: 0x1)
PlayModeTableRow.time_shift = 0x34 // uint32_t (Size: 0x4)
PlayModeTableRow.min_pmc = 0x38 // uint32_t (Size: 0x4)
PlayModeTableRow.max_pmc = 0x3c // uint32_t (Size: 0x4)
PlayModeTableRow.max_pmc_team = 0x40 // uint32_t (Size: 0x4)
PlayModeTableRow.pmc_team_num = 0x44 // uint32_t (Size: 0x4)
PlayModeTableRow.scav_team_num = 0x48 // uint32_t (Size: 0x4)
PlayModeTableRow.NormalBeginTime = 0x4c // uint32_t (Size: 0x4)
PlayModeTableRow.NormalBeginPersonNum = 0x50 // uint32_t (Size: 0x4)
PlayModeTableRow.LongTimeBeginTime = 0x54 // uint32_t (Size: 0x4)
PlayModeTableRow.LongTimeBeginPersonNum = 0x58 // uint32_t (Size: 0x4)
PlayModeTableRow.TimeoutTime = 0x5c // uint32_t (Size: 0x4)
PlayModeTableRow.SpawnAIPersonPercent = 0x60 // uint32_t (Size: 0x4)
PlayModeTableRow.UnprotectAllPlayerTime = 0x64 // uint32_t (Size: 0x4)
PlayModeTableRow.MaxProtectPlayerTime = 0x68 // uint32_t (Size: 0x4)
PlayModeTableRow.prefer_score = 0x6c // uint32_t (Size: 0x4)
PlayModeTableRow.ds_tick_rate = 0x70 // uint32_t (Size: 0x4)
PlayModeTableRow.Dynamic_Light = 0x74 // uint32_t (Size: 0x4)
PlayModeTableRow.Intelligence_Weight = 0x78 // uint32_t (Size: 0x4)
PlayModeTableRow.DSNetTickRate = 0x7c // int32_t (Size: 0x4)
PlayerAvatarPopupMenuButtonTableRow.ID = 0x8 // uint16_t (Size: 0x2)
PlayerAvatarPopupMenuButtonTableRow.DisplayName = 0x10 // FText (Size: 0x18)
PlayerAvatarPopupMenuButtonTableRow.IconName = 0x28 // FString (Size: 0x10)
PlayerAvatarPopupMenuButtonTableRow.displayType = 0x38 // uint8_t (Size: 0x1)
PlayerAvatarPopupMenuButtonTableRow.ExecFunc = 0x40 // FString (Size: 0x10)
PlayerAvatarPopupMenuButtonTableRow.ForbiddenMode = 0x50 // TArray<uint16_t> (Size: 0x10)
PlayerAvatarPopupMenuTableRow.ID = 0x8 // uint16_t (Size: 0x2)
PlayerAvatarPopupMenuTableRow.Type = 0xc // uint32_t (Size: 0x4)
PlayerAvatarPopupMenuTableRow.sub_type = 0x10 // uint32_t (Size: 0x4)
PlayerAvatarPopupMenuTableRow.ButtonTypes = 0x18 // TArray<uint16_t> (Size: 0x10)
PlayerAvatarPopupMenuTableRow.InviteTeamType = 0x28 // uint32_t (Size: 0x4)
PlayerAvatarPopupMenuTableRow.AddFriendType = 0x2c // uint32_t (Size: 0x4)
PlayerLevelConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
PlayerLevelConfTableRow.Version = 0xc // uint32_t (Size: 0x4)
PlayerLevelConfTableRow.rewards = 0x10 // TArray<FLevelRewardConf> (Size: 0x10)
PlayerLevelConfTableRow.funcs = 0x20 // TArray<FLevelFuncConf> (Size: 0x10)
PlayerListTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PlayerListTableRow.Name = 0x10 // FText (Size: 0x18)
PlayerListTableRow.Type = 0x28 // uint32_t (Size: 0x4)
PlayerListTableRow.DefaultValue = 0x2c // uint32_t (Size: 0x4)
PlayerListTableRow.Param1 = 0x30 // FString (Size: 0x10)
PlayerListTableRow.OptionsName = 0x40 // FText (Size: 0x18)
PlayerNamePoolTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PlayerNamePoolTableRow.Group = 0xc // uint32_t (Size: 0x4)
PlayerNamePoolTableRow.Name = 0x10 // FText (Size: 0x18)
PmcAiConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PmcAiConfTableRow.Openid = 0x10 // uint64_t (Size: 0x8)
PmcAiConfTableRow.Level = 0x18 // uint32_t (Size: 0x4)
PmcAiConfTableRow.Name = 0x20 // FString (Size: 0x10)
PmcAiLimitItemConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
PmcAiLimitItemConfTableRow.limit_rate = 0xc // uint32_t (Size: 0x4)
PmcAiLimitItemConfTableRow.limit_source_array = 0x10 // TArray<uint32_t> (Size: 0x10)
PoolLimitValueTableRow.pool_id = 0x8 // uint32_t (Size: 0x4)
PoolLimitValueTableRow.value_limit = 0xc // uint32_t (Size: 0x4)
PreTaskId.task_id = 0x0 // uint32_t (Size: 0x4)
PriceConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PriceConfTableRow.Price = 0xc // uint32_t (Size: 0x4)
PrivilegeBubbleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PrivilegeBubbleConfTableRow.vip_id = 0xc // uint32_t (Size: 0x4)
PrivilegeBubbleConfTableRow.bubble_type = 0x10 // uint32_t (Size: 0x4)
PrivilegeBubbleConfTableRow.bubble_pos_x = 0x14 // float (Size: 0x4)
PrivilegeBubbleConfTableRow.bubble_pos_y = 0x18 // float (Size: 0x4)
PrivilegeBubbleConfTableRow.bubble_des = 0x20 // FText (Size: 0x18)
PrivilegeBubbleConfTableRow.is_work = 0x38 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.cost_num = 0xc // uint32_t (Size: 0x4)
PrivilegeConfTableRow.Duration = 0x10 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.cost_num2 = 0x14 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.duration2 = 0x18 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.icon = 0x20 // FText (Size: 0x18)
PrivilegeConfTableRow.rest_renew_days = 0x38 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.active_card = 0x3c // uint32_t (Size: 0x4)
PrivilegeConfTableRow.renewal_face_pic = 0x40 // FText (Size: 0x18)
PrivilegeConfTableRow.jumpgotoid = 0x58 // uint32_t (Size: 0x4)
PrivilegeConfTableRow.expire_mail_id = 0x5c // uint32_t (Size: 0x4)
PrivilegeConfTableRow.item_list = 0x60 // TArray<uint32_t> (Size: 0x10)
PrivilegeDesConfTableRow.dataid = 0x8 // uint32_t (Size: 0x4)
PrivilegeDesConfTableRow.vip_id = 0xc // uint32_t (Size: 0x4)
PrivilegeDesConfTableRow.display_order = 0x10 // uint32_t (Size: 0x4)
PrivilegeDesConfTableRow.vipsubitem_id = 0x14 // uint32_t (Size: 0x4)
PrivilegeDesConfTableRow.privilegedes = 0x18 // FText (Size: 0x18)
PrivilegeDesConfTableRow.bubbledes = 0x30 // FText (Size: 0x18)
PrivilegeDesConfTableRow.icon_name = 0x48 // FString (Size: 0x10)
PrivilegeItemConfTableRow.active_item = 0x8 // uint32_t (Size: 0x4)
PrivilegeItemConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
PrivilegeItemConfTableRow.get_item = 0x10 // FText (Size: 0x18)
PrivilegeItemConfTableRow.season_get_item = 0x28 // FText (Size: 0x18)
PrivilegeItemConfTableRow.daily_item = 0x40 // FText (Size: 0x18)
PrivilegeItemConfTableRow.week_item = 0x58 // FText (Size: 0x18)
PrivilegeItemConfTableRow.item_ids = 0x70 // TArray<uint32_t> (Size: 0x10)
PrivilegeItemConfTableRow.Value = 0x80 // uint32_t (Size: 0x4)
ProtectionTypeConfTableRow.ProtectionType = 0x8 // uint32_t (Size: 0x4)
ProtectionTypeConfTableRow.ProtectionTime = 0xc // uint32_t (Size: 0x4)
ProtectionTypeConfTableRow.ProtectionDuraction = 0x10 // uint32_t (Size: 0x4)
ProtectionTypeConfTableRow.ForbidInteractProtectionTime = 0x14 // uint32_t (Size: 0x4)
ProvinceConfTableRow.ADCode = 0x8 // uint32_t (Size: 0x4)
ProvinceConfTableRow.ip_show = 0x10 // FString (Size: 0x10)
PurchaseConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
PurchaseConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
PurchaseConfTableRow.is_for_act = 0x10 // uint32_t (Size: 0x4)
PurchaseConfTableRow.product_id = 0x18 // FString (Size: 0x10)
PurchaseConfTableRow.Price = 0x28 // uint32_t (Size: 0x4)
PurchaseConfTableRow.price_us = 0x2c // float (Size: 0x4)
PurchaseConfTableRow.price_extra = 0x30 // uint32_t (Size: 0x4)
PurchaseConfTableRow.item_id = 0x34 // uint32_t (Size: 0x4)
PurchaseConfTableRow.item_num = 0x38 // uint32_t (Size: 0x4)
PurchaseConfTableRow.item_name = 0x40 // FText (Size: 0x18)
PurchaseConfTableRow.item_desc = 0x58 // FText (Size: 0x18)
PurchaseConfTableRow.sell_type = 0x70 // uint32_t (Size: 0x4)
PurchaseConfTableRow.Style = 0x78 // FString (Size: 0x10)
PurchaseConfTableRow.service_code = 0x88 // FText (Size: 0x18)
PurchaseConfTableRow.service_name = 0xa0 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.ID = 0x8 // uint32_t (Size: 0x4)
QuickChatDataStaticsTableRow.Key = 0x10 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.BattleInfoTable = 0x28 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.BattleInfoCalculate = 0x40 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.Format = 0x58 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.Operation = 0x70 // FText (Size: 0x18)
QuickChatDataStaticsTableRow.Factor = 0x88 // uint32_t (Size: 0x4)
QuickChatTableRow.ID = 0x8 // uint32_t (Size: 0x4)
QuickChatTableRow.Content = 0x10 // FText (Size: 0x18)
QuickChatTableRow.isLeader = 0x28 // uint32_t (Size: 0x4)
QuickChatTableRow.isBattleInfo = 0x2c // uint32_t (Size: 0x4)
QuickChatTableRow.BattleInfoField = 0x30 // FText (Size: 0x18)
QuickSortContainerPriorityTableRow.ID = 0x8 // uint32_t (Size: 0x4)
QuickSortContainerPriorityTableRow.Priority = 0xc // uint32_t (Size: 0x4)
RankedAwardShowConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedAwardShowConfTableRow.main_image = 0x10 // FString (Size: 0x10)
RankedAwardShowConfTableRow.core_image = 0x20 // FString (Size: 0x10)
RankedAwardShowConfTableRow.rank_image = 0x30 // FString (Size: 0x10)
RankedBoxConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
RankedBoxConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
RankedBoxConfTableRow.equip_num = 0x10 // uint32_t (Size: 0x4)
RankedBoxConfTableRow.def_num = 0x14 // uint32_t (Size: 0x4)
RankedBoxConfTableRow.use_num = 0x18 // uint32_t (Size: 0x4)
RankedBoxConfTableRow.etc_num = 0x1c // uint32_t (Size: 0x4)
RankedBoxConfTableRow.desc = 0x20 // FText (Size: 0x18)
RankedCommonConfTableRow.Ranked_conf_type = 0x8 // uint32_t (Size: 0x4)
RankedCommonConfTableRow.Val = 0x10 // FString (Size: 0x10)
RankedHistoryInfoConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedHistoryInfoConfTableRow.field_text = 0x10 // FText (Size: 0x18)
RankedHistoryInfoConfTableRow.Field = 0x28 // FString (Size: 0x10)
RankedHistoryInfoConfTableRow.Type = 0x38 // uint32_t (Size: 0x4)
RankedHistoryInfoConfTableRow.Priority = 0x3c // uint32_t (Size: 0x4)
RankedLeaderboardSaleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedLeaderboardSaleConfTableRow.lowindex = 0xc // uint32_t (Size: 0x4)
RankedLeaderboardSaleConfTableRow.Ratio = 0x10 // uint32_t (Size: 0x4)
RankedLevelAwardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedLevelAwardConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
RankedLevelAwardConfTableRow.Level = 0x10 // uint32_t (Size: 0x4)
RankedLevelAwardConfTableRow.task_show_main = 0x14 // uint32_t (Size: 0x4)
RankedLevelAwardConfTableRow.rewards = 0x18 // TArray<FCommonItemConfItem> (Size: 0x10)
RankedLevelConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
RankedLevelConfTableRow.upgrade_score = 0xc // uint32_t (Size: 0x4)
RankedLevelConfTableRow.TitleDesc = 0x10 // FText (Size: 0x18)
RankedLevelConfTableRow.ranking_k_factor = 0x28 // uint32_t (Size: 0x4)
RankedLevelConfTableRow.icon = 0x2c // uint32_t (Size: 0x4)
RankedLevelConfTableRow.nextseason_level = 0x30 // uint32_t (Size: 0x4)
RankedLevelConfTableRow.dogtag_itemid = 0x34 // uint32_t (Size: 0x4)
RankedLevelConfTableRow.ranked_level_type = 0x38 // uint32_t (Size: 0x4)
RankedLevelConfTableRow.Price = 0x3c // uint32_t (Size: 0x4)
RankedLevelRangeConfTableRow.rangeid = 0x8 // uint32_t (Size: 0x4)
RankedLevelRangeConfTableRow.rangecount = 0xc // uint32_t (Size: 0x4)
RankedLevelRangeConfTableRow.StageId = 0x10 // uint32_t (Size: 0x4)
RankedLevelRangeConfTableRow.main_name = 0x18 // FText (Size: 0x18)
RankedLevelRangeConfTableRow.sub_name = 0x30 // FText (Size: 0x18)
RankedMapConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedMapConfTableRow.begin_time = 0x10 // FDateTime (Size: 0x8)
RankedMapConfTableRow.end_time = 0x18 // FDateTime (Size: 0x8)
RankedMapConfTableRow.ranked_map_list = 0x20 // TArray<uint32_t> (Size: 0x10)
RankedMapConfTableRow.factor_list = 0x30 // TArray<uint32_t> (Size: 0x10)
RankedMapConfTableRow.ranked_rulegroup = 0x40 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.Group = 0xc // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.Level = 0x10 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.ranked_level_diff = 0x18 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.bonus_score = 0x28 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.kill_wander_normal_score = 0x38 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.kill_wander_boss_score = 0x3c // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.loot_value_score = 0x40 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.loot_times_score = 0x44 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.survial_score = 0x48 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.assist_kill_score = 0x4c // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.faction_win_score = 0x50 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.round_kill_range = 0x58 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_kill_score = 0x68 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_dead_range = 0x78 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_dead_score = 0x88 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_kd_range = 0x98 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_kd_score = 0xa8 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_win_basescore = 0xb8 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.round_win_scorediff_range = 0xc0 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_win_scorediff_value = 0xd0 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_win_teamrun = 0xe0 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_win_teamrun_value = 0xf0 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_lose_basescore = 0x100 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.round_lose_scorediff_range = 0x108 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_lose_scorediff_value = 0x118 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_lose_teamrun = 0x128 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_lose_teamrun_value = 0x138 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.round_run_score = 0x148 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_kill_range = 0x150 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_kill_score = 0x160 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_dead_range = 0x170 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_dead_score = 0x180 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_kd_range = 0x190 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_kd_score = 0x1a0 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_win_basescore = 0x1b0 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_win_scorediff_range = 0x1b8 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_win_scorediff_value = 0x1c8 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_win_teamrun = 0x1d8 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_win_teamrun_value = 0x1e8 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_lose_basescore = 0x1f8 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_lose_scorediff_range = 0x200 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_lose_scorediff_value = 0x210 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_lose_teamrun = 0x220 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_lose_teamrun_value = 0x230 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_even_basescore = 0x240 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_even_scorediff_range = 0x248 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_even_scorediff_value = 0x258 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_even_teamrun = 0x268 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_even_teamrun_value = 0x278 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_run_score = 0x288 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_lastkill_score = 0x28c // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.tdm_totaldefeat_scorediff_range = 0x290 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.tdm_totaldefeat_scorediff_value = 0x2a0 // TArray<uint32_t> (Size: 0x10)
RankedNewScoreConfTableRow.kill_pmc_score_limit = 0x2b0 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.kill_scav_score_limit = 0x2b4 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.loot_value_score_limit = 0x2b8 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.loot_times_score_limit = 0x2bc // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.survial_score_limit = 0x2c0 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.assist_kill_score_limit = 0x2c4 // uint32_t (Size: 0x4)
RankedNewScoreConfTableRow.penalty_score = 0x2c8 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.chall_coin_factor = 0x2cc // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.chall_coin_bonus = 0x2d0 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.fight_times = 0x2d8 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.fight_times_factor = 0x2e8 // TArray<int32_t> (Size: 0x10)
RankedNewScoreConfTableRow.difficulty_score_factor = 0x2f8 // int32_t (Size: 0x4)
RankedNewScoreConfTableRow.difficulty_penalty_score_factor = 0x2fc // int32_t (Size: 0x4)
RankedOldLevelMappingTableRow.Level = 0x8 // uint32_t (Size: 0x4)
RankedOldLevelMappingTableRow.before_ea_level = 0xc // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.begin_time = 0x10 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.warmup_end_time = 0x18 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.end_time = 0x20 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.carnival_end_time = 0x28 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.season_end_time = 0x30 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.desc = 0x38 // FText (Size: 0x18)
RankedSeasonConfTableRow.is_delay_start = 0x50 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.show_season_id = 0x54 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.season_reward_base = 0x58 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.countdown_time = 0x60 // FDateTime (Size: 0x8)
RankedSeasonConfTableRow.bp_lv_award_group_id = 0x68 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.ranked_lv_award_group_id = 0x6c // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.badge_group_id = 0x70 // uint32_t (Size: 0x4)
RankedSeasonConfTableRow.background_img_2 = 0x78 // FString (Size: 0x10)
RankedSeasonConfTableRow.season_chapter = 0x88 // TArray<FSeasonChapterRef> (Size: 0x10)
RankedSeasonRewardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedSeasonRewardConfTableRow.rewards = 0x10 // TArray<FCommonItemConfItem> (Size: 0x10)
RankedSettleScoreConfTableRow.Level = 0x8 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.kill_pmc_score_limit = 0xc // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.kill_scav_score_limit = 0x10 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.loot_value_score_limit = 0x14 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.loot_times_score_limit = 0x18 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.survial_score_limit = 0x1c // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.assist_kill_score = 0x20 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.assist_kill_score_limit = 0x24 // uint32_t (Size: 0x4)
RankedSettleScoreConfTableRow.penalty_score = 0x28 // int32_t (Size: 0x4)
RankedSettleScoreConfTableRow.chall_coin_factor = 0x2c // int32_t (Size: 0x4)
RankedSettleScoreConfTableRow.chall_coin_bonus = 0x30 // int32_t (Size: 0x4)
RankedTeamScoreConfTableRow.Rank = 0x8 // uint32_t (Size: 0x4)
RankedTeamScoreConfTableRow.Weight = 0xc // uint32_t (Size: 0x4)
RankedTopRankRewardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedTopRankRewardConfTableRow.start_rank = 0xc // uint32_t (Size: 0x4)
RankedTopRankRewardConfTableRow.end_rank = 0x10 // uint32_t (Size: 0x4)
RankedTopRankRewardConfTableRow.rewards = 0x18 // TArray<FCommonItemConfItem> (Size: 0x10)
RankedWeekRewardConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RankedWeekRewardConfTableRow.Level = 0xc // uint32_t (Size: 0x4)
RankedWeekRewardConfTableRow.active_point = 0x10 // uint32_t (Size: 0x4)
RankedWeekRewardConfTableRow.rewards = 0x18 // TArray<FCommonItemConfItem> (Size: 0x10)
RatingConditionConf.expression = 0x0 // FText (Size: 0x18)
RatingConditionConf.Op = 0x18 // uint32_t (Size: 0x4)
RatingConditionConf.Val = 0x20 // int64_t (Size: 0x8)
RayTracingWhitelistTableRow.RowId = 0x8 // uint32_t (Size: 0x4)
RayTracingWhitelistTableRow.GPUName = 0x10 // FString (Size: 0x10)
RechargeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RechargeConfTableRow.recharge_money = 0xc // uint32_t (Size: 0x4)
RechargeConfTableRow.recharge_reward = 0x10 // uint32_t (Size: 0x4)
RecommandSuppliesPack.item_id = 0x0 // uint32_t (Size: 0x4)
RecommandSuppliesPack.Num = 0x4 // uint32_t (Size: 0x4)
RecommendEquipTableRow.Key = 0x8 // uint32_t (Size: 0x4)
RecommendEquipTableRow.group_id = 0xc // uint32_t (Size: 0x4)
RecommendEquipTableRow.Items = 0x10 // TArray<FPlanEquipItem> (Size: 0x10)
RecommendPlanConfTableRow.group_id = 0x8 // uint32_t (Size: 0x4)
RecommendPlanConfTableRow.Name = 0x10 // FText (Size: 0x18)
RecommendPlanConfTableRow.show_index = 0x28 // uint32_t (Size: 0x4)
RecommendPlanConfTableRow.details = 0x30 // FText (Size: 0x18)
RecommendPlanConfTableRow.color_type = 0x48 // uint32_t (Size: 0x4)
RecommendPlanConfTableRow.icon_type = 0x4c // uint32_t (Size: 0x4)
RecommendWeaponItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
RecommendWeaponItemConf.Num = 0x4 // uint32_t (Size: 0x4)
RecommendWeaponItemConf.slot_index = 0x8 // uint32_t (Size: 0x4)
RecommendWeaponItemConf.Parent = 0xc // uint32_t (Size: 0x4)
RecommendWeaponItemConf.parent_idx = 0x10 // uint32_t (Size: 0x4)
RecruitStyleConf.Style = 0x0 // uint32_t (Size: 0x4)
RegionConfTableRow.Region = 0x8 // uint32_t (Size: 0x4)
RegionConfTableRow.Open = 0xc // uint32_t (Size: 0x4)
RegistEquipConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RegistEquipConfTableRow.Index = 0xc // uint32_t (Size: 0x4)
RegistEquipConfTableRow.item_id = 0x10 // uint32_t (Size: 0x4)
RegistEquipConfTableRow.Num = 0x14 // uint32_t (Size: 0x4)
RegistEquipConfTableRow.is_black = 0x18 // uint32_t (Size: 0x4)
RegistEquipConfTableRow.Items = 0x20 // TArray<FBlackItemConf> (Size: 0x10)
RepairDurabilityConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RepairDurabilityConfTableRow.durability_price_conf = 0x10 // TArray<FDurabilityPriceConf> (Size: 0x10)
RepairMaterialConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RepairMaterialConfTableRow.material_name = 0x10 // FText (Size: 0x18)
RepairMaterialConfTableRow.low_repair_coef = 0x28 // float (Size: 0x4)
RepairMaterialConfTableRow.low_tech_coef = 0x2c // float (Size: 0x4)
RepairMaterialConfTableRow.low_repair_businessman_ids = 0x30 // TArray<uint32_t> (Size: 0x10)
RepairMaterialConfTableRow.mid_repair_coef = 0x40 // float (Size: 0x4)
RepairMaterialConfTableRow.mid_tech_coef = 0x44 // float (Size: 0x4)
RepairMaterialConfTableRow.mid_repair_businessman_ids = 0x48 // TArray<uint32_t> (Size: 0x10)
RepairMaterialConfTableRow.high_repair_coef = 0x58 // float (Size: 0x4)
RepairMaterialConfTableRow.high_tech_coef = 0x5c // float (Size: 0x4)
RepairMaterialConfTableRow.high_repair_businessman_ids = 0x60 // TArray<uint32_t> (Size: 0x10)
RepairMaterialConfTableRow.unit_repair_price_coef = 0x70 // float (Size: 0x4)
RepairMaterialConfTableRow.repairability = 0x78 // FText (Size: 0x18)
ReportReasonConfTableRow.reason_id = 0x8 // uint32_t (Size: 0x4)
ReportReasonConfTableRow.Category = 0xc // uint32_t (Size: 0x4)
ReportReasonConfTableRow.use_scene = 0x10 // TArray<uint32_t> (Size: 0x10)
ReportReasonConfTableRow.Content = 0x20 // FText (Size: 0x18)
ReportReasonConfTableRow.desc = 0x38 // FText (Size: 0x18)
ResourceAreaConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ResourceAreaConfTableRow.MapID = 0xc // uint32_t (Size: 0x4)
ResourceAreaConfTableRow.tagid = 0x10 // uint32_t (Size: 0x4)
ResourceAreaConfTableRow.TagName = 0x18 // FText (Size: 0x18)
ResourceAreaConfTableRow.MapVolumeId = 0x30 // uint32_t (Size: 0x4)
ResourceAreaConfTableRow.ShowLootVolumeId = 0x38 // TArray<uint32_t> (Size: 0x10)
ResourceAreaConfTableRow.IsShowAll = 0x48 // uint32_t (Size: 0x4)
ResourceListConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ResourceListConfTableRow.Name = 0x10 // FText (Size: 0x18)
ResourceListConfTableRow.icon = 0x28 // FString (Size: 0x10)
ResourceListConfTableRow.rare = 0x38 // uint8_t (Size: 0x1)
ResourceListConfTableRow.typeId = 0x40 // TArray<uint32_t> (Size: 0x10)
ResourceTypeIconConfTableRow.typeId = 0x8 // uint32_t (Size: 0x4)
ResourceTypeIconConfTableRow.icon = 0x10 // FString (Size: 0x10)
ResourceTypeIconConfTableRow.IsDefault = 0x20 // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.return_type = 0x8 // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.return_time = 0xc // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.return_player_level = 0x10 // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.return_last_days = 0x14 // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.elo_interval = 0x18 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.login_score = 0x28 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.login_tag = 0x38 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.login_decrease_elo = 0x48 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.wealth_elo_interval = 0x58 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.login_decrease_wealth_elo = 0x68 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.match_elo_change_battle_cnt = 0x78 // uint32_t (Size: 0x4)
ReturnTypeConfTableRow.match_elo_change = 0x80 // TArray<uint32_t> (Size: 0x10)
ReturnTypeConfTableRow.match_wealth_elo_change = 0x90 // TArray<uint32_t> (Size: 0x10)
RewardShareConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RewardShareConfTableRow.avatar_set = 0x10 // TArray<uint32_t> (Size: 0x10)
RewardShareConfTableRow.is_after = 0x20 // uint32_t (Size: 0x4)
RewardsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RewardsConfTableRow.rewards = 0x10 // TArray<FBlackItemConf> (Size: 0x10)
RoadmapAwardsConfTableRow.award_id = 0x8 // uint32_t (Size: 0x4)
RoadmapAwardsConfTableRow.season_id = 0xc // uint32_t (Size: 0x4)
RoadmapAwardsConfTableRow.task_num = 0x10 // uint32_t (Size: 0x4)
RoadmapAwardsConfTableRow.rewardgroup_name = 0x18 // FText (Size: 0x18)
RoadmapAwardsConfTableRow.rewardgroup_picture = 0x30 // TArray<uint32_t> (Size: 0x10)
RoadmapAwardsConfTableRow.is_down = 0x40 // uint32_t (Size: 0x4)
RoadmapAwardsConfTableRow.crossover_ID = 0x44 // uint32_t (Size: 0x4)
RoadmapAwardsConfTableRow.awards = 0x48 // TArray<FAwardItemConf> (Size: 0x10)
RobotNamePoolTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RobotNamePoolTableRow.Group = 0xc // uint32_t (Size: 0x4)
RobotNamePoolTableRow.Name = 0x10 // FText (Size: 0x18)
RoleBannerBackgroundConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleBannerBackgroundConfTableRow.is_dynamic = 0xc // uint32_t (Size: 0x4)
RoleBannerBackgroundConfTableRow.jump_goto = 0x10 // uint32_t (Size: 0x4)
RoleBannerBackgroundConfTableRow.no_source_description = 0x18 // FText (Size: 0x18)
RoleBannerBackgroundConfTableRow.is_dynamic_logo = 0x30 // uint32_t (Size: 0x4)
RoleBannerBackgroundConfTableRow.activity_info = 0x38 // FString (Size: 0x10)
RoleBannerCustomDataConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleBannerCustomDataConfTableRow.show_index = 0xc // uint32_t (Size: 0x4)
RoleBannerCustomDataConfTableRow.Name = 0x10 // FText (Size: 0x18)
RoleBannerCustomDataConfTableRow.desc = 0x28 // FText (Size: 0x18)
RoleBannerCustomDataConfTableRow.data_type = 0x40 // TArray<uint32_t> (Size: 0x10)
RoleBannerCustomDataConfTableRow.Format = 0x50 // FString (Size: 0x10)
RoleBannerCustomDataConfTableRow.suffix = 0x60 // FText (Size: 0x18)
RoleBannerDataBGConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleBannerDataBGConfTableRow.is_dynamic = 0xc // uint32_t (Size: 0x4)
RoleBannerDataBGConfTableRow.jump_goto = 0x10 // uint32_t (Size: 0x4)
RoleBannerDataBGConfTableRow.no_source_description = 0x18 // FText (Size: 0x18)
RoleBannerDataBGConfTableRow.is_dynamic_logo = 0x30 // uint32_t (Size: 0x4)
RoleBannerDataBGConfTableRow.activity_info = 0x38 // FString (Size: 0x10)
RoleBannerDefaultBadgeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleBannerFrameConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleBannerFrameConfTableRow.is_dynamic = 0xc // uint32_t (Size: 0x4)
RoleBannerFrameConfTableRow.jump_goto = 0x10 // uint32_t (Size: 0x4)
RoleBannerFrameConfTableRow.no_source_description = 0x18 // FText (Size: 0x18)
RoleBannerFrameConfTableRow.is_dynamic_logo = 0x30 // uint32_t (Size: 0x4)
RoleBannerFrameConfTableRow.activity_info = 0x38 // FString (Size: 0x10)
RoleIdentityConfTableRow.IdentityId = 0x8 // uint32_t (Size: 0x4)
RoleIdentityConfTableRow.Describe = 0x10 // FText (Size: 0x18)
RoleKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoleKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
RoleKVConfTableRow.val_array = 0x18 // TArray<int64_t> (Size: 0x10)
RoleKVConfTableRow.daily_time_vec = 0x28 // TArray<FRoleKVDailyTimeConf> (Size: 0x10)
RoleKVConfTableRow.time1 = 0x38 // FDateTime (Size: 0x8)
RoleKVConfTableRow.time2 = 0x40 // FDateTime (Size: 0x8)
RoleKVDailyTimeConf.daily_time = 0x0 // FText (Size: 0x18)
RookieDetailConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
RookieDetailConfTableRow.desc = 0x10 // FText (Size: 0x18)
RookieDetailConfTableRow.desc1 = 0x28 // FText (Size: 0x18)
RookieDetailConfTableRow.subtype = 0x40 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.positionX = 0x44 // float (Size: 0x4)
RookieDetailConfTableRow.positionY = 0x48 // float (Size: 0x4)
RookieDetailConfTableRow.SizeX = 0x4c // float (Size: 0x4)
RookieDetailConfTableRow.SizeY = 0x50 // float (Size: 0x4)
RookieDetailConfTableRow.offsetX = 0x54 // float (Size: 0x4)
RookieDetailConfTableRow.unloadchecktype = 0x58 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.AttachType = 0x5c // uint32_t (Size: 0x4)
RookieDetailConfTableRow.CheckCondition = 0x60 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.EffectScale = 0x64 // float (Size: 0x4)
RookieDetailConfTableRow.buttonSizeX = 0x68 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.buttonSizeY = 0x6c // uint32_t (Size: 0x4)
RookieDetailConfTableRow.panelName = 0x70 // FString (Size: 0x10)
RookieDetailConfTableRow.TaskId = 0x80 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.businessId = 0x84 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.classifyId = 0x88 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.warehousesubid = 0x8c // uint32_t (Size: 0x4)
RookieDetailConfTableRow.prepareid = 0x90 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.prepareTab = 0x94 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.mapRuleType = 0x98 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.btnName = 0xa0 // FString (Size: 0x10)
RookieDetailConfTableRow.itemSpaceType = 0xb0 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.waitPanelName = 0xb8 // FString (Size: 0x10)
RookieDetailConfTableRow.backPanelName = 0xc8 // FString (Size: 0x10)
RookieDetailConfTableRow.waitSubPanelName = 0xd8 // FString (Size: 0x10)
RookieDetailConfTableRow.waitClosePanelName = 0xe8 // FString (Size: 0x10)
RookieDetailConfTableRow.dragItemid = 0xf8 // uint64_t (Size: 0x8)
RookieDetailConfTableRow.ParentID = 0x100 // uint64_t (Size: 0x8)
RookieDetailConfTableRow.movieid = 0x108 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.pptid = 0x110 // TArray<uint32_t> (Size: 0x10)
RookieDetailConfTableRow.pptemptyclose = 0x120 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.DisplayName = 0x128 // FText (Size: 0x18)
RookieDetailConfTableRow.displayType = 0x140 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.sound_name = 0x148 // FString (Size: 0x10)
RookieDetailConfTableRow.attachCheckType = 0x158 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.passCheck = 0x15c // uint32_t (Size: 0x4)
RookieDetailConfTableRow.floatTitle = 0x160 // FText (Size: 0x18)
RookieDetailConfTableRow.floatContent = 0x178 // TArray<FText> (Size: 0x10)
RookieDetailConfTableRow.isfloating = 0x188 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.isShowpromptly = 0x18c // uint32_t (Size: 0x4)
RookieDetailConfTableRow.talkcharacter = 0x190 // uint32_t (Size: 0x4)
RookieDetailConfTableRow.scrollAttachType = 0x194 // uint32_t (Size: 0x4)
RookieGunCheckConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieGunCheckConfTableRow.ItemId = 0x10 // uint64_t (Size: 0x8)
RookieGunCheckConfTableRow.List = 0x18 // TArray<uint32_t> (Size: 0x10)
RookieItemPickConfTableRow.ItemIdIndex = 0x8 // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.season_clear = 0xc // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.trigger_id = 0x10 // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.itemIdAndType = 0x18 // TArray<uint64_t> (Size: 0x10)
RookieItemPickConfTableRow.classifytype = 0x28 // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.takescope = 0x30 // TArray<uint32_t> (Size: 0x10)
RookieItemPickConfTableRow.triggertimes = 0x40 // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.cdtimes = 0x44 // uint32_t (Size: 0x4)
RookieItemPickConfTableRow.List = 0x48 // TArray<uint32_t> (Size: 0x10)
RookieMailReceiveConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieMailReceiveConfTableRow.mailType = 0xc // uint32_t (Size: 0x4)
RookieMailReceiveConfTableRow.season_clear = 0x10 // uint32_t (Size: 0x4)
RookieMailReceiveConfTableRow.trigger_id = 0x14 // uint32_t (Size: 0x4)
RookieMailReceiveConfTableRow.List = 0x18 // TArray<uint32_t> (Size: 0x10)
RookieSendItemBackConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
RookieSendItemBackConfTableRow.Num = 0xc // uint32_t (Size: 0x4)
RookieStepConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieStepConfTableRow.pre_taskid = 0xc // uint32_t (Size: 0x4)
RookieStepConfTableRow.forceguildtype = 0x10 // uint32_t (Size: 0x4)
RookieStepConfTableRow.jump_id = 0x14 // uint32_t (Size: 0x4)
RookieStepConfTableRow.break_jump = 0x18 // uint32_t (Size: 0x4)
RookieStepConfTableRow.protected_jump = 0x1c // uint32_t (Size: 0x4)
RookieStepConfTableRow.is_effective = 0x20 // uint32_t (Size: 0x4)
RookieStepConfTableRow.is_repeatable = 0x24 // uint32_t (Size: 0x4)
RookieStepConfTableRow.get_itemid = 0x28 // TArray<uint32_t> (Size: 0x10)
RookieStepConfTableRow.ItemId = 0x38 // uint32_t (Size: 0x4)
RookieStepConfTableRow.trade_id = 0x3c // uint32_t (Size: 0x4)
RookieStepConfTableRow.block_action = 0x40 // TArray<uint32_t> (Size: 0x10)
RookieStepConfTableRow.tips_list = 0x50 // TArray<uint32_t> (Size: 0x10)
RookieTaskDoneConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieTaskDoneConfTableRow.TaskId = 0xc // uint32_t (Size: 0x4)
RookieTaskDoneConfTableRow.season_clear = 0x10 // uint32_t (Size: 0x4)
RookieTaskDoneConfTableRow.trigger_id = 0x14 // uint32_t (Size: 0x4)
RookieTaskDoneConfTableRow.State = 0x18 // uint32_t (Size: 0x4)
RookieTaskDoneConfTableRow.List = 0x20 // TArray<uint32_t> (Size: 0x10)
RookieTraderUnlockConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieTraderUnlockConfTableRow.traderid = 0xc // uint32_t (Size: 0x4)
RookieTraderUnlockConfTableRow.season_clear = 0x10 // uint32_t (Size: 0x4)
RookieTraderUnlockConfTableRow.trigger_id = 0x14 // uint32_t (Size: 0x4)
RookieTraderUnlockConfTableRow.List = 0x18 // TArray<uint32_t> (Size: 0x10)
RookieTriggerConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.arg = 0xc // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.season_clear = 0x10 // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.trigger_id = 0x14 // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.trigger_type = 0x18 // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.cond_value = 0x20 // uint64_t (Size: 0x8)
RookieTriggerConfTableRow.sys_id = 0x28 // uint32_t (Size: 0x4)
RookieTriggerConfTableRow.List = 0x30 // TArray<FTriggerRookieItem> (Size: 0x10)
RookieTriggerIdConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.season_clear = 0xc // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.trigger_id = 0x10 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.trigger_type = 0x14 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.is_pop_after_unlock = 0x18 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.cond_value = 0x20 // TArray<uint64_t> (Size: 0x10)
RookieTriggerIdConfTableRow.extra_param = 0x30 // TArray<uint32_t> (Size: 0x10)
RookieTriggerIdConfTableRow.trigger_level = 0x40 // uint8_t (Size: 0x1)
RookieTriggerIdConfTableRow.Priority = 0x44 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.triggertimes = 0x48 // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.cdtimes = 0x4c // uint32_t (Size: 0x4)
RookieTriggerIdConfTableRow.trigger_panel = 0x50 // FString (Size: 0x10)
RookieTriggerIdConfTableRow.List = 0x60 // TArray<uint32_t> (Size: 0x10)
RookieTriggerTypeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.season_clear = 0xc // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.trigger_id = 0x10 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.rookieTriggerType = 0x14 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.ItemId = 0x18 // TArray<uint64_t> (Size: 0x10)
RookieTriggerTypeConfTableRow.tagid = 0x28 // TArray<uint32_t> (Size: 0x10)
RookieTriggerTypeConfTableRow.traderid = 0x38 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.AttachType = 0x3c // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.Priority = 0x40 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.triggertimes = 0x44 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.cdtimes = 0x48 // uint32_t (Size: 0x4)
RookieTriggerTypeConfTableRow.List = 0x50 // TArray<uint32_t> (Size: 0x10)
RookirTriggerSummaryConfTableRow.trigger_id = 0x8 // uint32_t (Size: 0x4)
RookirTriggerSummaryConfTableRow.repetition_allowed = 0xc // uint32_t (Size: 0x4)
RookirTriggerSummaryConfTableRow.desc = 0x10 // FText (Size: 0x18)
RookirTriggerSummaryConfTableRow.check_play_mode = 0x28 // TArray<uint32_t> (Size: 0x10)
RookirTriggerSummaryConfTableRow.trigger_level = 0x38 // uint32_t (Size: 0x4)
RoomKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
RoomKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
RoomKVConfTableRow.val_array = 0x18 // TArray<int64_t> (Size: 0x10)
RuleConf.cond = 0x0 // uint32_t (Size: 0x4)
RuleConf.cond_ids = 0x8 // TArray<uint32_t> (Size: 0x10)
SafeBoxConfTableRow.container_id = 0x8 // uint32_t (Size: 0x4)
SafeBoxConfTableRow.show_index = 0xc // uint32_t (Size: 0x4)
SafeBoxConfTableRow.day_price = 0x10 // uint32_t (Size: 0x4)
SafeBoxConfTableRow.is_hidden = 0x14 // uint32_t (Size: 0x4)
SafeBoxConfTableRow.group_id = 0x18 // uint32_t (Size: 0x4)
SafeBoxConfTableRow.is_time = 0x1c // uint32_t (Size: 0x4)
SafeBoxConfTableRow.list_desc = 0x20 // FText (Size: 0x18)
SafeBoxConfTableRow.jump_goto = 0x38 // uint32_t (Size: 0x4)
SafeBoxConfTableRow.Price = 0x3c // uint32_t (Size: 0x4)
SafeLootLimitTableRow.ID = 0x8 // uint32_t (Size: 0x4)
SafeLootLimitTableRow.PoolLists = 0x10 // TArray<FLimitPoolConf> (Size: 0x10)
ScavAIDynamicLimitTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
ScavAIDynamicLimitTableRow.MapID = 0xc // int32_t (Size: 0x4)
ScavAIDynamicLimitTableRow.AISpawnConfigID = 0x10 // TArray<int32_t> (Size: 0x10)
ScavAIDynamicLimitTableRow.eventId = 0x20 // int32_t (Size: 0x4)
ScavAIDynamicLimitTableRow.Weather = 0x28 // TArray<float> (Size: 0x10)
ScavAIDynamicLimitTableRow.ExpectedPMCPlayerNum = 0x38 // int32_t (Size: 0x4)
ScavAIDynamicLimitTableRow.ScavAIDynamicLimitStartTime = 0x3c // float (Size: 0x4)
ScavAIDynamicLimitTableRow.ScavLimitPerPMCPlayer = 0x40 // int32_t (Size: 0x4)
ScavAIDynamicLimitTableRow.ScavLimitBase = 0x44 // int32_t (Size: 0x4)
ScavEquipConfTableRow.is_npc = 0x8 // uint32_t (Size: 0x4)
ScavEquipConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
ScavEquipConfTableRow.class_id = 0x10 // uint32_t (Size: 0x4)
ScavEquipConfTableRow.slot_index = 0x14 // uint32_t (Size: 0x4)
ScavEquipConfTableRow.Weight = 0x18 // uint32_t (Size: 0x4)
ScavEquipConfTableRow.item_id = 0x1c // uint32_t (Size: 0x4)
ScavEquipConfTableRow.exts = 0x20 // TArray<FExtEquipConf> (Size: 0x10)
ScavWaveInfoArray.Probability = 0x0 // float (Size: 0x4)
ScavWaveInfoArray.Min = 0x4 // int32_t (Size: 0x4)
ScavWaveInfoArray.Max = 0x8 // int32_t (Size: 0x4)
ScavWaveInfoArray.MinInterval = 0xc // float (Size: 0x4)
ScavWaveInfoArray.MaxInterval = 0x10 // float (Size: 0x4)
Scheme703060001TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060001TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060001TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060001TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060001TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060001TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060001TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060001TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
Scheme703060002TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060002TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060002TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060002TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060002TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060002TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060002TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060002TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
Scheme703060003TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060003TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060003TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060003TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060003TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060003TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060003TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060003TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
Scheme703060004TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060004TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060004TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060004TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060004TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060004TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060004TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060004TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
Scheme703060005TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060005TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060005TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060005TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060005TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060005TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060005TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060005TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
Scheme703060006TableRow.ID = 0x8 // uint32_t (Size: 0x4)
Scheme703060006TableRow.Vest = 0xc // uint32_t (Size: 0x4)
Scheme703060006TableRow.Armor = 0x10 // uint32_t (Size: 0x4)
Scheme703060006TableRow.Backpack = 0x14 // uint32_t (Size: 0x4)
Scheme703060006TableRow.Helmet = 0x18 // uint32_t (Size: 0x4)
Scheme703060006TableRow.Visor = 0x1c // uint32_t (Size: 0x4)
Scheme703060006TableRow.Headset = 0x20 // uint32_t (Size: 0x4)
Scheme703060006TableRow.Mask = 0x24 // uint32_t (Size: 0x4)
ScopeScaleConfigTableRow.ID = 0x8 // uint64_t (Size: 0x8)
ScopeScaleConfigTableRow.WeaponScopeScale = 0x10 // TArray<FWeaponScopeScale> (Size: 0x10)
ScreenEffectPaddingTableRow.AssetName = 0x8 // FString (Size: 0x10)
ScreenEffectPaddingTableRow.Left = 0x18 // float (Size: 0x4)
ScreenEffectPaddingTableRow.Top = 0x1c // float (Size: 0x4)
ScreenEffectPaddingTableRow.Right = 0x20 // float (Size: 0x4)
ScreenEffectPaddingTableRow.Bottom = 0x24 // float (Size: 0x4)
ScreenEffectPaddingTableRow.MarginLeft = 0x28 // float (Size: 0x4)
ScreenEffectPaddingTableRow.MarginTop = 0x2c // float (Size: 0x4)
ScreenEffectPaddingTableRow.MarginRight = 0x30 // float (Size: 0x4)
ScreenEffectPaddingTableRow.MarginBottom = 0x34 // float (Size: 0x4)
SeasonChapterRef.chapter_id = 0x0 // uint32_t (Size: 0x4)
SeasonChapterRef.chapter_name = 0x8 // FText (Size: 0x18)
SeasonChapterRef.cdn_image = 0x20 // FString (Size: 0x10)
SeasonChapterRef.rotate_distance = 0x30 // uint32_t (Size: 0x4)
SeasonChapterRef.chapter_begin_time = 0x38 // FDateTime (Size: 0x8)
SeasonChapterRef.chapter_end_time = 0x40 // FDateTime (Size: 0x8)
SeasonCrossOverTaskTreeConfTableRow.show_order = 0x8 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child_len = 0xc // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.root_task_id = 0x10 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child1 = 0x14 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child2 = 0x18 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child3 = 0x1c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child4 = 0x20 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child5 = 0x24 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child6 = 0x28 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child7 = 0x2c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child8 = 0x30 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child9 = 0x34 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child10 = 0x38 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child11 = 0x3c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child12 = 0x40 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child13 = 0x44 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child14 = 0x48 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child15 = 0x4c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child16 = 0x50 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child17 = 0x54 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child18 = 0x58 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child19 = 0x5c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child20 = 0x60 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child21 = 0x64 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child22 = 0x68 // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child23 = 0x6c // uint32_t (Size: 0x4)
SeasonCrossOverTaskTreeConfTableRow.child24 = 0x70 // uint32_t (Size: 0x4)
SeasonPublicityTableRow.info_id = 0x8 // uint32_t (Size: 0x4)
SeasonPublicityTableRow.info_type = 0xc // uint32_t (Size: 0x4)
SeasonPublicityTableRow.info_picture = 0x10 // FString (Size: 0x10)
SeasonPublicityTableRow.info_big_title = 0x20 // FText (Size: 0x18)
SeasonPublicityTableRow.info_small_title = 0x38 // FText (Size: 0x18)
SeasonPublicityTableRow.info_describe1 = 0x50 // FText (Size: 0x18)
SeasonPublicityTableRow.info_describe2 = 0x68 // FText (Size: 0x18)
SeasonPublicityTableRow.info_path = 0x80 // FString (Size: 0x10)
SeasonTaskTreeConfTableRow.show_order = 0x8 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child_len = 0xc // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.root_task_id = 0x10 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child1 = 0x14 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child2 = 0x18 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child3 = 0x1c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child4 = 0x20 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child5 = 0x24 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child6 = 0x28 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child7 = 0x2c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child8 = 0x30 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child9 = 0x34 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child10 = 0x38 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child11 = 0x3c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child12 = 0x40 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child13 = 0x44 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child14 = 0x48 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child15 = 0x4c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child16 = 0x50 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child17 = 0x54 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child18 = 0x58 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child19 = 0x5c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child20 = 0x60 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child21 = 0x64 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child22 = 0x68 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child23 = 0x6c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child24 = 0x70 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child25 = 0x74 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child26 = 0x78 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child27 = 0x7c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child28 = 0x80 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child29 = 0x84 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child30 = 0x88 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child31 = 0x8c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child32 = 0x90 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child33 = 0x94 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child34 = 0x98 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child35 = 0x9c // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child36 = 0xa0 // uint32_t (Size: 0x4)
SeasonTaskTreeConfTableRow.child37 = 0xa4 // uint32_t (Size: 0x4)
SecurityQuestionConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
SecurityQuestionConfTableRow.QuestionDesc = 0x10 // FText (Size: 0x18)
ServerInfoTableRow.ServerCode = 0x8 // uint32_t (Size: 0x4)
ServerInfoTableRow.Describe = 0x10 // FText (Size: 0x18)
ServerKey2TextTableRow.ServerKey = 0x8 // FString (Size: 0x10)
ServerKey2TextTableRow.ServerText = 0x18 // FText (Size: 0x18)
ShareTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ShareTableRow.pic_desc = 0x10 // FText (Size: 0x18)
ShareTableRow.pic = 0x28 // FString (Size: 0x10)
ShareTextTableRow.ID = 0x8 // uint64_t (Size: 0x8)
ShareTextTableRow.Text = 0x10 // FText (Size: 0x18)
ShockConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ShockConfTableRow.ShockPath = 0x10 // FString (Size: 0x10)
ShockConfTableRow.Duration = 0x20 // float (Size: 0x4)
ShockConfTableRow.Amplitude = 0x24 // uint32_t (Size: 0x4)
ShockConfTableRow.CoolDownTime = 0x28 // float (Size: 0x4)
ShockConfTableRow.Default = 0x2c // uint32_t (Size: 0x4)
ShockConfTableRow.Loop = 0x30 // uint32_t (Size: 0x4)
ShockConfTableRow.Interval = 0x34 // uint32_t (Size: 0x4)
ShowDetailTableRow.ItemId = 0x8 // uint64_t (Size: 0x8)
ShowDetailTableRow.ShowDetailType = 0x10 // uint32_t (Size: 0x4)
ShowDetailTableRow.ResourcePath = 0x18 // FString (Size: 0x10)
ShowExtendConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ShowExtendConfTableRow.Lower_Price = 0xc // uint32_t (Size: 0x4)
ShowExtendConfTableRow.Upper_Price = 0x10 // uint32_t (Size: 0x4)
ShowExtendConfTableRow.Lower_Extend = 0x14 // uint32_t (Size: 0x4)
ShowExtendConfTableRow.Upper_Extend = 0x18 // uint32_t (Size: 0x4)
ShowTimeConf.start_time = 0x0 // FDateTime (Size: 0x8)
ShowTimeConf.end_time = 0x8 // FDateTime (Size: 0x8)
SkinMaterialInfo.Index = 0x0 // uint32_t (Size: 0x4)
SkinMaterialInfo.OverrideMaterial = 0x8 // FSoftObjectPath (Size: 0x18)
SkipTutorialTableRow.QuestionId = 0x8 // uint32_t (Size: 0x4)
SkipTutorialTableRow.Question = 0x10 // FString (Size: 0x10)
SkipTutorialTableRow.Option1 = 0x20 // FString (Size: 0x10)
SkipTutorialTableRow.Option2 = 0x30 // FString (Size: 0x10)
SkipTutorialTableRow.Option3 = 0x40 // FString (Size: 0x10)
SkipTutorialTableRow.Option4 = 0x50 // FString (Size: 0x10)
SkipTutorialTableRow.Answer = 0x60 // uint32_t (Size: 0x4)
SoundConfTableRow.sound_name = 0x8 // FName (Size: 0x8)
SoundConfTableRow.chn_name = 0x10 // FText (Size: 0x18)
SoundConfTableRow.desc = 0x28 // FText (Size: 0x18)
SoundConfTableRow.sound_ak_event = 0x40 // FString (Size: 0x10)
SpecialDanceTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
SpecialDanceTableRow.GestureIconPath = 0x10 // FString (Size: 0x10)
SpecialDanceTableRow.GestureDescription = 0x20 // FText (Size: 0x18)
SpecialDanceTableRow.AnimationName = 0x38 // FText (Size: 0x18)
SpecialDanceTableRow.depend_avatar = 0x50 // uint32_t (Size: 0x4)
SpecialDanceTableRow.activity_info = 0x58 // FString (Size: 0x10)
SpecialDanceTableRow.jump_goto = 0x68 // TArray<uint32_t> (Size: 0x10)
SpecialDanceTableRow.no_source_description = 0x78 // FText (Size: 0x18)
SpeechConfTableRow.SpeechID = 0x8 // uint32_t (Size: 0x4)
SpeechConfTableRow.NPCID = 0xc // uint32_t (Size: 0x4)
SpeechConfTableRow.Npc_stage = 0x10 // TArray<uint32_t> (Size: 0x10)
SpeechConfTableRow.SpeechType = 0x20 // uint32_t (Size: 0x4)
SpeechConfTableRow.SpeechText = 0x28 // FText (Size: 0x18)
SpeechConfTableRow.Level = 0x40 // TArray<uint32_t> (Size: 0x10)
SpeechConfTableRow.QuestID = 0x50 // uint32_t (Size: 0x4)
SpeechConfTableRow.QspeechType = 0x54 // uint32_t (Size: 0x4)
SpeechConfTableRow.AudioEvent = 0x58 // FText (Size: 0x18)
SpeechConfTableRow.BNK = 0x70 // FText (Size: 0x18)
SprayIconTextureTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
SprayIconTextureTableRow.SprayDescription = 0x10 // FText (Size: 0x18)
SprayIconTextureTableRow.isGif = 0x28 // uint32_t (Size: 0x4)
SprayIconTextureTableRow.SprayTexture = 0x30 // FString (Size: 0x10)
SprayIconTextureTableRow.SprayScale = 0x40 // float (Size: 0x4)
SprayIconTextureTableRow.activity_info = 0x48 // FString (Size: 0x10)
SprayIconTextureTableRow.jump_goto = 0x58 // TArray<uint32_t> (Size: 0x10)
SprayIconTextureTableRow.no_source_description = 0x68 // FText (Size: 0x18)
SprayIconTextureTableRow.SprayUVTiling = 0x80 // FVector2D (Size: 0x8)
SprayIconTextureTableRow.SprayFrameRate = 0x88 // float (Size: 0x4)
StandaloneWeatherTableRow.PlaymModeID = 0x8 // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather1 = 0xc // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather2 = 0x10 // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather3 = 0x14 // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather4 = 0x18 // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather5 = 0x1c // uint32_t (Size: 0x4)
StandaloneWeatherTableRow.Weather6 = 0x20 // uint32_t (Size: 0x4)
StashSlotConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
StashSlotConfTableRow.money_id = 0xc // uint32_t (Size: 0x4)
StashSlotConfTableRow.money_num = 0x10 // uint32_t (Size: 0x4)
SteamAchievementConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
SteamAchievementConfTableRow.achievement_name = 0x10 // FText (Size: 0x18)
SteamAchievementConfTableRow.stat_name = 0x28 // FText (Size: 0x18)
SteamAchievementConfTableRow.statis_event_id = 0x40 // uint32_t (Size: 0x4)
SteamAchievementConfTableRow.max_progress = 0x44 // uint32_t (Size: 0x4)
StickersTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
StickersTableRow.StickersIconPath = 0x10 // FString (Size: 0x10)
StickersTableRow.StickersGifTexture = 0x20 // FString (Size: 0x10)
StickersTableRow.isGif = 0x30 // uint32_t (Size: 0x4)
StickersTableRow.activity_info = 0x38 // FString (Size: 0x10)
StickersTableRow.jump_goto = 0x48 // TArray<uint32_t> (Size: 0x10)
StickersTableRow.no_source_description = 0x58 // FText (Size: 0x18)
SupplyStationGroupConfigTableRow.ID = 0x8 // uint32_t (Size: 0x4)
SupplyStationGroupConfigTableRow.FixArmorCoe = 0xc // float (Size: 0x4)
SupplyStationSingleConfigTableRow.ID = 0x8 // uint32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.GroupID = 0xc // uint32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.ItemId = 0x10 // uint32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.MaxBuyNum = 0x14 // int32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.bIsDownShelf = 0x18 // int32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.ShowProbability = 0x1c // float (Size: 0x4)
SupplyStationSingleConfigTableRow.MarketPriceMultiplier = 0x20 // float (Size: 0x4)
SupplyStationSingleConfigTableRow.FixedPrice = 0x24 // int32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.TypeBelong = 0x28 // int32_t (Size: 0x4)
SupplyStationSingleConfigTableRow.PlayerBuyNumLimit = 0x2c // int32_t (Size: 0x4)
TabDetailItem.tab_title = 0x0 // FText (Size: 0x18)
TabDetailItem.ppt_id = 0x18 // uint32_t (Size: 0x4)
Tag.tag_type = 0x0 // uint32_t (Size: 0x4)
Tag.tag_desc = 0x8 // FString (Size: 0x10)
Tag.tag_begin_time = 0x18 // FDateTime (Size: 0x8)
Tag.tag_end_time = 0x20 // FDateTime (Size: 0x8)
TagMatchedConfTableRow.Tag = 0x8 // FString (Size: 0x10)
TagMatchedConfTableRow.matchedItemIDs = 0x18 // TArray<uint32_t> (Size: 0x10)
TagSheet1TableRow.ID = 0x8 // uint32_t (Size: 0x4)
TagSheet1TableRow.Tag = 0x10 // FString (Size: 0x10)
TagSheet2TableRow.ID = 0x8 // uint32_t (Size: 0x4)
TagSheet2TableRow.SocketName = 0x10 // FString (Size: 0x10)
TagSheet2TableRow.PartName = 0x20 // FText (Size: 0x18)
TargetArmorTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TargetArmorTableRow.item_id = 0xc // uint32_t (Size: 0x4)
TargetArmorTableRow.unlock_item = 0x10 // uint32_t (Size: 0x4)
TargetArmorTableRow.is_default = 0x14 // uint32_t (Size: 0x4)
TaskActDescConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
TaskActDescConfTableRow.task_title = 0x10 // FText (Size: 0x18)
TaskActDescConfTableRow.task_detail = 0x28 // FText (Size: 0x18)
TaskActDescConfTableRow.rewards = 0x40 // TArray<FAwardItemConf> (Size: 0x10)
TaskActDescConfTableRow.need_reissue = 0x50 // uint32_t (Size: 0x4)
TaskActTargetDescConfTableRow.target_type = 0x8 // uint32_t (Size: 0x4)
TaskActTargetDescConfTableRow.target_desc = 0x10 // FText (Size: 0x18)
TaskActTargetDescParamConfTableRow.ID = 0x8 // int64_t (Size: 0x8)
TaskActTargetDescParamConfTableRow.desc = 0x10 // FText (Size: 0x18)
TaskCommitTargetConfTableRow.target_id = 0x8 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.commit_type = 0xc // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.item_id = 0x10 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.item_list = 0x18 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.big_type = 0x28 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.mid_type = 0x2c // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.sub_type = 0x30 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.rarity_list = 0x38 // TArray<int32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.size_x = 0x48 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.size_y = 0x58 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.size_all = 0x68 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.is_raidloot = 0x78 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.Durability = 0x80 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.durability_limit = 0x90 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.Engonomics = 0xa0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.Accuracy = 0xb0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.ads_moa_y = 0xc0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.horizontal_recoil = 0xd0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.vertical_recoil = 0xe0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.sight_range = 0xf0 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.muzzle_velocity = 0x100 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.max_count = 0x110 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.Recoil = 0x120 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.fire_type = 0x130 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.Caliber = 0x134 // uint32_t (Size: 0x4)
TaskCommitTargetConfTableRow.fire_rate = 0x138 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.effect_dist = 0x148 // TArray<uint32_t> (Size: 0x10)
TaskCommitTargetConfTableRow.Components = 0x158 // TArray<uint32_t> (Size: 0x10)
TaskConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
TaskConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
TaskConfTableRow.label_type = 0x10 // uint32_t (Size: 0x4)
TaskConfTableRow.active_task_type = 0x14 // uint32_t (Size: 0x4)
TaskConfTableRow.disp_title = 0x18 // FText (Size: 0x18)
TaskConfTableRow.season_id = 0x30 // uint32_t (Size: 0x4)
TaskConfTableRow.chapter_name = 0x38 // FText (Size: 0x18)
TaskConfTableRow.disp_type = 0x50 // uint32_t (Size: 0x4)
TaskConfTableRow.disp_desc = 0x58 // FText (Size: 0x18)
TaskConfTableRow.disp_detail = 0x70 // FText (Size: 0x18)
TaskConfTableRow.disp_address = 0x88 // uint32_t (Size: 0x4)
TaskConfTableRow.chapter = 0x90 // FText (Size: 0x18)
TaskConfTableRow.unlock_time = 0xa8 // FDateTime (Size: 0x8)
TaskConfTableRow.unlock_condtions = 0xb0 // TArray<FUnlockCondtionRef> (Size: 0x10)
TaskConfTableRow.pre_tasks = 0xc0 // TArray<uint32_t> (Size: 0x10)
TaskConfTableRow.pre_logic = 0xd0 // uint32_t (Size: 0x4)
TaskConfTableRow.source_type = 0xd4 // uint32_t (Size: 0x4)
TaskConfTableRow.source_id = 0xd8 // uint32_t (Size: 0x4)
TaskConfTableRow.faction_icon = 0xdc // uint32_t (Size: 0x4)
TaskConfTableRow.Faction = 0xe0 // uint32_t (Size: 0x4)
TaskConfTableRow.show_specified_businessman_stage = 0xe4 // uint32_t (Size: 0x4)
TaskConfTableRow.businessman_stage = 0xe8 // uint32_t (Size: 0x4)
TaskConfTableRow.Targets = 0xf0 // TArray<FTaskTargetRefItem> (Size: 0x10)
TaskConfTableRow.need_finish_num = 0x100 // uint32_t (Size: 0x4)
TaskConfTableRow.hide_day = 0x104 // uint32_t (Size: 0x4)
TaskConfTableRow.kw_desc = 0x108 // FText (Size: 0x18)
TaskConfTableRow.gift_exp = 0x120 // uint32_t (Size: 0x4)
TaskConfTableRow.gift_ruble = 0x124 // uint32_t (Size: 0x4)
TaskConfTableRow.rewards = 0x128 // TArray<FAwardItemConf> (Size: 0x10)
TaskConfTableRow.prev_type = 0x138 // uint32_t (Size: 0x4)
TaskConfTableRow.reaccept_if_failed = 0x13c // uint32_t (Size: 0x4)
TaskConfTableRow.accept_dialog_start_id = 0x140 // uint32_t (Size: 0x4)
TaskConfTableRow.finish_dialog_start_id = 0x144 // uint32_t (Size: 0x4)
TaskConfTableRow.task_difficult = 0x148 // uint32_t (Size: 0x4)
TaskConfTableRow.complete_in_one_battle = 0x14c // bool (Size: 0x1)
TaskConfTableRow.sort_weight = 0x150 // uint32_t (Size: 0x4)
TaskConfTableRow.activity_id = 0x154 // uint32_t (Size: 0x4)
TaskConfTableRow.reports_id = 0x158 // TArray<int32_t> (Size: 0x10)
TaskConfTableRow.gradually_unlock = 0x168 // bool (Size: 0x1)
TaskConfTableRow.task_cover = 0x16c // uint32_t (Size: 0x4)
TaskConfTableRow.core_reward_item_id = 0x170 // uint32_t (Size: 0x4)
TaskConfTableRow.task_chain_show_core_reward = 0x174 // uint32_t (Size: 0x4)
TaskDialogueTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TaskDialogueTableRow.conversation = 0x10 // FText (Size: 0x18)
TaskDialogueTableRow.Sound = 0x28 // FText (Size: 0x18)
TaskDialogueTableRow.bg = 0x40 // FText (Size: 0x18)
TaskDialogueTableRow.Title = 0x58 // FText (Size: 0x18)
TaskDialogueTableRow.next_id = 0x70 // uint32_t (Size: 0x4)
TaskDialogueTableRow.NPC = 0x74 // uint32_t (Size: 0x4)
TaskDialogueTableRow.gifts = 0x78 // TArray<FCommonItemConfItem> (Size: 0x10)
TaskLinkConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TaskLinkConfTableRow.Links = 0x10 // TArray<FActLink> (Size: 0x10)
TaskReportConfTableRow.report_id = 0x8 // uint32_t (Size: 0x4)
TaskReportConfTableRow.target_id = 0xc // uint32_t (Size: 0x4)
TaskReportConfTableRow.State = 0x10 // uint32_t (Size: 0x4)
TaskReportConfTableRow.businessman_id = 0x14 // uint32_t (Size: 0x4)
TaskReportConfTableRow.Title = 0x18 // FText (Size: 0x18)
TaskReportConfTableRow.Content = 0x30 // FText (Size: 0x18)
TaskReportConfTableRow.report_time = 0x48 // float (Size: 0x4)
TaskReportConfTableRow.sound_url = 0x50 // FText (Size: 0x18)
TaskTargetConfTableRow.target_id = 0x8 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.target_type = 0xc // uint32_t (Size: 0x4)
TaskTargetConfTableRow.desc = 0x10 // FText (Size: 0x18)
TaskTargetConfTableRow.jump_goto = 0x28 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.Progress = 0x2c // uint32_t (Size: 0x4)
TaskTargetConfTableRow.Param1 = 0x30 // int64_t (Size: 0x8)
TaskTargetConfTableRow.Param2 = 0x38 // int64_t (Size: 0x8)
TaskTargetConfTableRow.Param3 = 0x40 // int64_t (Size: 0x8)
TaskTargetConfTableRow.team_share = 0x48 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.icon_item_id = 0x50 // int64_t (Size: 0x8)
TaskTargetConfTableRow.item_list = 0x58 // TArray<int64_t> (Size: 0x10)
TaskTargetConfTableRow.big_type = 0x68 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.mid_type = 0x6c // uint32_t (Size: 0x4)
TaskTargetConfTableRow.sub_type = 0x70 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.rarity_list = 0x78 // TArray<int32_t> (Size: 0x10)
TaskTargetConfTableRow.rewards = 0x88 // TArray<FCommonItemConfItem> (Size: 0x10)
TaskTargetConfTableRow.prev_target = 0x98 // TArray<uint32_t> (Size: 0x10)
TaskTargetConfTableRow.prev_type = 0xa8 // uint32_t (Size: 0x4)
TaskTargetConfTableRow.fail_when_next_fail = 0xac // uint32_t (Size: 0x4)
TaskTargetConfTableRow.node_type = 0xb0 // uint32_t (Size: 0x4)
TaskTargetRefItem.target_id = 0x0 // uint32_t (Size: 0x4)
TaskTargetRefItem.group_id = 0x4 // uint32_t (Size: 0x4)
TaskTargetRefItem.Property = 0x8 // uint32_t (Size: 0x4)
TeamBattleStyleTextTableRow.battle_style_type = 0x8 // uint32_t (Size: 0x4)
TeamBattleStyleTextTableRow.Name = 0x10 // FText (Size: 0x18)
TeamConvenientMacthTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamConvenientMacthTableRow.Name = 0x10 // FText (Size: 0x18)
TeamConvenientMacthTableRow.Type = 0x28 // uint32_t (Size: 0x4)
TeamConvenientMacthTableRow.DefaultValue = 0x2c // uint32_t (Size: 0x4)
TeamConvenientMacthTableRow.Param1 = 0x30 // uint32_t (Size: 0x4)
TeamEquipStyleTextTableRow.equip_style_type = 0x8 // uint32_t (Size: 0x4)
TeamEquipStyleTextTableRow.Name = 0x10 // FText (Size: 0x18)
TeamKVConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamKVConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
TeamKVConfTableRow.val_array = 0x18 // TArray<int64_t> (Size: 0x10)
TeamLendConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamLendConfTableRow.Val = 0xc // uint32_t (Size: 0x4)
TeamLendConfTableRow.ary = 0x10 // TArray<uint32_t> (Size: 0x10)
TeamListTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamListTableRow.Name = 0x10 // FText (Size: 0x18)
TeamListTableRow.Type = 0x28 // uint32_t (Size: 0x4)
TeamListTableRow.DefaultValue = 0x2c // uint32_t (Size: 0x4)
TeamListTableRow.Param1 = 0x30 // uint32_t (Size: 0x4)
TeamListTableRow.Param2 = 0x34 // uint32_t (Size: 0x4)
TeamOptionTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamOptionTableRow.Name = 0x10 // FText (Size: 0x18)
TeamOptionTableRow.DefaultValue = 0x28 // uint32_t (Size: 0x4)
TeamOptionTableRow.IsShow = 0x2c // uint32_t (Size: 0x4)
TeamRatingBattleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamRatingBattleConfTableRow.group_id = 0xc // uint32_t (Size: 0x4)
TeamRatingBattleConfTableRow.Weight = 0x10 // uint32_t (Size: 0x4)
TeamRatingBattleConfTableRow.rating_change = 0x18 // int64_t (Size: 0x8)
TeamRatingBattleConfTableRow.rating_limit_change = 0x20 // int64_t (Size: 0x8)
TeamRatingBattleConfTableRow.Conditions = 0x28 // TArray<FRatingConditionConf> (Size: 0x10)
TeamRatingCommConfTableRow.conf_type = 0x8 // uint32_t (Size: 0x4)
TeamRatingCommConfTableRow.Val = 0x10 // int64_t (Size: 0x8)
TeamRecruitStyleConfTableRow.style_type = 0x8 // uint32_t (Size: 0x4)
TeamRecruitStyleConfTableRow.style_list = 0x10 // TArray<FRecruitStyleConf> (Size: 0x10)
TeamStyleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamStyleConfTableRow.style_name = 0x10 // FText (Size: 0x18)
TeamTargetConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TeamTargetConfTableRow.target_name = 0x10 // FText (Size: 0x18)
TeamVoiceTableRow.ItemId = 0x8 // int32_t (Size: 0x4)
TeamVoiceTableRow.VoiceDesc = 0x10 // FText (Size: 0x18)
TeamVoiceTableRow.VoicePath = 0x28 // FString (Size: 0x10)
TeamVoiceTableRow.VoiceContent = 0x38 // FText (Size: 0x18)
TeamVoiceTableRow.activity_info = 0x50 // FString (Size: 0x10)
TeamVoiceTableRow.WanderPath = 0x60 // FString (Size: 0x10)
TeamVoiceTableRow.WanderContent = 0x70 // FString (Size: 0x10)
TeamVoiceTableRow.VoiceType = 0x80 // int32_t (Size: 0x4)
ThrowableWeaponDetailTableRow.ItemId = 0x8 // uint64_t (Size: 0x8)
ThrowableWeaponDetailTableRow.DelayEffect = 0x10 // TArray<float> (Size: 0x10)
ThrowableWeaponDetailTableRow.EffectRange = 0x20 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.EffectTime = 0x38 // float (Size: 0x4)
ThrowableWeaponDetailTableRow.ArmorDamage = 0x40 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.Penetration = 0x58 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.PieceCount = 0x70 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.PieceType = 0x88 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.battery = 0xa0 // FText (Size: 0x18)
ThrowableWeaponDetailTableRow.detectrange = 0xb8 // FText (Size: 0x18)
TicketConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TicketConfTableRow.item_id = 0xc // uint32_t (Size: 0x4)
TicketConfTableRow.cast_num = 0x10 // uint32_t (Size: 0x4)
TicketConfTableRow.tip_id = 0x14 // int32_t (Size: 0x4)
TipItem.Tips = 0x0 // FText (Size: 0x18)
TipItem.Weight = 0x18 // uint32_t (Size: 0x4)
TitleItemConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TitleItemConfTableRow.start_time = 0x10 // FDateTime (Size: 0x8)
TitleItemConfTableRow.end_time = 0x18 // FDateTime (Size: 0x8)
TitleItemConfTableRow.JumpId = 0x20 // uint32_t (Size: 0x4)
TitleItemConfTableRow.no_source_description = 0x28 // FText (Size: 0x18)
TitleItemConfTableRow.CannotGetDesc = 0x40 // FText (Size: 0x18)
TitleItemConfTableRow.MaxAddStarNum = 0x58 // uint32_t (Size: 0x4)
TitleItemConfTableRow.ShowNormalGetPanel = 0x5c // uint32_t (Size: 0x4)
TitleItemConfTableRow.is_dynamic_logo = 0x60 // uint32_t (Size: 0x4)
TitleItemConfTableRow.activity_info = 0x68 // FString (Size: 0x10)
TitleItemConfTableRow.is_show_star = 0x78 // uint32_t (Size: 0x4)
TitleItemConfTableRow.seasonId = 0x7c // uint32_t (Size: 0x4)
TitleItemConfTableRow.is_off_sale = 0x80 // uint32_t (Size: 0x4)
TitleItemConfTableRow.can_add_star = 0x84 // uint32_t (Size: 0x4)
TitleItemConfTableRow.show_get_time = 0x88 // uint32_t (Size: 0x4)
TitleItemConfTableRow.is_cannot_get = 0x8c // uint32_t (Size: 0x4)
TradeConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TradeConfTableRow.businessman_id = 0xc // uint32_t (Size: 0x4)
TradeConfTableRow.classify_id = 0x10 // uint32_t (Size: 0x4)
TradeConfTableRow.Seq = 0x14 // uint32_t (Size: 0x4)
TradeConfTableRow.loyalty_level = 0x18 // uint32_t (Size: 0x4)
TradeConfTableRow.lock_desc = 0x20 // FText (Size: 0x18)
TradeConfTableRow.is_hide = 0x38 // uint32_t (Size: 0x4)
TradeConfTableRow.task_id = 0x3c // uint32_t (Size: 0x4)
TradeConfTableRow.businessman_reputation = 0x40 // uint32_t (Size: 0x4)
TradeConfTableRow.Level = 0x44 // uint32_t (Size: 0x4)
TradeConfTableRow.have_item = 0x48 // uint32_t (Size: 0x4)
TradeConfTableRow.buy_limit = 0x4c // uint32_t (Size: 0x4)
TradeConfTableRow.limit_forever = 0x50 // uint32_t (Size: 0x4)
TradeConfTableRow.refresh_begin_time = 0x58 // FDateTime (Size: 0x8)
TradeConfTableRow.refresh_period = 0x60 // uint32_t (Size: 0x4)
TradeConfTableRow.limit_refresh_begin_time = 0x68 // FDateTime (Size: 0x8)
TradeConfTableRow.limit_refresh_period = 0x70 // uint32_t (Size: 0x4)
TradeConfTableRow.sell_item_id = 0x74 // uint32_t (Size: 0x4)
TradeConfTableRow.sell_num = 0x78 // uint32_t (Size: 0x4)
TradeConfTableRow.is_faction = 0x7c // uint32_t (Size: 0x4)
TradeConfTableRow.sellItemName = 0x80 // FText (Size: 0x18)
TradeConfTableRow.exchange_item_vec = 0x98 // TArray<FExchangeItemConf> (Size: 0x10)
TradeDialogVoiceConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TradeDialogVoiceConfTableRow.businessman_id = 0xc // uint32_t (Size: 0x4)
TradeDialogVoiceConfTableRow.DialogTypeDef = 0x10 // FString (Size: 0x10)
TradeDialogVoiceConfTableRow.AudioSourceName = 0x20 // FString (Size: 0x10)
TradeHeadIconTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TradeHeadIconTableRow.businessman_id = 0xc // uint32_t (Size: 0x4)
TradeHeadIconTableRow.BusinessHead_Path = 0x10 // FString (Size: 0x10)
TradeHeadIconTableRow.stage_head_vec = 0x20 // TArray<FBusinessHeadConf> (Size: 0x10)
TradeItemClassifyConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TradeItemClassifyConfTableRow.bussinessman_id = 0xc // uint32_t (Size: 0x4)
TradeItemClassifyConfTableRow.icon_path = 0x10 // FText (Size: 0x18)
TradeItemClassifyConfTableRow.Name = 0x28 // FText (Size: 0x18)
TradeItemClassifyConfTableRow.item_types = 0x40 // TArray<uint64_t> (Size: 0x10)
TradeItemClassifyConfTableRow.classify_type = 0x50 // uint32_t (Size: 0x4)
TradeItemClassifyConfTableRow.is_act_classify = 0x54 // uint32_t (Size: 0x4)
TradeItemClassifyConfTableRow.show_classify = 0x58 // uint32_t (Size: 0x4)
TradeItemClassifyConfTableRow.isManuallyRefresh = 0x5c // uint32_t (Size: 0x4)
TraderScaleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
TraderScaleConfTableRow.DistancePercentA = 0xc // float (Size: 0x4)
TreasuryCabinetCombination.cabinet_list = 0x0 // TArray<uint32_t> (Size: 0x10)
TriggerArea.AreaID = 0x0 // FString (Size: 0x10)
TriggerArea.TriggerEvent = 0x10 // FString (Size: 0x10)
TriggerArea.FollowArea = 0x20 // FString (Size: 0x10)
TriggerRookieItem.ID = 0x0 // uint32_t (Size: 0x4)
TriggerRookieItem.break_jump = 0x4 // uint32_t (Size: 0x4)
TriggerRookieItem.get_itemid = 0x8 // TArray<uint32_t> (Size: 0x10)
TriggerRookieItem.ItemId = 0x18 // uint32_t (Size: 0x4)
TriggerRookieItem.trade_id = 0x1c // uint32_t (Size: 0x4)
UnbanLootMapIdConfTableRow.mapIDPrefix = 0x8 // uint32_t (Size: 0x4)
UnbanMapIdConfTableRow.mapIDPrefix = 0x8 // uint32_t (Size: 0x4)
UnlockCondtionRef.cond_type = 0x0 // uint32_t (Size: 0x4)
UnlockCondtionRef.cond_value = 0x4 // uint32_t (Size: 0x4)
UpgradeCostItems.item_id = 0x0 // uint32_t (Size: 0x4)
UpgradeCostItems.Num = 0x4 // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.ID = 0x8 // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.Type = 0xc // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.function_control_id = 0x10 // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.preview_level = 0x14 // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.sort = 0x18 // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.sys_id = 0x1c // uint32_t (Size: 0x4)
UpgradeUnlockTableRow.unlock_tip = 0x20 // FText (Size: 0x18)
UpgradeUnlockTableRow.preview_label = 0x38 // FText (Size: 0x18)
UpgradeUnlockTableRow.preview_desc = 0x50 // FText (Size: 0x18)
UpgradeUnlockTableRow.label = 0x68 // FText (Size: 0x18)
UpgradeUnlockTableRow.desc1 = 0x80 // FText (Size: 0x18)
UpgradeUnlockTableRow.image_path = 0x98 // FString (Size: 0x10)
UpgradeUnlockTableRow.small_image_path = 0xa8 // FString (Size: 0x10)
UpgradeUnlockTableRow.robot_help_key = 0xb8 // FText (Size: 0x18)
UpgradeUnlockTableRow.begin_time = 0xd0 // FString (Size: 0x10)
UpgradeUnlockTableRow.end_time = 0xe0 // FString (Size: 0x10)
UpgradeUnlockTableRow.desc = 0xf0 // FText (Size: 0x18)
ValueDistributionConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.Inclination = 0xc // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.Gun = 0x10 // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.ContainerArmor = 0x14 // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.head = 0x18 // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.Bullet = 0x1c // uint32_t (Size: 0x4)
ValueDistributionConfTableRow.Consumables = 0x20 // uint32_t (Size: 0x4)
VoiceIconSoundTableRow.ItemId = 0x8 // int32_t (Size: 0x4)
VoiceIconSoundTableRow.VoiceIconPath = 0x10 // FString (Size: 0x10)
VoiceIconSoundTableRow.VoiceDescription = 0x20 // FText (Size: 0x18)
VoiceIconSoundTableRow.VoiceSoundPaths = 0x38 // TArray<FString> (Size: 0x10)
VoiceIconSoundTableRow.WanderVoiceSoundPaths = 0x48 // TArray<FString> (Size: 0x10)
VoiceIconSoundTableRow.activity_info = 0x58 // FString (Size: 0x10)
VoiceIconSoundTableRow.jump_goto = 0x68 // TArray<uint32_t> (Size: 0x10)
VoiceIconSoundTableRow.no_source_description = 0x78 // FText (Size: 0x18)
WalkInTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WalkInTableRow.GestureIconPath = 0x10 // FString (Size: 0x10)
WalkInTableRow.GestureDescription = 0x20 // FText (Size: 0x18)
WalkInTableRow.AnimationName = 0x38 // FText (Size: 0x18)
WalkInTableRow.depend_avatar = 0x50 // uint32_t (Size: 0x4)
WalkInTableRow.Weight = 0x54 // uint32_t (Size: 0x4)
WalkInTableRow.Rotation = 0x58 // uint32_t (Size: 0x4)
WalkInTableRow.activity_info = 0x60 // FString (Size: 0x10)
WarZoneConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WarZoneConfTableRow.country_codes = 0x10 // TArray<uint32_t> (Size: 0x10)
WeaponAssembleConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponAssembleConfTableRow.col_size = 0xc // uint32_t (Size: 0x4)
WeaponAssembleConfTableRow.row_size = 0x10 // uint32_t (Size: 0x4)
WeaponAssembleConfTableRow.unique_id = 0x18 // FString (Size: 0x10)
WeaponAssembleConfTableRow.can_fire = 0x28 // uint32_t (Size: 0x4)
WeaponAssembleConfTableRow.Items = 0x30 // TArray<FWeaponItemConf> (Size: 0x10)
WeaponAvatarSetCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponAvatarSetCfgTableRow.avatar_set = 0x10 // TArray<uint32_t> (Size: 0x10)
WeaponAvatarSetCfgTableRow.SkinAssemble = 0x20 // uint32_t (Size: 0x4)
WeaponAvatarSetCfgTableRow.ExtSkinAssemble = 0x28 // TArray<uint32_t> (Size: 0x10)
WeaponAvatarSetCfgTableRow.ExtSkinList = 0x38 // TArray<uint32_t> (Size: 0x10)
WeaponAvatarSetCfgTableRow.seq_plan = 0x48 // uint32_t (Size: 0x4)
WeaponClassifyConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponClassifyConfTableRow.IconPath = 0x10 // FString (Size: 0x10)
WeaponClassifyConfTableRow.Name = 0x20 // FText (Size: 0x18)
WeaponClassifyConfTableRow.ItemType = 0x38 // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.BulletSize = 0x10 // FText (Size: 0x18)
WeaponDetailConfTableRow.size_ext = 0x28 // TArray<uint32_t> (Size: 0x10)
WeaponDetailConfTableRow.TypesOfFire = 0x38 // FText (Size: 0x18)
WeaponDetailConfTableRow.FireRate = 0x50 // FString (Size: 0x10)
WeaponDetailConfTableRow.MuzzleVelocity = 0x60 // float (Size: 0x4)
WeaponDetailConfTableRow.BaseDamage = 0x64 // float (Size: 0x4)
WeaponDetailConfTableRow.AdapterAdjustDamage = 0x68 // float (Size: 0x4)
WeaponDetailConfTableRow.FiringPowerDisplay = 0x70 // FText (Size: 0x18)
WeaponDetailConfTableRow.Engonomics = 0x88 // float (Size: 0x4)
WeaponDetailConfTableRow.WeaponStability = 0x8c // float (Size: 0x4)
WeaponDetailConfTableRow.ImpactForce = 0x90 // float (Size: 0x4)
WeaponDetailConfTableRow.ImpactResistance = 0x94 // float (Size: 0x4)
WeaponDetailConfTableRow.GSLeverSpeed = 0x98 // float (Size: 0x4)
WeaponDetailConfTableRow.Accuracy = 0x9c // float (Size: 0x4)
WeaponDetailConfTableRow.ZeroDropDistance = 0xa0 // float (Size: 0x4)
WeaponDetailConfTableRow.MoaScale = 0xa4 // float (Size: 0x4)
WeaponDetailConfTableRow.AdsMoaX = 0xa8 // float (Size: 0x4)
WeaponDetailConfTableRow.AdsMoaY = 0xac // float (Size: 0x4)
WeaponDetailConfTableRow.MoaFinalScale = 0xb0 // float (Size: 0x4)
WeaponDetailConfTableRow.HorizontalRecoil = 0xb4 // float (Size: 0x4)
WeaponDetailConfTableRow.VerticalRecoil = 0xb8 // float (Size: 0x4)
WeaponDetailConfTableRow.Recoil = 0xbc // float (Size: 0x4)
WeaponDetailConfTableRow.EffectiveDistance = 0xc0 // FString (Size: 0x10)
WeaponDetailConfTableRow.ADSMoveSpeedRatio = 0xd0 // float (Size: 0x4)
WeaponDetailConfTableRow.MoveSpeedRatio = 0xd4 // float (Size: 0x4)
WeaponDetailConfTableRow.CheckMagRatio = 0xd8 // float (Size: 0x4)
WeaponDetailConfTableRow.SuppressorSoundShow = 0xe0 // FText (Size: 0x18)
WeaponDetailConfTableRow.SilencerType = 0xf8 // uint8_t (Size: 0x1)
WeaponDetailConfTableRow.RunSpeedRatio = 0xfc // float (Size: 0x4)
WeaponDetailConfTableRow.SprintSpeedRatio = 0x100 // float (Size: 0x4)
WeaponDetailConfTableRow.SilentWalkSpeedRatio = 0x104 // float (Size: 0x4)
WeaponDetailConfTableRow.AccuracyPunishRatio = 0x108 // float (Size: 0x4)
WeaponDetailConfTableRow.LeanRatio = 0x10c // float (Size: 0x4)
WeaponDetailConfTableRow.ShouldReloadByOne = 0x110 // int8_t (Size: 0x1)
WeaponDetailConfTableRow.CanFold = 0x114 // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.Scope = 0x118 // FString (Size: 0x10)
WeaponDetailConfTableRow.AmmoCapacity = 0x128 // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.RaceStrategy = 0x12c // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.LightIntensityDisplay = 0x130 // FString (Size: 0x10)
WeaponDetailConfTableRow.EnergyCostPerFire = 0x140 // float (Size: 0x4)
WeaponDetailConfTableRow.AdapterArmorLevel = 0x148 // FString (Size: 0x10)
WeaponDetailConfTableRow.Caliber = 0x158 // FText (Size: 0x18)
WeaponDetailConfTableRow.AccessoryType = 0x170 // FString (Size: 0x10)
WeaponDetailConfTableRow.ReloadSpeedRatio = 0x180 // float (Size: 0x4)
WeaponDetailConfTableRow.MaxCount = 0x184 // float (Size: 0x4)
WeaponDetailConfTableRow.SightRange = 0x188 // float (Size: 0x4)
WeaponDetailConfTableRow.SprintToIdle = 0x18c // float (Size: 0x4)
WeaponDetailConfTableRow.IsCulling = 0x190 // uint32_t (Size: 0x4)
WeaponDetailConfTableRow.FireRequireTags = 0x198 // TArray<FString> (Size: 0x10)
WeaponDetailConfTableRow.fi_require_tags = 0x1a8 // TArray<FWeaponTag> (Size: 0x10)
WeaponDetailConfTableRow.AdapterFireRequireTags = 0x1b8 // TArray<FString> (Size: 0x10)
WeaponDetailConfTableRow.ad_require_tags = 0x1c8 // TArray<FWeaponTag> (Size: 0x10)
WeaponDetailConfTableRow.FireRequireTagsDecrease = 0x1d8 // FString (Size: 0x10)
WeaponDetailConfTableRow.de_require_tags = 0x1e8 // TArray<FWeaponTag> (Size: 0x10)
WeaponDetailConfTableRow.AssembleTag = 0x1f8 // FString (Size: 0x10)
WeaponDetailConfTableRow.SubAssembleTag = 0x208 // FString (Size: 0x10)
WeaponDetailConfTableRow.ConflictedItemIds = 0x218 // TArray<uint32_t> (Size: 0x10)
WeaponDetailConfTableRow.slot_type = 0x228 // uint64_t (Size: 0x8)
WeaponDetailConfTableRow.sub_slot_type = 0x230 // uint64_t (Size: 0x8)
WeaponDetailConfTableRow.DurabilityAccuracyCurvePath = 0x238 // FString (Size: 0x10)
WeaponDetailConfTableRow.DurabilityMalfunctionCurvePath = 0x248 // FString (Size: 0x10)
WeaponDetailConfTableRow.DurabilityMoaCurvePath = 0x258 // FString (Size: 0x10)
WeaponDetailConfTableRow.Sockets = 0x268 // TArray<FWeaponSocket> (Size: 0x10)
WeaponDetailValueToAttributeTableRow.DetailValueName = 0x8 // FString (Size: 0x10)
WeaponDetailValueToAttributeTableRow.AttributeName = 0x18 // FString (Size: 0x10)
WeaponDetailValueToAttributeTableRow.ModOp = 0x28 // uint32_t (Size: 0x4)
WeaponFilterItemsConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponFilterItemsConfTableRow.Name = 0x10 // FText (Size: 0x18)
WeaponFilterItemsConfTableRow.arr = 0x28 // TArray<uint32_t> (Size: 0x10)
WeaponItemConf.item_id = 0x0 // uint32_t (Size: 0x4)
WeaponItemConf.Num = 0x4 // uint32_t (Size: 0x4)
WeaponItemConf.slot_index = 0x8 // uint32_t (Size: 0x4)
WeaponItemConf.Parent = 0xc // uint32_t (Size: 0x4)
WeaponItemConf.parent_idx = 0x10 // uint32_t (Size: 0x4)
WeaponItemConf.spray_item_id = 0x14 // uint32_t (Size: 0x4)
WeaponPresetConfTableRow.ID = 0x8 // uint64_t (Size: 0x8)
WeaponPresetConfTableRow.Name = 0x10 // FText (Size: 0x18)
WeaponPresetConfTableRow.isSuper = 0x28 // uint32_t (Size: 0x4)
WeaponPresetConfTableRow.baseId = 0x2c // uint32_t (Size: 0x4)
WeaponRecommendArgConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponRecommendArgConfTableRow.Blacklist = 0x10 // TArray<uint32_t> (Size: 0x10)
WeaponRecommendArgConfTableRow.design_prob = 0x20 // uint32_t (Size: 0x4)
WeaponRecommendArgConfTableRow.ds_out_prob = 0x24 // uint32_t (Size: 0x4)
WeaponRecommendConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponRecommendConfTableRow.Items = 0x10 // TArray<FRecommendWeaponItemConf> (Size: 0x10)
WeaponRecommendWeaponConfTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponRecommendWeaponConfTableRow.max_num = 0xc // uint32_t (Size: 0x4)
WeaponRuleConfTableRow.base_id = 0x8 // uint32_t (Size: 0x4)
WeaponRuleConfTableRow.rules = 0x10 // TArray<FRuleConf> (Size: 0x10)
WeaponRuleWDCFTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
WeaponRuleWDCFTableRow.BulletSize = 0x10 // FText (Size: 0x18)
WeaponRuleWDCFTableRow.AmmoCapacity = 0x28 // uint32_t (Size: 0x4)
WeaponRuleWDCFTableRow.size_ext = 0x30 // TArray<uint32_t> (Size: 0x10)
WeaponRuleWDCFTableRow.CanFold = 0x40 // uint32_t (Size: 0x4)
WeaponRuleWDCFTableRow.AssembleTag = 0x48 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.SubAssembleTag = 0x58 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.slot_type = 0x68 // uint64_t (Size: 0x8)
WeaponRuleWDCFTableRow.sub_slot_type = 0x70 // uint64_t (Size: 0x8)
WeaponRuleWDCFTableRow.Sockets = 0x78 // TArray<FWeaponSocket> (Size: 0x10)
WeaponRuleWDCFTableRow.ConflictedItemIds = 0x88 // TArray<uint32_t> (Size: 0x10)
WeaponRuleWDCFTableRow.Engonomics = 0x98 // float (Size: 0x4)
WeaponRuleWDCFTableRow.Accuracy = 0x9c // float (Size: 0x4)
WeaponRuleWDCFTableRow.MoaScale = 0xa0 // float (Size: 0x4)
WeaponRuleWDCFTableRow.AdsMoaX = 0xa4 // float (Size: 0x4)
WeaponRuleWDCFTableRow.AdsMoaY = 0xa8 // float (Size: 0x4)
WeaponRuleWDCFTableRow.HorizontalRecoil = 0xac // float (Size: 0x4)
WeaponRuleWDCFTableRow.VerticalRecoil = 0xb0 // float (Size: 0x4)
WeaponRuleWDCFTableRow.SightRange = 0xb4 // float (Size: 0x4)
WeaponRuleWDCFTableRow.MuzzleVelocity = 0xb8 // float (Size: 0x4)
WeaponRuleWDCFTableRow.RaceStrategy = 0xbc // uint32_t (Size: 0x4)
WeaponRuleWDCFTableRow.MaxCount = 0xc0 // float (Size: 0x4)
WeaponRuleWDCFTableRow.Recoil = 0xc4 // float (Size: 0x4)
WeaponRuleWDCFTableRow.ZeroDropDistance = 0xc8 // float (Size: 0x4)
WeaponRuleWDCFTableRow.TypesOfFire = 0xd0 // FText (Size: 0x18)
WeaponRuleWDCFTableRow.Caliber = 0xe8 // FText (Size: 0x18)
WeaponRuleWDCFTableRow.FireRate = 0x100 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.EffectiveDistance = 0x110 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.FireRequireTags = 0x120 // TArray<FString> (Size: 0x10)
WeaponRuleWDCFTableRow.fi_require_tags = 0x130 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCFTableRow.AdapterFireRequireTags = 0x140 // TArray<FString> (Size: 0x10)
WeaponRuleWDCFTableRow.ad_require_tags = 0x150 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCFTableRow.FireRequireTagsDecrease = 0x160 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.de_require_tags = 0x170 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCFTableRow.ShouldReloadByOne = 0x180 // int8_t (Size: 0x1)
WeaponRuleWDCFTableRow.AccessoryType = 0x188 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.AdapterAdjustDamage = 0x198 // float (Size: 0x4)
WeaponRuleWDCFTableRow.Scope = 0x1a0 // FString (Size: 0x10)
WeaponRuleWDCFTableRow.ReloadSpeedRatio = 0x1b0 // float (Size: 0x4)
WeaponRuleWDCFTableRow.ADSMoveSpeedRatio = 0x1b4 // float (Size: 0x4)
WeaponRuleWDCFTableRow.MoveSpeedRatio = 0x1b8 // float (Size: 0x4)
WeaponRuleWDCTableRow.ItemId = 0x8 // uint32_t (Size: 0x4)
WeaponRuleWDCTableRow.BulletSize = 0x10 // FText (Size: 0x18)
WeaponRuleWDCTableRow.AmmoCapacity = 0x28 // uint32_t (Size: 0x4)
WeaponRuleWDCTableRow.size_ext = 0x30 // TArray<uint32_t> (Size: 0x10)
WeaponRuleWDCTableRow.CanFold = 0x40 // uint32_t (Size: 0x4)
WeaponRuleWDCTableRow.AssembleTag = 0x48 // FString (Size: 0x10)
WeaponRuleWDCTableRow.SubAssembleTag = 0x58 // FString (Size: 0x10)
WeaponRuleWDCTableRow.slot_type = 0x68 // uint64_t (Size: 0x8)
WeaponRuleWDCTableRow.sub_slot_type = 0x70 // uint64_t (Size: 0x8)
WeaponRuleWDCTableRow.Sockets = 0x78 // TArray<FWeaponSocket> (Size: 0x10)
WeaponRuleWDCTableRow.ConflictedItemIds = 0x88 // TArray<uint32_t> (Size: 0x10)
WeaponRuleWDCTableRow.Engonomics = 0x98 // float (Size: 0x4)
WeaponRuleWDCTableRow.Accuracy = 0x9c // float (Size: 0x4)
WeaponRuleWDCTableRow.MoaScale = 0xa0 // float (Size: 0x4)
WeaponRuleWDCTableRow.AdsMoaX = 0xa4 // float (Size: 0x4)
WeaponRuleWDCTableRow.AdsMoaY = 0xa8 // float (Size: 0x4)
WeaponRuleWDCTableRow.HorizontalRecoil = 0xac // float (Size: 0x4)
WeaponRuleWDCTableRow.VerticalRecoil = 0xb0 // float (Size: 0x4)
WeaponRuleWDCTableRow.SightRange = 0xb4 // float (Size: 0x4)
WeaponRuleWDCTableRow.MuzzleVelocity = 0xb8 // float (Size: 0x4)
WeaponRuleWDCTableRow.RaceStrategy = 0xbc // uint32_t (Size: 0x4)
WeaponRuleWDCTableRow.MaxCount = 0xc0 // float (Size: 0x4)
WeaponRuleWDCTableRow.Recoil = 0xc4 // float (Size: 0x4)
WeaponRuleWDCTableRow.ZeroDropDistance = 0xc8 // float (Size: 0x4)
WeaponRuleWDCTableRow.TypesOfFire = 0xd0 // FText (Size: 0x18)
WeaponRuleWDCTableRow.Caliber = 0xe8 // FText (Size: 0x18)
WeaponRuleWDCTableRow.FireRate = 0x100 // FString (Size: 0x10)
WeaponRuleWDCTableRow.EffectiveDistance = 0x110 // FString (Size: 0x10)
WeaponRuleWDCTableRow.FireRequireTags = 0x120 // TArray<FString> (Size: 0x10)
WeaponRuleWDCTableRow.fi_require_tags = 0x130 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCTableRow.AdapterFireRequireTags = 0x140 // TArray<FString> (Size: 0x10)
WeaponRuleWDCTableRow.ad_require_tags = 0x150 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCTableRow.FireRequireTagsDecrease = 0x160 // FString (Size: 0x10)
WeaponRuleWDCTableRow.de_require_tags = 0x170 // TArray<FWeaponTag> (Size: 0x10)
WeaponRuleWDCTableRow.ShouldReloadByOne = 0x180 // int8_t (Size: 0x1)
WeaponRuleWDCTableRow.AccessoryType = 0x188 // FString (Size: 0x10)
WeaponRuleWDCTableRow.AdapterAdjustDamage = 0x198 // float (Size: 0x4)
WeaponRuleWDCTableRow.Scope = 0x1a0 // FString (Size: 0x10)
WeaponRuleWDCTableRow.ReloadSpeedRatio = 0x1b0 // float (Size: 0x4)
WeaponRuleWDCTableRow.ADSMoveSpeedRatio = 0x1b4 // float (Size: 0x4)
WeaponRuleWDCTableRow.MoveSpeedRatio = 0x1b8 // float (Size: 0x4)
WeaponScopeScale.ID = 0x0 // uint64_t (Size: 0x8)
WeaponScopeScale.WeaponName = 0x8 // FText (Size: 0x18)
WeaponScopeScale.RoScale = 0x20 // float (Size: 0x4)
WeaponScopeScale.LoScale = 0x24 // float (Size: 0x4)
WeaponScopeScale.ADSGunKickScale = 0x28 // float (Size: 0x4)
WeaponSkinConfTableRow.SkinID = 0x8 // uint32_t (Size: 0x4)
WeaponSkinConfTableRow.ItemId = 0xc // int32_t (Size: 0x4)
WeaponSkinConfTableRow.SkinAssemble = 0x10 // int32_t (Size: 0x4)
WeaponSkinConfTableRow.IsStaticMesh = 0x14 // bool (Size: 0x1)
WeaponSkinConfTableRow.MeshPathGame = 0x18 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.MeshPathLobby = 0x30 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.MeshPathRollup = 0x48 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.OverrideMaterialsGame = 0x60 // TArray<FSkinMaterialInfo> (Size: 0x10)
WeaponSkinConfTableRow.OverrideMaterialsLobby = 0x70 // TArray<FSkinMaterialInfo> (Size: 0x10)
WeaponSkinConfTableRow.OverrideMaterials_Rollup = 0x80 // TArray<FSkinMaterialInfo> (Size: 0x10)
WeaponSkinConfTableRow.OverrideCheckWeaponHand = 0x90 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.OverrideCheckWeaponGun = 0xa8 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.OverrideAnimSet = 0xc0 // FSoftClassPath (Size: 0x18)
WeaponSkinConfTableRow.OverrideInvAnimBP = 0xd8 // FSoftClassPath (Size: 0x18)
WeaponSkinConfTableRow.OverrideInvAnimation = 0xf0 // TArray<FInvAnimationInfo> (Size: 0x10)
WeaponSkinConfTableRow.AdditionMeshAnimInfos = 0x100 // TArray<FAdditionMeshAnimInfo> (Size: 0x10)
WeaponSkinConfTableRow.IsSwitchSexuality = 0x110 // bool (Size: 0x1)
WeaponSkinConfTableRow.MeshPathGame_Female = 0x118 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.MeshPathLobby_Female = 0x130 // FSoftObjectPath (Size: 0x18)
WeaponSkinConfTableRow.CueClass = 0x148 // FSoftClassPath (Size: 0x18)
WeaponSocket.SocketName = 0x0 // FString (Size: 0x10)
WeaponSocket.PartName = 0x10 // FText (Size: 0x18)
WeaponSocket.SupportAdapterTagList = 0x28 // TArray<FString> (Size: 0x10)
WeaponSocket.masks = 0x38 // TArray<uint64_t> (Size: 0x10)
WeaponSocket.Types = 0x48 // TArray<uint64_t> (Size: 0x10)
WeaponSortCfgTableRow.ID = 0x8 // uint32_t (Size: 0x4)
WeaponSortCfgTableRow.WeaponType = 0xc // uint32_t (Size: 0x4)
WeaponSortCfgTableRow.WeaponItemID = 0x10 // uint32_t (Size: 0x4)
WeaponSortCfgTableRow.WeaponIndex = 0x14 // uint32_t (Size: 0x4)
WeaponTag.masks = 0x0 // TArray<uint64_t> (Size: 0x10)
WeaponTag.Types = 0x10 // TArray<uint64_t> (Size: 0x10)
WeatherRateItem.Weather = 0x0 // uint32_t (Size: 0x4)
WeatherRateItem.Weight = 0x4 // uint32_t (Size: 0x4)
WeeklyActivityAwardConfTableRow.award_id = 0x8 // uint32_t (Size: 0x4)
WeeklyActivityAwardConfTableRow.season_id = 0xc // uint32_t (Size: 0x4)
WeeklyActivityAwardConfTableRow.daily_active_point = 0x10 // uint32_t (Size: 0x4)
WeeklyActivityAwardConfTableRow.awards = 0x18 // TArray<FAwardItemConf> (Size: 0x10)
WeeklyClearVirtualItemConfTableRow.item_id = 0x8 // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.clear_period = 0xc // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.remain_num = 0x10 // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.need_clear = 0x14 // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.refill_period = 0x18 // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.refill_num = 0x1c // uint32_t (Size: 0x4)
WeeklyClearVirtualItemConfTableRow.limit_num = 0x20 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.target_id = 0xc // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.mode_ids = 0x10 // TArray<uint32_t> (Size: 0x10)
WeeklyCollectItemConfTableRow.map_ids = 0x20 // TArray<uint32_t> (Size: 0x10)
WeeklyCollectItemConfTableRow.rule_ids = 0x30 // TArray<uint32_t> (Size: 0x10)
WeeklyCollectItemConfTableRow.difficulties = 0x40 // TArray<uint32_t> (Size: 0x10)
WeeklyCollectItemConfTableRow.instigator_charactertype = 0x50 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.CountDownStartSeconds = 0x54 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.CollectionType = 0x58 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.CollectItemIDs = 0x60 // TArray<uint32_t> (Size: 0x10)
WeeklyCollectItemConfTableRow.Istakein = 0x70 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.instigator_stayvolume = 0x78 // FText (Size: 0x18)
WeeklyCollectItemConfTableRow.EquipItemType = 0x90 // uint32_t (Size: 0x4)
WeeklyCollectItemConfTableRow.EquipItemIDs = 0x98 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.target_id = 0xc // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.mode_ids = 0x10 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.map_ids = 0x20 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.rule_ids = 0x30 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.difficulties = 0x40 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.instigator_charactertype = 0x50 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.CountDownStartSeconds = 0x54 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.killedplayer_charactertypes = 0x58 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.instigator_stayvolume = 0x68 // FText (Size: 0x18)
WeeklyKillTargetConfTableRow.killedplayer_stayvolume = 0x80 // FText (Size: 0x18)
WeeklyKillTargetConfTableRow.KillerWeaponIDs = 0x98 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.RequireAdaptersIDs = 0xa8 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.EquipItemType = 0xb8 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.EquipItemIDs = 0xc0 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.MinDistance = 0xd0 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.MaxDistance = 0xd4 // uint32_t (Size: 0x4)
WeeklyKillTargetConfTableRow.EnduranceTypes = 0xd8 // TArray<uint32_t> (Size: 0x10)
WeeklyKillTargetConfTableRow.WeaponZoomTpye = 0xe8 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.task_id = 0x8 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.target_id = 0xc // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.mode_ids = 0x10 // TArray<uint32_t> (Size: 0x10)
WeeklyTakeOutItemConfTableRow.map_ids = 0x20 // TArray<uint32_t> (Size: 0x10)
WeeklyTakeOutItemConfTableRow.rule_ids = 0x30 // TArray<uint32_t> (Size: 0x10)
WeeklyTakeOutItemConfTableRow.difficulties = 0x40 // TArray<uint32_t> (Size: 0x10)
WeeklyTakeOutItemConfTableRow.instigator_charactertype = 0x50 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.CountDownStartSeconds = 0x54 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.ChangeValueToCount = 0x58 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.TakeOutItemIDs = 0x60 // TArray<uint32_t> (Size: 0x10)
WeeklyTakeOutItemConfTableRow.Istakein = 0x70 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.instigator_stayvolume = 0x78 // FText (Size: 0x18)
WeeklyTakeOutItemConfTableRow.EquipItemType = 0x90 // uint32_t (Size: 0x4)
WeeklyTakeOutItemConfTableRow.EquipItemIDs = 0x98 // TArray<uint32_t> (Size: 0x10)
WxGameShareConfTableRow.sys_id = 0x8 // uint32_t (Size: 0x4)
WxGameShareConfTableRow.Type = 0xc // uint32_t (Size: 0x4)
WxGameShareConfTableRow.act_id = 0x10 // uint32_t (Size: 0x4)
WxGameShareConfTableRow.content_id = 0x14 // uint32_t (Size: 0x4)
WxGameShareConfTableRow.share_reward = 0x18 // TArray<FWxGameShareRewardConf> (Size: 0x10)
WxGameShareRewardConf.item_id = 0x0 // uint32_t (Size: 0x4)
WxGameShareRewardConf.Num = 0x4 // uint32_t (Size: 0x4)
WxGameShareRewardConf.is_black = 0x8 // uint32_t (Size: 0x4)
actionChoiceItem.faction_id = 0x0 // uint32_t (Size: 0x4)
actionChoiceItem.faction_dec = 0x8 // FText (Size: 0x18)
exchangeItem.item_id = 0x0 // uint32_t (Size: 0x4)
exchangeItem.Num = 0x4 // uint32_t (Size: 0x4)
AICharacterMarkableInfo.AIID = 0x0 // int64_t (Size: 0x8)
AICharacterMarkableInfo.SpawnReason = 0x8 // EESpawnReason (Size: 0x1)
AICharacterMarkableInfo.ConfigID = 0xc // int32_t (Size: 0x4)
AISpawnPool.ToSpawnAIID = 0x0 // FName (Size: 0x8)
AISpawnPool.EquipmentPoolID = 0x8 // int32_t (Size: 0x4)
ARGWeaponInfo.WeaponAssembleId = 0x0 // int32_t (Size: 0x4)
ARGWeaponInfo.WeaponLevel = 0x4 // int32_t (Size: 0x4)
ASGFactionData.Faction = 0x0 // EEFactionType (Size: 0x1)
ASGFactionData.FactionColor = 0x4 // FLinearColor (Size: 0x10)
ASGFactionData.FactionPlayerList = 0x18 // TArray<FASGPlayerData> (Size: 0x10)
ASGFactionData.FactionLevel = 0x28 // int32_t (Size: 0x4)
ASGPlayerData.PlayerName = 0x0 // FString (Size: 0x10)
ASGPlayerData.PlayerGid = 0x10 // uint64_t (Size: 0x8)
ASGPlayerData.PlayerKillerNum = 0x18 // int32_t (Size: 0x4)
ASGPlayerData.PlayerDeathNum = 0x1c // int32_t (Size: 0x4)
ASGPlayerData.PlayerAssistNum = 0x20 // int32_t (Size: 0x4)
ASGPlayerData.bAlive = 0x24 // bool (Size: 0x1)
ASGPlayerData.PlayerIcon = 0x28 // FSGPlayerIconInfo (Size: 0x58)
ASGPlayerData.PlayerBanner = 0x80 // FSGPlayerBannerInfo (Size: 0x28)
ASGPlayerData.PlayerSex = 0xa8 // EECharacterSex (Size: 0x1)
ASGPlayerData.PlayerMemIndex = 0xac // int32_t (Size: 0x4)
ASGPlayerData.RankedLevel = 0xb0 // uint32_t (Size: 0x4)
ASGPlayerData.roomid = 0xb8 // uint64_t (Size: 0x8)
ASGPlayerData.PlayerLevel = 0xc0 // int32_t (Size: 0x4)
ASkeletalAnimSwitherRow.Asset = 0x0 // AnimationAsset* (Size: 0x8)
ASkeletalAnimSwitherRow.PlayTime = 0x8 // float (Size: 0x4)
ASkeletalAnimSwitherRow.bLooping = 0xc // bool (Size: 0x1)
AchievementBase.AchievementID = 0x3b8 // int32_t (Size: 0x4)
AchievementBase.bSubAchievement = 0x3bc // bool (Size: 0x1)
AchievementData.AchievementID = 0x0 // int32_t (Size: 0x4)
AchievementData.Progress = 0x4 // int32_t (Size: 0x4)
AchievementDistributerTableRow.AchievementID = 0x8 // int32_t (Size: 0x4)
AchievementDistributerTableRow.bSubAchievement = 0xc // bool (Size: 0x1)
AchievementDistributerTableRow.QuestDistributerClass = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
AchievementList.Achievements = 0x0 // TArray<FAchievementData> (Size: 0x10)
AchievementSubsystem.Player2JoinInAchievements = 0x40 // TMap<...> (Size: 0x50)
AchievementSubsystem.AchievementID2Objects = 0x90 // TMap<...> (Size: 0x50)
ActQuestTargetTemplateTableRow.TargetTypeID = 0x8 // int32_t (Size: 0x4)
ActQuestTargetTemplateTableRow.QuestClass = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
ActionDefine.EnabledContext = 0x0 // TArray<EEActionContext> (Size: 0x10)
ActivateLootPointConfig.LootPointType = 0x0 // int32_t (Size: 0x4)
ActivateLootPointConfig.ActivateMinCount = 0x4 // int32_t (Size: 0x4)
ActivateLootPointConfig.ActivateMaxCount = 0x8 // int32_t (Size: 0x4)
ActivateLootPointConfigs.ForceActivateLootPoints = 0x0 // TArray<int32_t> (Size: 0x10)
ActivateLootPointConfigs.ActivateConfigs = 0x10 // TArray<FActivateLootPointConfig> (Size: 0x10)
ActivityRequireDistributers.DistributerClasses = 0x0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
ActivityTemplateMissionTableRow.TargetTypeID = 0x8 // int32_t (Size: 0x4)
ActivityTemplateMissionTableRow.MissionFlowAsset = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
AnnounceConfigTableRow.AnnouncementID = 0x8 // int32_t (Size: 0x4)
AnnounceConfigTableRow.TemplateUMG = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
AnnounceConfigTableRow.Comment = 0x38 // FString (Size: 0x10)
AnnounceConfigTableRow.TitleText = 0x48 // FText (Size: 0x18)
AnnounceConfigTableRow.ContentText = 0x60 // FText (Size: 0x18)
AnnounceConfigTableRow.StyleTableKey = 0x78 // FName (Size: 0x8)
AnnounceConfigTableRow.MainImage = 0x80 // TSoftObjectPtr<UObject> (Size: 0x28)
AnnounceConfigTableRow.ReliableType = 0xa8 // EEAnnounceReliable (Size: 0x1)
AnnounceConfigTableRow.BroadcastDuration = 0xac // float (Size: 0x4)
AnnounceConfigTableRow.LifeDurationSec = 0xb0 // int32_t (Size: 0x4)
AnnounceConfigTableRow.PlayAudio = 0xb8 // AkAudioEvent* (Size: 0x8)
AnnounceConfigTableRow.PlayVoice = 0xc0 // FString (Size: 0x10)
AnnounceConfigTableRow.ExtraParams = 0xd0 // TMap<...> (Size: 0x50)
AnnounceHUDTaskInfo.TaskInfo = 0x0 // FAnnounceTaskInfo (Size: 0x30)
AnnounceHUDTaskInfo.SlotTypes = 0x30 // TSet<...> (Size: 0x50)
AnnounceHUDTaskInfo.AnnounceType = 0x80 // EEAnnounceType (Size: 0x1)
AnnounceInvokeConfig.OptionalAnnouncementID = 0x0 // int32_t (Size: 0x4)
AnnounceInvokeConfig.OptionalText = 0x8 // FText (Size: 0x18)
AnnounceInvokeConfig.ExternParams = 0x20 // TArray<int32_t> (Size: 0x10)
AnnounceRepArray.ServerArrayEndIndex = 0x0 // int32_t (Size: 0x4)
AnnounceRepArray.AnnounceTaskRingArray = 0x8 // TArray<FAnnounceTaskInfo> (Size: 0x10)
AnnounceStyleTable.Comment = 0x8 // FString (Size: 0x10)
AnnounceStyleTable.TemplateUMG = 0x18 // TSoftClassPtr<UObject> (Size: 0x28)
AnnounceStyleTable.MainImage = 0x40 // TSoftObjectPtr<UObject> (Size: 0x28)
AnnounceStyleTable.MainImgColor = 0x68 // FSlateColor (Size: 0x28)
AnnounceStyleTable.TemplateConfig = 0x90 // FAnnounceTemplates (Size: 0x150)
AnnounceTaskInfo.TaskId = 0x0 // int32_t (Size: 0x4)
AnnounceTaskInfo.AnnouncementID = 0x4 // int32_t (Size: 0x4)
AnnounceTaskInfo.TaskBeginTime = 0x8 // float (Size: 0x4)
AnnounceTaskInfo.ExternParams = 0x10 // TArray<int32_t> (Size: 0x10)
AnnounceTaskInfo.OptionalString = 0x20 // FString (Size: 0x10)
AnnounceTaskWaitAssetLoaded.TaskWaitWidgetAssetLoad = 0x0 // FAnnounceTaskInfo (Size: 0x30)
AnnounceTaskWaitAssetLoaded.WidgetClassPtr = 0x30 // TSoftClassPtr<UObject> (Size: 0x28)
AnnounceTemplateChangeTextColor.ContentTextColor = 0x0 // FSlateColor (Size: 0x28)
AnnounceTemplateCountDownBR.BackgroundColor = 0x0 // FSlateColor (Size: 0x28)
AnnounceTemplateCountDownBR.TimeTextColor = 0x28 // FSlateColor (Size: 0x28)
AnnounceTemplateTopInfoTips.SubImgColor = 0x0 // FSlateColor (Size: 0x28)
AnnounceTemplateTopInfoTips.TipsIconImg = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
AnnounceTemplateTopInfoTips.IconGlowEffectColor = 0x50 // FSlateColor (Size: 0x28)
AnnounceTemplateTopInfoTips.ContentTextColor = 0x78 // FSlateColor (Size: 0x28)
AnnounceTemplateTopInfoTips.TitleTextColor = 0xa0 // FSlateColor (Size: 0x28)
AnnounceTemplateTopInfoTips.AnimaToPlay = 0xc8 // int32_t (Size: 0x4)
AnnounceTemplates.TemplateType = 0x0 // EEAnnounceTemplateType (Size: 0x1)
AnnounceTemplates.countdown = 0x8 // FAnnounceTemplateCountDownBR (Size: 0x50)
AnnounceTemplates.TopInfoTips = 0x58 // FAnnounceTemplateTopInfoTips (Size: 0xd0)
AnnounceTemplates.ChangeTextColor = 0x128 // FAnnounceTemplateChangeTextColor (Size: 0x28)
AntiDataStruct.roomid = 0x0 // uint64_t (Size: 0x8)
AntiDataStruct.ClientVersion = 0x8 // FString (Size: 0x10)
AntiDataStruct.AntiData = 0x18 // FString (Size: 0x10)
AntiDataStruct.Source = 0x28 // uint32_t (Size: 0x4)
AntiDataStruct.bIsOverLength = 0x2c // uint32_t (Size: 0x4)
AreaDataInfo.Triggertype = 0x0 // int32_t (Size: 0x4)
AreaDataInfo.AreaID = 0x4 // int32_t (Size: 0x4)
AreaDataInfo.AreaName = 0x8 // FName (Size: 0x8)
AreaDataInfo.EnterTimeStamp = 0x10 // int64_t (Size: 0x8)
AreaDataInfo.EnterInventoryValue = 0x18 // float (Size: 0x4)
AreaDataInfo.EnterMainWeaponValue = 0x1c // int32_t (Size: 0x4)
AreaDataInfo.EnterSecondWeaponValue = 0x20 // int32_t (Size: 0x4)
AreaDataInfo.EnterSafeBoxValue = 0x24 // int32_t (Size: 0x4)
AreaDataInfo.EnterArmorValue = 0x28 // int32_t (Size: 0x4)
AreaRuntimeDataInSpawnGroup.AreaInfo = 0x0 // FAreaInfo (Size: 0x18)
AudioPropagateManager.VisibleNearistPortalNum = 0x310 // int32_t (Size: 0x4)
AudioPropagateManager.InVisiblePortalNum = 0x314 // int32_t (Size: 0x4)
AudioPropagateManager.FadeCollisionRadius = 0x318 // float (Size: 0x4)
AudioPropagateManager.AudioPortals = 0x320 // TArray<Actor*> (Size: 0x10)
BigMapAreaTextureInfo.AreaID = 0x0 // int32_t (Size: 0x4)
BigMapAreaTextureInfo.MapTexture = 0x8 // FBigMapTexture (Size: 0x30)
BigMapAreaTextureInfo.AreaName = 0x38 // FText (Size: 0x18)
BigMapAreaTextureInfo.MapScale = 0x50 // float (Size: 0x4)
BigMapAreaTextureInfo.MapUVOffset = 0x54 // FVector2D (Size: 0x8)
BigMapInfoActor.MapID = 0x310 // int32_t (Size: 0x4)
BigMapInfoActor.WorldCenter = 0x314 // FVector (Size: 0xc)
BigMapInfoActor.MapTopLeftLocation = 0x320 // FVector (Size: 0xc)
BigMapInfoActor.WorldNorthAngleOffset = 0x32c // FVector (Size: 0xc)
BigMapInfoActor.WorldExtent = 0x338 // FVector (Size: 0xc)
BigMapInfoActor.MapTexture = 0x348 // FBigMapTexture (Size: 0x30)
BigMapInfoActor.DefaultMapName = 0x378 // FString (Size: 0x10)
BigMapInfoActor.CoreAreaTexturePath = 0x388 // TSoftObjectPtr<UObject> (Size: 0x28)
BigMapInfoActor.MapAreaTextureInfos = 0x3b0 // TArray<FBigMapAreaTextureInfo> (Size: 0x10)
BigMapInfoActor.UncompressedSize = 0x3c0 // int32_t (Size: 0x4)
BigMapInfoActor.CompressedSize = 0x3c4 // int32_t (Size: 0x4)
BigMapInfoActor.CoreWidth = 0x3c8 // int32_t (Size: 0x4)
BigMapInfoActor.CoreHeight = 0x3cc // int32_t (Size: 0x4)
BigMapInfoActor.CompressedCoreAreaData = 0x3d0 // TArray<uint8_t> (Size: 0x10)
BigMapTexture.MapTexture = 0x0 // Texture2D* (Size: 0x8)
BigMapTexture.bEnable4Tiles = 0x8 // bool (Size: 0x1)
BigMapTexture.Map4TileTexture1 = 0x10 // Texture2D* (Size: 0x8)
BigMapTexture.Map4TileTexture2 = 0x18 // Texture2D* (Size: 0x8)
BigMapTexture.Map4TileTexture3 = 0x20 // Texture2D* (Size: 0x8)
BigMapTexture.Map4TileTexture4 = 0x28 // Texture2D* (Size: 0x8)
BulletDamageStruct.WeaponName = 0x0 // FString (Size: 0x10)
BulletDamageStruct.BulletName = 0x10 // FString (Size: 0x10)
BulletDamageStruct.WeaponType = 0x20 // FString (Size: 0x10)
BulletDamageStruct.HitCharacter = 0x30 // int32_t (Size: 0x4)
BulletDamageStruct.HitArmor = 0x34 // int32_t (Size: 0x4)
BulletDamageStruct.HitEndurance = 0x38 // int32_t (Size: 0x4)
BulletDamageStruct.HitGroup = 0x3c // int32_t (Size: 0x4)
BulletDamageStruct.HitEnduranceDamage = 0x40 // float (Size: 0x4)
BulletDamageStruct.HitSubEndurance = 0x44 // int32_t (Size: 0x4)
BulletDamageStruct.HitSubGroup = 0x48 // int32_t (Size: 0x4)
BulletDamageStruct.HitSubEnduranceDamage = 0x4c // float (Size: 0x4)
BulletDampingBind.PhysicalMaterial = 0x0 // PhysicalMaterial* (Size: 0x8)
BulletDampingBind.DampingParam = 0x8 // FBulletDampingParam (Size: 0x10)
BulletDampingParam.VelSub = 0x0 // float (Size: 0x4)
BulletDampingParam.DamageSub = 0x4 // float (Size: 0x4)
BulletDampingParam.PenetrationSub = 0x8 // float (Size: 0x4)
BulletDampingParam.Density = 0xc // float (Size: 0x4)
CAAICharacter.AimingRotationOffset = 0x1e08 // uint32_t (Size: 0x4)
CAAICharacter.bUseInterpConstant = 0x1e18 // bool (Size: 0x1)
CAAssembleEnvironment.ForceActiveTime = 0x990 // float (Size: 0x4)
CAAssembleEnvironment.ForcedLodModel = 0x994 // int32_t (Size: 0x4)
CAAssembleEnvironment.RotateSpeed = 0x998 // float (Size: 0x4)
CAAssembleEnvironment.CameraPosXOffset = 0x99c // float (Size: 0x4)
CAAssembleEnvironment.CameraPosXRate = 0x9a0 // float (Size: 0x4)
CAAssembleEnvironment.CameraPosXItemGridRate = 0x9a4 // float (Size: 0x4)
CAAssembleEnvironment.WeaponOffsetRate = 0x9a8 // float (Size: 0x4)
CAAssembleEnvironment.WeaponOffset = 0x9ac // float (Size: 0x4)
CAAssembleEnvironment.CamMaxRate = 0x9b0 // float (Size: 0x4)
CAAssembleEnvironment.CamMinRate = 0x9b4 // float (Size: 0x4)
CAAssembleEnvironment.CameraPosXOverrideConf = 0x9b8 // DataTable* (Size: 0x8)
CAAssembleEnvironment.ExtraCaptureCameraConfMap = 0x9c0 // TMap<...> (Size: 0x50)
CAAssembleEnvironment.bAllowCacheShowInfo = 0xa10 // bool (Size: 0x1)
CAAssembleEnvironment.ShowType = 0xa14 // int32_t (Size: 0x4)
CAAssembleEnvironment.RotateComp = 0xa18 // SceneComponent* (Size: 0x8)
CAAssembleEnvironment.AssembleRTMaterial = 0xa20 // MaterialInstanceDynamic* (Size: 0x8)
CAAssembleEnvironment.CacheImage = 0xa68 // Object* (Size: 0x8)
CAAssembleEnvironment.CacheInventory = 0xa70 // SGInventory* (Size: 0x8)
CACameraAdvancedFocus.position = 0x0 // FVector (Size: 0xc)
CACameraAdvancedFocus.Rotation = 0xc // FRotator (Size: 0xc)
CACameraChangeArray.SpeedItem = 0x0 // TArray<FCACameraChangeFocusSpeed> (Size: 0x10)
CACameraChangeFocusSpeed.Name = 0x0 // FString (Size: 0x10)
CACameraChangeFocusSpeed.Speed = 0x10 // float (Size: 0x4)
CACharacterAIAimingComponent.TargetActor = 0x278 // Actor* (Size: 0x8)
CACharacterAIAimingComponent.RotationOffsetInterpSpeed = 0x298 // float (Size: 0x4)
CACharacterAIAimingComponent.TargetPoint = 0x29c // FVector (Size: 0xc)
CACharacterAIAimingComponent.FocalProgressInInterpSpeed = 0x2ac // float (Size: 0x4)
CACharacterAIAimingComponent.FocalProgressOutInterpSpeed = 0x2b0 // float (Size: 0x4)
CACharacterAIAimingComponent.AOLimit = 0x2b4 // float (Size: 0x4)
CAClimateRain.OcclusionDryRate = 0x548 // float (Size: 0x4)
CAClimateRain.OcclusionWetnessRate = 0x54c // float (Size: 0x4)
CAClimateRain.ShadowCaptureESMParameters = 0x550 // FShadowCaptureParameters (Size: 0x28)
CAClimateRain.bEnableESMParametersUpdate = 0x5a0 // bool (Size: 0x1)
CAClimateSceneLightingComponent.SunLight = 0x118 // DirectionalLight* (Size: 0x8)
CAClimateSceneLightingComponent.MoonLight = 0x120 // DirectionalLight* (Size: 0x8)
CAClimateSceneLightingComponent.BindSun = 0x128 // MFClimateCelestialBody* (Size: 0x8)
CAClimateSceneLightingComponent.BindMoon = 0x130 // MFClimateCelestialBody* (Size: 0x8)
CAClimateSceneLightingComponent.SkyLight = 0x138 // SkyLight* (Size: 0x8)
CAClimateSceneLightingComponent.SkyAtmosphere = 0x140 // SkyAtmosphere* (Size: 0x8)
CAClimateSceneLightingComponent.Fog = 0x148 // ExponentialHeightFog* (Size: 0x8)
CAClimateSceneLightingComponent.bEnableSkyFogControl = 0x150 // bool (Size: 0x1)
CAClimateSceneLightingComponent.SkyIntensity = 0x154 // float (Size: 0x4)
CAClimateSceneLightingComponent.FogIntensity = 0x158 // float (Size: 0x4)
CAClimateSceneLightingComponent.SkyLightIntensity = 0x15c // float (Size: 0x4)
CAClimateSceneLightingComponent.GlobalShadow = 0x160 // float (Size: 0x4)
CAClimateSceneLightingComponent.SkyColor = 0x164 // FLinearColor (Size: 0x10)
CAClimateSceneLightingComponent.SunLightColor = 0x174 // FLinearColor (Size: 0x10)
CAClimateSceneLightingComponent.CloudIntensity = 0x184 // float (Size: 0x4)
CAClimateSceneLightingComponent.bAutoUpdateCloudCastShadow = 0x188 // bool (Size: 0x1)
CAClimateSceneLightingComponent.CastCloudShadowTransferTime = 0x18c // float (Size: 0x4)
CAClimateSceneLightingComponent.CloudShadowValue = 0x190 // float (Size: 0x4)
CAClimateSceneLightingComponent.SunDirection = 0x194 // FVector (Size: 0xc)
CAClimateSceneLightingComponent.MoonDirection = 0x1a0 // FVector (Size: 0xc)
CAClimateSceneLightingComponent.SunLightComponent = 0x1b0 // DirectionalLightComponent* (Size: 0x8)
CAClimateSceneLightingComponent.MoonLightComponent = 0x1b8 // DirectionalLightComponent* (Size: 0x8)
CAClimateSceneLightingComponent.CurrentLightningSceneLightColor = 0x1c0 // FLinearColor (Size: 0x10)
CAClimateSceneLightingComponent.LightningFakeLight = 0x1d0 // DirectionalLightComponent* (Size: 0x8)
CAExpCaculator_BlueprintBase.bShowExpTip = 0x28 // bool (Size: 0x1)
CAGameUserSettings.SettingConfigVersion = 0x324 // int32_t (Size: 0x4)
CAGameUserSettings.LanguageString = 0x328 // FString (Size: 0x10)
CAGameUserSettings.AudioLanguageString = 0x338 // FString (Size: 0x10)
CAGameUserSettings.IsAdviseOpen = 0x348 // bool (Size: 0x1)
CAGameUserSettings.IsPrivacyOpen = 0x349 // bool (Size: 0x1)
CAGameUserSettings.IsShowRoomVisitOpen = 0x34a // bool (Size: 0x1)
CAGameUserSettings.UIShowType = 0x350 // TMap<...> (Size: 0x50)
CAGameUserSettings.BoolValue = 0x3a0 // TMap<...> (Size: 0x50)
CAGameUserSettings.VoiceMode = 0x3f0 // int32_t (Size: 0x4)
CAGameUserSettings.VoiceRoomType = 0x3f4 // int32_t (Size: 0x4)
CAGameUserSettings.ChatRoomType = 0x3f8 // int32_t (Size: 0x4)
CAGameUserSettings.ListenChannelType = 0x3fc // int32_t (Size: 0x4)
CAGameUserSettings.CustomGraphcisMode = 0x400 // int32_t (Size: 0x4)
CAGameUserSettings.FocusTaskID = 0x404 // int32_t (Size: 0x4)
CAGameUserSettings.FocusTaskTargetProgress = 0x408 // TMap<...> (Size: 0x50)
CAGameUserSettings.bInfiniteAmmo = 0x458 // bool (Size: 0x1)
CAGameUserSettings.bInfiniteEndurance = 0x459 // bool (Size: 0x1)
CAGameUserSettings.bDefault2KResolution = 0x45a // bool (Size: 0x1)
CAGameUserSettings.bCAUseGPUCrashDebugging = 0x45b // bool (Size: 0x1)
CAGameUserSettings.bEnableLobbyFrameLimit = 0x45c // bool (Size: 0x1)
CAGameUserSettings.TotalMaxFPS = 0x460 // float (Size: 0x4)
CAGameUserSettings.bEnableBackgroundFrameLimit = 0x464 // bool (Size: 0x1)
CAGameUserSettings.bDisableToggleFullscreenmode = 0x465 // bool (Size: 0x1)
CAGameUserSettings.IsHitCloseBag = 0x466 // bool (Size: 0x1)
CAGameUserSettings.bIsItemAutoJump = 0x467 // bool (Size: 0x1)
CAGameUserSettings.bIsAnchorMode = 0x468 // bool (Size: 0x1)
CAGameUserSettings.LastReportTimestamp = 0x470 // int64_t (Size: 0x8)
CAGameUserSettings.BattleShadowQuality = 0x478 // int32_t (Size: 0x4)
CAGameUserSettings.bIsOpenVRS = 0x47c // bool (Size: 0x1)
CAGameUserSettings.bEnableScreenCenterPoint = 0x47d // bool (Size: 0x1)
CAGameUserSettings.DLSSModelType = 0x480 // int32_t (Size: 0x4)
CAGameUserSettings.FrameInterpolationType = 0x484 // int32_t (Size: 0x4)
CAGameUserSettings.bAllowInvitationFromFriends = 0x488 // bool (Size: 0x1)
CAGameUserSettings.bAllowInvitationFromStrangers = 0x489 // bool (Size: 0x1)
CAGameUserSettings.bJumpDialog = 0x48a // bool (Size: 0x1)
CAGameUserSettings.bPrivacyLeaderOpen = 0x48b // bool (Size: 0x1)
CAGameUserSettings.ScopeQualityLevel = 0x48c // int32_t (Size: 0x4)
CAGameUserSettings.bShowSightSetting = 0x490 // bool (Size: 0x1)
CAGameUserSettings.bEnableAutoRotateItem = 0x491 // bool (Size: 0x1)
CAGameUserSettings.ReflexMode = 0x492 // uint8_t (Size: 0x1)
CAGameUserSettings.bDoubleClickMoveItem = 0x493 // bool (Size: 0x1)
CAGameUserSettings.bPinSafeBox = 0x494 // bool (Size: 0x1)
CAGameUserSettings.bFirstTimeToIntelligenceKey = 0x495 // bool (Size: 0x1)
CAGameUserSettings.RayTracingQuality = 0x498 // int32_t (Size: 0x4)
CAGameUserSettings.bEnableRayTracing = 0x49c // bool (Size: 0x1)
CAGameUserSettings.LandscapeQuality = 0x4a0 // int32_t (Size: 0x4)
CAGameUserSettings.bShowAvatarInBag = 0x4a4 // bool (Size: 0x1)
CAHardwareCheckConfigTableRow.CheckValueName = 0x8 // FString (Size: 0x10)
CAHardwareCheckConfigTableRow.Value = 0x18 // float (Size: 0x4)
CAHardwareCheckConfigTableRow.Comment = 0x20 // FString (Size: 0x10)
CAMaxFrameControlSubsystem.LobbyMaxFPS = 0x40 // float (Size: 0x4)
CAMaxFrameControlSubsystem.BattleMaxFPS = 0x44 // float (Size: 0x4)
CAMaxFrameControlSubsystem.MinimizedMaxFPS = 0x48 // float (Size: 0x4)
CAMaxFrameControlSubsystem.BackgroundMaxFPS = 0x4c // float (Size: 0x4)
CAMaxFrameControlSubsystem.bRegistered = 0x50 // bool (Size: 0x1)
CAMaxFrameControlSubsystem.bWindowDeactivated = 0x51 // bool (Size: 0x1)
CAMaxFrameControlSubsystem.bEnableBackgroundFrameLimit = 0x52 // bool (Size: 0x1)
CAMessageEvents.QuickChat = 0x30 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.SpeakingRouletteX = 0x40 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.SpeakingRouletteY = 0x50 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.OnAwardExp = 0x60 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.ThrowGrenadeInventory = 0x70 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.JumpInputActionEvent = 0x80 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.CloseRouletteActionEvent = 0x90 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.OpenRouletteActionEvent = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.OpenMousePinRouletteActionEvent = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
CAMessageEvents.CloseMousePinRouletteActionEvent = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
CANPCAIBehaviorHistoryDebugComponent.DecisionCounter = 0x110 // TMap<...> (Size: 0x50)
CANPCAIBehaviorHistoryDebugComponent.HitGroupCounter = 0x160 // TArray<int32_t> (Size: 0x10)
CANPCAIBehaviorHistoryDebugComponent.BBKey_Dec_CrossFireDecision = 0x170 // FName (Size: 0x8)
CANPCAIBehaviorHistoryDebugComponent.MarkedPlayerController = 0x178 // TArray<PlayerController*> (Size: 0x10)
CANPCAIBehaviorHistoryDebugComponent.MaxHistorySize = 0x18c // int32_t (Size: 0x4)
CANPCAIBehaviorHistoryDebugComponent.BehaviorComp = 0x190 // CABehaviorTreeComponent* (Size: 0x8)
CAPCAimingComponent.AimingProritySwitchDesire = 0x1b8 // float (Size: 0x4)
CAPCAimingComponent.ScatteredItemsLootRadius = 0x1bc // float (Size: 0x4)
CAPCAimingComponent.ScatteredItemsCheckRadius = 0x1c0 // float (Size: 0x4)
CAPCAimingComponent.CachedInteractableItem = 0x1d0 // Actor* (Size: 0x8)
CAPCInputHandleComponent.LocalizationKey_CannotProne_UsingItem = 0x168 // FString (Size: 0x10)
CAPCInputHandleComponent.OperationBlockMessages = 0x178 // TMap<...> (Size: 0x50)
CAPCInputHandleComponent.ActionContextMapping = 0x1c8 // TMap<...> (Size: 0x50)
CAPCInputHandleComponent.ContextDefine = 0x218 // TMap<...> (Size: 0x50)
CAPCInputHandleComponent.InpuContextStack = 0x268 // TArray<EEActionContext> (Size: 0x10)
CAPCInputHandleComponent.HoldTime = 0x2d0 // float (Size: 0x4)
CAPCInputHandleComponent.bBlackStoreOpen = 0x2d4 // bool (Size: 0x1)
CAPCMousePinComponent.CheckDistance = 0x100 // float (Size: 0x4)
CAPCMousePinComponent.LastHitActorCache = 0x108 // Actor* (Size: 0x8)
CAPCMousePinComponent.bIsUpPosition = 0x110 // bool (Size: 0x1)
CAPCMousePinComponent.bIsDownPosition = 0x111 // bool (Size: 0x1)
CAPCMousePinComponent.CurrentPinEdge = 0x112 // EEPinEdge (Size: 0x1)
CAPCMousePinComponent.CosAngle = 0x114 // float (Size: 0x4)
CAPCMousePinComponent.ProneSizeSquared2D = 0x118 // float (Size: 0x4)
CAPCMousePinComponent.AllVolume = 0x120 // TArray<Actor*> (Size: 0x10)
CAPCRunTimeGiveEquipComponent.MainWeaponInfo = 0x100 // FMinimalPlayerItemInfoBase (Size: 0x10)
CAPCRunTimeGiveEquipComponent.EquipItemsGiveAry = 0x110 // TArray<FMinimalPlayerItemInfoBase> (Size: 0x10)
CAPCRunTimeGiveEquipComponent.InventoryItemsGiveAry = 0x120 // TArray<FMinimalPlayerItemInfoBase> (Size: 0x10)
CAPCRunTimeGiveEquipComponent.ExtraSkinMap = 0x130 // TMap<...> (Size: 0x50)
CAPCRunTimeGiveEquipComponent.OverrideSkinMap = 0x180 // TMap<...> (Size: 0x50)
CAPCRunTimeGiveEquipComponent.NoUseSelfSkinIDArray = 0x1d0 // TArray<int32_t> (Size: 0x10)
CAPCRunTimeGiveEquipComponent.bIsOnlyWeapon = 0x1e0 // bool (Size: 0x1)
CAPCRunTimeGiveEquipComponent.ServerCurGivingWeapon = 0x1e8 // SGInventory* (Size: 0x8)
CAPCRunTimeGiveEquipComponent.ClientCurGivingWeapon = 0x1f0 // SGInventory* (Size: 0x8)
CAPCRunTimeGiveEquipComponent.GiveInfoStart = 0x1f8 // FRunTimeGiveInfo_ClientStart (Size: 0x8)
CAPCRunTimeGiveEquipComponent.GiveInfoSwitchWeapon = 0x200 // FRunTimeGiveInfo_ClientSwitchToWeapon (Size: 0x8)
CAPCRunTimeGiveEquipComponent.GiveInfoStop = 0x208 // FRunTimeGiveInfo_Stop (Size: 0x4)
CAPCRunTimeGiveEquipComponent.MaxSlicedGiveTime = 0x278 // float (Size: 0x4)
CAPCRunTimeGiveEquipComponent.ServerSafeTime_WaitClientToMelee = 0x27c // float (Size: 0x4)
CAPCRunTimeGiveEquipComponent.ClientSafeTime_WaitToGivingWeapon = 0x280 // float (Size: 0x4)
CAPCRunTimeGiveEquipComponent.ServerSafeTime_WaitNetState = 0x284 // float (Size: 0x4)
CAPCRunTimeGiveEquipComponent.IsClearHiddenFlagInClient = 0x288 // bool (Size: 0x1)
CAPCRunTimeGiveEquipComponent.IsAutoPullBolt = 0x289 // bool (Size: 0x1)
CAPCRunTimeGiveEquipComponent.RemoveItemType = 0x290 // TArray<EESGInvItemIdType> (Size: 0x10)
CAPCRunTimeGiveEquipComponent.RemoveItemTypeOnlyWeapon = 0x2a0 // TArray<EESGInvItemIdType> (Size: 0x10)
CAPCSuitEquipARGComponent.PreInvCreateNum = 0x2a0 // int32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.AllSuitInfoAry = 0x100 // TArray<FSuitInfo> (Size: 0x10)
CAPCSuitEquipBaseComponent.SkinMap = 0x110 // TMap<...> (Size: 0x50)
CAPCSuitEquipBaseComponent.SuitSelectAry = 0x160 // TArray<FSuitInfo> (Size: 0x10)
CAPCSuitEquipBaseComponent.LastSelectSuitInfo = 0x170 // FSuitInfo (Size: 0x40)
CAPCSuitEquipBaseComponent.MaxColumnNum = 0x1b0 // int32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.GameModeType = 0x1b4 // EESGGameModeType (Size: 0x1)
CAPCSuitEquipBaseComponent.bIsFillPoolComponent = 0x1b5 // bool (Size: 0x1)
CAPCSuitEquipBaseComponent.GiveEquipFireStateDelayTime = 0x1b8 // float (Size: 0x4)
CAPCSuitEquipBaseComponent.IsAlwaysGiveByBagClose_DebugFlag = 0x1c8 // bool (Size: 0x1)
CAPCSuitEquipBaseComponent.IsGiveLastClickSuit_DebugFlag = 0x1c9 // bool (Size: 0x1)
CAPCSuitEquipBaseComponent.IsAlwaysCanSuitSelect_DebugFlag = 0x1ca // bool (Size: 0x1)
CAPCSuitEquipBaseComponent.IsGenerateTestItemSkin = 0x1cb // bool (Size: 0x1)
CAPCSuitEquipBaseComponent.TestWeaponSkinIDMin = 0x1cc // uint32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.TestWeaponSkinIDMax = 0x1d0 // uint32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.TestEquipSkinIDMin = 0x1d4 // uint32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.TestEquipSkinIDMax = 0x1d8 // uint32_t (Size: 0x4)
CAPCSuitEquipBaseComponent.TestExtraSkinAry = 0x1e0 // TArray<uint32_t> (Size: 0x10)
CAPCSuitEquipBaseComponent.TLogSuitSelectInfoAry = 0x1f0 // TArray<FTLogSuitSelectInfo> (Size: 0x10)
CAPCSuitEquipBaseComponent.LastGiveSuitInfo = 0x258 // FSuitInfo (Size: 0x40)
CAPCSuitEquipRWGComponent.LastBeforeSelectSuitInfo = 0x2f0 // FSuitInfo (Size: 0x40)
CAQuestHUD.QuestWidget = 0x290 // TMap<...> (Size: 0x50)
CATargetMonitorComponent.MonitorActor = 0x5f0 // TWeakObjectPtr<UObject> (Size: 0x8)
CATargetMonitorComponent.MonitorWidget = 0x5f8 // TWeakObjectPtr<UObject> (Size: 0x8)
CATargetMonitorComponent.HitHistory = 0x600 // TArray<FVector> (Size: 0x10)
CATargetMonitorComponent.bValidHit = 0x610 // bool (Size: 0x1)
CATargetMonitorWidget.TargetMonitorComponentList = 0x2f0 // TArray<CATargetMonitorComponent*> (Size: 0x10)
CATargetMonitorWidget.OwnerWidgetComponent = 0x300 // WidgetComponent* (Size: 0x8)
CAUserWidget_DebugTeammateInfo.bStartDebug = 0x2f0 // bool (Size: 0x1)
CAUserWidget_DebugTeammateInfo.bUsingSceneCapture = 0x2f1 // bool (Size: 0x1)
CAUserWidget_DebugTeammateInfo.ScopeRange = 0x2f4 // FScopeRangeForTeammateIcon (Size: 0x2c)
CAUserWidget_DebugTeammateInfo.MaterialPoint = 0x320 // FVector2D (Size: 0x8)
CAUserWidget_DebugTeammateInfo.ScreenPointInside = 0x328 // FVector2D (Size: 0x8)
CAUserWidget_DebugTeammateInfo.ScreenPointOutside = 0x330 // FVector2D (Size: 0x8)
CAUserWidget_DebugTeammateInfo.ShowRange = 0x338 // FBox2D (Size: 0x14)
CAUserWidget_DebugTeammateInfo.HideRange = 0x34c // FBox2D (Size: 0x14)
CAUserWidget_DebugTeammateInfo.MaterialRange = 0x360 // FBox2D (Size: 0x14)
CAUserWidget_DebugTeammateInfo.bInsideScope = 0x374 // bool (Size: 0x1)
CAUserWidget_DebugTeammateInfo.ScopeRadius = 0x378 // float (Size: 0x4)
CAUserWidget_DebugTeammateInfo.LocationZ = 0x37c // float (Size: 0x4)
CAUserWidget_DebugTeammateInfo.DebugLocationZ = 0x380 // float (Size: 0x4)
CAUserWidget_SceneWidgetBase.ZoomingThreshold = 0x2f0 // float (Size: 0x4)
CAUserWidget_SceneWidgetBase.BiasX = 0x2f4 // float (Size: 0x4)
CAUserWidget_SceneWidgetBase.BiasY = 0x2f8 // float (Size: 0x4)
CAUserWidget_TeammateInfo.DebugWidgetClass = 0x300 // ClassProperty (Size: 0x8)
CAWeaponRenderView.RotateSpeed = 0x908 // float (Size: 0x4)
CAWeaponRenderView.CamBasePosX = 0x90c // float (Size: 0x4)
CAWeaponRenderView.CamBasePosY = 0x910 // float (Size: 0x4)
CAWeaponRenderView.CamOffsetScale = 0x914 // float (Size: 0x4)
CAWeaponRenderView.CamDistanceScale = 0x918 // float (Size: 0x4)
CAWeaponRenderView.CamMoveTime = 0x91c // float (Size: 0x4)
CAWeaponRenderView.FullScreenCamChangeSpeedX = 0x920 // float (Size: 0x4)
CAWeaponRenderView.AutoRotateSpeed = 0x924 // float (Size: 0x4)
CAWeaponRenderView.RotatorConf = 0x928 // DataTable* (Size: 0x8)
CacheModifyData.Characters = 0x0 // TArray<Character*> (Size: 0x10)
CanBeDestroyedActorConfig.ConfigName = 0x0 // FString (Size: 0x10)
CanBeDestroyedActorConfig.PropMesh = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
CanBeDestroyedActorConfig.DestroyedParticle = 0x38 // TSoftObjectPtr<UObject> (Size: 0x28)
CanBeDestroyedActorConfig.DestroyedAudio = 0x60 // AkAudioEvent* (Size: 0x8)
CanBeDestroyedActorConfig.MaxHealth = 0x68 // float (Size: 0x4)
CanBeDestroyedActorConfig.DelayDestroyedAfterBroken = 0x6c // float (Size: 0x4)
CanBeDestroyedActorConfig.DropLocationBias = 0x70 // FVector (Size: 0xc)
CanBeDestroyedActorConfig.BrokenDropTimes = 0x7c // int32_t (Size: 0x4)
CanBeDestroyedActorConfig.BrokenDropInventoryIDs = 0x80 // TArray<int32_t> (Size: 0x10)
CanBeDestroyedActorConfig.BrokenDropInventoryItemNum = 0x90 // TArray<int32_t> (Size: 0x10)
CanBeDestroyedActorConfig.BrokenDropInventoryWeights = 0xa0 // TArray<float> (Size: 0x10)
CanBeDestroyedActorConfigTableRow.ConfigID = 0x8 // int32_t (Size: 0x4)
CanBeDestroyedActorConfigTableRow.Config = 0x10 // FCanBeDestroyedActorConfig (Size: 0xb0)
CaptureCameraConf.CameraPosXOffset = 0x0 // float (Size: 0x4)
CaptureCameraConf.CameraPosXRate = 0x4 // float (Size: 0x4)
CaptureCameraConf.CameraPosXItemGridRate = 0x8 // float (Size: 0x4)
CaptureCameraConf.WeaponOffsetRate = 0xc // float (Size: 0x4)
CaptureCameraConf.WeaponOffset = 0x10 // float (Size: 0x4)
CaptureCameraConf.CamMaxRate = 0x14 // float (Size: 0x4)
CaptureCameraConf.CamMinRate = 0x18 // float (Size: 0x4)
CaptureCameraConf.CameraPosXOverrideConf = 0x20 // DataTable* (Size: 0x8)
CaptureCameraConf.DefineRTSize = 0x28 // FVector2D (Size: 0x8)
CapturePointFactionConfig.PositiveRate = 0x0 // float (Size: 0x4)
CapturePointFactionConfig.InverseRate = 0x4 // float (Size: 0x4)
CapturePointFactionConfig.DecayRate = 0x8 // float (Size: 0x4)
CapturePointFactionConfig.PositiveCoefficient = 0xc // float (Size: 0x4)
CapturePointFactionConfig.InverseCoefficient = 0x10 // float (Size: 0x4)
CapturePointFactionConfig.AdditionCoefficient = 0x14 // float (Size: 0x4)
CapturePointFactionConfig.MaxPositiveCoefficient = 0x18 // float (Size: 0x4)
CapturePointFactionConfig.MaxInverseCoefficient = 0x1c // float (Size: 0x4)
CapturePointFactionConfig.MaxAdditionCoefficient = 0x20 // float (Size: 0x4)
CapturePointFactionConfig.CapturePointVecColor = 0x24 // FVector (Size: 0xc)
CapturePointFactionInfo.BelongFactionType = 0x0 // EEFactionType (Size: 0x1)
CapturePointFactionInfo.BiasFactionType = 0x1 // EEFactionType (Size: 0x1)
CapturePointFactionInfo.CurFactionType = 0x2 // EEFactionType (Size: 0x1)
CapturePointFactionInfo.CurDateTime = 0x8 // FDateTime (Size: 0x8)
CapturePointFactionInfo.CurProgress = 0x10 // float (Size: 0x4)
CapturePointFactionInfo.CurRate = 0x14 // float (Size: 0x4)
ChangeWeaponOrStartFireStruct.FireID = 0x0 // uint64_t (Size: 0x8)
ChangeWeaponOrStartFireStruct.WeaponName = 0x8 // FString (Size: 0x10)
ChangeWeaponOrStartFireStruct.bIsChangeWeaponOrStartFire = 0x18 // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.bHitCharacter = 0x1c // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitEndurance = 0x20 // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitGroup = 0x24 // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitEnduranceDamage = 0x28 // float (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitSubEndurance = 0x2c // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitSubGroup = 0x30 // int32_t (Size: 0x4)
ChangeWeaponOrStartFireStruct.HitSubEnduranceDamage = 0x34 // float (Size: 0x4)
CharacterAttributeCheckInfo.bUseCustomAttribute = 0x28 // bool (Size: 0x1)
CharacterAttributeCheckInfo.Attribute = 0x30 // FGameplayAttribute (Size: 0x38)
CharacterAttributeCheckInfo.CustomAttribute = 0x68 // EEQuestCheckCustomAttribute (Size: 0x1)
CharacterAttributeCheckInfo.MinValue = 0x6c // float (Size: 0x4)
CharacterAttributeCheckInfo.MaxValue = 0x70 // float (Size: 0x4)
CharacterGameplayTagCheckInfo.TagContainer = 0x28 // FGameplayTagContainer (Size: 0x20)
CharacterGameplayTagCheckInfo.CheckType = 0x48 // EEGameplayTagCheckType (Size: 0x1)
ChaseActivityInvMarkScaleInfo.Distance = 0x0 // float (Size: 0x4)
ChaseActivityInvMarkScaleInfo.Scale = 0x4 // float (Size: 0x4)
CheckAccuracy.MinAccuracy = 0x28 // float (Size: 0x4)
CheckAccuracy.MaxAccuracy = 0x2c // float (Size: 0x4)
CheckAdsMoa.AdsMoaXMin = 0x28 // float (Size: 0x4)
CheckAdsMoa.AdsMoaXMax = 0x2c // float (Size: 0x4)
CheckAdsMoa.AdsMoaYMin = 0x30 // float (Size: 0x4)
CheckAdsMoa.AdsMoaYMax = 0x34 // float (Size: 0x4)
CheckBulletItemId.ValidBulletIds = 0x28 // TArray<uint64_t> (Size: 0x10)
CheckCaptureWeaponZoomType.ZoomType = 0x28 // EESGZoomType (Size: 0x1)
CheckCurrentBulletCount.MinBulletCount = 0x28 // int32_t (Size: 0x4)
CheckCurrentBulletCount.MaxBulletCount = 0x2c // int32_t (Size: 0x4)
CheckDamageTypeClass.DamageTypeClass = 0x28 // ClassProperty (Size: 0x8)
CheckDurability.MinDurability = 0x28 // float (Size: 0x4)
CheckDurability.MaxDurability = 0x2c // float (Size: 0x4)
CheckEngonomics.MinEngonomics = 0x28 // float (Size: 0x4)
CheckEngonomics.MaxEngonomics = 0x2c // float (Size: 0x4)
CheckExclusionAdapters.ExclusionAdapters = 0x28 // TArray<uint64_t> (Size: 0x10)
CheckFireMode.FireMode = 0x28 // EESGWeaponShootingMode (Size: 0x1)
CheckHorizontalRecoil.MinHorizontalRecoil = 0x28 // float (Size: 0x4)
CheckHorizontalRecoil.MaxHorizontalRecoil = 0x2c // float (Size: 0x4)
CheckIsTakeInItem.bIsTakeIn = 0x28 // bool (Size: 0x1)
CheckItemTypeID.ItemTypeIDs = 0x28 // TArray<uint64_t> (Size: 0x10)
CheckLootPointType.LootPointTypes = 0x28 // TArray<int32_t> (Size: 0x10)
CheckMaxBulletCount.MinBulletCount = 0x28 // int32_t (Size: 0x4)
CheckMaxBulletCount.MaxBulletCount = 0x2c // int32_t (Size: 0x4)
CheckMuzzleVelocity.MinMuzzleVelocity = 0x28 // float (Size: 0x4)
CheckMuzzleVelocity.MaxMuzzleVelocity = 0x2c // float (Size: 0x4)
CheckObjects.CheckObjects = 0x10 // TArray<UAFSMCheckObject*> (Size: 0x10)
CheckOccupiedGridCount.OccupiedGridCountMin = 0x28 // int32_t (Size: 0x4)
CheckOccupiedGridCount.OccupiedGridCountMax = 0x2c // int32_t (Size: 0x4)
CheckRequireAdapters.RequireAdapters = 0x28 // TArray<uint64_t> (Size: 0x10)
CheckRuntimeFireRate.MinFireRatePerMinute = 0x28 // int32_t (Size: 0x4)
CheckRuntimeFireRate.MaxFireRatePerMinute = 0x2c // int32_t (Size: 0x4)
CheckSightRange.MinSightRange = 0x28 // float (Size: 0x4)
CheckSightRange.MaxSightRange = 0x2c // float (Size: 0x4)
CheckVerticalRecoil.MinVerticalRecoil = 0x28 // float (Size: 0x4)
CheckVerticalRecoil.MaxVerticalRecoil = 0x2c // float (Size: 0x4)
CheckWeaponCanFire.IsCanFire = 0x28 // bool (Size: 0x1)
CheckWeight.MinWeight = 0x28 // float (Size: 0x4)
CheckWeight.MaxWeight = 0x2c // float (Size: 0x4)
CombinPickupData.PickupClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
CombinPickupData.LocationOffset = 0x28 // FVector (Size: 0xc)
CombinPickupData.RotatorOffset = 0x34 // FRotator (Size: 0xc)
CombinPickupData.SpawnPickup = 0x40 // UAPickup* (Size: 0x8)
CommonThreeDTraceInfo.IndexId = 0x0 // int32_t (Size: 0x4)
CommonThreeDTraceInfo.TraceConfigID = 0x4 // int32_t (Size: 0x4)
CommonThreeDTraceInfo.WorldLocation = 0x8 // FVector (Size: 0xc)
CommonThreeDTraceInfo.TraceActor = 0x18 // Actor* (Size: 0x8)
CompetitionHUD.PostProcessVolume = 0x568 // PostProcessVolume* (Size: 0x8)
CompetitionHUD.CompetitionPlayerComponentClasses = 0x570 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
CompetitionHUD.OBPlayerComponentClasses = 0x580 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
CompetitionHUD.bCreate = 0x590 // bool (Size: 0x1)
CompetitionHUD.OutlineMaterial = 0x598 // TSoftObjectPtr<UObject> (Size: 0x28)
DSTestGameMode.AICharacterClass = 0x660 // ClassProperty (Size: 0x8)
DSTestGameMode.AIControllerClass = 0x668 // ClassProperty (Size: 0x8)
DSTestGameMode.BehaviorTreeTemplate = 0x670 // BehaviorTree* (Size: 0x8)
DSTestGameMode.AIMaxCount = 0x678 // int32_t (Size: 0x4)
DSTestGameMode.SpawnAIRadius = 0x67c // int32_t (Size: 0x4)
DSTestGameMode.CenterPoint = 0x680 // FVector (Size: 0xc)
DZPCUIModeComponent.bEscapeInfoOpen = 0x120 // bool (Size: 0x1)
DarkZoneEscapePointInfo.EscapePoint = 0x0 // Actor* (Size: 0x8)
DarkZoneEscapePointInfo.Ratio = 0x8 // float (Size: 0x4)
DarkZonePlayerStartPointInfo.PlayerStartPointList = 0x0 // TArray<Actor*> (Size: 0x10)
DarkZonePlayerStartPointInfo.TeamIndexList = 0x10 // TArray<int32_t> (Size: 0x10)
DarkZonePlayerStartPointInfo.GroupIndex = 0x20 // int32_t (Size: 0x4)
DarkZonePlayerStartPointInfo.TeamPlayerStartPointList = 0x28 // TArray<Actor*> (Size: 0x10)
DeathBoxToTeamIndexCacheInfo.InTeamIndex = 0x0 // int32_t (Size: 0x4)
DeathBoxToTeamIndexCacheInfo.DeathBoxActor = 0x8 // Actor* (Size: 0x8)
DebugShowPointInfo.AbsPosition = 0x0 // FVector (Size: 0xc)
DebugShowPointInfo.Description = 0x10 // FString (Size: 0x10)
DefaultOperationSettingTable.ActionName = 0x8 // FName (Size: 0x8)
DefaultOperationSettingTable.KeyType = 0x10 // EEOperationKeyType (Size: 0x1)
DefaultOperationSettingTable.KeyChord = 0x18 // FInputChord (Size: 0x20)
DefaultOperationSettingTable.KeyStyle = 0x38 // EEOperationKeyStyle (Size: 0x1)
DefaultOperationSettingTable.EffectiveTarget = 0x40 // TArray<EEOperationInputType> (Size: 0x10)
DefaultOperationSettingTable.Scale = 0x50 // float (Size: 0x4)
DefaultSettingTable.SettingName = 0x8 // FName (Size: 0x8)
DefaultSettingTable.DefaultValue = 0x10 // float (Size: 0x4)
DistributeMissionHistory.MissionFlow = 0x0 // MFMissionFlow* (Size: 0x8)
DistributeMissionHistory.TriggerCharacterType = 0x8 // EECharacterType (Size: 0x1)
DistributeMissionHistory.TriggerCharacterLevel = 0xc // int32_t (Size: 0x4)
DistributeMissionHistory.MisionFlowID = 0x10 // int32_t (Size: 0x4)
DistributeQuestHistory.QuestDistributer = 0x0 // MFQuestDistributerBase* (Size: 0x8)
DistributeQuestHistory.TriggerCharacterType = 0x8 // EECharacterType (Size: 0x1)
DistributeQuestHistory.TriggerCharacterLevel = 0xc // int32_t (Size: 0x4)
DistributeQuestHistory.GraphID = 0x10 // int32_t (Size: 0x4)
EscapeConditionDescData.strDescTextName = 0x0 // FString (Size: 0x10)
EscapeConditionDescData.Param0 = 0x10 // int32_t (Size: 0x4)
EscapeConditionDescData.Param1 = 0x14 // int32_t (Size: 0x4)
FactionPlayerStart.FactionType = 0x0 // EEFactionType (Size: 0x1)
FactionPlayerStart.DomainPlayerStart = 0x8 // TArray<int32_t> (Size: 0x10)
FactionPlayerStart.bOccupyDomainPlayerStart = 0x18 // bool (Size: 0x1)
FactionPlayerStart.PlayerStartResult = 0x20 // TArray<int32_t> (Size: 0x10)
FactionPlayerStart.PlayerStartResultUsed = 0x30 // TArray<int32_t> (Size: 0x10)
FactionPlayerStartConfigRow.FactionType = 0x0 // EEFactionType (Size: 0x1)
FactionPlayerStartConfigRow.ChooseNum = 0x4 // int32_t (Size: 0x4)
FactionPlayerStartConfigRow.CheckType = 0x8 // EEFPSCCheckType (Size: 0x1)
FactionPlayerStartConfigRow.PlayerStartTeamType = 0x9 // EEPlayerTeamType (Size: 0x1)
FactionPlayerStartConfigRow.ParamOne = 0xc // int32_t (Size: 0x4)
FactionPlayerStartConfigRow.ParamTwo = 0x10 // int32_t (Size: 0x4)
FactionPlayerStartConfigRow.NewReferenceVector = 0x18 // FMFMissionVariableRead_Vector (Size: 0x38)
FactionScoreAction.Actions = 0x0 // TArray<MFMissionAction*> (Size: 0x10)
GameAreaStatisDateInfo.AreaIDArrays = 0x0 // TArray<FAreaDataInfo> (Size: 0x10)
GameHUDReportInfo.ParentWidget = 0x8 // Overlay* (Size: 0x8)
GameModeAutoTest.ParticleSystemComponentArray = 0x3f8 // TArray<ParticleSystemComponent*> (Size: 0x10)
GameModeAutoTest.ActorArray = 0x408 // TArray<Actor*> (Size: 0x10)
GameStateTraceableInventoryProxy.GameStateTraceComponent = 0x28 // UAGameStateTraceComponent* (Size: 0x8)
GameStateTraceableInventoryProxy.Inventory = 0x30 // SGInventory* (Size: 0x8)
GiveItemInfo.ItemId = 0x0 // int32_t (Size: 0x4)
GiveItemInfo.MinStackCount = 0x4 // int32_t (Size: 0x4)
GiveItemInfo.MaxStackCount = 0x8 // int32_t (Size: 0x4)
GiveItemInfo.InventoryClass = 0x10 // ClassProperty (Size: 0x8)
GlobalEventMessage_ActivateLootPoint.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_AddInventoryToLootContainer.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_BroadcastOnGameHUD.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_DisableLootPoint.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_DistributeFactionDomain.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_DistributeMission.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_DistributeMission.IntCount = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_DistributeMissionN.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_DistributeMissionN.IntCount = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_DoorState.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_EscapeVolumeStateChange.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_Escort.Instigator = 0x0 // Character* (Size: 0x8)
GlobalEventMessage_Escort.TeamMember = 0x8 // Character* (Size: 0x8)
GlobalEventMessage_Escort.EscapeVolume = 0x10 // Actor* (Size: 0x8)
GlobalEventMessage_FactionPlayerStart.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_GiveItem.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_InvokeAnnounce.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_MonitorTakeDamageItem.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_MonitorTakeDamageItem.IntCount = 0x8 // int32_t (Size: 0x4)
GlobalEventMessage_OrderPlayerStart.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_Paradrop.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_RandTimeRange.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_RdmBlackboard.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_RdmPlayerStart.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_Scene.Instigator = 0x0 // GameState* (Size: 0x8)
GlobalEventMessage_ShowControl.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnActor.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnGashapon.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnInteractItem.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnInteractItem.InteractActor = 0x8 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnInventory.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnInventory.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_SpawnParticle.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_SpawnPickup.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_Survival.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_TakeOutItem.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_TakeOutItem.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_TakeOutItem.StackableItemSourceInfo = 0x10 // FStackableItemSourceInfo (Size: 0x18)
GlobalEventMessage_TakeOutType.Instigator = 0x0 // Actor* (Size: 0x8)
GlobalEventMessage_TakeOutType.Inventory = 0x8 // SGInventory* (Size: 0x8)
GlobalEventMessage_WalkDistance.Instigator = 0x0 // PlayerState* (Size: 0x8)
GlobalEventMessage_WalkDistance.EndGameType = 0x8 // EEPlayerEndGameType (Size: 0x1)
HardwareBlacklistTableRow.HardwareId = 0x8 // uint32_t (Size: 0x4)
HardwareBlacklistTableRow.HardwareName = 0x10 // FString (Size: 0x10)
InteractionStatistics.ItemId = 0x0 // uint32_t (Size: 0x4)
InteractionStatistics.MapID = 0x4 // uint32_t (Size: 0x4)
InteractionStatistics.InteractionType = 0x8 // int32_t (Size: 0x4)
InventoryFixResult.bIsCanFix = 0x0 // bool (Size: 0x1)
InventoryFixResult.NeedMoney = 0x4 // int32_t (Size: 0x4)
InventoryFixResult.AfterFixDurability = 0x8 // float (Size: 0x4)
InventoryFlashDebuffStruct.DebuffTime = 0x0 // float (Size: 0x4)
InventoryFlashDebuffStruct.GetDebuffPosX = 0x4 // float (Size: 0x4)
InventoryFlashDebuffStruct.GetDebuffPosY = 0x8 // float (Size: 0x4)
InventoryFlashDebuffStruct.GetDebuffPosZ = 0xc // float (Size: 0x4)
InventoryFultonRecoveryComponent.TraceConfigID = 0xf8 // int32_t (Size: 0x4)
InventoryFultonRecoveryComponent.MissionIDList = 0x100 // TArray<int32_t> (Size: 0x10)
InventoryFultonRecoveryComponent.ConfigID = 0x110 // int32_t (Size: 0x4)
InventoryFultonRecoveryComponent.FultonOwner = 0x118 // PlayerController* (Size: 0x8)
InventoryFultonRecoveryComponent.OwnerGID = 0x120 // uint64_t (Size: 0x8)
InventoryFultonRecoveryComponent.DurationBeforeStartUp = 0x128 // float (Size: 0x4)
InventoryFultonRecoveryComponent.ToastTime = 0x138 // TArray<float> (Size: 0x10)
InventoryFultonRecoveryComponent.ToastKey = 0x148 // TArray<FString> (Size: 0x10)
InventoryFultonRecoveryComponent.StartUpState = 0x161 // bool (Size: 0x1)
InventoryFultonRecoveryComponent.bMissionCompleted = 0x162 // bool (Size: 0x1)
InventoryFultonRecoveryComponent.bStartInteract = 0x163 // bool (Size: 0x1)
InventoryFultonRecoveryComponent.CurrentMissionID = 0x164 // int32_t (Size: 0x4)
InventoryInfo.ItemGID = 0x0 // int64_t (Size: 0x8)
InventoryInfo.ItemId = 0x8 // int64_t (Size: 0x8)
InventoryInfo.StackCount = 0x10 // int32_t (Size: 0x4)
InventoryInfo.Durability = 0x14 // int32_t (Size: 0x4)
InventoryInfo.MaxDurability = 0x18 // int32_t (Size: 0x4)
InventoryInfo.ParentGID = 0x20 // int64_t (Size: 0x8)
InventoryInfo.Index = 0x28 // int32_t (Size: 0x4)
InventoryInfo.StartRow = 0x2c // int32_t (Size: 0x4)
InventoryInfo.StartColumn = 0x30 // int32_t (Size: 0x4)
InventoryInfo.AttachPosition = 0x34 // EEAttachPosition (Size: 0x1)
InventoryInfo.InsureType = 0x38 // int32_t (Size: 0x4)
InventoryInfo.TakeInPlayerGID = 0x40 // int64_t (Size: 0x8)
InventoryMarkableInfo.ItemId = 0x0 // int32_t (Size: 0x4)
InventoryMarkableInfo.ConfigID = 0x4 // int32_t (Size: 0x4)
InventoryPoolConfig.InventoryID = 0x0 // FString (Size: 0x10)
InventoryPoolConfig.MaxPoolSize = 0x10 // int32_t (Size: 0x4)
InventoryPoolConfig.PoolItemLoc = 0x14 // FVector (Size: 0xc)
InventoryPoolConfig.IsAutoPullBolt = 0x20 // bool (Size: 0x1)
InventoryPoolItemInfo.ItemId = 0x0 // int64_t (Size: 0x8)
InventoryPoolItemInfo.ItemNum = 0x8 // int32_t (Size: 0x4)
ItemGroupReplaceInfo.TakeInItemGID = 0x0 // int64_t (Size: 0x8)
ItemGroupReplaceInfo.ItemGroupAfterReplace = 0x8 // TArray<SGPlayerItemInfoBase*> (Size: 0x10)
ItemGroupReplaceInfo.ItemGroupCreateInfos = 0x18 // TArray<FItemTreeCreateInfo> (Size: 0x10)
ItemGroupReplaceInfo.bReplaced = 0x28 // bool (Size: 0x1)
ItemTreeCreateInfo.FromPlayerGID = 0x0 // int64_t (Size: 0x8)
ItemTreeCreateInfo.FromTeamIndex = 0x8 // int32_t (Size: 0x4)
ItemTreeCreateInfo.CreatedRootInventory = 0x10 // SGInventory* (Size: 0x8)
ItemTreeCreateInfo.PendingCreateInventories = 0x18 // TArray<FPendingCreateItemInfo> (Size: 0x10)
LoadingExInfo.MapName = 0x0 // FString (Size: 0x10)
LoadingExInfo.GameModeName = 0x10 // FString (Size: 0x10)
LoadingExInfo.WeatherIconPath = 0x20 // FString (Size: 0x10)
LoadingExInfo.TimeHour = 0x30 // FString (Size: 0x10)
LoadingExInfo.CurTimeStamp = 0x40 // int32_t (Size: 0x4)
LoadingExInfo.Show = 0x44 // bool (Size: 0x1)
LootPointInfoStruct.LootPointID = 0x0 // int32_t (Size: 0x4)
LootPointInfoStruct.PickUpName = 0x8 // FString (Size: 0x10)
LootPointInfoStruct.LevelName = 0x18 // FString (Size: 0x10)
MFMissionCapturePointChooseConifg.VolumeRef = 0x0 // FMissionActorReference (Size: 0x18)
MFMissionCapturePointChooseConifg.Weight = 0x18 // int32_t (Size: 0x4)
MFMissionChooseVolumeConifg.VolumeRef = 0x0 // FMissionActorReference (Size: 0x18)
MFMissionChooseVolumeConifg.Weight = 0x18 // int32_t (Size: 0x4)
MFMissionFactionCompeteConfig.DomainVolumes = 0x0 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
MFMissionFactionCompeteConfig.PlayerStartEnable = 0x10 // bool (Size: 0x1)
MFMissionFactionCompeteConfig.bOccupyDomainPlayerStart = 0x11 // bool (Size: 0x1)
MFMissionFactionCompeteConfig.AISpawnPointEnable = 0x12 // bool (Size: 0x1)
MFMissionFactionCompeteConfig.VictoryEscapePoints = 0x18 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
MFMissionFactionCompeteConfig.DefeatedEscapePoints_Time = 0x28 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
MFMissionFactionCompeteConfig.DefeatedEscapePoints_NoBag = 0x38 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
MFMissionFactionCompeteConfig.InitialSpawnAIEventStrs = 0x48 // TArray<FString> (Size: 0x10)
MFMissionFactionCompeteConfig.VictorySpawnAIEventStrs = 0x58 // TArray<FString> (Size: 0x10)
MFMissionFactionCompeteConfig.StageChangeSceneEventTags = 0x68 // TArray<FString> (Size: 0x10)
MFMissionFactionCompeteConfig.FactionWarSpawnTypeTags = 0x78 // TArray<FString> (Size: 0x10)
MFMissionFactionCompeteInfo.VictoryEscapePointVariables = 0x0 // TArray<MFMissionVariableWrite_ActorReference*> (Size: 0x10)
MFMissionFactionCompeteInfo.DefeatedEscapePointVariables_Time = 0x10 // TArray<MFMissionVariableWrite_ActorReference*> (Size: 0x10)
MFMissionFactionCompeteInfo.DefeatedEscapePointVariables_NoBag = 0x20 // TArray<MFMissionVariableWrite_ActorReference*> (Size: 0x10)
MFMissionFactionCompeteInfo.InitialSpawnAIEventStrArray = 0x30 // MFMissionVariableWrite_StringArray* (Size: 0x8)
MFMissionFactionCompeteInfo.VictorySpawnAIEventStrArray = 0x38 // MFMissionVariableWrite_StringArray* (Size: 0x8)
MFMissionFactionCompeteInfo.StageChangeSceneEventTagArray = 0x40 // MFMissionVariableWrite_StringArray* (Size: 0x8)
MFMissionFactionCompeteInfo.FactionWarSpawnTypeTagArray = 0x48 // MFMissionVariableWrite_StringArray* (Size: 0x8)
MFMissionVariableRead_ActorReference.ConfigValue = 0x28 // FMissionActorReference (Size: 0x18)
MFMissionVariableWrite_ActorReference.Value = 0x50 // FMissionActorReference (Size: 0x18)
MFMobileGamePadViewEffect.SoundIndicatorHUD = 0x320 // SoundIndicatorWidget* (Size: 0x8)
MediaPlayerController.MediaPlayer = 0x310 // MediaPlayer* (Size: 0x8)
MeleeStartFireInformationStatistics.Timestamp = 0x0 // int64_t (Size: 0x8)
MeleeStartFireInformationStatistics.WeaponId = 0x8 // int64_t (Size: 0x8)
MeleeStartFireInformationStatistics.WeaponName = 0x10 // FString (Size: 0x10)
MeleeStartFireInformationStatistics.WeaponType = 0x20 // FString (Size: 0x10)
MeleeStartFireInformationStatistics.bHit = 0x30 // bool (Size: 0x1)
MeleeStartFireInformationStatistics.HitNumber = 0x34 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitPmcNumber = 0x38 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitScavNumber = 0x3c // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitDistance = 0x40 // float (Size: 0x4)
MeleeStartFireInformationStatistics.TeamType = 0x44 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitCharacterTeamType = 0x48 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitCharacterPlayerID = 0x50 // int64_t (Size: 0x8)
MeleeStartFireInformationStatistics.HitEndurance = 0x58 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitSubEndurance = 0x5c // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.ArmorId = 0x60 // int64_t (Size: 0x8)
MeleeStartFireInformationStatistics.ArmorLevel = 0x68 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.CauseArmorConsume = 0x6c // float (Size: 0x4)
MeleeStartFireInformationStatistics.CauseArmorReduceDamage = 0x70 // float (Size: 0x4)
MeleeStartFireInformationStatistics.ResultDamage = 0x74 // float (Size: 0x4)
MeleeStartFireInformationStatistics.WeaponInventory = 0x78 // SGInventory* (Size: 0x8)
MeleeStartFireInformationStatistics.HitCharacterType = 0x80 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.ShotTime = 0x84 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitTime = 0x88 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.PlayerPositionX = 0x8c // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.PlayerPositionY = 0x90 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.PlayerPositionZ = 0x94 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.MeleePositionX = 0x98 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.MeleePositionY = 0x9c // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.MeleePositionZ = 0xa0 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitPositionX = 0xa4 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitPositionY = 0xa8 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.HitPositionZ = 0xac // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.TimeSeconds = 0xb0 // int32_t (Size: 0x4)
MeleeStartFireInformationStatistics.TimeFromLastThrow = 0xb4 // int32_t (Size: 0x4)
MemberInfo.GID = 0x0 // int64_t (Size: 0x8)
MemberInfo.Level = 0x8 // int32_t (Size: 0x4)
MemberInfo.HeadIconDynamicPath = 0x10 // FString (Size: 0x10)
MemberInfo.HeadIconTexture = 0x20 // Object* (Size: 0x8)
MemberInfo.HeadboxPath = 0x28 // FString (Size: 0x10)
MemberInfo.PrivilegeIconPath = 0x38 // FString (Size: 0x10)
MemberInfo.PlayerName = 0x48 // FString (Size: 0x10)
MemberInfo.TitleName = 0x58 // FString (Size: 0x10)
MemberInfo.TitleIconPath = 0x68 // FString (Size: 0x10)
MemberInfo.TitleBackgroundPath = 0x78 // FString (Size: 0x10)
MemberInfo.TitleShowNum = 0x88 // int32_t (Size: 0x4)
MemberInfo.TitleHighestRankStarNum = 0x8c // int32_t (Size: 0x4)
MemberInfo.Type = 0x90 // int32_t (Size: 0x4)
MemberInfo.NameCardPath = 0x98 // FString (Size: 0x10)
MemberInfo.bDynamicCard = 0xa8 // bool (Size: 0x1)
MemberInfo.NationalFlagPath = 0xb0 // FString (Size: 0x10)
MemberInfo.RankingIconPath = 0xc0 // FString (Size: 0x10)
MemberInfo.VoiceBan = 0xd0 // bool (Size: 0x1)
MemberInfo.VoiceClose = 0xd1 // bool (Size: 0x1)
MemberInfo.RoleBannerInfoList = 0xd8 // TArray<FRoleBannerInfo> (Size: 0x10)
MemberInfo.RoleBannerCustomDataList = 0xe8 // TArray<FRoleBannerCustomData> (Size: 0x10)
MemberInfo.LevelStr = 0xf8 // FString (Size: 0x10)
MemberInfo.IsDynamicBackground = 0x108 // bool (Size: 0x1)
MemberInfo.BannerBackgroundImgPath = 0x110 // FString (Size: 0x10)
MemberInfo.IsDynamicFrame = 0x120 // bool (Size: 0x1)
MemberInfo.FramePath = 0x128 // FString (Size: 0x10)
MessageIDInfo.BlockTagLocationKey = 0x0 // TMap<...> (Size: 0x50)
MissionActionAICharacterMarkableInfo.bShowTraceableActor = 0x0 // bool (Size: 0x1)
MissionActionAICharacterMarkableInfo.AICharacterTag = 0x4 // FMFGlobalEventParameterTag (Size: 0x8)
MissionActionAICharacterMarkableInfo.AIID = 0x10 // int64_t (Size: 0x8)
MissionActionAICharacterMarkableInfo.SpawnReason = 0x18 // EESpawnReason (Size: 0x1)
MissionActionAICharacterMarkableInfo.ConfigID = 0x1c // int32_t (Size: 0x4)
MissionActionActorMarkableInfo.bShowTraceableActor = 0x0 // bool (Size: 0x1)
MissionActionActorMarkableInfo.ActorTag = 0x4 // FMFGlobalEventParameterTag (Size: 0x8)
MissionActionActorMarkableInfo.ActorRef = 0x10 // FMissionActorReference (Size: 0x18)
MissionActionActorMarkableInfo.ActorVar = 0x28 // FMFMissionVariableRead_Object (Size: 0x30)
MissionActionActorMarkableInfo.ConfigID = 0x58 // int32_t (Size: 0x4)
MissionActionGiveItemInfo.ItemId = 0x0 // int32_t (Size: 0x4)
MissionActionGiveItemInfo.MinStackCount = 0x4 // int32_t (Size: 0x4)
MissionActionGiveItemInfo.MaxStackCount = 0x8 // int32_t (Size: 0x4)
MissionActionGiveItemInfo.InventoryClass = 0x10 // ClassProperty (Size: 0x8)
MissionActionInventoryMarkableInfo.bShowTraceableActor = 0x0 // bool (Size: 0x1)
MissionActionInventoryMarkableInfo.SpawnVolumeActor = 0x8 // FMissionActorReference (Size: 0x18)
MissionActionInventoryMarkableInfo.SpawnVolumeTag = 0x20 // FMFGlobalEventParameterTag (Size: 0x8)
MissionActionInventoryMarkableInfo.InVolumeInventoryContainer = 0x28 // FMissionActorReference (Size: 0x18)
MissionActionInventoryMarkableInfo.bNotCharacterOwner = 0x40 // bool (Size: 0x1)
MissionActionInventoryMarkableInfo.InventoryTag = 0x44 // FMFGlobalEventParameterTag (Size: 0x8)
MissionActionInventoryMarkableInfo.ItemId = 0x4c // int32_t (Size: 0x4)
MissionActionInventoryMarkableInfo.InventoryType = 0x50 // EESGInventoryType (Size: 0x1)
MissionActionInventoryMarkableInfo.LootStatus = 0x51 // EESGInventoryContainerLootStatus (Size: 0x1)
MissionActionInventoryMarkableInfo.ConfigID = 0x54 // int32_t (Size: 0x4)
MissionActionRandomEscapePoint.EscapePointID = 0x0 // int32_t (Size: 0x4)
MissionActionRandomEscapePoint.NewEscapePointID = 0x8 // FMFMissionVariableRead_Int (Size: 0x30)
MissionActionRandomEscapePoint.EscapeVolume = 0x38 // FMFMissionVariableRead_ActorReference (Size: 0x40)
MissionActionRandomEscapePoint.Weight = 0x78 // int32_t (Size: 0x4)
MissionActionRelevantToAI.AIIDs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionActionRelevantToAI.ConfigID = 0x10 // int32_t (Size: 0x4)
MissionActionRelevantToAI.FailedAINum = 0x14 // int32_t (Size: 0x4)
MissionActionRelevantToAICharacters.AICharacters = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionActionRelevantToInteract.InteractItemIDs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionActionRelevantToInteract.ConfigID = 0x10 // int32_t (Size: 0x4)
MissionActionRelevantToInteract.FailedInteractNum = 0x14 // int32_t (Size: 0x4)
MissionActionRelevantToInteractActors.InteractActors = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionActionRelevantToInventories.Inventories = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionActionRelevantToInventory.InventoryItemIDs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionActionRelevantToInventory.ConfigID = 0x10 // int32_t (Size: 0x4)
MissionActionRelevantToInventory.FailedInventoryNum = 0x14 // int32_t (Size: 0x4)
MissionActionRelevantToVolume.VolumeItemIDs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionActionRelevantToVolume.ConfigID = 0x10 // int32_t (Size: 0x4)
MissionActionRelevantToVolume.FailedInteractNum = 0x14 // int32_t (Size: 0x4)
MissionActionSpawnedInventories.Inventories = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionActionVolumeMarkableInfo.bShowTraceableActor = 0x0 // bool (Size: 0x1)
MissionActionVolumeMarkableInfo.SpawnedInventories = 0x8 // TArray<int32_t> (Size: 0x10)
MissionActionVolumeMarkableInfo.VolumeTag = 0x18 // FMFGlobalEventParameterTag (Size: 0x8)
MissionActionVolumeMarkableInfo.VolumeID = 0x20 // int32_t (Size: 0x4)
MissionActionVolumeMarkableInfo.NewVolumeID = 0x28 // FMFMissionVariableRead_Int (Size: 0x30)
MissionActionVolumeMarkableInfo.ConfigID = 0x58 // int32_t (Size: 0x4)
MissionCheckActorClass.ParentClass = 0x28 // TSoftClassPtr<UObject> (Size: 0x28)
MissionCheckActorLocation.Center = 0x28 // FVector (Size: 0xc)
MissionCheckActorLocation.Radius = 0x34 // float (Size: 0x4)
MissionConditionAccuracy.MinAccuracy = 0x28 // float (Size: 0x4)
MissionConditionAccuracy.MaxAccuracy = 0x2c // float (Size: 0x4)
MissionConditionAdsMoa.AdsMoaXMin = 0x28 // float (Size: 0x4)
MissionConditionAdsMoa.AdsMoaXMax = 0x2c // float (Size: 0x4)
MissionConditionAdsMoa.AdsMoaYMin = 0x30 // float (Size: 0x4)
MissionConditionAdsMoa.AdsMoaYMax = 0x34 // float (Size: 0x4)
MissionConditionAttributeInfo.bUseCustomAttribute = 0x28 // bool (Size: 0x1)
MissionConditionAttributeInfo.Attribute = 0x30 // FGameplayAttribute (Size: 0x38)
MissionConditionAttributeInfo.CustomAttribute = 0x68 // EEMissionConditionCustomAttribute (Size: 0x1)
MissionConditionAttributeInfo.MinValue = 0x6c // float (Size: 0x4)
MissionConditionAttributeInfo.MaxValue = 0x70 // float (Size: 0x4)
MissionConditionBulletItemId.ValidBulletIds = 0x28 // TArray<uint64_t> (Size: 0x10)
MissionConditionCanAddToContainer.ItemId = 0x28 // int64_t (Size: 0x8)
MissionConditionCanAddToContainer.bPreferMerge = 0x30 // bool (Size: 0x1)
MissionConditionCaptureWeaponZoomType.ZoomType = 0x28 // EESGZoomType (Size: 0x1)
MissionConditionCorpseContainer.DeathCharacterTypes = 0x28 // TArray<EECharacterType> (Size: 0x10)
MissionConditionCorpseContainer.KillerWeaponTypeIDs = 0x38 // TArray<uint64_t> (Size: 0x10)
MissionConditionCorpseContainer.DeathParts = 0x48 // TArray<EECharacterEnduranceType> (Size: 0x10)
MissionConditionCorpseContainer.RelationTypes = 0x58 // TArray<EEBetweenRelationType> (Size: 0x10)
MissionConditionCurrentBulletCount.MinBulletCount = 0x28 // int32_t (Size: 0x4)
MissionConditionCurrentBulletCount.MaxBulletCount = 0x2c // int32_t (Size: 0x4)
MissionConditionDamageTypeClass.DamageTypeClass = 0x28 // ClassProperty (Size: 0x8)
MissionConditionDurability.MinDurability = 0x28 // float (Size: 0x4)
MissionConditionDurability.MaxDurability = 0x2c // float (Size: 0x4)
MissionConditionEngonomics.MinEngonomics = 0x28 // float (Size: 0x4)
MissionConditionEngonomics.MaxEngonomics = 0x2c // float (Size: 0x4)
MissionConditionExclusionAdapters.ExclusionAdapters = 0x28 // TArray<uint64_t> (Size: 0x10)
MissionConditionFireMode.FireMode = 0x28 // EESGWeaponShootingMode (Size: 0x1)
MissionConditionGameplayTagInfo.TagContainer = 0x28 // FGameplayTagContainer (Size: 0x20)
MissionConditionGameplayTagInfo.CheckType = 0x48 // EEMissionConditionGameplayTagCheckType (Size: 0x1)
MissionConditionHorizontalRecoil.MinHorizontalRecoil = 0x28 // float (Size: 0x4)
MissionConditionHorizontalRecoil.MaxHorizontalRecoil = 0x2c // float (Size: 0x4)
MissionConditionInventoryType.InventoryTypes = 0x28 // TArray<EESGInventoryType> (Size: 0x10)
MissionConditionIsInRecoveryItem.CheckTargetTag = 0x28 // FMFGlobalEventParameterTag (Size: 0x8)
MissionConditionIsInRecoveryItem.bIsInRecovery = 0x30 // bool (Size: 0x1)
MissionConditionIsTakeInItem.CheckTargetTag = 0x28 // FMFGlobalEventParameterTag (Size: 0x8)
MissionConditionIsTakeInItem.bIsTakeIn = 0x30 // bool (Size: 0x1)
MissionConditionIsTakeInItem.bMustInstigatorTakeIn = 0x31 // bool (Size: 0x1)
MissionConditionItemRarity.Rarities = 0x28 // TArray<uint32_t> (Size: 0x10)
MissionConditionItemTypeID.ItemTypeIDs = 0x28 // TArray<uint64_t> (Size: 0x10)
MissionConditionItemValue.MinItemValue = 0x28 // int32_t (Size: 0x4)
MissionConditionItemValue.MaxItemValue = 0x2c // int32_t (Size: 0x4)
MissionConditionLootPointType.LootPointTypes = 0x28 // TArray<int32_t> (Size: 0x10)
MissionConditionLootSubAreaVolume.LootVolumeIDs = 0x28 // TArray<int32_t> (Size: 0x10)
MissionConditionLootSubAreaVolume.LootVolumeNames = 0x38 // TArray<FString> (Size: 0x10)
MissionConditionMaxBulletCount.MinBulletCount = 0x28 // int32_t (Size: 0x4)
MissionConditionMaxBulletCount.MaxBulletCount = 0x2c // int32_t (Size: 0x4)
MissionConditionMuzzleVelocity.MinMuzzleVelocity = 0x28 // float (Size: 0x4)
MissionConditionMuzzleVelocity.MaxMuzzleVelocity = 0x2c // float (Size: 0x4)
MissionConditionOccupiedGridCount.OccupiedGridCountMin = 0x28 // int32_t (Size: 0x4)
MissionConditionOccupiedGridCount.OccupiedGridCountMax = 0x2c // int32_t (Size: 0x4)
MissionConditionRequireAdapters.RequireAdapters = 0x28 // TArray<uint64_t> (Size: 0x10)
MissionConditionRuntimeFireRate.MinFireRatePerMinute = 0x28 // int32_t (Size: 0x4)
MissionConditionRuntimeFireRate.MaxFireRatePerMinute = 0x2c // int32_t (Size: 0x4)
MissionConditionSightRange.MinSightRange = 0x28 // float (Size: 0x4)
MissionConditionSightRange.MaxSightRange = 0x2c // float (Size: 0x4)
MissionConditionSpawnVolume.SpawnVolumeActor = 0x28 // FMissionActorReference (Size: 0x18)
MissionConditionTimeOfDay.Hour = 0x0 // int32_t (Size: 0x4)
MissionConditionTimeOfDay.Minute = 0x4 // int32_t (Size: 0x4)
MissionConditionTimeOfDay.Second = 0x8 // int32_t (Size: 0x4)
MissionConditionUsedLoot.bUsedLoot = 0x28 // bool (Size: 0x1)
MissionConditionVerticalRecoil.MinVerticalRecoil = 0x28 // float (Size: 0x4)
MissionConditionVerticalRecoil.MaxVerticalRecoil = 0x2c // float (Size: 0x4)
MissionConditionWeaponCanFire.IsCanFire = 0x28 // bool (Size: 0x1)
MissionConditionWeight.MinWeight = 0x28 // float (Size: 0x4)
MissionConditionWeight.MaxWeight = 0x2c // float (Size: 0x4)
MissionCreateData.MissionID = 0x0 // int32_t (Size: 0x4)
MissionCreateData.CurProgress = 0x4 // int32_t (Size: 0x4)
MissionCreateData.MaxProgress = 0x8 // int32_t (Size: 0x4)
MissionCreateData.ActivityTemplateParams = 0x10 // TArray<int32_t> (Size: 0x10)
MissionFlowClassTableRow.MissionFlowID = 0x8 // int32_t (Size: 0x4)
MissionFlowClassTableRow.MissionFlowAsset = 0x10 // TSoftObjectPtr<UObject> (Size: 0x28)
MissionFlowCreateData.MissionFlowID = 0x0 // int32_t (Size: 0x4)
MissionFlowCreateData.MissionList = 0x8 // TArray<FMissionCreateData> (Size: 0x10)
MissionFlowCreateData.bActTask = 0x18 // bool (Size: 0x1)
MissionFlowCreateData.bShowInGame = 0x19 // bool (Size: 0x1)
MissionFlowPlayers.PlayerList = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionFlowUploadData.MissionFlowName = 0x0 // FString (Size: 0x10)
MissionFlowUploadData.MissionFlowStatus = 0x10 // EEMissionStatus (Size: 0x1)
MissionFlowUploadData.bBeforeState = 0x11 // bool (Size: 0x1)
MissionFlowUploadData.MissionUploadDataList = 0x18 // TArray<FMissionUploadData> (Size: 0x10)
MissionObjectiveActivateLootPointConfig.LootPointType = 0x0 // int32_t (Size: 0x4)
MissionObjectiveActivateLootPointConfig.ActivateMinCount = 0x4 // int32_t (Size: 0x4)
MissionObjectiveActivateLootPointConfig.ActivateMaxCount = 0x8 // int32_t (Size: 0x4)
MissionObjectiveActivateLootPointConfigs.ForceActivateLootPoints = 0x0 // TArray<int32_t> (Size: 0x10)
MissionObjectiveActivateLootPointConfigs.ActivateConfigs = 0x10 // TArray<FMissionObjectiveActivateLootPointConfig> (Size: 0x10)
MissionObjectiveAddInventoryToLootContainerInfo.Weight = 0x0 // int32_t (Size: 0x4)
MissionObjectiveAddInventoryToLootContainerInfo.ItemId = 0x4 // int32_t (Size: 0x4)
MissionObjectiveAddInventoryToSearchContainerInfo.ItemId = 0x0 // int32_t (Size: 0x4)
MissionObjectiveBroadcastGameHUDConfigs.GameHUDConfigs = 0x0 // TArray<FBroadcastOnGameHUDConfig> (Size: 0x10)
MissionObjectiveBroadcastedCheckTimeConfigs.CheckIndexs = 0x0 // TArray<int32_t> (Size: 0x10)
MissionObjectiveCollectedItems.Inventories = 0x0 // TArray<SGInventory*> (Size: 0x10)
MissionObjectiveEffectMissionFlowInfo.MissionFlowID = 0x0 // int32_t (Size: 0x4)
MissionObjectiveEffectMissionFlowInfo.MissionIDs = 0x8 // TArray<int32_t> (Size: 0x10)
MissionObjectiveGiveItemInfo.ItemId = 0x0 // int32_t (Size: 0x4)
MissionObjectiveGiveItemInfo.MinStackCount = 0x4 // int32_t (Size: 0x4)
MissionObjectiveGiveItemInfo.MaxStackCount = 0x8 // int32_t (Size: 0x4)
MissionObjectiveGiveItemInfo.InventoryClass = 0x10 // ClassProperty (Size: 0x8)
MissionObjectiveInteractTargets.InteractTargets = 0x0 // TArray<Actor*> (Size: 0x10)
MissionObjectiveSceneEventInfo.SceneEventClassPtr = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
MissionObjectiveSceneEventInfo.ValidTime = 0x28 // float (Size: 0x4)
MissionObjectiveSceneEventInfo.ValidScope = 0x2c // float (Size: 0x4)
MissionObjectiveSceneEventInfo.Location = 0x30 // FVector (Size: 0xc)
MissionObjectiveSceneEventInfo.CoverRange = 0x3c // float (Size: 0x4)
MissionObjectiveSceneEventInfo.Weight = 0x40 // int32_t (Size: 0x4)
MissionObjectiveSceneEventInfo.Tags = 0x48 // TArray<FString> (Size: 0x10)
MissionObjectiveSceneEventInfo.TagArray = 0x58 // FMFMissionVariableRead_StringArray (Size: 0x38)
MissionObjectiveSpawnAIEventConfig.SpawnNum = 0x0 // int32_t (Size: 0x4)
MissionObjectiveSpawnAIEventConfig.EventParams = 0x8 // TArray<FMissionObjectiveSpawnAIEventParams> (Size: 0x10)
MissionObjectiveSpawnAIEventParams.EventStrList = 0x0 // TArray<FString> (Size: 0x10)
MissionObjectiveSpawnAIEventParams.EventStrArray = 0x10 // FMFMissionVariableRead_StringArray (Size: 0x38)
MissionObjectiveSpawnAIEventParams.Weight = 0x48 // int32_t (Size: 0x4)
MissionObjectiveSpawnActorInfo.SpawnPointActor = 0x0 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnActorInfo.StaticMesh = 0x18 // StaticMesh* (Size: 0x8)
MissionObjectiveSpawnActorInfo.Weight = 0x20 // int32_t (Size: 0x4)
MissionObjectiveSpawnActorInfo.RelatedTargetTypes = 0x28 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
MissionObjectiveSpawnInteractItemInfo.SpawnPointActor = 0x0 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnInteractItemInfo.InteractItemClass = 0x18 // ClassProperty (Size: 0x8)
MissionObjectiveSpawnInteractItemInfo.Weight = 0x20 // int32_t (Size: 0x4)
MissionObjectiveSpawnInteractItemInfo.ConfigID = 0x24 // int32_t (Size: 0x4)
MissionObjectiveSpawnInteractItemInfo.RelatedTargetTypes = 0x28 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
MissionObjectiveSpawnInventoryInfo.SpawnPointActor = 0x0 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnInventoryInfo.SpawnVolumeActor = 0x18 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnInventoryInfo.ContainerClass = 0x30 // ClassProperty (Size: 0x8)
MissionObjectiveSpawnInventoryInfo.ItemIDs = 0x38 // TArray<int64_t> (Size: 0x10)
MissionObjectiveSpawnInventoryInfo.Weight = 0x48 // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfo.ConfigID = 0x4c // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfo.LootPointType = 0x50 // int32_t (Size: 0x4)
MissionObjectiveSpawnInventoryInfo.RelatedTargetTypes = 0x58 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
MissionObjectiveSpawnParticleInfo.SpawnPointActor = 0x0 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnParticleInfo.Effect = 0x18 // ParticleSystem* (Size: 0x8)
MissionObjectiveSpawnParticleInfo.Weight = 0x20 // int32_t (Size: 0x4)
MissionObjectiveSpawnPickupInfo.SpawnPointActor = 0x0 // FMissionActorReference (Size: 0x18)
MissionObjectiveSpawnPickupInfo.PickupClass = 0x18 // ClassProperty (Size: 0x8)
MissionObjectiveSpawnPickupInfo.Weight = 0x20 // int32_t (Size: 0x4)
MissionObjectiveSpawnPickupInfo.ConfigID = 0x24 // int32_t (Size: 0x4)
MissionObjectiveSpawnPickupInfo.RelatedTargetTypes = 0x28 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
MissionObjectiveSpawnedActors.Actors = 0x0 // TArray<SGNetRelevantConfigurableActor*> (Size: 0x10)
MissionObjectiveSpawnedInteractItems.InteractItems = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionObjectiveSpawnedInventories.Inventories = 0x0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
MissionParadropRow.NewPlacementActor = 0x0 // FMFMissionVariableRead_ActorReference (Size: 0x40)
MissionParadropRow.ConfigRowName = 0x40 // FName (Size: 0x8)
MissionRdmBlackboardInstance.Weight = 0x28 // int32_t (Size: 0x4)
MissionRdmBlackboardInstance.Tag = 0x2c // FName (Size: 0x8)
MissionRdmBlackboardInstance.ChildRandom = 0x38 // TArray<MissionRdmBlackboardInstance*> (Size: 0x10)
MissionRelatedPlayers.PlayerStates = 0x0 // TArray<PlayerState*> (Size: 0x10)
MissionRelatedPlayers.TeamInfos = 0x10 // TArray<SGTeamInfo*> (Size: 0x10)
MissionRelatedPlayers.PlayerTeamTypes = 0x20 // TArray<EEPlayerTeamType> (Size: 0x10)
MissionRelatedPlayers.FactionTypes = 0x30 // TArray<EEFactionType> (Size: 0x10)
MissionRelatedTargets.Characters = 0x0 // TArray<Character*> (Size: 0x10)
MissionRelatedTargets.TeamInfos = 0x10 // TArray<SGTeamInfo*> (Size: 0x10)
MissionRelatedTargets.PlayerTeamTypes = 0x20 // TArray<EEPlayerTeamType> (Size: 0x10)
MissionRelatedTargets.FactionTypes = 0x30 // TArray<EEFactionType> (Size: 0x10)
MissionRewardItemEntry.MissionID = 0x0 // int32_t (Size: 0x4)
MissionRewardItemEntry.ItemId = 0x8 // int64_t (Size: 0x8)
MissionTraceableParam.ConfigID = 0x0 // int32_t (Size: 0x4)
MissionUploadData.MissionName = 0x0 // FString (Size: 0x10)
MissionUploadData.MissionStatus = 0x10 // EEMissionStatus (Size: 0x1)
MissionUploadData.CurProgress = 0x14 // int32_t (Size: 0x4)
MissionVariableWriteRow.Variables = 0x0 // TArray<MFMissionVariableWriteBase*> (Size: 0x10)
ModifyEscapeInfo.EscapePointID = 0x0 // int32_t (Size: 0x4)
ModifyEscapeInfo.bAddEscapePoint = 0x4 // bool (Size: 0x1)
ModifyEscapeInfoList.ModifyEscapeInfos = 0x0 // TArray<FModifyEscapeInfo> (Size: 0x10)
MousePinTraceInfo.WorldLocation = 0x0 // FVector (Size: 0xc)
MousePinTraceInfo.TraceType = 0xc // int32_t (Size: 0x4)
MousePinTraceInfo.bIsVisible = 0x10 // bool (Size: 0x1)
MousePinTraceInfo.MaxLifeTime = 0x14 // float (Size: 0x4)
MousePinTraceInfo.LifeTimeHandle = 0x18 // float (Size: 0x4)
MousePinTraceInfo.Handle = 0x1c // int32_t (Size: 0x4)
MousePinTraceInfoList.MousePinTraceInfoList = 0x0 // TArray<FMousePinTraceInfo> (Size: 0x10)
NewTraceableActorInfo.bTraceLocation = 0x8 // bool (Size: 0x1)
NewTraceableActorInfo.NeedDisplayPlatforms = 0x18 // TArray<EENewTraceDisplayPlatform> (Size: 0x10)
NewTraceableActorInfo.TraceActor = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
NewTraceableActorInfo.TraceActorOwner = 0x30 // TWeakObjectPtr<UObject> (Size: 0x8)
NewTraceableActorInfo.bActorDestroyed = 0x38 // bool (Size: 0x1)
NewTraceableActorInfo.WorldLocation = 0x3c // FVector (Size: 0xc)
NewTraceableActorInfo.Handle = 0x48 // int32_t (Size: 0x4)
NewTraceableActorInfo.ConfigID = 0x4c // int32_t (Size: 0x4)
NewTraceableActorInfo.bNeedTrace = 0x50 // bool (Size: 0x1)
NewTraceableActorInfo.CreateTimeStamp = 0x58 // int64_t (Size: 0x8)
NewTraceableActorInfo.TaskId = 0x60 // int32_t (Size: 0x4)
NewTraceableActorInfo.TargetId = 0x64 // int32_t (Size: 0x4)
NewTraceableActorInfo.Extend = 0x68 // FVector (Size: 0xc)
NewTraceableActorInfo.ConditionEscapeId = 0x74 // int32_t (Size: 0x4)
NewTraceableActorInfoList.TraceableActorInfos = 0x0 // TArray<FNewTraceableActorInfo> (Size: 0x10)
NiagaraSwitherRow.Asset = 0x0 // NiagaraSystem* (Size: 0x8)
NiagaraSwitherRow.PlayTime = 0x8 // float (Size: 0x4)
ObjPoolClassWeight.Class = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
ObjPoolClassWeight.Weight = 0x28 // int32_t (Size: 0x4)
OnKillOtherStruct.WeaponName = 0x0 // FString (Size: 0x10)
OnKillOtherStruct.BulletName = 0x10 // FString (Size: 0x10)
OnKillOtherStruct.KillTime = 0x20 // float (Size: 0x4)
OnKillOtherStruct.HitHelmetInventoryName = 0x28 // FString (Size: 0x10)
OnKillOtherStruct.HitVestInventoryName = 0x38 // FString (Size: 0x10)
OnKillOtherStruct.KilledPlayerTeamType = 0x48 // int32_t (Size: 0x4)
OnKillOtherStruct.ArmorLevel = 0x4c // int32_t (Size: 0x4)
OnKillOtherStruct.HitEndurance = 0x50 // int32_t (Size: 0x4)
OnKillOtherStruct.TeamType = 0x54 // int32_t (Size: 0x4)
OnKillOtherStruct.bADS = 0x58 // bool (Size: 0x1)
OnKillOtherStruct.WeaponInventory = 0x60 // SGInventory* (Size: 0x8)
OnKillOtherStruct.HitDistance = 0x68 // float (Size: 0x4)
OnKillOtherStruct.KillerPlayerID = 0x70 // uint64_t (Size: 0x8)
OnKillOtherStruct.CauseArmorConsume = 0x78 // float (Size: 0x4)
OnKillOtherStruct.CauseArmorReduceDamage = 0x7c // float (Size: 0x4)
OnKillOtherStruct.bHitHead = 0x80 // bool (Size: 0x1)
OnKillOtherStruct.ResultDamage = 0x84 // float (Size: 0x4)
OnKillOtherStruct.GameRunningTime = 0x88 // float (Size: 0x4)
OnKillOtherStruct.KilledCharacterID = 0x90 // uint64_t (Size: 0x8)
OnKillOtherStruct.HitGroup = 0x98 // int32_t (Size: 0x4)
OnKillOtherStruct.HitHeadPart = 0x9c // int32_t (Size: 0x4)
OnKillOtherStruct.KillerPosX = 0xa0 // float (Size: 0x4)
OnKillOtherStruct.KillerPosY = 0xa4 // float (Size: 0x4)
OnKillOtherStruct.KillerPosZ = 0xa8 // float (Size: 0x4)
OnKillOtherStruct.DeathPosX = 0xac // float (Size: 0x4)
OnKillOtherStruct.DeathPosY = 0xb0 // float (Size: 0x4)
OnKillOtherStruct.DeathPosZ = 0xb4 // float (Size: 0x4)
OnKillOtherStruct.GunId = 0xb8 // int32_t (Size: 0x4)
OnKillOtherStruct.BulletItemID = 0xbc // uint32_t (Size: 0x4)
OnKillOtherStruct.VestItemID = 0xc0 // uint32_t (Size: 0x4)
OnKillOtherStruct.HelmetItemID = 0xc4 // uint32_t (Size: 0x4)
OnKillOtherStruct.VerticalRecoil = 0xc8 // float (Size: 0x4)
OnKillOtherStruct.HorizontalRecoil = 0xcc // float (Size: 0x4)
OnKillOtherStruct.MoaX = 0xd0 // float (Size: 0x4)
OnKillOtherStruct.MoaY = 0xd4 // float (Size: 0x4)
OnKillOtherStruct.Ergonomics = 0xd8 // float (Size: 0x4)
OnKillOtherStruct.Accuracy = 0xdc // float (Size: 0x4)
OnKillOtherStruct.AccessoryIds = 0xe0 // FString (Size: 0x10)
ParticalSwitherRow.EffectActor = 0x0 // SGShowControlEffectActor* (Size: 0x8)
ParticalSwitherRow.PlayTime = 0x8 // float (Size: 0x4)
PathArray.PathNodes = 0x0 // TArray<SGAIPathNode*> (Size: 0x10)
PathNodeGroupInfo.BattleVolumes = 0x0 // Volume* (Size: 0x8)
PathNodeGroupInfo.PathNodes = 0x8 // TArray<SGAIPathNode*> (Size: 0x10)
PathNodeGroupInfo.ScavSpawnPoints = 0x18 // TArray<Actor*> (Size: 0x10)
PendingCreateItemInfo.PlayerItemInfo = 0x0 // SGPlayerItemInfoBase* (Size: 0x8)
PendingCreateItemInfo.ParentInventory = 0x8 // Actor* (Size: 0x8)
PendingCreateItemInfo.ContainerIndex = 0x10 // int32_t (Size: 0x4)
PlayerItemGroupReplaceInfo.PlayerGid = 0x0 // int64_t (Size: 0x8)
PlayerItemGroupReplaceInfo.TeamIndex = 0x8 // int32_t (Size: 0x4)
PlayerItemGroupReplaceInfo.ItemGroupReplaceInfos = 0x10 // TArray<FItemGroupReplaceInfo> (Size: 0x10)
PlayerStartGroupInfo.GroupIndex = 0x0 // int32_t (Size: 0x4)
PlayerStartGroupInfo.TeamType = 0x4 // EEPlayerTeamType (Size: 0x1)
PlayerStartGroupInfo.PlayerStarts = 0x8 // TArray<PlayerStart*> (Size: 0x10)
PlayerStateTraceableInventoryProxy.PlayerStateTraceComponent = 0x28 // UAPlayerStateTraceComponent* (Size: 0x8)
PlayerStateTraceableInventoryProxy.Inventory = 0x30 // SGInventory* (Size: 0x8)
PlayerTakeDamageByWeaponStatistics.WeaponName = 0x0 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.BulletName = 0x10 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.WeaponType = 0x20 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.VestLevel = 0x30 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.VestName = 0x38 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.HelmetLevel = 0x48 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HelmetName = 0x50 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.DamageHitType = 0x60 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.ResultDamage = 0x70 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ArmorConsume = 0x74 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.PenetrateDamage = 0x78 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.CharacterAllEndurance = 0x7c // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HitArmorName = 0x80 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.CurWeaponADSTime = 0x90 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.CurWeaponFireInterval = 0x94 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ValidAimTime = 0x98 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.DamageHitTypeInt = 0x9c // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ArmorReduceDamage = 0xa0 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ShootDistance = 0xa4 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.TeamType = 0xa8 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.bIsDead = 0xac // bool (Size: 0x1)
PlayerTakeDamageByWeaponStatistics.ShooterCharacterID = 0xb0 // uint64_t (Size: 0x8)
PlayerTakeDamageByWeaponStatistics.ShooterTeamType = 0xb8 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.CharacterType = 0xbc // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.WeaponValue = 0xc0 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HitSubEndurance = 0xc4 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.VerticalRecoil = 0xc8 // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HorizontalRecoil = 0xcc // float (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.SightName = 0xd0 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.WeaponId = 0xe0 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.MapID = 0xe4 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.Weatherid = 0xe8 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HurtFlowID = 0xec // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.EnemyRoleType = 0xf0 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.EnemyRoleID = 0xf8 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.EnemyUserName = 0x108 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.HurtTime = 0x118 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HurtType = 0x11c // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.DamageStart = 0x120 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.DamageReduce = 0x124 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HPstart = 0x128 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HPEnd = 0x12c // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HelmetHPStart = 0x130 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.HelmetHPEnd = 0x134 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ArmorHPStart = 0x138 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.ArmorHPEnd = 0x13c // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.FallHeight = 0x140 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.PlayerKilled = 0x144 // int32_t (Size: 0x4)
PlayerTakeDamageByWeaponStatistics.DebuffStartList = 0x148 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.DebuffEndList = 0x158 // FString (Size: 0x10)
PlayerTakeDamageByWeaponStatistics.bPenetrateArmor = 0x168 // bool (Size: 0x1)
PylonIDMapTableRow.Key = 0x8 // int64_t (Size: 0x8)
PylonIDMapTableRow.PylonID = 0x10 // int32_t (Size: 0x4)
PylonPoint.PylonID = 0x338 // int32_t (Size: 0x4)
QuestActionComp_SendNPCRequest.DestinationActor = 0x108 // Actor* (Size: 0x8)
QuestActionComp_SendNPCRequest.Timeout = 0x110 // float (Size: 0x4)
QuestActionSpawnInventoryInfo.SpawnPointID = 0x0 // int64_t (Size: 0x8)
QuestActionSpawnInventoryInfo.ItemId = 0x8 // int64_t (Size: 0x8)
QuestActionSpawnInventoryInfo.Weight = 0x10 // int32_t (Size: 0x4)
QuestActionSpawnInventoryInfo.ItemStackCount = 0x14 // int32_t (Size: 0x4)
QuestActionSpawnInventoryInfo.bCheckPlacement = 0x18 // bool (Size: 0x1)
QuestActionSpawnInventoryInfo.OperatorType = 0x19 // EETraceMarkOperatorType (Size: 0x1)
QuestActionSpawnInventoryInfo.MarkType = 0x1a // EETraceableMarkType (Size: 0x1)
QuestActionSpawnInventoryInfo.ScanningInterval = 0x1c // float (Size: 0x4)
QuestActionSpawnInventoryInfo.ConfigID = 0x20 // int32_t (Size: 0x4)
QuestAction_Damage_T.EnduranceType = 0x100 // EECharacterEnduranceType (Size: 0x1)
QuestAction_Debuff_T.EnduranceType = 0x100 // EECharacterEnduranceType (Size: 0x1)
QuestAction_Debuff_T.BuffName = 0x108 // FString (Size: 0x10)
QuestAction_FollowBar_T.FlowBarType = 0x100 // EETutorialFlowBarType (Size: 0x1)
QuestAction_FollowBar_T.bShow = 0x101 // bool (Size: 0x1)
QuestAction_FollowBar_T.TargetActor = 0x108 // Actor* (Size: 0x8)
QuestAction_FollowBar_T.Offset = 0x110 // FVector (Size: 0xc)
QuestAction_FollowBar_T.TextStrKey = 0x120 // FString (Size: 0x10)
QuestAction_FollowBar_T.IsLocalOffset = 0x130 // bool (Size: 0x1)
QuestAction_FollowBar_T.IsDetiveAction = 0x131 // bool (Size: 0x1)
QuestAction_HUDMask_T.Maskid = 0x100 // int32_t (Size: 0x4)
QuestAction_HUDMask_T.bShow = 0x104 // bool (Size: 0x1)
QuestAction_HUDMask_T.IsDeactiveAction = 0x105 // bool (Size: 0x1)
QuestAction_HUDMask_T.bShowMaskVisual = 0x106 // bool (Size: 0x1)
QuestAction_HudMessage_T.MessageArray = 0x100 // TArray<int64_t> (Size: 0x10)
QuestAction_HudMessage_T.ClearMessageArray = 0x110 // TArray<int64_t> (Size: 0x10)
QuestAction_HudMessage_T.IsDetiveAction = 0x120 // bool (Size: 0x1)
QuestAction_InputChange_T.PadButtonType = 0x100 // EEUAGamePadTable (Size: 0x1)
QuestAction_InputChange_T.bShow = 0x101 // bool (Size: 0x1)
QuestAction_InputChange_T.IsDetiveAction = 0x102 // bool (Size: 0x1)
QuestAction_InputChange_T.bLimitInput = 0x103 // bool (Size: 0x1)
QuestAction_InventoryDestroyed.InventoryIDs = 0x100 // TArray<int32_t> (Size: 0x10)
QuestAction_InventoryDestroyed.EffectType = 0x110 // EInventoryDestroyedEffectType (Size: 0x1)
QuestAction_ItemMenu_T.bEnable = 0x100 // bool (Size: 0x1)
QuestAction_ItemMenu_T.IsDeactiveAction = 0x101 // bool (Size: 0x1)
QuestAction_LetVolumeInteractable.MapIDs = 0x100 // TArray<int32_t> (Size: 0x10)
QuestAction_LetVolumeInteractable.VolumeName = 0x110 // FString (Size: 0x10)
QuestAction_LetVolumeInteractable.bForceUsePointMark = 0x120 // bool (Size: 0x1)
QuestAction_LetVolumeInteractable.bEnterVolumeAutoComplete = 0x121 // bool (Size: 0x1)
QuestAction_LetVolumeInteractable.UserWidgetPopInfo = 0x128 // FUserWidgetPopInfo (Size: 0x48)
QuestAction_LetVolumeInteractable.bCheckCostBeforePopWidget = 0x170 // bool (Size: 0x1)
QuestAction_LetVolumeInteractable.CostInventoryInfos = 0x178 // TArray<FInteractInventoryInfo> (Size: 0x10)
QuestAction_LetVolumeInteractable.ObtainInventoryInfos = 0x188 // TArray<FInteractInventoryInfo> (Size: 0x10)
QuestAction_LetVolumeInteractable.ValidVolume = 0x198 // SGVolume* (Size: 0x8)
QuestAction_LetVolumeInteractable.bAlreadyGathered = 0x1a0 // bool (Size: 0x1)
QuestAction_LockInput_T.bLock = 0x100 // bool (Size: 0x1)
QuestAction_LockInput_T.IsDeactiveAction = 0x101 // bool (Size: 0x1)
QuestAction_MessageInState_T.characterState = 0x118 // EETutorialCharacterState (Size: 0x1)
QuestAction_MessageInState_T.InStateMessageArray = 0x120 // TArray<int64_t> (Size: 0x10)
QuestAction_MessageInState_T.InStateClearMessageArray = 0x130 // TArray<int64_t> (Size: 0x10)
QuestAction_MessageInState_T.InStateEffect = 0x140 // EEGamePadEffectTable (Size: 0x1)
QuestAction_MessageInState_T.NotInStateMessageArray = 0x148 // TArray<int64_t> (Size: 0x10)
QuestAction_MessageInState_T.NotInStateClearMessageArray = 0x158 // TArray<int64_t> (Size: 0x10)
QuestAction_MessageInState_T.NotInStateEffect = 0x168 // EEGamePadEffectTable (Size: 0x1)
QuestAction_MessageInState_T.InStatePadButtonType = 0x169 // EEUAGamePadTable (Size: 0x1)
QuestAction_MessageInState_T.InStateHightWidget = 0x16a // EEUAGamePadHightWidgetTable (Size: 0x1)
QuestAction_MessageInState_T.InStateOffSet = 0x16c // FVector2D (Size: 0x8)
QuestAction_MessageInState_T.NotInStatePadButtonType = 0x174 // EEUAGamePadTable (Size: 0x1)
QuestAction_MessageInState_T.NotInStateHightWidget = 0x175 // EEUAGamePadHightWidgetTable (Size: 0x1)
QuestAction_MessageInState_T.NotInStateOffSet = 0x178 // FVector2D (Size: 0x8)
QuestAction_MoveVolumeParticle_T.MoveVolume = 0x100 // UAMTutorialMoveToVolume* (Size: 0x8)
QuestAction_MoveVolumeParticle_T.bShow = 0x108 // bool (Size: 0x1)
QuestAction_MoveVolumeParticle_T.IsDetiveAction = 0x109 // bool (Size: 0x1)
QuestAction_PadHightEffect_T.PadButtonType = 0x100 // EEUAGamePadTable (Size: 0x1)
QuestAction_PadHightEffect_T.HightWidget = 0x101 // EEUAGamePadHightWidgetTable (Size: 0x1)
QuestAction_PadHightEffect_T.Offset = 0x104 // FVector2D (Size: 0x8)
QuestAction_PadHightEffect_T.bShow = 0x10c // bool (Size: 0x1)
QuestAction_PadHightEffect_T.IsDetiveAction = 0x10d // bool (Size: 0x1)
QuestAction_QuestReport.AcitveReportIDList = 0x100 // TArray<int32_t> (Size: 0x10)
QuestAction_QuestReport.SuccessReportIDList = 0x110 // TArray<int32_t> (Size: 0x10)
QuestAction_QuestReport.FaildReportIDList = 0x120 // TArray<int32_t> (Size: 0x10)
QuestAction_RelevantToActors.TargetActors = 0x100 // TArray<Actor*> (Size: 0x10)
QuestAction_RelevantToActors.InteractItemIDs = 0x110 // TArray<int32_t> (Size: 0x10)
QuestAction_RelevantToActors.VolumeItemIDs = 0x120 // TArray<int32_t> (Size: 0x10)
QuestAction_RelevantToActors.InventoryItemIDs = 0x130 // TArray<int32_t> (Size: 0x10)
QuestAction_RelevantToActors.AIIDs = 0x140 // TArray<int32_t> (Size: 0x10)
QuestAction_RelevantToActors.bForceUsePointMark = 0x150 // bool (Size: 0x1)
QuestAction_RelevantToActors.OperatorType = 0x151 // EETraceMarkOperatorType (Size: 0x1)
QuestAction_RelevantToActors.MarkType = 0x152 // EETraceableMarkType (Size: 0x1)
QuestAction_RelevantToActors.ScanningInterval = 0x154 // float (Size: 0x4)
QuestAction_RelevantToActors.ConfigID = 0x158 // int32_t (Size: 0x4)
QuestAction_SoundUI_T.bShow = 0x100 // bool (Size: 0x1)
QuestAction_SoundUI_T.IsDetiveAction = 0x101 // bool (Size: 0x1)
QuestAction_SpawnInteractItem.QuestInteractItemSpawnInfos = 0x100 // TArray<QuestInteractItemSpawnInfo*> (Size: 0x10)
QuestAction_SpawnInteractItem.SpawnedInteractItem = 0x110 // TArray<SGNetRelevantConfigurableActor*> (Size: 0x10)
QuestAction_SpawnInteractItem.bDontDestroyOnDeactive = 0x120 // bool (Size: 0x1)
QuestAction_SpawnQuestDistributer.MapID = 0x100 // int32_t (Size: 0x4)
QuestAction_SpawnQuestDistributer.DistributerClass = 0x108 // ClassProperty (Size: 0x8)
QuestAction_SpawnQuestInventory.QuestInventorySpawnInfos = 0x100 // TArray<QuestInventorySpawnInfo*> (Size: 0x10)
QuestAction_SpawnQuestInventory.SpawnInventoryNum = 0x110 // int32_t (Size: 0x4)
QuestAction_SpawnQuestInventory.SpawnInventoryInfos = 0x118 // TArray<FQuestActionSpawnInventoryInfo> (Size: 0x10)
QuestAction_SpawnQuestInventory.SpawnedQuestInventorys = 0x128 // TArray<SGInventory*> (Size: 0x10)
QuestAction_TimeLimitCountDown.CountDownStartSecond = 0x100 // float (Size: 0x4)
QuestAction_TimeLimitCountDown.RemainTime = 0x104 // float (Size: 0x4)
QuestAction_TimeLimitCountDown.RemainTimeUpdateServerTime = 0x108 // float (Size: 0x4)
QuestAction_TimeLimitCountDown.CountDownTimerHandle = 0x110 // FTimerHandle (Size: 0x8)
QuestAction_TimeLimitCountDown.TargetActors = 0x118 // TArray<Actor*> (Size: 0x10)
QuestAction_TimeLimitCountDown.InteractItemIDs = 0x128 // TArray<int32_t> (Size: 0x10)
QuestAction_TimeLimitCountDown.VolumeItemIDs = 0x138 // TArray<int32_t> (Size: 0x10)
QuestAction_TimeLimitCountDown.InventoryItemIDs = 0x148 // TArray<int32_t> (Size: 0x10)
QuestAction_TimeLimitCountDown.AIIDs = 0x158 // TArray<int32_t> (Size: 0x10)
QuestAction_WidgetEffect_T.PadEffectType = 0x100 // EEGamePadEffectTable (Size: 0x1)
QuestAction_WidgetEffect_T.bShow = 0x101 // bool (Size: 0x1)
QuestAction_WidgetEffect_T.IsDetiveAction = 0x102 // bool (Size: 0x1)
QuestBase.bClearProgressWhenFinishGame = 0x3f0 // bool (Size: 0x1)
QuestBase.QuestTraceInfoComponent = 0x3f8 // QuestTraceInfoComponent* (Size: 0x8)
QuestConditionComp_ArmorType.bEqualType = 0x50 // bool (Size: 0x1)
QuestConditionComp_ArmorType.ArmorType = 0x51 // EESGArmorType (Size: 0x1)
QuestConditionComp_CharacterEnduranceType.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CharacterEnduranceType.CharacterEnduranceType = 0x58 // EECharacterEnduranceType (Size: 0x1)
QuestConditionComp_CharacterEnduranceType.CharacterEnduranceTypes = 0x60 // TArray<EECharacterEnduranceType> (Size: 0x10)
QuestConditionComp_CharacterGameEffectType.CharacterGameEffectTypes = 0x50 // TArray<EECharacterGameEffectType> (Size: 0x10)
QuestConditionComp_CharacterState_T.SourceActorContextConfig = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CharacterState_T.characterState = 0x58 // EETutorialCharacterState (Size: 0x1)
QuestConditionComp_CharacterState_T.CharacterStateCheckType = 0x59 // EETutorialCharacterStateCheckType (Size: 0x1)
QuestConditionComp_CharacterStatus.CharacterType = 0x50 // EEQuestConditionCharacterType (Size: 0x1)
QuestConditionComp_CharacterStatus.CharacterStatus = 0x51 // EEQuestConditionCharacterStatus (Size: 0x1)
QuestConditionComp_CharacterStatus.CheckTargetContextSource = 0x58 // ClassProperty (Size: 0x8)
QuestConditionComp_CharacterStatus.AIIDs = 0x60 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_CharacterStatus.AreaIDs = 0x70 // TArray<FString> (Size: 0x10)
QuestConditionComp_CharacterType.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CharacterType.SpecifiedTypes = 0x58 // TArray<EECharacterType> (Size: 0x10)
QuestConditionComp_CharacterType.BossGroupID = 0x68 // int64_t (Size: 0x8)
QuestConditionComp_ChaseActivityState.ChaseActivityState = 0x50 // EEChaseActivityState (Size: 0x1)
QuestConditionComp_CheckAIID.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckAIID.ValidAIIDPrefix = 0x58 // TArray<int64_t> (Size: 0x10)
QuestConditionComp_CheckAchievement.AchievementValue = 0x50 // int32_t (Size: 0x4)
QuestConditionComp_CheckAttribute.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckAttribute.AttributeCheckInfoList = 0x58 // TArray<CharacterAttributeCheckInfo*> (Size: 0x10)
QuestConditionComp_CheckCharacterEquipItem.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckCharacterEquipItem.bCheckTeammate = 0x58 // bool (Size: 0x1)
QuestConditionComp_CheckCharacterEquipItem.CheckItemType = 0x59 // EECheckItemType (Size: 0x1)
QuestConditionComp_CheckCharacterEquipItem.CheckParams = 0x60 // TArray<CheckItemParamBase*> (Size: 0x10)
QuestConditionComp_CheckDamageInfo.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckDamageInfo.CheckParams = 0x58 // TArray<CheckDamageInfoParamBase*> (Size: 0x10)
QuestConditionComp_CheckGameplayEffect.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckGameplayEffect.GameplayTagCheckInfoList = 0x58 // TArray<CharacterGameplayTagCheckInfo*> (Size: 0x10)
QuestConditionComp_CheckItem.CheckCharacterContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckItem.CheckTargetContextSource = 0x58 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckItem.CheckParams = 0x60 // TArray<CheckItemParamBase*> (Size: 0x10)
QuestConditionComp_CheckItemID.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckItemID.CheckItemIDs = 0x58 // TArray<uint64_t> (Size: 0x10)
QuestConditionComp_CheckNumber.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckNumber.bIntNumber = 0x58 // bool (Size: 0x1)
QuestConditionComp_CheckNumber.CompareType = 0x59 // EENumberCompareType (Size: 0x1)
QuestConditionComp_CheckNumber.MinIntValue = 0x5c // int32_t (Size: 0x4)
QuestConditionComp_CheckNumber.MaxIntValue = 0x60 // int32_t (Size: 0x4)
QuestConditionComp_CheckNumber.MinFloatValue = 0x64 // float (Size: 0x4)
QuestConditionComp_CheckNumber.MaxFloatValue = 0x68 // float (Size: 0x4)
QuestConditionComp_CheckPlayerLevel.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckPlayerLevel.MinLevel = 0x58 // int32_t (Size: 0x4)
QuestConditionComp_CheckPlayerLevel.MaxLevel = 0x5c // int32_t (Size: 0x4)
QuestConditionComp_CheckUseInventoryPhase.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_CheckUseInventoryPhase.UseInventoryPhase = 0x58 // EEUseInventoryPhase (Size: 0x1)
QuestConditionComp_CurrentTODTime.StartTime = 0x50 // FTimeOfDay (Size: 0xc)
QuestConditionComp_CurrentTODTime.EndTime = 0x5c // FTimeOfDay (Size: 0xc)
QuestConditionComp_EscapeVolume.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_EscapeVolume.EscapePointIDs = 0x58 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_EscapeVolume.OperatorType = 0x68 // EETraceMarkOperatorType (Size: 0x1)
QuestConditionComp_EscapeVolume.ConfigID = 0x6c // int32_t (Size: 0x4)
QuestConditionComp_MapName.MapName = 0x50 // FString (Size: 0x10)
QuestConditionComp_PlayModeId.ModeIDArray = 0x50 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_PlayModeId.SubModeIDArray = 0x60 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_PlayModeId.MapIDArray = 0x70 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_PlayModeId.RuleIdArray = 0x80 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_PlayModeId.DifficultyArray = 0x90 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_PlayerEndGameType.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_PlayerEndGameType.PlayerEndGameTypes = 0x58 // TArray<EEPlayerEndGameType> (Size: 0x10)
QuestConditionComp_RecoveryAttributeType.RecoveryAttributeType = 0x50 // EESGRecoveryAttributeType (Size: 0x1)
QuestConditionComp_StayVolume.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_StayVolume.ValidVolumeIDs = 0x58 // TArray<int32_t> (Size: 0x10)
QuestConditionComp_StayVolume.ValidVolumeNames = 0x68 // TArray<FString> (Size: 0x10)
QuestConditionComp_StayVolume.bForceUsePointMark = 0x78 // bool (Size: 0x1)
QuestConditionComp_StayVolume.ValidVolumes = 0x80 // TArray<SGVolume*> (Size: 0x10)
QuestConditionComp_StayVolume.OperatorType = 0x90 // EETraceMarkOperatorType (Size: 0x1)
QuestConditionComp_StayVolume.ConfigID = 0x94 // int32_t (Size: 0x4)
QuestConditionComp_TakeLimit.ItemTypeIDs = 0x50 // TArray<uint64_t> (Size: 0x10)
QuestConditionComp_TakeLimit.LogicType = 0x60 // EEQuestTakeLimitLogicType (Size: 0x1)
QuestConditionComp_TeamInfo.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_TeamInfo.TeamInfoCheckType = 0x58 // EETeamInfoCheckType (Size: 0x1)
QuestConditionComp_TeamInfo.StringValue1 = 0x60 // FString (Size: 0x10)
QuestConditionComp_TeamInfo.StringValue2 = 0x70 // FString (Size: 0x10)
QuestConditionComp_TimeAfterActivation.CompareType = 0x50 // EENumCompareType (Size: 0x1)
QuestConditionComp_TimeAfterActivation.Value1 = 0x54 // int32_t (Size: 0x4)
QuestConditionComp_TimeAfterActivation.Value2 = 0x58 // int32_t (Size: 0x4)
QuestConditionComp_TimeLimit.CheckTargetContextSource = 0x50 // ClassProperty (Size: 0x8)
QuestConditionComp_TimeLimit.TimeLimitType = 0x60 // EETimeLimitType (Size: 0x1)
QuestConditionComp_TimeLimit.TimeLimitSeconds = 0x64 // int32_t (Size: 0x4)
QuestConditionComp_TimeLimit.TimeRecordCount = 0x68 // int32_t (Size: 0x4)
QuestCreateData.TargetId = 0x0 // int32_t (Size: 0x4)
QuestCreateData.CurrProgress = 0x4 // int32_t (Size: 0x4)
QuestCreateData.MaxProgress = 0x8 // int32_t (Size: 0x4)
QuestCreateData.PreviewTargets = 0x10 // TArray<int32_t> (Size: 0x10)
QuestCreateData.NodeType = 0x20 // int32_t (Size: 0x4)
QuestCreateData.PrevType = 0x24 // int32_t (Size: 0x4)
QuestCreateData.FailWhenNextFail = 0x28 // int32_t (Size: 0x4)
QuestCreateData.IsAct = 0x2c // bool (Size: 0x1)
QuestCreateData.ActQuestTemplateParams = 0x30 // TArray<int32_t> (Size: 0x10)
QuestDistributerBase.bClearProgressWhenFinishGame = 0x3b0 // bool (Size: 0x1)
QuestDistributerSubsystem.QuestDistPathList = 0x30 // TArray<FString> (Size: 0x10)
QuestDistributerSubsystem.BlueprintGeneratedClasses = 0x48 // TArray<ClassProperty> (Size: 0x10)
QuestDistributerSubsystem.SpawnedQuestDistributers = 0x58 // TArray<MFQuestDistributerBase*> (Size: 0x10)
QuestDistributerSubsystem.DistributeQuestHistories = 0x68 // TArray<FDistributeQuestHistory> (Size: 0x10)
QuestEffectSpawnInteractItemInfo.SpawnPointID = 0x0 // int64_t (Size: 0x8)
QuestEffectSpawnInteractItemInfo.InteractItemClass = 0x8 // ClassProperty (Size: 0x8)
QuestEffectSpawnInteractItemInfo.Weight = 0x10 // int32_t (Size: 0x4)
QuestEffectSpawnInteractItemInfo.bQuestActionRelevantToActors = 0x14 // bool (Size: 0x1)
QuestEffectSpawnInteractItemInfo.TargetContextSource = 0x18 // ClassProperty (Size: 0x8)
QuestEffectSpawnInteractItemInfo.RelatedTargetTypes = 0x20 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffectSpawnInventoryInfo.SpawnPointID = 0x0 // int64_t (Size: 0x8)
QuestEffectSpawnInventoryInfo.ContainerClass = 0x8 // ClassProperty (Size: 0x8)
QuestEffectSpawnInventoryInfo.ItemIDs = 0x10 // TArray<int64_t> (Size: 0x10)
QuestEffectSpawnInventoryInfo.Weight = 0x20 // int32_t (Size: 0x4)
QuestEffectSpawnInventoryInfo.ConfigID = 0x24 // int32_t (Size: 0x4)
QuestEffectSpawnInventoryInfo.TargetContextSource = 0x28 // ClassProperty (Size: 0x8)
QuestEffectSpawnInventoryInfo.RelatedTargetTypes = 0x30 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffectSpawnPickupInfo.SpawnPointID = 0x0 // int64_t (Size: 0x8)
QuestEffectSpawnPickupInfo.PickupClass = 0x8 // ClassProperty (Size: 0x8)
QuestEffectSpawnPickupInfo.Weight = 0x10 // int32_t (Size: 0x4)
QuestEffectSpawnPickupInfo.ConfigID = 0x14 // int32_t (Size: 0x4)
QuestEffectSpawnPickupInfo.TargetContextSource = 0x18 // ClassProperty (Size: 0x8)
QuestEffectSpawnPickupInfo.RelatedTargetTypes = 0x20 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffect_ActivateLootPoint.ActivateLootPointConfigs = 0x38 // TMap<...> (Size: 0x50)
QuestEffect_Broadcast.RelatedTargetContextSource = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_Broadcast.RelatedTargetTypes = 0x40 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffect_Broadcast.GameHUDConfig = 0x50 // FBroadcastOnGameHUDConfig (Size: 0x30)
QuestEffect_DistributeQuest.TargetContextSource = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_DistributeQuest.RelatedTargetTypes = 0x40 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffect_DistributeQuest.bUseRandomQuestTable = 0x50 // bool (Size: 0x1)
QuestEffect_DistributeQuest.GraphID = 0x54 // int32_t (Size: 0x4)
QuestEffect_DistributeQuest.RandomQuestTable = 0x58 // DataTable* (Size: 0x8)
QuestEffect_GiveItem.TargetContextSource = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_GiveItem.RelatedTargetTypes = 0x40 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffect_GiveItem.GiveItemInfos = 0x50 // TArray<FGiveItemInfo> (Size: 0x10)
QuestEffect_ModifyAchievement.ModifyTarget = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_ModifyAchievement.ModifyValueSource = 0x40 // ClassProperty (Size: 0x8)
QuestEffect_ModifyEscapePoint.TickTimerHandle = 0x38 // FTimerHandle (Size: 0x8)
QuestEffect_ModifyEscapePoint.bOpenEscapePoint = 0x40 // bool (Size: 0x1)
QuestEffect_ModifyEscapePoint.RandomEscapePoint = 0x44 // int32_t (Size: 0x4)
QuestEffect_ModifyEscapePoint.RandomEscapePointIDs = 0x48 // TArray<FRandomEscapePoint> (Size: 0x10)
QuestEffect_ModifyEscapePoint.EscapePointIDs = 0x58 // TArray<int32_t> (Size: 0x10)
QuestEffect_ModifyEscapePoint.CharacterType = 0x68 // EECharacterType (Size: 0x1)
QuestEffect_ModifyEscapePoint.EscapePresetNames = 0x70 // TArray<FString> (Size: 0x10)
QuestEffect_ModifyEscapePoint.bUseCharacterType = 0x80 // bool (Size: 0x1)
QuestEffect_ModifyEscapePoint.DelayTime = 0x84 // float (Size: 0x4)
QuestEffect_ModifyMarkable.RelatedTargetContextSource = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_ModifyMarkable.RelatedTargetTypes = 0x40 // TArray<EERelatedTargetType> (Size: 0x10)
QuestEffect_ModifyMarkable.bMarkable = 0x50 // bool (Size: 0x1)
QuestEffect_ModifyMarkable.AICharacterMarkContextSource = 0x58 // ClassProperty (Size: 0x8)
QuestEffect_ModifyMarkable.AICharacterMarkables = 0x60 // TArray<FAICharacterMarkableInfo> (Size: 0x10)
QuestEffect_ModifyMarkable.InventoryMarkables = 0x70 // TArray<FInventoryMarkableInfo> (Size: 0x10)
QuestEffect_ModifyMarkable.VolumeMarkables = 0x80 // TArray<FVolumeMarkableInfo> (Size: 0x10)
QuestEffect_ResetAchievement.ModifyTarget = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_SpawnAI.TriggerSpawnByAreaConfig = 0x38 // FTriggerSpawnByAreaConfig (Size: 0x18)
QuestEffect_SpawnAI.TriggerSpawnByVolumeConfig = 0x50 // FTriggerSpawnByVolumeConfig (Size: 0x18)
QuestEffect_SpawnAI.TriggerSpawnByEventConfig = 0x68 // FTriggerSpawnByEventConfig (Size: 0x18)
QuestEffect_SpawnAI.EventStrs = 0x80 // TArray<FString> (Size: 0x10)
QuestEffect_SpawnActorAtPylon.SpawnActorClass = 0x38 // ClassProperty (Size: 0x8)
QuestEffect_SpawnActorAtPylon.bUsePylonIDMapTable = 0x40 // bool (Size: 0x1)
QuestEffect_SpawnActorAtPylon.TargetContextSource = 0x48 // ClassProperty (Size: 0x8)
QuestEffect_SpawnActorAtPylon.PylonIDTable = 0x50 // DataTable* (Size: 0x8)
QuestEffect_SpawnActorAtPylon.PylonIDs = 0x58 // TArray<int32_t> (Size: 0x10)
QuestEffect_SpawnInteractItem.SpawnInteractItemNum = 0x38 // int32_t (Size: 0x4)
QuestEffect_SpawnInteractItem.SpawnInteractItemInfos = 0x40 // TArray<FQuestEffectSpawnInteractItemInfo> (Size: 0x10)
QuestEffect_SpawnInteractItem.SpawnedInteractItem = 0x50 // TArray<SGNetRelevantConfigurableActor*> (Size: 0x10)
QuestEffect_SpawnInventory.SpawnLocation = 0x38 // FVector (Size: 0xc)
QuestEffect_SpawnInventory.SpawnRotation = 0x44 // FRotator (Size: 0xc)
QuestEffect_SpawnInventory.ContainerClass = 0x50 // ClassProperty (Size: 0x8)
QuestEffect_SpawnInventory.ItemIDs = 0x58 // TArray<int64_t> (Size: 0x10)
QuestEffect_SpawnInventory.SpawnInventoryNum = 0x68 // int32_t (Size: 0x4)
QuestEffect_SpawnInventory.SpawnInventoryInfos = 0x70 // TArray<FQuestEffectSpawnInventoryInfo> (Size: 0x10)
QuestEffect_SpawnPickup.SpawnPickupNum = 0x38 // int32_t (Size: 0x4)
QuestEffect_SpawnPickup.SpawnPickupInfos = 0x40 // TArray<FQuestEffectSpawnPickupInfo> (Size: 0x10)
QuestIDTableRow.QuestID = 0x8 // int32_t (Size: 0x4)
QuestIDTableRow.QuestClass = 0x10 // TSoftClassPtr<UObject> (Size: 0x28)
QuestInteractItemSpawnInfo.InventorySpawnPoint = 0x28 // QuestItemSpawnPoint* (Size: 0x8)
QuestInteractItemSpawnInfo.InteractItemClass = 0x30 // ClassProperty (Size: 0x8)
QuestInteractItemSpawnInfo.bCheckPlacement = 0x38 // bool (Size: 0x1)
QuestInteractItemSpawnInfo.OperatorType = 0x39 // EETraceMarkOperatorType (Size: 0x1)
QuestInteractItemSpawnInfo.ConfigID = 0x3c // int32_t (Size: 0x4)
QuestInventory.TaskId = 0x0 // int32_t (Size: 0x4)
QuestInventory.TargetId = 0x4 // int32_t (Size: 0x4)
QuestInventory.ItemIDs = 0x8 // TArray<int64_t> (Size: 0x10)
QuestInventory.BigType = 0x18 // int32_t (Size: 0x4)
QuestInventory.MidType = 0x20 // int64_t (Size: 0x8)
QuestInventory.subtype = 0x28 // int64_t (Size: 0x8)
QuestInventory.RarityList = 0x30 // TArray<int32_t> (Size: 0x10)
QuestInventorySpawnInfo.InventorySpawnPoint = 0x28 // QuestItemSpawnPoint* (Size: 0x8)
QuestInventorySpawnInfo.ItemId = 0x30 // uint64_t (Size: 0x8)
QuestInventorySpawnInfo.ItemStackCount = 0x38 // int32_t (Size: 0x4)
QuestInventorySpawnInfo.bCheckPlacement = 0x3c // bool (Size: 0x1)
QuestInventorySpawnInfo.OperatorType = 0x3d // EETraceMarkOperatorType (Size: 0x1)
QuestInventorySpawnInfo.MarkType = 0x3e // EETraceableMarkType (Size: 0x1)
QuestInventorySpawnInfo.ScanningInterval = 0x40 // float (Size: 0x4)
QuestInventorySpawnInfo.ConfigID = 0x44 // int32_t (Size: 0x4)
QuestItemSpawnPoint.SpawnPointID = 0x338 // int32_t (Size: 0x4)
QuestItemSpawnPoint.CurrentInstigator = 0x340 // Character* (Size: 0x8)
QuestItemSpawnPoint.AdditionComponents = 0x348 // TArray<ClassProperty> (Size: 0x10)
QuestManagerActor.QuestTable = 0x320 // DataTable* (Size: 0x8)
QuestManagerActor.ActQuestTemplateTable = 0x328 // DataTable* (Size: 0x8)
QuestManagerActor.TraceTasks = 0x330 // TArray<int32_t> (Size: 0x10)
QuestManagerActor.MaxTraceNum = 0x340 // int32_t (Size: 0x4)
QuestManagerActor.DummyQuestClass = 0x348 // ClassProperty (Size: 0x8)
QuestManagerActor.TutorialHintItemIDs = 0x350 // TArray<int32_t> (Size: 0x10)
QuestManagerActor.TutorialHintSelfBagWidgetIDs = 0x360 // TArray<EEUAHUDNewBagWidgetIdentification> (Size: 0x10)
QuestManagerActor.TutorialHintCorpseBagWidgetIDs = 0x370 // TArray<EEUAHUDNewBagWidgetIdentification> (Size: 0x10)
QuestManagerActor.TutorialHintWidgetPaths = 0x380 // TArray<FString> (Size: 0x10)
QuestManagerComponent.MaxSecondInOneFrame = 0x108 // float (Size: 0x4)
QuestManagerComponent.WaitDestroyGraph = 0x120 // TArray<MFQuestNodeGraph*> (Size: 0x10)
QuestManagerComponent.HasFinishPC = 0x130 // TArray<PlayerController*> (Size: 0x10)
QuestObjCom_TakeOutItemType.LimitItemMainMidTypePreix = 0x168 // int32_t (Size: 0x4)
QuestObjectiveComp_AIMove_T.AllCharacter = 0x168 // TArray<SGCharacter*> (Size: 0x10)
QuestObjectiveComp_AIMove_T.AllAISpawnPoint = 0x178 // TArray<SGAISpawnPoint*> (Size: 0x10)
QuestObjectiveComp_AIMove_T.ArriveCharacter = 0x188 // TArray<SGCharacter*> (Size: 0x10)
QuestObjectiveComp_Assemble_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_Assemble_T.WeaponClass = 0x170 // ClassProperty (Size: 0x8)
QuestObjectiveComp_AttractAI.bEnableTeamMemberHelp = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_BagTabSign_T.BagType = 0x168 // EETutorialBagType (Size: 0x1)
QuestObjectiveComp_BagTabSign_T.BagTabType = 0x169 // EETutorialBagTabType (Size: 0x1)
QuestObjectiveComp_Bag_T.BagState = 0x168 // EETutorialBagState (Size: 0x1)
QuestObjectiveComp_Bag_T.BagType = 0x169 // EETutorialBagType (Size: 0x1)
QuestObjectiveComp_Bag_T.SpawnPoint = 0x170 // SGAISpawnPoint* (Size: 0x8)
QuestObjectiveComp_Bag_T.ContainerClass = 0x178 // ClassProperty (Size: 0x8)
QuestObjectiveComp_BgnUseItem_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_BgnUseItem_T.CharacterEnduranceType = 0x170 // EECharacterEnduranceType (Size: 0x1)
QuestObjectiveComp_BigMap_T.BigMapState = 0x168 // EEBigMapState (Size: 0x1)
QuestObjectiveComp_ChangeState_T.characterState = 0x168 // EETutorialCharacterState (Size: 0x1)
QuestObjectiveComp_CharacterMove.MinUpdateDistance = 0x168 // int32_t (Size: 0x4)
QuestObjectiveComp_CharacterMove.CacheDistance = 0x16c // int32_t (Size: 0x4)
QuestObjectiveComp_ClearArea.SpecifiedTypes = 0x168 // TArray<EECharacterType> (Size: 0x10)
QuestObjectiveComp_ClearArea.VolumeID = 0x178 // int64_t (Size: 0x8)
QuestObjectiveComp_ClearArea.VolumeStatisComponent = 0x180 // UAVolumeStatisComponent* (Size: 0x8)
QuestObjectiveComp_ClearArea.TargetNum = 0x188 // uint32_t (Size: 0x4)
QuestObjectiveComp_ClearArea.TickTimerHandle = 0x190 // FTimerHandle (Size: 0x8)
QuestObjectiveComp_ClickFakeMap.DelayTime = 0x168 // float (Size: 0x4)
QuestObjectiveComp_ClickItem_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_CollectItem.CollectedItems = 0x168 // TArray<SGInventory*> (Size: 0x10)
QuestObjectiveComp_CollectItem.bEnableTeamMemberHelp = 0x190 // bool (Size: 0x1)
QuestObjectiveComp_CollectItem.bAddProgressWhenActivate = 0x191 // bool (Size: 0x1)
QuestObjectiveComp_CollectItem.bChangeCountsToValue = 0x192 // bool (Size: 0x1)
QuestObjectiveComp_CompleteRequest.bIncreaseQuestPrgress = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_Door_T.Door = 0x168 // SGDoorBase* (Size: 0x8)
QuestObjectiveComp_Door_T.DoorState = 0x170 // EETutorialDoorState (Size: 0x1)
QuestObjectiveComp_FacePanel_T.FacePanelState = 0x168 // EEFacePanelState (Size: 0x1)
QuestObjectiveComp_HealthUI_T.BodyType = 0x168 // EECharacterEnduranceType (Size: 0x1)
QuestObjectiveComp_HitTarget.bEnableTeamMemberHelp = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_Interaction.InteractTargets = 0x168 // TArray<Actor*> (Size: 0x10)
QuestObjectiveComp_Interaction.bHasTryInteract = 0x178 // bool (Size: 0x1)
QuestObjectiveComp_Interaction.InteractEnableType = 0x179 // EEQuestInteractEnableType (Size: 0x1)
QuestObjectiveComp_KillAI_T.AISpawnPointArr = 0x168 // TArray<SGAISpawnPoint*> (Size: 0x10)
QuestObjectiveComp_KillTarget.bEnableTeamMemberHelp = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_MoveItem_T.NewPositionType = 0x168 // EEAttachPosition (Size: 0x1)
QuestObjectiveComp_MoveItem_T.ItemClass = 0x170 // ClassProperty (Size: 0x8)
QuestObjectiveComp_MoveTo_T.Volume = 0x168 // SGVolume* (Size: 0x8)
QuestObjectiveComp_PickUpItem_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_Search_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_Setting_T.SettingPannalState = 0x168 // EETutorialSettingState (Size: 0x1)
QuestObjectiveComp_Sound_T.DelayTime = 0x168 // float (Size: 0x4)
QuestObjectiveComp_Survival.bResetOnCheckFailed = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_Survival.TickTimerHandle = 0x170 // FTimerHandle (Size: 0x8)
QuestObjectiveComp_SwitchWeapon_T.WeaponClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_TakeInItemValue.bChangeValueToCounts = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_TakeOutItemValue.bEscapeFailedIngnoreSafeBox = 0x16c // bool (Size: 0x1)
QuestObjectiveComp_TakeOutItemValue.bChangeValueToCounts = 0x16d // bool (Size: 0x1)
QuestObjectiveComp_Target_T.Targets = 0x168 // TArray<SGRangeTargetBase*> (Size: 0x10)
QuestObjectiveComp_Target_T.DamageType = 0x178 // EETutorialDamageType (Size: 0x1)
QuestObjectiveComp_Target_T.bAccumulate = 0x179 // bool (Size: 0x1)
QuestObjectiveComp_UseInventory.TickTimerHandle = 0x170 // FTimerHandle (Size: 0x8)
QuestObjectiveComp_UseItem_T.ItemClass = 0x168 // ClassProperty (Size: 0x8)
QuestObjectiveComp_UseThrowable.bEnableTeamMemberHelp = 0x168 // bool (Size: 0x1)
QuestObjectiveComp_ViewTrace_T.ViewTargetActor = 0x168 // Actor* (Size: 0x8)
QuestObjectiveComp_ViewTrace_T.TraceLength = 0x170 // int32_t (Size: 0x4)
QuestObjectiveComp_ViewTrace_T.Duration = 0x174 // float (Size: 0x4)
QuestObjectiveComp_ViewTrace_T.CheckChannal = 0x178 // uint8_t (Size: 0x1)
QuestPrimaryCondition_CharacterEnduranceChanged.RecoveryAttributeChangeType = 0x78 // EERecoveryAttributeChangeType (Size: 0x1)
QuestPrimaryCondition_CharacterFoodChanged.RecoveryAttributeChangeType = 0x78 // EERecoveryAttributeChangeType (Size: 0x1)
QuestPrimaryCondition_CharacterMoistureChanged.RecoveryAttributeChangeType = 0x78 // EERecoveryAttributeChangeType (Size: 0x1)
QuestPrimaryCondition_ChaseActivityStateChange.ChaseActivityState = 0x78 // EEChaseActivityState (Size: 0x1)
QuestPrimaryCondition_Countdown.TickTimerHandle = 0x78 // FTimerHandle (Size: 0x8)
QuestPrimaryCondition_Countdown.DelayTime = 0x80 // float (Size: 0x4)
QuestPrimaryCondition_Interact.InteractEventType = 0x78 // EEInteractEventType (Size: 0x1)
QuestPrimaryCondition_Interact.bCheckVolumeID = 0x79 // bool (Size: 0x1)
QuestPrimaryCondition_Interact.ValidVolumeIDs = 0x80 // TArray<int32_t> (Size: 0x10)
QuestPrimaryCondition_Interact.bCheckVolumeName = 0x90 // bool (Size: 0x1)
QuestPrimaryCondition_Interact.ValidVolumeNames = 0x98 // TArray<FString> (Size: 0x10)
QuestPrimaryCondition_KillEvent.bEnableTeamMemberHelp = 0x78 // bool (Size: 0x1)
QuestPrimaryCondition_LootPointSpawnCompleted.ValidLootPointTypes = 0x78 // TArray<int32_t> (Size: 0x10)
QuestPrimaryCondition_RandTimeRange.TickTimerHandle = 0x78 // FTimerHandle (Size: 0x8)
QuestPrimaryCondition_RandTimeRange.StartTime = 0x80 // FTimeOfDay (Size: 0xc)
QuestPrimaryCondition_RandTimeRange.EndTime = 0x8c // FTimeOfDay (Size: 0xc)
QuestPrimaryCondition_Survival.TickTimerHandle = 0x78 // FTimerHandle (Size: 0x8)
QuestPrimaryCondition_TakeInItemValue.bChangeValueToCounts = 0x78 // bool (Size: 0x1)
QuestPrimaryCondition_TakeOutItemValue.bEscapeFailedIngnoreSafeBox = 0x78 // bool (Size: 0x1)
QuestPrimaryCondition_TakeOutItemValue.bChangeValueToCounts = 0x79 // bool (Size: 0x1)
QuestPrimaryCondition_UseRecoveryInventory.UseInventoryPhase = 0x78 // EEUseInventoryPhase (Size: 0x1)
QuestPrimaryCondition_WalkDistance.MoveDistanceTypes = 0x78 // TArray<EECharacterMoveDistanceType> (Size: 0x10)
QuestProgress_Count_G.ProgressUnit = 0x118 // int32_t (Size: 0x4)
QuestProgress_Count_G.CachedProgress = 0x11c // int32_t (Size: 0x4)
QuestReplicateData.Controller = 0x0 // Controller* (Size: 0x8)
QuestReplicateData.GraphID = 0x8 // int32_t (Size: 0x4)
QuestReplicateData.GraphState = 0xc // EEQuestStatus (Size: 0x1)
QuestReplicateData.QuestActors = 0x10 // TArray<MFQuestBase*> (Size: 0x10)
QuestReplicateData.IsSeasonTask = 0x20 // bool (Size: 0x1)
QuestReplicateData.QuestBeforeState = 0x21 // bool (Size: 0x1)
QuestReplicateData.OldGraphState = 0x22 // EEQuestStatus (Size: 0x1)
QuestReplicateData.GraphStateChangeTime = 0x24 // float (Size: 0x4)
QuestTraceInfo.TraceActor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
QuestTraceInfo.TraceMarkType = 0x8 // EEQuestTraceMarkType (Size: 0x1)
QuestTraceInfo.Handle = 0xc // int32_t (Size: 0x4)
QuestTraceInfo.WorldLocation = 0x10 // FVector (Size: 0xc)
QuestTraceInfo.Extend = 0x1c // FVector (Size: 0xc)
QuestTraceInfo.bIsActorDestroyed = 0x28 // bool (Size: 0x1)
QuestTraceInfo.bHasOwner = 0x29 // bool (Size: 0x1)
QuestTraceInfo.bNeedTrace = 0x2a // bool (Size: 0x1)
QuestTraceInfo.OwnerQuest = 0x2c // TWeakObjectPtr<UObject> (Size: 0x8)
QuestTraceInfo.TaskId = 0x34 // int32_t (Size: 0x4)
QuestTraceInfo.TargetId = 0x38 // int32_t (Size: 0x4)
QuestTraceInfo.EscapeId = 0x3c // int32_t (Size: 0x4)
RWGRandPoolUnit.RandWeight = 0x0 // int32_t (Size: 0x4)
RWGRandPoolUnit.SuitInfo = 0x8 // FSuitInfo (Size: 0x40)
RandomCacheStruct.EscapePoints = 0x0 // TArray<int32_t> (Size: 0x10)
RandomEscapePoint.EscapePointID = 0x0 // int32_t (Size: 0x4)
RandomEscapePoint.Weight = 0x4 // int32_t (Size: 0x4)
RandomMissionTableRow.TaskId = 0x8 // int32_t (Size: 0x4)
RandomMissionTableRow.Weight = 0xc // int32_t (Size: 0x4)
RandomMissionTableRow.MinLevel = 0x10 // int32_t (Size: 0x4)
RandomMissionTableRow.MaxLevel = 0x14 // int32_t (Size: 0x4)
RandomQuestTableRow.TaskId = 0x8 // int32_t (Size: 0x4)
RandomQuestTableRow.Weight = 0xc // int32_t (Size: 0x4)
RandomQuestTableRow.MinLevel = 0x10 // int32_t (Size: 0x4)
RandomQuestTableRow.MaxLevel = 0x14 // int32_t (Size: 0x4)
ReachGoalAction.Actions = 0x0 // TArray<MFMissionAction*> (Size: 0x10)
RelevantFollowActorList.ActorList = 0x0 // TArray<Actor*> (Size: 0x10)
RestrictedAreaInfo.CenterPointOffsetMax = 0x0 // float (Size: 0x4)
RestrictedAreaInfo.CenterPoint = 0x4 // FVector (Size: 0xc)
RestrictedAreaInfo.Radius = 0x10 // float (Size: 0x4)
RestrictedAreaInfo.WaitTime = 0x14 // float (Size: 0x4)
RestrictedAreaInfo.ShrinkTime = 0x18 // float (Size: 0x4)
RestrictedAreaInfo.Damage = 0x1c // int32_t (Size: 0x4)
RestrictedAreaInfo.DamageInterval = 0x20 // float (Size: 0x4)
RichTextBlockUMGDecorator.UMGSet = 0x28 // DataTable* (Size: 0x8)
RichTextBlockUMGDecorator.CacheWidget = 0x30 // TMap<...> (Size: 0x50)
RichUMGRow.WidgetClass = 0x8 // ClassProperty (Size: 0x8)
RoleBannerCustomData.Name = 0x0 // FString (Size: 0x10)
RoleBannerCustomData.Value = 0x10 // FString (Size: 0x10)
RoleBannerCustomData.IsDynamicDataBG = 0x20 // bool (Size: 0x1)
RoleBannerCustomData.BackgroundImagePath = 0x28 // FString (Size: 0x10)
RoleBannerCustomData.Index = 0x38 // int32_t (Size: 0x4)
RoleBannerCustomData.IsValid = 0x3c // bool (Size: 0x1)
RoleBannerInfo.Index = 0x0 // int32_t (Size: 0x4)
RoleBannerInfo.TitleName = 0x8 // FString (Size: 0x10)
RoleBannerInfo.TitleIconPath = 0x18 // FString (Size: 0x10)
RoleBannerInfo.TitleBackgroundPath = 0x28 // FString (Size: 0x10)
RoleBannerInfo.TitleShowNum = 0x38 // int32_t (Size: 0x4)
RoleBannerInfo.TitleHighestRankStarNum = 0x3c // int32_t (Size: 0x4)
RoundGameFactionData.Faction = 0x0 // EEFactionType (Size: 0x1)
RoundGameFactionData.FactionColor = 0x4 // FLinearColor (Size: 0x10)
RoundGameFactionData.FactionPlayerList = 0x18 // TArray<FRoundGamePlayerData> (Size: 0x10)
RoundGamePlayerData.PlayerName = 0x0 // FString (Size: 0x10)
RoundGamePlayerData.PlayerGid = 0x10 // uint64_t (Size: 0x8)
RoundGamePlayerData.PlayerKillerNum = 0x18 // int32_t (Size: 0x4)
RoundGamePlayerData.PlayerDeathNum = 0x1c // int32_t (Size: 0x4)
RoundGamePlayerData.PlayerAssistNum = 0x20 // int32_t (Size: 0x4)
RoundGamePlayerData.bAlive = 0x24 // bool (Size: 0x1)
RoundGamePlayerData.PlayerIcon = 0x28 // FSGPlayerIconInfo (Size: 0x58)
RoundGamePlayerData.PlayerBanner = 0x80 // FSGPlayerBannerInfo (Size: 0x28)
RoundGamePlayerData.PlayerSex = 0xa8 // EECharacterSex (Size: 0x1)
RoundGamePlayerData.PlayerMemIndex = 0xac // int32_t (Size: 0x4)
RoundGamePlayerData.RankedLevel = 0xb0 // uint32_t (Size: 0x4)
RoundGamePlayerData.roomid = 0xb8 // uint64_t (Size: 0x8)
RoundGamePlayerData.Score = 0xc0 // int32_t (Size: 0x4)
RoundGamePlayerData.CurRandomWeaponID = 0xc4 // int32_t (Size: 0x4)
RouteChart.Brush = 0x130 // FSlateBrush (Size: 0x90)
RouteChart.IntervalSize = 0x1c0 // float (Size: 0x4)
RouteChart.PointScale = 0x1c4 // float (Size: 0x4)
RouteChart.bSkipFirstAndLastPoint = 0x1c8 // bool (Size: 0x1)
RouteChart.InterpolatedPointsNumArray = 0x1e0 // TArray<int32_t> (Size: 0x10)
RouteChart.InterpolatedPointsArray = 0x1f0 // TArray<FVector2D> (Size: 0x10)
RouteChart.OriginalPointsArray = 0x200 // TArray<FVector2D> (Size: 0x10)
RunTimeGiveInfo_ClientStart.IsQuickToWeapon = 0x0 // bool (Size: 0x1)
RunTimeGiveInfo_ClientStart.IsTakeupMelee = 0x1 // bool (Size: 0x1)
RunTimeGiveInfo_ClientStart.GiveKey = 0x4 // int32_t (Size: 0x4)
RunTimeGiveInfo_ClientSwitchToWeapon.WeaponPartCount = 0x0 // int32_t (Size: 0x4)
RunTimeGiveInfo_ClientSwitchToWeapon.GiveKey = 0x4 // int32_t (Size: 0x4)
RunTimeGiveInfo_Stop.GiveKey = 0x0 // int32_t (Size: 0x4)
SGInventorySpawnInfo.InventoryClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
SGInventorySpawnInfo.bIsFullWeapon = 0x28 // bool (Size: 0x1)
SGInventorySpawnInfo.LootDropID = 0x30 // uint64_t (Size: 0x8)
SGInventorySpawnInfo.LootDropTableItemID = 0x38 // uint64_t (Size: 0x8)
SGInventorySpawnInfo.ReallyLootDropTableItemID = 0x40 // uint64_t (Size: 0x8)
SGInventorySpawnInfo.Count = 0x48 // uint32_t (Size: 0x4)
SGInventorySpawnInfo.SkinID = 0x4c // uint32_t (Size: 0x4)
SGInventorySpawnInfo.ParentItemID = 0x50 // uint32_t (Size: 0x4)
SGInventorySpawnInfo.SlotIndex = 0x54 // int32_t (Size: 0x4)
SGInventorySpawnInfo.ParentLootDropID = 0x58 // uint64_t (Size: 0x8)
SGInventorySpawnInfo.FormActivityID = 0x70 // uint32_t (Size: 0x4)
SGInventorySpawnInfo.FormActivityPoolID = 0x74 // uint32_t (Size: 0x4)
SGLootRandomItemTableRow.ItemType = 0x8 // EELootRandomItemType (Size: 0x1)
SGLootRandomItemTableRow.ItemId = 0x10 // uint64_t (Size: 0x8)
SGLootRandomItemTableRow.ItemNum = 0x18 // uint8_t (Size: 0x1)
SGLootRandomItemTableRow.SubItemTable = 0x20 // DataTable* (Size: 0x8)
SGLootRandomItemTableRow.Weight = 0x28 // int32_t (Size: 0x4)
SGLootRandomItemTableRow.Percent = 0x2c // float (Size: 0x4)
SGLootRandomItemTableRow.RandTimes = 0x30 // int32_t (Size: 0x4)
SGLootRandomItemTableRow.OperationType = 0x34 // EESGLootRandomItemOperation (Size: 0x1)
SGLootRandomItemTableRow.IsPermanent = 0x35 // bool (Size: 0x1)
SGLootRandomItemTableRow.Describe = 0x38 // FText (Size: 0x18)
SGSceneMoveActorRaw.ActorReference = 0x0 // FMissionActorReference (Size: 0x18)
SGSceneMoveActorRaw.MoveLocation = 0x18 // FVector (Size: 0xc)
SGSupplyStation.SupplyStationGroupConfigID = 0x8a0 // int32_t (Size: 0x4)
SGSupplyStation.TraceConfigID = 0x8a4 // int32_t (Size: 0x4)
SGSupplyStation.bIsOpen = 0x8a8 // bool (Size: 0x1)
SGSupplyStation.FixArmorCoe = 0x8ac // float (Size: 0x4)
SGSupplyStation.SupplyStationItems = 0x8b0 // TArray<FSupplyStationItem> (Size: 0x10)
SGSupplyStation.SupplyStationLimitBuyNumInfoList = 0x8c0 // TArray<FSupplyStationLimitBuyNumInfo> (Size: 0x10)
SGSupplyStation.ItemSkeletalMeshComponents = 0x8d0 // TArray<SkeletalMeshComponent*> (Size: 0x10)
SGSupplyStationBeUsedComponent.OpenAnimationTime = 0x148 // float (Size: 0x4)
SGSupplyStationBeUsedComponent.UserCache = 0x158 // Actor* (Size: 0x8)
SaveQuest.MapTraceTasks = 0x28 // TMap<...> (Size: 0x50)
ScanDeviceResultInfo.ScanningAreaID = 0x0 // int32_t (Size: 0x4)
ScanDeviceResultInfo.Timestamp = 0x8 // FDateTime (Size: 0x8)
ScanDeviceResultInfo.ResultCode = 0x10 // EEScanDeviceScanResultCode (Size: 0x1)
ScanningDeviceAreaVolume.ScanningAreaID = 0x398 // int32_t (Size: 0x4)
ScanningDeviceAreaVolume.InAreaActors = 0x3a0 // TArray<Actor*> (Size: 0x10)
ScavInfoForPathNodeGroup.ScavPawn = 0x0 // SGAICharacter* (Size: 0x8)
ScavInfoForPathNodeGroup.AreaName = 0x8 // FString (Size: 0x10)
ScavInfoForPathNodeGroup.CurrentPathNode = 0x18 // SGAIPathNode* (Size: 0x8)
SecHurtFlowStruct.MapID = 0x0 // int32_t (Size: 0x4)
SecHurtFlowStruct.Weatherid = 0x4 // int32_t (Size: 0x4)
SecHurtFlowStruct.HurtFlowID = 0x8 // int32_t (Size: 0x4)
SecHurtFlowStruct.EnemyOpenID = 0x10 // FString (Size: 0x10)
SecHurtFlowStruct.EnemyRoleID = 0x20 // FString (Size: 0x10)
SecHurtFlowStruct.EnemyRoleType = 0x30 // int32_t (Size: 0x4)
SecHurtFlowStruct.EnemyUserName = 0x38 // FString (Size: 0x10)
SecHurtFlowStruct.HurtTime = 0x48 // int32_t (Size: 0x4)
SecHurtFlowStruct.HurtType = 0x4c // int32_t (Size: 0x4)
SecHurtFlowStruct.HitType = 0x50 // int32_t (Size: 0x4)
SecHurtFlowStruct.DamageStart = 0x54 // int32_t (Size: 0x4)
SecHurtFlowStruct.DamageReduce = 0x58 // int32_t (Size: 0x4)
SecHurtFlowStruct.ArmorDef = 0x5c // int32_t (Size: 0x4)
SecHurtFlowStruct.HPstart = 0x60 // int32_t (Size: 0x4)
SecHurtFlowStruct.HPEnd = 0x64 // int32_t (Size: 0x4)
SecHurtFlowStruct.HelmetHPStart = 0x68 // int32_t (Size: 0x4)
SecHurtFlowStruct.HelmetHPEnd = 0x6c // int32_t (Size: 0x4)
SecHurtFlowStruct.ArmorHPStart = 0x70 // int32_t (Size: 0x4)
SecHurtFlowStruct.ArmorHPEnd = 0x74 // int32_t (Size: 0x4)
SecHurtFlowStruct.FallHeight = 0x78 // int32_t (Size: 0x4)
SecHurtFlowStruct.PlayerKilled = 0x7c // int32_t (Size: 0x4)
SecHurtFlowStruct.IfIsAI = 0x80 // int32_t (Size: 0x4)
SecHurtFlowStruct.DebuffStartList = 0x88 // FString (Size: 0x10)
SecHurtFlowStruct.DebuffEndList = 0x98 // FString (Size: 0x10)
SecHurtFlowStruct.DebuffLevelStartList = 0xa8 // FString (Size: 0x10)
SecHurtFlowStruct.DebuffLevelEndList = 0xb8 // FString (Size: 0x10)
SecurityCamera.TraceConfigID = 0xa18 // int32_t (Size: 0x4)
SecurityCameraMonitor.TraceConfigID = 0x928 // int32_t (Size: 0x4)
SecurityMonitorSpawner.AvailableCameraIDList = 0x310 // TArray<int32_t> (Size: 0x10)
SecurityMonitorSpawner.BatteryEndurance = 0x320 // float (Size: 0x4)
SecurityMonitorSpawner.BatteryRechargeTime = 0x324 // float (Size: 0x4)
SecurityMonitorSpawner.MonitorInventoryClass = 0x328 // ClassProperty (Size: 0x8)
ShortcutItemStruct.ShortcutItemInvList = 0x0 // TArray<SGInventory*> (Size: 0x10)
ShortcutItemStruct.ShortcutItemInv = 0x10 // SGInventory* (Size: 0x8)
ShortcutItemStruct.MyAttachPosition = 0x18 // EEAttachPosition (Size: 0x1)
ShortcutItemStruct.InvAttachPosition = 0x19 // EEAttachPosition (Size: 0x1)
SlotAnnounceTaskQueueControl.AnnounceTaskQueue = 0x0 // TArray<FAnnounceHUDTaskInfo> (Size: 0x10)
SlotAnnounceTaskQueueControl.SlotPlayingAnnounceNowPtr = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
SlotAnnounceTaskQueueControl.CountDownHoldTheSlotPtr = 0x18 // TWeakObjectPtr<UObject> (Size: 0x8)
SoundContext.SourceActor = 0x0 // Actor* (Size: 0x8)
SoundContext.SoundLocation = 0x8 // FVector (Size: 0xc)
SoundContext.IconWidget = 0x18 // SoundWaveWidget* (Size: 0x8)
SoundContext.MatUpper = 0x20 // MaterialInterface* (Size: 0x8)
SoundContext.MatMiddle = 0x28 // MaterialInterface* (Size: 0x8)
SoundContext.MatLower = 0x30 // MaterialInterface* (Size: 0x8)
SoundIndicatorArrowWidget.ArrowForward = 0x2f0 // Image* (Size: 0x8)
SoundIndicatorArrowWidget.ArrowBackward = 0x2f8 // CanvasPanel* (Size: 0x8)
SoundIndicatorArrowWidget.AnimF = 0x300 // WidgetAnimation* (Size: 0x8)
SoundIndicatorArrowWidget.AnimB = 0x308 // WidgetAnimation* (Size: 0x8)
SoundIndicatorWidget.SoundQueueMaxLength = 0x2f0 // int32_t (Size: 0x4)
SoundIndicatorWidget.MaxSoundWidgetDisplayNum = 0x2f4 // int32_t (Size: 0x4)
SoundIndicatorWidget.OnGenerateSoundCalledMaxCount = 0x2f8 // int32_t (Size: 0x4)
SoundIndicatorWidget.SoundWidgetClass = 0x300 // ClassProperty (Size: 0x8)
SoundIndicatorWidget.IndicatorPanel = 0x308 // CanvasPanel* (Size: 0x8)
SoundIndicatorWidget.LeftArrow = 0x310 // SoundIndicatorArrowWidget* (Size: 0x8)
SoundIndicatorWidget.RightArrow = 0x318 // SoundIndicatorArrowWidget* (Size: 0x8)
SoundIndicatorWidget.Backboard = 0x320 // Widget* (Size: 0x8)
SoundIndicatorWidget.ThunderstormPanel = 0x328 // CanvasPanel* (Size: 0x8)
SoundIndicatorWidget.DefaultHeight = 0x330 // float (Size: 0x4)
SoundIndicatorWidget.OpenBagHeight = 0x334 // float (Size: 0x4)
SoundIndicatorWidget.UpDownZThreshold = 0x338 // float (Size: 0x4)
SoundIndicatorWidget.UpDownZThresholdThrowableProjectile = 0x33c // float (Size: 0x4)
SoundIndicatorWidget.UpperAngle = 0x340 // float (Size: 0x4)
SoundIndicatorWidget.LowerAngle = 0x344 // float (Size: 0x4)
SoundIndicatorWidget.IndicatorAppearDuration = 0x348 // float (Size: 0x4)
SoundIndicatorWidget.AngleThresHold = 0x34c // float (Size: 0x4)
SoundIndicatorWidget.HeightCalculateUseAngleDistance = 0x350 // float (Size: 0x4)
SoundIndicatorWidget.TriggerProbabilityFadeInCurve = 0x358 // CurveFloat* (Size: 0x8)
SoundIndicatorWidget.TriggerProbabilityFadeOutCurve = 0x360 // CurveFloat* (Size: 0x8)
SoundIndicatorWidget.InterferenceMagnitudeFadeInCurve = 0x368 // CurveFloat* (Size: 0x8)
SoundIndicatorWidget.InterferenceMagnitudeFadeOutCurve = 0x370 // CurveFloat* (Size: 0x8)
SoundIndicatorWidget.bIsTinnitus = 0x390 // bool (Size: 0x1)
SoundIndicatorWidget.bIsInBag = 0x391 // bool (Size: 0x1)
SoundIndicatorWidget.LeftArrowSource = 0x3bc // FName (Size: 0x8)
SoundIndicatorWidget.RightArrowSource = 0x3c4 // FName (Size: 0x8)
SoundIndicatorWidget.ActiveSoundMap = 0x3d0 // TMap<...> (Size: 0x50)
SoundIndicatorWidget.SoundWaveSoundActorArr = 0x420 // TArray<SoundWaveWidget*> (Size: 0x10)
SoundIndicatorWidget.ActiveSoundMapUpdateFlags = 0x430 // TMap<...> (Size: 0x50)
SoundIndicatorWidget.ViewChar = 0x480 // SGCharacter* (Size: 0x8)
SoundIndicatorWidget.IconWidgetList = 0x488 // TArray<SoundWaveWidget*> (Size: 0x10)
SoundIndicatorWidget.PreviewSoundContext = 0x498 // FSoundContext (Size: 0x88)
SoundIndicatorWidget.VecHalfXY = 0x520 // FVector2D (Size: 0x8)
SoundIndicatorWidget.LeftArrowAnim = 0x528 // WidgetAnimation* (Size: 0x8)
SoundIndicatorWidget.RightArrowAnim = 0x530 // WidgetAnimation* (Size: 0x8)
SoundWaveWidget.UpperArrow = 0x2f0 // Widget* (Size: 0x8)
SoundWaveWidget.LowerArrow = 0x2f8 // Widget* (Size: 0x8)
SoundWaveWidget.RetainerBox = 0x300 // Widget* (Size: 0x8)
SoundWaveWidget.SoundImageSwitcher = 0x308 // VisibilityWidgetSwitcher* (Size: 0x8)
SoundWaveWidget.InterferenceBox = 0x310 // RetainerBox* (Size: 0x8)
SoundWaveWidget.ThunderStormEffect = 0x318 // MaterialInstance* (Size: 0x8)
SoundWaveWidget.SourceActor = 0x320 // Actor* (Size: 0x8)
SoundWaveWidget.StaffGuageWidth = 0x328 // float (Size: 0x4)
SoundWaveWidget.AngleThresHold = 0x32c // float (Size: 0x4)
SoundWaveWidget.ArrowMoveFactor = 0x330 // float (Size: 0x4)
SpawnArea.PathNodes = 0x20 // TArray<SGAIPathNode*> (Size: 0x10)
SpawnArea.GuardPoints = 0x30 // TArray<Actor*> (Size: 0x10)
SpawnArea.MapTargetActors = 0x40 // TArray<TSoftObjectPtr<UObject>> (Size: 0x10)
SpawnArea.BattleVolume = 0x50 // Volume* (Size: 0x8)
SpawnArea.BattleExclusiveVolume = 0x58 // TArray<Volume*> (Size: 0x10)
SpawnArea.ExclusiveAreas = 0x68 // TArray<FString> (Size: 0x10)
SpawnArea.MapEffectMarkActor = 0x78 // Actor* (Size: 0x8)
SpawnArea.PlayTriggerVolume = 0x80 // SGAITriggerVolume* (Size: 0x8)
SpawnArea.BattleTestStartPoints = 0x88 // TArray<Actor*> (Size: 0x10)
SpawnArea.PatrolNoEntryVolume = 0x98 // TArray<Volume*> (Size: 0x10)
SpawnArea.bEnableTestData = 0xa8 // bool (Size: 0x1)
SpawnArea.AreaData = 0xb0 // FAISpawnAreaInfoTableRow (Size: 0x68)
SpawnAreaBase.SpawnPoints = 0x0 // TArray<Actor*> (Size: 0x10)
SpawnAreaBase.SpawnPointInfos = 0x10 // TArray<SpawnPointInfo*> (Size: 0x10)
StairsBlockingVolume.bOverrideWalkableSlopeOnInstance = 0x348 // uint8_t (Size: 0x1)
StairsBlockingVolume.WalkableSlopeOverride = 0x34c // FWalkableSlopeOverride (Size: 0x10)
StartFireInformationStatistics.Timestamp = 0x0 // int64_t (Size: 0x8)
StartFireInformationStatistics.WeaponId = 0x8 // int64_t (Size: 0x8)
StartFireInformationStatistics.WeaponName = 0x10 // FString (Size: 0x10)
StartFireInformationStatistics.BulletID = 0x20 // int64_t (Size: 0x8)
StartFireInformationStatistics.BulletName = 0x28 // FString (Size: 0x10)
StartFireInformationStatistics.BulletCount = 0x38 // int32_t (Size: 0x4)
StartFireInformationStatistics.WeaponType = 0x40 // FString (Size: 0x10)
StartFireInformationStatistics.bADS = 0x50 // bool (Size: 0x1)
StartFireInformationStatistics.bHit = 0x51 // bool (Size: 0x1)
StartFireInformationStatistics.bHitHead = 0x52 // bool (Size: 0x1)
StartFireInformationStatistics.HitDistance = 0x54 // float (Size: 0x4)
StartFireInformationStatistics.VerticalRecoil = 0x58 // float (Size: 0x4)
StartFireInformationStatistics.HorizontalRecoil = 0x5c // float (Size: 0x4)
StartFireInformationStatistics.SightName = 0x60 // FString (Size: 0x10)
StartFireInformationStatistics.EngageDistance = 0x70 // float (Size: 0x4)
StartFireInformationStatistics.WaistShotAccuracy = 0x74 // float (Size: 0x4)
StartFireInformationStatistics.EffectiveDistance = 0x78 // float (Size: 0x4)
StartFireInformationStatistics.TeamType = 0x7c // int32_t (Size: 0x4)
StartFireInformationStatistics.HitCharacterTeamType = 0x80 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitCharacterPlayerID = 0x88 // int64_t (Size: 0x8)
StartFireInformationStatistics.HitEndurance = 0x90 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitGroup = 0x94 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitEnduranceDamage = 0x98 // float (Size: 0x4)
StartFireInformationStatistics.HitSubEndurance = 0x9c // int32_t (Size: 0x4)
StartFireInformationStatistics.HitSubGroup = 0xa0 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitSubEnduranceDamage = 0xa4 // float (Size: 0x4)
StartFireInformationStatistics.ArmorId = 0xa8 // int64_t (Size: 0x8)
StartFireInformationStatistics.ArmorLevel = 0xb0 // int32_t (Size: 0x4)
StartFireInformationStatistics.CauseArmorConsume = 0xb4 // float (Size: 0x4)
StartFireInformationStatistics.CauseArmorReduceDamage = 0xb8 // float (Size: 0x4)
StartFireInformationStatistics.ResultDamage = 0xbc // float (Size: 0x4)
StartFireInformationStatistics.WeaponInventory = 0xc0 // SGInventory* (Size: 0x8)
StartFireInformationStatistics.ChangeWeaponOrFire = 0xc8 // uint32_t (Size: 0x4)
StartFireInformationStatistics.HitCharacterType = 0xcc // int32_t (Size: 0x4)
StartFireInformationStatistics.HitAIID = 0xd0 // int64_t (Size: 0x8)
StartFireInformationStatistics.MoaX = 0xd8 // float (Size: 0x4)
StartFireInformationStatistics.MoaY = 0xdc // float (Size: 0x4)
StartFireInformationStatistics.ShootingMode = 0xe0 // int32_t (Size: 0x4)
StartFireInformationStatistics.MapID = 0xe4 // int32_t (Size: 0x4)
StartFireInformationStatistics.Weatherid = 0xe8 // int32_t (Size: 0x4)
StartFireInformationStatistics.AtackFlowID = 0xec // int32_t (Size: 0x4)
StartFireInformationStatistics.TargetUserName = 0xf0 // FString (Size: 0x10)
StartFireInformationStatistics.GunType = 0x100 // int32_t (Size: 0x4)
StartFireInformationStatistics.GunPartslist = 0x108 // FString (Size: 0x10)
StartFireInformationStatistics.BulletSpeed = 0x118 // int32_t (Size: 0x4)
StartFireInformationStatistics.MagazineMax = 0x11c // int32_t (Size: 0x4)
StartFireInformationStatistics.MagazineLeft = 0x120 // int32_t (Size: 0x4)
StartFireInformationStatistics.ShotFrequency = 0x124 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletDamage = 0x128 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletDamageReduce = 0x12c // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletDown = 0x130 // int32_t (Size: 0x4)
StartFireInformationStatistics.ReloadTime = 0x134 // int32_t (Size: 0x4)
StartFireInformationStatistics.PlayerPose = 0x138 // int32_t (Size: 0x4)
StartFireInformationStatistics.ShotPose = 0x13c // int32_t (Size: 0x4)
StartFireInformationStatistics.FireType = 0x140 // int32_t (Size: 0x4)
StartFireInformationStatistics.Sideways = 0x144 // int32_t (Size: 0x4)
StartFireInformationStatistics.ShotTime = 0x148 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitTime = 0x14c // int32_t (Size: 0x4)
StartFireInformationStatistics.PlayerPositionX = 0x150 // int32_t (Size: 0x4)
StartFireInformationStatistics.PlayerPositionY = 0x154 // int32_t (Size: 0x4)
StartFireInformationStatistics.PlayerPositionZ = 0x158 // int32_t (Size: 0x4)
StartFireInformationStatistics.GunPositionX = 0x15c // int32_t (Size: 0x4)
StartFireInformationStatistics.GunPositionY = 0x160 // int32_t (Size: 0x4)
StartFireInformationStatistics.GunPositionZ = 0x164 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletsBornPositionX = 0x168 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletsBornPositionY = 0x16c // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletsBornPositionZ = 0x170 // int32_t (Size: 0x4)
StartFireInformationStatistics.LastHitTime = 0x174 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletFlyDistance = 0x178 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletFlyTime = 0x17c // int32_t (Size: 0x4)
StartFireInformationStatistics.HitPositionX = 0x180 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitPositionY = 0x184 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitPositionZ = 0x188 // int32_t (Size: 0x4)
StartFireInformationStatistics.HitPart = 0x18c // int32_t (Size: 0x4)
StartFireInformationStatistics.RecoilMoveX = 0x190 // int32_t (Size: 0x4)
StartFireInformationStatistics.RecoilMoveY = 0x194 // int32_t (Size: 0x4)
StartFireInformationStatistics.WeaponAimFOV = 0x198 // int32_t (Size: 0x4)
StartFireInformationStatistics.BulletDamageBuff = 0x19c // int32_t (Size: 0x4)
StartFireInformationStatistics.HitSubHeadPart = 0x1a0 // int32_t (Size: 0x4)
StartFireInformationStatistics.bPenetrateArmor = 0x1a4 // bool (Size: 0x1)
StartFireInformationStatistics.HitMovableArmorID = 0x1a8 // int64_t (Size: 0x8)
StartFireInformationStatistics.MovableArmorConsume = 0x1b0 // float (Size: 0x4)
StartFireInformationStatistics.MovableArmorBlockDamage = 0x1b4 // float (Size: 0x4)
StartFireInformationStatistics.FireNetAvgLag = 0x1b8 // float (Size: 0x4)
StartFireInformationStatistics.FireNetLossPercentage = 0x1bc // float (Size: 0x4)
StartFireInformationStatistics.FireNetAvgLossPercentage = 0x1c0 // float (Size: 0x4)
StartFireInformationStatistics.CauserMaxLocDelta = 0x1c4 // float (Size: 0x4)
StartFireInformationStatistics.HitNetAvgLag = 0x1c8 // float (Size: 0x4)
StartFireInformationStatistics.HitNetLossPercentage = 0x1cc // float (Size: 0x4)
StartFireInformationStatistics.HitNetAvgLossPercentage = 0x1d0 // float (Size: 0x4)
StartFireInformationStatistics.TakerMaxLocDelta = 0x1d4 // float (Size: 0x4)
StartFireInformationStatistics.TargetVestArmorID = 0x1d8 // uint32_t (Size: 0x4)
StartFireInformationStatistics.TargetHelmetArmorID = 0x1dc // uint32_t (Size: 0x4)
StartFireInformationStatistics.TargetFaceShieldID = 0x1e0 // uint32_t (Size: 0x4)
StartFireInformationStatistics.TargetThighArmorID = 0x1e4 // uint32_t (Size: 0x4)
StartFireInformationStatistics.QuietStep = 0x1e8 // int32_t (Size: 0x4)
StartFireInformationStatistics.ContinuousFireCount = 0x1ec // int32_t (Size: 0x4)
StartFireInformationStatistics.ShotTargetDistance = 0x1f0 // float (Size: 0x4)
StartFireInformationStatistics.TimeSeconds = 0x1f4 // int32_t (Size: 0x4)
StartFireInformationStatistics.ShotTargetGID = 0x1f8 // uint64_t (Size: 0x8)
StartFireInformationStatistics.TimeFromLastThrow = 0x200 // int32_t (Size: 0x4)
StartFireInformationStatistics.DamageTakerMoveReceivedTimeDelta = 0x204 // float (Size: 0x4)
StartFireInformationStatistics.HitBoneName = 0x208 // FString (Size: 0x10)
StartFireInformationStatistics.DamageCauserLocDelta = 0x218 // float (Size: 0x4)
StartFireInformationStatistics.DamageTakerLocDelta = 0x21c // float (Size: 0x4)
StartFireInformationStatistics.HasValidate = 0x220 // int32_t (Size: 0x4)
StartFireInformationStatistics.DamageTakerIsGamePlayer = 0x224 // int32_t (Size: 0x4)
StartFireInformationStatistics.CauserOutLossPercentage = 0x230 // float (Size: 0x4)
StartFireInformationStatistics.CauserOutAvgLossPercentage = 0x234 // float (Size: 0x4)
StartFireInformationStatistics.CauserOutLossPercentageWhenHit = 0x238 // float (Size: 0x4)
StartFireInformationStatistics.CauserOutAvgLossPercentageWhenHit = 0x23c // float (Size: 0x4)
StartFireInformationStatistics.TakerNetAvgLag = 0x240 // float (Size: 0x4)
StartFireInformationStatistics.TakerInLossPercentage = 0x244 // float (Size: 0x4)
StartFireInformationStatistics.TakerInAvgLossPercentage = 0x248 // float (Size: 0x4)
SubContextGroup.ContextPriority = 0x0 // EEActionPriority (Size: 0x1)
SubContextGroup.SubContext = 0x8 // TArray<EEActionContext> (Size: 0x10)
SupplyStationItem.ItemId = 0x0 // uint32_t (Size: 0x4)
SupplyStationItem.MaxBuyNum = 0x4 // int32_t (Size: 0x4)
SupplyStationItem.CurrentNum = 0x8 // int32_t (Size: 0x4)
SupplyStationItem.UniqueID = 0xc // int32_t (Size: 0x4)
SupplyStationItem.Price = 0x10 // int32_t (Size: 0x4)
SupplyStationItem.TypeBelong = 0x14 // int32_t (Size: 0x4)
SupplyStationItem.PlayerBuyNumLimit = 0x18 // int32_t (Size: 0x4)
SupplyStationLimitBuyNumInfo.PlayerState = 0x0 // PlayerState* (Size: 0x8)
SupplyStationLimitBuyNumInfo.SingleBuyNumInfoList = 0x8 // TArray<FSupplyStationLimitBuyNumInfo_Single> (Size: 0x10)
SupplyStationLimitBuyNumInfo_Single.ItemId = 0x0 // uint32_t (Size: 0x4)
SupplyStationLimitBuyNumInfo_Single.UniqueID = 0x4 // int32_t (Size: 0x4)
SupplyStationLimitBuyNumInfo_Single.AlreadyBuyNum = 0x8 // int32_t (Size: 0x4)
SupplyStationSpanwer.SupplyStationClass = 0x310 // ClassProperty (Size: 0x8)
SupplyStationSpanwer.SupplyStationConfigID = 0x318 // int32_t (Size: 0x4)
SupplyStationSpanwer.bNeedOverrideDSConfig = 0x31c // bool (Size: 0x1)
SystemPopMsgTableRow.MsgID = 0x8 // uint32_t (Size: 0x4)
SystemPopMsgTableRow.MsgText = 0x10 // FText (Size: 0x18)
TaskCreateData.TaskId = 0x0 // int32_t (Size: 0x4)
TaskCreateData.QuestArr = 0x8 // TArray<FQuestCreateData> (Size: 0x10)
TaskCreateData.CompleteInOneBattle = 0x18 // bool (Size: 0x1)
TaskCreateData.PrevType = 0x24 // int32_t (Size: 0x4)
TaskCreateData.IsAct = 0x28 // bool (Size: 0x1)
TeamEscapeInfo.TeamInfo = 0x0 // SGTeamInfo* (Size: 0x8)
TeamEscapeInfo.EscapePointIDs = 0x8 // TArray<int32_t> (Size: 0x10)
TeamEscapeInfo.FinishDistribute = 0x18 // bool (Size: 0x1)
TeamEscapeInfo.PresetIndex = 0x1c // int32_t (Size: 0x4)
TeamEscapeInfo.DelayedEvacuation = 0x20 // FUADelayedEvacuationStruct (Size: 0x20)
TeamPlayerBaseInfo.GID = 0x0 // uint64_t (Size: 0x8)
TeamPlayerBaseInfo.SquadIndex = 0x8 // int32_t (Size: 0x4)
TeamPlayerBaseInfo.PlayerState = 0x10 // SGPlayerState* (Size: 0x8)
TeamPlayerBaseInfo.CharacterSex = 0x18 // EECharacterSex (Size: 0x1)
TeamPlayerBaseInfo.TitleID = 0x1c // int32_t (Size: 0x4)
TeamPlayerBaseInfo.TitleStarNum = 0x20 // int32_t (Size: 0x4)
TeamPlayerBaseInfo.TitleRank = 0x24 // int32_t (Size: 0x4)
TeamPlayerBaseInfo.TitleHighestRankedLevel = 0x28 // int32_t (Size: 0x4)
TeamPlayerInfo.Sign_EscapePointPos = 0x0 // FVector2D (Size: 0x8)
TeamPlayerInfo.Sign_EscapePointID = 0x8 // int32_t (Size: 0x4)
TeamPlayerInfo.Sign_QuestTraceInfo = 0xc // FTraceableActorInfo (Size: 0x58)
TeamPlayerInfo.Sign_PlayerPos = 0x64 // FVector2D (Size: 0x8)
TeamPlayerInfo.UpdateTimeStamp = 0x70 // int64_t (Size: 0x8)
TeammemberIdentityInfo.PlayerName = 0x0 // FString (Size: 0x10)
TeammemberIdentityInfo.PlayerLevel = 0x10 // int32_t (Size: 0x4)
TeammemberIdentityInfo.HeadBoxID = 0x14 // int32_t (Size: 0x4)
TeammemberIdentityInfo.HeadPicID = 0x18 // int32_t (Size: 0x4)
TeammemberPlayerBaseInfo.IndexInTeam = 0x0 // int32_t (Size: 0x4)
TeammemberPlayerBaseInfo.GID = 0x8 // uint64_t (Size: 0x8)
TeammemberPlayerBaseInfo.SquadIndex = 0x10 // int32_t (Size: 0x4)
TeammemberPlayerBaseInfo.Controller = 0x18 // Controller* (Size: 0x8)
TeammemberPlayerBaseInfo.Character = 0x20 // SGCharacter* (Size: 0x8)
TeammemberPlayerBaseInfo.CharacterSex = 0x28 // EECharacterSex (Size: 0x1)
TeammemberPlayerBaseInfo.TitleInfo = 0x2c // FTeammemberTitleInfo (Size: 0x10)
TeammemberPlayerBaseInfo.StatusInfo = 0x3c // FTeammemberStatusInfo (Size: 0x18)
TeammemberPlayerBaseInfo.IdentityInfo = 0x58 // FTeammemberIdentityInfo (Size: 0x20)
TeammemberPlayerBaseInfo.bIsAI = 0x78 // bool (Size: 0x1)
TeammemberPlayerBaseInfo.bRemoved = 0x79 // bool (Size: 0x1)
TeammemberStatusInfo.Condition = 0x0 // EESGPlayerCondition (Size: 0x1)
TeammemberStatusInfo.DeathLocation = 0x4 // FVector2D (Size: 0x8)
TeammemberStatusInfo.TransientLocation = 0xc // FVector (Size: 0xc)
TeammemberTitleInfo.TitleID = 0x0 // int32_t (Size: 0x4)
TeammemberTitleInfo.TitleStarNum = 0x4 // int32_t (Size: 0x4)
TeammemberTitleInfo.TitleRank = 0x8 // int32_t (Size: 0x4)
TeammemberTitleInfo.TitleHighestRankedLevel = 0xc // int32_t (Size: 0x4)
ThrowableDebuffStruct.DizzyTime = 0x0 // float (Size: 0x4)
ThrowableDebuffStruct.BlindTime = 0x4 // float (Size: 0x4)
ThrowableDebuffStruct.SlowDownTime = 0x8 // float (Size: 0x4)
ThrowableDebuffStruct.TinnitusTime = 0xc // float (Size: 0x4)
ThrowableStartFireInformationStatistics.Timestamp = 0x0 // int64_t (Size: 0x8)
ThrowableStartFireInformationStatistics.WeaponId = 0x8 // int64_t (Size: 0x8)
ThrowableStartFireInformationStatistics.WeaponName = 0x10 // FString (Size: 0x10)
ThrowableStartFireInformationStatistics.WeaponType = 0x20 // FString (Size: 0x10)
ThrowableStartFireInformationStatistics.bHit = 0x30 // bool (Size: 0x1)
ThrowableStartFireInformationStatistics.HitCharacterArray = 0x38 // TArray<FString> (Size: 0x10)
ThrowableStartFireInformationStatistics.HitNumber = 0x48 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitPmcNumber = 0x4c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitScavNumber = 0x50 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ThrowDistance = 0x54 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.TeamType = 0x58 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterTeamType = 0x5c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterPlayerID = 0x60 // int64_t (Size: 0x8)
ThrowableStartFireInformationStatistics.HitEndurance = 0x68 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitSubEndurance = 0x6c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ArmorId = 0x70 // int64_t (Size: 0x8)
ThrowableStartFireInformationStatistics.ArmorLevel = 0x78 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.CauseArmorConsume = 0x7c // float (Size: 0x4)
ThrowableStartFireInformationStatistics.CauseArmorReduceDamage = 0x80 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.ResultDamage = 0x84 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.WeaponInventory = 0x88 // SGInventory* (Size: 0x8)
ThrowableStartFireInformationStatistics.HitCharacterType = 0x90 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitAIID = 0x98 // int64_t (Size: 0x8)
ThrowableStartFireInformationStatistics.ShotTime = 0xa0 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitTime = 0xa4 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.PlayerPositionX = 0xa8 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.PlayerPositionY = 0xac // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.PlayerPositionZ = 0xb0 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ThrowPositionX = 0xb4 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ThrowPositionY = 0xb8 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ThrowPositionZ = 0xbc // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ProjectileBornPositionX = 0xc0 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ProjectileBornPositionY = 0xc4 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ProjectileBornPositionZ = 0xc8 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitPositionX = 0xcc // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitPositionY = 0xd0 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitPositionZ = 0xd4 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterPositionX = 0xd8 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterPositionY = 0xdc // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterPositionZ = 0xe0 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HitCharacterTeammateNumber = 0xe4 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ThrowCharacterID = 0xe8 // FString (Size: 0x10)
ThrowableStartFireInformationStatistics.HegPenetrateObstacle = 0xf8 // bool (Size: 0x1)
ThrowableStartFireInformationStatistics.HegPenetrateObstacleNum = 0xfc // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.HegPenetrateObstacleDamage = 0x100 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.HegNumCauseTinnitus = 0x104 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragSumBodyDamage = 0x108 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.FragSumArmorDamage = 0x10c // float (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitNumber = 0x110 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitHeadNumber = 0x114 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitChestNumber = 0x118 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitStomachNumber = 0x11c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitLeftArmNumber = 0x120 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitRightArmNumber = 0x124 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitLeftLegNumber = 0x128 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitRightLegNumber = 0x12c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.FragHitArmorLevel = 0x130 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.MolotovTime = 0x134 // float (Size: 0x4)
ThrowableStartFireInformationStatistics.MolotovHitNumber = 0x138 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.ActivityUse = 0x13c // bool (Size: 0x1)
ThrowableStartFireInformationStatistics.OwnerTeamIndex = 0x140 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.TeamFlash = 0x144 // bool (Size: 0x1)
ThrowableStartFireInformationStatistics.MapID = 0x148 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.TimeSeconds = 0x14c // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.TimeFromLastThrow = 0x150 // int32_t (Size: 0x4)
ThrowableStartFireInformationStatistics.InfectedCharacterTeamTypeArray = 0x158 // TArray<FString> (Size: 0x10)
ThrowableStartFireInformationStatistics.InfectedCharacterArray = 0x168 // TArray<FString> (Size: 0x10)
ThrowableStartFireInformationStatistics.InfectedCharacterTeamType = 0x178 // FString (Size: 0x10)
ThrowableStartFireInformationStatistics.InfectedCharacter = 0x188 // FString (Size: 0x10)
TimeOfDay.Hour = 0x0 // int32_t (Size: 0x4)
TimeOfDay.Minute = 0x4 // int32_t (Size: 0x4)
TimeOfDay.Second = 0x8 // int32_t (Size: 0x4)
TraceInfoHistoryBlackboard.ActiveTraceDataList = 0x0 // TArray<FNewTraceableActorInfo> (Size: 0x10)
TraceInfoHistoryBlackboard.PassivityTraceDataList = 0x10 // TArray<FNewTraceableActorInfo> (Size: 0x10)
TraceInfoHistoryBlackboard.MousePinTraceDataList = 0x20 // TArray<FMousePinTraceInfoList> (Size: 0x10)
TraceableActorInfo.Actor = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
TraceableActorInfo.ActorOuter = 0x8 // TWeakObjectPtr<UObject> (Size: 0x8)
TraceableActorInfo.bActorDestroyed = 0x10 // bool (Size: 0x1)
TraceableActorInfo.bOwnerAlive = 0x11 // bool (Size: 0x1)
TraceableActorInfo.bHasOwner = 0x12 // bool (Size: 0x1)
TraceableActorInfo.WorldLocation = 0x14 // FVector (Size: 0xc)
TraceableActorInfo.Handle = 0x20 // int32_t (Size: 0x4)
TraceableActorInfo.OperatorType = 0x24 // EETraceMarkOperatorType (Size: 0x1)
TraceableActorInfo.MarkType = 0x25 // EETraceableMarkType (Size: 0x1)
TraceableActorInfo.ConfigID = 0x28 // int32_t (Size: 0x4)
TraceableActorInfo.ScanningInterval = 0x2c // float (Size: 0x4)
TraceableActorInfo.LastUpdateServerTime = 0x30 // float (Size: 0x4)
TraceableActorInfo.OwnerQuest = 0x34 // TWeakObjectPtr<UObject> (Size: 0x8)
TraceableActorInfo.TaskId = 0x3c // int32_t (Size: 0x4)
TraceableActorInfo.TargetId = 0x40 // int32_t (Size: 0x4)
TraceableActorInfo.bNeedTrace = 0x44 // bool (Size: 0x1)
TraceableActorInfo.Extend = 0x48 // FVector (Size: 0xc)
TraceableActorInfo.EscapeId = 0x54 // int32_t (Size: 0x4)
TraceableActorList.TraceableActorInfos = 0x0 // TArray<FTraceableActorInfo> (Size: 0x10)
TrackPlayerInfo.PlayerStateTraceComponent = 0x0 // UAPlayerStateTraceComponent* (Size: 0x8)
TrackPlayerInfo.ChaseActivityComp = 0x8 // UAPlayerStateChaseActivityComp* (Size: 0x8)
TrackPlayerInfo.ChaseActivityAvatarInfo = 0x10 // FChaseActivityAvatarInfo (Size: 0x10)
TreeItemData.Index = 0x28 // FString (Size: 0x10)
TreeItemData.Child = 0x38 // TArray<TreeItemData*> (Size: 0x10)
TreeItemData.Parent = 0x48 // TreeItemData* (Size: 0x8)
TriggerSpawnByAreaConfig.SpawnNum = 0x0 // int32_t (Size: 0x4)
TriggerSpawnByAreaConfig.AreaParams = 0x8 // TArray<FTriggerSpawnByAreaParams> (Size: 0x10)
TriggerSpawnByAreaParams.SquadID = 0x0 // int32_t (Size: 0x4)
TriggerSpawnByAreaParams.SpawnAreas = 0x8 // TArray<FString> (Size: 0x10)
TriggerSpawnByAreaParams.Weight = 0x18 // int32_t (Size: 0x4)
TriggerSpawnByEventConfig.SpawnNum = 0x0 // int32_t (Size: 0x4)
TriggerSpawnByEventConfig.EventParams = 0x8 // TArray<FTriggerSpawnByEventParams> (Size: 0x10)
TriggerSpawnByEventParams.EventStrs = 0x0 // TArray<FString> (Size: 0x10)
TriggerSpawnByEventParams.Weight = 0x10 // int32_t (Size: 0x4)
TriggerSpawnByVolumeConfig.SpawnNum = 0x0 // int32_t (Size: 0x4)
TriggerSpawnByVolumeConfig.VolumeParams = 0x8 // TArray<FTriggerSpawnByVolumeParams> (Size: 0x10)
TriggerSpawnByVolumeParams.VolumeIDs = 0x0 // TArray<int32_t> (Size: 0x10)
TriggerSpawnByVolumeParams.Weight = 0x10 // int32_t (Size: 0x4)
TutorialCaptainTipRow.HUDTableID = 0x8 // int64_t (Size: 0x8)
TutorialCaptainTipRow.VoiceRowName = 0x10 // FName (Size: 0x8)
TutorialCaptainTipRow.BodyMontage = 0x18 // AnimMontage* (Size: 0x8)
TutorialCaptainTipRow.MontageSectionName = 0x20 // FName (Size: 0x8)
TutorialCaptainTipRow.FacialMontage = 0x28 // FString (Size: 0x10)
TutorialCheckpointSettings.PlayerStart = 0x0 // SGPlayerStart* (Size: 0x8)
TutorialCheckpointSettings.bResetCaptainRotation = 0x8 // bool (Size: 0x1)
UAAIEventSwither.eventId = 0x40 // EENPCAISceneEventID (Size: 0x1)
UAAIEventSwither.SceneEventClass = 0x48 // ClassProperty (Size: 0x8)
UAAIEventSwither.Location = 0x50 // FVector (Size: 0xc)
UAAIEventSwither.ValidTime = 0x5c // float (Size: 0x4)
UAAIEventSwither.ValidScope = 0x60 // float (Size: 0x4)
UAAIEventSwither.CoverRange = 0x64 // float (Size: 0x4)
UAAISpawnBossStuff.BossArray = 0x1c0 // TArray<SGAICharacter*> (Size: 0x10)
UAAISpawnBossStuff.FollowerArray = 0x1d0 // TArray<SGAICharacter*> (Size: 0x10)
UAAISpawnBossStuff.BossSpawnPointInfo = 0x1e0 // TMap<...> (Size: 0x50)
UAAISpawnBossStuff.FreePathPointsDic = 0x240 // TMap<...> (Size: 0x50)
UAAISpawnBossStuff.PathPointGroupIDDic = 0x290 // TMap<...> (Size: 0x50)
UAAISpawnBossStuff.BattleTestStartPoints = 0x2e0 // TArray<Actor*> (Size: 0x10)
UAAISpawnBossStuff.ZoneGroupInfo = 0x2f0 // NPCAIZoneGroupInfo* (Size: 0x8)
UAAISpawnBossStuff.Inited = 0x2f8 // bool (Size: 0x1)
UAAISpawnBossStuff.CurrentAreaName = 0x300 // FString (Size: 0x10)
UAAISpawnBossStuff.CanSpawn = 0x310 // bool (Size: 0x1)
UAAISpawnBossStuff.MapID = 0x314 // int32_t (Size: 0x4)
UAAISpawnBossStuff.InBattleTest = 0x318 // bool (Size: 0x1)
UAAISpawnBossStuff.SpawnControllerData = 0x320 // FAISpawnBossSpawnControllerTableRow (Size: 0x88)
UAAISpawnConfigNode.SpawnArea = 0x310 // TMap<...> (Size: 0x50)
UAAISpawnController.ScavGroupClass = 0x478 // ClassProperty (Size: 0x8)
UAAISpawnController.BossGroupClass = 0x480 // ClassProperty (Size: 0x8)
UAAISpawnController.PMCGroupClass = 0x488 // ClassProperty (Size: 0x8)
UAAISpawnController.PlayerScavAIGroupClass = 0x490 // ClassProperty (Size: 0x8)
UAAISpawnController.SpawnArea = 0x498 // TMap<...> (Size: 0x50)
UAAISpawnController.SpawnVolume = 0x4e8 // TMap<...> (Size: 0x50)
UAAISpawnController.ScavSquadArray = 0x540 // TArray<UAAISpawnScavStuff*> (Size: 0x10)
UAAISpawnController.BossSquadArray = 0x550 // TArray<UAAISpawnBossStuff*> (Size: 0x10)
UAAISpawnController.PMCSquadArray = 0x560 // TArray<UAAISpawnPMCStuff*> (Size: 0x10)
UAAISpawnController.PMCTeammateSquadArray = 0x570 // TArray<UAAISpawnPMCStuff*> (Size: 0x10)
UAAISpawnController.PlayerScavAISquadArray = 0x580 // TArray<UAAISpawnPlayerScavAIStuff*> (Size: 0x10)
UAAISpawnController.PMCAIEquipmentLimit = 0x590 // TArray<FPMCAIEquipmentLimit> (Size: 0x10)
UAAISpawnController.PMCAISpawnPoints = 0x5a0 // TArray<FPlayerStartGroup> (Size: 0x10)
UAAISpawnController.PlayerScavAISpawnPoints = 0x5b0 // TArray<FPlayerStartGroup> (Size: 0x10)
UAAISpawnController.PendingSpawnStuffs = 0x5c0 // TArray<UAAISpawnStuff*> (Size: 0x10)
UAAISpawnController.PendingPlayerTeam = 0x5d0 // TArray<SGTeamInfo*> (Size: 0x10)
UAAISpawnController.ScavTableData = 0x630 // TArray<FAISpawnScavSpawnControllerTableRow> (Size: 0x10)
UAAISpawnController.BossTableData = 0x640 // TArray<FAISpawnBossSpawnControllerTableRow> (Size: 0x10)
UAAISpawnController.PMCConfigForTest = 0x650 // FAISpawnPMCConfigTableRow (Size: 0x130)
UAAISpawnController.PMCConfig = 0x780 // FAISpawnPMCConfigTableRow (Size: 0x130)
UAAISpawnController.PlayerScavConfig = 0x8b0 // FAISpawnPlayerScavConfigTableRow (Size: 0x80)
UAAISpawnController.ScavAIDynamicLimitConfig = 0x930 // FScavAIDynamicLimitTableRow (Size: 0x48)
UAAISpawnController.CoolDown_PMCAI2 = 0x980 // TMap<...> (Size: 0x50)
UAAISpawnController.CoolDownDisSquared_PMCAI2 = 0x9d0 // int32_t (Size: 0x4)
UAAISpawnController.ScavAIDynamicLimitInterval = 0xa38 // float (Size: 0x4)
UAAISpawnController.TrySpawnBossWaitTime = 0xa90 // float (Size: 0x4)
UAAISpawnController.TrySpawnBossInterval = 0xa94 // float (Size: 0x4)
UAAISpawnManagerComponent.ValidUpdateInterval = 0x388 // double (Size: 0x8)
UAAISpawnManagerComponent.MinValidUpdateInterval = 0x390 // double (Size: 0x8)
UAAISpawnManagerComponent.InRoomHeight = 0x398 // float (Size: 0x4)
UAAISpawnManagerComponent.MinAvailableDurationBeforeSpawn = 0x3a0 // double (Size: 0x8)
UAAISpawnManagerComponent.MyUAAISpawnController = 0x3b8 // UAAISpawnController* (Size: 0x8)
UAAISpawnManagerComponent.SetAIActive_CDList = 0x3c0 // TMap<...> (Size: 0x50)
UAAISpawnManagerComponent.SetAIActive_TeamCDList = 0x410 // TMap<...> (Size: 0x50)
UAAISpawnManagerComponent.SetAIActive_CD = 0x460 // float (Size: 0x4)
UAAISpawnManagerComponent.GenerateSubPoint = 0x464 // bool (Size: 0x1)
UAAISpawnManagerComponent.SubPointCircleCount = 0x468 // int32_t (Size: 0x4)
UAAISpawnManagerComponent.SubPointDistanceBetween = 0x46c // float (Size: 0x4)
UAAISpawnPMCStuff.AIPortraitPool = 0x1c8 // AIPortraitBase* (Size: 0x8)
UAAISpawnPMCStuff.Temp_Sps = 0x1d8 // TArray<Actor*> (Size: 0x10)
UAAISpawnPMCStuff.PMCAILevelPool = 0x200 // TArray<int32_t> (Size: 0x10)
UAAISpawnPMCStuff.PMCAILevelPool_Base = 0x210 // TArray<int32_t> (Size: 0x10)
UAAISpawnPMCStuff.AISpawnGroupTable = 0x220 // DataTable* (Size: 0x8)
UAAISpawnPMCStuff.WakeUpWaitTime_Plan2 = 0x228 // float (Size: 0x4)
UAAISpawnPMCStuff.TimeOutCheckTime_Plan2 = 0x22c // float (Size: 0x4)
UAAISpawnPMCStuff.Player_Plan2 = 0x230 // Pawn* (Size: 0x8)
UAAISpawnPMCStuff.Volume_Plan2 = 0x238 // Actor* (Size: 0x8)
UAAISpawnPMCStuff.MinDistanceToPlayer = 0x24c // float (Size: 0x4)
UAAISpawnPMCStuff.TeamInfo = 0x250 // SGTeamInfo* (Size: 0x8)
UAAISpawnScavStuff.CanSpawn = 0x1d4 // bool (Size: 0x1)
UAAISpawnScavStuff.BattleTestStartPoints = 0x1d8 // TArray<Actor*> (Size: 0x10)
UAAISpawnScavStuff.ScavPathInfo = 0x1f0 // TArray<FScavInfoForPathNodeGroup> (Size: 0x10)
UAAISpawnScavStuff.PathNodesArray = 0x200 // TArray<SGAIPathNode*> (Size: 0x10)
UAAISpawnScavStuff.SpawnPointsArray = 0x210 // TArray<SGAIPathNode*> (Size: 0x10)
UAAISpawnScavStuff.CorePathNodeArray = 0x220 // TArray<SGAIPathNode*> (Size: 0x10)
UAAISpawnScavStuff.FreePathNodes = 0x230 // TArray<SGAIPathNode*> (Size: 0x10)
UAAISpawnScavStuff.AvailiableSpawnPoints = 0x240 // TArray<SGAIPathNode*> (Size: 0x10)
UAAISpawnScavStuff.PlayerArray = 0x250 // TSet<...> (Size: 0x50)
UAAISpawnScavStuff.PathNodesDict = 0x2a0 // TMap<...> (Size: 0x50)
UAAISpawnScavStuff.ZoneGroupInfo = 0x2f0 // NPCAIZoneGroupInfo* (Size: 0x8)
UAAISpawnScavStuff.AIMemoryComp = 0x2f8 // ActorComponent* (Size: 0x8)
UAAISpawnScavStuff.SpawnControllerData = 0x300 // FAISpawnScavSpawnControllerTableRow (Size: 0xa8)
UAAISpawnScavStuff.PathNodeGroupsInfo_LoopElement = 0x3b0 // FPathNodeGroupInfo (Size: 0x28)
UAAISpawnStuff.TeamAIWaitTime = 0x160 // float (Size: 0x4)
UAAISpawnStuff.PMCPlayerStartTime = 0x164 // float (Size: 0x4)
UAAISpawnStuff.AreaRuntimeData = 0x170 // TMap<...> (Size: 0x50)
UAAISpawnSwither.VolumeIDs = 0x40 // TArray<int32_t> (Size: 0x10)
UAAISpawnSwither.bDoOnce = 0x50 // bool (Size: 0x1)
UAARGGSGlobalDataComponent.FactionGlobalDataA = 0x110 // FASGFactionData (Size: 0x30)
UAARGGSGlobalDataComponent.FactionGlobalDataB = 0x140 // FASGFactionData (Size: 0x30)
UAARGGSGlobalDataComponent.ARGRoundTime = 0x174 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.ARGExtraRoundTime = 0x178 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.AnnounceBGMLeftTime = 0x17c // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.MaxLevel = 0x180 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.UpgradeRequestKill = 0x184 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.WinRequestKill = 0x188 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.AnnounceLevel = 0x18c // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.DeathWatchTime = 0x190 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.RebornWaitTime = 0x194 // int32_t (Size: 0x4)
UAARGGSGlobalDataComponent.RebornSaftyTime = 0x198 // float (Size: 0x4)
UAARGGSGlobalDataComponent.RebornSelectSuitMaxTime = 0x19c // float (Size: 0x4)
UAARGGSGlobalDataComponent.RoundSwitchEquipSelectionTime = 0x1a0 // float (Size: 0x4)
UAARGGSGlobalDataComponent.InterruptRebornSafetyActions = 0x1a8 // TArray<FGameplayTag> (Size: 0x10)
UAARGGSGlobalDataComponent.InterruptRebornSuitSelectActions = 0x1b8 // TArray<FGameplayTag> (Size: 0x10)
UAActivityDataCenterComponent.ActivityDataCenterType = 0xf8 // EEActivityDataCenterType (Size: 0x1)
UAActivityMissionSubsystem.ActivityMissionFlowList = 0x90 // TArray<MFMissionFlow*> (Size: 0x10)
UAActivityMissionSubsystem.MissionFlowPathList = 0xa0 // TArray<FString> (Size: 0x10)
UAActivityMissionSubsystem.MissionFlowAssetList = 0xb0 // TArray<MFMissionFlow*> (Size: 0x10)
UAActorInventoryFactoryComponent.LootPointID = 0x2d0 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.LootDataInfoID = 0x2d4 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.LootID = 0x2d8 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.TimeBucket = 0x2dc // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.LootPointType = 0x2e0 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.LootPointTypeName = 0x2e8 // FText (Size: 0x18)
UAActorInventoryFactoryComponent.CustomIndex = 0x300 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.LootDropID = 0x308 // int64_t (Size: 0x8)
UAActorInventoryFactoryComponent.MapID = 0x310 // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.RealitySpawnInfoList = 0x318 // TArray<FSGInventorySpawnInfo> (Size: 0x10)
UAActorInventoryFactoryComponent.StayLootVolumeID = 0x32c // int32_t (Size: 0x4)
UAActorInventoryFactoryComponent.StayLootVolumeName = 0x330 // FString (Size: 0x10)
UAActorInventoryFactoryComponent.bLimitInBox = 0x340 // bool (Size: 0x1)
UAAmmoSpawnRow.MinCount = 0x8 // int32_t (Size: 0x4)
UAAmmoSpawnRow.MaxCount = 0xc // int32_t (Size: 0x4)
UAAnnounceDisplayContainer.TopAnnounce = 0x2f0 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.BottomAnnounce = 0x2f8 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.RightAnnounce = 0x300 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.CenterAnnounce = 0x308 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.LeftAnnounce = 0x310 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.RightBottomAnnounce = 0x318 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.MultiAnnounce = 0x320 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.LeftUpAnnounce = 0x328 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.RightUpAnnounce = 0x330 // Overlay* (Size: 0x8)
UAAnnounceDisplayContainer.SlotToOverlayMap = 0x338 // TMap<...> (Size: 0x50)
UAAnnounceDisplayContainer.ContainerOrder = 0x388 // EEAnnounceOrderType (Size: 0x1)
UAAnnounceHUDManager.TopAnnounce = 0x2f0 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.BottomAnnounce = 0x2f8 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.RightAnnounce = 0x300 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.CenterAnnounce = 0x308 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.LeftAnnounce = 0x310 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.RightBottomAnnounce = 0x318 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.MultiAnnounce = 0x320 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.LeftUpAnnounce = 0x328 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.RightUpAnnounce = 0x330 // Overlay* (Size: 0x8)
UAAnnounceHUDManager.SlotToOverlayMap = 0x338 // TMap<...> (Size: 0x50)
UAAnnounceHUDManager.TaskWaitAddedQueue = 0x388 // TArray<FAnnounceTaskWaitAssetLoaded> (Size: 0x10)
UAAnnounceHUDManager.NowPlayingAnnounceWidgets = 0x398 // TSet<...> (Size: 0x50)
UAAnnounceHUDManager.AnnounceTaskControl = 0x438 // TMap<...> (Size: 0x50)
UAAnnounceHUDManager.AnnounceWidgetPool = 0x488 // TMap<...> (Size: 0x50)
UAAnnouncePlayComponent.ClientArrayEndIndex = 0x110 // int8_t (Size: 0x1)
UAAnnouncePlayComponent.PreEndLocationTaskID = 0x114 // int32_t (Size: 0x4)
UAAnnouncePlayComponent.AlreadyReceivedReliableTasks = 0x118 // TSet<...> (Size: 0x50)
UAAnnouncePlayComponent.RingArrayMaxLen = 0x17c // int32_t (Size: 0x4)
UAAnnouncePlayComponent.RepArray = 0x180 // FAnnounceRepArray (Size: 0x18)
UAAnnouncePlayComponent.bGameBegin = 0x198 // bool (Size: 0x1)
UAAnnounceSubSystem.AnnouncePlayComponentMap = 0x30 // TMap<...> (Size: 0x50)
UAAnnounceSubSystem.OnAnnouncePlayedOver = 0x80 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnAnnounceAddTaskToQueue = 0x90 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnAnnounceCancelNowPlayingAnnounce = 0xa0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnAnnounceHUDManagerFinishedConstruct = 0xb0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnAnnounceClearAllHUD = 0xc0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.ToggleAnnounceHudEnable = 0xd0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnAnnounceClearQueueByAnnounceID = 0xe0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OnPlayComponentInitialized = 0xf0 // FMulticastInlineDelegate (Size: 0x10)
UAAnnounceSubSystem.OrderTypeToContainer = 0x110 // TMap<...> (Size: 0x50)
UAAnnounceWidgetBase.SlotTypes = 0x2f0 // TSet<...> (Size: 0x50)
UAAnnounceWidgetBase.bDestructOnPlayOver = 0x340 // bool (Size: 0x1)
UAAnnounceWidgetBase.bEndPlayByAudioEnd = 0x341 // bool (Size: 0x1)
UAAnnounceWidgetBase.OrderType = 0x342 // EEAnnounceOrderType (Size: 0x1)
UAAnnounceWidgetBase.MainContentText = 0x348 // TextBlock* (Size: 0x8)
UAAnnounceWidgetBase.TitleText = 0x350 // TextBlock* (Size: 0x8)
UAAnnounceWidgetBase.MainContentRichText = 0x358 // RichTextBlock* (Size: 0x8)
UAAnnounceWidgetBase.MainImage = 0x360 // Image* (Size: 0x8)
UAAnnounceWidgetBase.StartPlayAnimation = 0x368 // WidgetAnimation* (Size: 0x8)
UAAnnounceWidgetBase.LoopPlayAnimation = 0x370 // WidgetAnimation* (Size: 0x8)
UAAnnounceWidgetBase.EndPlayAnimation = 0x378 // WidgetAnimation* (Size: 0x8)
UAAnnounceWidgetBase.StartHideAnimation = 0x380 // WidgetAnimation* (Size: 0x8)
UAAnnounceWidgetBase.EndHideAnimation = 0x388 // WidgetAnimation* (Size: 0x8)
UAAnnounceWidgetBase.AudioEvent = 0x390 // AkAudioEvent* (Size: 0x8)
UAAnnounceWidgetBase.AudioStringEventName = 0x398 // FString (Size: 0x10)
UAAnnounceWidgetBase.AudioStringExternalFilename = 0x3a8 // FString (Size: 0x10)
UAAnnounceWidgetBase.ImageNeedUseSelfSize = 0x3b8 // TSet<...> (Size: 0x50)
UAAnnounceWidgetBase.PlayHUDTaskInfo = 0x408 // FAnnounceHUDTaskInfo (Size: 0x98)
UAAnnounceWidgetBase.AnnounceDisplayRemainTime = 0x4a0 // float (Size: 0x4)
UAAnnounceWidgetBase.AlreadyBoundAnima = 0x4a8 // TSet<...> (Size: 0x50)
UAAnnounceWidgetBase.RuntimeState = 0x4f8 // EEAnnounceWidgetRuntimeState (Size: 0x1)
UAAnnounceWidgetBase.MainImageColor = 0x500 // FSlateColor (Size: 0x28)
UAAnnounceWidgetTopInfoTips.IconPanel = 0x528 // CanvasPanel* (Size: 0x8)
UAAnnounceWidgetTopInfoTips.IconImage = 0x530 // Image* (Size: 0x8)
UAAnnounceWidgetTopInfoTips.IconGlowEffect = 0x538 // Image* (Size: 0x8)
UAAnnounceWidgetTopInfoTips.SubImage = 0x540 // Image* (Size: 0x8)
UAAsyncAction_SpawnAICharacter.OnSpawned = 0x30 // FMulticastInlineDelegate (Size: 0x10)
UAAsyncAction_SpawnAICharacter.OnReady = 0x40 // FMulticastInlineDelegate (Size: 0x10)
UAAsyncAction_SpawnAICharacter.Failed = 0x50 // FMulticastInlineDelegate (Size: 0x10)
UAAsyncAction_SpawnAICharacter.AISpawnPoint = 0x60 // SGAISpawnPoint* (Size: 0x8)
UAAsyncAction_SpawnAICharacter.AIBattleVolume = 0x68 // Volume* (Size: 0x8)
UAAutoColorGrading.CameraSpotlight = 0x3d0 // SpotLightComponent* (Size: 0x8)
UAAutoColorGrading.CameraLocationBack = 0x3d8 // float (Size: 0x4)
UAAutoColorGrading.CameraLocationUp = 0x3dc // float (Size: 0x4)
UAAutoColorGrading.CameraLocationLeft = 0x3e0 // float (Size: 0x4)
UAAutoColorGrading.CameraLocationForward = 0x3e4 // float (Size: 0x4)
UABarrierDampingParamManager.BulletDampingBindList = 0x28 // TArray<FBulletDampingBind> (Size: 0x10)
UABarrierDampingParamManager.DefaultDamping = 0x38 // FBulletDampingParam (Size: 0x10)
UABenchmarkDataTableData.Marker = 0x8 // FString (Size: 0x10)
UABenchmarkDataTableData.Type = 0x18 // FString (Size: 0x10)
UABenchmarkDataTableData.Unit = 0x28 // FString (Size: 0x10)
UABenchmarkDataTableData.Value = 0x38 // FString (Size: 0x10)
UABenchmarkDataTableData.PosX = 0x48 // float (Size: 0x4)
UABenchmarkDataTableData.PosY = 0x4c // float (Size: 0x4)
UABenchmarkDataTableData.PosZ = 0x50 // float (Size: 0x4)
UABenchmarkDataTableData.RotX = 0x54 // float (Size: 0x4)
UABenchmarkDataTableData.RotY = 0x58 // float (Size: 0x4)
UABenchmarkDataTableData.RotZ = 0x5c // float (Size: 0x4)
UABenchmarkManuallyTickActor.NowId = 0x310 // int32_t (Size: 0x4)
UABenchmarkManuallyTickActor.MarkerTransforms = 0x318 // TArray<FTransform> (Size: 0x10)
UABigGoldRaidBox.BigGoldRaidBoxMeshComponent = 0x318 // SkeletalMeshComponent* (Size: 0x8)
UABigGoldRaidBox.TraceConfigID = 0x320 // int32_t (Size: 0x4)
UABigGoldRaidBox.BigGoldInteractStateCache = 0x324 // EEBigGoldRaidInteractState (Size: 0x1)
UABigGoldRaidBox.MinGuaranteeItemAndWeight = 0x328 // TArray<FBigGoldRaidBoxSpawnInfo> (Size: 0x10)
UABigGoldRaidBox.AirDropAlarmEvent = 0x338 // AkAudioEvent* (Size: 0x8)
UABigGoldRaidBox.AirDropUnlockEvent = 0x340 // AkAudioEvent* (Size: 0x8)
UABigGoldRaidBox.LootSubAreaVolumeID = 0x348 // int32_t (Size: 0x4)
UABigGoldRaidBox.LootSubAreaVolume = 0x350 // SGLootSubAreaVolume* (Size: 0x8)
UABigGoldRaidBox.SupplyInfoInfoArray = 0x358 // TArray<FUAParadropSupplyInfo> (Size: 0x10)
UABigGoldRaidBox.InventoryFactoryNum = 0x368 // int32_t (Size: 0x4)
UABigGoldRaidBox.AlreadyInitFactoryNum = 0x36c // int32_t (Size: 0x4)
UABigGoldRaidBox.ActorInventoryFactoryComponentsCache = 0x370 // TArray<SGActorInventoryFactoryComponent*> (Size: 0x10)
UABigGoldRaidBox.InventoryCache = 0x380 // SGInventory* (Size: 0x8)
UABigGoldRaidBox.RedScreenNiagaraComponents = 0x388 // TArray<NiagaraComponent*> (Size: 0x10)
UABigGoldRaidBox.GreenScreenNiagaraComponents = 0x398 // TArray<NiagaraComponent*> (Size: 0x10)
UABigGoldRaidBox.NumberNiagaraComponents = 0x3a8 // TArray<NiagaraComponent*> (Size: 0x10)
UABigGoldRaidBoxSpawnGroup.RandomSpawnPoint = 0x310 // TArray<Actor*> (Size: 0x10)
UABigGoldRaidBoxSpawnGroup.BigGoldRaidBoxClass = 0x320 // ClassProperty (Size: 0x8)
UABigGoldRaidBoxSpawnGroup.LootSubAreaVolumeClass = 0x328 // ClassProperty (Size: 0x8)
UABigGoldRaidBoxSpawnGroup.LootSubAreaVolumePositionBias = 0x330 // FVector (Size: 0xc)
UABigGoldRaidBoxSpawnGroup.LootSubAreaVolumeScaleBias = 0x33c // FVector (Size: 0xc)
UABigGoldRaidComponent.bIsOpenDebugMode = 0x100 // bool (Size: 0x1)
UABigGoldRaidComponent.bHasStartBigGoldRaid = 0x101 // bool (Size: 0x1)
UABigMapAreaVolume.AreaID = 0x398 // int32_t (Size: 0x4)
UABigMapAreaVolume.Layer = 0x39c // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.WorldCenter = 0x30 // FVector (Size: 0xc)
UABigMapInstanceSubsystem.MapTopLeftLocation = 0x3c // FVector (Size: 0xc)
UABigMapInstanceSubsystem.WorldNorthAngleOffset = 0x48 // FVector (Size: 0xc)
UABigMapInstanceSubsystem.WorldExtent = 0x54 // FVector (Size: 0xc)
UABigMapInstanceSubsystem.MapTexture = 0x60 // FBigMapTexture (Size: 0x30)
UABigMapInstanceSubsystem.MapAreaTextureInfos = 0x90 // TArray<FBigMapAreaTextureInfo> (Size: 0x10)
UABigMapInstanceSubsystem.CoreWidth = 0xa0 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CoreHeight = 0xa4 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CoreAreaData = 0xa8 // TArray<uint8_t> (Size: 0x10)
UABigMapInstanceSubsystem.CurMainModeID = 0xb8 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CurSubModeID = 0xbc // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CurMapID = 0xc0 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CurSpecialID = 0xc4 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CurDifficulty = 0xc8 // int32_t (Size: 0x4)
UABigMapInstanceSubsystem.CurLootMaps = 0xd0 // TArray<FString> (Size: 0x10)
UABigMapInstanceSubsystem.IsInitConfig = 0xed // bool (Size: 0x1)
UABigMapInstanceSubsystem.BigMapEffectDataTable = 0xf0 // DataTable* (Size: 0x8)
UABigMapModuleBase.ModuleCanvas = 0x28 // UserWidget* (Size: 0x8)
UABigMapModuleBase.BigMap_Panel = 0x30 // CanvasPanel* (Size: 0x8)
UABigMapModuleBase.BigMap_Widget = 0x38 // UserWidget* (Size: 0x8)
UABigMapModuleBase.ModuleTogle_Widget = 0x40 // UserWidget* (Size: 0x8)
UABigMapModuleBase.IsVisibility = 0x48 // bool (Size: 0x1)
UABigMapModuleBase.ModuleName = 0x50 // FText (Size: 0x18)
UABigMapModuleBase.Order = 0x68 // int32_t (Size: 0x4)
UABigMapModuleBase.WidgetPool = 0x70 // TArray<UserWidget*> (Size: 0x10)
UABigMapModuleBase.AsynLoadingWidgets = 0x80 // TArray<int32_t> (Size: 0x10)
UABulletDampingComponent.DampingMgrCache = 0x100 // UABarrierDampingParamManager* (Size: 0x8)
UABulletDampingComponent.DampingManagerClass = 0x108 // ClassProperty (Size: 0x8)
UACameraShake_Drone.AttackedCameraShakeClass = 0x40 // ClassProperty (Size: 0x8)
UACapturePointVolume.DefaultVecColor = 0x398 // FVector (Size: 0xc)
UACapturePointVolume.CapturePointTotalProgress = 0x3a4 // float (Size: 0x4)
UACapturePointVolume.CapturePointFactionConfig = 0x3a8 // TMap<...> (Size: 0x50)
UACapturePointVolume.CapturePointFactionInfo = 0x3f8 // FCapturePointFactionInfo (Size: 0x18)
UACapturePointVolume.bEnable = 0x410 // bool (Size: 0x1)
UACapturePointVolume.bIsFighting = 0x411 // bool (Size: 0x1)
UACharacter.WeaponManagerComponentNative = 0x1b28 // SGCharacterWeaponManagerComponent* (Size: 0x8)
UACharacter.DeathComponentNative = 0x1b30 // SGCharacterDeathComponent* (Size: 0x8)
UACharacter.MovementAbilityComponentNative = 0x1b38 // SGCharacterMovementAbilityComponent* (Size: 0x8)
UACharacter.TurnComponentNative = 0x1b40 // SGCharacterTurnComponent* (Size: 0x8)
UACharacter.InputProcessComponentNative = 0x1b48 // SGCharacterInputProcessComponent* (Size: 0x8)
UACharacter.MovementProneComponentNative = 0x1b50 // SGCharacterMovementProneComponent* (Size: 0x8)
UACharacter.MovementDBNOComponentNative = 0x1b58 // SGCharacterMovementDBNOComponent* (Size: 0x8)
UACharacter.DBNOComponentNative = 0x1b60 // SGCharacterDBNOComponent* (Size: 0x8)
UACharacter.LeanComponentNative = 0x1b68 // SGCharacterLeanWallComponent* (Size: 0x8)
UACharacter.RagdollComponentNative = 0x1b70 // SGCharacterRagdollNewComponent* (Size: 0x8)
UACharacter.AIComponentNative = 0x1b78 // SGCharacterAIComponent* (Size: 0x8)
UACharacter.AIPoseComponentNative = 0x1b80 // SGCharacterAIPoseComponent* (Size: 0x8)
UACharacter.WeaponSwayComponentNative = 0x1b88 // SGCharacterWeaponSwayComponent* (Size: 0x8)
UACharacter.PoseCacheComponentNative = 0x1b90 // SGUAMCharacterPoseCacheComponent* (Size: 0x8)
UACharacter.EnergyComponentNative = 0x1b98 // SGCharacterEnergyComponent* (Size: 0x8)
UACharacter.SprintComponentNative = 0x1ba0 // SGCharacterSprintComponent* (Size: 0x8)
UACharacter.UseComponentNative = 0x1ba8 // SGActorUseComponent* (Size: 0x8)
UACharacter.PreviewComponentNative = 0x1bb0 // SGCharacterPreviewComponent* (Size: 0x8)
UACharacter.WeaponTraceComponentNative = 0x1bb8 // SGCharacterWeaponTraceComponent* (Size: 0x8)
UACharacter.CurveBreathComponentNative = 0x1bc0 // SGCharacterCurveBreathComponent* (Size: 0x8)
UACharacter.TakeHitEffectComponentNative = 0x1bc8 // SGCharacterTakeHitEffectComponent* (Size: 0x8)
UACharacter.InteractionComponentNative = 0x1bd0 // SGCharacterInteractionComponent* (Size: 0x8)
UACharacter.TeamRescueComponentNative = 0x1bd8 // SGCharacterTeamRescueComponent* (Size: 0x8)
UACharacter.IKComponentNative = 0x1be0 // SGCharacterIKComponent* (Size: 0x8)
UACharacter.StunGrenadeEffectComponentNative = 0x1be8 // SGCharacterStunGrenadeEffectComponent* (Size: 0x8)
UACharacter.WeightComponentNative = 0x1bf0 // SGCharacterWeightComponent* (Size: 0x8)
UACharacter.SenseAbilityComponentNative = 0x1bf8 // SGCharacterSenseAbilityComponent* (Size: 0x8)
UACharacter.CastShadowCompNative = 0x1c00 // SGCharacterCastShadowComponent* (Size: 0x8)
UACharacter.AvatarCompNative = 0x1c08 // SGCharacterAvatarComponent* (Size: 0x8)
UACharacter.AvatarMergeCompNative = 0x1c10 // SGCharacterAvatarMergeComponent* (Size: 0x8)
UACharacter.FOVComponentNative = 0x1c18 // SGCharacterFOVComponent* (Size: 0x8)
UACharacter.InventorySearchComponentNative = 0x1c20 // SGCharacterInventorySearchComponent* (Size: 0x8)
UACharacter.FallComponentNative = 0x1c28 // SGCharacterFallComponent* (Size: 0x8)
UACharacter.HealthComponentNative = 0x1c30 // SGCharacterHealthComponent* (Size: 0x8)
UACharacter.TakeDamageComponentNative = 0x1c38 // SGCharacterTakeDamageComponent* (Size: 0x8)
UACharacter.BeUsedCorpseComponentNative = 0x1c40 // SGCharacterBeUsedCorpseComponent* (Size: 0x8)
UACharacter.BeUsedRescueComponentNative = 0x1c48 // SGCharacterBeUsedRescueComponent* (Size: 0x8)
UACharacter.WeaponAttachComponentNative = 0x1c50 // SGCharacterWeaponAttachComponent* (Size: 0x8)
UACharacter.MeshComponentNative = 0x1c58 // SGCharacterMeshComponent* (Size: 0x8)
UACharacter.HoldBreathComponentNative = 0x1c60 // SGCharacterHoldBreathComponent* (Size: 0x8)
UACharacter.ProgressManagerComponentNative = 0x1c68 // SGCharacterProgressManagerComponent* (Size: 0x8)
UACharacter.FootEffectComponentNative = 0x1c70 // SGCharacterFootEffectComponent* (Size: 0x8)
UACharacter.InventoryGiveComponentNative = 0x1c78 // SGCharacterInventoryGiveComponent* (Size: 0x8)
UACharacter.MoistureComponentNative = 0x1c80 // SGCharacterMoistureComponent* (Size: 0x8)
UACharacter.EnduranceComponentNative = 0x1c88 // SGCharacterEnduranceComponent* (Size: 0x8)
UACharacter.AvatarManagerComponentNative = 0x1c90 // SGCharacterAvatarManagerComponent* (Size: 0x8)
UACharacter.DebugMovementComponentNative = 0x1c98 // SGCharacterDebugMovementComponent* (Size: 0x8)
UACharacter.FoodComponentNative = 0x1ca0 // SGCharacterFoodComponent* (Size: 0x8)
UACharacter.SoundComponentNative = 0x1ca8 // SGCharacterSoundComponent* (Size: 0x8)
UACharacter.BoneBreakComponentNative = 0x1cb0 // SGCharacterBoneBreakComponent* (Size: 0x8)
UACharacter.DamageDebugComponentNative = 0x1cb8 // SGCharacterDamageDebugComponent* (Size: 0x8)
UACharacter.FlashGrenadeEffectComponentNative = 0x1cc0 // SGCharacterFlashGrenadeEffectComponent* (Size: 0x8)
UACharacter.InvInteractFlagComponentNative = 0x1cc8 // SGCharacterInvInteractFlagComponent* (Size: 0x8)
UACharacter.MovementVaultComponentNative = 0x1cd0 // SGCharacterMovementVaultComponent* (Size: 0x8)
UACharacter.SwimComponentNative = 0x1cd8 // SGCharacterSwimComponent* (Size: 0x8)
UACharacter.LagCompensationComponentNative = 0x1ce0 // SGCharacterLagCompensationComponent* (Size: 0x8)
UACharacter.SignificanceComponentNative = 0x1ce8 // SGCharacterSignificanceComponent* (Size: 0x8)
UACharacter.TeamMoveComponentNative = 0x1cf0 // SGCharacterTeamMoveComponent* (Size: 0x8)
UACharacter.InventoryManagerComponentNative = 0x1cf8 // UACharacterInventoryManagerComponent* (Size: 0x8)
UACharacter.ActivityComponentNative = 0x1d00 // SGCharacterActivityComponent* (Size: 0x8)
UACharacter.SetRTPCComponentNative = 0x1d08 // SetRTPCComponent* (Size: 0x8)
UACharacter.InventoryDetectComponentNative = 0x1d10 // SGCharacterInventoryDetectComponent* (Size: 0x8)
UACharacter.AKComponentNative = 0x1d18 // AkComponent* (Size: 0x8)
UACharacter.AvatarComponentNative = 0x1d20 // SGCharacterAvatarComponent* (Size: 0x8)
UACharacter.InventoryComponentNative = 0x1d28 // SGCharacterInventoryComponent* (Size: 0x8)
UACharacter.ContainerGridMgrComponentNative = 0x1d30 // SGCharacterContainerGridMgrComponent* (Size: 0x8)
UACharacter.LoadProtectComponentNative = 0x1d38 // SGCharacterLoadProtectComponent* (Size: 0x8)
UACharacter.SpectatingComponentNative = 0x1d40 // SGCharacterSpectatingComponent* (Size: 0x8)
UACharacter.ArmorManagerComponentNative = 0x1d48 // SGCharacterArmorManagerComponent* (Size: 0x8)
UACharacter.TemplateClass = 0x1d50 // ClassProperty (Size: 0x8)
UACharacterAvatarManagerComponent.BadgeList = 0x908 // TArray<SGInventory*> (Size: 0x10)
UACharacterAvatarManagerComponent.WearBadgeList = 0x918 // SGInventory* (Size: 0x8)
UACharacterConditionDetecterComponent.EventMap = 0xf8 // TMap<...> (Size: 0x50)
UACharacterConditionDetecterComponent.TimeInterval = 0x150 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.UpperEnergythreshold = 0x154 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.LowerEnergythreshold = 0x158 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.HealthThreshold = 0x15c // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.UnderLevel = 0x160 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.DangerAreaTipsLevel = 0x164 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.AttackScavTipsLevel = 0x168 // int32_t (Size: 0x4)
UACharacterConditionDetecterComponent.NewMapTutorialModule = 0x170 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UACharacterConditionDetecterComponent.bIsOutOfUpperEnergy = 0x180 // bool (Size: 0x1)
UACharacterConditionDetecterComponent.bIsOutOfLowerEnergy = 0x181 // bool (Size: 0x1)
UACharacterConditionDetecterComponent.bIsOutOfHealth = 0x182 // bool (Size: 0x1)
UACharacterConditionDetecterComponent.bHightlightEscape = 0x183 // bool (Size: 0x1)
UACharacterConditionDetecterComponent.InnerRadius = 0x184 // float (Size: 0x4)
UACharacterConditionDetecterComponent.OuterRadius = 0x188 // float (Size: 0x4)
UACharacterConditionDetecterComponent.LootDetectHandle = 0x190 // FTimerHandle (Size: 0x8)
UACharacterConditionDetecterComponent.NearbyContainers = 0x198 // TMap<...> (Size: 0x50)
UACharacterConditionDetecterComponent.SearchedContainers = 0x1e8 // TMap<...> (Size: 0x50)
UACharacterDeathComponent.RewardBoxClass = 0x968 // ClassProperty (Size: 0x8)
UACharacterDeathComponent.RewardBoxMaxExpandTimes = 0x970 // int32_t (Size: 0x4)
UACharacterDeathComponent.RewardBoxCurrentExpandTimes = 0x974 // int32_t (Size: 0x4)
UACharacterDeathComponent.RewardBoxExpandRowsEveryTime = 0x978 // int32_t (Size: 0x4)
UACharacterDeathComponent.DelayDeathNiagaraTime = 0x97c // float (Size: 0x4)
UACharacterDeathComponent.DeathEffects = 0x980 // TArray<FEffectParticleInfo> (Size: 0x10)
UACharacterDeathComponent.NewParentMaterial = 0x990 // MaterialInterface* (Size: 0x8)
UACharacterDeathComponent.OverrideParentMaterial = 0x998 // TMap<...> (Size: 0x50)
UACharacterDeathComponent.DefaultTextureParameters = 0x9e8 // TMap<...> (Size: 0x50)
UACharacterDeathComponent.DeathMTCurve = 0xa38 // TMap<...> (Size: 0x50)
UACharacterDeathComponent.DelaySpawnRewardBoxTime = 0xa88 // float (Size: 0x4)
UACharacterDeathComponent.PrioritySpawnItems = 0xa90 // TArray<EEAttachPosition> (Size: 0x10)
UACharacterDeathComponent.DeathMaterialInstanceDynamic = 0xaa0 // TArray<MaterialInstanceDynamic*> (Size: 0x10)
UACharacterDeathComponent.DeathEffectProgress = 0xab0 // float (Size: 0x4)
UACharacterDeathComponent.RewardBox = 0xab8 // SGInventory* (Size: 0x8)
UACharacterDeathComponent.bPlayDeathEffect = 0xac0 // bool (Size: 0x1)
UACharacterDeathComponent.TemporaryHiddenAdapters = 0xac8 // TArray<Actor*> (Size: 0x10)
UACharacterInventoryManagerComponent.ShortCutInventoryArray = 0x328 // TArray<FShortcutItemStruct> (Size: 0x10)
UACharacterInventoryManagerComponent.OnMouseEnterCurrentItem = 0x338 // SGInventory* (Size: 0x8)
UACharacterInventoryManagerComponent.bRefreshAllInventoryValue = 0x340 // bool (Size: 0x1)
UACharacterInventoryManagerComponent.AllInventoryValue = 0x344 // float (Size: 0x4)
UACharacterInventoryManagerComponent.AllInventoryValueBringIn = 0x348 // float (Size: 0x4)
UACharacterInventoryManagerComponent.AllInventoryValueTrade = 0x34c // float (Size: 0x4)
UACharacterInventoryManagerComponent.AllInventoryValueTradeBringIn = 0x350 // float (Size: 0x4)
UACharacterManagerMarkedComponent.MarkedDataList = 0x100 // TArray<FUAMarkedData> (Size: 0x10)
UAChronographSwither.DelayTime = 0x48 // float (Size: 0x4)
UAChronographSwither.BeginTime = 0x4c // int32_t (Size: 0x4)
UAChronographSwither.EndTime = 0x50 // int32_t (Size: 0x4)
UAChronographSwither.NiagaraActor = 0x58 // Actor* (Size: 0x8)
UAChronographSwither.NiagaraComponent = 0x60 // NiagaraComponent* (Size: 0x8)
UACorpseDetectorComponent.AppearanceParams = 0x10a0 // FUADetectorAppearanceParams (Size: 0x80)
UADestroyInventorySwither.InventoryMonitorVolume = 0x40 // SGInventoryMonitorVolume* (Size: 0x8)
UADestroyInventorySwither.FrameUnReplicateActor = 0x48 // TArray<SGInventory*> (Size: 0x10)
UADestroyInventorySwither.FrameDestroyActor = 0x58 // TArray<SGInventory*> (Size: 0x10)
UADetectorAppearanceParams.RotationParamKey = 0x0 // FName (Size: 0x8)
UADetectorAppearanceParams.RotationParamForwards = 0x8 // FVector (Size: 0xc)
UADetectorAppearanceParams.RotationParamLeft = 0x14 // FVector (Size: 0xc)
UADetectorAppearanceParams.RotationParamRight = 0x20 // FVector (Size: 0xc)
UADetectorAppearanceParams.RotationParamBack = 0x2c // FVector (Size: 0xc)
UADetectorAppearanceParams.PowerLengthParamKey = 0x38 // FName (Size: 0x8)
UADetectorAppearanceParams.PowerLengthParam = 0x40 // FVector (Size: 0xc)
UADetectorAppearanceParams.PowerColorParamKey = 0x4c // FName (Size: 0x8)
UADetectorAppearanceParams.PowerColorThreshold = 0x54 // float (Size: 0x4)
UADetectorAppearanceParams.PowerColorSmallParam = 0x58 // FVector (Size: 0xc)
UADetectorAppearanceParams.PowerColorBigParam = 0x64 // FVector (Size: 0xc)
UADetectorAppearanceParams.OpenXHParamKey = 0x70 // FName (Size: 0x8)
UADetectorAppearanceParams.OpenXHSmallParam = 0x78 // float (Size: 0x4)
UADetectorAppearanceParams.OpenXHBigParam = 0x7c // float (Size: 0x4)
UADoorLockComponent.bEnableLootProtect = 0x108 // bool (Size: 0x1)
UADroneCameraEffectComponent.DeletaRotationValue = 0xf8 // float (Size: 0x4)
UADroneCharacter.OwnerCharacter = 0x5d8 // SGCharacter* (Size: 0x8)
UADroneCharacter.DroneComponentClasses = 0x5e0 // TArray<ClassProperty> (Size: 0x10)
UADroneCharacter.DroneComponents = 0x5f0 // TArray<ActorComponent*> (Size: 0x10)
UADroneControlDataComponent.RemoteCharacter = 0xf8 // UADroneCharacter* (Size: 0x8)
UADroneControlDataComponent.RemoteCharacterClass = 0x100 // ClassProperty (Size: 0x8)
UADroneControlDataComponent.SpawnOffestPosition = 0x108 // FVector (Size: 0xc)
UADroneDeathComponent.CloseDroneCurve = 0x100 // CurveFloat* (Size: 0x8)
UADroneDeathComponent.DestroyParticle = 0x108 // ParticleSystem* (Size: 0x8)
UADroneDeathComponent.DestroyPSC = 0x110 // ParticleSystemComponent* (Size: 0x8)
UADroneFlyPathComponent.FlyCurve = 0xf8 // CurveVector* (Size: 0x8)
UADroneFlyPathComponent.TotalFlyTime = 0x100 // float (Size: 0x4)
UADroneHealthComponent.IsAttacked = 0xf8 // bool (Size: 0x1)
UADroneHealthComponent.Health = 0x110 // int32_t (Size: 0x4)
UADroneHealthComponent.MaxHealth = 0x114 // int32_t (Size: 0x4)
UADroneHealthComponent.AttackedCameraShakeClass = 0x118 // ClassProperty (Size: 0x8)
UADroneMovementComponent.HeightLimit = 0xc58 // float (Size: 0x4)
UADroneMovementComponent.RangeLimit = 0xc5c // float (Size: 0x4)
UADroneMovementComponent.InFlyMaxSpeed = 0xc60 // float (Size: 0x4)
UADronePowerComponent.TotalPower = 0xf8 // int32_t (Size: 0x4)
UADronePowerComponent.CurPower = 0xfc // int32_t (Size: 0x4)
UADroneWifiComponent.DronePostMat = 0xf8 // MaterialInstance* (Size: 0x8)
UADroneWifiComponent.DronePostMatDynamic = 0x100 // MaterialInstanceDynamic* (Size: 0x8)
UADroneWifiComponent.WifiStrongCurve = 0x108 // CurveFloat* (Size: 0x8)
UADsaLogic.session_ = 0x38 // UADsaSession* (Size: 0x8)
UADsaSession.CmdHandlerArr = 0x28 // TArray<UADsaCmdHandler*> (Size: 0x10)
UADynamicMissionSubsystem.FultonRandomResult = 0x88 // TArray<MFMissionFlow*> (Size: 0x10)
UADynamicMissionSubsystem.DynamicMissionFlowList = 0xa0 // TArray<MFMissionFlow*> (Size: 0x10)
UADynamicMissionSubsystem.DistributeMissionHistories = 0xb0 // TArray<FDistributeMissionHistory> (Size: 0x10)
UADynamicMissionSubsystem.MissionFlowPathList = 0xc0 // TArray<FString> (Size: 0x10)
UADynamicMissionSubsystem.MissionFlowAssetList = 0xd0 // TArray<MFMissionFlow*> (Size: 0x10)
UAEscapeInteractFSM.ActiveCheckObjectArr = 0x1d8 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeNewInteractVolume.ResetEscapeVolume = 0x398 // UAEscapeVolume* (Size: 0x8)
UAEscapeNewInteractVolume.OrderInteractState = 0x3a0 // EEEscapeState (Size: 0x1)
UAEscapeNewInteractVolume.InteractForEveryone = 0x3a1 // bool (Size: 0x1)
UAEscapeNewInteractVolume.LimitNum = 0x3a4 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.RecyleingState = 0x3a8 // EEEscapeInteractVolumeState (Size: 0x1)
UAEscapeNewInteractVolume.RecyleingDelayTime = 0x3ac // float (Size: 0x4)
UAEscapeNewInteractVolume.EscapeInteractTextID = 0x3b0 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.UnactivateMessageId = 0x3b4 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.LimitInteractMessageId = 0x3b8 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.InteractedMessageId = 0x3bc // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.CostCheckMessageId = 0x3c0 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.ConfigID = 0x3c4 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.EscapeInteractVolumeType = 0x3c8 // EEEscapeVolumeType (Size: 0x1)
UAEscapeNewInteractVolume.StartDateTime = 0x3d0 // FDateTime (Size: 0x8)
UAEscapeNewInteractVolume.TotalTime = 0x3d8 // float (Size: 0x4)
UAEscapeNewInteractVolume.ActiveCheckObjectArr = 0x3e0 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeNewInteractVolume.ResetCheckObjectArr = 0x3f0 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeNewInteractVolume.InteractNum = 0x400 // int32_t (Size: 0x4)
UAEscapeNewInteractVolume.InteractPC = 0x408 // TArray<PlayerController*> (Size: 0x10)
UAEscapeNewInteractVolume.DelayTimerHandle = 0x418 // FTimerHandle (Size: 0x8)
UAEscapeNewInteractVolume.InteractedShowComp = 0x420 // SGShowControlComponent* (Size: 0x8)
UAEscapeNewInteractVolume.ActivateShowComp = 0x428 // SGShowControlComponent* (Size: 0x8)
UAEscapeNewInteractVolume.UnactivateShowComp = 0x430 // SGShowControlComponent* (Size: 0x8)
UAEscapeNewInteractVolume.FSMComp = 0x438 // UAEscapeInteractFSM* (Size: 0x8)
UAEscapeNewInteractVolume.UAVolumeInteractComp = 0x440 // UAVolumeInteractComponent* (Size: 0x8)
UAEscapeNewInteractVolume.RelevantEscapeVolume = 0x448 // TArray<UAEscapeVolume*> (Size: 0x10)
UAEscapeNewInteractVolume.InteractedTeamIndex = 0x458 // TArray<int32_t> (Size: 0x10)
UAEscapeNewInteractVolume.PreConditionVolumes = 0x468 // TArray<SGVolume*> (Size: 0x10)
UAEscapePointTimerComponent.EscapePointID = 0xf8 // int32_t (Size: 0x4)
UAEscapePointTimerComponent.IsCanUse = 0xfc // bool (Size: 0x1)
UAEscapePointTimerComponent.StartDateTime = 0x100 // FDateTime (Size: 0x8)
UAEscapePointTimerComponent.TotalTime = 0x108 // float (Size: 0x4)
UAEscapePointTimerComponent.TimeType = 0x10c // EEUATimeType (Size: 0x1)
UAEscapePointTimerComponent.enable = 0x10d // bool (Size: 0x1)
UAEscapePointTimerComponent.EscapeTimeType = 0x10e // EEUAEscapeTimeType (Size: 0x1)
UAEscapeRuntimeConfigComponent.EscapeConditionDescDatas = 0xf8 // TArray<FEscapeConditionDescData> (Size: 0x10)
UAEscapeVolume.EscapeVolumeType = 0x3a0 // EEEscapeVolumeType (Size: 0x1)
UAEscapeVolume.EscapeVolumeStyle = 0x3a1 // EEEscapeVolumeStyle (Size: 0x1)
UAEscapeVolume.CheckObjectArr = 0x3a8 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeVolume.CheckObjectRelative = 0x3b8 // EEUAFSMRelative (Size: 0x1)
UAEscapeVolume.CanEscapeCheckObjectArr = 0x3c0 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeVolume.CanEscapeRelative = 0x3d0 // EEUAFSMRelative (Size: 0x1)
UAEscapeVolume.CloseCheckObjectArr = 0x3d8 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeVolume.CloseRelative = 0x3e8 // EEUAFSMRelative (Size: 0x1)
UAEscapeVolume.IsVehicleEscapeVolume = 0x3e9 // bool (Size: 0x1)
UAEscapeVolume.RandomSelectEscapeCheckObjects = 0x3f0 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAEscapeVolume.RandomSelectEscapeCheckObjectCount = 0x400 // int32_t (Size: 0x4)
UAEscapeVolume.OnEscapeStateChange = 0x408 // FMulticastInlineDelegate (Size: 0x10)
UAEscapeVolume.OnEscapePlayerNumChange = 0x418 // FMulticastInlineDelegate (Size: 0x10)
UAEscapeVolume.RequiredStaySeconds = 0x428 // float (Size: 0x4)
UAEscapeVolume.TimingCheckObject = 0x430 // UAFSMCheckObject* (Size: 0x8)
UAEscapeVolume.RelativeInteractVolume = 0x438 // TArray<UAEscapeNewInteractVolume*> (Size: 0x10)
UAEscapeVolume.VolumeFSMComponent = 0x448 // UAFSMComponent* (Size: 0x8)
UAEscapeVolume.PlayerFSMComponentArray = 0x450 // TArray<UAFSMComponent*> (Size: 0x10)
UAEscapeVolume.OpenShowComp = 0x460 // SGShowControlComponent* (Size: 0x8)
UAEscapeVolume.CanEscapeShowComp = 0x468 // SGShowControlComponent* (Size: 0x8)
UAEscapeVolume.CloseShowComp = 0x470 // SGShowControlComponent* (Size: 0x8)
UAEscapeVolume.TriggerPlayers = 0x480 // TArray<SGPlayerController*> (Size: 0x10)
UAFSMAdvanceParam.OnlyReplicateToTarget = 0x0 // bool (Size: 0x1)
UAFSMCRelation.CheckObjectArr = 0x38 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAFSMCRelation.SuccessNum = 0x48 // int32_t (Size: 0x4)
UAFSMCheckObject.OwnerFSM = 0x28 // UAFSMComponent* (Size: 0x8)
UAFSMCheckObject.bCanReset = 0x30 // bool (Size: 0x1)
UAFSMComponent.OnFSMStateChange = 0xf8 // FMulticastInlineDelegate (Size: 0x10)
UAFSMComponent.OnPreFSMStateChange = 0x108 // FMulticastInlineDelegate (Size: 0x10)
UAFSMComponent.bRunOnBeginPlay = 0x118 // bool (Size: 0x1)
UAFSMComponent.CheckObjectArr = 0x120 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAFSMComponent.UAFSMInfo = 0x130 // FUAFSMInfo (Size: 0x38)
UAFSMComponent.bPauseing = 0x168 // bool (Size: 0x1)
UAFSMComponent.bHasStart = 0x169 // bool (Size: 0x1)
UAFSMComponent.bNeedTick = 0x16a // bool (Size: 0x1)
UAFSMComponent.TickInterval = 0x16c // float (Size: 0x4)
UAFSMComponent.TickCountDown = 0x170 // float (Size: 0x4)
UAFSMComponent.StateCheckObjects = 0x178 // TMap<...> (Size: 0x50)
UAFSMExecuteObject.OwnerFSM = 0x28 // UAFSMComponent* (Size: 0x8)
UAFSMInfo.FSMState = 0x0 // FString (Size: 0x10)
UAFSMInfo.OldFSMState = 0x10 // FString (Size: 0x10)
UAFSMInfo.StateEnterTimeSeconds = 0x20 // float (Size: 0x4)
UAFSMInfo.TargetObject = 0x28 // Object* (Size: 0x8)
UAFSMInfo.OnlyReplicateToTarget = 0x30 // bool (Size: 0x1)
UAFaction.bFactionInnerFriendly = 0x388 // bool (Size: 0x1)
UAFlightComponent.TargetLandingLocationIndicatorParticleSystem = 0xf8 // ParticleSystem* (Size: 0x8)
UAFlightComponent.JammingEffectTemplate = 0x100 // TSoftObjectPtr<UObject> (Size: 0x28)
UAFlightComponent.FlightConfigChange = 0x138 // FMulticastInlineDelegate (Size: 0x10)
UAFlightComponent.FlightKeyPointsChange = 0x148 // FMulticastInlineDelegate (Size: 0x10)
UAFlightComponent.Start = 0x164 // FVector (Size: 0xc)
UAFlightComponent.End = 0x170 // FVector (Size: 0xc)
UAFlightComponent.ConfigRowName = 0x180 // FName (Size: 0x8)
UAFlightComponent.KeyPoints = 0x190 // TArray<FVector> (Size: 0x10)
UAFlightComponent.FlightCaller = 0x1a0 // Pawn* (Size: 0x8)
UAFlightComponent.PassedKeyPointNum = 0x1a8 // int32_t (Size: 0x4)
UAFlightComponent.ControlledActor = 0x1b0 // Actor* (Size: 0x8)
UAFlightComponent.DestoryWhenArrive = 0x1b8 // bool (Size: 0x1)
UAFlightComponent.TargetLandingLocationIndicatorParticleSystemComponents = 0x1c0 // TArray<ParticleSystemComponent*> (Size: 0x10)
UAFollowCharacterWidget.CanvasPanelToMove = 0x2f8 // CanvasPanel* (Size: 0x8)
UAFollowCharacterWidget.WidgetIndex = 0x300 // int32_t (Size: 0x4)
UAFollowCharacterWidget.WidgetInfo = 0x308 // FFollowCharacterWidgetInfo (Size: 0x20)
UAFollowCharacterWidget.FollowedCharacter = 0x340 // Character* (Size: 0x8)
UAFollowCharacterWidget.LocalPlayerController = 0x348 // PlayerController* (Size: 0x8)
UAFollowCharacterWidget.LocalCharacter = 0x350 // Character* (Size: 0x8)
UAFollowCharacterWidget.VisibleDistance = 0x358 // float (Size: 0x4)
UAFollowCharacterWidget.Offset = 0x35c // FVector (Size: 0xc)
UAFollowCharacterWidget.Offset2D = 0x368 // FVector2D (Size: 0x8)
UAGILoadingTipsComponent.LoadingTexture = 0x28 // Texture2D* (Size: 0x8)
UAGILoadingTipsComponent.CountdownTexture = 0x30 // Texture2D* (Size: 0x8)
UAGILoadingTipsComponent.MapDefaultLoadingTexture = 0x38 // Texture2D* (Size: 0x8)
UAGILoadingTipsComponent.MapDefaultCountdownTexture = 0x40 // Texture2D* (Size: 0x8)
UAGILoadingTipsComponent.MapDefaultLoadingUMG = 0x48 // UserWidget* (Size: 0x8)
UAGILoadingTipsComponent.Tips = 0x50 // TArray<FTipItem> (Size: 0x10)
UAGILoadingTipsComponent.WeightCount = 0x60 // int32_t (Size: 0x4)
UAGILoadingTipsComponent.FirstTip = 0x68 // FText (Size: 0x18)
UAGILoadingTipsComponent.SecondTip = 0x80 // FText (Size: 0x18)
UAGILoadingTipsComponent.SelectUnlockMapID = 0x98 // int32_t (Size: 0x4)
UAGILoadingTipsComponent.CurValidLoadingTipsArr = 0xa0 // TArray<FLoadingTipsTableRow> (Size: 0x10)
UAGILoadingTipsComponent.CurValidLoadingTipsIndex = 0xb0 // int32_t (Size: 0x4)
UAGILoadingTipsComponent.bOpenRank = 0xb4 // bool (Size: 0x1)
UAGILoadingTipsComponent.bIsHighHagnification = 0xb5 // bool (Size: 0x1)
UAGILoadingTipsComponent.MemberInfoArr = 0xb8 // TArray<FMemberInfo> (Size: 0x10)
UAGILoadingTipsComponent.NeedNewPlayerTips = 0xc8 // bool (Size: 0x1)
UAGILoadingTipsComponent.MemberSpeakingMap = 0xd0 // TMap<...> (Size: 0x50)
UAGILoadingTipsComponent.LoadingExInfo = 0x120 // FLoadingExInfo (Size: 0x48)
UAGILoadingTipsComponent.bEnableRoleBanner = 0x168 // bool (Size: 0x1)
UAGILoadingTipsComponent.bMinmapLoadFinished = 0x169 // bool (Size: 0x1)
UAGILoadingTipsComponent.PlayerLevel = 0x16c // int32_t (Size: 0x4)
UAGMInventoryManagerComponent.AdditionalAvailableFulton = 0x208 // int32_t (Size: 0x4)
UAGMInventoryManagerComponent.AdditionalAvailableGashaCoin = 0x20c // int32_t (Size: 0x4)
UAGMMsgHandlerManagerComponent.StandAloneHandlers = 0xf8 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAGMMsgHandlerManagerComponent.DSHandlers = 0x108 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAGMMsgHandlerManagerComponent.Handlers = 0x118 // TArray<UADsaCmdHandler*> (Size: 0x10)
UAGMMsgHandlerManagerComponent.DsaLogic = 0x128 // UADsaLogic* (Size: 0x8)
UAGMMsgHandlerManagerComponent.bHasInit = 0x130 // bool (Size: 0x1)
UAGSEscapeManagerComponent.bInit = 0x108 // bool (Size: 0x1)
UAGSEscapeManagerComponent.EscapePointMap = 0x110 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.TeamEscapeMap = 0x160 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.ModifyEscapeInfoMap = 0x1b0 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.TeamInfoEscapeInfosMap = 0x200 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.PlayerTeamTypeEscapeInfosMap = 0x250 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.FactionTypeEscapeInfosMap = 0x2a0 // TMap<...> (Size: 0x50)
UAGSEscapeManagerComponent.EscapeMap = 0x300 // TMap<...> (Size: 0x50)
UAGSGreenHandEventComponent.OnQuestComplete = 0x100 // FMulticastInlineDelegate (Size: 0x10)
UAGSGreenHandEventComponent.OnLoadingScreenMovieFinish = 0x110 // FMulticastInlineDelegate (Size: 0x10)
UAGSMPGameFlowComponent.RoundBeginTime = 0x120 // float (Size: 0x4)
UAGSMPGameFlowComponent.ExtraRoundBeginTime = 0x124 // float (Size: 0x4)
UAGSMPGameFlowComponent.bIsExtraRound = 0x128 // bool (Size: 0x1)
UAGSMPGameFlowComponent.SkippedTime = 0x12c // float (Size: 0x4)
UAGSMPGameFlowComponent.OverRunTime = 0x130 // float (Size: 0x4)
UAGSSceneManagerComponent.RefLevels = 0xf8 // TArray<FName> (Size: 0x10)
UAGSSceneManagerComponent.AddtionLevels = 0x108 // TArray<FName> (Size: 0x10)
UAGSSceneManagerComponent.DeleteActors = 0x118 // TArray<FMissionActorReference> (Size: 0x10)
UAGSSceneManagerComponent.MoveActorArr = 0x128 // TArray<FSGSceneMoveActorRaw> (Size: 0x10)
UAGSTutorialEventComponent.Coach = 0x100 // SGAICharacter* (Size: 0x8)
UAGSTutorialEventComponent.OnSoundTutorialBtnClick = 0x108 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnSoundTutorialUIChangeShow = 0x118 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnDirectionalBarChangeShow = 0x128 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnBigMapStateChange = 0x138 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnBagTabClick = 0x148 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnBagStateChange = 0x158 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnFinishEscape = 0x168 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.PlayMeida = 0x178 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.StopMeida = 0x188 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnClickItem = 0x198 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnSetItemSelectMenuEnable = 0x1a8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnCheckWeaponBtnClick = 0x1b8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnLevelLoadComplete = 0x1c8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnFakeMapEffectClicked = 0x1d8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnSettingPannalChange = 0x1e8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnItemMoveFail = 0x1f8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnSetBagContainerUILock = 0x208 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnFireBtnClick = 0x218 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnBlackBarEnableChange = 0x228 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnHealthUIClick = 0x238 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnItemLockedByID = 0x248 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.ChangeViewCheckTarget = 0x258 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.ChangeStarSightEffectShow = 0x268 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.ShowFacePaintWidget = 0x278 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.CloseFacePaintWidget = 0x288 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OpenItemDetail = 0x298 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.UnSelectInventory = 0x2a8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnBeginUseItem = 0x2b8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.CloseBag = 0x2c8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnFacePanelStateChange = 0x2d8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnCreateTeamReqAndStartMatching = 0x2e8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnTutorialSequenceFinished = 0x2f8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.PlayBlink = 0x308 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnMovieFinishCacheDelegate = 0x318 // FDelegate (Size: 0x10)
UAGSTutorialEventComponent.PlayB1EndEffect = 0x328 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.SpeedAbilityClass = 0x338 // ClassProperty (Size: 0x8)
UAGSTutorialEventComponent.SpeedAbilitySpecHandle = 0x340 // FGameplayAbilitySpecHandle (Size: 0x4)
UAGSTutorialEventComponent.CoachSpeedAbilityClass = 0x348 // ClassProperty (Size: 0x8)
UAGSTutorialEventComponent.CoachSpeedAbilitySpecHandle = 0x350 // FGameplayAbilitySpecHandle (Size: 0x4)
UAGSTutorialEventComponent.OnBlackfilmFadeBegin = 0x358 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnSetLifeStateClickEnable = 0x368 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.CharacterConditonCheckEnable = 0x378 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.OnThrowingWeaponEffectEnable = 0x388 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.TutorialRookieIDReport = 0x398 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.ShouldCheckRookieTimes = 0x3a8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.FinishSwitchCheckpoint = 0x3b8 // FMulticastInlineDelegate (Size: 0x10)
UAGSTutorialEventComponent.AIMap = 0x3c8 // TMap<...> (Size: 0x50)
UAGSTutorialEventComponent.AIDeathBoxMap = 0x418 // TMap<...> (Size: 0x50)
UAGSTutorialEventComponent.ChangePlayMediaEndType = 0x468 // FMulticastInlineDelegate (Size: 0x10)
UAGameAreaStatisComponent.OnEnterReportAreaVolume = 0x100 // FMulticastInlineDelegate (Size: 0x10)
UAGameAreaStatisComponent.OnLeavingReportAreaVolume = 0x110 // FMulticastInlineDelegate (Size: 0x10)
UAGameAreaStatisComponent.NativeCachePlayerAreaIDMap = 0x120 // TMap<...> (Size: 0x50)
UAGameHUDManager.GameHUDReportInfos = 0x2f0 // TMap<...> (Size: 0x50)
UAGameHUDManager.WidgetAsset = 0x390 // ClassProperty (Size: 0x8)
UAGameHUDManager.Tips_Panel = 0x398 // Overlay* (Size: 0x8)
UAGameHUDManager.DialogBox_Panel = 0x3a0 // Overlay* (Size: 0x8)
UAGameHUDManager.Objective_Panel = 0x3a8 // Overlay* (Size: 0x8)
UAGameHUDManager.Suggestive_Panel = 0x3b0 // Overlay* (Size: 0x8)
UAGameHUDManager.WarnMessage_Panel = 0x3b8 // Overlay* (Size: 0x8)
UAGameHUDManager.LightTips_Panel = 0x3c0 // Overlay* (Size: 0x8)
UAGameHUDManager.ActivityPhase_Panel = 0x3c8 // Overlay* (Size: 0x8)
UAGameHUDManager.Quest_Widget = 0x3d0 // CAQuestHUD* (Size: 0x8)
UAGameHUDManager.RouletteTips_Panel = 0x3d8 // Overlay* (Size: 0x8)
UAGameInstanceDsaLogicComponent.DsaLogic = 0x28 // UADsaLogic* (Size: 0x8)
UAGameLootDataInfoPoints.DataInfoID = 0x0 // int32_t (Size: 0x4)
UAGameLootDataInfoPoints.LootPointList = 0x8 // TArray<SGActorInventoryFactoryComponent*> (Size: 0x10)
UAGameModeActivityItemUpgradeComp.PumpkinActivityID = 0x100 // int32_t (Size: 0x4)
UAGameModeActivityItemUpgradeComp.FlyHorseActivityID = 0x104 // int32_t (Size: 0x4)
UAGameModeActivityItemUpgradeComp.BestFlyHorseItemID = 0x108 // uint64_t (Size: 0x8)
UAGameModeActivityManagerComp.ActivityRequireDistributers = 0x188 // TMap<...> (Size: 0x50)
UAGameModeBattleRoyalePickupManagerComponent.BirthIslandSpotPoints = 0x140 // TArray<UAPickupFactoryComponent*> (Size: 0x10)
UAGameModeBattleRoyalePickupManagerComponent.AirlineSpotPoints = 0x150 // TArray<UAPickupFactoryComponent*> (Size: 0x10)
UAGameModeChoosePlayerStartComponent.PMCPlayerSpawnintTimeOut = 0x11c // float (Size: 0x4)
UAGameModeChoosePlayerStartComponent.PMCPlayerStartMap = 0x120 // TMap<...> (Size: 0x50)
UAGameModeChoosePlayerStartComponent.ScavPlayerStartMap = 0x170 // TMap<...> (Size: 0x50)
UAGameModeChoosePlayerStartComponent.FactionOrderMap = 0x1c0 // TMap<...> (Size: 0x50)
UAGameModeChoosePlayerStartComponent.FactionPlayerStartMap = 0x210 // TMap<...> (Size: 0x50)
UAGameModePickupManagerComponent.SpotPointActors = 0x100 // TArray<Actor*> (Size: 0x10)
UAGameModePickupManagerComponent.TotalSpotPoints = 0x110 // TArray<UAPickupFactoryComponent*> (Size: 0x10)
UAGameStateActorPoolComponent.InventoryMap = 0x100 // TMap<...> (Size: 0x50)
UAGameStateActorPoolComponent.InventoryIDs = 0x150 // TArray<int32_t> (Size: 0x10)
UAGameStateActorPoolComponent.ClientCacheIndex = 0x160 // int32_t (Size: 0x4)
UAGameStateActorPoolComponent.bEnableDynamicNetworkObjPool = 0x164 // bool (Size: 0x1)
UAGameStateActorPoolComponent.DynamicInventoryType = 0x168 // TArray<EESGInventoryType> (Size: 0x10)
UAGameStateActorPoolComponent.DynamicInventoryPoolConfig = 0x178 // FPoolInventoryInfo (Size: 0x14)
UAGameStateActorPoolComponent.MaxClassNum = 0x18c // int32_t (Size: 0x4)
UAGameStateActorPoolComponent.TimeHandle = 0x190 // FTimerHandle (Size: 0x8)
UAGameStateActorPoolComponent.MillisecondPerFrame = 0x198 // float (Size: 0x4)
UAGameStateCheckPointManagerComp.OnRefreshAtCheckPoint = 0x100 // FMulticastInlineDelegate (Size: 0x10)
UAGameStateCheckPointManagerComp.OnFinishRefreshAtCheckPoint = 0x110 // FMulticastInlineDelegate (Size: 0x10)
UAGameStateCheckPointManagerComp.CurrentPC = 0x120 // PlayerController* (Size: 0x8)
UAGameStateCheckPointManagerComp.CheckPointClass = 0x128 // ClassProperty (Size: 0x8)
UAGameStateCheckPointManagerComp.QuestClass = 0x130 // ClassProperty (Size: 0x8)
UAGameStateCheckPointManagerComp.DefaultTutorialAKMInventoryClass = 0x138 // ClassProperty (Size: 0x8)
UAGameStateCheckPointManagerComp.DefaultTutorialHK416InventoryClass = 0x140 // ClassProperty (Size: 0x8)
UAGameStateCheckPointManagerComp.CurCheckPointIndex = 0x148 // int32_t (Size: 0x4)
UAGameStateCheckPointManagerComp.CurFirstWeaponID = 0x14c // int32_t (Size: 0x4)
UAGameStateCheckPointManagerComp.CurSecondWeaponID = 0x150 // int32_t (Size: 0x4)
UAGameStateCheckPointManagerComp.CheckpointArray = 0x158 // TArray<Actor*> (Size: 0x10)
UAGameStateCheckPointManagerComp.QuestArray = 0x168 // TArray<Actor*> (Size: 0x10)
UAGameStateCheckPointManagerComp.CurrentCharacter = 0x180 // SGCharacter* (Size: 0x8)
UAGameStateCheckPointManagerComp.CurrentCheckPoint = 0x188 // SGPlayerStart* (Size: 0x8)
UAGameStateCheckPointManagerComp.IsSkipA = 0x190 // bool (Size: 0x1)
UAGameStateDeathDropComponent.OneTickMaxSecondCost = 0x158 // float (Size: 0x4)
UAGameStateDeathDropComponent.DeathDropTypeConfigID = 0x15c // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.DuplicationDropRateConfigID = 0x160 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.ConvertToMoneyItemCountCoefficientConfigID = 0x164 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.MaxValueAdapterConvertRateConfigID = 0x168 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.ConvertWeightPowConfigID = 0x16c // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.MoneyItemIDConfigID = 0x170 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.ItemTotalValueToMoneyCoefficientConfigID = 0x174 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.ArmorDurabilityConvertCoefficientConfigID = 0x178 // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.HighValueItemConvertCoefficientConfigID = 0x17c // int32_t (Size: 0x4)
UAGameStateDeathDropComponent.PlayerItemGroupReplaceInfos = 0x180 // TArray<FPlayerItemGroupReplaceInfo> (Size: 0x10)
UAGameStateDeathDropComponent.DeathDropReplaceATable = 0x190 // DataTable* (Size: 0x8)
UAGameStateDeathDropComponent.DeathDropReplaceBTable = 0x198 // DataTable* (Size: 0x8)
UAGameStateDeathDropComponent.DeathDropReplacePoolTable = 0x1a0 // DataTable* (Size: 0x8)
UAGameStateDebugShowPoints.DebugDelaySeconds = 0x100 // float (Size: 0x4)
UAGameStateDebugShowPoints.DebugShowPointInfos = 0x108 // TArray<FDebugShowPointInfo> (Size: 0x10)
UAGameStateDebugShowPoints.AnchorActors = 0x118 // TArray<Actor*> (Size: 0x10)
UAGameStateGameTypeComponent.MainGameModeType = 0x100 // EEMainGameModeType (Size: 0x1)
UAGameStateGameTypeComponent.SubGameModeType = 0x102 // EESubGameModeType (Size: 0x2)
UAGameStateGameTypeComponent.MapID = 0x104 // EEGameMapId (Size: 0x1)
UAGameStateGameTypeComponent.MatchType = 0x105 // EEGameMatchType (Size: 0x1)
UAGameStateGameTypeComponent.TeamType = 0x106 // EEGameTeamType (Size: 0x1)
UAGameStateIntelligenceComponent.IntelligenceKeyTookOutPS = 0x1d8 // SGPlayerState* (Size: 0x8)
UAGameStateIntelligenceComponent.TraceConfigID = 0x1e8 // int32_t (Size: 0x4)
UAGameStateIntelligenceComponent.NoOwnerTraceConfigID = 0x1ec // int32_t (Size: 0x4)
UAGameStateIntelligenceComponent.FirstTimeTraceDelay = 0x1f0 // float (Size: 0x4)
UAGameStateIntelligenceComponent.NoOwnerTraceDelay = 0x1f4 // float (Size: 0x4)
UAGameStateIntelligenceComponent.TraceShowDuration = 0x1f8 // float (Size: 0x4)
UAGameStateIntelligenceComponent.TraceUpdateInterval = 0x1fc // float (Size: 0x4)
UAGameStateIntelligenceComponent.bIsIntelligenceExposed = 0x201 // bool (Size: 0x1)
UAGameStateRandomTeamPlayerStartComponent.RandomTeamIndexArray = 0x100 // TArray<int32_t> (Size: 0x10)
UAGameStateStatisComponent.LootBoxNameTool = 0x840 // FUALootBoxNameTool (Size: 0xc0)
UAGameStateStatisComponent.bIsNeedSendRefreshInfo = 0x900 // bool (Size: 0x1)
UAGameStateTODTimeComponent.CurrentWeatherWeights = 0x108 // TArray<float> (Size: 0x10)
UAGameStateTODTimeComponent.WeatherToAudioState = 0x118 // TMap<...> (Size: 0x50)
UAGameStateTODTimeComponent.DefaultDayBeginHour = 0x168 // int32_t (Size: 0x4)
UAGameStateTODTimeComponent.bEnableScheduledWeather = 0x16c // bool (Size: 0x1)
UAGameStateTODTimeComponent.WeatherBlendTime = 0x170 // float (Size: 0x4)
UAGameStateTODTimeComponent.bFixOnFirstWeather = 0x174 // bool (Size: 0x1)
UAGameStateTODTimeComponent.WeatherBlendingProgress = 0x178 // float (Size: 0x4)
UAGameStateTODTimeComponent.ScheduledWeathers = 0x180 // TArray<int32_t> (Size: 0x10)
UAGameStateTODTimeComponent.BlendingFromPresets = 0x190 // TArray<float> (Size: 0x10)
UAGameStateTODTimeComponent.BlendingToPresets = 0x1a0 // TArray<float> (Size: 0x10)
UAGameStateTODTimeComponent.CustomBlendingWeatherProgress = 0x1b0 // float (Size: 0x4)
UAGameStateTODTimeComponent.CustomBlendingTime = 0x1b4 // float (Size: 0x4)
UAGameStateTODTimeComponent.bCustomBlendingWeather = 0x1b8 // bool (Size: 0x1)
UAGameStateTODTimeComponent.bEnableScheduledTODUpdate = 0x1b9 // bool (Size: 0x1)
UAGameStateTODTimeComponent.bFixOnFirstTODTime = 0x1ba // bool (Size: 0x1)
UAGameStateTODTimeComponent.TimeflowRate = 0x1bc // float (Size: 0x4)
UAGameStateTODTimeComponent.TodUpdateMax = 0x1c0 // float (Size: 0x4)
UAGameStateTODTimeComponent.CurrentTimeInSeconds = 0x1c4 // float (Size: 0x4)
UAGameStateTODTimeComponent.GameStartTodSeconds = 0x1c8 // int32_t (Size: 0x4)
UAGameStateTODTimeComponent.CustomBlendingTodProgress = 0x1cc // float (Size: 0x4)
UAGameStateTODTimeComponent.CustomBlendingTodTime = 0x1d0 // float (Size: 0x4)
UAGameStateTODTimeComponent.CustomBlendingTodEnd = 0x1d4 // float (Size: 0x4)
UAGameStateTODTimeComponent.CustomBlendingTodStart = 0x1d8 // float (Size: 0x4)
UAGameStateTODTimeComponent.bCustomBlendingTod = 0x1dc // bool (Size: 0x1)
UAGameStateTraceComponent.MinScanInterval = 0x100 // float (Size: 0x4)
UAGameStateTraceComponent.AllPlayerStateTraceComponents = 0x108 // TArray<UAPlayerStateTraceComponent*> (Size: 0x10)
UAGameStateTraceComponent.TrackPlayerInfos = 0x118 // TArray<FTrackPlayerInfo> (Size: 0x10)
UAGameStateTraceComponent.GlobalTraceableActorInfos = 0x128 // TArray<FTraceableActorInfo> (Size: 0x10)
UAGameStateTraceComponent.TeamInfoTraceableActorsMap = 0x138 // TMap<...> (Size: 0x50)
UAGameStateTraceComponent.PlayerTeamTypeTraceableActorsMap = 0x188 // TMap<...> (Size: 0x50)
UAGameStateTraceComponent.FactionTypeTraceableActorsMap = 0x1d8 // TMap<...> (Size: 0x50)
UAGameStateTraceComponent.InventoryProxies = 0x228 // TArray<GameStateTraceableInventoryProxy*> (Size: 0x10)
UAGashaponCoinSpawnPoint.GashaCoinClass = 0x310 // ClassProperty (Size: 0x8)
UAGashaponCoinSpawnPoint.bAlwaysSpawn = 0x318 // bool (Size: 0x1)
UAGashaponCoinSpawnPoint.bHaveSpawned = 0x319 // bool (Size: 0x1)
UAGashaponSpawnPoint.GashaponClass = 0x310 // ClassProperty (Size: 0x8)
UAGashaponSpawnPoint.GashaponName = 0x318 // FString (Size: 0x10)
UAGashaponSpawnPoint.bAlwaysSpawn = 0x328 // bool (Size: 0x1)
UAGashaponSpawnPoint.SpawnItemID = 0x32c // int32_t (Size: 0x4)
UAGashaponSpawnPoint.Capacity = 0x330 // int32_t (Size: 0x4)
UAGashaponSpawnPoint.CharacterUsageCounter = 0x334 // int32_t (Size: 0x4)
UAGashaponSpawnPoint.OnceSpawnCount = 0x338 // int32_t (Size: 0x4)
UAGashaponSpawnPoint.InteractionExpressionTime = 0x33c // float (Size: 0x4)
UAGashaponSpawnPoint.GashaponSpawnInventoryGears = 0x340 // TMap<...> (Size: 0x50)
UAGashaponSpawnPoint.SpendInventoryInfoList = 0x390 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAHUDWidget_BigMapBase.Modules = 0x318 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAHUDWidget_BigMapBase.LoadedModules = 0x328 // TArray<UABigMapModuleBase*> (Size: 0x10)
UAHUDWidget_BigMapBase.CurTouchResponse = 0x338 // EEBigMapTouchResponseType (Size: 0x1)
UAHUDWidget_BigMapBase.MobileInputDataList = 0x340 // TArray<FMobileInputData> (Size: 0x10)
UAHUDWidget_BigMapBase.ChildWidgets = 0x350 // TArray<ClassProperty> (Size: 0x10)
UAHUDWidget_ChaseActivityInvMark.DisplayTraceInfoList = 0x308 // TArray<FNewTraceableActorInfo> (Size: 0x10)
UAHUDWidget_ChaseActivityInvMark.ActiveSubWidgetMap = 0x318 // TMap<...> (Size: 0x50)
UAHUDWidget_ChaseActivityInvMark.DisplayCanvasPanel = 0x368 // PanelWidget* (Size: 0x8)
UAHUDWidget_ChaseActivityInvMark.SubWidgetClass = 0x370 // ClassProperty (Size: 0x8)
UAHUDWidget_ChaseActivityInvMark.CorpseHeadOffset = 0x378 // FVector (Size: 0xc)
UAHUDWidget_ChaseActivityInvMark.EffectDistance = 0x384 // float (Size: 0x4)
UAHUDWidget_ChaseActivityInvMark.ColorOnVisible = 0x388 // FLinearColor (Size: 0x10)
UAHUDWidget_ChaseActivityInvMark.ColorOnInvisible = 0x398 // FLinearColor (Size: 0x10)
UAHUDWidget_ChaseActivityInvMark.MinDistanceScale = 0x3a8 // FChaseActivityInvMarkScaleInfo (Size: 0x8)
UAHUDWidget_ChaseActivityInvMark.MaxDistanceScale = 0x3b0 // FChaseActivityInvMarkScaleInfo (Size: 0x8)
UAHUDWidget_NewMapPanel.GlobalModuleList = 0x2f0 // TArray<TSoftClassPtr<UObject>> (Size: 0x10)
UAHUDWidget_NewMapPanel.CurTouchResponse = 0x300 // EENewMapTouchResponseType (Size: 0x1)
UAHUDWidget_NewMapPanel.CurDisplayModel = 0x301 // EENewMapDisplayModel (Size: 0x1)
UAHUDWidget_NewMapPanel.LoadedModules = 0x308 // TArray<UANewMapModuleBase*> (Size: 0x10)
UAHUDWidget_NewMapPanel.bTouchMoved = 0x318 // bool (Size: 0x1)
UAHUDWidget_NewMapPanel.IsOpenMap = 0x319 // bool (Size: 0x1)
UAHUDWidget_NewMapPanel.MobileInputDataList = 0x360 // TArray<FMobileInputData> (Size: 0x10)
UAHUDWidget_NewMapPanel.TopLeft2ButtomLeft = 0x370 // FVector2D (Size: 0x8)
UAHUDWidget_NewMapPanel.TopLeft2TopRight = 0x378 // FVector2D (Size: 0x8)
UAHUDWidget_NewMapPanel.MapSize = 0x380 // FVector2D (Size: 0x8)
UAHUDWidget_NewMapPanel.MapUVOffset = 0x388 // FVector2D (Size: 0x8)
UAHUDWidget_NewMapPanel.MapExtend = 0x390 // FVector2D (Size: 0x8)
UAHUDWidget_NewMapPanel.MapScale = 0x398 // float (Size: 0x4)
UAHUDWidget_NewMapPanel.CurAreaID = 0x39c // int32_t (Size: 0x4)
UAHUDWidget_NewMapPanel.CurLayer = 0x3a0 // int32_t (Size: 0x4)
UAHUDWidget_NewMapPanel.MoveSpeed = 0x3a4 // float (Size: 0x4)
UAHUDWidget_NewMapPanel.PinchedSpeed = 0x3a8 // float (Size: 0x4)
UAHUDWidget_NewMapPanel.MaxMapScale = 0x3ac // float (Size: 0x4)
UAHUDWidget_NewMapPanel.MapTickFrequency = 0x3b0 // float (Size: 0x4)
UAHUDWidget_NewMapPanel.IntervalTime = 0x3b4 // float (Size: 0x4)
UAHUDWidget_NewMapPanel.ImageMap = 0x3b8 // Image* (Size: 0x8)
UAHUDWidget_NewMapPanel.CanvasPanelMap = 0x3c0 // CanvasPanel* (Size: 0x8)
UAHUDWidget_NewMapPanel.MapTextureMID = 0x3c8 // MaterialInstanceDynamic* (Size: 0x8)
UAHUDWidget_NewMapPanel.NewMapSizeChangeInterfaces = 0x3d0 // TArray<Object*> (Size: 0x10)
UAHUDWidget_NewMapPanel.NewMapOffsetChangeInterfaces = 0x3e0 // TArray<Object*> (Size: 0x10)
UAHUDWidget_NewMapPanel.NewMapTickInterfaces = 0x3f0 // TArray<Object*> (Size: 0x10)
UAHUDWidget_NewMapPanel.NewMapScaleChangeInterfaces = 0x400 // TArray<Object*> (Size: 0x10)
UAHUDWidget_NewMapPanel.NewMapAreaChangeInterfaces = 0x410 // TArray<Object*> (Size: 0x10)
UAHUDWidget_NewMapPanel.MapActionKey = 0x420 // FKey (Size: 0x18)
UAHUDWidget_NewMapPanel.ChildWidgets = 0x438 // TArray<ClassProperty> (Size: 0x10)
UAHUDWidget_NewMapPanel.bDisableSetMapUVOffset = 0x448 // bool (Size: 0x1)
UAHUDWidget_NewMapPanel.bDisableSetMapScale = 0x449 // bool (Size: 0x1)
UAHUDWidget_NewMapPanel.SizeReferenceWidget = 0x450 // Widget* (Size: 0x8)
UAHUDWidget_ReplayPlayer.bEnableListenCharacters = 0x2f0 // bool (Size: 0x1)
UAHUDWidget_ReplayPlayer.TimeText = 0x2f8 // TextBlock* (Size: 0x8)
UAHUDWidget_ReplayPlayer.TimeSlider = 0x300 // Slider* (Size: 0x8)
UAHUDWidget_ReplayPlayer.FollowCharacterComboBox = 0x308 // ComboBoxString* (Size: 0x8)
UAHUDWidget_ReplayPlayer.ReplayCurrentTime = 0x310 // float (Size: 0x4)
UAHUDWidget_ReplayPlayer.ReplayCurrentMinutes = 0x314 // int32_t (Size: 0x4)
UAHUDWidget_ReplayPlayer.ReplayCurrentSeconds = 0x318 // int32_t (Size: 0x4)
UAHUDWidget_ReplayPlayer.ReplayTotalTime = 0x31c // float (Size: 0x4)
UAHUDWidget_ReplayPlayer.ReplayTotalMinutes = 0x320 // int32_t (Size: 0x4)
UAHUDWidget_ReplayPlayer.ReplayTotalSeconds = 0x324 // int32_t (Size: 0x4)
UAHUDWidget_ReplayPlayer.PlayerCharacterNames = 0x338 // TArray<FString> (Size: 0x10)
UAHUDWidget_ReplayPlayer.AICharacterNames = 0x358 // TArray<FString> (Size: 0x10)
UAHUDWidget_ScanDevicePanel.CanvasPanelMap = 0x308 // CanvasPanel* (Size: 0x8)
UAHUDWidget_ScanDevicePanel.TopLeft2ButtomLeft = 0x310 // FVector2D (Size: 0x8)
UAHUDWidget_ScanDevicePanel.TopLeft2TopRight = 0x318 // FVector2D (Size: 0x8)
UAHUDWidget_ScanDevicePanel.MapSize = 0x320 // FVector2D (Size: 0x8)
UAHUDWidget_ScanDevicePanel.MapUVOffset = 0x328 // FVector2D (Size: 0x8)
UAHUDWidget_ScanDevicePanel.MapExtend = 0x330 // FVector2D (Size: 0x8)
UAHUDWidget_ScanDevicePanel.MapScale = 0x338 // float (Size: 0x4)
UAHUDWidget_ScanDevicePanel.CurAreaID = 0x33c // int32_t (Size: 0x4)
UAHUDWidget_ScanDevicePanel.CurLayer = 0x340 // int32_t (Size: 0x4)
UAHUDWidget_ScanDevicePanel.SizeReferenceWidget = 0x348 // Widget* (Size: 0x8)
UAHUDWidget_ShootTest.WeaponNames = 0x2f0 // TArray<FString> (Size: 0x10)
UAHUDWidget_ShootTest.Weapon = 0x300 // SGInventory* (Size: 0x8)
UAHUDWidget_ShootTest.bIsShooting = 0x308 // bool (Size: 0x1)
UAHUDWidget_ShootTest.TargetShootCount = 0x30c // int32_t (Size: 0x4)
UAHUDWidget_ShootTest.RealShootCount = 0x310 // int32_t (Size: 0x4)
UAInteractComponentBase.CostInventoryInfos = 0x160 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAInteractComponentBase.ObtainInventoryInfos = 0x170 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAInteractComponentBase.bCheckCostBeforePopWidget = 0x180 // bool (Size: 0x1)
UAInteractComponentBase.OnInteractiveSuccessful = 0x188 // FMulticastInlineDelegate (Size: 0x10)
UAInteractComponentBase.InteractCompletePlayers = 0x198 // TArray<PlayerController*> (Size: 0x10)
UAInteractComponentBase.bInteractEnable = 0x1a8 // bool (Size: 0x1)
UAInteractComponentBase.bInteractEnableReplicate = 0x1a9 // bool (Size: 0x1)
UAInteractComponentBase.DisableMessageId = 0x1ac // int32_t (Size: 0x4)
UAInteractComponentBase.InteractCount = 0x1b0 // int32_t (Size: 0x4)
UAInteractComponentBase.RelevantID = 0x1b4 // int32_t (Size: 0x4)
UAInteractComponentBase.AIIDPrefixs = 0x1b8 // TArray<FString> (Size: 0x10)
UAInteractVolume.TextStr = 0x398 // FString (Size: 0x10)
UAInteractVolume.UAVolumeInteractComp = 0x3a8 // UAVolumeInteractComponent* (Size: 0x8)
UAInteractVolume.InteractedShowComp = 0x3b0 // SGShowControlComponent* (Size: 0x8)
UAInteractVolume.UninteractedShowComp = 0x3b8 // SGShowControlComponent* (Size: 0x8)
UAInventoryDetectorComponent.AppearanceParams = 0x1088 // FUADetectorAppearanceParams (Size: 0x80)
UAInventoryFulton.FastRecycleID = 0x8d8 // int32_t (Size: 0x4)
UAInventoryInitDataComponent.bInitFromDataTable = 0x108 // bool (Size: 0x1)
UAInventoryPoolComponent.PoolConfig = 0x100 // TArray<FInventoryPoolConfig> (Size: 0x10)
UAInventoryPoolComponent.IsAutoPullBolt = 0x110 // bool (Size: 0x1)
UAInventoryPoolComponent.PoolInvAry = 0x118 // TArray<SGInventory*> (Size: 0x10)
UAInventoryPoolComponent.PoolUnitMap = 0x128 // TMap<...> (Size: 0x50)
UAInventoryPoolUnit.PoolConfig = 0x30 // FInventoryPoolConfig (Size: 0x28)
UAInventoryPoolUnit.PoolAry = 0x58 // TArray<SGInventory*> (Size: 0x10)
UAInventoryPoolUnit.InvPartAry = 0x68 // TArray<SGInventory*> (Size: 0x10)
UAInventoryPoolUnit.Owner = 0x90 // Object* (Size: 0x8)
UAInventoryQuestInfoComponent.RelevantQuest = 0x100 // MFQuestBase* (Size: 0x8)
UAInventoryQuestInfoComponent.bDestroyWhenLoseOwner = 0x108 // bool (Size: 0x1)
UAIrrelevantAreaVolume.AreaID = 0x348 // int32_t (Size: 0x4)
UAItemInteractComponent.InteractDistance = 0x1c8 // float (Size: 0x4)
UAItemInteractComponent.bDestroyOnComplete = 0x1cc // bool (Size: 0x1)
UALifeDetectorComponent.PowerParam1Key = 0x1298 // FName (Size: 0x8)
UALifeDetectorComponent.PowerParam2Key = 0x12a0 // FName (Size: 0x8)
UALifeDetectorComponent.PowerLengthParam = 0x12a8 // FName (Size: 0x8)
UALifeDetectorComponent.ScanResultPrefix = 0x12b0 // FName (Size: 0x8)
UALifeDetectorComponent.PowerColorParamKey = 0x12b8 // FName (Size: 0x8)
UALifeDetectorComponent.PowerColorThreshold = 0x12c0 // float (Size: 0x4)
UALifeDetectorComponent.PowerColorSmallParam = 0x12c4 // FVector (Size: 0xc)
UALifeDetectorComponent.PowerColorBigParam = 0x12d0 // FVector (Size: 0xc)
UALifeDetectorComponent.DistanceParam1Key = 0x12dc // FName (Size: 0x8)
UALifeDetectorComponent.DistanceParam2Key = 0x12e4 // FName (Size: 0x8)
UALifeDetectorComponent.DistanceScaleParam = 0x12ec // float (Size: 0x4)
UALifeDetectorComponent.AlphaKeyParam = 0x12f0 // FString (Size: 0x10)
UALifeDetectorComponent.AlphaDivisorParam1 = 0x1300 // int32_t (Size: 0x4)
UALifeDetectorComponent.AlphaDivisorParam2 = 0x1304 // int32_t (Size: 0x4)
UALifeDetectorComponent.BrightnessMaxNum = 0x1308 // int32_t (Size: 0x4)
UALightFadeComponent.DistanceOffest = 0xf8 // float (Size: 0x4)
UALightFadeComponent.DefaultIntensity = 0xfc // float (Size: 0x4)
UALockLootContainer.ConditionType = 0x8a0 // EELockLootContainerConditionType (Size: 0x1)
UALockLootContainer.CostInventoryInfos = 0x8a8 // TArray<FInteractInventoryInfo> (Size: 0x10)
UALockLootContainer.MissionFlowName = 0x8b8 // FString (Size: 0x10)
UALockLootContainer.UnLockTime = 0x8c8 // int32_t (Size: 0x4)
UALockLootContainer.StartUnLockDateTime = 0x8d0 // FDateTime (Size: 0x8)
UALockLootContainer.AkAudioEventOnUnLocking = 0x8d8 // AkAudioEvent* (Size: 0x8)
UALockLootContainer.AkAudioEventOnUnLock = 0x8e0 // AkAudioEvent* (Size: 0x8)
UALockLootContainer.CurFSMState = 0x8e8 // FString (Size: 0x10)
UALockLootContainer.LeftUnLockTime = 0x8f8 // float (Size: 0x4)
UALockLootContainer.FSMComp = 0x900 // UAFSMComponent* (Size: 0x8)
UALootBoxNameTool.TextForFindTableID = 0x0 // FText (Size: 0x18)
UALootCombinPickup.CombinArray = 0x310 // TArray<FCombinPickupData> (Size: 0x10)
UALootSubAreaVolume.Name = 0x3d0 // FString (Size: 0x10)
UALootSubAreaVolume.CurMapID = 0x3e0 // int32_t (Size: 0x4)
UALootSubAreaVolume.PickupList = 0x3e8 // TArray<SGPickup*> (Size: 0x10)
UALootSubAreaVolume.IsHeatMapVolume = 0x3f8 // bool (Size: 0x1)
UALootSubAreaVolume.BattleIntensityExpectation = 0x3f9 // EEBattleIntensityExpectation (Size: 0x1)
UALootSubAreaVolume.Inventories = 0x400 // TArray<SGInventory*> (Size: 0x10)
UALootSubAreaVolume.bHasRegisterPickups = 0x410 // bool (Size: 0x1)
UALootSubAreaVolume.FirstUnLockTime = 0x414 // float (Size: 0x4)
UALootSubAreaVolume.UnLockTimes = 0x418 // int32_t (Size: 0x4)
UALootSubsystem.PylonPoints = 0x38 // TMap<...> (Size: 0x50)
UALootSubsystem.MapID = 0x88 // int32_t (Size: 0x4)
UALootSubsystem.bDebugPickupInventory = 0x98 // bool (Size: 0x1)
UALootSubsystem.ClientPickupableInventories = 0xa0 // TMap<...> (Size: 0x50)
UALootSubsystem.InventoryOldKeys = 0xf0 // TMap<...> (Size: 0x50)
UAMCOMInteractComponent.InventoryLocOffset = 0x1c8 // FVector (Size: 0xc)
UAMCOMInteractComponent.CacheCostInventoryInfos = 0x1d8 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAMCOMInteractComponent.CacheCostInventorys = 0x1e8 // TArray<SGInventory*> (Size: 0x10)
UAMTutorialMoveToVolume.ParticleSystemComponent = 0x398 // ParticleSystemComponent* (Size: 0x8)
UAMTutorialMoveToVolume.Particle = 0x3a0 // ParticleSystem* (Size: 0x8)
UAMTutorialMoveToVolume.NiagaraComponent = 0x3a8 // NiagaraComponent* (Size: 0x8)
UAMTutorialMoveToVolume.Niagara = 0x3b0 // NiagaraSystem* (Size: 0x8)
UAMarkComponent.MarkRadius = 0x114 // float (Size: 0x4)
UAMarkComponent.MaxMarkDistance = 0x118 // float (Size: 0x4)
UAMarkComponent.MarkPreparationTime = 0x11c // float (Size: 0x4)
UAMarkComponent.MarkContinueTime = 0x120 // float (Size: 0x4)
UAMarkComponent.CurDistance = 0x124 // float (Size: 0x4)
UAMarkedData.MarkedType = 0x0 // EEUAMarkedType (Size: 0x1)
UAMarkedData.MarkedContinueTime = 0x4 // float (Size: 0x4)
UAMissionAction_ActivatePickupGroup.PickupGroups = 0x48 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_AddAIToTeam.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_AddAIToTeam.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_AddAIToTeam.FactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_AddAIToTeam.AIID = 0x70 // int32_t (Size: 0x4)
UAMissionAction_AddDoorLimitedFaction.FactionType = 0x48 // EEFactionType (Size: 0x1)
UAMissionAction_AddDoorLimitedFaction.DoorActorArray = 0x50 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_AddFactionScore.Faction = 0x48 // EEFactionType (Size: 0x1)
UAMissionAction_BindFactionScore.BindFaction = 0x48 // EEFactionType (Size: 0x1)
UAMissionAction_BindFactionScore.TotleName = 0x50 // FText (Size: 0x18)
UAMissionAction_BroadcastOnGameHUD.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_BroadcastOnGameHUD.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_BroadcastOnGameHUD.RelatedFactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_BroadcastOnGameHUD.GameHUDConfigs = 0x70 // TArray<FBroadcastOnGameHUDConfig> (Size: 0x10)
UAMissionAction_ChangeDoorType.DoorActor = 0x48 // FMissionActorReference (Size: 0x18)
UAMissionAction_ChangeDoorType.DoorActorArr = 0x60 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_ChangeDoorType.Type = 0x70 // EESGDoorOpenType (Size: 0x1)
UAMissionAction_ChangeLimitAreaState.StateType = 0x48 // EELimitAreaStateType (Size: 0x1)
UAMissionAction_CleanUpForRound.IncludeAllInventory = 0x48 // bool (Size: 0x1)
UAMissionAction_CleanUpForRound.IncludeAllAICharacter = 0x49 // bool (Size: 0x1)
UAMissionAction_CleanUpForRound.NeedRestDoors = 0x50 // TMap<...> (Size: 0x50)
UAMissionAction_ConfigScorePanel.ModifyConfigType = 0x48 // EEScorePanelConfigType (Size: 0x1)
UAMissionAction_ConfigScorePanel.ScoreConfig = 0x50 // FScorePanelConfig_Score (Size: 0x20)
UAMissionAction_ConfigScorePanel.TimeConfig = 0x70 // FScorePanelConfig_Time (Size: 0xc)
UAMissionAction_DeactivateObjective.ModifyNodeNameList = 0x48 // TArray<FString> (Size: 0x10)
UAMissionAction_DeactivateObjective.ModifyNodeList = 0x58 // TArray<MFMissionFlowNode*> (Size: 0x10)
UAMissionAction_DeactivateObjective.bOnlyApplyToInstigator = 0x68 // bool (Size: 0x1)
UAMissionAction_DeleteActor.DeleteActors = 0x48 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_DisableInteract.bDisableInteract = 0x48 // bool (Size: 0x1)
UAMissionAction_DisableInteract.VolumeNames = 0x50 // TArray<FString> (Size: 0x10)
UAMissionAction_DisableInteract.ValidVolumes = 0x60 // TArray<SGVolume*> (Size: 0x10)
UAMissionAction_DistributeMission.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_DistributeMission.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_DistributeMission.RelatedTeamTypes = 0x60 // TArray<EEMissionRelatedTeamType> (Size: 0x10)
UAMissionAction_DistributeMission.RelatedFactionTypes = 0x70 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_DistributeMission.DistributeMissionType = 0x80 // EEDistributeMissionType (Size: 0x1)
UAMissionAction_DistributeMission.bUseRandomMissionable = 0x81 // bool (Size: 0x1)
UAMissionAction_DistributeMission.MissionFlowID = 0x84 // int32_t (Size: 0x4)
UAMissionAction_DistributeMission.RandomMissionTable = 0x88 // DataTable* (Size: 0x8)
UAMissionAction_DistributeMission.TeamInfoDistributeMissions = 0x98 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAMissionAction_DistributeMission.PlayerTeamTypeDistributeMissions = 0xa8 // TArray<EEPlayerTeamType> (Size: 0x10)
UAMissionAction_EscapeConditions.Tips = 0x48 // FString (Size: 0x10)
UAMissionAction_EscapeConditions.EscapeVolumes = 0x58 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_EscapeConditions.EscapeConditionsType = 0x68 // EEEscapeConditionsType (Size: 0x1)
UAMissionAction_EscapeConditions.EscapeConditionsChangeType = 0x69 // EEEscapeConditionsChangeType (Size: 0x1)
UAMissionAction_EscapeConditions.CheckObjects = 0x70 // TArray<UAFSMCheckObject*> (Size: 0x10)
UAMissionAction_EscapeVolumState.EscapeVolumes = 0x48 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_EscapeVolumState.NewEscapeVolumes = 0x58 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
UAMissionAction_EscapeVolumState.NewTargetState = 0x68 // EEEscapeState (Size: 0x1)
UAMissionAction_EscapeVolumState.LimitState = 0x70 // TArray<EEEscapeState> (Size: 0x10)
UAMissionAction_EscapeVolumState.bSetTriggerPlayerController = 0x80 // bool (Size: 0x1)
UAMissionAction_ForbidContainerInteract.ForbidInteractFactionList = 0x48 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_ForbidContainerInteract.ForbidInteractConfigMsg = 0x58 // FString (Size: 0x10)
UAMissionAction_ForbidContainerInteract.ContainerActorArray = 0x68 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_ForbidContainerInteract.AllPickupActors = 0x78 // TArray<Actor*> (Size: 0x10)
UAMissionAction_ForceFightSettled.WinnerFactionType = 0x48 // EEFactionType (Size: 0x1)
UAMissionAction_GameShowControl.bActive = 0x48 // bool (Size: 0x1)
UAMissionAction_GameShowControl.ShowControlActors = 0x50 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_GiveItem.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_GiveItem.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_GiveItem.GiveItemInfos = 0x60 // TArray<FMissionActionGiveItemInfo> (Size: 0x10)
UAMissionAction_InventorySrcType.OrderFaction = 0x48 // EEFactionType (Size: 0x1)
UAMissionAction_InventorySrcType.OrderCharacterTypeTypes = 0x50 // TArray<EECharacterType> (Size: 0x10)
UAMissionAction_InventorySrcType.ChangeSourceType = 0x60 // EESGTakeInSourceType (Size: 0x1)
UAMissionAction_InvokeAnnounce.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_InvokeAnnounce.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_InvokeAnnounce.RelatedFactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_InvokeAnnounce.AnnounceInvokeConfigs = 0x70 // TArray<FAnnounceInvokeConfig> (Size: 0x10)
UAMissionAction_InvokeAnnounce.bSendForDead = 0x80 // bool (Size: 0x1)
UAMissionAction_InvokeToast.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_InvokeToast.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_InvokeToast.RelatedFactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_InvokeToast.ToastKeys = 0x70 // TArray<FString> (Size: 0x10)
UAMissionAction_LetVolumeInteractable.MapIDs = 0x48 // TArray<int32_t> (Size: 0x10)
UAMissionAction_LetVolumeInteractable.VolumeNames = 0x58 // TArray<FString> (Size: 0x10)
UAMissionAction_LetVolumeInteractable.ConfigID = 0x68 // int32_t (Size: 0x4)
UAMissionAction_LetVolumeInteractable.bEnterVolumeAutoComplete = 0x6c // bool (Size: 0x1)
UAMissionAction_LetVolumeInteractable.UserWidgetPopInfo = 0x70 // FUserWidgetPopInfo (Size: 0x48)
UAMissionAction_LetVolumeInteractable.bCheckCostBeforePopWidget = 0xb8 // bool (Size: 0x1)
UAMissionAction_LetVolumeInteractable.CostInventoryInfos = 0xc0 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAMissionAction_LetVolumeInteractable.ObtainInventoryInfos = 0xd0 // TArray<FInteractInventoryInfo> (Size: 0x10)
UAMissionAction_LetVolumeInteractable.ValidVolumes = 0xe0 // TArray<SGVolume*> (Size: 0x10)
UAMissionAction_ModifyAreaAIPool.AreaName = 0x48 // FString (Size: 0x10)
UAMissionAction_ModifyAreaAIPool.NewAIPool = 0x58 // TArray<FAIPoolInfo> (Size: 0x10)
UAMissionAction_ModifyAreaAIPool.MaxAINum = 0x68 // int32_t (Size: 0x4)
UAMissionAction_ModifyEscapePoint.TickTimerHandle = 0x48 // FTimerHandle (Size: 0x8)
UAMissionAction_ModifyEscapePoint.RelatedTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_ModifyEscapePoint.RelatedTargetTypes = 0x58 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.RelatedFactionTypes = 0x68 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.bAddEscapePoint = 0x78 // bool (Size: 0x1)
UAMissionAction_ModifyEscapePoint.RandomEscapePoint = 0x7c // int32_t (Size: 0x4)
UAMissionAction_ModifyEscapePoint.RandomEscapePointIDs = 0x80 // TArray<FMissionActionRandomEscapePoint> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.EscapePointIDs = 0x90 // TArray<int32_t> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.NewEscapePointIDs = 0xa0 // TArray<FMFMissionVariableRead_Int> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.bCheckEscapePreset = 0xb0 // bool (Size: 0x1)
UAMissionAction_ModifyEscapePoint.EscapePresetNames = 0xb8 // TArray<FString> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.DelayTime = 0xc8 // float (Size: 0x4)
UAMissionAction_ModifyEscapePoint.OrderState = 0xd0 // TArray<EEEscapeState> (Size: 0x10)
UAMissionAction_ModifyEscapePoint.CacheData = 0xe0 // TMap<...> (Size: 0x50)
UAMissionAction_ModifyTraceableActor.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_ModifyTraceableActor.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_ModifyTraceableActor.RelatedFactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_ModifyTraceableActor.ActorMarkables = 0x70 // TArray<FMissionActionActorMarkableInfo> (Size: 0x10)
UAMissionAction_ModifyTraceableActor.AICharacterMarkables = 0x80 // TArray<FMissionActionAICharacterMarkableInfo> (Size: 0x10)
UAMissionAction_ModifyTraceableActor.InventoryMarkables = 0x90 // TArray<FMissionActionInventoryMarkableInfo> (Size: 0x10)
UAMissionAction_ModifyTraceableActor.VolumeMarkables = 0xa0 // TArray<FMissionActionVolumeMarkableInfo> (Size: 0x10)
UAMissionAction_MonitorTakeDamageItem.TakeDamageActorVar = 0x48 // FMFMissionVariableRead_ActorReference (Size: 0x40)
UAMissionAction_MonitorTakeDamageItem.CompareType = 0x88 // EEMissionCompareType (Size: 0x1)
UAMissionAction_MonitorTakeDamageItem.ComparisonNumber = 0x8c // int32_t (Size: 0x4)
UAMissionAction_MonitorTakeDamageItem.ComparisonNumberMin = 0x90 // int32_t (Size: 0x4)
UAMissionAction_MonitorTakeDamageItem.ComparisonNumberMax = 0x94 // int32_t (Size: 0x4)
UAMissionAction_MonitorTakeDamageItem.bSuccessOrFailedWhenConditionPass = 0x98 // bool (Size: 0x1)
UAMissionAction_MonitorTakeDamageItem.TakeDamageActor = 0xa0 // SGTakeDamageItem* (Size: 0x8)
UAMissionAction_MonitorTakeDamageItem.Instigators = 0xa8 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAMissionAction_MoveActor.MoveActorArr = 0x48 // TArray<FSGSceneMoveActorRaw> (Size: 0x10)
UAMissionAction_RecBrilliantTime.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_RecBrilliantTime.DuplicatePreventionKeyActorTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_RecBrilliantTime.TimeForwardOffsetMilliseconds = 0x58 // int32_t (Size: 0x4)
UAMissionAction_RecBrilliantTime.TimeBackwardOffsetMilliseconds = 0x5c // int32_t (Size: 0x4)
UAMissionAction_RefreshTakeDamageItem.ActorRefs = 0x48 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_RefreshTakeDamageItem.bEnableTakeDamage = 0x58 // bool (Size: 0x1)
UAMissionAction_RefreshTakeDamageItem.bResetHP = 0x59 // bool (Size: 0x1)
UAMissionAction_RegisterSceneEvent.SceneEventNum = 0x48 // int32_t (Size: 0x4)
UAMissionAction_RegisterSceneEvent.SceneEventInfos = 0x50 // TArray<FMissionObjectiveSceneEventInfo> (Size: 0x10)
UAMissionAction_RelevantToActors.RelatedTargets = 0x48 // TArray<Actor*> (Size: 0x10)
UAMissionAction_RelevantToActors.RelevantToInteract = 0x58 // FMissionActionRelevantToInteract (Size: 0x18)
UAMissionAction_RelevantToActors.RelevantToVolume = 0x70 // FMissionActionRelevantToVolume (Size: 0x18)
UAMissionAction_RelevantToActors.RelevantToInventory = 0x88 // FMissionActionRelevantToInventory (Size: 0x18)
UAMissionAction_RelevantToActors.RelevantToAI = 0xa0 // FMissionActionRelevantToAI (Size: 0x18)
UAMissionAction_RelevantToActors.CharacterRelevantToInteractActorsMap = 0xb8 // TMap<...> (Size: 0x50)
UAMissionAction_RelevantToActors.CharacterRelevantToInventoriesMap = 0x108 // TMap<...> (Size: 0x50)
UAMissionAction_RelevantToActors.CharacterRelevantToAICharactersMap = 0x158 // TMap<...> (Size: 0x50)
UAMissionAction_Settlement.RelatedTargetTag = 0x48 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionAction_Settlement.RelatedTargetTypes = 0x50 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_Settlement.RelatedFactionTypes = 0x60 // TArray<EEFactionType> (Size: 0x10)
UAMissionAction_Settlement.SettlementType = 0x70 // EEPlayerTouchSettlementType (Size: 0x1)
UAMissionAction_ShowControl.bActive = 0x48 // bool (Size: 0x1)
UAMissionAction_ShowControl.ShowControlActors = 0x50 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_ShowControl.RelatedTargetTypes = 0x60 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionAction_ShowControl.InstigatorRelatedTargetsMap = 0x70 // TMap<...> (Size: 0x50)
UAMissionAction_ShowControl.TeamInfoShowControlActors = 0xc0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAMissionAction_ShowControl.PlayerTeamTypeShowControlActors = 0xd0 // TArray<EEPlayerTeamType> (Size: 0x10)
UAMissionAction_ShowHideActor.ActorRefs = 0x48 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionAction_ShowHideActor.bShow = 0x58 // bool (Size: 0x1)
UAMissionAction_ShowMaxScore.HudMaxScore = 0x48 // int32_t (Size: 0x4)
UAMissionAction_SpawnInventory.SpawnInventoryNum = 0x48 // int32_t (Size: 0x4)
UAMissionAction_SpawnInventory.SpawnInventoryInfos = 0x50 // TArray<FMissionObjectiveSpawnInventoryInfo> (Size: 0x10)
UAMissionAction_SpawnInventory.FailedInventoryNum = 0x60 // int32_t (Size: 0x4)
UAMissionAction_SpawnInventory.EffectMissionFlowInfos = 0x68 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionAction_SpawnInventory.InstigatorRelatedTargetsMap = 0x78 // TMap<...> (Size: 0x50)
UAMissionAction_SpawnInventory.CharacterSpawnedInventoriesMap = 0xc8 // TMap<...> (Size: 0x50)
UAMissionAction_SpawnInventory.TeamInfoSpawnedInventoriesMap = 0x118 // TMap<...> (Size: 0x50)
UAMissionAction_SpawnInventory.PlayerTeamTypeSpawnedInventoriesMap = 0x168 // TMap<...> (Size: 0x50)
UAMissionAction_SpawnInventory.ValidVolumeMap = 0x1b8 // TMap<...> (Size: 0x50)
UAMissionAction_TimeLimitCountDown.CountDownStartSecond = 0x48 // float (Size: 0x4)
UAMissionAction_TimeLimitCountDown.Instigator2TimerHandleMap = 0x50 // TMap<...> (Size: 0x50)
UAMissionAction_TimeLimitCountDown.TargetActors = 0xa0 // TArray<Actor*> (Size: 0x10)
UAMissionAction_TimeLimitCountDown.InteractItemIDs = 0xb0 // TArray<int32_t> (Size: 0x10)
UAMissionAction_TimeLimitCountDown.VolumeItemIDs = 0xc0 // TArray<int32_t> (Size: 0x10)
UAMissionAction_TimeLimitCountDown.InventoryItemIDs = 0xd0 // TArray<int32_t> (Size: 0x10)
UAMissionAction_TimeLimitCountDown.AIIDs = 0xe0 // TArray<int32_t> (Size: 0x10)
UAMissionAction_TimeLimitCountDownV2.CountDownStartSecond = 0x48 // float (Size: 0x4)
UAMissionAction_TimeLimitCountDownV2.Instigator2TimerHandleMap = 0x50 // TMap<...> (Size: 0x50)
UAMissionAction_TimeLimitCountDownV2.MissionNodeNames = 0xa0 // TArray<FString> (Size: 0x10)
UAMissionAction_TriggerParadrop.WaveIndex = 0x48 // int32_t (Size: 0x4)
UAMissionCondition_AIID.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_AIID.AIIDPrefixs = 0x58 // TArray<int64_t> (Size: 0x10)
UAMissionCondition_AIID.SpawnAreas = 0x68 // TArray<FString> (Size: 0x10)
UAMissionCondition_ActivationTime.CompareType = 0x50 // EEMissionCompareType (Size: 0x1)
UAMissionCondition_ActivationTime.MinTime = 0x54 // int32_t (Size: 0x4)
UAMissionCondition_ActivationTime.MaxTime = 0x58 // int32_t (Size: 0x4)
UAMissionCondition_Actor.CheckActorTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Actor.ActorParams = 0x58 // TArray<MissionCheckActorParamBase*> (Size: 0x10)
UAMissionCondition_AllEquipValue.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_AllEquipValue.MinCharacterAllEquipValue = 0x58 // int32_t (Size: 0x4)
UAMissionCondition_AllEquipValue.MaxCharacterAllEquipValue = 0x5c // int32_t (Size: 0x4)
UAMissionCondition_ArmorType.CheckArmorTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_ArmorType.ArmorTypes = 0x58 // TArray<EESGArmorType> (Size: 0x10)
UAMissionCondition_Attribute.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Attribute.AttributeInfos = 0x58 // TArray<MissionConditionAttributeInfo*> (Size: 0x10)
UAMissionCondition_Avatar.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Avatar.bAnyMatchSuccess = 0x58 // bool (Size: 0x1)
UAMissionCondition_Avatar.AvatarIDs = 0x60 // TArray<uint64_t> (Size: 0x10)
UAMissionCondition_CharacterInv.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_CharacterInv.AttachPosition = 0x58 // EEAttachPosition (Size: 0x1)
UAMissionCondition_CharacterInv.CheckInventoryID = 0x5c // int32_t (Size: 0x4)
UAMissionCondition_CharacterInv.CompareType = 0x60 // EEMissionCompareType (Size: 0x1)
UAMissionCondition_CharacterInv.CheckInventoryNum = 0x64 // int32_t (Size: 0x4)
UAMissionCondition_CharacterInv.CheckInventoryNumMin = 0x68 // int32_t (Size: 0x4)
UAMissionCondition_CharacterInv.CheckInventoryNumMax = 0x6c // int32_t (Size: 0x4)
UAMissionCondition_CharacterStatus.CharacterType = 0x50 // EEMissionConditionCharacterType (Size: 0x1)
UAMissionCondition_CharacterStatus.CharacterStatus = 0x51 // EEMissionConditionCharacterStatus (Size: 0x1)
UAMissionCondition_CharacterStatus.CheckTargetTag = 0x54 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_CharacterStatus.AIIDs = 0x60 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_CharacterStatus.AreaIDs = 0x70 // TArray<FString> (Size: 0x10)
UAMissionCondition_CharacterType.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_CharacterType.CharacterTypes = 0x58 // TArray<EECharacterType> (Size: 0x10)
UAMissionCondition_CurrentTODTime.StartTime = 0x50 // FMissionConditionTimeOfDay (Size: 0xc)
UAMissionCondition_CurrentTODTime.EndTime = 0x5c // FMissionConditionTimeOfDay (Size: 0xc)
UAMissionCondition_DamageInfo.CheckDamageInfoTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_DamageInfo.DamageInfoParams = 0x58 // TArray<MissionConditionDamageInfoParamBase*> (Size: 0x10)
UAMissionCondition_Distance.SourceActorTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Distance.DestActorTag = 0x58 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Distance.MinDistance = 0x60 // float (Size: 0x4)
UAMissionCondition_Distance.MaxDistance = 0x64 // float (Size: 0x4)
UAMissionCondition_EnduranceType.CheckEnduranceTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_EnduranceType.EnduranceTypes = 0x58 // TArray<EECharacterEnduranceType> (Size: 0x10)
UAMissionCondition_EquipItem.CheckTargetTag = 0x68 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_EquipItem.bCheckTeammate = 0x70 // bool (Size: 0x1)
UAMissionCondition_EquipItem.CheckItemType = 0x71 // EEMissionConditionItemType (Size: 0x1)
UAMissionCondition_EscapeVolume.CheckEscapeVolumeTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_EscapeVolume.EscapePointIDs = 0x58 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_EscapeVolume.TraceableParam = 0x68 // FMissionTraceableParam (Size: 0x4)
UAMissionCondition_FactionEnumType.CheckEnumTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_FactionEnumType.CheckArr = 0x58 // TArray<EEFactionType> (Size: 0x10)
UAMissionCondition_FactionLevel.OwnerFaction = 0x50 // EEFactionType (Size: 0x1)
UAMissionCondition_FactionLevel.EnemyFaction = 0x51 // EEFactionType (Size: 0x1)
UAMissionCondition_FactionLevel.LevelDifference = 0x54 // int32_t (Size: 0x4)
UAMissionCondition_FactionLevel.CompareType = 0x58 // EEMissionCompareType (Size: 0x1)
UAMissionCondition_FactionScore.OwnerFaction = 0x50 // EEFactionType (Size: 0x1)
UAMissionCondition_FactionScore.EnemyFaction = 0x51 // EEFactionType (Size: 0x1)
UAMissionCondition_FactionScore.ScoreDifference = 0x54 // int32_t (Size: 0x4)
UAMissionCondition_FactionScore.CompareType = 0x58 // EEMissionCompareType (Size: 0x1)
UAMissionCondition_FactionType.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_FactionType.CheckArr = 0x58 // TArray<EEFactionType> (Size: 0x10)
UAMissionCondition_GameplayEffect.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_GameplayEffect.GameplayTagInfos = 0x58 // TArray<MissionConditionGameplayTagInfo*> (Size: 0x10)
UAMissionCondition_InSameFaction.ATag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_InSameFaction.BTag = 0x58 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_InSameTeam.ATag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_InSameTeam.BTag = 0x58 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Item.CheckItemTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Item.ItemParams = 0x58 // TArray<MissionConditionItemParamBase*> (Size: 0x10)
UAMissionCondition_MemberCount.MemberCountType = 0x50 // EEMissionConditionMemberCountType (Size: 0x1)
UAMissionCondition_MemberCount.CheckCount = 0x54 // int32_t (Size: 0x4)
UAMissionCondition_MemberCount.CheckFactions = 0x58 // TArray<EEFactionType> (Size: 0x10)
UAMissionCondition_Number.CheckNumberTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Number.CompareType = 0x58 // EEMissionCompareType (Size: 0x1)
UAMissionCondition_Number.NumberType = 0x59 // EEMissionConditionNumberType (Size: 0x1)
UAMissionCondition_Number.ComparisonNumber = 0x60 // int64_t (Size: 0x8)
UAMissionCondition_Number.ComparisonNumberMin = 0x68 // int32_t (Size: 0x4)
UAMissionCondition_Number.ComparisonNumberMax = 0x6c // int32_t (Size: 0x4)
UAMissionCondition_Paradrop.CheckType = 0x50 // EEMissionObjectiveConditionCheckType (Size: 0x1)
UAMissionCondition_Paradrop.ParadropPointActorRefs = 0x58 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionCondition_Paradrop.bParadropPointChosen = 0x68 // bool (Size: 0x1)
UAMissionCondition_Paradrop.ParadropStates = 0x70 // TArray<EESGParadropState> (Size: 0x10)
UAMissionCondition_PlayModeId.ModeIDArray = 0x50 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayModeId.SubModeIDArray = 0x60 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayModeId.MapIDArray = 0x70 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayModeId.SpecialIDArray = 0x80 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayModeId.ExclusiveSpecialIDArray = 0x90 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayModeId.DifficultyArray = 0xa0 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_PlayerEndGameType.CheckPlayerEndGameTypeTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_PlayerEndGameType.PlayerEndGameTypes = 0x58 // TArray<EEPlayerEndGameType> (Size: 0x10)
UAMissionCondition_PlayerLevel.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_PlayerLevel.MinLevel = 0x58 // int32_t (Size: 0x4)
UAMissionCondition_PlayerLevel.MaxLevel = 0x5c // int32_t (Size: 0x4)
UAMissionCondition_RandomProbability.ProbabilityPercent = 0x50 // float (Size: 0x4)
UAMissionCondition_Self.ATag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Self.BTag = 0x58 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_SpawnAIEvent.CheckType = 0x50 // EEMissionObjectiveConditionCheckType (Size: 0x1)
UAMissionCondition_SpawnAIEvent.EventStrList = 0x58 // TArray<FString> (Size: 0x10)
UAMissionCondition_StayVolume.ValidVolumes = 0x50 // TArray<SGVolume*> (Size: 0x10)
UAMissionCondition_StayVolume.CheckTargetTag = 0x60 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_StayVolume.ValidVolumeIDs = 0x68 // TArray<int32_t> (Size: 0x10)
UAMissionCondition_StayVolume.ValidVolumeNames = 0x78 // TArray<FString> (Size: 0x10)
UAMissionCondition_StayVolume.bTraceable = 0x88 // bool (Size: 0x1)
UAMissionCondition_StayVolume.TraceableParam = 0x8c // FMissionTraceableParam (Size: 0x4)
UAMissionCondition_String.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_String.StringPrefixs = 0x58 // TArray<FString> (Size: 0x10)
UAMissionCondition_TeamInfo.CheckTargetTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_TeamInfo.TeamInfoType = 0x58 // EEMissionConditionTeamInfoType (Size: 0x1)
UAMissionCondition_TeamInfo.StringValue1 = 0x60 // FString (Size: 0x10)
UAMissionCondition_TeamInfo.StringValue2 = 0x70 // FString (Size: 0x10)
UAMissionCondition_TimeLimit.CheckInstigatorTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_TimeLimit.TimeLimitType = 0x58 // EEMissionTimeLimitType (Size: 0x1)
UAMissionCondition_TimeLimit.TimeLimitSeconds = 0x5c // int32_t (Size: 0x4)
UAMissionCondition_TimeLimit.TimeRecordCount = 0x60 // int32_t (Size: 0x4)
UAMissionCondition_Trigger.CheckTriggerTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_Trigger.SpawnItemIDs = 0x58 // TArray<uint64_t> (Size: 0x10)
UAMissionCondition_UseInventoryPhase.CheckUseInventoryPhaseTag = 0x50 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionCondition_UseInventoryPhase.UseInventoryPhase = 0x58 // EEUseInventoryPhase (Size: 0x1)
UAMissionItemSpawnPoint.SpawnPointID = 0x338 // int32_t (Size: 0x4)
UAMissionItemSpawnPoint.CurrentInstigator = 0x340 // Character* (Size: 0x8)
UAMissionItemSpawnPoint.AdditionComponents = 0x348 // TArray<ClassProperty> (Size: 0x10)
UAMissionObjAction_AddEscapePoint.RandomEscapePoint = 0x160 // int32_t (Size: 0x4)
UAMissionObjAction_AddEscapePoint.RandomEscapePointIDs = 0x168 // TArray<FMissionActionRandomEscapePoint> (Size: 0x10)
UAMissionObjAction_AddEscapePoint.RandomCache = 0x178 // TMap<...> (Size: 0x50)
UAMissionObjAction_Continuity.ProcessedPCs = 0x140 // TArray<PlayerController*> (Size: 0x10)
UAMissionObjAction_Continuity.Instigators = 0x150 // TArray<Actor*> (Size: 0x10)
UAMissionObjAction_DistributeFactionDomain.FactionType = 0x140 // EEFactionType (Size: 0x1)
UAMissionObjAction_DistributeFactionDomain.DomainVolumeArr = 0x148 // TArray<FMFMissionVariableRead_ActorReference> (Size: 0x10)
UAMissionObjAction_DistributeFactionDomain.PlayerStartEnable = 0x158 // bool (Size: 0x1)
UAMissionObjAction_DistributeFactionDomain.bOccupyDomainPlayerStart = 0x159 // bool (Size: 0x1)
UAMissionObjAction_DistributeFactionDomain.AISpawnPointEnable = 0x15a // bool (Size: 0x1)
UAMissionObjAction_DistributeMission.DistributeMissionType = 0x160 // EEDistributeMissionType (Size: 0x1)
UAMissionObjAction_DistributeMission.bUseRandomMissionable = 0x161 // bool (Size: 0x1)
UAMissionObjAction_DistributeMission.MissionFlowID = 0x164 // int32_t (Size: 0x4)
UAMissionObjAction_DistributeMission.RandomMissionTable = 0x168 // DataTable* (Size: 0x8)
UAMissionObjAction_DistributeMission.MissionFlowMap = 0x170 // TMap<...> (Size: 0x50)
UAMissionObjAction_DoorState.DoorActor = 0x140 // FMissionActorReference (Size: 0x18)
UAMissionObjAction_DoorState.TargetState = 0x158 // EESGDoorState (Size: 0x1)
UAMissionObjAction_DoorState.bDisableOnComplete = 0x159 // bool (Size: 0x1)
UAMissionObjAction_FactionPlayerStart.PlayerStartConfig = 0x140 // TArray<FFactionPlayerStartConfigRow> (Size: 0x10)
UAMissionObjAction_Paradrop.ParadropArr = 0x140 // TArray<FMissionParadropRow> (Size: 0x10)
UAMissionObjAction_RdmBlackboard.ChildRandom = 0x140 // TArray<MissionRdmBlackboardInstance*> (Size: 0x10)
UAMissionObjAction_RdmBlackboard.TagMap = 0x150 // TMap<...> (Size: 0x50)
UAMissionObjAction_RdmBlackboard.RandomTags = 0x1a0 // TArray<FName> (Size: 0x10)
UAMissionObjAction_RdmPlayerStart.FactionType = 0x140 // EEFactionType (Size: 0x1)
UAMissionObjAction_RdmPlayerStart.GroupIndexArr = 0x148 // TArray<int32_t> (Size: 0x10)
UAMissionObjAction_Scene.LevelToAdd = 0x140 // FString (Size: 0x10)
UAMissionObjAction_Scene.ActLevelMap = 0x150 // TMap<...> (Size: 0x50)
UAMissionObjAction_Scene.LevelToAddList = 0x1a0 // TArray<FString> (Size: 0x10)
UAMissionObjAction_Scene.LevelStreamingMap = 0x1b0 // TMap<...> (Size: 0x50)
UAMissionObjAction_TakeOutLimit.LimitType = 0x160 // EETakeOutLimitType (Size: 0x1)
UAMissionObjAction_TakeOutLimit.OrderTakeInSourceType = 0x161 // EESGTakeInSourceType (Size: 0x1)
UAMissionObjective.ActivityTemplateParams = 0x130 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_AISceneEvent.TickTimerHandle = 0x140 // FTimerHandle (Size: 0x8)
UAMissionObjective_AISceneEvent.TimeLength = 0x148 // float (Size: 0x4)
UAMissionObjective_AISceneEvent.EventType = 0x14c // EEAISceneEventType (Size: 0x1)
UAMissionObjective_AISceneEvent.AISceneEventClasses = 0x150 // TArray<ClassProperty> (Size: 0x10)
UAMissionObjective_ARGReachGoal.FactionTypes = 0x140 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_ARGReachGoal.EnemyFactionTypes = 0x150 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_ARGReachGoal.TickTimerHandle = 0x168 // FTimerHandle (Size: 0x8)
UAMissionObjective_ActivateLootPoint.ActivateLootPointConfigs = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_AddInventoryToLootContainer.bCheckShieldRandom = 0x140 // bool (Size: 0x1)
UAMissionObjective_AddInventoryToLootContainer.GiveNum = 0x144 // int32_t (Size: 0x4)
UAMissionObjective_AddInventoryToLootContainer.MapIDs = 0x148 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_AddInventoryToLootContainer.VolumeIDs = 0x158 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_AddInventoryToLootContainer.VolumeNames = 0x168 // TArray<FString> (Size: 0x10)
UAMissionObjective_AddInventoryToLootContainer.VolumeNameVariableKeys = 0x178 // TArray<FMFMissionVariableRead_String> (Size: 0x10)
UAMissionObjective_AddInventoryToLootContainer.bIncludeScatter = 0x188 // bool (Size: 0x1)
UAMissionObjective_AddInventoryToLootContainer.bIncludeLocked = 0x189 // bool (Size: 0x1)
UAMissionObjective_AddInventoryToLootContainer.bConsistentWeight = 0x18a // bool (Size: 0x1)
UAMissionObjective_AddInventoryToLootContainer.ConsistentItemID = 0x18c // int32_t (Size: 0x4)
UAMissionObjective_AddInventoryToLootContainer.LootContainerInfoMap = 0x190 // TMap<...> (Size: 0x50)
UAMissionObjective_AddInventoryToLootContainer.ValidPickups = 0x1e0 // TArray<SGPickup*> (Size: 0x10)
UAMissionObjective_AddInventoryToLootContainer.WaitingInstigators = 0x1f0 // TArray<MFMissionFlowComponent*> (Size: 0x10)
UAMissionObjective_AssistKill.KillAIIDList = 0x140 // TArray<FName> (Size: 0x10)
UAMissionObjective_AssistKill.KillAIIDPrefixs = 0x150 // TArray<int64_t> (Size: 0x10)
UAMissionObjective_AssistKill.bOnlyCheckKilled = 0x160 // bool (Size: 0x1)
UAMissionObjective_AssistKill.bEnableTeamKill = 0x161 // bool (Size: 0x1)
UAMissionObjective_BroadcastOnGameHUD.RelatedTargetTypes = 0x140 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionObjective_BroadcastOnGameHUD.RelatedFactionTypes = 0x150 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_BroadcastOnGameHUD.GameHUDConfigs = 0x160 // TArray<FBroadcastOnGameHUDConfig> (Size: 0x10)
UAMissionObjective_CapturePoint.TimeLength = 0x140 // float (Size: 0x4)
UAMissionObjective_CapturePoint.CaptureMessage = 0x148 // FGlobalEventMessage_CapturePointVolumeBelongChange (Size: 0x10)
UAMissionObjective_CapturePointChoose.CapturePointChooseNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_CapturePointChoose.CapturePointChooseConifgs = 0x148 // TArray<FMFMissionCapturePointChooseConifg> (Size: 0x10)
UAMissionObjective_CapturePointChoose.PreviousCapturePoints = 0x158 // FMFMissionFlowVariableKeySelector (Size: 0x28)
UAMissionObjective_CapturePointChoose.CurrentCapturePoints = 0x180 // FMFMissionFlowVariableKeySelector (Size: 0x28)
UAMissionObjective_CapturePointChoose.TraceRelatedFactionTypes = 0x1a8 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_CapturePointChoose.MapTraceConfigID = 0x1b8 // int32_t (Size: 0x4)
UAMissionObjective_CapturePointChoose.SceneTraceConfigID = 0x1bc // int32_t (Size: 0x4)
UAMissionObjective_CapturePointEnable.AllCapturePoints = 0x140 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionObjective_CapturePointEnable.bCapturePointEnable = 0x150 // bool (Size: 0x1)
UAMissionObjective_CapturePointEnable.CapturePoints = 0x158 // FMFMissionFlowVariableKeySelector (Size: 0x28)
UAMissionObjective_CapturePointEnable.TraceRelatedFactionTypes = 0x180 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_CapturePointEnable.MapTraceConfigID = 0x190 // int32_t (Size: 0x4)
UAMissionObjective_CapturePointReportPlayer.CapturePointTimeMap = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_ChooseVolume.ChooseVolumeNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_ChooseVolume.ChooseVolumeConifgs = 0x148 // TArray<FMFMissionChooseVolumeConifg> (Size: 0x10)
UAMissionObjective_ChooseVolume.CurrentVolumes = 0x158 // FMFMissionFlowVariableKeySelector (Size: 0x28)
UAMissionObjective_ClearArea.TickTimerHandle = 0x140 // FTimerHandle (Size: 0x8)
UAMissionObjective_ClearArea.VolumeStatisComponent = 0x148 // UAVolumeStatisComponent* (Size: 0x8)
UAMissionObjective_ClearArea.CharacterTypes = 0x150 // TArray<EECharacterType> (Size: 0x10)
UAMissionObjective_ClearArea.VolumeID = 0x160 // int64_t (Size: 0x8)
UAMissionObjective_CollectItem.bAddProgressWhenActivate = 0x140 // bool (Size: 0x1)
UAMissionObjective_CollectItem.bChangeCountsToValue = 0x141 // bool (Size: 0x1)
UAMissionObjective_CollectItem.bDisableRepeatCollect = 0x142 // bool (Size: 0x1)
UAMissionObjective_CollectItem.CharacterCollectedItemsMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_DisableLootPoint.LootPoints = 0x140 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_DistributeMission.RelatedTargetTypes = 0x140 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionObjective_DistributeMission.RelatedTeamTypes = 0x150 // TArray<EEMissionRelatedTeamType> (Size: 0x10)
UAMissionObjective_DistributeMission.RelatedFactionTypes = 0x160 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_DistributeMission.DistributeMissionType = 0x170 // EEDistributeMissionType (Size: 0x1)
UAMissionObjective_DistributeMission.bUseRandomMissionable = 0x171 // bool (Size: 0x1)
UAMissionObjective_DistributeMission.MissionFlowID = 0x174 // int32_t (Size: 0x4)
UAMissionObjective_DistributeMission.RandomMissionTable = 0x178 // DataTable* (Size: 0x8)
UAMissionObjective_DistributeMission.TeamInfoDistributeMissions = 0x188 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAMissionObjective_DistributeMission.PlayerTeamTypeDistributeMissions = 0x198 // TArray<EEPlayerTeamType> (Size: 0x10)
UAMissionObjective_EnduranceChanged.bAddEndurance = 0x140 // bool (Size: 0x1)
UAMissionObjective_EscapeVolumeStateChange.RelevantEscapeVolume = 0x140 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionObjective_EscapeVolumeStateChange.CheckState = 0x150 // EEEscapeState (Size: 0x1)
UAMissionObjective_FSMFlowStateChange.NewFlowStateList = 0x140 // TArray<FString> (Size: 0x10)
UAMissionObjective_FSMFlowStateChange.OldFlowStateList = 0x150 // TArray<FString> (Size: 0x10)
UAMissionObjective_FactionCompete.FactionCompeteConfigMap = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_FactionCompete.FactionCompeteInfoMap = 0x190 // TMap<...> (Size: 0x50)
UAMissionObjective_FactionScoreUpdate.FactionTypes = 0x140 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_FactionScoreUpdate.EnemyFactionTypes = 0x150 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_FactionScoreUpdate.TimeLimit = 0x160 // FMissionConditionTimeOfDay (Size: 0xc)
UAMissionObjective_FactionScoreUpdate.TickTimerHandle = 0x170 // FTimerHandle (Size: 0x8)
UAMissionObjective_FactionScoreUpdate.FactionScoreActionMap = 0x178 // TMap<...> (Size: 0x50)
UAMissionObjective_GiveItem.GiveNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_GiveItem.AreaIDs = 0x148 // TArray<FString> (Size: 0x10)
UAMissionObjective_GiveItem.GiveItemInfos = 0x158 // TArray<FMissionObjectiveGiveItemInfo> (Size: 0x10)
UAMissionObjective_GuardAI.GuardAIIDList = 0x140 // TArray<FName> (Size: 0x10)
UAMissionObjective_HitTarget.bAccumulateDamage = 0x140 // bool (Size: 0x1)
UAMissionObjective_HitTarget.DamageStatisType = 0x141 // EEDamageStatisType (Size: 0x1)
UAMissionObjective_HitTarget.bStatisFlashed = 0x142 // bool (Size: 0x1)
UAMissionObjective_HitTarget.AccumulateDamageMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_Interact.InteractEventType = 0x140 // EEInteractEventType (Size: 0x1)
UAMissionObjective_Interact.bCheckVolumeID = 0x141 // bool (Size: 0x1)
UAMissionObjective_Interact.ValidVolumeIDs = 0x148 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_Interact.bCheckVolumeName = 0x158 // bool (Size: 0x1)
UAMissionObjective_Interact.ValidVolumeNames = 0x160 // TArray<FString> (Size: 0x10)
UAMissionObjective_Interact.CharacterInteractTargetsMap = 0x170 // TMap<...> (Size: 0x50)
UAMissionObjective_InteractActor.CharacterInteractTargetsMap = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_InteractActor.InteractActorConfigIDs = 0x190 // TArray<int32_t> (Size: 0x10)
UAMissionObjective_InvokeAnnounce.RelatedTargetTag = 0x140 // FMFGlobalEventParameterTag (Size: 0x8)
UAMissionObjective_InvokeAnnounce.RelatedTargetTypes = 0x148 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionObjective_InvokeAnnounce.RelatedFactionTypes = 0x158 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_InvokeAnnounce.AnnounceInvokeConfigs = 0x168 // TArray<FAnnounceInvokeConfig> (Size: 0x10)
UAMissionObjective_KillTarget.KillAIIDList = 0x140 // TArray<FName> (Size: 0x10)
UAMissionObjective_KillTarget.KillAIIDPrefixs = 0x150 // TArray<int64_t> (Size: 0x10)
UAMissionObjective_KillTarget.bOnlyCheckKilled = 0x160 // bool (Size: 0x1)
UAMissionObjective_LimitAreaPlanDataInfoChange.CurCenterLocation = 0x140 // MFMissionVariableWrite_Vector* (Size: 0x8)
UAMissionObjective_LimitAreaPlanDataInfoChange.TargetCenterLocation = 0x148 // MFMissionVariableWrite_Vector* (Size: 0x8)
UAMissionObjective_MFStateChange.MissionFlowNames = 0x140 // TArray<FString> (Size: 0x10)
UAMissionObjective_MFStateChange.TargetState = 0x150 // EEMissionStatus (Size: 0x1)
UAMissionObjective_MPEnding.EndingTime = 0x140 // float (Size: 0x4)
UAMissionObjective_MPEnding.Instigator2TimerHandleMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_MPEnding.VictoryFactionType = 0x198 // EEFactionType (Size: 0x1)
UAMissionObjective_MonitorTakeDamageItem.TakeDamageActorVar = 0x140 // FMFMissionVariableRead_ActorReference (Size: 0x40)
UAMissionObjective_MonitorTakeDamageItem.TickTimerHandle = 0x180 // FTimerHandle (Size: 0x8)
UAMissionObjective_MonitorTakeDamageItem.TakeDamageActor = 0x188 // SGTakeDamageItem* (Size: 0x8)
UAMissionObjective_OrderPlayerStart.FactionType = 0x140 // EEFactionType (Size: 0x1)
UAMissionObjective_OrderPlayerStart.GroupIndex = 0x144 // int32_t (Size: 0x4)
UAMissionObjective_Paradrop.ParadropStates = 0x140 // TArray<EESGParadropState> (Size: 0x10)
UAMissionObjective_PlayerFlowState.CheckPlayerFlowStates = 0x140 // TArray<EEPlayerFlowState> (Size: 0x10)
UAMissionObjective_RandTimeRange.Instigator2TimerHandleMap = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_RandTimeRange.TimerType = 0x190 // EEMissionObjective_RandTimerType (Size: 0x1)
UAMissionObjective_RandTimeRange.StartTime = 0x194 // FMissionConditionTimeOfDay (Size: 0xc)
UAMissionObjective_RandTimeRange.EndTime = 0x1a0 // FMissionConditionTimeOfDay (Size: 0xc)
UAMissionObjective_RecKillTime.TimeBetweenDamageSeconds = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_RecLootTime.MinLootItemTotalValue = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_RecLootTime.bOnlyFromPMC = 0x144 // bool (Size: 0x1)
UAMissionObjective_RecLootTime.MaxLootTimeSeconds = 0x148 // int32_t (Size: 0x4)
UAMissionObjective_RecLootTime.CharacterLootStartTime = 0x150 // TMap<...> (Size: 0x50)
UAMissionObjective_RecLootTime.CharacterLootingInventory = 0x1a0 // TMap<...> (Size: 0x50)
UAMissionObjective_RecLootTime.CharacterOwedItemsMap = 0x1f0 // TMap<...> (Size: 0x50)
UAMissionObjective_RecLootTime.CharacterCollectedItemsMap = 0x240 // TMap<...> (Size: 0x50)
UAMissionObjective_RegisterSceneEvent.SceneEventNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_RegisterSceneEvent.SceneEventInfos = 0x148 // TArray<FMissionObjectiveSceneEventInfo> (Size: 0x10)
UAMissionObjective_RoundBeginForPlay.RoundTime = 0x140 // float (Size: 0x4)
UAMissionObjective_RoundBeginForPlay.Instigator2TimerHandleMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_RoundCountDown.CountDownTime = 0x140 // float (Size: 0x4)
UAMissionObjective_RoundCountDown.Instigator2TimerHandleMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_RoundRestart.PrepareTime = 0x140 // float (Size: 0x4)
UAMissionObjective_RoundRestart.MaxLoadTime = 0x144 // float (Size: 0x4)
UAMissionObjective_RoundRestart.MinLoadTime = 0x148 // float (Size: 0x4)
UAMissionObjective_RoundRestart.CountDownTime = 0x14c // float (Size: 0x4)
UAMissionObjective_RoundRestart.Instigator2TimerHandleMap = 0x150 // TMap<...> (Size: 0x50)
UAMissionObjective_RoundSettlement.WinFactionTypes = 0x140 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_RoundSettlement.LossFactionTypes = 0x150 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_RoundSwitchSides.bSwitchSides = 0x140 // bool (Size: 0x1)
UAMissionObjective_SearchContainer.bCheckShieldRandom = 0x140 // bool (Size: 0x1)
UAMissionObjective_SearchContainer.AddInventoryInfos = 0x148 // TArray<FMissionObjectiveAddInventoryToSearchContainerInfo> (Size: 0x10)
UAMissionObjective_Settlement.bNeedCheckWhetherCanFinishGame = 0x140 // bool (Size: 0x1)
UAMissionObjective_Settlement.CurGameModeType = 0x141 // EESGGameModeType (Size: 0x1)
UAMissionObjective_Settlement.VictoryFactionTypes = 0x148 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_Settlement.FailedFactionTypes = 0x158 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_Settlement.TieFactionTypes = 0x168 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_ShowControl.ShowControlActors = 0x140 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionObjective_ShowControl.RelatedTargetTypes = 0x150 // TArray<EEMissionRelatedTargetType> (Size: 0x10)
UAMissionObjective_ShowControl.InstigatorRelatedTargetsMap = 0x160 // TMap<...> (Size: 0x50)
UAMissionObjective_ShowControl.TeamInfoShowControlActors = 0x1b0 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAMissionObjective_ShowControl.PlayerTeamTypeShowControlActors = 0x1c0 // TArray<EEPlayerTeamType> (Size: 0x10)
UAMissionObjective_SpawnAI.EventConfig = 0x140 // FMissionObjectiveSpawnAIEventConfig (Size: 0x18)
UAMissionObjective_SpawnAI.FailedAINum = 0x158 // int32_t (Size: 0x4)
UAMissionObjective_SpawnAI.EffectMissionFlowInfos = 0x160 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionObjective_SpawnAI.SpawnedAIIDList = 0x170 // TArray<FName> (Size: 0x10)
UAMissionObjective_SpawnAI.SpawnedAICharacerList = 0x180 // TArray<SGAICharacter*> (Size: 0x10)
UAMissionObjective_SpawnAI.SpawnedEventList = 0x190 // TArray<FString> (Size: 0x10)
UAMissionObjective_SpawnAI.ActivatedMissionFlowComponent = 0x1a0 // MFMissionFlowComponent* (Size: 0x8)
UAMissionObjective_SpawnActor.SpawnActorNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_SpawnActor.SpawnActorInfos = 0x148 // TArray<FMissionObjectiveSpawnActorInfo> (Size: 0x10)
UAMissionObjective_SpawnActor.InstigatorRelatedTargetsMap = 0x158 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnActor.CharacterSpawnedActorsMap = 0x1a8 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnActor.TeamInfoSpawnedActorsMap = 0x1f8 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnActor.PlayerTeamTypeSpawnedActorsMap = 0x248 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnGashapon.SpawnGashaponActorRefs = 0x140 // TArray<FMissionActorReference> (Size: 0x10)
UAMissionObjective_SpawnInteractItem.SpawnInteractItemNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_SpawnInteractItem.SpawnInteractItemInfos = 0x148 // TArray<FMissionObjectiveSpawnInteractItemInfo> (Size: 0x10)
UAMissionObjective_SpawnInteractItem.bDestroyWhenMissionFailed = 0x158 // bool (Size: 0x1)
UAMissionObjective_SpawnInteractItem.FailedInteractNum = 0x15c // int32_t (Size: 0x4)
UAMissionObjective_SpawnInteractItem.EffectMissionFlowInfos = 0x160 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionObjective_SpawnInteractItem.InstigatorRelatedTargetsMap = 0x170 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInteractItem.CharacterSpawnedInteractItemsMap = 0x1c0 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInteractItem.TeamInfoSpawnedInteractItemsMap = 0x210 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInteractItem.PlayerTeamTypeSpawnedInteractItemsMap = 0x260 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventory.bCheckShieldRandom = 0x140 // bool (Size: 0x1)
UAMissionObjective_SpawnInventory.SpawnInventoryNum = 0x144 // int32_t (Size: 0x4)
UAMissionObjective_SpawnInventory.SpawnInventoryInfos = 0x148 // TArray<FMissionObjectiveSpawnInventoryInfo> (Size: 0x10)
UAMissionObjective_SpawnInventory.FailedInventoryNum = 0x158 // int32_t (Size: 0x4)
UAMissionObjective_SpawnInventory.EffectMissionFlowInfos = 0x160 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionObjective_SpawnInventory.InstigatorRelatedTargetsMap = 0x170 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventory.CharacterSpawnedInventoriesMap = 0x1c0 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventory.TeamInfoSpawnedInventoriesMap = 0x210 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventory.PlayerTeamTypeSpawnedInventoriesMap = 0x260 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventory.ValidVolumeMap = 0x2b0 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventoryByTable.bCheckShieldRandom = 0x140 // bool (Size: 0x1)
UAMissionObjective_SpawnInventoryByTable.EffectMissionFlowInfos = 0x148 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionObjective_SpawnInventoryByTable.InstigatorRelatedTargetsMap = 0x158 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventoryByTable.CharacterSpawnedInventoriesMap = 0x1a8 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventoryByTable.TeamInfoSpawnedInventoriesMap = 0x1f8 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventoryByTable.PlayerTeamTypeSpawnedInventoriesMap = 0x248 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnInventoryByTable.ItemSpawnPoints = 0x298 // TArray<UAMissionItemSpawnPoint*> (Size: 0x10)
UAMissionObjective_SpawnInventoryByTable.TimerInterval = 0x2a8 // float (Size: 0x4)
UAMissionObjective_SpawnInventoryByTable.TimelimitEveryTime = 0x2ac // float (Size: 0x4)
UAMissionObjective_SpawnInventoryByTable.Instigator2TimerHandleMap = 0x2b0 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnParticle.SpawnParticleNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_SpawnParticle.SpawnParticleInfos = 0x148 // TArray<FMissionObjectiveSpawnParticleInfo> (Size: 0x10)
UAMissionObjective_SpawnPickup.SpawnPickupNum = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_SpawnPickup.SpawnPickupInfos = 0x148 // TArray<FMissionObjectiveSpawnPickupInfo> (Size: 0x10)
UAMissionObjective_SpawnPickup.FailedPickupNum = 0x158 // int32_t (Size: 0x4)
UAMissionObjective_SpawnPickup.EffectMissionFlowInfos = 0x160 // TArray<FMissionObjectiveEffectMissionFlowInfo> (Size: 0x10)
UAMissionObjective_SpawnPickup.InstigatorRelatedTargetsMap = 0x170 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnPickup.CharacterSpawnedPickupsMap = 0x1c0 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnPickup.TeamInfoSpawnedPickupsMap = 0x210 // TMap<...> (Size: 0x50)
UAMissionObjective_SpawnPickup.PlayerTeamTypeSpawnedPickupsMap = 0x260 // TMap<...> (Size: 0x50)
UAMissionObjective_StartInvDetecting.DetectingMode = 0x140 // EEStartInvDetectingMode (Size: 0x1)
UAMissionObjective_StartInvDetecting.RandomPointRadius = 0x144 // float (Size: 0x4)
UAMissionObjective_StartInvDetecting.DetectRadius = 0x148 // float (Size: 0x4)
UAMissionObjective_StartLoot.bCheckShieldRandom = 0x140 // bool (Size: 0x1)
UAMissionObjective_StartLoot.AddInventoryInfos = 0x148 // TArray<FMissionObjectiveAddInventoryToSearchContainerInfo> (Size: 0x10)
UAMissionObjective_Survival.bResetOnCheckFailed = 0x140 // bool (Size: 0x1)
UAMissionObjective_Survival.Instigator2TimerHandleMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_TDMCountDown.CountDownTime = 0x140 // float (Size: 0x4)
UAMissionObjective_TDMCountDown.Instigator2TimerHandleMap = 0x148 // TMap<...> (Size: 0x50)
UAMissionObjective_TDMIsFinished.FactionTypes = 0x140 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_TDMIsFinished.GameTimeoverTimerHandle = 0x158 // FTimerHandle (Size: 0x8)
UAMissionObjective_TDMPrepare.PrepareTime = 0x140 // float (Size: 0x4)
UAMissionObjective_TDMPrepare.MaxLoadTime = 0x144 // float (Size: 0x4)
UAMissionObjective_TDMPrepare.MinLoadTime = 0x148 // float (Size: 0x4)
UAMissionObjective_TDMPrepare.Instigator2TimerHandleMap = 0x150 // TMap<...> (Size: 0x50)
UAMissionObjective_TDMReachGoal.FactionTypes = 0x140 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_TDMReachGoal.EnemyFactionTypes = 0x150 // TArray<EEFactionType> (Size: 0x10)
UAMissionObjective_TDMReachGoal.TickTimerHandle = 0x168 // FTimerHandle (Size: 0x8)
UAMissionObjective_TDMRoundStart.Instigator2TimerHandleMap = 0x140 // TMap<...> (Size: 0x50)
UAMissionObjective_TDMRoundStart.bExtraRound = 0x190 // bool (Size: 0x1)
UAMissionObjective_TakeInItem.bIngnoreSafeBox = 0x140 // bool (Size: 0x1)
UAMissionObjective_TakeInItem.bIngnoreKeyContainer = 0x141 // bool (Size: 0x1)
UAMissionObjective_TakeInItem.bChangeValueToCounts = 0x142 // bool (Size: 0x1)
UAMissionObjective_TakeInItemAndEscapeMap.bIngnoreSafeBox = 0x140 // bool (Size: 0x1)
UAMissionObjective_TakeInItemAndEscapeMap.bIngnoreKeyContainer = 0x141 // bool (Size: 0x1)
UAMissionObjective_TakeInItemAndEscapeMap.bChangeValueToCounts = 0x142 // bool (Size: 0x1)
UAMissionObjective_TakeOutItem.bEscapeFailedIngnoreSafeBox = 0x140 // bool (Size: 0x1)
UAMissionObjective_TakeOutItem.bChangeValueToCounts = 0x141 // bool (Size: 0x1)
UAMissionObjective_TakeOutItem.bUseStackCounts = 0x142 // bool (Size: 0x1)
UAMissionObjective_TriggerCustomParadrop.ParadropConfigRowName = 0x140 // FName (Size: 0x8)
UAMissionObjective_TriggerCustomParadrop.RequiredFallingChannelRadius = 0x148 // float (Size: 0x4)
UAMissionObjective_TriggerCustomParadrop.RequiredFlatGroundRadius = 0x14c // float (Size: 0x4)
UAMissionObjective_TriggerCustomParadrop.bUseCustomNavSkeletonQueryParameter = 0x150 // bool (Size: 0x1)
UAMissionObjective_TriggerCustomParadrop.CustomNavSkeletonQueryExtent = 0x154 // FVector (Size: 0xc)
UAMissionObjective_TriggerCustomParadrop.bUseNavSkeletonResultFirst = 0x160 // bool (Size: 0x1)
UAMissionObjective_TriggerCustomParadrop.TriggerCenterLocation = 0x168 // FMFMissionVariableRead_Vector (Size: 0x38)
UAMissionObjective_ValidCharacterNumberChange.OldValidCharacterNumber = 0x140 // int32_t (Size: 0x4)
UAMissionObjective_ValidCharacterNumberChange.CheckCharacterType = 0x148 // TArray<EECharacterType> (Size: 0x10)
UAMissionObjective_ValidTeamNumberChange.bIncludeAITeam = 0x140 // bool (Size: 0x1)
UAMissionObjective_ValidTeamNumberChange.OldValidTeamNumber = 0x144 // int32_t (Size: 0x4)
UAMissionObjective_WalkDistance.MoveDistanceTypes = 0x140 // TArray<EECharacterMoveDistanceType> (Size: 0x10)
UAMissionSubsystem.Index2MissionFlowMap = 0xa0 // TMap<...> (Size: 0x50)
UAMissionSubsystem.MissionFlowPlayersMap = 0xf0 // TMap<...> (Size: 0x50)
UAMissionSubsystem.ActivityTemplateMissionTable = 0x140 // DataTable* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.ScaleCanvasPanel = 0x2f0 // CanvasPanel* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.WidgetSwitcher_Tips = 0x2f8 // WidgetSwitcher* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.Image_Bg = 0x300 // Image* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.Image_Icon = 0x308 // Image* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.TextValue = 0x310 // TextBlock* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.swState = 0x318 // WidgetSwitcher* (Size: 0x8)
UAMobileHUDWidegt_ValuablesTips.CacheTraceableActorInfo = 0x320 // FNewTraceableActorInfo (Size: 0x78)
UAMobileHUDWidegt_ValuablesTips.EscapePointTraceStateRefreshIntervalTime = 0x39c // float (Size: 0x4)
UAMobileHUDWidegt_ValuablesTips.CacheEscapeNewInteractVolume = 0x3a0 // UAEscapeNewInteractVolume* (Size: 0x8)
UAModePickupLevelConfigsMappingTableRow.ModeId = 0x8 // int32_t (Size: 0x4)
UAModePickupLevelConfigsMappingTableRow.MapID = 0xc // int32_t (Size: 0x4)
UAModePickupLevelConfigsMappingTableRow.MatchID = 0x10 // int32_t (Size: 0x4)
UAModePickupLevelConfigsMappingTableRow.TeamID = 0x14 // int32_t (Size: 0x4)
UAModePickupLevelConfigsMappingTableRow.PickupLevelConfigsTable = 0x18 // DataTable* (Size: 0x8)
UANetReplicationGraphConnection.DistancePriorityWeight = 0x510 // float (Size: 0x4)
UANetReplicationGraphConnection.SelfOwnedPriorityWeight = 0x514 // float (Size: 0x4)
UANetReplicationGraphConnection.ElapsedFrameCountWeight = 0x518 // float (Size: 0x4)
UANetReplicationGraphConnection.ForceRelevantMaxDistThreshold = 0x51c // float (Size: 0x4)
UANetReplicationGraphConnection.ForceRelevantMinGlobalFrameCount = 0x520 // int32_t (Size: 0x4)
UANetReplicationGraphConnection.MaxRelevantDistMinGlobalFrameCountSquared = 0x524 // int32_t (Size: 0x4)
UANetReplicationGraphConnection.ForceRelevantNonSelfOwnedActorCountPerFrame = 0x528 // int32_t (Size: 0x4)
UANetReplicationGraphConnection.NetCullDistCheckTolerance = 0x52c // float (Size: 0x4)
UANetReplicationGraphConnection.CharacterPriorityWeight = 0x530 // float (Size: 0x4)
UANetReplicationGraphConnection.InvIsSearchingByThisCharacterPriorityWeight = 0x534 // float (Size: 0x4)
UANetReplicationGraphConnection.NearDistPriority = 0x538 // float (Size: 0x4)
UANetReplicationGraphConnection.MiddleDistPriority = 0x53c // float (Size: 0x4)
UANetReplicationGraphConnection.NearDistPriorityRepFrameInterval = 0x540 // int32_t (Size: 0x4)
UANetReplicationGraphConnection.MiddleDistPriorityRepFrameInterval = 0x544 // int32_t (Size: 0x4)
UANetReplicationGraphConnection.FarDistPriorityRepFrameInterval = 0x548 // int32_t (Size: 0x4)
UANetworkObjPoolRulesObject.BeginLength = 0x44 // int32_t (Size: 0x4)
UANetworkObjPoolRulesObject.StepDistance = 0x48 // float (Size: 0x4)
UANetworkObjPoolRulesObject.DistancePerSecond = 0x4c // float (Size: 0x4)
UANetworkObjPoolRulesObject.ObjPoolClassWeights = 0x50 // TArray<FObjPoolClassWeight> (Size: 0x10)
UANetworkObjPoolRulesObject.ClassWeightMap = 0x60 // TMap<...> (Size: 0x50)
UANetworkObjPoolSubsystem.ActorPoolTable = 0x38 // FSGModeActorPoolTable (Size: 0x80)
UANetworkObjPoolSubsystem.ClassArr = 0xc8 // TArray<ClassProperty> (Size: 0x10)
UANetworkObjPoolSubsystem.ExpectationMemArr = 0x118 // TArray<FUAObjPoolExpectationMem> (Size: 0x10)
UANetworkObjPoolSubsystem.ExpectationMemMap = 0x128 // TMap<...> (Size: 0x50)
UANetworkObjPoolSubsystem.MaxStaticMem = 0x178 // float (Size: 0x4)
UANetworkObjPoolSubsystem.CurrStaticMem = 0x17c // float (Size: 0x4)
UANetworkObjPoolSubsystem.MaxDynamicMem = 0x180 // float (Size: 0x4)
UANetworkObjPoolSubsystem.CurrDynamicMem = 0x184 // float (Size: 0x4)
UANetworkObjPoolSubsystem.PreloadClassTable = 0x188 // FSGModePreloadClassTable (Size: 0x40)
UANewMapDynamicSubWidget.TargetCharacter = 0x310 // Character* (Size: 0x8)
UANewMapModuleBase.IsVisibility = 0x28 // bool (Size: 0x1)
UANewMapModuleBase.ModuleName = 0x30 // FText (Size: 0x18)
UANewMapModuleBase.Order = 0x48 // int32_t (Size: 0x4)
UANewMapModuleBase.ModuleAdditionCanvasPanelOrder = 0x4c // int32_t (Size: 0x4)
UANewMapModuleBase.ModuleCanvasPanelClass = 0x50 // ClassProperty (Size: 0x8)
UANewMapModuleBase.AttachCanvasName = 0x58 // FString (Size: 0x10)
UANewMapModuleBase.MaxPreLoadCount_Framing = 0x68 // int32_t (Size: 0x4)
UANewMapModuleBase.RootParent = 0x70 // CanvasPanel* (Size: 0x8)
UANewMapModuleBase.ModuleTogle_Widget = 0x78 // UserWidget* (Size: 0x8)
UANewMapModuleBase.ModuleAdditionCanvasPanel = 0x80 // UserWidget* (Size: 0x8)
UANewMapModuleBase.NewMapPanel = 0x88 // UAHUDWidget_NewMapPanel* (Size: 0x8)
UANewMapModuleBase.ActiveSubWidgetMap = 0x98 // TMap<...> (Size: 0x50)
UANewMapModuleBase.SubWidgetPool = 0xe8 // TArray<UANewMapSubWidgetBase*> (Size: 0x10)
UANewMapStaticSubWidget.bCacheLocation = 0x310 // bool (Size: 0x1)
UANewMapStaticSubWidget.CacheWorldLocation = 0x314 // FVector (Size: 0xc)
UANewMapSubWidgetBase.SoleID = 0x300 // int32_t (Size: 0x4)
UANewMapSubWidgetBase.ModuleParent = 0x308 // UANewMapModuleBase* (Size: 0x8)
UANiagaraSwither.NiagaraPlaySequence = 0x48 // TArray<FNiagaraSwitherRow> (Size: 0x10)
UANiagaraSwither.NiagaraActor = 0x58 // Actor* (Size: 0x8)
UANiagaraSwither.NiagaraComponent = 0x60 // NiagaraComponent* (Size: 0x8)
UAOElevatorIndicatorSwither.DelayTime = 0x48 // float (Size: 0x4)
UAOElevatorIndicatorSwither.BeginFloor = 0x4c // int32_t (Size: 0x4)
UAOElevatorIndicatorSwither.EndFloor = 0x50 // int32_t (Size: 0x4)
UAOElevatorIndicatorSwither.EachFloorTime = 0x54 // float (Size: 0x4)
UAOElevatorIndicatorSwither.NiagaraActor = 0x58 // Actor* (Size: 0x8)
UAOElevatorIndicatorSwither.RunningSound = 0x60 // AkAudioEvent* (Size: 0x8)
UAOElevatorIndicatorSwither.EachFloorSound = 0x68 // AkAudioEvent* (Size: 0x8)
UAOElevatorIndicatorSwither.ArriveSound = 0x70 // AkAudioEvent* (Size: 0x8)
UAOElevatorIndicatorSwither.SoundActor = 0x78 // Actor* (Size: 0x8)
UAOElevatorIndicatorSwither.NiagaraComponent = 0x80 // NiagaraComponent* (Size: 0x8)
UAObjPoolExpectationMem.Priority = 0x0 // int32_t (Size: 0x4)
UAObjPoolExpectationMem.ExpectationMem = 0x4 // float (Size: 0x4)
UAPCARGControlComponent.CurrentPlayerLevel = 0x270 // int32_t (Size: 0x4)
UAPCARGControlComponent.CurrentWeaponKillNum = 0x274 // int32_t (Size: 0x4)
UAPCEscapeComponent.EscapePresetName = 0x100 // FString (Size: 0x10)
UAPCEscapeComponent.EscapePointIDs = 0x110 // TArray<int32_t> (Size: 0x10)
UAPCEscapeComponent.PassCheckPointIDs = 0x120 // TArray<int32_t> (Size: 0x10)
UAPCEscapeComponent.HasExploratedPointIDs = 0x130 // TArray<int32_t> (Size: 0x10)
UAPCEscapeComponent.PreConditionPointIDs = 0x140 // TArray<int32_t> (Size: 0x10)
UAPCEscapeComponent.EscapePresetIndex = 0x150 // int32_t (Size: 0x4)
UAPCEscapeComponent.AnnounceConfigID = 0x154 // int32_t (Size: 0x4)
UAPCQuestManagerComponent.ReplicateDataList = 0x100 // TArray<FQuestReplicateData> (Size: 0x10)
UAPCQuestManagerComponent.PlayerOldGraphState = 0x110 // TMap<...> (Size: 0x50)
UAPCRWGControlComponent.CurrentWeaponKillNum = 0x288 // int32_t (Size: 0x4)
UAPCRebornComponent.AutoGiveEquipment = 0x100 // bool (Size: 0x1)
UAPCRebornComponent.LastGiveSuitInfo = 0x108 // FSuitInfo (Size: 0x40)
UAPCRebornComponent.OldCharacter = 0x148 // SGCharacter* (Size: 0x8)
UAPCRoundControlComponent.ThisRoundLastGiveSuitInfo = 0x120 // FSuitInfo (Size: 0x40)
UAPCRoundControlComponent.RoundStateInfo = 0x160 // FRoundStateInfo (Size: 0xc)
UAPCRoundControlComponent.RoundBeginPrepareTime = 0x170 // float (Size: 0x4)
UAPCRoundControlComponent.MaxLoadTime = 0x174 // float (Size: 0x4)
UAPCRoundControlComponent.MinLoadTime = 0x178 // float (Size: 0x4)
UAPCRoundControlComponent.MaxPrepareTime = 0x17c // float (Size: 0x4)
UAPCRoundControlComponent.RoundBeginTime = 0x180 // float (Size: 0x4)
UAPCRoundControlComponent.MaxRoundTime = 0x184 // float (Size: 0x4)
UAPCRoundSelectEquipComponent.TestInvAry = 0x100 // TArray<SGInventory*> (Size: 0x10)
UAPCRoundSelectEquipComponent.AnnihilateTempleEquips = 0x110 // TArray<FSuitInfo> (Size: 0x10)
UAPCRoundSelectEquipComponent.SkinMap = 0x120 // TMap<...> (Size: 0x50)
UAPCRoundSelectEquipComponent.CurSelectedSuit = 0x170 // FSuitInfo (Size: 0x40)
UAPCRoundSelectEquipComponent.IsGenerateTestItemSkin = 0x1b0 // bool (Size: 0x1)
UAPCRoundSelectEquipComponent.TestWeaponSkinIDMin = 0x1b4 // uint32_t (Size: 0x4)
UAPCRoundSelectEquipComponent.TestWeaponSkinIDMax = 0x1b8 // uint32_t (Size: 0x4)
UAPCRoundSelectEquipComponent.TestEquipSkinIDMin = 0x1bc // uint32_t (Size: 0x4)
UAPCRoundSelectEquipComponent.TestEquipSkinIDMax = 0x1c0 // uint32_t (Size: 0x4)
UAPCRoundSelectEquipComponent.EventAnnihilateKillInfoAry = 0x1c8 // TArray<FEventAnnihilateKillInfo> (Size: 0x10)
UAPCServerCommandComponent.PendingRefreshedPickups = 0x160 // TArray<Actor*> (Size: 0x10)
UAPCServerCommandComponent.SimulateTimes = 0x174 // int32_t (Size: 0x4)
UAPCServerCommandComponent.SimulateRefreshLootPointPickups = 0x178 // TArray<Actor*> (Size: 0x10)
UAPCServerCommandComponent.SimulateLootGuaranteePickups = 0x188 // TArray<Actor*> (Size: 0x10)
UAPCSettlementComponent.EscapeVolume = 0x158 // UAEscapeVolume* (Size: 0x8)
UAPCSettlementComponent.EscapeParamA = 0x160 // float (Size: 0x4)
UAPCSettlementComponent.EscapeParamTT = 0x164 // float (Size: 0x4)
UAPCSettlementComponent.EscapeParamT = 0x168 // float (Size: 0x4)
UAPCSettlementComponent.bDestroyCharacterWhenQuit = 0x178 // bool (Size: 0x1)
UAPCSettlementComponent.ActiveSettlementType = 0x179 // EEPlayerActiveSettlementType (Size: 0x1)
UAPCTDMControlComponent.RoundStateInfo = 0x12c // FRoundStateInfo (Size: 0xc)
UAPCTDMControlComponent.PreState = 0x138 // EEUAPlayerRoundState (Size: 0x1)
UAPCTDMControlComponent.RoundBeginPrepareTime = 0x13c // float (Size: 0x4)
UAPCTDMControlComponent.MaxLoadTime = 0x140 // float (Size: 0x4)
UAPCTDMControlComponent.MinLoadTime = 0x144 // float (Size: 0x4)
UAPCTDMControlComponent.MaxPrepareTime = 0x148 // float (Size: 0x4)
UAPCTDMControlComponent.RoundBeginTime = 0x14c // float (Size: 0x4)
UAPCTDMControlComponent.MaxRoundTime = 0x150 // float (Size: 0x4)
UAPCTDMControlComponent.RebornSaftyStartTime = 0x154 // float (Size: 0x4)
UAPCTDMControlComponent.RebornSuitSelectEndTime = 0x158 // float (Size: 0x4)
UAPCTDMControlComponent.RoundSwitchEquipSelectionEndTime = 0x15c // float (Size: 0x4)
UAPCTDMControlComponent.bIsEquipQuickSwitchDone = 0x160 // bool (Size: 0x1)
UAPCTDMControlComponent.bCanReborn = 0x161 // bool (Size: 0x1)
UAPCTDMControlComponent.bBanJumpAfterReborn = 0x162 // bool (Size: 0x1)
UAPCTDMControlComponent.InterruptRebornSafetyActions = 0x198 // TArray<FGameplayTag> (Size: 0x10)
UAPCTDMControlComponent.InterruptRebornSelectActions = 0x1a8 // TArray<FGameplayTag> (Size: 0x10)
UAPCTDMControlComponent.KillInfoCache = 0x1b8 // FKillInfo (Size: 0xb8)
UAPCTDMRebornComponent.AutoGiveEquipment = 0x100 // bool (Size: 0x1)
UAPCTDMRebornComponent.OldCharacter = 0x108 // SGCharacter* (Size: 0x8)
UAPCUIModeComponent.bOperationResultOpened = 0x108 // bool (Size: 0x1)
UAPCUIModeComponent.bShowMessageBox = 0x109 // bool (Size: 0x1)
UAPCUIModeComponent.bModalBoxOpen = 0x10a // bool (Size: 0x1)
UAPCUIModeComponent.bLoadingPanel = 0x10b // bool (Size: 0x1)
UAPCUIModeComponent.ForceDisableBagStateChange = 0x10c // bool (Size: 0x1)
UAPCUIModeComponent.bPreparationsOpened = 0x10e // bool (Size: 0x1)
UAPCUIModeComponent.bMainMenuOpened = 0x10f // bool (Size: 0x1)
UAPCUIModeComponent.bBagOpened = 0x110 // bool (Size: 0x1)
UAPCUIModeComponent.bBagOpened_Real = 0x111 // bool (Size: 0x1)
UAPCUIModeComponent.bMapOpened = 0x112 // bool (Size: 0x1)
UAPCUIModeComponent.bOperationUIPanelOpen = 0x113 // bool (Size: 0x1)
UAPCUIModeComponent.bSettlement = 0x114 // bool (Size: 0x1)
UAPCUIModeComponent.bGameOver = 0x115 // bool (Size: 0x1)
UAPCUIModeComponent.bAIDebugInfoOpen = 0x116 // bool (Size: 0x1)
UAPCUIModeComponent.bCombatStatsOpened = 0x117 // bool (Size: 0x1)
UAPCUIModeComponent.bGameSetttingOpened = 0x118 // bool (Size: 0x1)
UAPCUIModeComponent.bIsBagTemporarilyHidden = 0x119 // bool (Size: 0x1)
UAPCUIModeComponent.bWeaponBuildOpened = 0x11a // bool (Size: 0x1)
UAParadrop.VerticalDropSimulationComponent = 0x3b8 // SGLinearMotionSimulationComponent* (Size: 0x8)
UAParadrop.HeightToleranceThreshold = 0x3c0 // float (Size: 0x4)
UAParadrop.ParadropUniformFallingStageName = 0x3c4 // FName (Size: 0x8)
UAParadrop.ParadropDamagedAcceleratedFallingStageName = 0x3cc // FName (Size: 0x8)
UAParadrop.ParadropDamagedUniformFallingStageName = 0x3d4 // FName (Size: 0x8)
UAParadrop.ParadropCarrierAcceleratedFloatingStageName = 0x3dc // FName (Size: 0x8)
UAParadrop.ParadropCarrierUniformFloatingStageName = 0x3e4 // FName (Size: 0x8)
UAParadrop.ParadropCarrierStayTime = 0x3ec // float (Size: 0x4)
UAParadrop.ServerCurrentTransform = 0x3f0 // FTransform (Size: 0x30)
UAParadropBalloon.BalloonSkeletalMeshComponent = 0x318 // SkeletalMeshComponent* (Size: 0x8)
UAParadropBalloon.BalloonRedLightsParticleSystemComponent = 0x320 // ParticleSystemComponent* (Size: 0x8)
UAParadropBalloon.BalloonLeakParticleSystemComponent = 0x328 // ParticleSystemComponent* (Size: 0x8)
UAParadropBalloon.BalloonAnimInstance = 0x330 // ClassProperty (Size: 0x8)
UAParadropBalloon.RedLightsSocketName = 0x338 // FName (Size: 0x8)
UAParadropBalloon.RedLightsRelativeTransform = 0x340 // FTransform (Size: 0x30)
UAParadropBalloon.LeakSocketName = 0x370 // FName (Size: 0x8)
UAParadropBalloon.LeakRelativeTransform = 0x380 // FTransform (Size: 0x30)
UAParadropBalloon.MaxEndurance = 0x3b0 // float (Size: 0x4)
UAParadropBalloon.EnduranceLossPerDamaged = 0x3b4 // float (Size: 0x4)
UAParadropBalloon.ActorEnduranceComponent = 0x3b8 // SGActorEnduranceComponent* (Size: 0x8)
UAParadropBalloon.AttachParadrop = 0x3c0 // SGParadropBase* (Size: 0x8)
UAParadropFlight.ParadropPoints = 0x8 // TArray<Actor*> (Size: 0x10)
UAParadropFlight.OverWriteKeyPoints = 0x20 // TArray<FTransform> (Size: 0x10)
UAParadropGroup.ParadropPointArray = 0x0 // TArray<Actor*> (Size: 0x10)
UAParadropManagerComponent.FlightStartEvent = 0x208 // FMulticastInlineDelegate (Size: 0x10)
UAParadropManagerComponent.FlightArriveEvent = 0x218 // FMulticastInlineDelegate (Size: 0x10)
UAParadropManagerComponent.ParadropGroupMap = 0x228 // TMap<...> (Size: 0x50)
UAParadropManagerComponent.ParadropWaves = 0x3d8 // TArray<FUAParadropWave> (Size: 0x10)
UAParadropManagerComponent.MaxPlaneNum = 0x3e8 // int32_t (Size: 0x4)
UAParadropManagerComponent.DelayFlightTimeOffset = 0x3ec // float (Size: 0x4)
UAParadropManagerComponent.FlightDistancePlus = 0x400 // float (Size: 0x4)
UAParadropManagerComponent.ParadropDistSquared2D_Theshold = 0x404 // float (Size: 0x4)
UAParadropManagerComponent.VolumePointIDs = 0x408 // TMap<...> (Size: 0x50)
UAParadropManagerComponent.CachePlaneClass = 0x458 // TArray<ClassProperty> (Size: 0x10)
UAParadropManagerComponent.Point_ParadropMap = 0x478 // TMap<...> (Size: 0x50)
UAParadropPoint.GroupIndex = 0x310 // int32_t (Size: 0x4)
UAParadropPointComponent.GroupIndex = 0xf8 // int32_t (Size: 0x4)
UAParadropSupply.SupplyFrameSkeletalMeshComponent = 0x320 // SkeletalMeshComponent* (Size: 0x8)
UAParadropSupply.SupplyFallingParticleSystemComponent = 0x328 // ParticleSystemComponent* (Size: 0x8)
UAParadropSupply.SupplySignalParticleSystemComponent = 0x330 // ParticleSystemComponent* (Size: 0x8)
UAParadropSupply.ActorSoundComponent = 0x338 // SGActorSoundComponent* (Size: 0x8)
UAParadropSupply.SupplyFrameMeshHideType = 0x340 // EEUAParadropSupplyFrameMeshHideType (Size: 0x1)
UAParadropSupply.SupplyFrameAnimInstance = 0x348 // ClassProperty (Size: 0x8)
UAParadropSupply.SupplyFrameLandingDuration = 0x350 // float (Size: 0x4)
UAParadropSupply.FallingSocketName = 0x354 // FName (Size: 0x8)
UAParadropSupply.FallingRelativeTransform = 0x360 // FTransform (Size: 0x30)
UAParadropSupply.SignalSocketName = 0x390 // FName (Size: 0x8)
UAParadropSupply.SignalRelativeTransform = 0x3a0 // FTransform (Size: 0x30)
UAParadropSupply.SignalParticleDuration = 0x3d0 // float (Size: 0x4)
UAParadropSupply.bHideSupplyWhenEmpty = 0x3d4 // bool (Size: 0x1)
UAParadropSupply.bSupplyHidden = 0x3d5 // bool (Size: 0x1)
UAParadropSupply.bDefaultSearched = 0x3d6 // bool (Size: 0x1)
UAParadropSupply.SignalSmokeTemplate = 0x3d8 // NiagaraSystem* (Size: 0x8)
UAParadropSupply.SignalSmokeParticle = 0x3e0 // NiagaraComponent* (Size: 0x8)
UAParadropSupply.FadeSmokeTemplate = 0x3e8 // NiagaraSystem* (Size: 0x8)
UAParadropSupply.FadeSmokeParticle = 0x3f0 // NiagaraComponent* (Size: 0x8)
UAParadropSupply.SupplyLandingParticleSystem = 0x3f8 // ParticleSystem* (Size: 0x8)
UAParadropSupply.LandingRelativeTransform = 0x400 // FTransform (Size: 0x30)
UAParadropSupply.SupplyLandingAudioEvent = 0x430 // AkAudioEvent* (Size: 0x8)
UAParadropSupply.SupplySignalBeginAudioEvent = 0x438 // AkAudioEvent* (Size: 0x8)
UAParadropSupply.SupplySignalEndAudioEvent = 0x440 // AkAudioEvent* (Size: 0x8)
UAParadropSupply.SupplyLandingAudioEventName = 0x448 // FName (Size: 0x8)
UAParadropSupply.SupplySignalBeginAudioEventName = 0x450 // FName (Size: 0x8)
UAParadropSupply.SupplySignalEndAudioEventName = 0x458 // FName (Size: 0x8)
UAParadropSupply.ExtraSupplyClass = 0x460 // ClassProperty (Size: 0x8)
UAParadropSupply.ExtraSupplySocketName = 0x468 // FName (Size: 0x8)
UAParadropSupply.ExtraSupplyRelativeTransform = 0x470 // FTransform (Size: 0x30)
UAParadropSupply.AttachParadrop = 0x4a0 // SGParadropBase* (Size: 0x8)
UAParadropSupply.SupplyInfoInfoArray = 0x4c0 // TArray<FUAParadropSupplyInfo> (Size: 0x10)
UAParadropSupply.ExtraSupply = 0x4d0 // Actor* (Size: 0x8)
UAParadropSupplyInfo.LootContainer = 0x0 // Actor* (Size: 0x8)
UAParadropSupplyInfo.SocketName = 0x8 // FName (Size: 0x8)
UAParadropVolumeInfo.AvailablePointIDs = 0x0 // TArray<int32_t> (Size: 0x10)
UAParadropWave.Flights = 0x10 // TArray<FUAParadropFlight> (Size: 0x10)
UAParadropWave.ParadropInstigator = 0x28 // Pawn* (Size: 0x8)
UAParticalSwither.ParticalPlaySequence = 0x48 // TArray<FParticalSwitherRow> (Size: 0x10)
UAParticalSwither.CurrEffectActor = 0x58 // SGShowControlEffectActor* (Size: 0x8)
UAPickup.BoxComponent = 0x318 // BoxComponent* (Size: 0x8)
UAPickup.TraceConfigID = 0x320 // int32_t (Size: 0x4)
UAPickupConfigComponent.PickupLevelPercentages = 0x238 // TArray<FUAPickupLevelPercentage> (Size: 0x10)
UAPickupConfigComponent.SpawnCountMin = 0x248 // int32_t (Size: 0x4)
UAPickupConfigComponent.SpawnCountMax = 0x24c // int32_t (Size: 0x4)
UAPickupConfigComponent.bRandomRotation = 0x250 // bool (Size: 0x1)
UAPickupConfigComponent.bSpawnInBirthIsland = 0x251 // bool (Size: 0x1)
UAPickupFactoryComponent.Radius = 0x238 // float (Size: 0x4)
UAPickupFactoryComponent.OverrideLevel = 0x23c // int32_t (Size: 0x4)
UAPickupFactoryComponent.CachedPickupConfigComponent = 0x240 // UAPickupConfigComponent* (Size: 0x8)
UAPickupLevelConfigsTableRow.Level = 0x8 // int32_t (Size: 0x4)
UAPickupLevelConfigsTableRow.Describtion = 0x10 // FString (Size: 0x10)
UAPickupLevelConfigsTableRow.Percent = 0x20 // float (Size: 0x4)
UAPickupLevelConfigsTableRow.PickupPercentages = 0x28 // TArray<FUAPickupPercentage> (Size: 0x10)
UAPickupLevelPercentage.Level = 0x0 // int32_t (Size: 0x4)
UAPickupLevelPercentage.Percent = 0x4 // float (Size: 0x4)
UAPickupPercentage.PickupClass = 0x0 // TSoftClassPtr<UObject> (Size: 0x28)
UAPickupPercentage.Percent = 0x28 // float (Size: 0x4)
UAPlayerCheckPointInfoComponent.CheckPointIndex = 0x100 // int32_t (Size: 0x4)
UAPlayerCheckPointInfoComponent.DefaultEquipInventories = 0x108 // TArray<ClassProperty> (Size: 0x10)
UAPlayerCheckPointInfoComponent.ShowHUDArray = 0x118 // TArray<EEUAGamePadTable> (Size: 0x10)
UAPlayerCheckPointInfoComponent.NextQuestActor = 0x128 // MFQuestBase* (Size: 0x8)
UAPlayerCheckPointInfoComponent.ClearAllInventories = 0x130 // bool (Size: 0x1)
UAPlayerCheckPointInfoComponent.NeedSaveEquipment = 0x131 // bool (Size: 0x1)
UAPlayerStateChaseActivityComp.MarkBuffStartTime = 0x2d8 // float (Size: 0x4)
UAPlayerStateChaseActivityComp.bStartBeMarkBuff = 0x2dc // bool (Size: 0x1)
UAPlayerStateChaseActivityComp.BeMarkBuffTimerHandle = 0x2e0 // FTimerHandle (Size: 0x8)
UAPlayerStateChaseActivityComp.bQuestReportVisible = 0x2e8 // bool (Size: 0x1)
UAPlayerStateChaseActivityComp.bOnStartSpectating = 0x2e9 // bool (Size: 0x1)
UAPlayerStateChaseActivityComp.bFirstActivityInvCollected = 0x2ea // bool (Size: 0x1)
UAPlayerStateMissionRewardComponent.RewardRecords = 0x100 // TArray<FMissionRewardItemEntry> (Size: 0x10)
UAPlayerStateMissionRewardComponent.Messageid = 0x110 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.AllWeaponDamageStruct = 0xa68 // TArray<FPlayerTakeDamageByWeaponStatistics> (Size: 0x10)
UAPlayerStateStatisComponent.AllStartFireStruct = 0xa78 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.AllMeleeStartFireStruct = 0xac8 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.AllThrowableStartFireStruct = 0xb18 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.AllChangeWeaponOrStartFireStruct = 0xb68 // TArray<FChangeWeaponOrStartFireStruct> (Size: 0x10)
UAPlayerStateStatisComponent.AllBulletAimStruct = 0xb78 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.AllAntiDataStructArray = 0xbc8 // TArray<FAntiDataStruct> (Size: 0x10)
UAPlayerStateStatisComponent.AllInteractionStruct = 0xbd8 // TArray<FInteractionStatistics> (Size: 0x10)
UAPlayerStateStatisComponent.AllOnKillOtherStruct = 0xbe8 // TArray<FOnKillOtherStruct> (Size: 0x10)
UAPlayerStateStatisComponent.AllUseInventoryFlashStruct = 0xbf8 // TArray<FUseInventoryFlashStruct> (Size: 0x10)
UAPlayerStateStatisComponent.AllInventoryFlashDebuffStruct = 0xc08 // TArray<FInventoryFlashDebuffStruct> (Size: 0x10)
UAPlayerStateStatisComponent.ThrowableDebuffStruct = 0xc18 // FThrowableDebuffStruct (Size: 0x10)
UAPlayerStateStatisComponent.CanNotEnterStationaryStateTagsConfig = 0xc40 // FGameplayTagContainer (Size: 0x20)
UAPlayerStateStatisComponent.PlayerOfflineTimeThreshold = 0xc60 // float (Size: 0x4)
UAPlayerStateStatisComponent.MovementDistanceThreshold = 0xc64 // float (Size: 0x4)
UAPlayerStateStatisComponent.CloseToEscapePointDistanceThresholdMapByEscapePointID = 0xc68 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.WantToEscapePointDistanceThresholdMapByEscapePointID = 0xcb8 // TMap<...> (Size: 0x50)
UAPlayerStateStatisComponent.StationaryStateNumThreshold = 0xd08 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.MaxStationaryStateDurationThreshold = 0xd0c // float (Size: 0x4)
UAPlayerStateStatisComponent.DiedPrematurelyTimeThreshold = 0xd10 // float (Size: 0x4)
UAPlayerStateStatisComponent.CachedEscapeVolumes = 0xd18 // TArray<Actor*> (Size: 0x10)
UAPlayerStateStatisComponent.StationaryStateNum = 0xdd0 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.MaxStationaryStateDuration = 0xdd4 // float (Size: 0x4)
UAPlayerStateStatisComponent.bUseSniperRifle = 0xdd8 // bool (Size: 0x1)
UAPlayerStateStatisComponent.CloseToEscapePointStationaryStateNum = 0xddc // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.CloseToEscapePointMaxStationaryStateDuration = 0xde0 // float (Size: 0x4)
UAPlayerStateStatisComponent.CamperTypeAnalysisRecord = 0xde8 // FString (Size: 0x10)
UAPlayerStateStatisComponent.MurderousEscapeVolumeIDRecord = 0xdf8 // FString (Size: 0x10)
UAPlayerStateStatisComponent.AntiCamperStageCounterRecord = 0xe08 // FString (Size: 0x10)
UAPlayerStateStatisComponent.EnableAntiCamperFunction = 0xe18 // bool (Size: 0x1)
UAPlayerStateStatisComponent.KillNumberInStationaryState = 0xe1c // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.KillPlayerNumberInStationaryState = 0xe20 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.CamperAnalysisAdditionalInformation = 0xe28 // FString (Size: 0x10)
UAPlayerStateStatisComponent.TotalStayTime = 0xe38 // float (Size: 0x4)
UAPlayerStateStatisComponent.TotalSilentWalkTime = 0xe3c // float (Size: 0x4)
UAPlayerStateStatisComponent.TotalWalkTime = 0xe40 // float (Size: 0x4)
UAPlayerStateStatisComponent.TotalSprintTime = 0xe44 // float (Size: 0x4)
UAPlayerStateStatisComponent.TotalAliveTime = 0xe48 // float (Size: 0x4)
UAPlayerStateStatisComponent.FlareGunFireNum = 0xe4c // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.FlareGunFireWhenAvailabilityHintIconGreenNum = 0xe50 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.FlareGunCallParadropFailedByNoLandingLocationFoundNum = 0xe54 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.FlareGunCallParadropSuccessedNum = 0xe58 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.FlareGunCallParadropSuccessedTime = 0xe60 // FString (Size: 0x10)
UAPlayerStateStatisComponent.NativeCachedSGCharacter = 0xe70 // SGCharacter* (Size: 0x8)
UAPlayerStateStatisComponent.ThemeActivities = 0xe78 // int32_t (Size: 0x4)
UAPlayerStateStatisComponent.GameModeType = 0xe7c // int32_t (Size: 0x4)
UAPlayerStateTraceComponent.MinScanInterval = 0x100 // float (Size: 0x4)
UAPlayerStateTraceComponent.GlobalTraceableActorInfos = 0x108 // TArray<FTraceableActorInfo> (Size: 0x10)
UAPlayerStateTraceComponent.PlayerTraceableActorInfos = 0x118 // TArray<FTraceableActorInfo> (Size: 0x10)
UAPlayerStateTraceComponent.TraceableActorInfos = 0x128 // TArray<FTraceableActorInfo> (Size: 0x10)
UAPlayerStateTraceComponent.TraceActorInfo = 0x138 // FTraceableActorInfo (Size: 0x58)
UAPlayerStateTraceComponent.TraceActivityInfo = 0x190 // FTraceableActorInfo (Size: 0x58)
UAPlayerStateTraceComponent.InventoryProxies = 0x1e8 // TArray<PlayerStateTraceableInventoryProxy*> (Size: 0x10)
UAPlayerStateTraceComponent.MousePinLifeTime = 0x1f8 // float (Size: 0x4)
UAPlayerStateTraceComponent.MousePinLimitNum = 0x1fc // int32_t (Size: 0x4)
UAPushCharacterVolume.bConstantPushDirection = 0x3a0 // bool (Size: 0x1)
UAPushCharacterVolume.PushDirection = 0x3a4 // FVector (Size: 0xc)
UAPushCharacterVolume.PushSpeed = 0x3b0 // float (Size: 0x4)
UAPushCharacterVolume.PushCharacters = 0x3b8 // TArray<Character*> (Size: 0x10)
UAPushVolumeSwither.DelayTime = 0x48 // float (Size: 0x4)
UAPushVolumeSwither.ShowTime = 0x4c // float (Size: 0x4)
UAPushVolumeSwither.PushCharacterVolume = 0x50 // UAPushCharacterVolume* (Size: 0x8)
UARWGGSGlobalDataComponent.RWGTime = 0x160 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.RWGExtraRoundTime = 0x164 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.bTriggerByKill = 0x168 // bool (Size: 0x1)
UARWGGSGlobalDataComponent.RandomWeaponRequestKillNum = 0x16c // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.bTriggerByReborn = 0x170 // bool (Size: 0x1)
UARWGGSGlobalDataComponent.GoalScore = 0x174 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.AnnounceScore = 0x178 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.AnnounceRoundLeftTime = 0x17c // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.AnnounceKillNum = 0x180 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.DeathWatchTime = 0x184 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.RebornWaitTime = 0x188 // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.RebornSafetyTime = 0x18c // int32_t (Size: 0x4)
UARWGGSGlobalDataComponent.InterruptRebornSafetyActions = 0x190 // TArray<FGameplayTag> (Size: 0x10)
UARWGGSGlobalDataComponent.CachedAllPlayers = 0x1a0 // TArray<FRoundGamePlayerData> (Size: 0x10)
UAReplicationGraph.PrivateGridNode = 0x690 // UAReplicationGraphNode_GridSpatialization2D* (Size: 0x8)
UAReplicationGraph.PrivateSparseGridNode = 0x698 // UAReplicationGraphNode_GridSpatialization2D* (Size: 0x8)
UAReplicationGraph.SpatializedClasses = 0x6f0 // TArray<ClassProperty> (Size: 0x10)
UAReplicationGraph.NonSpatializedChildClasses = 0x700 // TArray<ClassProperty> (Size: 0x10)
UAReplicationGraph.AlwaysRelevantClasses = 0x710 // TArray<ClassProperty> (Size: 0x10)
UAReplicationGraph.CrossListNode = 0x720 // UAReplicationGraphNode_CrossList* (Size: 0x8)
UAReplicationGraph.AlwaysRelevantNode = 0x728 // UAReplicationGraphNode_AlwaysRelevant* (Size: 0x8)
UAReplicationGraph.SimpleDisRelevancyNode = 0x730 // UAReplicationGraphNode_SimpleDistanceRelevancy* (Size: 0x8)
UAReplicationGraph.AlwaysRelevantToTeamNode = 0x738 // UAReplicationGraphNode_AlwaysRelevantToTeam* (Size: 0x8)
UAReplicationGraph.AlwaysRelevantForConnectionList = 0x790 // TArray<FConnectionAlwaysRelevantNodePair> (Size: 0x10)
UAReplicationGraph.AlwaysRelevantForConnectionNodes = 0x7a0 // TMap<...> (Size: 0x50)
UAReplicationGraph.ControllerConnectionMap = 0x7f0 // TMap<...> (Size: 0x50)
UAReplicationGraph.AINovisableItemMap = 0x840 // TMap<...> (Size: 0x50)
UAReplicationGraphNode_AlwaysRelevant.DormancyNode = 0xf8 // ReplicationGraphNode_DormancyNode* (Size: 0x8)
UAReplicationGraphNode_AlwaysRelevant_ForConnection.Owner = 0x50 // NetReplicationGraphConnection* (Size: 0x8)
UAReplicationGraphNode_AlwaysRelevant_ForConnection.AlwaysRelevantInventoryReplication = 0x268 // TArray<Actor*> (Size: 0x10)
UAReplicationGraphNode_AlwaysRelevant_ForConnection.LastPawn = 0x3a8 // Actor* (Size: 0x8)
UAReplicationGraphNode_AlwaysRelevant_ForConnection.PastRelevantActors = 0x3b0 // TArray<FAlwaysRelevantActorInfo> (Size: 0x10)
UAReplicationGraphNode_GridSpatialization2D.RepGraph = 0x260 // UAReplicationGraph* (Size: 0x8)
UAReplicationGraphNode_RelevantFollowOwner.RelevantFollowActorListMap = 0x50 // TMap<...> (Size: 0x50)
UAReplicationGraphNode_RelevantFollowOwner.InverseRelevantFollowActorListMap = 0xa0 // TMap<...> (Size: 0x50)
UAReplicationGraphNode_RelevantFollowOwner.PendingRelevantFollowActorListMap = 0xf0 // TMap<...> (Size: 0x50)
UARoundGSGlobalDataComponent.bGunFightOver = 0x108 // bool (Size: 0x1)
UARoundGSGlobalDataComponent.FactionGlobalDataA = 0x110 // FRoundGameFactionData (Size: 0x28)
UARoundGSGlobalDataComponent.FactionGlobalDataB = 0x138 // FRoundGameFactionData (Size: 0x28)
UAScanAreaCenterPoint.ConfigID = 0x310 // int32_t (Size: 0x4)
UAScanAreaCenterPoint.ScanningAreaID = 0x314 // int32_t (Size: 0x4)
UAScanAreaOutlinePoint.ScanningAreaID = 0x310 // int32_t (Size: 0x4)
UAScanAreaOutlinePoint.Index = 0x314 // int32_t (Size: 0x4)
UAScanDeviceInfoComponent.AllScanningAreaCenterPoints = 0x198 // TMap<...> (Size: 0x50)
UAScanDeviceInfoComponent.ResultOnMapTime = 0x1e8 // float (Size: 0x4)
UASceneCanBeDestroyedActor.PropMesh = 0x310 // StaticMeshComponent* (Size: 0x8)
UASceneCanBeDestroyedActor.ParticleSystem = 0x318 // ParticleSystemComponent* (Size: 0x8)
UASceneCanBeDestroyedActor.CanBeDestroyedActorConfigTableID = 0x320 // int32_t (Size: 0x4)
UASceneCanBeDestroyedActor.ActorConfig = 0x328 // FCanBeDestroyedActorConfig (Size: 0xb0)
UASceneCanBeDestroyedActor.CurrentHealth = 0x3e0 // float (Size: 0x4)
UAShootTestTarget.HitCount = 0x318 // int32_t (Size: 0x4)
UASkeletalAnimSwither.SkeletalMeshActor = 0x48 // SkeletalMeshActor* (Size: 0x8)
UASkeletalAnimSwither.AnimPlaySequence = 0x50 // TArray<FASkeletalAnimSwitherRow> (Size: 0x10)
UASkeletalAnimSwither.SkeletalMeshComponent = 0x60 // SkeletalMeshComponent* (Size: 0x8)
UAStatisticDataCollectCore_Stat.SceneInfoCollect_Stat = 0x38 // TArray<FSceneObjInfo_Stat> (Size: 0x10)
UAStatisticDataCollectCore_Stat.MyTable = 0x48 // DataTable* (Size: 0x8)
UAStatisticDataCollectCore_Stat.CollectKeyWord = 0x50 // FString (Size: 0x10)
UAStatisticDataCollectCore_StatCmp.SceneInfoCollect_Stat = 0x38 // TArray<FSceneObjInfo_Stat> (Size: 0x10)
UAStatisticDataCollectCore_StatCmp.MyTable = 0x48 // DataTable* (Size: 0x8)
UAStatisticDataCollectCore_StatCmp.MyTableCmp = 0x50 // DataTable* (Size: 0x8)
UAStatisticDataCollectCore_StatCmp.CollectKeyWord = 0x58 // FString (Size: 0x10)
UAStatisticDataCollectCore_StatCmp.bIsAdd = 0x68 // bool (Size: 0x1)
UATDMGSGlobalDataComponent.GoalScore = 0x160 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.AnnounceScore = 0x164 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.RoundTimeArr = 0x168 // TArray<int32_t> (Size: 0x10)
UATDMGSGlobalDataComponent.AnnounceRoundLeftTime = 0x178 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.AnnounceBGMLeftTime = 0x17c // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.AnnounceKillNum = 0x180 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.DeathWatchTime = 0x184 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.RebornWaitTime = 0x188 // int32_t (Size: 0x4)
UATDMGSGlobalDataComponent.RebornSaftyTime = 0x18c // float (Size: 0x4)
UATDMGSGlobalDataComponent.RebornSelectSuitMaxTime = 0x190 // float (Size: 0x4)
UATDMGSGlobalDataComponent.RoundSwitchEquipSelectionTime = 0x194 // float (Size: 0x4)
UATDMGSGlobalDataComponent.InterruptRebornSafetyActions = 0x198 // TArray<FGameplayTag> (Size: 0x10)
UATDMGSGlobalDataComponent.InterruptRebornSuitSelectActions = 0x1a8 // TArray<FGameplayTag> (Size: 0x10)
UATeamEscapeComponent.StateMap = 0xf8 // TArray<FUATeamEscapeRow> (Size: 0x10)
UATeamEscapeComponent.TeamExplreEscapePoints = 0x108 // TArray<int32_t> (Size: 0x10)
UATeamEscapeComponent.bDelayedEvacuationReportID = 0x138 // int32_t (Size: 0x4)
UATeamEscapeRow.EscapePointID = 0x0 // int32_t (Size: 0x4)
UATeamEscapeRow.State = 0x4 // EEEscapeExploreState (Size: 0x1)
UATeamInfo.TeammemberPlayerBaseInfoArray = 0x4b0 // TArray<FTeammemberPlayerBaseInfo> (Size: 0x10)
UATeamInfo.TimerInterval = 0x4d0 // float (Size: 0x4)
UATeamInfo.ClearTimerInterval = 0x4d4 // float (Size: 0x4)
UATeamInfo.TeamMemberPlayerInfosArray = 0x4d8 // TArray<FTeamPlayerInfo> (Size: 0x10)
UATeamInfo.OldTeamMemberPlayerInfosArray = 0x4e8 // TArray<FTeamPlayerInfo> (Size: 0x10)
UATeamInfo.OldSignType = 0x4f8 // EESignType (Size: 0x1)
UATeamInfo.TeamMemberPlayerBaseInfosArray = 0x500 // TArray<FTeamPlayerBaseInfo> (Size: 0x10)
UATeamZoneInfoComponent.TeamMemberInventory = 0xf8 // TMap<...> (Size: 0x50)
UATeamZoneInfoComponent.TeamMemberZoneInfo = 0x148 // TMap<...> (Size: 0x50)
UATeamZoneInfoComponent.TeamMemberResult = 0x198 // TMap<...> (Size: 0x50)
UATeamZoneInfoComponent.TeamMemberKillNum = 0x1e8 // TMap<...> (Size: 0x50)
UATeamZoneInfoComponent.TeamMemberGIDs = 0x238 // TArray<uint64_t> (Size: 0x10)
UATeamZoneInfoComponent.TeamMemberDamageNum = 0x248 // TMap<...> (Size: 0x50)
UATeamZoneInfoComponent.TeamMemberGameTime = 0x298 // TMap<...> (Size: 0x50)
UATeammateInfoSubWidget.TeammatePlayerState = 0x380 // PlayerState* (Size: 0x8)
UATeammateInfoSubWidget.TeammateLighterColors = 0x388 // TArray<FSlateColor> (Size: 0x10)
UATeammateInfoSubWidget.TeammateDarkerColors = 0x398 // TArray<FSlateColor> (Size: 0x10)
UATeammateInfoSubWidget.LighterColorImages = 0x3a8 // TArray<Image*> (Size: 0x10)
UATeammateInfoSubWidget.DarkerColorImages = 0x3b8 // TArray<Image*> (Size: 0x10)
UATeammateInfoSubWidget.CharecterInvisibleOpacity = 0x3c8 // float (Size: 0x4)
UATeammateInfoSubWidget.WorldOffset = 0x3cc // FVector (Size: 0xc)
UATeammateInfoSubWidget.WorldOffsetDBNO = 0x3d8 // FVector (Size: 0xc)
UATeammateInfoSubWidget.ScreenOffset = 0x3e4 // FVector2D (Size: 0x8)
UATeammateInfoSubWidget.ScreenOffsetDBNO = 0x3ec // FVector2D (Size: 0x8)
UATeammateInfoSubWidget.MinOpacity = 0x3f4 // float (Size: 0x4)
UATeammateInfoSubWidget.OpacityRadius = 0x3f8 // float (Size: 0x4)
UATeammateInfoSubWidget.SpecialImage = 0x400 // Image* (Size: 0x8)
UATeammateInfoSubWidget.MentorBrush = 0x408 // FSlateBrush (Size: 0x90)
UATeammateInfoSubWidget.PupilBrush = 0x498 // FSlateBrush (Size: 0x90)
UATeammateInfoSubWidget.PlayerNameTextWidget = 0x528 // TextBlock* (Size: 0x8)
UATeammateInfoSubWidget.PlayerNumberTextWidget = 0x530 // TextBlock* (Size: 0x8)
UATeammateInfoSubWidget.RescueWidget = 0x538 // Widget* (Size: 0x8)
UATeammateInfoSubWidget.NumberWidget = 0x540 // Widget* (Size: 0x8)
UATeammateInfoSubWidget.HealthBarWidget = 0x548 // Widget* (Size: 0x8)
UATeammateInfoSubWidget.SquadLighterColor = 0x550 // FSlateColor (Size: 0x28)
UATeammateInfoSubWidget.SquadDarkerColor = 0x578 // FSlateColor (Size: 0x28)
UATeammateInfoWidget.LocalPlayerState = 0x2f0 // PlayerState* (Size: 0x8)
UATeammateInfoWidget.SubWidgetClass = 0x2f8 // ClassProperty (Size: 0x8)
UATeammateInfoWidget.SubWidgets = 0x300 // TArray<UAFollowCharacterWidget*> (Size: 0x10)
UATeammateInfoWidget.DestroyedSubWidgets = 0x310 // TArray<UAFollowCharacterWidget*> (Size: 0x10)
UATeammateInfoWidget.ChaseSubWidgetClass = 0x320 // ClassProperty (Size: 0x8)
UATeammateInfoWidget.DossSubWidgetClass = 0x328 // ClassProperty (Size: 0x8)
UATeammateInfoWidget.DossSubWidget = 0x330 // UAFollowCharacterWidget* (Size: 0x8)
UATeammateInfoWidget.FactionSubWidgetClass = 0x338 // ClassProperty (Size: 0x8)
UATeammateInfoWidget.FactionAISubWidgetClass = 0x340 // ClassProperty (Size: 0x8)
UATeammateInfoWidget.CanvasPanel = 0x348 // CanvasPanel* (Size: 0x8)
UATeammateInfoWidget.SubWidgetClassMap = 0x350 // TMap<...> (Size: 0x50)
UATeammateInfoWidget.CharacterWidgetMap = 0x3a0 // TMap<...> (Size: 0x50)
UATelescopeFiringComponent.DefaultCoolDownTime = 0x6d0 // float (Size: 0x4)
UAThirdPersonCameraMode_Drone.PitchCurve = 0x258 // CurveFloat* (Size: 0x8)
UAThirdPersonCameraMode_Drone.RollCurve = 0x260 // CurveFloat* (Size: 0x8)
UAThreeDTracePoint.TraceIndex = 0x310 // int32_t (Size: 0x4)
UAThreeDTracePoint.TraceConfig = 0x314 // int32_t (Size: 0x4)
UATraceDataInfoComponent.NewTraceSyncRule = 0xf8 // EENewTraceSyncRule (Size: 0x1)
UATraceDataInfoComponent.MinScanInterval = 0xfc // float (Size: 0x4)
UATraceDataInfoComponent.ActiveTraceInfoList = 0x100 // TArray<FNewTraceableActorInfo> (Size: 0x10)
UATraceDataInfoComponent.PassivityTraceInfoList = 0x110 // TArray<FNewTraceableActorInfo> (Size: 0x10)
UATraceDataInfoComponent.MousePinTraceInfoList = 0x120 // TArray<FMousePinTraceInfoList> (Size: 0x10)
UATraceDataInfoComponent.ScanDeviceResultInfoList = 0x130 // TArray<FScanDeviceResultInfo> (Size: 0x10)
UATraceDataInfoComponent.DeathBoxCacheInfoList = 0x140 // TArray<FDeathBoxToTeamIndexCacheInfo> (Size: 0x10)
UATraceDataInfoComponent.CommonThreeDTraceInfos = 0x150 // TArray<FCommonThreeDTraceInfo> (Size: 0x10)
UATraceDataInfoComponent.ClientPassivityTraceInfoList = 0x160 // TArray<FNewTraceableActorInfo> (Size: 0x10)
UATraceDispatcherBase.TraceInfoHistoryBlackboardMap = 0x28 // TMap<...> (Size: 0x50)
UATraceDispatcherBase.DisplayPlatform = 0x78 // EENewTraceDisplayPlatform (Size: 0x1)
UATraceDispatcherBase.PlatformInterfaces = 0x80 // TArray<TScriptInterface<IInterface>> (Size: 0x10)
UATraceSubSystem.DispatcherMap = 0x40 // TMap<...> (Size: 0x50)
UATraceSubSystem.TeamInfoTraceableActorsMap = 0x90 // TMap<...> (Size: 0x50)
UATraceSubSystem.PlayerTeamTypeTraceableActorsMap = 0xe0 // TMap<...> (Size: 0x50)
UATraceSubSystem.FactionTypeTraceableActorsMap = 0x130 // TMap<...> (Size: 0x50)
UATraceSubSystem.OnRemoveNewPassivityTraceableActorInfo = 0x180 // FMulticastInlineDelegate (Size: 0x10)
UATutorialEventInfo.ID = 0x0 // int32_t (Size: 0x4)
UATutorialEventInfo.EventName = 0x8 // FString (Size: 0x10)
UATutorialEventInfo.MaxTimesInGame = 0x18 // int32_t (Size: 0x4)
UATutorialEventInfo.MaxTimesInCareer = 0x1c // int32_t (Size: 0x4)
UATutorialEventInfo.NotTriggerTimesInCareer = 0x20 // int32_t (Size: 0x4)
UATutorialEventInfo.CD = 0x24 // int32_t (Size: 0x4)
UATutorialEventInfo.Para1 = 0x28 // int32_t (Size: 0x4)
UATutorialEventInfo.Para2 = 0x2c // int32_t (Size: 0x4)
UATutorialEventInfo.Para3 = 0x30 // int32_t (Size: 0x4)
UATutorialHelper.TutorialCheckpoints = 0x310 // TArray<FTutorialCheckpointSettings> (Size: 0x10)
UATutorialHelper.CaptainTips = 0x320 // DataTable* (Size: 0x8)
UATutorialHelper.CaptainController = 0x328 // SGAIController* (Size: 0x8)
UATutorialHelper.CaptainCharacter = 0x330 // SGAICharacter* (Size: 0x8)
UATutorialHelper.DisableCaptainComponents = 0x338 // TArray<ClassProperty> (Size: 0x10)
UATutorialHelper.CharacterAnimationSetsClass = 0x348 // ClassProperty (Size: 0x8)
UATutorialHelper.PerWeaponAnimationSetsClass = 0x350 // ClassProperty (Size: 0x8)
UATutorialMissionAction_HUDMask.Maskid = 0x48 // int32_t (Size: 0x4)
UATutorialMissionAction_HUDMask.bShow = 0x4c // bool (Size: 0x1)
UATutorialMissionAction_HUDMask.IsDeactiveAction = 0x4d // bool (Size: 0x1)
UATutorialMissionAction_HUDMask.bShowMaskVisual = 0x4e // bool (Size: 0x1)
UATutorialMissionAction_HudMessage.MessageArray = 0x48 // TArray<int64_t> (Size: 0x10)
UATutorialMissionAction_HudMessage.ClearMessageArray = 0x58 // TArray<int64_t> (Size: 0x10)
UATutorialMissionAction_LockItemIDs.Locked = 0x48 // bool (Size: 0x1)
UATutorialMissionAction_LockItemIDs.ItemIDs = 0x50 // TArray<int32_t> (Size: 0x10)
UATutorialMissionAction_MapSign.SignTargetLocation = 0x48 // FVector2D (Size: 0x8)
UATutorialMissionAction_MapSign.Sign_EscapePointID = 0x50 // int32_t (Size: 0x4)
UATutorialMissionAction_MapSign.bShow = 0x54 // bool (Size: 0x1)
UATutorialMissionAction_PadHighEffect.PadButtonType = 0x48 // EEUAGamePadTable (Size: 0x1)
UATutorialMissionAction_PadHighEffect.HightWidget = 0x49 // EEUAGamePadHightWidgetTable (Size: 0x1)
UATutorialMissionAction_PadHighEffect.Offset = 0x4c // FVector2D (Size: 0x8)
UATutorialMissionAction_PadHighEffect.bShow = 0x54 // bool (Size: 0x1)
UATutorialMissionAction_QuestTraceHighEffect.TaskId = 0x48 // int32_t (Size: 0x4)
UATutorialMissionAction_QuestTraceHighEffect.Show = 0x4c // bool (Size: 0x1)
UATutorialMissionAction_WidgetEffect_T.PadEffectType = 0x48 // EEGamePadEffectTable (Size: 0x1)
UATutorialMissionAction_WidgetEffect_T.bShow = 0x49 // bool (Size: 0x1)
UATutorialMissionObjective_AddMapSign.SignType = 0x140 // EEMapSignType (Size: 0x1)
UATutorialMissionObjective_AddMapSign.EscapePointID = 0x144 // int32_t (Size: 0x4)
UATutorialMissionObjective_AddMapSign.TaskId = 0x148 // int32_t (Size: 0x4)
UATutorialMissionObjective_Bag.bOpen = 0x140 // bool (Size: 0x1)
UATutorialMissionObjective_Bag.BagType = 0x141 // EETutorialBagType (Size: 0x1)
UATutorialMissionObjective_Bag.SpawnPoint = 0x148 // FMissionActorReference (Size: 0x18)
UATutorialMissionObjective_Bag.ContainerClass = 0x160 // ClassProperty (Size: 0x8)
UATutorialMissionObjective_BagTabClick.BagTabType = 0x140 // EETutorialBagTabType (Size: 0x1)
UATutorialMissionObjective_BigMapDetailBoardShow.DetailBoardType = 0x140 // EEDetailBoardType (Size: 0x1)
UATutorialMissionObjective_BigMapDetailBoardShow.bOpen = 0x141 // bool (Size: 0x1)
UATutorialMissionObjective_ClickItem.ItemClass = 0x140 // ClassProperty (Size: 0x8)
UATutorialMissionObjective_MoveItem.NewPositionType = 0x140 // EEAttachPosition (Size: 0x1)
UATutorialMissionObjective_MoveItem.ItemClass = 0x148 // ClassProperty (Size: 0x8)
UATutorialMissionObjective_MoveItem.MoveOrAdd = 0x150 // EEMoveCheckStyle (Size: 0x1)
UATutorialMissionObjective_MoveTo.VolumeID = 0x140 // int64_t (Size: 0x8)
UATutorialMissionObjective_OpenItemDetail.bShow = 0x140 // bool (Size: 0x1)
UATutorialMissionObjective_OpenItemDetail.ItemId = 0x144 // int32_t (Size: 0x4)
UATutorialMissionObjective_OpenPPT.bShow = 0x140 // bool (Size: 0x1)
UATutorialMissionObjective_OpenPPT.WidgetID = 0x144 // int32_t (Size: 0x4)
UATutorialMissionObjective_TestKillTarget.KillAIIDList = 0x140 // TArray<FName> (Size: 0x10)
UATutorialMissionObjective_TestKillTarget.KillAIIDPrefixs = 0x150 // TArray<int64_t> (Size: 0x10)
UATutorialMissionObjective_WeaponAssemble.ItemClass = 0x140 // ClassProperty (Size: 0x8)
UATutorialMissionObjective_WeaponAssemble.WeaponClass = 0x148 // ClassProperty (Size: 0x8)
UAUnifyWrapper.Wind = 0x310 // UAWindWrapperComponent* (Size: 0x8)
UAVolumeInteractComponent.bEnterVolumeAutoComplete = 0x1d0 // bool (Size: 0x1)
UAVolumeInteractComponent.bEnableTriggerCompleteEvent = 0x1d2 // bool (Size: 0x1)
UAVolumeInteractComponent.MaxDistanceErrorRange = 0x1d4 // float (Size: 0x4)
UAVolumeInteractComponent.InteractAngle = 0x1e0 // float (Size: 0x4)
UAVolumeInteractComponent.bEnableInteractionAbility = 0x1e4 // bool (Size: 0x1)
UAVolumeInteractComponent.SkeletalMeshActor = 0x1e8 // SkeletalMeshActor* (Size: 0x8)
UAVolumeInteractComponent.CharacterMontage = 0x1f0 // AnimMontage* (Size: 0x8)
UAVolumeInteractComponent.TargetMontage = 0x1f8 // AnimMontage* (Size: 0x8)
UAVolumeInteractComponent.RelativeInteractiveObject = 0x200 // TArray<Actor*> (Size: 0x10)
UAVolumeInteractComponent.TraceConfigID = 0x210 // int32_t (Size: 0x4)
UAVolumeInteractComponent.AnnounceConfigID = 0x214 // int32_t (Size: 0x4)
UAVolumeSpawnInventoryComponent.SpawnedInventoryInfos = 0x100 // TArray<FVolumeSpawnedInventoryInfo> (Size: 0x10)
UAVolumeStatisComponent.EnteredActors = 0x100 // TArray<TWeakObjectPtr<UObject>> (Size: 0x10)
UAWeaponAttributes.BulletZeroFlyDistanceForWeaponAction = 0x0 // float (Size: 0x4)
UAWeaponAttributes.ZeroDropDistance = 0x4 // float (Size: 0x4)
UAWeaponAttributes.Accuracy = 0x8 // float (Size: 0x4)
UAWeaponAttributes.MoaX = 0xc // float (Size: 0x4)
UAWeaponAttributes.MoaY = 0x10 // float (Size: 0x4)
UAWeaponAttributes.VerticalRecoil = 0x14 // float (Size: 0x4)
UAWeaponAttributes.HorizontalRecoil = 0x18 // float (Size: 0x4)
UAWeaponViewEffectComponent.ViewEffectCurve = 0x100 // CurveFloat* (Size: 0x8)
UAWeaponViewEffectComponent.WeaponPostMat = 0x108 // MaterialInstance* (Size: 0x8)
UAWeaponViewEffectComponent.WeaponPostMatDynamic = 0x110 // MaterialInstanceDynamic* (Size: 0x8)
UseInventoryFlashStruct.UseTime = 0x0 // float (Size: 0x4)
UseInventoryFlashStruct.UsePosX = 0x4 // float (Size: 0x4)
UseInventoryFlashStruct.UsePosY = 0x8 // float (Size: 0x4)
UseInventoryFlashStruct.UsePosZ = 0xc // float (Size: 0x4)
VolumeMarkableInfo.VolumeID = 0x0 // int32_t (Size: 0x4)
VolumeMarkableInfo.ConfigID = 0x4 // int32_t (Size: 0x4)
VolumeSpawnedInventoryInfo.SpawnedInventory = 0x0 // TWeakObjectPtr<UObject> (Size: 0x8)
VolumeSpawnedInventoryInfo.SpawnInventoryInfo = 0x8 // FMissionObjectiveSpawnInventoryInfo (Size: 0x68)
MFCSettingsComponent.TargetMFC = 0xf8 // MaterialParameterCollection* (Size: 0x8)
MFCSettingsComponent.ScalarParameterSettings = 0x100 // TArray<FScalarParameterSetting> (Size: 0x10)
MFCSettingsComponent.VectorParameterSettings = 0x110 // TArray<FVectorParameterSetting> (Size: 0x10)
ScalarParameterSetting.Name = 0x0 // FString (Size: 0x10)
ScalarParameterSetting.Value = 0x10 // float (Size: 0x4)
ScalarParameterSetting.ResetValue = 0x14 // float (Size: 0x4)
UAShadowSettingComponent.ShadowMode = 0x238 // uint8_t (Size: 0x1)
UAShadowSettingComponent.CSMResolutionScale = 0x23c // int32_t (Size: 0x4)
UAShadowSettingComponent.bEnableCSMCache = 0x240 // bool (Size: 0x1)
UAShadowSettingComponent.BoundsRadius = 0x244 // float (Size: 0x4)
UAShadowSettingComponent.PreviewInfluenceRadius = 0x248 // DrawSphereComponent* (Size: 0x8)
UAShadowSettingComponent.DirectionalLightComponent = 0x250 // DirectionalLightComponent* (Size: 0x8)
VectorParameterSetting.Name = 0x0 // FString (Size: 0x10)
VectorParameterSetting.Value = 0x10 // FLinearColor (Size: 0x10)
VectorParameterSetting.ResetValue = 0x20 // FLinearColor (Size: 0x10)
CubemapData.TODTime = 0x0 // float (Size: 0x4)
CubemapData.CubemapTexture = 0x8 // TSoftObjectPtr<UObject> (Size: 0x28)
CubemapData.AverageBrightness = 0x30 // float (Size: 0x4)
CubemapData.IrradianceEnvironmentMapFloats = 0x38 // TArray<float> (Size: 0x10)
CubemapDataCollection.ConfigID = 0x0 // int32_t (Size: 0x4)
CubemapDataCollection.DataArray = 0x8 // TArray<FCubemapData> (Size: 0x10)
SGCameraMaterial_RainDrop.ShowThreshold = 0x730 // float (Size: 0x4)
UAClimateExtraParametersControlComponent.SunMoonLightComponent = 0x100 // MFClimateSunMoonSceneLightComponent* (Size: 0x8)
UAClimateExtraParametersControlComponent.bDebugDisableControlDawnSceneLightInfo = 0x108 // bool (Size: 0x1)
UAClimateExtraParametersControlComponent.Cloud2DDetailsTiling = 0x10c // float (Size: 0x4)
UAClimateExtraParametersControlComponent.Cloud2DDetailsWarping = 0x110 // float (Size: 0x4)
UAClimateExtraParametersControlComponent.Cloud2DOverallStrength = 0x114 // float (Size: 0x4)
UAClimateExtraParametersControlComponent.SkyAndCloudTint = 0x118 // FLinearColor (Size: 0x10)
UAClimateExtraParametersControlComponent.MPC = 0x128 // MaterialParameterCollection* (Size: 0x8)
UAMFClimateRain.On1PRainStateChange = 0x530 // FMulticastInlineDelegate (Size: 0x10)
UASkyLightCubemapBakerComponent.SceneCapturingTODTimes = 0x128 // TArray<float> (Size: 0x10)
UASkyLightCubemapBakerComponent.SkyLight = 0x138 // SkyLight* (Size: 0x8)
UASkyLightCubemapBakerComponent.CubemapDataCollections = 0x140 // TArray<FCubemapDataCollection> (Size: 0x10)
UASkyLightCubemapUpdaterComponent.SkyLight = 0x110 // SkyLight* (Size: 0x8)
UASkyLightCubemapUpdaterComponent.SkylightCubemap = 0x118 // TextureCube* (Size: 0x8)
UFixManager.UseBinaryLua = 0x28 // bool (Size: 0x1)
UFixManager.fixItemLis = 0x40 // TArray<UFixItem*> (Size: 0x10)
UStructLog.SocketName = 0x0 // FName (Size: 0x8)
UStructLog.bDisplaySocket = 0x8 // bool (Size: 0x1)
UStructLog.UIStartOffest = 0xc // FVector (Size: 0xc)
UStructLog.UIEndOffest = 0x18 // FVector (Size: 0xc)
UStructLog.UIPartName = 0x28 // FText (Size: 0x18)
UStructLog.bPlaceHolderInventory = 0x40 // bool (Size: 0x1)
UStructLog.FakeID = 0x44 // uint32_t (Size: 0x4)
ParticleSystemWidget.ParticleSystemTemplate = 0x130 // ParticleSystem* (Size: 0x8)
ParticleSystemWidget.bAutoActivate = 0x138 // bool (Size: 0x1)
ParticleSystemWidget.bReactivate = 0x139 // bool (Size: 0x1)
ParticleSystemWidget.WorldParticleComponent = 0x140 // UIParticleComponent* (Size: 0x8)
ParticleSystemWidget.WorldParticleActor = 0x148 // Actor* (Size: 0x8)
AnchorData.Offsets = 0x0 // FMargin (Size: 0x10)
AnchorData.Anchors = 0x10 // FAnchors (Size: 0x10)
AnchorData.Alignment = 0x20 // FVector2D (Size: 0x8)
AnimationEventBinding.Animation = 0x0 // WidgetAnimation* (Size: 0x8)
AnimationEventBinding.Delegate = 0x8 // FDelegate (Size: 0x10)
AnimationEventBinding.AnimationEvent = 0x18 // EEWidgetAnimationEvent (Size: 0x1)
AnimationEventBinding.UserTag = 0x1c // FName (Size: 0x8)
AsyncTaskDownloadImage.OnSuccess = 0x30 // FMulticastInlineDelegate (Size: 0x10)
AsyncTaskDownloadImage.OnFail = 0x40 // FMulticastInlineDelegate (Size: 0x10)
BackgroundBlur.Padding = 0x148 // FMargin (Size: 0x10)
BackgroundBlur.HorizontalAlignment = 0x158 // uint8_t (Size: 0x1)
BackgroundBlur.VerticalAlignment = 0x159 // uint8_t (Size: 0x1)
BackgroundBlur.bApplyAlphaToBlur = 0x15a // bool (Size: 0x1)
BackgroundBlur.BlurStrength = 0x15c // float (Size: 0x4)
BackgroundBlur.bOverrideAutoRadiusCalculation = 0x160 // bool (Size: 0x1)
BackgroundBlur.BlurRadius = 0x164 // int32_t (Size: 0x4)
BackgroundBlur.LowQualityFallbackBrush = 0x168 // FSlateBrush (Size: 0x90)
BackgroundBlurSlot.Padding = 0x60 // FMargin (Size: 0x10)
BackgroundBlurSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
BackgroundBlurSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
BlueprintWidgetAnimationDelegateBinding.Action = 0x0 // EEWidgetAnimationEvent (Size: 0x1)
BlueprintWidgetAnimationDelegateBinding.AnimationToBind = 0x4 // FName (Size: 0x8)
BlueprintWidgetAnimationDelegateBinding.FunctionNameToBind = 0xc // FName (Size: 0x8)
BlueprintWidgetAnimationDelegateBinding.UserTag = 0x14 // FName (Size: 0x8)
Border.HorizontalAlignment = 0x148 // uint8_t (Size: 0x1)
Border.VerticalAlignment = 0x149 // uint8_t (Size: 0x1)
Border.bShowEffectWhenDisabled = 0x14a // uint8_t (Size: 0x1)
Border.ContentColorAndOpacity = 0x14c // FLinearColor (Size: 0x10)
Border.ContentColorAndOpacityDelegate = 0x15c // FDelegate (Size: 0x10)
Border.Padding = 0x16c // FMargin (Size: 0x10)
Border.Background = 0x180 // FSlateBrush (Size: 0x90)
Border.BackgroundDelegate = 0x210 // FDelegate (Size: 0x10)
Border.BrushColor = 0x220 // FLinearColor (Size: 0x10)
Border.BrushColorDelegate = 0x230 // FDelegate (Size: 0x10)
Border.DesiredSizeScale = 0x240 // FVector2D (Size: 0x8)
Border.bFlipForRightToLeftFlowDirection = 0x248 // bool (Size: 0x1)
Border.OnMouseButtonDownEvent = 0x24c // FDelegate (Size: 0x10)
Border.OnMouseButtonUpEvent = 0x25c // FDelegate (Size: 0x10)
Border.OnMouseMoveEvent = 0x26c // FDelegate (Size: 0x10)
Border.OnMouseDoubleClickEvent = 0x27c // FDelegate (Size: 0x10)
BorderSlot.Padding = 0x60 // FMargin (Size: 0x10)
BorderSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
BorderSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
Button.Style = 0x148 // SlateWidgetStyleAsset* (Size: 0x8)
Button.WidgetStyle = 0x150 // FButtonStyle (Size: 0x298)
Button.ColorAndOpacity = 0x3e8 // FLinearColor (Size: 0x10)
Button.BackgroundColor = 0x3f8 // FLinearColor (Size: 0x10)
Button.ClickMethod = 0x408 // uint8_t (Size: 0x1)
Button.TouchMethod = 0x409 // uint8_t (Size: 0x1)
Button.PressMethod = 0x40a // uint8_t (Size: 0x1)
Button.IsFocusable = 0x40b // bool (Size: 0x1)
Button.isGray = 0x40c // bool (Size: 0x1)
Button.ClickCdTime = 0x410 // float (Size: 0x4)
Button.OnClicked = 0x420 // FMulticastInlineDelegate (Size: 0x10)
Button.OnPressed = 0x430 // FMulticastInlineDelegate (Size: 0x10)
Button.OnReleased = 0x440 // FMulticastInlineDelegate (Size: 0x10)
Button.OnHovered = 0x450 // FMulticastInlineDelegate (Size: 0x10)
Button.OnUnhovered = 0x460 // FMulticastInlineDelegate (Size: 0x10)
ButtonSlot.Padding = 0x60 // FMargin (Size: 0x10)
ButtonSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
ButtonSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
CanvasPanelSlot.LayoutData = 0x60 // FAnchorData (Size: 0x28)
CanvasPanelSlot.bAutoSize = 0x88 // bool (Size: 0x1)
CanvasPanelSlot.ZOrder = 0x8c // int32_t (Size: 0x4)
CheckBox.CheckedState = 0x148 // EECheckBoxState (Size: 0x1)
CheckBox.CheckedStateDelegate = 0x14c // FDelegate (Size: 0x10)
CheckBox.WidgetStyle = 0x160 // FCheckBoxStyle (Size: 0x5c8)
CheckBox.Style = 0x728 // SlateWidgetStyleAsset* (Size: 0x8)
CheckBox.UncheckedImage = 0x730 // SlateBrushAsset* (Size: 0x8)
CheckBox.UncheckedHoveredImage = 0x738 // SlateBrushAsset* (Size: 0x8)
CheckBox.UncheckedPressedImage = 0x740 // SlateBrushAsset* (Size: 0x8)
CheckBox.CheckedImage = 0x748 // SlateBrushAsset* (Size: 0x8)
CheckBox.CheckedHoveredImage = 0x750 // SlateBrushAsset* (Size: 0x8)
CheckBox.CheckedPressedImage = 0x758 // SlateBrushAsset* (Size: 0x8)
CheckBox.UndeterminedImage = 0x760 // SlateBrushAsset* (Size: 0x8)
CheckBox.UndeterminedHoveredImage = 0x768 // SlateBrushAsset* (Size: 0x8)
CheckBox.UndeterminedPressedImage = 0x770 // SlateBrushAsset* (Size: 0x8)
CheckBox.HorizontalAlignment = 0x778 // uint8_t (Size: 0x1)
CheckBox.Padding = 0x77c // FMargin (Size: 0x10)
CheckBox.BorderBackgroundColor = 0x790 // FSlateColor (Size: 0x28)
CheckBox.ClickMethod = 0x7b8 // uint8_t (Size: 0x1)
CheckBox.TouchMethod = 0x7b9 // uint8_t (Size: 0x1)
CheckBox.PressMethod = 0x7ba // uint8_t (Size: 0x1)
CheckBox.IsFocusable = 0x7bb // bool (Size: 0x1)
CheckBox.OnCheckStateChanged = 0x7c0 // FMulticastInlineDelegate (Size: 0x10)
CircularThrobber.NumberOfPieces = 0x130 // int32_t (Size: 0x4)
CircularThrobber.Period = 0x134 // float (Size: 0x4)
CircularThrobber.Radius = 0x138 // float (Size: 0x4)
CircularThrobber.PieceImage = 0x140 // SlateBrushAsset* (Size: 0x8)
CircularThrobber.Image = 0x148 // FSlateBrush (Size: 0x90)
CircularThrobber.bEnableRadius = 0x1d8 // bool (Size: 0x1)
ComboBox.Items = 0x130 // TArray<Object*> (Size: 0x10)
ComboBox.OnGenerateWidgetEvent = 0x140 // FDelegate (Size: 0x10)
ComboBox.bIsFocusable = 0x150 // bool (Size: 0x1)
ComboBoxString.DefaultOptions = 0x130 // TArray<FString> (Size: 0x10)
ComboBoxString.SelectedOption = 0x140 // FString (Size: 0x10)
ComboBoxString.WidgetStyle = 0x150 // FComboBoxStyle (Size: 0x420)
ComboBoxString.ItemStyle = 0x570 // FTableRowStyle (Size: 0x838)
ComboBoxString.ContentPadding = 0xda8 // FMargin (Size: 0x10)
ComboBoxString.MaxListHeight = 0xdb8 // float (Size: 0x4)
ComboBoxString.HasDownArrow = 0xdbc // bool (Size: 0x1)
ComboBoxString.EnableGamepadNavigationMode = 0xdbd // bool (Size: 0x1)
ComboBoxString.Font = 0xdc0 // FSlateFontInfo (Size: 0x60)
ComboBoxString.ForegroundColor = 0xe20 // FSlateColor (Size: 0x28)
ComboBoxString.bIsFocusable = 0xe48 // bool (Size: 0x1)
ComboBoxString.OnGenerateWidgetEvent = 0xe4c // FDelegate (Size: 0x10)
ComboBoxString.OnSelectionChanged = 0xe60 // FMulticastInlineDelegate (Size: 0x10)
ComboBoxString.OnOpening = 0xe70 // FMulticastInlineDelegate (Size: 0x10)
DelegateRuntimeBinding.ObjectName = 0x0 // FString (Size: 0x10)
DelegateRuntimeBinding.PropertyName = 0x10 // FName (Size: 0x8)
DelegateRuntimeBinding.FunctionName = 0x18 // FName (Size: 0x8)
DelegateRuntimeBinding.SourcePath = 0x20 // FDynamicPropertyPath (Size: 0x28)
DelegateRuntimeBinding.Kind = 0x48 // EEBindingKind (Size: 0x1)
DragDropOperation.Tag = 0x28 // FString (Size: 0x10)
DragDropOperation.Payload = 0x38 // Object* (Size: 0x8)
DragDropOperation.DefaultDragVisual = 0x40 // Widget* (Size: 0x8)
DragDropOperation.Pivot = 0x48 // EEDragPivot (Size: 0x1)
DragDropOperation.Offset = 0x4c // FVector2D (Size: 0x8)
DragDropOperation.EnableLerpAnim = 0x54 // bool (Size: 0x1)
DragDropOperation.OnDrop = 0x58 // FMulticastInlineDelegate (Size: 0x10)
DragDropOperation.OnDragCancelled = 0x68 // FMulticastInlineDelegate (Size: 0x10)
DragDropOperation.OnDragged = 0x78 // FMulticastInlineDelegate (Size: 0x10)
DynamicEntryBox.EntryWidgetClass = 0x200 // ClassProperty (Size: 0x8)
DynamicEntryBoxBase.EntryBoxType = 0x130 // EEDynamicBoxType (Size: 0x1)
DynamicEntryBoxBase.EntrySpacing = 0x134 // FVector2D (Size: 0x8)
DynamicEntryBoxBase.SpacingPattern = 0x140 // TArray<FVector2D> (Size: 0x10)
DynamicEntryBoxBase.EntrySizeRule = 0x150 // FSlateChildSize (Size: 0x8)
DynamicEntryBoxBase.EntryHorizontalAlignment = 0x158 // uint8_t (Size: 0x1)
DynamicEntryBoxBase.EntryVerticalAlignment = 0x159 // uint8_t (Size: 0x1)
DynamicEntryBoxBase.MaxElementSize = 0x15c // int32_t (Size: 0x4)
DynamicEntryBoxBase.RadialBoxSettings = 0x160 // FRadialBoxSettings (Size: 0xc)
DynamicEntryBoxBase.EntryWidgetPool = 0x180 // FUserWidgetPool (Size: 0x80)
EditableText.Text = 0x130 // FText (Size: 0x18)
EditableText.TextDelegate = 0x148 // FDelegate (Size: 0x10)
EditableText.HintText = 0x158 // FText (Size: 0x18)
EditableText.HintTextDelegate = 0x170 // FDelegate (Size: 0x10)
EditableText.WidgetStyle = 0x180 // FEditableTextStyle (Size: 0x240)
EditableText.Style = 0x3c0 // SlateWidgetStyleAsset* (Size: 0x8)
EditableText.BackgroundImageSelected = 0x3c8 // SlateBrushAsset* (Size: 0x8)
EditableText.BackgroundImageComposing = 0x3d0 // SlateBrushAsset* (Size: 0x8)
EditableText.CaretImage = 0x3d8 // SlateBrushAsset* (Size: 0x8)
EditableText.Font = 0x3e0 // FSlateFontInfo (Size: 0x60)
EditableText.ColorAndOpacity = 0x440 // FSlateColor (Size: 0x28)
EditableText.IsReadOnly = 0x468 // bool (Size: 0x1)
EditableText.IsPassword = 0x469 // bool (Size: 0x1)
EditableText.MinimumDesiredWidth = 0x46c // float (Size: 0x4)
EditableText.IsCaretMovedWhenGainFocus = 0x470 // bool (Size: 0x1)
EditableText.SelectAllTextWhenFocused = 0x471 // bool (Size: 0x1)
EditableText.RevertTextOnEscape = 0x472 // bool (Size: 0x1)
EditableText.ClearKeyboardFocusOnCommit = 0x473 // bool (Size: 0x1)
EditableText.SelectAllTextOnCommit = 0x474 // bool (Size: 0x1)
EditableText.AllowContextMenu = 0x475 // bool (Size: 0x1)
EditableText.KeyboardType = 0x476 // uint8_t (Size: 0x1)
EditableText.VirtualKeyboardOptions = 0x477 // FVirtualKeyboardOptions (Size: 0x1)
EditableText.VirtualKeyboardTrigger = 0x478 // EEVirtualKeyboardTrigger (Size: 0x1)
EditableText.VirtualKeyboardDismissAction = 0x479 // EEVirtualKeyboardDismissAction (Size: 0x1)
EditableText.Justification = 0x47a // uint8_t (Size: 0x1)
EditableText.ShapedTextOptions = 0x47b // FShapedTextOptions (Size: 0x3)
EditableText.OnTextChanged = 0x480 // FMulticastInlineDelegate (Size: 0x10)
EditableText.OnTextCommitted = 0x490 // FMulticastInlineDelegate (Size: 0x10)
EditableTextBox.Text = 0x130 // FText (Size: 0x18)
EditableTextBox.TextDelegate = 0x148 // FDelegate (Size: 0x10)
EditableTextBox.WidgetStyle = 0x158 // FEditableTextBoxStyle (Size: 0x868)
EditableTextBox.Style = 0x9c0 // SlateWidgetStyleAsset* (Size: 0x8)
EditableTextBox.HintText = 0x9c8 // FText (Size: 0x18)
EditableTextBox.HintTextDelegate = 0x9e0 // FDelegate (Size: 0x10)
EditableTextBox.Font = 0x9f0 // FSlateFontInfo (Size: 0x60)
EditableTextBox.ForegroundColor = 0xa50 // FLinearColor (Size: 0x10)
EditableTextBox.BackgroundColor = 0xa60 // FLinearColor (Size: 0x10)
EditableTextBox.ReadOnlyForegroundColor = 0xa70 // FLinearColor (Size: 0x10)
EditableTextBox.IsReadOnly = 0xa80 // bool (Size: 0x1)
EditableTextBox.IsPassword = 0xa81 // bool (Size: 0x1)
EditableTextBox.MinimumDesiredWidth = 0xa84 // float (Size: 0x4)
EditableTextBox.Padding = 0xa88 // FMargin (Size: 0x10)
EditableTextBox.HintVAlignment = 0xa98 // uint8_t (Size: 0x1)
EditableTextBox.IsCaretMovedWhenGainFocus = 0xa99 // bool (Size: 0x1)
EditableTextBox.SelectAllTextWhenFocused = 0xa9a // bool (Size: 0x1)
EditableTextBox.RevertTextOnEscape = 0xa9b // bool (Size: 0x1)
EditableTextBox.ClearKeyboardFocusOnCommit = 0xa9c // bool (Size: 0x1)
EditableTextBox.SelectAllTextOnCommit = 0xa9d // bool (Size: 0x1)
EditableTextBox.AllowContextMenu = 0xa9e // bool (Size: 0x1)
EditableTextBox.KeyboardType = 0xa9f // uint8_t (Size: 0x1)
EditableTextBox.VirtualKeyboardOptions = 0xaa0 // FVirtualKeyboardOptions (Size: 0x1)
EditableTextBox.VirtualKeyboardTrigger = 0xaa1 // EEVirtualKeyboardTrigger (Size: 0x1)
EditableTextBox.VirtualKeyboardDismissAction = 0xaa2 // EEVirtualKeyboardDismissAction (Size: 0x1)
EditableTextBox.Justification = 0xaa3 // uint8_t (Size: 0x1)
EditableTextBox.ShapedTextOptions = 0xaa4 // FShapedTextOptions (Size: 0x3)
EditableTextBox.OnTextChanged = 0xaa8 // FMulticastInlineDelegate (Size: 0x10)
EditableTextBox.OnTextCommitted = 0xab8 // FMulticastInlineDelegate (Size: 0x10)
ExpandableArea.Style = 0x138 // FExpandableAreaStyle (Size: 0x130)
ExpandableArea.BorderBrush = 0x268 // FSlateBrush (Size: 0x90)
ExpandableArea.BorderColor = 0x2f8 // FSlateColor (Size: 0x28)
ExpandableArea.bIsExpanded = 0x320 // bool (Size: 0x1)
ExpandableArea.MaxHeight = 0x324 // float (Size: 0x4)
ExpandableArea.HeaderPadding = 0x328 // FMargin (Size: 0x10)
ExpandableArea.AreaPadding = 0x338 // FMargin (Size: 0x10)
ExpandableArea.OnExpansionChanged = 0x348 // FMulticastInlineDelegate (Size: 0x10)
ExpandableArea.HeaderContent = 0x358 // Widget* (Size: 0x8)
ExpandableArea.BodyContent = 0x360 // Widget* (Size: 0x8)
GridPanel.ColumnFill = 0x148 // TArray<float> (Size: 0x10)
GridPanel.RowFill = 0x158 // TArray<float> (Size: 0x10)
GridSlot.Padding = 0x60 // FMargin (Size: 0x10)
GridSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
GridSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
GridSlot.Row = 0x74 // int32_t (Size: 0x4)
GridSlot.RowSpan = 0x78 // int32_t (Size: 0x4)
GridSlot.Column = 0x7c // int32_t (Size: 0x4)
GridSlot.ColumnSpan = 0x80 // int32_t (Size: 0x4)
GridSlot.Layer = 0x84 // int32_t (Size: 0x4)
GridSlot.Nudge = 0x88 // FVector2D (Size: 0x8)
HorizontalBoxSlot.Padding = 0x68 // FMargin (Size: 0x10)
HorizontalBoxSlot.Size = 0x78 // FSlateChildSize (Size: 0x8)
HorizontalBoxSlot.HorizontalAlignment = 0x80 // uint8_t (Size: 0x1)
HorizontalBoxSlot.VerticalAlignment = 0x81 // uint8_t (Size: 0x1)
Image.Brush = 0x130 // FSlateBrush (Size: 0x90)
Image.BrushDelegate = 0x1c0 // FDelegate (Size: 0x10)
Image.ColorAndOpacity = 0x1d0 // FLinearColor (Size: 0x10)
Image.ColorAndOpacityDelegate = 0x1e0 // FDelegate (Size: 0x10)
Image.bFlipForRightToLeftFlowDirection = 0x1f0 // bool (Size: 0x1)
Image.bHideOversea = 0x1f4 // uint8_t (Size: 0x1)
Image.bAsyncLoad = 0x1f4 // uint8_t (Size: 0x1)
Image.OnMouseButtonDownEvent = 0x1f8 // FDelegate (Size: 0x10)
Image.DeferredObject = 0x240 // TSoftObjectPtr<UObject> (Size: 0x28)
InputKeySelector.WidgetStyle = 0x130 // FButtonStyle (Size: 0x298)
InputKeySelector.TextStyle = 0x3c8 // FTextBlockStyle (Size: 0x290)
InputKeySelector.SelectedKey = 0x658 // FInputChord (Size: 0x20)
InputKeySelector.Font = 0x678 // FSlateFontInfo (Size: 0x60)
InputKeySelector.Margin = 0x6d8 // FMargin (Size: 0x10)
InputKeySelector.ColorAndOpacity = 0x6e8 // FLinearColor (Size: 0x10)
InputKeySelector.KeySelectionText = 0x6f8 // FText (Size: 0x18)
InputKeySelector.NoKeySpecifiedText = 0x710 // FText (Size: 0x18)
InputKeySelector.bAllowModifierKeys = 0x728 // bool (Size: 0x1)
InputKeySelector.bAllowGamepadKeys = 0x729 // bool (Size: 0x1)
InputKeySelector.EscapeKeys = 0x730 // TArray<FKey> (Size: 0x10)
InputKeySelector.OnKeySelected = 0x740 // FMulticastInlineDelegate (Size: 0x10)
InputKeySelector.OnIsSelectingKeyChanged = 0x750 // FMulticastInlineDelegate (Size: 0x10)
InputKeySelector.OnButtonClicked = 0x760 // FMulticastInlineDelegate (Size: 0x10)
InvalidationBox.bCanCache = 0x148 // bool (Size: 0x1)
InvalidationBox.CacheRelativeTransforms = 0x149 // bool (Size: 0x1)
LazyLoadBinding.Name = 0x0 // FString (Size: 0x10)
LazyLoadBinding.PanelSlot = 0x10 // TWeakObjectPtr<UObject> (Size: 0x8)
LazyLoadBinding.Visibility = 0x18 // EESlateVisibility (Size: 0x1)
ListItemData.Index = 0x28 // int32_t (Size: 0x4)
ListItemData.Content = 0x30 // FText (Size: 0x18)
ListView.ListItemDataPool = 0x330 // TArray<Object*> (Size: 0x10)
ListView.Orientation = 0x340 // uint8_t (Size: 0x1)
ListView.SelectionMode = 0x341 // uint8_t (Size: 0x1)
ListView.ConsumeMouseWheel = 0x342 // EEConsumeMouseWheel (Size: 0x1)
ListView.bClearSelectionOnClick = 0x343 // bool (Size: 0x1)
ListView.bIsFocusable = 0x344 // bool (Size: 0x1)
ListView.EntrySpacing = 0x348 // float (Size: 0x4)
ListView.bReturnFocusToSelection = 0x34c // bool (Size: 0x1)
ListView.bEnableScrolledDelegate = 0x34d // bool (Size: 0x1)
ListView.ScrollOffsetScalar = 0x350 // float (Size: 0x4)
ListView.ScrollBarStyle = 0x358 // FScrollBarStyle (Size: 0x518)
ListView.ListItems = 0x870 // TArray<Object*> (Size: 0x10)
ListView.BP_OnEntryInitialized = 0x890 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnItemClicked = 0x8a0 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnItemDoubleClicked = 0x8b0 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnItemIsHoveredChanged = 0x8c0 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnItemSelectionChanged = 0x8d0 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnItemScrolledIntoView = 0x8e0 // FMulticastInlineDelegate (Size: 0x10)
ListView.BP_OnTabelViewScrolled = 0x8f0 // FMulticastInlineDelegate (Size: 0x10)
ListViewBase.EntryWidgetClass = 0x130 // ClassProperty (Size: 0x8)
ListViewBase.WheelScrollMultiplier = 0x138 // float (Size: 0x4)
ListViewBase.bEnableScrollAnimation = 0x13c // bool (Size: 0x1)
ListViewBase.bEnableFixedLineOffset = 0x13d // bool (Size: 0x1)
ListViewBase.bEnableOverscroll = 0x13e // bool (Size: 0x1)
ListViewBase.ScrollboxSizeOverride = 0x140 // FVector2D (Size: 0x8)
ListViewBase.ScrollbarThickness = 0x148 // FVector2D (Size: 0x8)
ListViewBase.ScrollbarPadding = 0x150 // FMargin (Size: 0x10)
ListViewBase.BP_OnListViewIsHoveredChanged = 0x160 // FMulticastInlineDelegate (Size: 0x10)
ListViewBase.FixedLineScrollOffset = 0x170 // float (Size: 0x4)
ListViewBase.BP_OnEntryGenerated = 0x178 // FMulticastInlineDelegate (Size: 0x10)
ListViewBase.BP_OnEntryReleased = 0x188 // FMulticastInlineDelegate (Size: 0x10)
ListViewBase.EntryWidgetPool = 0x198 // FUserWidgetPool (Size: 0x80)
MenuAnchor.MenuClass = 0x148 // ClassProperty (Size: 0x8)
MenuAnchor.OnGetMenuContentEvent = 0x150 // FDelegate (Size: 0x10)
MenuAnchor.OnGetUserMenuContentEvent = 0x160 // FDelegate (Size: 0x10)
MenuAnchor.Placement = 0x170 // uint8_t (Size: 0x1)
MenuAnchor.bFitInWindow = 0x171 // bool (Size: 0x1)
MenuAnchor.ShouldDeferPaintingAfterWindowContent = 0x172 // bool (Size: 0x1)
MenuAnchor.UseApplicationMenuStack = 0x173 // bool (Size: 0x1)
MenuAnchor.OnMenuOpenChanged = 0x178 // FMulticastInlineDelegate (Size: 0x10)
MovieScene2DTransformMask.Mask = 0x0 // uint32_t (Size: 0x4)
MovieScene2DTransformSection.TransformMask = 0xf0 // FMovieScene2DTransformMask (Size: 0x4)
MovieScene2DTransformSection.Translation = 0xf8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene2DTransformSection.Rotation = 0x238 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene2DTransformSection.Scale = 0x2d8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieScene2DTransformSection.Shear = 0x418 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSection.TopCurve = 0xe8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSection.LeftCurve = 0x188 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSection.RightCurve = 0x228 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSection.BottomCurve = 0x2c8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSectionTemplate.TopCurve = 0x38 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSectionTemplate.LeftCurve = 0xd8 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSectionTemplate.RightCurve = 0x178 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSectionTemplate.BottomCurve = 0x218 // FMovieSceneFloatChannel (Size: 0xa0)
MovieSceneMarginSectionTemplate.BlendType = 0x2b8 // EEMovieSceneBlendType (Size: 0x1)
MovieSceneWidgetMaterialSectionTemplate.BrushPropertyNamePath = 0x80 // TArray<FName> (Size: 0x10)
MovieSceneWidgetMaterialTrack.BrushPropertyNamePath = 0x90 // TArray<FName> (Size: 0x10)
MovieSceneWidgetMaterialTrack.TrackName = 0xa0 // FName (Size: 0x8)
MultiLineEditableText.Text = 0x150 // FText (Size: 0x18)
MultiLineEditableText.HintText = 0x168 // FText (Size: 0x18)
MultiLineEditableText.HintTextDelegate = 0x180 // FDelegate (Size: 0x10)
MultiLineEditableText.WidgetStyle = 0x190 // FTextBlockStyle (Size: 0x290)
MultiLineEditableText.bIsReadOnly = 0x420 // bool (Size: 0x1)
MultiLineEditableText.Font = 0x428 // FSlateFontInfo (Size: 0x60)
MultiLineEditableText.SelectAllTextWhenFocused = 0x488 // bool (Size: 0x1)
MultiLineEditableText.ClearTextSelectionOnFocusLoss = 0x489 // bool (Size: 0x1)
MultiLineEditableText.RevertTextOnEscape = 0x48a // bool (Size: 0x1)
MultiLineEditableText.ClearKeyboardFocusOnCommit = 0x48b // bool (Size: 0x1)
MultiLineEditableText.AllowContextMenu = 0x48c // bool (Size: 0x1)
MultiLineEditableText.VirtualKeyboardOptions = 0x48d // FVirtualKeyboardOptions (Size: 0x1)
MultiLineEditableText.VirtualKeyboardDismissAction = 0x48e // EEVirtualKeyboardDismissAction (Size: 0x1)
MultiLineEditableText.OnTextChanged = 0x490 // FMulticastInlineDelegate (Size: 0x10)
MultiLineEditableText.OnTextCommitted = 0x4a0 // FMulticastInlineDelegate (Size: 0x10)
MultiLineEditableTextBox.Text = 0x150 // FText (Size: 0x18)
MultiLineEditableTextBox.HintText = 0x168 // FText (Size: 0x18)
MultiLineEditableTextBox.HintTextDelegate = 0x180 // FDelegate (Size: 0x10)
MultiLineEditableTextBox.WidgetStyle = 0x190 // FEditableTextBoxStyle (Size: 0x868)
MultiLineEditableTextBox.TextStyle = 0x9f8 // FTextBlockStyle (Size: 0x290)
MultiLineEditableTextBox.bIsReadOnly = 0xc88 // bool (Size: 0x1)
MultiLineEditableTextBox.AllowContextMenu = 0xc89 // bool (Size: 0x1)
MultiLineEditableTextBox.VirtualKeyboardOptions = 0xc8a // FVirtualKeyboardOptions (Size: 0x1)
MultiLineEditableTextBox.VirtualKeyboardDismissAction = 0xc8b // EEVirtualKeyboardDismissAction (Size: 0x1)
MultiLineEditableTextBox.Style = 0xc90 // SlateWidgetStyleAsset* (Size: 0x8)
MultiLineEditableTextBox.Font = 0xc98 // FSlateFontInfo (Size: 0x60)
MultiLineEditableTextBox.ForegroundColor = 0xcf8 // FLinearColor (Size: 0x10)
MultiLineEditableTextBox.BackgroundColor = 0xd08 // FLinearColor (Size: 0x10)
MultiLineEditableTextBox.ReadOnlyForegroundColor = 0xd18 // FLinearColor (Size: 0x10)
MultiLineEditableTextBox.OnTextChanged = 0xd28 // FMulticastInlineDelegate (Size: 0x10)
MultiLineEditableTextBox.OnTextCommitted = 0xd38 // FMulticastInlineDelegate (Size: 0x10)
NamedSlotBinding.Name = 0x0 // FName (Size: 0x8)
NamedSlotBinding.Content = 0x8 // Widget* (Size: 0x8)
OverlaySlot.Padding = 0x68 // FMargin (Size: 0x10)
OverlaySlot.HorizontalAlignment = 0x78 // uint8_t (Size: 0x1)
OverlaySlot.VerticalAlignment = 0x79 // uint8_t (Size: 0x1)
PanelSlot.ContentClass = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
PanelSlot.Parent = 0x50 // PanelWidget* (Size: 0x8)
PanelSlot.Content = 0x58 // Widget* (Size: 0x8)
PanelWidget.Slots = 0x130 // TArray<PanelSlot*> (Size: 0x10)
ProgressBar.WidgetStyle = 0x130 // FProgressBarStyle (Size: 0x1b8)
ProgressBar.Style = 0x2e8 // SlateWidgetStyleAsset* (Size: 0x8)
ProgressBar.BackgroundImage = 0x2f0 // SlateBrushAsset* (Size: 0x8)
ProgressBar.FillImage = 0x2f8 // SlateBrushAsset* (Size: 0x8)
ProgressBar.MarqueeImage = 0x300 // SlateBrushAsset* (Size: 0x8)
ProgressBar.Percent = 0x308 // float (Size: 0x4)
ProgressBar.BarFillType = 0x30c // uint8_t (Size: 0x1)
ProgressBar.bIsMarquee = 0x30d // bool (Size: 0x1)
ProgressBar.BorderPadding = 0x310 // FVector2D (Size: 0x8)
ProgressBar.PercentDelegate = 0x318 // FDelegate (Size: 0x10)
ProgressBar.FillColorAndOpacity = 0x328 // FLinearColor (Size: 0x10)
ProgressBar.FillColorAndOpacityDelegate = 0x338 // FDelegate (Size: 0x10)
PropertyBinding.SourceObject = 0x28 // TWeakObjectPtr<UObject> (Size: 0x8)
PropertyBinding.SourcePath = 0x30 // FDynamicPropertyPath (Size: 0x28)
PropertyBinding.DestinationProperty = 0x58 // FName (Size: 0x8)
RadialBoxSettings.bDistributeItemsEvenly = 0x0 // bool (Size: 0x1)
RadialBoxSettings.AngleBetweenItems = 0x4 // float (Size: 0x4)
RadialBoxSettings.StartingAngle = 0x8 // float (Size: 0x4)
RetainerBox.bRetainRender = 0x148 // bool (Size: 0x1)
RetainerBox.RenderOnInvalidation = 0x149 // bool (Size: 0x1)
RetainerBox.RenderOnPhase = 0x14a // bool (Size: 0x1)
RetainerBox.Phase = 0x14c // int32_t (Size: 0x4)
RetainerBox.PhaseCount = 0x150 // int32_t (Size: 0x4)
RetainerBox.EffectMaterial = 0x158 // MaterialInterface* (Size: 0x8)
RetainerBox.TextureParameter = 0x160 // FName (Size: 0x8)
RichImageRow.Brush = 0x8 // FSlateBrush (Size: 0x90)
RichTextBlock.IsDecoratorAutoWrap = 0x150 // bool (Size: 0x1)
RichTextBlock.Text = 0x158 // FText (Size: 0x18)
RichTextBlock.TextStyleSet = 0x170 // DataTable* (Size: 0x8)
RichTextBlock.DecoratorClasses = 0x178 // TArray<ClassProperty> (Size: 0x10)
RichTextBlock.bOverrideDefaultStyle = 0x188 // bool (Size: 0x1)
RichTextBlock.DefaultTextStyleOverride = 0x190 // FTextBlockStyle (Size: 0x290)
RichTextBlock.MinDesiredWidth = 0x420 // float (Size: 0x4)
RichTextBlock.TextTransformPolicy = 0x424 // EETextTransformPolicy (Size: 0x1)
RichTextBlock.LocalizationFeature = 0x428 // int32_t (Size: 0x4)
RichTextBlock.LocalizationUpper = 0x42c // bool (Size: 0x1)
RichTextBlock.bShowDetail = 0x42d // bool (Size: 0x1)
RichTextBlock.bHandleLongText = 0x42e // bool (Size: 0x1)
RichTextBlock.MaxTextLength = 0x430 // int32_t (Size: 0x4)
RichTextBlock.bEnableAutoTruncate = 0x435 // bool (Size: 0x1)
RichTextBlock.DefaultTextStyle = 0x438 // FTextBlockStyle (Size: 0x290)
RichTextBlock.InstanceDecorators = 0x6c8 // TArray<RichTextBlockDecorator*> (Size: 0x10)
RichTextBlockImageDecorator.ImageSet = 0x28 // DataTable* (Size: 0x8)
RichTextStyleRow.TextStyle = 0x8 // FTextBlockStyle (Size: 0x290)
SafeZone.PadLeft = 0x148 // bool (Size: 0x1)
SafeZone.PadRight = 0x149 // bool (Size: 0x1)
SafeZone.PadTop = 0x14a // bool (Size: 0x1)
SafeZone.PadBottom = 0x14b // bool (Size: 0x1)
SafeZoneSlot.bIsTitleSafe = 0x60 // bool (Size: 0x1)
SafeZoneSlot.SafeAreaScale = 0x64 // FMargin (Size: 0x10)
SafeZoneSlot.HAlign = 0x74 // uint8_t (Size: 0x1)
SafeZoneSlot.VAlign = 0x75 // uint8_t (Size: 0x1)
SafeZoneSlot.Padding = 0x78 // FMargin (Size: 0x10)
ScaleBox.Stretch = 0x148 // uint8_t (Size: 0x1)
ScaleBox.StretchDirection = 0x149 // uint8_t (Size: 0x1)
ScaleBox.UserSpecifiedScale = 0x14c // float (Size: 0x4)
ScaleBox.IgnoreInheritedScale = 0x150 // bool (Size: 0x1)
ScaleBoxSlot.Padding = 0x60 // FMargin (Size: 0x10)
ScaleBoxSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
ScaleBoxSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
ScrollBar.WidgetStyle = 0x130 // FScrollBarStyle (Size: 0x518)
ScrollBar.Style = 0x648 // SlateWidgetStyleAsset* (Size: 0x8)
ScrollBar.bAlwaysShowScrollbar = 0x650 // bool (Size: 0x1)
ScrollBar.bAlwaysShowScrollbarTrack = 0x651 // bool (Size: 0x1)
ScrollBar.Orientation = 0x652 // uint8_t (Size: 0x1)
ScrollBar.Thickness = 0x654 // FVector2D (Size: 0x8)
ScrollBar.Padding = 0x65c // FMargin (Size: 0x10)
ScrollBox.WidgetStyle = 0x148 // FScrollBoxStyle (Size: 0x248)
ScrollBox.WidgetBarStyle = 0x390 // FScrollBarStyle (Size: 0x518)
ScrollBox.Style = 0x8a8 // SlateWidgetStyleAsset* (Size: 0x8)
ScrollBox.BarStyle = 0x8b0 // SlateWidgetStyleAsset* (Size: 0x8)
ScrollBox.Orientation = 0x8b8 // uint8_t (Size: 0x1)
ScrollBox.ScrollBarVisibility = 0x8b9 // EESlateVisibility (Size: 0x1)
ScrollBox.ConsumeMouseWheel = 0x8ba // EEConsumeMouseWheel (Size: 0x1)
ScrollBox.ScrollbarThickness = 0x8bc // FVector2D (Size: 0x8)
ScrollBox.ScrollbarPadding = 0x8c4 // FMargin (Size: 0x10)
ScrollBox.AlwaysShowScrollbar = 0x8d4 // bool (Size: 0x1)
ScrollBox.AlwaysShowScrollbarTrack = 0x8d5 // bool (Size: 0x1)
ScrollBox.AllowOverscroll = 0x8d6 // bool (Size: 0x1)
ScrollBox.bAnimateWheelScrolling = 0x8d7 // bool (Size: 0x1)
ScrollBox.bEnableScrolling = 0x8d8 // bool (Size: 0x1)
ScrollBox.NavigationDestination = 0x8d9 // EEDescendantScrollDestination (Size: 0x1)
ScrollBox.NavigationScrollPadding = 0x8dc // float (Size: 0x4)
ScrollBox.ScrollWhenFocusChanges = 0x8e0 // EEScrollWhenFocusChanges (Size: 0x1)
ScrollBox.bAllowRightClickDragScrolling = 0x8e1 // bool (Size: 0x1)
ScrollBox.WheelScrollMultiplier = 0x8e4 // float (Size: 0x4)
ScrollBox.OnUserScrolled = 0x8e8 // FMulticastInlineDelegate (Size: 0x10)
ScrollBox.BP_OnScrollboxIsHoveredChanged = 0x8f8 // FMulticastInlineDelegate (Size: 0x10)
ScrollBoxSlot.Padding = 0x60 // FMargin (Size: 0x10)
ScrollBoxSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
ScrollBoxSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
ShapedTextOptions.bOverride_TextShapingMethod = 0x0 // uint8_t (Size: 0x1)
ShapedTextOptions.bOverride_TextFlowDirection = 0x0 // uint8_t (Size: 0x1)
ShapedTextOptions.TextShapingMethod = 0x1 // EETextShapingMethod (Size: 0x1)
ShapedTextOptions.TextFlowDirection = 0x2 // EETextFlowDirection (Size: 0x1)
SizeBox.WidthOverride = 0x158 // float (Size: 0x4)
SizeBox.HeightOverride = 0x15c // float (Size: 0x4)
SizeBox.MinDesiredWidth = 0x160 // float (Size: 0x4)
SizeBox.MinDesiredHeight = 0x164 // float (Size: 0x4)
SizeBox.MaxDesiredWidth = 0x168 // float (Size: 0x4)
SizeBox.MaxDesiredHeight = 0x16c // float (Size: 0x4)
SizeBox.MinAspectRatio = 0x170 // float (Size: 0x4)
SizeBox.MaxAspectRatio = 0x174 // float (Size: 0x4)
SizeBox.bOverride_WidthOverride = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_HeightOverride = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MinDesiredWidth = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MinDesiredHeight = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MaxDesiredWidth = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MaxDesiredHeight = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MinAspectRatio = 0x178 // uint8_t (Size: 0x1)
SizeBox.bOverride_MaxAspectRatio = 0x178 // uint8_t (Size: 0x1)
SizeBoxSlot.Padding = 0x60 // FMargin (Size: 0x10)
SizeBoxSlot.HorizontalAlignment = 0x80 // uint8_t (Size: 0x1)
SizeBoxSlot.VerticalAlignment = 0x81 // uint8_t (Size: 0x1)
SlateAccessibleWidgetData.bCanChildrenBeAccessible = 0x28 // bool (Size: 0x1)
SlateAccessibleWidgetData.AccessibleBehavior = 0x29 // EESlateAccessibleBehavior (Size: 0x1)
SlateAccessibleWidgetData.AccessibleSummaryBehavior = 0x2a // EESlateAccessibleBehavior (Size: 0x1)
SlateAccessibleWidgetData.AccessibleText = 0x30 // FText (Size: 0x18)
SlateAccessibleWidgetData.AccessibleTextDelegate = 0x48 // FDelegate (Size: 0x10)
SlateAccessibleWidgetData.AccessibleSummaryText = 0x58 // FText (Size: 0x18)
SlateAccessibleWidgetData.AccessibleSummaryTextDelegate = 0x70 // FDelegate (Size: 0x10)
SlateChildSize.Value = 0x0 // float (Size: 0x4)
SlateChildSize.SizeRule = 0x4 // uint8_t (Size: 0x1)
SlateMeshVertex.position = 0x0 // FVector2D (Size: 0x8)
SlateMeshVertex.Color = 0x8 // FColor (Size: 0x4)
SlateMeshVertex.UV0 = 0xc // FVector2D (Size: 0x8)
SlateMeshVertex.UV1 = 0x14 // FVector2D (Size: 0x8)
SlateMeshVertex.UV2 = 0x1c // FVector2D (Size: 0x8)
SlateMeshVertex.UV3 = 0x24 // FVector2D (Size: 0x8)
SlateMeshVertex.UV4 = 0x2c // FVector2D (Size: 0x8)
SlateMeshVertex.UV5 = 0x34 // FVector2D (Size: 0x8)
SlateVectorArtData.VertexData = 0x28 // TArray<FSlateMeshVertex> (Size: 0x10)
SlateVectorArtData.IndexData = 0x38 // TArray<uint32_t> (Size: 0x10)
SlateVectorArtData.Material = 0x48 // MaterialInterface* (Size: 0x8)
SlateVectorArtData.ExtentMin = 0x50 // FVector2D (Size: 0x8)
SlateVectorArtData.ExtentMax = 0x58 // FVector2D (Size: 0x8)
Slider.Value = 0x130 // float (Size: 0x4)
Slider.ValueDelegate = 0x134 // FDelegate (Size: 0x10)
Slider.MinValue = 0x144 // float (Size: 0x4)
Slider.MaxValue = 0x148 // float (Size: 0x4)
Slider.WidgetStyle = 0x150 // FSliderStyle (Size: 0x370)
Slider.Orientation = 0x4c0 // uint8_t (Size: 0x1)
Slider.SliderBarColor = 0x4c4 // FLinearColor (Size: 0x10)
Slider.SliderHandleColor = 0x4d4 // FLinearColor (Size: 0x10)
Slider.IndentHandle = 0x4e4 // bool (Size: 0x1)
Slider.Locked = 0x4e5 // bool (Size: 0x1)
Slider.MouseUsesStep = 0x4e6 // bool (Size: 0x1)
Slider.RequiresControllerLock = 0x4e7 // bool (Size: 0x1)
Slider.StepSize = 0x4e8 // float (Size: 0x4)
Slider.IsFocusable = 0x4ec // bool (Size: 0x1)
Slider.OnMouseCaptureBegin = 0x4f0 // FMulticastInlineDelegate (Size: 0x10)
Slider.OnMouseCaptureEnd = 0x500 // FMulticastInlineDelegate (Size: 0x10)
Slider.OnControllerCaptureBegin = 0x510 // FMulticastInlineDelegate (Size: 0x10)
Slider.OnControllerCaptureEnd = 0x520 // FMulticastInlineDelegate (Size: 0x10)
Slider.OnValueChanged = 0x530 // FMulticastInlineDelegate (Size: 0x10)
Spacer.Size = 0x130 // FVector2D (Size: 0x8)
SpinBox.Value = 0x130 // float (Size: 0x4)
SpinBox.ValueDelegate = 0x134 // FDelegate (Size: 0x10)
SpinBox.WidgetStyle = 0x148 // FSpinBoxStyle (Size: 0x310)
SpinBox.Style = 0x458 // SlateWidgetStyleAsset* (Size: 0x8)
SpinBox.MinFractionalDigits = 0x460 // int32_t (Size: 0x4)
SpinBox.MaxFractionalDigits = 0x464 // int32_t (Size: 0x4)
SpinBox.bAlwaysUsesDeltaSnap = 0x468 // bool (Size: 0x1)
SpinBox.Delta = 0x46c // float (Size: 0x4)
SpinBox.SliderExponent = 0x470 // float (Size: 0x4)
SpinBox.Font = 0x478 // FSlateFontInfo (Size: 0x60)
SpinBox.Justification = 0x4d8 // uint8_t (Size: 0x1)
SpinBox.MinDesiredWidth = 0x4dc // float (Size: 0x4)
SpinBox.ClearKeyboardFocusOnCommit = 0x4e0 // bool (Size: 0x1)
SpinBox.SelectAllTextOnCommit = 0x4e1 // bool (Size: 0x1)
SpinBox.ForegroundColor = 0x4e8 // FSlateColor (Size: 0x28)
SpinBox.OnValueChanged = 0x510 // FMulticastInlineDelegate (Size: 0x10)
SpinBox.OnValueCommitted = 0x520 // FMulticastInlineDelegate (Size: 0x10)
SpinBox.OnBeginSliderMovement = 0x530 // FMulticastInlineDelegate (Size: 0x10)
SpinBox.OnEndSliderMovement = 0x540 // FMulticastInlineDelegate (Size: 0x10)
SpinBox.bOverride_MinValue = 0x550 // uint8_t (Size: 0x1)
SpinBox.bOverride_MaxValue = 0x550 // uint8_t (Size: 0x1)
SpinBox.bOverride_MinSliderValue = 0x550 // uint8_t (Size: 0x1)
SpinBox.bOverride_MaxSliderValue = 0x550 // uint8_t (Size: 0x1)
SpinBox.MinValue = 0x554 // float (Size: 0x4)
SpinBox.MaxValue = 0x558 // float (Size: 0x4)
SpinBox.MinSliderValue = 0x55c // float (Size: 0x4)
SpinBox.MaxSliderValue = 0x560 // float (Size: 0x4)
TextBlock.Text = 0x150 // FText (Size: 0x18)
TextBlock.TextDelegate = 0x168 // FDelegate (Size: 0x10)
TextBlock.ColorAndOpacity = 0x178 // FSlateColor (Size: 0x28)
TextBlock.ColorAndOpacityDelegate = 0x1a0 // FDelegate (Size: 0x10)
TextBlock.Font = 0x1b0 // FSlateFontInfo (Size: 0x60)
TextBlock.StrikeBrush = 0x210 // FSlateBrush (Size: 0x90)
TextBlock.ShadowOffset = 0x2a0 // FVector2D (Size: 0x8)
TextBlock.ShadowColorAndOpacity = 0x2a8 // FLinearColor (Size: 0x10)
TextBlock.ShadowColorAndOpacityDelegate = 0x2b8 // FDelegate (Size: 0x10)
TextBlock.MinDesiredWidth = 0x2c8 // float (Size: 0x4)
TextBlock.bWrapWithInvalidationPanel = 0x2cc // bool (Size: 0x1)
TextBlock.bAutoWrapText = 0x2cd // bool (Size: 0x1)
TextBlock.TextTransformPolicy = 0x2ce // EETextTransformPolicy (Size: 0x1)
TextBlock.LocalizationFeature = 0x2cf // EELocalizationFeature (Size: 0x1)
TextBlock.LocalizationUpper = 0x2d0 // bool (Size: 0x1)
TextBlock.bShowDetail = 0x2d1 // bool (Size: 0x1)
TextBlock.bHandleLongText = 0x2d2 // bool (Size: 0x1)
TextBlock.MaxTextLength = 0x2d4 // int32_t (Size: 0x4)
TextBlock.bEnableAutoTruncate = 0x2d9 // bool (Size: 0x1)
TextBlock.bForceUpper = 0x2da // bool (Size: 0x1)
TextBlock.bSimpleTextMode = 0x2dc // bool (Size: 0x1)
TextLayoutWidget.ShapedTextOptions = 0x130 // FShapedTextOptions (Size: 0x3)
TextLayoutWidget.Justification = 0x133 // uint8_t (Size: 0x1)
TextLayoutWidget.WrappingPolicy = 0x134 // EETextWrappingPolicy (Size: 0x1)
TextLayoutWidget.AutoWrapText = 0x135 // uint8_t (Size: 0x1)
TextLayoutWidget.WrapTextAt = 0x138 // float (Size: 0x4)
TextLayoutWidget.Margin = 0x13c // FMargin (Size: 0x10)
TextLayoutWidget.LineHeightPercentage = 0x14c // float (Size: 0x4)
Throbber.NumberOfPieces = 0x130 // int32_t (Size: 0x4)
Throbber.bAnimateHorizontally = 0x134 // bool (Size: 0x1)
Throbber.bAnimateVertically = 0x135 // bool (Size: 0x1)
Throbber.bAnimateOpacity = 0x136 // bool (Size: 0x1)
Throbber.PieceImage = 0x138 // SlateBrushAsset* (Size: 0x8)
Throbber.Image = 0x140 // FSlateBrush (Size: 0x90)
TileView.EntryHeight = 0x900 // float (Size: 0x4)
TileView.EntryWidth = 0x904 // float (Size: 0x4)
TileView.TileAlignment = 0x908 // EEListItemAlignment (Size: 0x1)
TileView.Padding = 0x90c // FMargin (Size: 0x10)
TileView.bWrapHorizontalNavigation = 0x91c // bool (Size: 0x1)
TreeView.BP_OnGetItemChildren = 0x910 // FDelegate (Size: 0x10)
TreeView.BP_OnItemExpansionChanged = 0x920 // FMulticastInlineDelegate (Size: 0x10)
UMGSequencePlayer.Animation = 0x418 // WidgetAnimation* (Size: 0x8)
UMGSequencePlayer.RootTemplateInstance = 0x428 // FMovieSceneRootEvaluationTemplateInstance (Size: 0xe8)
UMGSequenceTickManager.WeakUserWidgets = 0x28 // TSet<...> (Size: 0x50)
UMGSequenceTickManager.Linker = 0x78 // MovieSceneEntitySystemLinker* (Size: 0x8)
UniformGridPanel.SlotPadding = 0x148 // FMargin (Size: 0x10)
UniformGridPanel.MinDesiredSlotWidth = 0x158 // float (Size: 0x4)
UniformGridPanel.MinDesiredSlotHeight = 0x15c // float (Size: 0x4)
UniformGridSlot.HorizontalAlignment = 0x60 // uint8_t (Size: 0x1)
UniformGridSlot.VerticalAlignment = 0x61 // uint8_t (Size: 0x1)
UniformGridSlot.Row = 0x64 // int32_t (Size: 0x4)
UniformGridSlot.Column = 0x68 // int32_t (Size: 0x4)
UserWidget.disableAnimForceLast = 0x138 // bool (Size: 0x1)
UserWidget.ColorAndOpacity = 0x13c // FLinearColor (Size: 0x10)
UserWidget.ColorAndOpacityDelegate = 0x14c // FDelegate (Size: 0x10)
UserWidget.ForegroundColor = 0x160 // FSlateColor (Size: 0x28)
UserWidget.ForegroundColorDelegate = 0x188 // FDelegate (Size: 0x10)
UserWidget.OnVisibilityChanged = 0x198 // FMulticastInlineDelegate (Size: 0x10)
UserWidget.Padding = 0x1c0 // FMargin (Size: 0x10)
UserWidget.ActiveSequencePlayers = 0x1d0 // TArray<UMGSequencePlayer*> (Size: 0x10)
UserWidget.AnimationTickManager = 0x1e0 // UMGSequenceTickManager* (Size: 0x8)
UserWidget.StoppedSequencePlayers = 0x1e8 // TArray<UMGSequencePlayer*> (Size: 0x10)
UserWidget.NamedSlotBindings = 0x1f8 // TArray<FNamedSlotBinding> (Size: 0x10)
UserWidget.WidgetTree = 0x208 // WidgetTree* (Size: 0x8)
UserWidget.Priority = 0x210 // int32_t (Size: 0x4)
UserWidget.bSupportsKeyboardFocus = 0x214 // uint8_t (Size: 0x1)
UserWidget.bIsFocusable = 0x214 // uint8_t (Size: 0x1)
UserWidget.bStopAction = 0x214 // uint8_t (Size: 0x1)
UserWidget.bHasScriptImplementedTick = 0x214 // uint8_t (Size: 0x1)
UserWidget.bHasScriptImplementedPaint = 0x214 // uint8_t (Size: 0x1)
UserWidget.bLazyLoad = 0x214 // uint8_t (Size: 0x1)
UserWidget.TickFrequency = 0x220 // EEWidgetTickFrequency (Size: 0x1)
UserWidget.BlueprintTickEnable = 0x221 // bool (Size: 0x1)
UserWidget.InputComponent = 0x228 // InputComponent* (Size: 0x8)
UserWidget.AnimationCallbacks = 0x230 // TArray<FAnimationEventBinding> (Size: 0x10)
UserWidgetPool.ActiveWidgets = 0x0 // TArray<UserWidget*> (Size: 0x10)
UserWidgetPool.InactiveWidgets = 0x10 // TArray<UserWidget*> (Size: 0x10)
VerticalBoxSlot.Size = 0x60 // FSlateChildSize (Size: 0x8)
VerticalBoxSlot.Padding = 0x68 // FMargin (Size: 0x10)
VerticalBoxSlot.HorizontalAlignment = 0x80 // uint8_t (Size: 0x1)
VerticalBoxSlot.VerticalAlignment = 0x81 // uint8_t (Size: 0x1)
Viewport.BackgroundColor = 0x148 // FLinearColor (Size: 0x10)
VisibilityWidgetSwitcher.ActiveWidgetIndex = 0x158 // int32_t (Size: 0x4)
Widget.Slot = 0x28 // PanelSlot* (Size: 0x8)
Widget.bIsEnabledDelegate = 0x30 // FDelegate (Size: 0x10)
Widget.ToolTipText = 0x40 // FText (Size: 0x18)
Widget.ToolTipTextDelegate = 0x58 // FDelegate (Size: 0x10)
Widget.ToolTipWidget = 0x68 // Widget* (Size: 0x8)
Widget.ToolTipWidgetDelegate = 0x70 // FDelegate (Size: 0x10)
Widget.MaskGeometryType = 0x80 // EEMaskGeometryType (Size: 0x1)
Widget.MaskGeometryMargin = 0x84 // FVector2D (Size: 0x8)
Widget.VisibilityDelegate = 0x8c // FDelegate (Size: 0x10)
Widget.RenderTransform = 0x9c // FWidgetTransform (Size: 0x24)
Widget.RenderTransformPivot = 0xc0 // FVector2D (Size: 0x8)
Widget.bIsVariable = 0xc8 // uint8_t (Size: 0x1)
Widget.bCreatedByConstructionScript = 0xc8 // uint8_t (Size: 0x1)
Widget.bIsEnabled = 0xc8 // uint8_t (Size: 0x1)
Widget.bOverride_Cursor = 0xc8 // uint8_t (Size: 0x1)
Widget.AccessibleWidgetData = 0xd0 // SlateAccessibleWidgetData* (Size: 0x8)
Widget.bIsVolatile = 0xd8 // uint8_t (Size: 0x1)
Widget.Cursor = 0xda // uint8_t (Size: 0x1)
Widget.Clipping = 0xdb // EEWidgetClipping (Size: 0x1)
Widget.Visibility = 0xdc // EESlateVisibility (Size: 0x1)
Widget.RenderOpacity = 0xe0 // float (Size: 0x4)
Widget.Navigation = 0xe8 // WidgetNavigation* (Size: 0x8)
Widget.FlowDirectionPreference = 0xf0 // EEFlowDirectionPreference (Size: 0x1)
Widget.NativeBindings = 0x118 // TArray<PropertyBinding*> (Size: 0x10)
Widget.PaintOffsetFlag = 0x128 // int32_t (Size: 0x4)
WidgetAnimation.MovieScene = 0x60 // MovieScene* (Size: 0x8)
WidgetAnimation.AnimationBindings = 0x68 // TArray<FWidgetAnimationBinding> (Size: 0x10)
WidgetAnimation.bLegacyFinishOnStop = 0x78 // bool (Size: 0x1)
WidgetAnimation.DisplayLabel = 0x80 // FString (Size: 0x10)
WidgetAnimationBinding.WidgetName = 0x0 // FName (Size: 0x8)
WidgetAnimationBinding.SlotWidgetName = 0x8 // FName (Size: 0x8)
WidgetAnimationBinding.AnimationGuid = 0x10 // FGuid (Size: 0x10)
WidgetAnimationBinding.bIsRootWidget = 0x20 // bool (Size: 0x1)
WidgetAnimationDelegateBinding.WidgetAnimationDelegateBindings = 0x28 // TArray<FBlueprintWidgetAnimationDelegateBinding> (Size: 0x10)
WidgetAnimationPlayCallbackProxy.Finished = 0x28 // FMulticastInlineDelegate (Size: 0x10)
WidgetBlueprintGeneratedClass.WidgetTree = 0x328 // WidgetTree* (Size: 0x8)
WidgetBlueprintGeneratedClass.bClassRequiresNativeTick = 0x330 // uint8_t (Size: 0x1)
WidgetBlueprintGeneratedClass.Bindings = 0x338 // TArray<FDelegateRuntimeBinding> (Size: 0x10)
WidgetBlueprintGeneratedClass.animations = 0x348 // TArray<WidgetAnimation*> (Size: 0x10)
WidgetBlueprintGeneratedClass.NamedSlots = 0x358 // TArray<FName> (Size: 0x10)
WidgetComponent.Space = 0x600 // EEWidgetSpace (Size: 0x1)
WidgetComponent.TimingPolicy = 0x601 // EEWidgetTimingPolicy (Size: 0x1)
WidgetComponent.WidgetClass = 0x608 // ClassProperty (Size: 0x8)
WidgetComponent.DrawSize = 0x610 // FIntPoint (Size: 0x8)
WidgetComponent.bManuallyRedraw = 0x618 // bool (Size: 0x1)
WidgetComponent.bRedrawRequested = 0x619 // bool (Size: 0x1)
WidgetComponent.RedrawTime = 0x61c // float (Size: 0x4)
WidgetComponent.CurrentDrawSize = 0x628 // FIntPoint (Size: 0x8)
WidgetComponent.bDrawAtDesiredSize = 0x630 // bool (Size: 0x1)
WidgetComponent.Pivot = 0x634 // FVector2D (Size: 0x8)
WidgetComponent.bReceiveHardwareInput = 0x63c // bool (Size: 0x1)
WidgetComponent.bWindowFocusable = 0x63d // bool (Size: 0x1)
WidgetComponent.WindowVisibility = 0x63e // EEWindowVisibility (Size: 0x1)
WidgetComponent.bApplyGammaCorrection = 0x63f // bool (Size: 0x1)
WidgetComponent.OwnerPlayer = 0x640 // LocalPlayer* (Size: 0x8)
WidgetComponent.BackgroundColor = 0x648 // FLinearColor (Size: 0x10)
WidgetComponent.TintColorAndOpacity = 0x658 // FLinearColor (Size: 0x10)
WidgetComponent.OpacityFromTexture = 0x668 // float (Size: 0x4)
WidgetComponent.BlendMode = 0x66c // EEWidgetBlendMode (Size: 0x1)
WidgetComponent.bIsTwoSided = 0x66d // bool (Size: 0x1)
WidgetComponent.TickWhenOffscreen = 0x66e // bool (Size: 0x1)
WidgetComponent.BodySetup = 0x670 // BodySetup* (Size: 0x8)
WidgetComponent.TranslucentMaterial = 0x678 // MaterialInterface* (Size: 0x8)
WidgetComponent.TranslucentMaterial_OneSided = 0x680 // MaterialInterface* (Size: 0x8)
WidgetComponent.OpaqueMaterial = 0x688 // MaterialInterface* (Size: 0x8)
WidgetComponent.OpaqueMaterial_OneSided = 0x690 // MaterialInterface* (Size: 0x8)
WidgetComponent.MaskedMaterial = 0x698 // MaterialInterface* (Size: 0x8)
WidgetComponent.MaskedMaterial_OneSided = 0x6a0 // MaterialInterface* (Size: 0x8)
WidgetComponent.RenderTarget = 0x6a8 // TextureRenderTarget2D* (Size: 0x8)
WidgetComponent.MaterialInstance = 0x6b0 // MaterialInstanceDynamic* (Size: 0x8)
WidgetComponent.bAddedToScreen = 0x6b8 // bool (Size: 0x1)
WidgetComponent.bEditTimeUsable = 0x6b9 // bool (Size: 0x1)
WidgetComponent.SharedLayerName = 0x6bc // FName (Size: 0x8)
WidgetComponent.LayerZOrder = 0x6c4 // int32_t (Size: 0x4)
WidgetComponent.GeometryMode = 0x6c8 // EEWidgetGeometryMode (Size: 0x1)
WidgetComponent.CylinderArcAngle = 0x6cc // float (Size: 0x4)
WidgetComponent.TickMode = 0x6d0 // EETickMode (Size: 0x1)
WidgetComponent.Widget = 0x6f8 // UserWidget* (Size: 0x8)
WidgetInteractionComponent.OnHoveredWidgetChanged = 0x238 // FMulticastInlineDelegate (Size: 0x10)
WidgetInteractionComponent.VirtualUserIndex = 0x258 // int32_t (Size: 0x4)
WidgetInteractionComponent.PointerIndex = 0x25c // int32_t (Size: 0x4)
WidgetInteractionComponent.TraceChannel = 0x260 // uint8_t (Size: 0x1)
WidgetInteractionComponent.InteractionDistance = 0x264 // float (Size: 0x4)
WidgetInteractionComponent.InteractionSource = 0x268 // EEWidgetInteractionSource (Size: 0x1)
WidgetInteractionComponent.bEnableHitTesting = 0x269 // bool (Size: 0x1)
WidgetInteractionComponent.bShowDebug = 0x26a // bool (Size: 0x1)
WidgetInteractionComponent.DebugSphereLineThickness = 0x26c // float (Size: 0x4)
WidgetInteractionComponent.DebugLineThickness = 0x270 // float (Size: 0x4)
WidgetInteractionComponent.DebugColor = 0x274 // FLinearColor (Size: 0x10)
WidgetInteractionComponent.CustomHitResult = 0x300 // FHitResult (Size: 0x98)
WidgetInteractionComponent.LocalHitLocation = 0x398 // FVector2D (Size: 0x8)
WidgetInteractionComponent.LastLocalHitLocation = 0x3a0 // FVector2D (Size: 0x8)
WidgetInteractionComponent.HoveredWidgetComponent = 0x3a8 // WidgetComponent* (Size: 0x8)
WidgetInteractionComponent.LastHitResult = 0x3b0 // FHitResult (Size: 0x98)
WidgetInteractionComponent.bIsHoveredWidgetInteractable = 0x448 // bool (Size: 0x1)
WidgetInteractionComponent.bIsHoveredWidgetFocusable = 0x449 // bool (Size: 0x1)
WidgetInteractionComponent.bIsHoveredWidgetHitTestVisible = 0x44a // bool (Size: 0x1)
WidgetNavigation.Up = 0x28 // FWidgetNavigationData (Size: 0x24)
WidgetNavigation.Down = 0x4c // FWidgetNavigationData (Size: 0x24)
WidgetNavigation.Left = 0x70 // FWidgetNavigationData (Size: 0x24)
WidgetNavigation.Right = 0x94 // FWidgetNavigationData (Size: 0x24)
WidgetNavigation.Next = 0xb8 // FWidgetNavigationData (Size: 0x24)
WidgetNavigation.Previous = 0xdc // FWidgetNavigationData (Size: 0x24)
WidgetNavigationData.Rule = 0x0 // EEUINavigationRule (Size: 0x1)
WidgetNavigationData.WidgetToFocus = 0x4 // FName (Size: 0x8)
WidgetNavigationData.Widget = 0xc // TWeakObjectPtr<UObject> (Size: 0x8)
WidgetNavigationData.CustomDelegate = 0x14 // FDelegate (Size: 0x10)
WidgetSwitcher.ActiveWidgetIndex = 0x148 // int32_t (Size: 0x4)
WidgetSwitcherSlot.Padding = 0x68 // FMargin (Size: 0x10)
WidgetSwitcherSlot.HorizontalAlignment = 0x78 // uint8_t (Size: 0x1)
WidgetSwitcherSlot.VerticalAlignment = 0x79 // uint8_t (Size: 0x1)
WidgetToRenderTargetComponent.WidgetClass = 0xf8 // ClassProperty (Size: 0x8)
WidgetToRenderTargetComponent.RenderTarget = 0x100 // TextureRenderTarget2D* (Size: 0x8)
WidgetToRenderTargetComponent.bApplyGammaCorrection = 0x108 // bool (Size: 0x1)
WidgetToRenderTargetComponent.DrawScale = 0x10c // float (Size: 0x4)
WidgetToRenderTargetComponent.Widget = 0x118 // UserWidget* (Size: 0x8)
WidgetTransform.Translation = 0x0 // FVector2D (Size: 0x8)
WidgetTransform.Scale = 0x8 // FVector2D (Size: 0x8)
WidgetTransform.Scale_Oversea = 0x10 // FVector2D (Size: 0x8)
WidgetTransform.Shear = 0x18 // FVector2D (Size: 0x8)
WidgetTransform.Angle = 0x20 // float (Size: 0x4)
WidgetTree.RootWidget = 0x28 // Widget* (Size: 0x8)
WidgetTree.LazyLoadBindings = 0x30 // TArray<FLazyLoadBinding> (Size: 0x10)
WindowTitleBarArea.bWindowButtonsEnabled = 0x148 // bool (Size: 0x1)
WindowTitleBarArea.bDoubleClickTogglesFullscreen = 0x149 // bool (Size: 0x1)
WindowTitleBarAreaSlot.Padding = 0x60 // FMargin (Size: 0x10)
WindowTitleBarAreaSlot.HorizontalAlignment = 0x70 // uint8_t (Size: 0x1)
WindowTitleBarAreaSlot.VerticalAlignment = 0x71 // uint8_t (Size: 0x1)
WrapBox.InnerSlotPadding = 0x148 // FVector2D (Size: 0x8)
WrapBox.WrapWidth = 0x150 // float (Size: 0x4)
WrapBox.WrapSize = 0x154 // float (Size: 0x4)
WrapBox.bExplicitWrapWidth = 0x158 // bool (Size: 0x1)
WrapBox.bExplicitWrapSize = 0x159 // bool (Size: 0x1)
WrapBox.Orientation = 0x15a // uint8_t (Size: 0x1)
WrapBoxSlot.Padding = 0x60 // FMargin (Size: 0x10)
WrapBoxSlot.bFillEmptySpace = 0x70 // bool (Size: 0x1)
WrapBoxSlot.FillSpanWhenLessThan = 0x74 // float (Size: 0x4)
WrapBoxSlot.HorizontalAlignment = 0x78 // uint8_t (Size: 0x1)
WrapBoxSlot.VerticalAlignment = 0x79 // uint8_t (Size: 0x1)
GradientScrollBox.bRetainRender = 0x920 // bool (Size: 0x1)
GradientScrollBox.RenderOnInvalidation = 0x921 // bool (Size: 0x1)
GradientScrollBox.RenderOnPhase = 0x922 // bool (Size: 0x1)
GradientScrollBox.Phase = 0x924 // int32_t (Size: 0x4)
GradientScrollBox.PhaseCount = 0x928 // int32_t (Size: 0x4)
GradientScrollBox.EffectMaterial = 0x930 // MaterialInterface* (Size: 0x8)
GradientScrollBox.TextureParameter = 0x938 // FName (Size: 0x8)
GradientScrollBox.DownFadeRange = 0x940 // float (Size: 0x4)
GradientScrollBox.DownFadeIntensity = 0x944 // float (Size: 0x4)
GradientScrollBox.UpFadeRange = 0x948 // float (Size: 0x4)
GradientScrollBox.UpFadeIntensity = 0x94c // float (Size: 0x4)
GradientScrollBox.DefaultGradientMaterialDynamic = 0x960 // MaterialInstanceDynamic* (Size: 0x8)
UdpMessagingSettings.EnabledByDefault = 0x28 // bool (Size: 0x1)
UdpMessagingSettings.EnableTransport = 0x29 // bool (Size: 0x1)
UdpMessagingSettings.bAutoRepair = 0x2a // bool (Size: 0x1)
UdpMessagingSettings.bStopServiceWhenAppDeactivates = 0x2b // bool (Size: 0x1)
UdpMessagingSettings.UnicastEndpoint = 0x30 // FString (Size: 0x10)
UdpMessagingSettings.MulticastEndpoint = 0x40 // FString (Size: 0x10)
UdpMessagingSettings.MessageFormat = 0x50 // EEUdpMessageFormat (Size: 0x1)
UdpMessagingSettings.MulticastTimeToLive = 0x51 // uint8_t (Size: 0x1)
UdpMessagingSettings.StaticEndpoints = 0x58 // TArray<FString> (Size: 0x10)
UdpMessagingSettings.EnableTunnel = 0x68 // bool (Size: 0x1)
UdpMessagingSettings.TunnelUnicastEndpoint = 0x70 // FString (Size: 0x10)
UdpMessagingSettings.TunnelMulticastEndpoint = 0x80 // FString (Size: 0x10)
UdpMessagingSettings.RemoteTunnelEndpoints = 0x90 // TArray<FString> (Size: 0x10)
UdpMockMessage.Data = 0x0 // TArray<uint8_t> (Size: 0x10)
PropertyCollector.None = 0x0 // FString (Size: 0x10)
UnLuaLatentAction.Callback = 0x30 // FDelegate (Size: 0x10)
UnLuaLatentAction.bTickEvenWhenPaused = 0x40 // uint8_t (Size: 0x1)
UnLuaManager.ModuleNames = 0x30 // TMap<...> (Size: 0x50)
UnLuaManager.Classes = 0x80 // TMap<...> (Size: 0x50)
UnLuaManager.Derived2BaseClasses = 0x300 // TMap<...> (Size: 0x50)
UnLuaManager.AttachedActors = 0x450 // TSet<...> (Size: 0x50)
UnLuaManager.InputActionFunc = 0x4a0 // Function* (Size: 0x8)
UnLuaManager.InputAxisFunc = 0x4a8 // Function* (Size: 0x8)
UnLuaManager.InputTouchFunc = 0x4b0 // Function* (Size: 0x8)
UnLuaManager.InputVectorAxisFunc = 0x4b8 // Function* (Size: 0x8)
UnLuaManager.InputGestureFunc = 0x4c0 // Function* (Size: 0x8)
UnLuaManager.AnimNotifyFunc = 0x4c8 // Function* (Size: 0x8)
UnLuaPerformanceTestProxy.MeshID = 0x318 // int32_t (Size: 0x4)
UnLuaPerformanceTestProxy.MeshName = 0x320 // FString (Size: 0x10)
UnLuaPerformanceTestProxy.COM = 0x330 // FVector (Size: 0xc)
UnLuaPerformanceTestProxy.Indices = 0x340 // TArray<int32_t> (Size: 0x10)
UnLuaPerformanceTestProxy.Positions = 0x350 // TArray<FVector> (Size: 0x10)
UnLuaPerformanceTestProxy.PredictedPositions = 0x360 // TArray<FVector> (Size: 0x10)
CapturedPropSegment.PropertyName = 0x0 // FString (Size: 0x10)
CapturedPropSegment.PropertyIndex = 0x10 // int32_t (Size: 0x4)
CapturedPropSegment.ComponentName = 0x18 // FString (Size: 0x10)
FunctionCaller.FunctionName = 0x0 // FName (Size: 0x8)
LevelVariantSets.DirectorClass = 0x28 // ClassProperty (Size: 0x8)
LevelVariantSets.VariantSets = 0x30 // TArray<VariantSet*> (Size: 0x10)
LevelVariantSetsActor.LevelVariantSets = 0x310 // FSoftObjectPath (Size: 0x18)
PropertyValue.Properties = 0x88 // TArray<FieldPathProperty> (Size: 0x10)
PropertyValue.PropertyIndices = 0x98 // TArray<int32_t> (Size: 0x10)
PropertyValue.CapturedPropSegments = 0xa8 // TArray<FCapturedPropSegment> (Size: 0x10)
PropertyValue.FullDisplayString = 0xb8 // FString (Size: 0x10)
PropertyValue.PropertySetterName = 0xc8 // FName (Size: 0x8)
PropertyValue.PropertySetterParameterDefaults = 0xd0 // TMap<...> (Size: 0x50)
PropertyValue.bHasRecordedData = 0x120 // bool (Size: 0x1)
PropertyValue.LeafPropertyClass = 0x128 // ClassProperty (Size: 0x8)
PropertyValue.ValueBytes = 0x138 // TArray<uint8_t> (Size: 0x10)
PropertyValue.PropCategory = 0x148 // EEPropertyValueCategory (Size: 0x1)
SwitchActor.SceneComponent = 0x328 // SceneComponent* (Size: 0x8)
SwitchActor.LastSelectedOption = 0x330 // int32_t (Size: 0x4)
Variant.Dependencies = 0x28 // TArray<FVariantDependency> (Size: 0x10)
Variant.DisplayText = 0x38 // FText (Size: 0x18)
Variant.ObjectBindings = 0x68 // TArray<VariantObjectBinding*> (Size: 0x10)
Variant.Thumbnail = 0x78 // Texture2D* (Size: 0x8)
VariantDependency.VariantSet = 0x0 // TSoftObjectPtr<UObject> (Size: 0x28)
VariantDependency.Variant = 0x28 // TSoftObjectPtr<UObject> (Size: 0x28)
VariantDependency.bEnabled = 0x50 // bool (Size: 0x1)
VariantObjectBinding.CachedActorLabel = 0x28 // FString (Size: 0x10)
VariantObjectBinding.ObjectPtr = 0x38 // FSoftObjectPath (Size: 0x18)
VariantObjectBinding.LazyObjectPtr = 0x50 // TLazyObjectPtr<UObject> (Size: 0x1c)
VariantObjectBinding.CapturedProperties = 0x70 // TArray<PropertyValue*> (Size: 0x10)
VariantObjectBinding.FunctionCallers = 0x80 // TArray<FFunctionCaller> (Size: 0x10)
VariantSet.DisplayText = 0x28 // FText (Size: 0x18)
VariantSet.bExpanded = 0x58 // bool (Size: 0x1)
VariantSet.Variants = 0x60 // TArray<Variant*> (Size: 0x10)
VariantSet.Thumbnail = 0x70 // Texture2D* (Size: 0x8)
WebSocketNetDriver.WebSocketPort = 0x7e8 // int32_t (Size: 0x4)
SystemLocalizationMsgTableRow.MsgID = 0x8 // uint32_t (Size: 0x4)
SystemLocalizationMsgTableRow.culture = 0x10 // FString (Size: 0x10)
SystemLocalizationMsgTableRow.MsgText = 0x20 // FText (Size: 0x18)
WmfMediaSettings.AllowNonStandardCodecs = 0x28 // bool (Size: 0x1)
WmfMediaSettings.LowLatency = 0x29 // bool (Size: 0x1)
WmfMediaSettings.NativeAudioOut = 0x2a // bool (Size: 0x1)
WmfMediaSettings.HardwareAcceleratedVideoDecoding = 0x2b // bool (Size: 0x1)
